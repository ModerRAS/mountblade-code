// Decompiled with JetBrains decompiler
// Type: StoryMode.Quests.SecondPhase.ConspiracyQuestBase
// Assembly: StoryMode, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 11BAE65F-6C15-4628-A9C6-1B968588CDA1
// Assembly location: D:\steam\steamapps\common\Mount & Blade II Bannerlord\Modules\StoryMode\bin\Win64_Shipping_Client\StoryMode.dll

using StoryMode.StoryModeObjects;
using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.CampaignSystem;
using TaleWorlds.CampaignSystem.Party;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.Localization;

#nullable disable
namespace StoryMode.Quests.SecondPhase
{
  public abstract class ConspiracyQuestBase : QuestBase
  {
    public abstract TextObject SideNotificationText { get; }

    public abstract TextObject StartMessageLogFromMentor { get; }

    public abstract TextObject StartLog { get; }

    public abstract float ConspiracyStrengthDecreaseAmount { get; }

    public Hero Mentor
    {
      get
      {
        return !StoryModeManager.Current.MainStoryLine.IsOnImperialQuestLine ? StoryModeHeroes.AntiImperialMentor : StoryModeHeroes.ImperialMentor;
      }
    }

    public override bool IsRemainingTimeHidden => false;

    public override bool IsSpecialQuest => true;

    protected ConspiracyQuestBase(string questId, Hero questGiver)
      : base(questId, questGiver, CampaignTime.WeeksFromNow(3f), 0)
    {
      this.ChangeQuestDueTime(CampaignTime.WeeksFromNow(3f));
    }

    protected override void RegisterEvents()
    {
      StoryModeEvents.OnConspiracyActivatedEvent.AddNonSerializedListener((object) this, new Action(this.OnConspiracyActivated));
    }

    private void OnConspiracyActivated() => this.CompleteQuestWithFail();

    protected override void OnStartQuest()
    {
      base.OnStartQuest();
      Campaign.Current.CampaignInformationManager.NewMapNoticeAdded((InformationData) new ConspiracyQuestMapNotification((QuestBase) this, this.SideNotificationText));
      this.AddLog(this.StartMessageLogFromMentor);
      this.AddLog(this.StartLog);
    }

    protected override void OnCompleteWithSuccess()
    {
      base.OnCompleteWithSuccess();
      StoryModeManager.Current.MainStoryLine.SecondPhase.DecreaseConspiracyStrength(this.ConspiracyStrengthDecreaseAmount);
    }

    protected void DistributeConspiracyRaiderTroopsByLevel(
      PartyTemplateObject raiderTemplate,
      PartyBase partyToFill,
      int troopCountLimit)
    {
      List<KeyValuePair<int, List<CharacterObject>>> source = new List<KeyValuePair<int, List<CharacterObject>>>();
      foreach (PartyTemplateStack partyTemplateStack in (IEnumerable<PartyTemplateStack>) raiderTemplate.Stacks.OrderBy<PartyTemplateStack, int>((Func<PartyTemplateStack, int>) (t => t.Character.Level)))
      {
        int key = partyTemplateStack.Character.Level;
        if (!source.Exists((Predicate<KeyValuePair<int, List<CharacterObject>>>) (t => t.Key == key)))
          source.Add(new KeyValuePair<int, List<CharacterObject>>(key, new List<CharacterObject>()));
        CharacterObject character = partyTemplateStack.Character;
        KeyValuePair<int, List<CharacterObject>> keyValuePair = source.Find((Predicate<KeyValuePair<int, List<CharacterObject>>>) (t => t.Key == key));
        if (keyValuePair.Value != null && !keyValuePair.Value.Contains(character))
          keyValuePair.Value.Add(character);
      }
      int num = source.Sum<KeyValuePair<int, List<CharacterObject>>>((Func<KeyValuePair<int, List<CharacterObject>>, int>) (t => t.Key));
      List<KeyValuePair<int, int>> keyValuePairList = new List<KeyValuePair<int, int>>();
      foreach (KeyValuePair<int, List<CharacterObject>> keyValuePair in source)
        keyValuePairList.Add(new KeyValuePair<int, int>(keyValuePair.Key, MathF.Floor((float) keyValuePair.Key / (float) num * (float) troopCountLimit)));
      foreach (PartyTemplateStack stack in (List<PartyTemplateStack>) raiderTemplate.Stacks)
      {
        int level = stack.Character.Level;
        int index1 = keyValuePairList.FindIndex((Predicate<KeyValuePair<int, int>>) (t => t.Key == level));
        int index2 = keyValuePairList.Count - 1 - index1;
        int count = MathF.Floor((float) keyValuePairList[index2].Value / (float) source[index1].Value.Count);
        partyToFill.MemberRoster.AddToCounts(stack.Character, count);
      }
      if (partyToFill.MemberRoster.TotalManCount >= troopCountLimit)
        return;
      partyToFill.MemberRoster.AddToCounts(source[0].Value[0], troopCountLimit - partyToFill.MemberRoster.TotalManCount);
    }

    protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
    {
      base.AutoGeneratedInstanceCollectObjects(collectedObjects);
    }
  }
}
