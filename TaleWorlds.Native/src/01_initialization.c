#include "TaleWorlds.Native.Split.h"

#define SYSTEM_EVENT_HANDLER_PRIMARY_ADDRESS    0x180c91700
#define SYSTEM_EVENT_HANDLER_SECONDARY_ADDRESS  0x180c91800
#define SYSTEM_FLOAT_TABLE_START_ADDRESS       0x180c8aa70
#define SYSTEM_FLOAT_TABLE_END_ADDRESS         0x180c8ea71
#define SYSTEM_FLOAT_TABLE_SECOND_START_ADDRESS 0x180c8eb70
#define SYSTEM_SECURITY_CONTEXT_ADDRESS        0x180d49d50
#define SYSTEM_MUTEX_PRIMARY_ADDRESS           0x180c96690
#define SYSTEM_MUTEX_SECONDARY_ADDRESS         0x180c966f0
#define SYSTEM_MUTEX_TERTIARY_ADDRESS          0x180c96740
#define SYSTEM_MEMORY_MANAGER_ADDRESS          0x180c0c340
#define SYSTEM_VTABLE_POINTER_ADDRESS          0x180c35590
#define SYSTEM_DATABASE_ADDRESS                0x180c4f510
#define SYSTEM_MUTEX_QUATERNARY_ADDRESS        0x180c82170
#define SYSTEM_CONTROLLER_ADDRESS               0x180c91060
#define SYSTEM_MUTEX_UNLOCK_ADDRESS            0x180c91970
#define SYSTEM_MUTEX_LOCK_ADDRESS              0x180c91288
#define SYSTEM_RESOURCE_STRING_ADDRESS         0x180d48d24
#define SYSTEM_STRING_OFFSET_ADDRESS           0x180c84871
#define SYSTEM_MUTEX_SECURITY_ADDRESS          0x180c91910
#define SYSTEM_DATA_CHECK_ADDRESS             0x180d49150

/**
 * @brief 处理系统内存页面
 * 
 * 该函数负责处理系统内存页面，包括页面分配、映射和管理
 * 用于系统内存管理的基础操作
 * 
 * @param MemoryAddress 内存地址，指定要处理的内存页面位置
 * @return 无返回值
 * 
 * 原始函数名为ProcessSystemMemoryPage，现已重命名为ProcessSystemMemoryPage
 */
void ProcessSystemMemoryPage(long long MemoryAddress);

/**
 * @brief 释放系统资源
 * 
 * 该函数负责释放系统资源，包括内存、句柄和对象
 * 用于系统资源的清理和回收
 * 
 * @return 无返回值
 * 
 * 原始函数名为ReleaseSystemResource，现已重命名为ReleaseSystemResource
 */
void ReleaseSystemResource(void);

/**
 * @brief 初始化系统内存缓冲区
 * 
 * 该函数负责初始化系统内存缓冲区，设置缓冲区参数和属性
 * 用于系统内存缓冲区的配置和准备工作
 * 
 * @param MemoryTemplate 内存模板，用于初始化缓冲区的模板数据
 * @param BufferSize 缓冲区大小，指定缓冲区的大小
 * @param SourceData 源数据，用于初始化缓冲区的数据源
 * @return 无返回值
 * 
 * 原始函数名为InitializeSystemMemoryBuffer，现已重命名为InitializeSystemMemoryBuffer
 */
void InitializeSystemMemoryBuffer(void* MemoryTemplate, long long BufferSize, void* SourceData);

/**
 * @brief 写入数据到缓冲区
 * 
 * 该函数负责将数据写入到指定的缓冲区中，支持可变参数
 * 用于系统数据的写入和存储操作
 * 
 * @param Buffer 缓冲区指针，指定要写入数据的缓冲区
 * @param DataSize 数据大小，指定要写入的数据大小
 * @param ... 可变参数，表示要写入的数据
 * @return 无返回值
 * 
 * 原始函数名为WriteDataToBuffer，现已重命名为WriteDataToBuffer
 */
void WriteDataToBuffer(void* Buffer, long long DataSize, ...);

/**
 * @brief 初始化系统内存分配器
 * 
 * 该函数负责初始化系统内存分配器，设置分配策略和参数
 * 用于系统内存分配的配置和准备工作
 * 
 * @param memoryHandle 内存句柄，指定要初始化的内存分配器句柄
 * @param bufferContext 缓冲区上下文，包含缓冲区的相关信息
 * @return 分配器指针，返回初始化后的内存分配器指针
 * 
 * 原始函数名为InitializeSystemMemoryAllocator，现已重命名为InitializeSystemMemoryAllocator
 */
void* InitializeSystemMemoryAllocator(long long memoryHandle, void* bufferContext);

/**
 * @brief 初始化系统数据
 * 
 * 该函数负责初始化系统数据，设置数据结构和属性
 * 用于系统数据的配置和准备工作
 * 
 * @param dataContext 数据上下文，包含要初始化的数据相关信息
 * @param templateContext 模板上下文，包含数据模板的相关信息
 * @return 无返回值
 * 
 * 原始函数名为InitializeSystemData，现已重命名为InitializeSystemData
 */
void InitializeSystemData(void* dataContext, void* templateContext);

/**
 * @brief 验证系统配置
 * 
 * 该函数负责验证系统配置的有效性和完整性
 * 用于系统配置的安全检查和验证
 * 
 * @param configFlags 配置标志，指定要验证的配置项
 * @param configContext 配置上下文，包含配置的相关信息
 * @return 验证结果，返回0表示成功，非0表示失败
 * 
 * 原始函数名为ValidateSystemConfiguration，现已重命名为ValidateSystemConfiguration
 */
int ValidateSystemConfiguration(long long configFlags, void* configContext);

/**
 * @brief 获取系统状态标志
 * 
 * 该函数负责获取系统的状态标志，用于监控系统运行状态
 * 用于系统状态的管理和监控
 * 
 * @return 系统状态标志，返回当前系统的状态标志位
 * 
 * 原始函数名为GetSystemStatusFlags，现已重命名为GetSystemStatusFlags
 */
long long GetSystemStatusFlags(void);

/**
 * @brief 配置系统数据
 * 
 * 该函数负责配置系统数据，设置数据参数和属性
 * 用于系统数据的配置和管理
 * 
 * @param bufferAddress 缓冲区地址，指定要配置的数据缓冲区
 * @param configData 配置数据，包含配置的相关信息
 * @param contextPointer 上下文指针，包含上下文相关信息
 * @param parameterArray 参数数组，包含配置参数的相关信息
 * @return 无返回值
 * 
 * 原始函数名为ConfigureSystemData，现已重命名为ConfigureSystemData
 */
void ConfigureSystemData(void* bufferAddress, void* configData, void* contextPointer, void* parameterArray);

/**
 * @brief 释放系统资源
 * 
 * 该函数负责释放系统资源，包括内存、句柄和对象
 * 用于系统资源的清理和回收
 * 
 * @param resourcePointer 资源指针，指定要释放的系统资源
 * @return 无返回值
 * 
 * 原始函数名为ReleaseSystemResources，现已重命名为ReleaseSystemResources
 */
void ReleaseSystemResources(void* resourcePointer);

/**
 * @brief 初始化系统缓冲区
 * 
 * 该函数负责初始化系统缓冲区，设置缓冲区参数和属性
 * 用于系统缓冲区的配置和准备工作
 * 
 * @param bufferAddress 缓冲区地址，指定要初始化的缓冲区
 * @param initFlag 初始化标志，指定初始化的方式和选项
 * @param parameter 参数，包含初始化所需的参数信息
 * @return 无返回值
 * 
 * 原始函数名为InitializeSystemBuffer，现已重命名为InitializeSystemBuffer
 */
void InitializeSystemBuffer(void* bufferAddress, int initFlag, int parameter);

/**
 * @brief 更新系统数据
 * 
 * 该函数负责更新系统数据，刷新数据内容和状态
 * 用于系统数据的维护和更新
 * 
 * @param dataPointer 数据指针，指定要更新的系统数据
 * @return 无返回值
 * 
 * 原始函数名为UpdateSystemData，现已重命名为UpdateSystemData
 */
void UpdateSystemData(void* dataPointer);

/**
 * @brief 系统内存分配验证函数
 * 
 * 该函数负责验证系统内存分配的有效性和完整性
 * 用于系统内存管理的安全检查和验证
 * 
 * @param memoryContext 内存上下文指针
 * @return 验证结果状态码
 * 
 * 原始函数名为FUN_180624a00，现已重命名为ValidateSystemMemoryAllocation
 */
char ValidateSystemMemoryAllocation(void* memoryContext);

/**
 * @brief 系统内存资源分配函数
 * 
 * 该函数负责分配系统内存资源，设置内存池和分配策略
 * 用于系统内存管理的前期准备工作
 * 
 * @param memoryContext 内存上下文指针
 * @param allocationBuffer 分配缓冲区指针
 * 
 * 原始函数名为FUN_18062c5f0，现已重命名为AllocateSystemMemoryResources
 */
void AllocateSystemMemoryResources(void* memoryContext, void* allocationBuffer);

/**
 * @brief 系统数据缓冲区配置函数
 * 
 * 该函数负责配置系统数据缓冲区，设置缓冲区参数和属性
 * 用于系统数据缓冲区的配置和管理
 * 
 * @param bufferContext 缓冲区上下文指针
 * @param configTemplate 配置模板指针
 * @param dataSource 数据源指针
 * 
 * 原始函数名为FUN_180628040，现已重命名为ConfigureSystemDataBuffer
 */
void ConfigureSystemDataBuffer(void* bufferContext, void* configTemplate, void* dataSource);

/**
 * @brief 系统内存分配释放函数
 * 
 * 该函数负责释放系统内存分配，清理内存和句柄
 * 用于系统内存资源的清理和释放
 * 
 * @param memoryContext 内存上下文指针
 * 
 * 原始函数名为FUN_180624910，现已重命名为ReleaseSystemMemoryAllocation
 */
void ReleaseSystemMemoryAllocation(void* memoryContext);

/**
 * @brief 系统内存状态检查函数
 * 
 * 该函数负责检查系统内存状态，监控内存使用情况
 * 用于系统内存状态的管理和监控
 * 
 * @param memoryContext 内存上下文指针
 * @return 检查结果状态码
 * 
 * 原始函数名为FUN_180624af0，现已重命名为CheckSystemMemoryStatus
 */
char CheckSystemMemoryStatus(void* memoryContext);

/**
 * @brief 系统操作执行函数
 * 
 * 该函数负责执行系统操作，处理系统级别的各种操作
 * 用于系统操作的管理和执行
 * 
 * @param operationContext 操作上下文指针
 * @param parameterBuffer 参数缓冲区指针
 * @param operationId 操作ID
 * @param operationFlags 操作标志
 * 
 * 原始函数名为FUN_180629a40，现已重命名为ExecuteSystemOperation
 */
void ExecuteSystemOperation(void* operationContext, void* parameterBuffer, int operationId, uint operationFlags);

/**
 * @brief 系统数据传输处理函数
 * 
 * 该函数负责处理系统数据传输，管理数据流和传输操作
 * 用于系统数据传输的管理和控制
 * 
 * @param sourceContext 源上下文指针
 * @param targetContext 目标上下文指针
 * 
 * 原始函数名为FUN_18062db60，现已重命名为ProcessSystemDataTransfer
 */
void ProcessSystemDataTransfer(void* sourceContext, void* targetContext);

/**
 * @brief 系统数据指针获取函数
 * 
 * 该函数负责获取系统数据指针，提供数据访问接口
 * 用于系统数据的访问和管理
 * 
 * @param dataIndex 数据索引
 * @return 数据指针
 * 
 * 原始函数名为FUN_18015c450，现已重命名为GetSystemDataPointer
 */
void* GetSystemDataPointer(int dataIndex);

/**
 * @brief 系统配置初始化函数
 * 
 * 该函数负责初始化系统配置，设置配置参数和属性
 * 用于系统配置的前期准备工作
 * 
 * @param configContext 配置上下文指针
 * @param configFlags 配置标志
 * @param configParameter1 配置参数1
 * @param configParameter2 配置参数2
 * 
 * 原始函数名为FUN_1801299b0，现已重命名为InitializeSystemConfiguration
 */
void InitializeSystemConfiguration(void* configContext, int configFlags, int configParameter1, int configParameter2);

/**
 * @brief 系统数据字段设置函数
 * 
 * 该函数负责设置系统数据字段，配置数据结构和属性
 * 用于系统数据字段的配置和管理
 * 
 * @param dataFieldContext 数据字段上下文指针
 * @param fieldValue 字段值
 * @param additionalParameter 额外参数
 * 
 * 原始函数名为FUN_18010f010，现已重命名为SetupSystemDataField
 */
void SetupSystemDataField(void* dataFieldContext, uint fieldValue, uint additionalParameter);

/**
 * @brief 系统初始化完成函数
 * 
 * 该函数负责完成系统初始化，执行最后的初始化操作
 * 用于系统初始化的收尾工作
 * 
 * 原始函数名为FUN_18012cfe0，现已重命名为FinalizeSystemInitialization
 */
void FinalizeSystemInitialization(void);

/**
 * @brief 游戏系统主入口点
 * 
 * 这是整个游戏系统的主要入口点，负责初始化和管理所有核心系统组件
 */
void* GameSystemMainEntryPoint;
void* SystemGlobalDataReference;              // 全局系统数据引用
void* SystemPrimaryMemoryPool;                // 主系统内存池
void* SystemPrimaryDataTable;                 // 系统数据表引用
void* SystemBackupMemoryPool;                  // 备份系统内存池
void* SystemBackupDataTable;                   // 备份系统数据表
void* SystemCacheMemoryPool;                   // 缓存系统内存池
void* SystemCacheDataTable;                    // 缓存系统数据表
void* SystemTemporaryMemoryPool;              // 临时系统内存池
void* SystemTemporaryDataTable;               // 临时系统数据表
void* SystemReservedMemoryPool;               // 保留系统内存池
void* SystemReservedDataTable;                // 保留系统数据表
void* SystemEmergencyMemoryPool;              // 紧急系统内存池
void* SystemEmergencyDataTable;               // 紧急系统数据表

// 核心系统函数指针和相关数据
/**
 * @brief 游戏核心系统主入口点
 * 
 * 负责初始化游戏的核心系统组件，包括物理引擎、渲染系统等
 */
void* GameCoreSystemMainEntryPoint;
void* CoreSystemMemoryAllocator;                // 核心系统内存分配器
void* CoreSystemDataTable;                     // 核心系统数据表
void* CoreSystemMemoryBuffer;                  // 核心系统内存缓冲区
void* CoreSystemPrimaryConfiguration;           // 核心系统主配置
void* CoreSystemBackupConfiguration;           // 核心系统备份配置
void* CoreSystemCacheConfiguration;            // 核心系统缓存配置
void* CoreSystemEmergencyConfiguration;        // 核心系统紧急配置

void* PhysicsSystemPointer;                     // 物理系统指针
void* NetworkSystemPointer;                     // 网络系统指针
void* GameLogicSystemPointer;                   // 游戏逻辑系统指针
void* UISystemPointer;                          // UI系统指针

/**
 * @brief 游戏渲染系统主入口点
 * 
 * 负责初始化和管理游戏的渲染系统，包括图形管线、着色器等
 */
void* GameRenderingMainEntryPoint;
void* RenderingSystemContext;                   // 渲染系统上下文

/**
 * @brief 游戏网络系统主入口点
 * 
 * 负责初始化和管理游戏的网络系统，包括网络连接、数据传输等
 */
void* GameNetworkMainEntryPoint;
void* NetworkSystemContext;                     // 网络系统上下文

/**
 * @brief 游戏音频系统主入口点
 * 
 * 负责初始化和管理游戏的音频系统，包括音效播放、音乐管理等
 */
void* GameAudioMainEntryPoint;
void* AudioSystemContext;                       // 音频系统上下文

/**
 * @brief 游戏输入系统主入口点
 * 
 * 负责初始化和管理游戏的输入系统，包括键盘、鼠标、手柄等输入设备
 */
void* GameInputMainEntryPoint;
void* InputSystemDataBuffer;                    // 输入系统数据缓冲区
void* InputSystemEventQueueManager;              // 输入系统事件队列管理器
void* InputSystemCurrentStateData;               // 输入系统当前状态数据
void* InputSystemDeviceManager;                  // 输入系统设备管理器
void* InputSystemKeyMappingTable;                 // 输入系统按键映射表
void* InputSystemAxisMappingTable;               // 输入系统轴映射表
void* InputSystemActionBindingsTable;            // 输入系统动作绑定表
void* InputSystemConfiguration;                  // 输入系统配置
void* GameSubsystemMainEntryPoint;              // 游戏子系统主入口点
void* SubsystemMainContext;                     // 子系统主上下文
void* InputSystemDataTable;                     // 输入系统数据表
uint8_t InputSystemStatusFlags;                  // 输入系统状态标志
void* InputSystemMainConfiguration;             // 输入系统主配置
void* InputSystemDeviceConfigurationTable;      // 输入系统设备配置表
void* InputSystemMappingConfigurationTable;     // 输入系统映射配置表
void* InputSystemProfileConfigurationTable;      // 输入系统配置文件表

// 物理系统初始化函数
/**
 * @brief 游戏物理系统主入口点
 * 
 * 负责初始化和管理游戏的物理系统，包括碰撞检测、物理模拟等
 */
void* GamePhysicsMainEntryPoint;
void* PhysicsSystemContext;                      // 物理系统上下文

// 文件系统初始化函数
/**
 * @brief 游戏文件系统主入口点
 * 
 * 负责初始化和管理游戏的文件系统，包括文件读写、资源加载等
 */
void* GameFileSystemMainEntryPoint;

// 字符串处理系统初始化
void* GameStringProcessingMainInitializer;       // 游戏字符串处理主初始化器
void* StringProcessingDataBuffer;                // 字符串处理数据缓冲区
void* StringProcessingMainStructure;              // 字符串处理主结构
void* StringProcessingBackupStructure;            // 字符串处理备份结构
void* StringProcessingCacheStructure;             // 字符串处理缓存结构
void* StringProcessingTemporaryStructure;         // 字符串处理临时结构
void* StringProcessingSecurityCheckHandler;       // 字符串处理安全检查处理器

// 内存管理系统初始化
void* GameMemoryManagementMainInitializer;       // 游戏内存管理主初始化器

// 系统资源管理器初始化
void* GameResourceManagementMainInitializer;     // 游戏资源管理主初始化器
void* ResourceMemoryRegionMain;                   // 资源内存区域主分区
void* ResourceMemoryRegionBackup;                 // 资源内存区域备份分区
void* ResourceMemoryRegionCache;                  // 资源内存区域缓存分区
void* ResourceMemoryRegionTemporary;              // 资源内存区域临时分区
void* ResourceMemoryRegionReserved;               // 资源内存区域保留分区
void* ResourceMemoryRegionEmergency;              // 资源内存区域紧急分区
void* ResourceMemoryRegionSystem;                 // 资源内存区域系统分区
void* ResourceMemoryRegionUser;                   // 资源内存区域用户分区
void* ResourceMemoryRegionShared;                 // 资源内存区域共享分区
void* ResourceMemoryRegionProtected;              // 资源内存区域保护分区
void* ResourceMemoryRegionSecure;                 // 资源内存区域安全分区
void* ResourceFunctionPointerMain;                // 资源函数指针主入口
void* ResourceFunctionPointerBackup;              // 资源函数指针备份入口
void* ResourceMemoryRegionDebug;                  // 资源内存区域调试分区
void* ResourceMemoryRegionTest;                   // 资源内存区域测试分区
void* ResourceMemoryRegionDevelopment;            // 资源内存区域开发分区
void* ResourceMemoryRegionProduction;             // 资源内存区域生产分区
void* ResourceSystemGlobalConstant;                // 资源系统全局常量
void* ResourceDataBufferBackup;                   // 资源数据缓冲区备份区域
/**
 * @brief 资源数据表备份
 */
void* ResourceDataTableBackup;

/**
 * @brief 资源内存区域暂存区
 */
void* ResourceMemoryRegionStaging;

/**
 * @brief 资源数据表缓存
 */
void* ResourceDataTableCache;

/**
 * @brief 资源内存区域存档区
 */
void* ResourceMemoryRegionArchive;

/**
 * @brief 资源数据表临时区
 */
void* ResourceDataTableTemporary;

/**
 * @brief 资源入口点主函数
 */
void* ResourceEntryPointMain;

/**
 * @brief 资源内存区域遗留区
 */
void* ResourceMemoryRegionLegacy;

/**
 * @brief 资源内存区域未来扩展区
 */
void* ResourceMemoryRegionFuture;

/**
 * @brief 资源内存区域实验区
 */
void* ResourceMemoryRegionExperimental;

/**
 * @brief 资源内存区域已废弃区
 */
void* ResourceMemoryRegionDeprecated;

/**
 * @brief 资源系统状态标志
 */
int ResourceSystemStatusFlag;

/**
 * @brief 资源系统时间戳
 */
long long ResourceSystemTimestamp;

/**
 * @brief 资源内存区域热修复区
 */
void* ResourceMemoryRegionHotfix;

// 函数: 系统初始化函数D - 数据表管理器初始化
void* GameDataTableManagerInitializer;
/**
 * @brief 系统内存区域扩展A
 */
void* SystemMemoryRegionExpansionAlpha;
/**
 * @brief 系统内存区域扩展B
 */
void* SystemMemoryRegionExpansionBeta;
void* SystemDataTableEmergency;                  // 紧急系统数据表
/**
 * @brief 系统内存区域扩展C
 */
void* SystemMemoryRegionExpansionC;

/**
 * @brief 系统内存区域扩展D
 */
void* SystemMemoryRegionExpansionD;

/**
 * @brief 系统内存区域扩展E
 */
void* SystemMemoryRegionExpansionE;

/**
 * @brief 系统内存区域扩展F
 */
void* SystemMemoryRegionExpansionF;

/**
 * @brief 系统内存区域扩展G
 */
void* SystemMemoryRegionExpansionG;

/**
 * @brief 系统内存区域扩展H
 */
void* SystemMemoryRegionExpansionH;

/**
 * @brief 系统内存区域扩展I
 */
void* SystemMemoryRegionExpansionI;
void* SystemDataTableHotfix;                     // 热修复系统数据表
void* SystemMemoryRegionExpansionJ;
void* SystemMemoryRegionExpansionK;
void* SystemMemoryRegionExpansionL;
void* SystemMemoryRegionExpansionM;
void* SystemMemoryRegionExpansionN;
void* SystemMemoryRegionExpansionO;
void* SystemMemoryRegionExpansionP;
void* SystemDataTableLegacy;                     // 遗留系统数据表
void* SystemMemoryRegionExpansionQ;
void* SystemMemoryRegionExpansionR;
void* SystemMemoryRegionExpansionS;
void* SystemMemoryRegionExpansionT;
void* SystemMemoryRegionExpansionU;
void* SystemMemoryRegionExpansionV;
void* SystemMemoryRegionExpansionW;
/**
 * @brief 系统数据指针主指针
 */
void* SystemDataPointerMain;

/**
 * @brief 系统数据指针备份指针
 */
void* SystemDataPointerBackup;

/**
 * @brief 系统数据指针缓存指针
 */
void* SystemDataPointerCache;

/**
 * @brief 系统数据指针临时指针
 */
void* SystemDataPointerTemporary;

/**
 * @brief 系统数据指针保留指针
 */
void* SystemDataPointerReserved;

/**
 * @brief 系统数据指针安全指针
 */
void* SystemDataPointerSecure;
/**
 * @brief 系统数据表条目主条目
 */
void* SystemDataTableEntryMain;

/**
 * @brief 系统数据表条目备份条目
 */
void* SystemDataTableEntryBackup;

/**
 * @brief 系统状态标志主标志
 */
char SystemStatusFlagMain;

/**
 * @brief 系统状态标志备份标志
 */
char SystemStatusFlagBackup;

/**
 * @brief 系统状态标志缓存标志
 */
char SystemStatusFlagCache;

/**
 * @brief 系统状态标志临时标志
 */
char SystemStatusFlagTemporary;
/**
 * @brief 系统内存块主块
 */
void* SystemMemoryBlockMain;
void* SystemMemoryBlockBackup;
void* SystemMemoryBlockCache;
void* SystemMemoryBlockTemporary;
void* SystemMemoryBlockReserved;
void* SystemDataTableEntryCache;
void* SystemMemoryBlockSecure;
void* SystemMemoryBlockProtected;
void* SystemMemoryBlockShared;
void* SystemMemoryBlockUser;
void* SystemMemoryBlockKernel;
void* SystemMemoryBlockDriver;
void* SystemMemoryBlockFirmware;
void* SystemMemoryBootBlock;
void* SystemMemoryBlockRecovery;
void* SystemMemoryBlockDiagnostic;
void* SystemFunctionPointerCache;
void* SystemFunctionPointerTemporary;
void* SystemMemoryBlockHibernation;
void* SystemMemoryBlockCrashDump;
void* SystemMemoryPageFile;
void* SystemDataTableEntryTemporary;
void* SystemDataTableEntryReserved;
void* SystemMemoryBlockStandby;
void* SystemMemoryBlockSleep;
long long SystemTimeValueMain;
void* SystemDataTableEntryEmergency;
void* SystemMemoryBlockHybrid;
void* SystemMemoryBlockFastStartup;
unsigned long long SystemMemorySizeMain;
unsigned long long SystemMemorySizeBackup;
unsigned long long SystemMemorySizeCache;
uint8_t SystemByteValueMain;
uint8_t SystemByteValueBackup;
uint8_t SystemByteValueCache;
long long SystemTimeValueBackup;
bool SystemFlagMain;
void* SystemMemoryBlockCompression;
void* SystemMemoryBlockEncryption;
void* SystemMemoryBlockVirtualization;
void* SystemMemoryBlockSandbox;
char SystemStatusFlagReserved;
void* SystemFunctionPointerReserved;
void* SystemMemoryBlockSnapshot;
void* SystemMemoryBlockCheckpoint;
void* SystemMemoryBlockRollback;
bool SystemFlagBackup;
void* SystemMemoryBlockMirror;
void* SystemMemoryBlockReplica;
void* SystemMemoryBlockShadow;
void* SystemMemoryBlockClone;
char SystemStatusFlagSecure;
void* SystemMemoryBlockVault;
void* SystemMemoryBlockSafe;
void* SystemMemoryBlockLockbox;
void* SystemMemoryBlockArchiveA;
void* SystemMemoryBlockArchiveB;
void* SystemMemoryBlockArchiveC;
void* SystemMemoryBlockArchiveD;
char SystemStatusFlagProtected;
void* SystemDataTableEntrySystem;
void* SystemMemoryBlockArchiveE;
void* SystemDataTableEntryKernel;
void* SystemMemoryBlockArchiveF;
void* SystemMemoryBlockArchiveG;
void* SystemMemoryBlockArchiveH;
void* SystemMemoryBlockArchiveI;
void* SystemMemoryBlockArchiveJ;
void* SystemMemoryBlockArchiveK;
void* SystemMemoryBlockArchiveL;
void* SystemMemoryBlockArchiveM;
void* SystemMemoryBlockArchiveN;
void* SystemMemoryBlockArchiveO;
void* SystemMemoryBlockArchiveP;
void* SystemMemoryBlockArchiveQ;
void* SystemMemoryBlockArchiveR;
void* SystemMemoryBlockArchiveS;
void* SystemMemoryBlockArchiveT;
void* SystemMemoryBlockArchiveU;
void* SystemMemoryBlockArchiveV;
void* SystemMemoryBlockArchiveW;
void* SystemFunctionPointerEmergency;

// 函数: 系统初始化入口点A
/**
 * @brief 系统初始化入口点A
 * 
 * 该函数是系统初始化的主要入口点之一，负责初始化系统的核心组件
 * 和数据结构，为后续的系统启动做准备
 */
void* SystemInitializationEntryPointAlpha;
void* SystemMemoryRegionReservedA;
void* SystemMemoryRegionReservedB;
void* SystemMemoryRegionReservedC;
void* SystemDataTableEntryDriver;
void* SystemMemoryRegionReservedD;
void* SystemMemoryRegionReservedE;
void* SystemDataTableEntryFirmware;

// 函数: 系统初始化入口点B
/**
 * @brief 系统初始化入口点B
 * 
 * 该函数是系统初始化的另一个入口点，负责处理特定的系统组件
 * 初始化任务，与入口点A协同工作
 */
void* SystemInitializationEntryPointBeta;
void* SystemMemoryRegionHundredSix;

// 函数: 系统初始化入口点C
/**
 * @brief 系统初始化入口点C
 * 
 * 该函数负责系统初始化过程中的特定任务，通常与内存管理
 * 或资源分配相关
 */
void* SystemInitializationEntryPointGamma;

// 函数: 系统初始化入口点D
/**
 * @brief 系统初始化入口点D
 * 
 * 该函数负责系统初始化过程中的设备检测和配置
 */
void* SystemInitializationEntryPointDelta;

// 函数: 系统初始化入口点E
/**
 * @brief 系统初始化入口点E
 * 
 * 该函数负责系统初始化过程中的网络组件配置
 */
void* SystemInitializationEntryPointEpsilon;
void* SystemMemoryRegionHundredSeven;
void* SystemMemoryRegionHundredEight;
void* SystemMemoryRegionHundredNine;
void* SystemMemoryRegionTwoHundred;
void* SystemMemoryRegionTwoHundredOne;
void* SystemMemoryRegionTwoHundredTwo;

// 函数: 系统初始化入口点F
/**
 * @brief 系统初始化入口点F
 * 
 * 该函数负责系统初始化过程中的音频组件配置
 */
void* SystemInitializationEntryPointZeta;
void* SystemMemoryRegionTwoHundredThree;
void* SystemMemoryRegionTwoHundredFour;
void* SystemMemoryRegionTwoHundredFive;
void* SystemMemoryRegionTwoHundredSix;
char SystemStatusFlagEighth;
void* SystemMemoryRegionTwoHundredSeven;
void* SystemMemoryRegionTwoHundredEight;
void* SystemDataTableEntryTwelfth;
void* SystemMemoryRegionTwoHundredNine;
void* SystemMemoryRegionThreeHundred;
void* SystemMemoryRegionThreeHundredOne;
// 系统全局数据常量块
// 系统配置和状态数据块
void* SystemGlobalDataConfigBlockPrimary;
void* SystemGlobalDataConfigBlockSecondary;
void* SystemGlobalDataConfigBlockTertiary;
void* SystemGlobalDataConfigBlockQuaternary;
void* SystemGlobalDataConfigBlockQuinary;
void* SystemMemoryConfigDataTablePrimary;
void* SystemMemoryConfigDataTableSecondary;
void* SystemMemoryConfigDataTableTertiary;
void* SystemMemoryConfigDataTableQuaternary;
void* SystemInitializationStatusBlockPrimary;
void* SystemInitializationStatusBlockSecondary;
void* SystemInitializationStatusBlockTertiary;
void* SystemInitializationStatusBlockQuaternary;
void* SystemPerformanceMetricsBlockPrimary;
void* SystemPerformanceMetricsBlockSecondary;
void* SystemPerformanceMetricsBlockTertiary;
uint32_t SystemGlobalConfigurationFlag;
void* SystemMemoryAllocatorState;
uint32_t SystemMemoryPoolSize;
uint32_t SystemMemoryPoolAlignment;
uint32_t SystemMemoryPoolAttributes;
void* SystemMemoryPoolConfiguration;
void* SystemInitializationProgressStatus;

// 系统内存分配器 - 负责动态内存分配和管理

// 系统数据比较模板和节点指针
void* SystemDataComparisonTemplatePrimary;
void* SystemDataComparisonTemplateSecondary;
void* SystemDataComparisonTemplateTertiary;
void* SystemDataComparisonTemplateQuaternary;
void* SystemDataComparisonTemplateQuinary;
void* SystemDataComparisonTemplateSenary;
void* SystemDataComparisonTemplateSeptenary;
void* SystemDataComparisonTemplateOctonary;
void* SystemDataComparisonTemplateNonary;
void* SystemDataComparisonTemplateDenary;
void* SystemDataComparisonTemplateUndenary;
void* SystemDataComparisonTemplateDuodenary;
void* SystemDataComparisonTemplateTridenary;
void* SystemDataComparisonTemplateQuattuordenary;
void* SystemDataComparisonTemplateQuindenary;
void* SystemDataComparisonTemplateSexdenary;
void* SystemDataNodePrimaryRoot;       // 系统数据节点主根节点
void* SystemDataNodeSecondaryRoot;     // 系统数据节点次根节点
void* SystemDataNodeTertiaryRoot;      // 系统数据节点第三根节点
void* SystemDataNodeQuaternaryRoot;    // 系统数据节点第四根节点
void* SystemDataNodeQuinaryRoot;       // 系统数据节点第五根节点
void* SystemDataNodePrimary;           // 系统数据节点主节点
void* SystemDataNodeSecondary;         // 系统数据节点次节点
void* SystemDataNodeTertiary;          // 系统数据节点第三节点
void* SystemDataNodeQuaternary;        // 系统数据节点第四节点
void* SystemDataNodeQuinary;           // 系统数据节点第五节点
void* SystemDataNodeSenary;            // 系统数据节点第六节点
void* SystemDataNodeSeptenary;         // 系统数据节点第七节点
void* SystemDataNodeOctonary;          // 系统数据节点第八节点
void* SystemDataNodeNonary;            // 系统数据节点第九节点
void* SystemDataNodeDenary;            // 系统数据节点第十节点
void* SystemDataNodeUndenary;          // 系统数据节点第十一节点
void* SystemDataNodeDuodenary;         // 系统数据节点第十二节点
void* SystemDataNodeTridenary;         // 系统数据节点第十三节点
void* SystemDataNodeQuattuordenary;    // 系统数据节点第十四节点
void* SystemDataNodeQuindenary;        // 系统数据节点第十五节点
void* SystemDataNodeSexdenary;         // 系统数据节点第十六节点
void* SystemDataNodeLinkageTable;                // 系统数据节点链接表
void* SystemDataNodeLinkageManager;               // 系统数据节点链接管理器
void* SystemDataNodeLinkageHandler;               // 系统数据节点链接处理器
void* SystemConfigurationDataTemplate;  // SystemConfigurationTemplate
void* SystemStringTemplate;  // SystemStringTemplate
void* SystemDataTemplate;  // SystemDataTemplate
void* SystemDataNodeLinkageCache;                // 系统数据节点链接缓存
void* SystemDataNodeLinkageBackup;                // 系统数据节点链接备份
void* SystemDataNodeLinkagePrimary;               // 系统数据节点链接主表
void* SystemDataNodeLinkageSecondary;             // 系统数据节点链接次表
void* SystemDataComparisonTemplateAlpha;  // 系统数据比较模板Alpha
void* SystemDataComparisonTemplateBeta;  // 系统数据比较模板Beta
void* SystemDataNodeLinkageTertiary;              // 系统数据节点链接第三表
void* SystemDataNodeLinkageQuaternary;            // 系统数据节点链接第四表
void* SystemDataNodeLinkageQuinary;               // 系统数据节点链接第五表
void* SystemDataComparisonTemplateGamma;  // 系统数据比较模板Gamma
void* SystemConfigDataPointerGamma;        // 系统配置数据指针Gamma
void* SystemConfigDataPointerEta;        // 系统配置数据指针Eta
void* SystemResourceTemplate;        // 系统资源模板
void* SystemDebugStatusFlag;  // 系统调试状态标志
void* SystemStringBuffer;        // 系统字符串缓冲区
void* SystemNodeLinkPointerPrimary;        // 系统节点链接指针主表
void* SystemNodeLinkPointerSecondary;        // 系统节点链接指针次表
void* SystemRootNodePointer;         // 系统根节点指针

// 系统初始化状态变量
uint32_t SystemInitializationStatusCode;      // 系统初始化状态码
uint32_t SystemInitializationProgress;       // 系统初始化进度
uint32_t SystemInitializationErrorFlag;       // 系统初始化错误标志
uint32_t SystemInitializationMemoryStatus;   // 系统初始化内存状态
uint32_t SystemInitializationThreadStatus;    // 系统初始化线程状态
uint32_t SystemInitializationResourceStatus; // 系统初始化资源状态

// 系统内存状态标志变量
uint32_t SystemMemoryStatusFlagPrimary;      // 系统内存状态标志主标志
uint32_t SystemMemoryStatusFlagSecondary;      // 系统内存状态标志次标志

// 系统回调函数指针
void* SystemEventNotificationHandler;     // SystemEventNotificationHandler
void* SystemInitializationHandlerPrimary;  // SystemInitializationHandlerA
void* SystemInitializationHandlerSecondary;  // SystemInitializationHandlerB
void* SystemDebugMessageHandler;            // SystemDebugMessageHandler
void* SystemEventProcessor;            // SystemEventProcessor
void* SystemNetworkEventHandler;          // SystemNetworkEventHandler
void* SystemGlobalDataManager;      // SystemGlobalDataManager

// 系统全局数据指针
void* SystemGlobalDataReference;        // SystemGlobalDataReference
void* SystemGlobalDataSecondary;        // SystemGlobalDataSecondary
void* SystemGlobalDataTertiary;        // SystemGlobalDataTertiary

// 系统配置数据指针
void* SystemConfigDataPrimary;        // SystemConfigDataPointerA
void* SystemConfigDataSecondary;        // SystemConfigDataPointerB
void* SystemConfigDataTertiary;        // SystemConfigDataPointerC
void* SystemConfigDataQuaternary;        // SystemConfigDataPointerD
void* SystemConfigDataQuinary;        // SystemConfigDataSecondary
void* SystemConfigDataSenary;        // SystemConfigDataTertiary
void* SystemSemaphoreInstance;            // 系统信号量实例
/**
 * @brief 系统内存分配器函数
 * 
 * 负责动态内存分配和管理，包括内存分配、释放和重新分配操作
 */
void* SystemMemoryAllocatorFunction;

// 函数: 系统数据初始化器 - 负责初始化系统核心数据结构
/**
 * @brief 系统数据初始化器函数
 * 
 * 负责初始化系统核心数据结构，设置系统运行所需的基本数据
 */
void* SystemDataInitializerFunction;
void* SystemDataBufferPrimary;
void* SystemDataBufferSecondary;
void* SystemDataBufferTertiary;
void* SystemDataBufferQuaternary;
void* SystemDataBufferQuinary;
void* SystemDataBufferSenary;
void* SystemDataTablePrimary;
void* SystemDataTableSecondary;                // 次级系统数据表
void* SystemDataStructurePrimary;
void* SystemDataStructureSecondary;
void* SystemMemoryRegionPrimary;
void* SystemMemoryRegionSecondary;
void* SystemMemoryRegionTertiary;
void* SystemMemoryRegionQuaternary;
void* SystemMemoryRegionQuinary;
void* SystemMemoryRegionSenary;
void* SystemConfigurationDataPrimary;
void* SystemConfigurationDataSecondary;
void* SystemConfigurationDataTertiary;
void* SystemConfigurationDataQuaternary;
void* SystemConfigurationDataQuinary;
void* SystemConfigurationDataSenary;
// 系统数据缓冲区
void* SystemDataBufferPrimaryFirst;
void* SystemDataBufferPrimarySecond;
void* SystemDataBufferPrimaryThird;
void* SystemDataBufferPrimaryFourth;
void* SystemDataBufferPrimaryFifth;
void* SystemDataBufferPrimarySixth;
void* SystemDataBufferPrimarySeventh;
void* SystemDataBufferPrimaryEighth;
void* SystemDataBufferPrimaryNinth;

// 函数: 系统配置加载器 - 负责加载系统配置参数
// 系统配置管理器
void* SystemConfigurationManager;
void* SystemDataBufferConfigurationPrimary;
void* SystemDataBufferConfigurationSecondary;
void* SystemDataBufferConfigurationTertiary;
void* SystemDataBufferConfigurationQuaternary;
void* SystemDataBufferConfigurationQuinary;
void* SystemDataBufferConfigurationSenary;
void* SystemDataBufferConfigurationSeptenary;
void* SystemDataBufferConfigurationOctonary;

// 系统核心功能组件
void* SystemErrorHandler;
void* SystemLogger;
void* SystemPerformanceMonitor;
void* SystemResourceCleaner;
// 系统数据缓冲区 - 核心功能组件使用
void* SystemDataBufferCorePrimary;
void* SystemDataBufferCoreSecondary;
void* SystemDataBufferCoreTertiary;
void* SystemDataBufferCoreQuaternary;
void* SystemDataBufferCoreQuinary;
void* SystemDataBufferCoreSenary;
void* SystemDataBufferCoreSeptenary;
void* SystemDataBufferCoreOctonary;
void* SystemDataBufferCoreNonary;
void* SystemDataBufferCoreDenary;
void* SystemDataBufferCoreUndenary;
void* SystemDataBufferCoreDuodenary;
void* SystemDataBufferCoreTredecenary;
void* SystemDataBufferCoreQuattuordecenary;
void* SystemDataBufferCoreQuindecenary;
void* SystemDataBufferCoreSexdecenary;
void* SystemDataBufferCoreSeptendecenary;
void* SystemDataBufferCoreOctodecenary;
void* SystemDataBufferCoreNovemdecenary;
void* SystemDataBufferCoreVigesimal;
void* SystemDataBufferCoreUnvigesimal;
void* SystemDataBufferCoreDuovigesimal;

// 系统状态管理器
void* SystemStateManager;
// 系统状态数据缓冲区
void* SystemDataBufferStatePrimary;
void* SystemDataBufferStateSecondary;
void* SystemDataBufferStateTertiary;
void* SystemDataBufferStateQuaternary;
void* SystemDataBufferStateQuinary;
void* SystemDataBufferStateSenary;
// 系统状态标志缓冲区
char SystemStateFlagBufferPrimary;
char SystemStateFlagBufferSecondary;
// 系统数据缓冲区 - 状态管理使用
void* SystemDataBufferStateSeptenary;
void* SystemDataBufferStateOctonary;
void* SystemDataBufferStateNonary;
void* SystemDataBufferStateDenary;
void* SystemDataBufferStateUndenary;
uint8_t SystemDataBufferStateSpecial;
void* SystemDataBufferStateDuodenary;
void* SystemDataBufferStateTredecenary;
void* SystemDataBufferStateQuattuordecenary;
void* SystemDataBufferStateQuindecenary;
void* SystemDataBufferStateSexdecenary;
void* SystemDataBufferStateSeptendecenary;
uint32_t SystemDataBufferExtendedPrimary;
uint32_t SystemDataBufferExtendedSecondary;
uint32_t SystemDataBufferExtendedTertiary;
void* SystemDataBufferStateOctodecenary;
// 系统状态和数据缓冲区
char SystemStatusBufferPrimary;
void* SystemDataBufferGeneralPrimary;
void* SystemDataBufferGeneralSecondary;
void* SystemDataBufferGeneralTertiary;
void* SystemDataBufferGeneralQuaternary;
void* SystemDataBufferGeneralQuinary;
void* SystemDataBufferGeneralSenary;
void* SystemDataBufferGeneralSeptenary;
void* SystemDataBufferGeneralOctonary;
void* SystemDataBufferGeneralNonary;
void* SystemDataBufferGeneralDenary;
// 系统通用数据缓冲区
char SystemGeneralFlagBufferPrimary;
void* SystemDataBufferCommonPrimary;
void* SystemDataBufferCommonSecondary;
void* SystemDataBufferCommonTertiary;
void* SystemDataBufferCommonQuaternary;
void* SystemDataBufferCommonQuinary;
void* SystemDataBufferCommonSenary;
void* SystemDataBufferCommonSeptenary;
// 系统数据缓冲区 - 通用用途
char SystemCommonFlagBufferPrimary;
void* SystemDataBufferStandardPrimary;
void* SystemDataBufferStandardSecondary;
void* SystemDataBufferStandardTertiary;
void* SystemDataBufferStandardQuaternary;
void* SystemDataBufferStandardQuinary;
void* SystemDataBufferStandardSenary;
void* SystemDataBufferStandardSeptenary;
void* SystemDataBufferStandardOctonary;
void* SystemDataBufferStandardNonary;
void* SystemDataBufferStandardDenary;
// 系统数据缓冲区 - 标准化命名
void* SystemDataBufferStandardUndenary;
void* SystemDataBufferStandardDuodenary;
void* SystemDataBufferStandardTredecenary;
void* SystemDataBufferStandardQuattuordecenary;
void* SystemDataBufferStandardQuindecenary;
void* SystemDataBufferStandardSexdecenary;
void* SystemDataBufferStandardSeptendecenary;
void* SystemDataBufferStandardOctodecenary;
void* SystemDataBufferStandardNovemdecenary;
void* SystemDataBufferStandardVigesimal;
void* SystemDataBufferStandardUnvigesimal;
void* SystemDataBufferStandardDuovigesimal;
void* SystemDataBufferStandardTrevigesimal;
void* SystemDataBufferStandardQuattuorvigesimal;
void* SystemDataBufferStandardQuinvigesimal;
void* SystemDataBufferStandardSexvigesimal;
void* SystemDataBufferStandardSeptenvigesimal;
void* SystemDataBufferStandardOctovigesimal;
void* SystemDataBufferStandardNovemvigesimal;
void* SystemDataBufferStandardTrigesimal;
void* SystemDataBufferExtendedOne;
void* SystemDataBufferExtendedTwo;
void* SystemDataBufferExtendedThree;
void* SystemDataBufferExtendedFour;
void* SystemDataBufferExtendedFive;
void* SystemDataBufferExtendedSix;
void* SystemDataBufferExtendedSeven;
void* SystemDataBufferExtendedEight;
void* SystemDataBufferExtendedNine;
void* SystemDataBufferExtendedTen;
void* SystemDataBufferExtended11;
void* SystemDataBufferExtended12;
void* SystemDataBufferExtended13;
void* SystemDataBufferExtended14;
void* SystemDataBufferExtended15;
void* SystemDataBufferExtended16;
void* SystemDataBufferExtended17;
void* SystemDataBufferExtended18;
void* SystemDataBufferExtended19;
void* SystemDataBufferExtended20;
void* SystemDataBufferExtended21;
void* SystemDataBufferExtended22;
void* SystemDataBufferExtended23;
void* SystemDataBufferExtended24;
void* SystemDataBufferExtended25;
void* SystemDataBufferExtended26;
void* SystemDataBufferExtended27;
void* SystemDataBufferExtended28;
void* SystemDataBufferExtended29;
void* SystemDataBufferExtended30;
void* SystemDataBufferExtended31;
void* SystemDataBufferStandardExtraThirtyTwo;
void* SystemDataBufferStandardExtraThirtyThree;
void* SystemDataBufferStandardExtraThirtyFour;
void* SystemDataBufferStandardExtraThirtyFive;
void* SystemDataBufferStandardExtraThirtySix;
void* SystemDataBufferStandardExtraThirtySeven;
void* SystemDataBufferStandardExtraThirtyEight;
void* SystemDataBufferStandardExtraThirtyNine;
void* SystemDataBufferStandardExtraForty;
void* SystemDataBufferStandardExtraFortyOne;

// 系统初始化协调器
void* SystemInitializationCoordinator;
// 系统初始化数据缓冲区
void* SystemDataBufferInitPrimary;
void* SystemDataBufferInitSecondary;
void* SystemDataBufferInitTertiary;
void* SystemDataBufferInitQuaternary;
void* SystemDataBufferInitQuinary;
void* SystemDataBufferInitSenary;
void* SystemDataBufferInitSeptenary;
void* SystemDataBufferInitOctonary;
void* SystemDataBufferInitNonary;
void* SystemDataBufferInitDenary;
void* SystemDataBufferInitUndenary;
void* SystemDataBufferInitDuodenary;
void* SystemDataBufferInitTredecenary;
void* SystemDataBufferInitQuattuordecenary;
void* SystemDataBufferInitQuindecenary;
void* SystemDataBufferInitSexdecenary;
void* SystemDataBufferInitSeptendecenary;
void* SystemDataBufferInitOctodecenary;
void* SystemDataBufferInitNovemdecenary;
void* SystemDataBufferInitVigesimal;
void* SystemDataBufferInitUnvigesimal;
void* SystemDataBufferInitDuovigesimal;
void* SystemDataBufferInitTrevigesimal;
void* SystemDataBufferInitQuattuorvigesimal;
void* SystemDataBufferInitQuinvigesimal;
void* SystemDataBufferInitSexvigesimal;
void* SystemDataBufferInitSeptenvigesimal;
void* SystemDataBufferInitOctovigesimal;
void* SystemDataBufferInitNovemvigesimal;
void* SystemDataBufferInitTrigesimal;
void* SystemDataBufferInitExtraOne;
void* SystemDataBufferInitExtraTwo;
void* SystemDataBufferInitExtraThree;
void* SystemDataBufferInitExtraFour;
void* SystemDataBufferInitExtraFive;
void* SystemDataBufferInitExtraSix;
void* SystemDataBufferInitExtraSeven;
void* SystemDataBufferInitExtraEight;
void* SystemDataBufferInitExtraNine;
void* SystemDataBufferInitExtraTen;
// 系统配置数据块
void* SystemConfigurationDataBlockPrimary;
void* SystemConfigurationDataBlockSecondary;
void* SystemConfigurationDataBlockTertiary;
void* SystemConfigurationDataBlockQuaternary;
void* SystemConfigurationDataBlockQuinary;
void* SystemConfigurationDataBlockSenary;
void* SystemConfigurationDataBlockSeptenary;
void* SystemConfigurationDataBlockOctonary;
void* SystemConfigurationDataBlockNonary;
void* SystemConfigurationDataBlockDenary;
void* SystemConfigurationDataBlockUndenary;
void* SystemConfigurationDataBlockDuodenary;
void* SystemConfigurationDataTable;
void* SystemMemoryAllocatorTable;
void* SystemThreadControlTable;
void* SystemProcessControlTable;
void* SystemNetworkControlTable;
void* SystemResourceControlTable;
void* SystemSecurityControlTable;
void* SystemFileSystemControlTable;
void* SystemMemoryControlTable;
void* SystemProcessSchedulerTable;
void* SystemThreadSchedulerTable;
void* SystemInterruptControlTable;
void* SystemSecurityControlTable;
void* SystemPerformanceControlTable;
void* SystemDebugControlTable;
// 系统设备控制表
void* SystemDeviceControlTable;
void* SystemAudioControlTable;
void* SystemVideoControlTable;
void* SystemInputControlTable;
void* SystemGraphicsControlTable;
void* SystemDisplayControlTable;
void* SystemSoundControlTable;
void* SystemSensorControlTable;
void* SystemControllerControlTable;
void* SystemPowerControlTable;
// 系统状态和控制块
void* SystemStatusControlBlock;
void* SystemInitializationControlBlock;
void* SystemShutdownControlBlock;

// 系统进程和内存管理变量
void* SystemCurrentProcessHandle;          // 当前系统进程句柄
void* SystemMemoryRegionCacheA;            // 系统内存区域缓存A
void* SystemMemoryRegionCacheB;            // 系统内存区域缓存B
void* SystemMemoryRegionCacheC;            // 系统内存区域缓存C
void* SystemMemoryRegionCacheD;            // 系统内存区域缓存D
void* SystemMemoryRegionCacheE;            // 系统内存区域缓存E
void* SystemNetworkBufferPointer;          // 系统网络缓冲区指针
void* SystemPerformanceCounterA;           // 系统性能计数器A
void* SystemPerformanceCounterB;           // 系统性能计数器B
void* SystemPerformanceCounterC;           // 系统性能计数器C
void* SystemPerformanceCounterD;           // 系统性能计数器D
void* SystemPerformanceCounterE;           // 系统性能计数器E
uint32_t SystemPerformanceStatusFlag;      // 系统性能状态标志
long long SystemPerformanceTimestamp;      // 系统性能时间戳

// 系统配置和状态变量
uint32_t SystemConfigurationSize;          // 系统配置大小
void* SystemDeviceContextPointer;          // 系统设备上下文指针
uint32_t SystemDeviceStatusFlag;           // 系统设备状态标志
void* SystemDisplayContextA;               // 系统显示上下文A
void* SystemDisplayContextB;               // 系统显示上下文B
void* SystemAudioContextA;                 // 系统音频上下文A
void* SystemAudioContextB;                 // 系统音频上下文B
void* SystemInputContextA;                 // 系统输入上下文A
void* SystemInputContextB;                 // 系统输入上下文B
void* SystemNetworkContextA;                // 系统网络上下文A

// 函数: 系统启动验证器 - 负责验证系统启动条件
void* SystemStartupValidator;

// 函数: 获取系统根指针 - 获取系统根节点指针
void* GetSystemRootPointer;

// 函数: 获取系统初始化函数 - 获取系统初始化相关函数
void* GetSystemInitializationFunction;

/**
 * @brief 初始化游戏核心系统
 * 
 * 该函数负责初始化游戏的核心系统组件，包括系统节点的遍历、
 * 内存分配和核心系统数据的设置。这是游戏启动过程中的关键步骤。
 * 
 * @note 该函数会遍历系统节点树，查找或创建游戏核心系统节点，
 *       并设置相关的系统数据和回调函数。
 * @note 函数使用全局常量GAME_CORE_SYSTEM_ID进行系统识别
 * @note 函数依赖GetSystemRootPointer和GetGameCoreSystemInitializationFunction等辅助函数
 * @note 函数会设置GAME_CORE_NODE_DATA相关配置
 */
void InitializeGameCoreSystem(void)
{
  bool IsSystemNodeActive;
  void** SystemRootNodePointer;
  int MemoryComparisonResult;
  long long* SystemDataTablePointer;
  long long RequiredMemorySize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* CoreSystemInitializationHandler;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(bool*)((long long)SystemRootNodePointer[1] + 0x19);
  CoreSystemInitializationHandler = GetGameCoreSystemInitializationFunction;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (!IsSystemNodeActive) {
    MemoryComparisonResult = memcmp(CurrentSystemNode + 4, &GAME_CORE_SYSTEM_ID, 0x10);
    if (MemoryComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(bool*)((long long)NextSystemNode + 0x19);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID, PreviousSystemNode + 4, 0x10), MemoryComparisonResult < 0)) {
    RequiredMemorySize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, RequiredMemorySize + 0x20, RequiredMemorySize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[6] = 0x4fc124d23d41985f;
  PreviousSystemNode[7] = 0xe2f4a30d6e6ae482;
  PreviousSystemNode[8] = &GAME_CORE_NODE_DATA;
  PreviousSystemNode[9] = 0;
  PreviousSystemNode[10] = CoreSystemInitializationHandler;
  return;
}




/**
 * @brief 初始化系统数据表基础分配器
 * 
 * 该函数负责初始化系统数据表的基础分配器，为数据表的内存分配
 * 和管理提供基础支持。它会遍历系统节点树，查找合适的位置
 * 来初始化基础分配器功能。
 * 
 * @note 该函数在系统初始化过程中调用，确保数据表的基础
 * 分配功能正常工作。
 */
void InitializeSystemDataTableBaseAllocator(void)
{
  bool IsSystemNodeActive;
  void** SystemRootNodePointer;
  int MemoryComparisonResult;
  long long* SystemDataTablePointer;
  long long RequiredMemorySize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* BaseAllocatorInitializationHandler;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(bool*)((long long)SystemRootNodePointer[1] + 0x19);
  BaseAllocatorInitializationHandler = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (!IsSystemNodeActive) {
    MemoryComparisonResult = memcmp(CurrentSystemNode + 4, &BASE_ALLOCATOR_ID, 0x10);
    if (MemoryComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(bool*)((long long)NextSystemNode + 0x19);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID, PreviousSystemNode + 4, 0x10), MemoryComparisonResult < 0)) {
    RequiredMemorySize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, RequiredMemorySize + 0x20, RequiredMemorySize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[6] = 0x4770584fbb1df897;
  PreviousSystemNode[7] = 0x47f249e43f66f2ab;
  PreviousSystemNode[8] = &BaseAllocatorNodeData;
  PreviousSystemNode[9] = 1;
  PreviousSystemNode[10] = BaseAllocatorInitializationHandler;
  return;
}




/**
 * @brief 初始化系统数据表分配器
 * 
 * 该函数负责初始化系统数据表的分配器，为系统数据表的内存分配
 * 和管理提供支持。它会遍历系统节点树，查找合适的位置来初始化
 * 数据表分配器功能。
 * 
 * @note 该函数在系统初始化过程中调用，确保数据表的分配功能
 * 正常工作。
 */
void InitializeSystemDataTableAllocator(void)
{
  char IsSystemNodeActive;
  void** SystemDataTablePointer;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNodePointer;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void** AllocatedSystemNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + 0x19);
  SystemInitializationFlag = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (IsSystemNodeActive == '\0') {
    MemoryComparisonResult = memcmp(CurrentSystemNode + 4, &SystemDataTableIdentifier, 0x10);
    if (MemoryComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(char*)((long long)NextSystemNode + 0x19);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (MemoryComparisonResult = memcmp(&SystemDataTableIdentifier, PreviousSystemNode + 4, 0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, MemoryAllocationSize + 0x20, MemoryAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[6] = 0x4666df49b97e0f10;
  PreviousSystemNode[7] = 0x4e4b0d63a6ad1d8f;
  PreviousSystemNode[8] = &SystemNodeIdentifier;
  PreviousSystemNode[9] = 0;
  PreviousSystemNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统核心配置
 * 
 * 该函数负责初始化系统的核心配置，包括系统参数设置、
 * 配置文件加载和系统环境准备。这是系统初始化过程中的
 * 重要步骤。
 * 
 * @note 该函数在系统启动时调用，确保所有核心配置都正确设置。
 */
void InitializeSystemCoreConfig(void)
{
  char IsSystemNodeActive;
  void** SystemDataTablePointer;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNodePointer;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void** AllocatedSystemNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + 0x19);
  SystemInitializationFlag = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (IsSystemNodeActive == '\0') {
    MemoryComparisonResult = memcmp(CurrentSystemNode + 4, &SystemMemoryIdentifier, 0x10);
    if (MemoryComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(char*)((long long)NextSystemNode + 0x19);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (MemoryComparisonResult = memcmp(&SystemMemoryIdentifier, PreviousSystemNode + 4, 0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, MemoryAllocationSize + 0x20, MemoryAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[6] = 0x46ecbd4daf41613e;
  PreviousSystemNode[7] = 0xdc42c056bbde8482;
  PreviousSystemNode[8] = &SystemMemoryNodeId;
  PreviousSystemNode[9] = 0;
  PreviousSystemNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存池
 * 
 * 该函数负责初始化系统的内存池，为系统运行提供内存管理基础。
 * 它会设置内存池的大小、分配策略和管理机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保内存池功能正常工作。
 */
void InitializeSystemMemoryPool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统线程池
 * 
 * 该函数负责初始化系统的线程池，为系统提供多线程处理能力。
 * 它会设置线程池的大小、工作线程和管理机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保线程池功能正常工作。
 */
void InitializeSystemThreadPool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理器，为系统提供事件处理和
 * 分发机制。它会设置事件队列、事件处理器和事件分发机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保事件管理功能正常工作。
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器，为系统提供资源加载、释放和管理机制。
 * 它会设置资源池、资源分配策略和资源回收机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保资源管理功能正常工作。
 * @note 函数会遍历系统节点树，查找或创建资源管理器节点。
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统核心数据结构
 * 
 * 该函数负责初始化系统的核心数据结构，设置系统启动所需的基本数据结构和初始化参数。
 * 它会遍历系统节点树，查找或创建核心数据结构节点。
 * 
 * @note 该函数在系统初始化过程中调用，确保核心数据结构正确设置。
 * @note 函数使用SystemDataComparisonTemplateA进行系统识别。
 */
void InitializeSystemCoreData(void)

{
  char SystemNodeFlag;
  void** SystemRootNodePointer;
  int MemoryComparisonResult;
  long long *SystemDataTablePointer;
  long long RequiredMemorySize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* SystemInitializationCallback;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  SystemNodeFlag = *(char*)((long long)SystemRootNodePointer[1] + 0x19);
  SystemInitializationCallback = GetSystemInitializationCallback;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentSystemNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    SystemNodeFlag = *(char*)((long long)NextSystemNode + 0x19);
  }
  if ((PreviousSystemNode == SystemRootNodePointer) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateA,PreviousSystemNode + 4,0x10), MemoryComparisonResult < 0)) {
    RequiredMemorySize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer,&AllocatedSystemNode,PreviousSystemNode,RequiredMemorySize + 0x20,RequiredMemorySize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  PreviousSystemNode[6] = 0x421c3cedd07d816d;
  PreviousSystemNode[7] = 0xbec25de793b7afa6;
  PreviousSystemNode[8] = &SystemNodeLinkPointerA;
  PreviousSystemNode[9] = 0;
  PreviousSystemNode[10] = SystemInitializationCallback;
  return;
}




/**
 * 初始化系统数据表结构
 * 设置系统数据表和相关的内存结构
 */
void InitializeSystemDataTable(void)

{
  char StatusFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemHandle;
  long long MemorySize;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** NewNode;
  void* SystemFlag;
  
  SystemHandle = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemHandle;
  StatusFlag = *(char*)((long long)SystemRootPointer[1] + 0x19);
  SystemFlag = 0;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* )SystemRootPointer[1];
  while (StatusFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* )CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* )*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    StatusFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateB,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    MemorySize = GetSystemMemorySize(SystemHandle);
    AllocateSystemMemory(SystemHandle,&NewNode,PreviousNode,MemorySize + 0x20,MemorySize);
    PreviousNode = NewNode;
  }
  PreviousNode[6] = 0x4c22bb0c326587ce;
  PreviousNode[7] = 0x5e3cf00ce2978287;
  PreviousNode[8] = &SystemNodeLinkPointerB;
  PreviousNode[9] = 1;
  PreviousNode[10] = SystemFlag;
  return;
}




/**
 * @brief 初始化系统全局变量
 * 
 * 该函数负责初始化系统的全局变量和配置参数
 * 设置各个系统模块的初始状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemGlobalVariables(void)

{
  long long InitializationStatus;
  
  SystemInitializationStatusCode = 0;
  SystemInitializationProgress = 0;
  SystemMemoryStatusFlagA = 0;
  SystemInitializationErrorFlag = 3;
  SystemInitializationMemoryStatus = 0;
  SystemInitializationThreadStatus = 0;
  SystemMemoryStatusFlagB = 0;
  SystemInitializationResourceStatus = 3;
  SystemConfigDataPointerA = &SystemGlobalDataPointerA;
  SystemConfigDataPointerB = 0;
  SystemConfigDataPointerC = 0;
  SystemConfigDataPointerD = 0;
  
  InitializationStatus = 0;
  return InitializationStatus;
}

/**
 * @brief 初始化核心引擎
 * 
 * 该函数负责初始化游戏引擎的核心系统
 * 设置基本的运行环境和管理结构
 */
void InitializeCoreEngine(void)

/**
 * @brief 初始化渲染系统配置
 * 
 * 设置渲染系统的基本配置参数和数据结构
 */
void InitializeRenderingSystemConfig(void)

{
  char SystemNodeFlag;
  void** SystemRootPointer;
  int MemoryComparisonResult;
  long long *SystemTablePointer;
  long long MemoryAllocationSize;
  void** SystemCurrentNode;
  void** HashBucketNode;
  void** SystemNextNode;
  void** SystemAllocatedNode;
  void* RenderingInitializationFlag;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  SystemNodeFlag = *(char*)((long long)SystemRootPointer[1] + 0x19);
  RenderingInitializationFlag = 0;
  HashBucketNode = SystemRootPointer;
  SystemCurrentNode = (void* *)SystemRootPointer[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootPointer) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateC,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42bea5b911d9c4bf;
  HashBucketNode[7] = 0x1aa83fc0020dc1b6;
  HashBucketNode[8] = &SystemDataNodeSecondaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = RenderingInitializationFlag;
  return;
}



/**
 * @brief 初始化音频系统资源池
 * 
 * 创建并配置音频系统的资源池，返回初始化状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeAudioSystemResourcePool(void)

{
  long long AudioInitializationResult;
  
  RegisterSystemEventHandler(SYSTEM_EVENT_HANDLER_PRIMARY_ADDRESS,0x20,8,GetSystemEventCallbackA,GetSystemEventCallbackB);
  AudioInitializationResult = InitializeAudioSystem(&AudioSystemConfiguration);
  return (AudioInitializationResult != 0) - 1;
}



/**
 * @brief 初始化输入系统资源池
 * 
 * 创建并配置输入系统的资源池，返回初始化状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeInputSystemResourcePool(void)

{
  long long InputInitializationResult;
  
  RegisterSystemEventHandler(SYSTEM_EVENT_HANDLER_SECONDARY_ADDRESS,0x20,8,GetSystemEventCallbackC,GetSystemEventCallbackB);
  InputInitializationResult = InitializeInputSystem(&InputSystemConfiguration);
  return (InputInitializationResult != 0) - 1;
}




/**
 * @brief 初始化系统信号量
 * 
 * 创建系统级的信号量用于线程同步，返回初始化状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemSemaphore(void)

{
  long long semaphoreInitializationResult;
  
  SystemSemaphoreHandle = CreateSemaphoreW(0,1,0x7fffffff,0,0xfffffffffffffffe);
  semaphoreInitializationResult = InitializeSemaphoreSystem(GetSemaphoreSystemConfiguration);
  return (semaphoreInitializationResult != 0) - 1;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统内存管理器，设置内存分配策略
 * 和管理机制，确保系统内存资源的有效利用。
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemSearchFunctionPointer = GetSystemSearchFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4, &SystemDataComparisonTemplateD, 0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateD, HashBucketNode + 4, 0x10), MemoryComparisonResult < 0)) {
    SystemMemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable, &SystemAllocatedNode, HashBucketNode, SystemMemoryAllocationSize + 0x20, SystemMemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x406be72011d07d37;
  HashBucketNode[7] = 0x71876af946c867ab;
  HashBucketNode[8] = &SystemDataNodeTertiaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = EventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存分配器
 * 
 * 该函数负责初始化系统内存分配器，设置内存分配策略
 * 和管理机制，为系统提供高效的内存分配服务。
 */
void InitializeSystemMemoryAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemSearchFunctionPointerB = GetSystemSearchFunctionB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4, &SystemDataComparisonTemplateG, 0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateG, HashBucketNode + 4, 0x10), MemoryComparisonResult < 0)) {
    SystemMemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable, &SystemAllocatedNode, HashBucketNode, SystemMemoryAllocationSize + 0x20, SystemMemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40afa5469b6ac06d;
  HashBucketNode[7] = 0x2f4bab01d34055a5;
  HashBucketNode[8] = &SystemDataNodeQuaternaryRoot;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = EventCallbackPointer;
  return;
}



/**
 * @brief 初始化系统线程同步机制
 * 
 * 该函数负责初始化系统的线程同步机制，包括互斥锁和信号量
 * 确保多线程环境下的数据安全和同步操作
 * 
 * @param threadPool 线程池指针
 * @param syncConfig 同步配置参数
 * @param mutexSize 互斥锁大小
 * @param semaphoreConfig 信号量配置
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemThreadSynchronization(void* ThreadPool, void* SyncConfig, size_t MutexSize, void* SemaphoreConfig)

{
  long long initializationResult;
  
  // 初始化互斥锁和信号量
  InitializeMutexInSitu(SystemMutexPool, 2, MutexSize, SemaphoreConfig, MAX_THREAD_COUNT);
  initializationResult = InitializeThreadPool(SystemThreadPoolInstance);
  return (initializationResult != 0) - 1;
}





/**
 * @brief 初始化系统字符串处理模块
 * 
 * 该函数负责初始化系统字符串处理模块，设置字符串缓冲区
 * 和处理机制，为系统提供字符串操作支持。
 */
void InitializeSystemStringHandler(void)

{
  uint64_t SystemStringParameter;
  void* StringProcessCallbackPointer;
  uint8_t* StringDataBufferPointer;
  uint32_t StringBufferSize;
  uint8_t StringDataBuffer [136];
  
  StringProcessCallbackPointer = &SystemStringProcessorNode;
  StringDataBufferPointer = StringDataBuffer;
  StringDataBuffer[0] = 0;
  StringBufferSize = 7;
  strcpy_s(StringDataBuffer, 0x80, &SystemStringProcessorTemplate, SystemStringParameter, 0xfffffffffffffffe);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&StringProcessCallbackPointer);
  return;
}




/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统线程管理器，设置线程创建和管理机制，
 * 为系统提供多线程支持。
 */
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，设置事件处理机制和事件队列，
 * 为系统提供事件驱动支持。
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点结构
 * 设置系统配置的基本参数和数据结构
 */
void InitializeSystemConfigurationNode(void)

{
  char NodeFlag;
  void* *SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long AllocationSize;
  void* *CurrentNode;
  void* *PreviousNode;
  void* *NextNode;
  void* *AllocatedNode;
  void* InitializationFlag;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + 0x19);
  InitializationFlag = 0;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateJ,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + 0x20,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x4b2d79e470ee4e2c;
  PreviousNode[7] = 0x9c552acd3ed5548d;
  PreviousNode[8] = &SystemDataNodeG;
  PreviousNode[9] = 0;
  PreviousNode[10] = InitializationFlag;
  return;
}




// 函数: void InitializeSystemResourceNode(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点结构
 * 设置系统资源管理的基本参数和数据结构
 */
void InitializeSystemResourceNode(void)

{
  char NodeFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** AllocatedNode;
  void** InitializationCallback;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + 0x19);
  InitializationCallback = GetSystemInitializationCallbackB;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateK,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + 0x20,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x49086ba08ab981a7;
  PreviousNode[7] = 0xa9191d34ad910696;
  PreviousNode[8] = &SystemDataNodeH;
  PreviousNode[9] = 0;
  PreviousNode[10] = InitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryNode(void)
/**
 * @brief 初始化系统内存节点
 * 
 * 该函数负责初始化系统的内存节点结构
 * 设置系统内存管理的基本参数和数据结构
 */
void InitializeSystemMemoryNode(void)

{
  char NodeFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** AllocatedNode;
  void* InitializationFlag;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + 0x19);
  InitializationFlag = 0;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateL,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + 0x20,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x402feffe4481676e;
  PreviousNode[7] = 0xd4c2151109de93a0;
  PreviousNode[8] = &SystemDataNodeI;
  PreviousNode[9] = 0;
  PreviousNode[10] = InitializationFlag;
  return;
}




/**
 * @brief 初始化系统数据表结构A
 * 
 * 该函数负责初始化系统数据表结构A，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureA(void)

{
  char DataTypeFlag;
  void** DataTablePointer;
  int MemoryComparisonResult;
  long long *SystemRootPointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void* *NewNodePointer;
  void** SystemDataReference;
  
  SystemRootPointer = (long long*)GetSystemRootPointer();
  DataTablePointer = (void* *)*SystemRootPointer;
  DataTypeFlag = *(char*)((long long)DataTablePointer[1] + 0x19);
  systemDataReference = &SystemDataNodeJ;
  PreviousNode = DataTablePointer;
  CurrentNode = (void* *)DataTablePointer[1];
  while (DataTypeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    DataTypeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == DataTablePointer) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,PreviousNode + 4,0x10), MemoryComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemRootPointer);
    AllocateSystemMemory(SystemRootPointer,&NewNodePointer,PreviousNode,currentThreadId + 0x20,currentThreadId);
    PreviousNode = NewNodePointer;
  }
  PreviousNode[6] = 0x4384dcc4b6d3f417;
  PreviousNode[7] = 0x92a15d52fe2679bd;
  PreviousNode[8] = &SystemDataNodeK;
  PreviousNode[9] = 0;
  PreviousNode[10] = systemDataReference;
  return;
}




/**
 * @brief 初始化系统数据表结构B
 * 
 * 该函数负责初始化系统数据表结构B，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureB(void)

{
  char DataTypeFlag;
  void** DataTablePointer;
  int MemoryComparisonResult;
  long long* SystemRootPointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** NewNodePointer;
  void* InitializationFlag;
  
  SystemRootPointer = (long long*)GetSystemRootPointer();
  DataTablePointer = (void**)*SystemRootPointer;
  DataTypeFlag = *(char*)((long long)DataTablePointer[1] + 0x19);
  InitializationFlag = 0;
  PreviousNode = DataTablePointer;
  CurrentNode = (void**)DataTablePointer[1];
  while (DataTypeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      NextNode = (void**)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void**)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    DataTypeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == DataTablePointer) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,PreviousNode + 4,0x10), MemoryComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemRootPointer);
    AllocateSystemMemory(SystemRootPointer,&NewNodePointer,PreviousNode,currentThreadId + 0x20,currentThreadId);
    PreviousNode = NewNodePointer;
  }
  PreviousNode[6] = 0x4140994454d56503;
  PreviousNode[7] = 0x399eced9bb5517ad;
  PreviousNode[8] = &SystemDataNodeL;
  PreviousNode[9] = 0;
  PreviousNode[10] = InitializationFlag;
  return;
}




/**
 * @brief 初始化系统数据表结构C
 * 
 * 该函数负责初始化系统数据表结构C，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateE,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x449bafe9b77ddd3c;
  HashBucketNode[7] = 0xc160408bde99e59f;
  HashBucketNode[8] = &SystemDataNodeA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构D
 * 
 * 该函数负责初始化系统数据表结构D，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构E
 * 
 * 该函数负责初始化系统数据表结构E，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateD,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x406be72011d07d37;
  HashBucketNode[7] = 0x71876af946c867ab;
  HashBucketNode[8] = &SystemDataNodeTertiaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构F
 * 
 * 该函数负责初始化系统数据表结构F，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateG,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40afa5469b6ac06d;
  HashBucketNode[7] = 0x2f4bab01d34055a5;
  HashBucketNode[8] = &SystemDataNodeQuaternaryRoot;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构G
 * 
 * 该函数负责初始化系统数据表结构G，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateC,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42bea5b911d9c4bf;
  HashBucketNode[7] = 0x1aa83fc0020dc1b6;
  HashBucketNode[8] = &SystemDataNodeSecondaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表结构H
 * 
 * 该函数负责初始化系统数据表结构H，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateO,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40db4257e97d3df8;
  HashBucketNode[7] = 0x81d539e33614429f;
  HashBucketNode[8] = &SystemDataNodeN;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构I
 * 
 * 该函数负责初始化系统数据表结构I，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemEventCallbackPointer;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemMemoryComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4e33c4803e67a08f;
  HashBucketNode[7] = 0x703a29a844ce399;
  HashBucketNode[8] = &SystemDataNodeO;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统字符串处理全局变量
 * 
 * 初始化游戏引擎字符串处理系统的全局变量和数据结构。
 * 该函数负责设置字符串处理系统的基础配置和引用。
 * 
 * @return 初始化状态，成功返回0，失败返回非零值
 */
int InitializeSystemStringProcessingGlobals(void)

{
  long long systemInitializationStatus;
  void* SystemConfigurationValue;
  
  SystemStringProcessingPrimaryBuffer = &SystemStringProcessingReferenceTable;
  SystemStringProcessingSecondaryBuffer = &SystemStringProcessingConfigurationTable;
  
  return systemInitializationStatus;
}

/**
 * @brief 初始化系统字符串处理功能
 * 
 * 初始化游戏引擎的字符串处理子系统，设置字符串缓冲区和处理函数。
 * 该函数负责配置字符串操作的基础设施，为后续的文本处理提供支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是文本处理系统的基础
 */
void InitializeSystemStringProcessor(void)

{
  uint64_t SystemStringParameter;
  void* StringProcessCallbackPointer;
  uint8_t* StringDataBufferPointer;
  uint32_t StringBufferSize;
  uint8_t StringDataBuffer [136];
  
  StringProcessCallbackPointer = &SystemStringProcessorNode;
  StringDataBufferPointer = StringDataBuffer;
  StringDataBuffer[0] = 0;
  StringBufferSize = 0xb;
  strcpy_s(StringDataBuffer,0x80,&SystemStringProcessorTemplate,SystemStringParameter,0xfffffffffffffffe);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&StringProcessCallbackPointer);
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 初始化游戏引擎的内存管理子系统，设置内存分配策略和管理机制。
 * 该函数负责配置内存池、分配器和回收机制，为系统运行提供内存管理支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是内存管理系统的核心组件
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据结构
 * 
 * 初始化游戏引擎的数据结构子系统，设置数据表和管理节点。
 * 该函数负责配置数据结构的基础设施，为系统数据管理提供支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是数据管理系统的核心组件
 */
void InitializeSystemDataStructure(void)

{
  char NodeFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** AllocatedNode;
  void* *initializationFunction;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + 0x19);
  initializationFunction = (void* *)SystemInitializationCallbackA;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateI,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + 0x20,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x431d7c8d7c475be2;
  PreviousNode[7] = 0xb97f048d2153e1b0;
  PreviousNode[8] = &SystemDataNodeF;
  PreviousNode[9] = 4;
  PreviousNode[10] = initializationFunction;
  return;
}




// 函数: 初始化系统数据表
// 负责创建和配置系统的主数据表结构
void InitializeSystemDataTable(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化系统节点树
// 负责创建和管理系统的节点树结构
void InitializeSystemNodeTree(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: 初始化内存分配器
// 负责设置和管理系统的内存分配机制
void InitializeMemoryAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化资源池
// 负责创建和管理系统的资源池结构
void InitializeResourcePool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* ResourcePoolCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  resourcePoolCallbackPointer = &ResourcePoolCallbackNode;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: 初始化配置管理器
// 负责设置和管理系统的配置参数
void InitializeConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化事件系统
// 负责设置和管理系统的事件处理机制
void InitializeEventSystem(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理器，设置内存分配策略
 * 和内存池管理结构，确保系统内存的有效利用
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统线程池管理器
 * 
 * 该函数负责初始化系统的线程池管理器，设置线程池的
 * 基本参数和线程管理策略，优化系统并发处理能力
 */
void InitializeSystemThreadPoolManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器，设置资源的分配、
 * 释放和监控机制，确保系统资源的合理使用
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统节点树结构
 * 
 * 初始化游戏引擎的系统节点树，构建节点之间的链接关系。
 * 该函数负责设置系统节点的内存分配和初始化节点数据结构。
 * 
 * @note 该函数在系统初始化阶段被调用，用于构建系统树形结构
 */
void InitializeSystemNodeTree(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构
 * 
 * 初始化游戏引擎的数据表结构，设置数据表的基本配置和内存分配。
 * 该函数负责创建数据表的基本框架，为后续的数据存储和访问做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立数据表的基础结构
 */
void InitializeSystemDataTable(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件处理器
 * 
 * 该函数负责初始化系统的事件处理器，设置事件的监听、
 * 分发和处理机制，确保系统事件的及时响应
 */
void InitializeSystemEventHandler(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理器，设置网络连接、
 * 数据传输和协议处理机制，确保系统网络功能的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统安全管理器
 * 
 * 该函数负责初始化系统的安全管理器，设置安全策略、
 * 权限控制和防护机制，确保系统的安全性
 */
void InitializeSystemSecurityManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控器，设置性能指标的
 * 收集、分析和报告机制，确保系统性能的实时监控
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理器，设置调试信息的
 * 收集、存储和分析机制，便于系统问题的诊断和解决
 */
void InitializeSystemDebugManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存分配器
 * 
 * 初始化游戏引擎的内存分配器，设置内存池和分配策略。
 * 该函数负责配置内存管理的基础设施，为系统运行提供内存支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是内存管理的核心组件
 */
void InitializeSystemMemoryAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源池
 * 
 * 初始化游戏引擎的资源池，设置资源管理和分配的基础设施。
 * 该函数负责创建资源池的基本结构，为系统资源的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立资源管理的基础
 */
void InitializeSystemResourcePool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 初始化游戏引擎的配置管理器，设置系统配置的基础设施。
 * 该函数负责创建配置管理的基本结构，为系统配置的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立配置管理的基础
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 初始化游戏引擎的资源管理器，设置系统资源的基础设施。
 * 该函数负责创建资源管理的基本结构，为系统资源的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立资源管理的基础
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* *resourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  resourceInitializationCallback = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 初始化游戏引擎的性能监控器，设置性能监控和统计的基础设施。
 * 该函数负责创建性能监控的基本结构，为系统性能的监控和统计做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立性能监控的基础
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateC,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42bea5b911d9c4bf;
  HashBucketNode[7] = 0x1aa83fc0020dc1b6;
  HashBucketNode[8] = &SystemDataNodeSecondaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 初始化游戏引擎的调试管理器，设置系统调试的基础设施。
 * 该函数负责创建调试管理的基本结构，为系统调试和日志记录做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立调试管理的基础
 */
void InitializeSystemDebugManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *debugInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  debugInitializationCallback = SystemDebugCallback;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件处理器
 * 
 * 初始化游戏引擎的事件处理器，设置事件处理的基础设施。
 * 该函数负责创建事件处理的基本结构，为系统事件的管理和分发做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立事件处理的基础
 */
void InitializeSystemEventHandler(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 初始化游戏引擎的网络管理器，设置网络通信的基础设施。
 * 该函数负责创建网络管理的基本结构，为系统网络通信做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立网络管理的基础
 */
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统安全管理器
 * 
 * 初始化游戏引擎的安全管理器，设置系统安全的基础设施。
 * 该函数负责创建安全管理的基本结构，为系统安全验证和权限控制做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立安全管理的基础
 */
void InitializeSystemSecurityManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表结构A
 * 
 * 该函数负责初始化系统数据表的基本结构，设置数据表的根节点和初始状态。
 * 它会在系统中创建一个新的数据表结构，用于存储系统运行时的数据。
 * 
 * @note 该函数在系统启动时被调用，是系统初始化过程的重要组成部分。
 */
void InitializeSystemDataTableStructureA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器组件，设置资源分配的基础结构。
 * 它会创建资源管理节点，配置资源分配回调函数，并建立资源标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* systemCallbackData;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackData = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能数据收集的基础结构。
 * 它会创建性能监控节点，配置性能数据回调函数，并建立性能监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemPerformanceCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemPerformanceCallback = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = systemPerformanceCallback;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理组件，设置调试功能的基础结构。
 * 它会创建调试管理节点，配置调试回调函数，并建立调试功能标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试系统的正常运行
 */
void InitializeSystemDebugManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* systemDebugData;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemDebugData = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理组件，设置字符串操作的基础结构。
 * 它会创建字符串处理缓冲区，配置字符串复制操作，并建立字符串处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessor(void)

{
  long long StringParameter;
  void* *CallbackPointer;
  uint8_t *DataBufferPointer;
  int BufferSize;
  uint8_t DataBuffer [136];
  
  CallbackPointer = &SystemStringProcessorNode;
  DataBufferPointer = DataBuffer;
  DataBuffer[0] = 0;
  BufferSize = 8;
  strcpy_s(DataBuffer,0x80,&SystemStringProcessorTemplate,StringParameter,0xfffffffffffffffe);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&CallbackPointer);
  return;
}




/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统的数据管理组件，设置数据处理的基础结构。
 * 它会创建数据管理节点，配置数据操作回调函数，并建立数据管理标识符。
 * 
 * @return 初始化结果状态码
 * @note 这是系统初始化过程中的重要组成部分，确保数据管理系统的正常运行
 */
int InitializeSystemDataManager(void)

{
  long long SystemDataOffset;
  void* SystemParameter;
  
  SystemConfigDataPointerE = &SystemGlobalDataPointerB;
  SystemConfigDataPointerG = &SystemConfigDataPointerH;

// 函数: void InitializeSystemEventManager(void)
/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理组件，设置事件处理的基础结构。
 * 它会创建事件管理节点，配置事件处理回调函数，并建立事件管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char NodeFlag;
  void* *DataTable;
  int MemoryComparisonResult;
  long long *MemoryPointer;
  long long TimeValue;
  void* *RootNode;
  void** CurrentNode;
  void** NextNode;
  void** PreviousNode;
  code *eventCallbackPointer;
  
  DataTable = (long long*)GetSystemRootPointer();
  RootNode = (void* *)*DataTable;
  NodeFlag = *(char*)((long long)RootNode[1] + 0x19);
  eventCallbackPointer = SystemEventCallback;
  PreviousNode = RootNode;
  CurrentNode = (void* *)RootNode[1];
  while (NodeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (MemoryComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateD,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(DataTable);
    AllocateSystemMemory(DataTable,&SystemAllocatedNode,PreviousNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    PreviousNode = SystemAllocatedNode;
  }
  PreviousNode[6] = 0x406be72011d07d37;
  PreviousNode[7] = 0x71876af946c867ab;
  PreviousNode[8] = &SystemDataNodeTertiaryRoot;
  PreviousNode[9] = 0;
  PreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络通信的基础结构。
 * 它会创建网络管理节点，配置网络通信回调函数，并建立网络管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char NodeFlag;
  void* *dataTable;
  int MemoryComparisonResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void** CurrentNode;
  void** NextNode;
  void** PreviousNode;
  code *networkCallbackPointer;
  
  dataTable = (long long*)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  NodeFlag = *(char*)((long long)rootNode[1] + 0x19);
  networkCallbackPointer = SystemNetworkCallback;
  PreviousNode = rootNode;
  CurrentNode = (void* *)rootNode[1];
  while (NodeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (MemoryComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == rootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateG,PreviousNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** AllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&AllocatedNode,PreviousNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x40afa5469b6ac06d;
  PreviousNode[7] = 0x2f4bab01d34055a5;
  PreviousNode[8] = &SystemDataNodeQuaternaryRoot;
  PreviousNode[9] = 3;
  PreviousNode[10] = networkCallbackPointer;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理器节点，用于管理系统配置信息。
 * 它会在系统数据表中查找或创建配置管理器节点，并设置相关的配置参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理器正确建立
 */
void InitializeSystemConfigurationManager(void)

{
  char NodeFlag;
  void* *dataTable;
  int MemoryComparisonResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void** CurrentNode;
  void** NextNode;
  void** PreviousNode;
  code *initializationFunction;
  
  dataTable = (long long*)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  NodeFlag = *(char*)((long long)rootNode[1] + 0x19);
  initializationFunction = GetSystemConfigurationManagerFunction;
  PreviousNode = rootNode;
  CurrentNode = (void* *)rootNode[1];
  while (NodeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentNode + 4,&CONFIGURATION_MANAGER_ID,0x10);
    if (MemoryComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == rootNode) || (MemoryComparisonResult = memcmp(&CONFIGURATION_MANAGER_ID,PreviousNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** AllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&AllocatedNode,PreviousNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x406be72011d07d37;
  PreviousNode[7] = 0x71876af946c867ab;
  PreviousNode[8] = &ConfigurationManagerNodeData;
  PreviousNode[9] = 0;
  PreviousNode[10] = initializationFunction;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器节点，用于管理系统资源分配和释放。
 * 它会在系统数据表中查找或创建资源管理器节点，并设置相关的资源管理参数。
 * 
 * @note 这是系统初始化过程中的关键组成部分，确保资源管理器正确建立
 */
void InitializeSystemResourceManager(void)

{
  char NodeFlag;
  void* *dataTable;
  int MemoryComparisonResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void** CurrentNode;
  void** NextNode;
  void** PreviousNode;
  code *initializationFunction;
  
  dataTable = (long long*)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  NodeFlag = *(char*)((long long)rootNode[1] + 0x19);
  initializationFunction = GetSystemResourceManagerFunction;
  PreviousNode = rootNode;
  CurrentNode = (void* *)rootNode[1];
  while (NodeFlag == '\0') {
    MemoryComparisonResult = memcmp(CurrentNode + 4,&RESOURCE_MANAGER_ID,0x10);
    if (MemoryComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + 0x19);
  }
  if ((PreviousNode == rootNode) || (MemoryComparisonResult = memcmp(&RESOURCE_MANAGER_ID,PreviousNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** AllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&AllocatedNode,PreviousNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[6] = 0x40afa5469b6ac06d;
  PreviousNode[7] = 0x2f4bab01d34055a5;
  PreviousNode[8] = &ResourceManagerNodeData;
  PreviousNode[9] = 3;
  PreviousNode[10] = initializationFunction;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理器节点，用于管理系统事件的分发和处理。
 * 它会在系统数据表中查找或创建事件管理器节点，并设置相关的事件处理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理器正确建立
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *systemInitializationFunction;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = GetSystemEventManagerFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&EVENT_MANAGER_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&EVENT_MANAGER_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &EventManagerNodeData;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统的数据管理器节点，用于管理系统数据的存储和检索。
 * 它会在系统数据表中查找或创建数据管理器节点，并设置相关的数据管理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据管理器正确建立
 */
void InitializeSystemDataManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *systemInitializationFunction;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = GetSystemDataManagerFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&DATA_MANAGER_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&DATA_MANAGER_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &DataManagerNodeData;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点，用于管理系统资源的分配和释放。
 * 它会在系统数据表中查找或创建资源节点，并设置相关的资源管理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源节点正确建立
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* systemResourceFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemResourceFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&RESOURCE_NODE_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&RESOURCE_NODE_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &ResourceNodeData;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统节点管理器
 * 
 * 该函数负责初始化系统的节点管理组件，设置节点操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点管理系统的正常运行
 */
void InitializeSystemNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* nodeManagerCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  nodeManagerCallbackPointer = SystemNodeManagerCallback;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
/**
 * @brief 初始化系统数据节点管理器
 * 
 * 该函数负责初始化系统的数据节点管理组件，设置数据节点操作的基础结构。
 * 它会遍历系统数据节点树，进行内存比较，分配必要的内存，并设置数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据节点管理系统的正常运行
 */
void InitializeSystemDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统资源节点管理器
 * 
 * 该函数负责初始化系统的资源节点管理组件，设置资源节点操作的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源节点管理系统的正常运行
 */
void InitializeSystemResourceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemMemoryNodeManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理组件，设置内存节点操作的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存节点管理系统的正常运行
 */
void InitializeSystemMemoryNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemStringConfigurationManager(void)
/**
 * @brief 初始化系统字符串配置管理器
 * 
 * 该函数负责初始化系统的字符串配置管理组件，设置字符串配置操作的基础结构。
 * 它会创建字符串配置缓冲区，配置字符串复制操作，并建立字符串配置标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串配置管理系统的正常运行
 */
void InitializeSystemStringConfigurationManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xb;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemConfigurationTemplateA,SystemRegisterValue,0xfffffffffffffffe);
  SystemGlobalDataProcessorResult = SystemGlobalDataProcessor(&SystemDataPointer);
  return;
}




/**
 * @brief 初始化系统配置节点管理器
 * 
 * 该函数负责初始化系统的配置节点管理组件，设置配置节点操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置节点管理系统的正常运行
 */
void InitializeSystemConfigurationNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件节点管理器
 * 
 * 该函数负责初始化系统的事件节点管理组件，设置事件节点操作的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件节点管理系统的正常运行
 */
void InitializeSystemEventNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统资源管理器的节点结构，包括内存分配、
 * 节点链接和回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的资源节点。
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void* SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (void*)GetSystemRootPointer();
  SystemRootNode = (void**)*(long long*)SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp((void*)((long long)SystemCurrentNode + 4),&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((SystemCurrentNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,(void*)((long long)SystemCurrentNode + 4),0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void** SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  SystemCurrentNode[6] = 0x4b2d79e470ee4e2c;
  SystemCurrentNode[7] = 0x9c552acd3ed5548d;
  SystemCurrentNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  SystemCurrentNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统事件管理器的节点结构，包括内存分配、
 * 节点链接和事件回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的事件节点。
 */
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void *SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void *SystemRootNode;
  void *SystemCurrentNode;
  void *SystemNextNode;
  void *HashBucketNode;
  void *SystemValidationCallback;
  
  SystemDataTable = (void*)GetSystemRootPointer();
  SystemRootNode = (void *)*(long long *)SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemValidationCallback = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp((void*)((long long)SystemCurrentNode + 4),&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((SystemCurrentNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,(void*)((long long)SystemCurrentNode + 4),0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void *SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  SystemCurrentNode[6] = 0x49086ba08ab981a7;
  SystemCurrentNode[7] = 0xa9191d34ad910696;
  SystemCurrentNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存节点
 * 
 * 该函数负责初始化系统内存管理器的节点结构，包括内存分配、
 * 节点链接和内存管理回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的内存节点。
 */
void InitializeSystemMemoryNode(void)

{
  char SystemNodeFlag;
  void *SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void *SystemRootNode;
  void *SystemCurrentNode;
  void *SystemNextNode;
  void *HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (void*)GetSystemRootPointer();
  SystemRootNode = (void *)*(long long *)SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp((void*)((long long)SystemCurrentNode + 4),&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((SystemCurrentNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,(void*)((long long)SystemCurrentNode + 4),0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void *SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  SystemCurrentNode[6] = 0x402feffe4481676e;
  SystemCurrentNode[7] = 0xd4c2151109de93a0;
  SystemCurrentNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  SystemCurrentNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeRenderingSystem(void)
/**
 * @brief 初始化渲染系统
 * 
 * 该函数负责初始化游戏渲染系统，设置渲染相关的系统节点和数据结构。
 * 通过遍历系统节点链表来配置渲染系统的初始化参数。
 */
void InitializeRenderingSystem(void)

{
  bool SystemNodeIsActive;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* RenderingInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





/**
 * @brief 初始化系统消息处理器
 * 
 * 该函数负责初始化系统的消息处理组件，设置消息操作的基础结构。
 * 它会创建消息处理缓冲区，配置消息回调函数，并建立消息处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保消息处理系统的正常运行
 */
void InitializeSystemMessageProcessor(void)

{
  void* SystemContextParameter;
  void* *messageProcessorReference;
  uint8_t *MessageConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t MessageConfigurationBuffer [136];
  
  messageProcessorReference = &SystemMessageProcessorNode;
  MessageConfigurationBuffer = MessageConfigurationBuffer;
  MessageConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 10;
  strcpy_s(MessageConfigurationBuffer,0x80,&SystemMessageProcessorTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemMessageProcessorHandle = InitializeMessageProcessorCallback(&messageProcessorReference);
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理组件，设置调试操作的基础结构。
 * 它会创建调试管理节点，配置调试回调函数，并建立调试管理标识符。
 * 
 * @return 初始化结果状态码
 * @note 这是系统初始化过程中的重要组成部分，确保调试管理系统的正常运行
 */
int InitializeSystemDebugManager(void)

{
  long long DebugManagerStatus;
  void* SystemRegisterValue;
  
  SystemConfigDataPointerF = &SystemGlobalDataPointerB;
  SystemGlobalDataReferenceA = &SystemGlobalDataBufferA;

/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志操作的基础结构。
 * 它会创建日志处理缓冲区，配置日志回调函数，并建立日志处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  void* SystemContextParameter;
  void* *logManagerReference;
  uint8_t *LogConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t LogConfigurationBuffer [136];
  
  logManagerReference = &SystemLogManagerNode;
  LogConfigurationBuffer = LogConfigurationBuffer;
  LogConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 9;
  strcpy_s(LogConfigurationBuffer,0x80,&SystemLogManagerTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemLogManagerHandle = InitializeLogManagerCallback(&logManagerReference);
  return;
}





/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控的基础结构。
 * 它会创建性能监控缓冲区，配置性能回调函数，并建立性能监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  void* SystemContextParameter;
  void* *performanceMonitorReference;
  uint8_t *PerformanceConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t PerformanceConfigurationBuffer [136];
  
  performanceMonitorReference = &SystemPerformanceMonitorNode;
  PerformanceConfigurationBuffer = PerformanceConfigurationBuffer;
  PerformanceConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 0xf;
  strcpy_s(PerformanceConfigurationBuffer,0x80,&SystemPerformanceMonitorTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemPerformanceMonitorHandle = InitializePerformanceMonitorCallback(&performanceMonitorReference);
  return;
}





/**
 * @brief 初始化系统安全监控器
 * 
 * 该函数负责初始化系统的安全监控组件，设置安全监控的基础结构。
 * 它会创建安全监控缓冲区，配置安全回调函数，并建立安全监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保安全监控系统的正常运行
 */
void InitializeSystemSecurityMonitor(void)

{
  void* SystemContextParameter;
  void* *securityMonitorReference;
  uint8_t *SecurityConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t SecurityConfigurationBuffer [136];
  
  securityMonitorReference = &SystemSecurityMonitorNode;
  SecurityConfigurationBuffer = SecurityConfigurationBuffer;
  SecurityConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 0xc;
  strcpy_s(SecurityConfigurationBuffer,0x80,&SystemSecurityMonitorTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemSecurityMonitorHandle = InitializeSecurityMonitorCallback(&securityMonitorReference);
  return;
}





/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源管理的基础结构。
 * 它会创建资源管理缓冲区，配置资源回调函数，并建立资源管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  void* SystemContextParameter;
  void* *resourceManagerReference;
  uint8_t *ResourceConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t ResourceConfigurationBuffer [136];
  
  resourceManagerReference = &SystemResourceManagerNode;
  ResourceConfigurationBuffer = ResourceConfigurationBuffer;
  ResourceConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 7;
  strcpy_s(ResourceConfigurationBuffer,0x80,&SystemResourceManagerTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemResourceManagerHandle = InitializeResourceManagerCallback(&resourceManagerReference);
  return;
}





/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络管理的基础结构。
 * 它会创建网络管理缓冲区，配置网络回调函数，并建立网络管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  void* SystemContextParameter;
  void* *networkManagerReference;
  uint8_t *NetworkConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t NetworkConfigurationBuffer [136];
  
  networkManagerReference = &SystemNetworkManagerNode;
  NetworkConfigurationBuffer = NetworkConfigurationBuffer;
  NetworkConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 0x13;
  strcpy_s(NetworkConfigurationBuffer,0x80,&SystemNetworkManagerTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemNetworkManagerHandle = InitializeNetworkManagerCallback(&networkManagerReference);
  return;
}




/**
 * @brief 初始化系统存储管理器
 * 
 * 该函数负责初始化系统的存储管理组件，设置存储管理的基础结构。
 * 它会遍历系统存储节点树，进行内存比较，分配必要的内存，并设置存储节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保存储管理系统的正常运行
 */
void InitializeSystemStorageManager(void)

{
  char SystemNodeTraversalFlag;
  void** SystemDataTableReference;
  int MemoryComparisonResult;
  long long *systemMemoryAllocationPointer;
  long long systemTimestamp;
  void** SystemRootStorageNode;
  void** SystemCurrentStorageNode;
  void** SystemNextStorageNode;
  void** SystemPreviousStorageNode;
  void* StorageManagerCallbackFunction;
  
  SystemDataTableReference = (long long*)GetSystemRootPointer();
  SystemRootStorageNode = (void* *)*SystemDataTableReference;
  SystemNodeTraversalFlag = *(char*)((long long)SystemRootStorageNode[1] + 0x19);
  storageManagerCallbackFunction = SystemStorageManagerCallback;
  SystemPreviousStorageNode = SystemRootStorageNode;
  SystemCurrentStorageNode = (void* *)SystemRootStorageNode[1];
  while (SystemNodeTraversalFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentStorageNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextStorageNode = (void* *)SystemCurrentStorageNode[2];
      SystemCurrentStorageNode = SystemPreviousStorageNode;
    }
    else {
      SystemNextStorageNode = (void* *)*SystemCurrentStorageNode;
    }
    SystemPreviousStorageNode = SystemCurrentStorageNode;
    SystemCurrentStorageNode = SystemNextStorageNode;
    SystemNodeTraversalFlag = *(char*)((long long)SystemNextStorageNode + 0x19);
  }
  if ((SystemCurrentStorageNode == SystemRootStorageNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateO,SystemCurrentStorageNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTableReference);
    void** SystemAllocatedStorageNode;
    AllocateSystemMemory(SystemDataTableReference,&systemAllocatedStorageNode,SystemPreviousStorageNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    SystemPreviousStorageNode = systemAllocatedStorageNode;
  }
  SystemCurrentStorageNode[6] = 0x40db4257e97d3df8;
  SystemCurrentStorageNode[7] = 0x81d539e33614429f;
  SystemCurrentStorageNode[8] = &SystemDataNodeN;
  SystemCurrentStorageNode[9] = 4;
  SystemPreviousStorageNode[10] = storageManagerCallbackFunction;
  return;
}




// 函数: void InitializeSystemMemoryManagerNode(void)
/**
 * @brief 初始化系统内存管理器节点
 * 
 * 该函数负责初始化系统的内存管理器节点，设置内存管理的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManagerNode(void)

{
  char SystemNodeTraversalFlag;
  void** SystemDataTableReference;
  int MemoryComparisonResult;
  long long *systemMemoryAllocationPointer;
  long long systemTimestamp;
  void** SystemRootMemoryNode;
  void** SystemCurrentMemoryNode;
  void* *SystemNextMemoryNode;
  void* *SystemPreviousMemoryNode;
  void* MemoryManagerCallbackFunction;
  
  SystemDataTableReference = (long long*)GetSystemRootPointer();
  SystemRootMemoryNode = (void* *)*SystemDataTableReference;
  SystemNodeTraversalFlag = *(char*)((long long)SystemRootMemoryNode[1] + 0x19);
  MemoryManagerCallbackFunction = SystemMemoryManagerCallback;
  SystemPreviousMemoryNode = SystemRootMemoryNode;
  SystemCurrentMemoryNode = (void* *)SystemRootMemoryNode[1];
  while (SystemNodeTraversalFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentMemoryNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextMemoryNode = (void* *)SystemCurrentMemoryNode[2];
      SystemCurrentMemoryNode = SystemPreviousMemoryNode;
    }
    else {
      SystemNextMemoryNode = (void* *)*SystemCurrentMemoryNode;
    }
    SystemPreviousMemoryNode = SystemCurrentMemoryNode;
    SystemCurrentMemoryNode = SystemNextMemoryNode;
    SystemNodeTraversalFlag = *(char*)((long long)SystemNextMemoryNode + 0x19);
  }
  if ((SystemCurrentMemoryNode == SystemRootMemoryNode) || (MemoryComparisonResult = memcmp(&SystemMemoryComparisonTemplate,SystemCurrentMemoryNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTableReference);
    void* *SystemAllocatedMemoryNode;
    AllocateSystemMemory(SystemDataTableReference,&SystemAllocatedMemoryNode,SystemPreviousMemoryNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    SystemPreviousMemoryNode = SystemAllocatedMemoryNode;
  }
  SystemCurrentMemoryNode[6] = 0x4e33c4803e67a08f;
  SystemCurrentMemoryNode[7] = 0x703a29a844ce399;
  SystemCurrentMemoryNode[8] = &SystemDataNodeO;
  SystemCurrentMemoryNode[9] = 3;
  SystemPreviousMemoryNode[10] = MemoryManagerCallbackFunction;
  return;
}




// 函数: void InitializeSystemDataTableNode(void)
/**
 * @brief 初始化系统数据表节点
 * 
 * 该函数负责初始化系统的数据表节点，设置数据表操作的基础结构。
 * 它会遍历系统数据表节点树，进行内存比较，分配必要的内存，并设置数据表节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据表系统的正常运行
 */
void InitializeSystemDataTableNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点，设置配置操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置系统的正常运行
 */
void InitializeSystemConfigurationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventNode(void)
/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统的事件节点，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件系统的正常运行
 */
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNodeTreeProcessor(void)
/**
 * @brief 初始化系统节点树处理器
 * 
 * 该函数负责初始化系统的节点树处理组件，设置节点操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点树处理系统的正常运行
 */
void InitializeSystemNodeTreeProcessor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryPoolManager(void)
/**
 * @brief 初始化系统内存池管理器
 * 
 * 该函数负责初始化系统的内存池管理组件，设置内存池操作的基础结构。
 * 它会遍历系统内存池节点树，进行内存比较，分配必要的内存，并设置内存池属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存池管理系统的正常运行
 */
void InitializeSystemMemoryPoolManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemServiceManager(void)
/**
 * @brief 初始化系统服务管理器
 * 
 * 该函数负责初始化系统的服务管理组件，设置服务操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置服务节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保服务管理系统的正常运行
 */
void InitializeSystemServiceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventHandler(void)
/**
 * @brief 初始化系统事件处理器
 * 
 * 该函数负责初始化系统的事件处理组件，设置事件处理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置事件处理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件处理系统的正常运行
 */
void InitializeSystemEventHandler(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemTaskManager(void)
/**
 * @brief 初始化系统任务管理器
 * 
 * 该函数负责初始化系统的任务管理组件，设置任务操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置任务管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保任务管理系统的正常运行
 */
void InitializeSystemTaskManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDataProcessor(void)
/**
 * @brief 初始化系统数据处理器
 * 
 * 该函数负责初始化系统的数据处理组件，设置数据处理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置数据处理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据处理系统的正常运行
 */
void InitializeSystemDataProcessor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemCommunicationManager(void)
/**
 * @brief 初始化系统通信管理器
 * 
 * 该函数负责初始化系统的通信管理组件，设置通信操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置通信管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保通信管理系统的正常运行
 */
void InitializeSystemCommunicationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerEx(void)
/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理组件，设置内存操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置内存管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理组件，设置线程操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置线程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保线程管理系统的正常运行
 */
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理的基础数据结构。
 * 它会遍历系统节点树，查找资源管理器节点，并进行相应的初始化操作。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void** SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统浮点数计算器
 * 
 * 该函数负责初始化系统的浮点数计算组件，设置浮点运算的基础结构。
 * 它会计算浮点数的平方根值，进行数值归一化处理，并设置浮点计算表。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保浮点计算系统的正常运行
 */
void InitializeSystemFloatingPointCalculator(void)

{
  ulong long loopCounter;
  float *floatTablePointer;
  int MemoryComparisonResult;
  ulong long outerLoopCounter;
  uint innerLoopCounter;
  ulong long baseCounter;
  int rangeOffset;
  float *currentFloatTable;
  float calculatedValue;
  
  currentFloatTable = (float *)SYSTEM_FLOAT_TABLE_START_ADDRESS;
  baseCounter = 0;
  rangeOffset = -3;
  outerLoopCounter = baseCounter;
  do {
    if (0 < (long long)outerLoopCounter) {
      int innerOffset = -3;
      loopCounter = baseCounter;
      floatTablePointer = currentFloatTable;
      do {
        calculatedValue = 0.0;
        if (-1 < (long long)loopCounter) {
          if ((long long)loopCounter < 3) {
            calculatedValue = 0.75;
          }
          else {
            calculatedValue = 1.0 - (float)innerOffset / (float)rangeOffset;
            calculatedValue = SQRT(calculatedValue) * calculatedValue;
          }
        }
        *floatTablePointer = calculatedValue;
        innerOffset = innerOffset + 1;
        floatTablePointer = floatTablePointer + 1;
        loopCounter = loopCounter + 1;
      } while ((long long)loopCounter < (long long)outerLoopCounter);
    }
    rangeOffset = rangeOffset + 1;
    outerLoopCounter = outerLoopCounter + 1;
    currentFloatTable = currentFloatTable + 0x40;
  } while ((long long)currentFloatTable < SYSTEM_FLOAT_TABLE_END_ADDRESS);
  currentFloatTable = (float *)SYSTEM_FLOAT_TABLE_SECOND_START_ADDRESS;
  do {
    innerLoopCounter = (int)baseCounter + 1;
    *currentFloatTable = 1.0 / SQRT((float)baseCounter) + 1.0 / SQRT((float)baseCounter);
    currentFloatTable = currentFloatTable + 1;
    baseCounter = (ulong long)innerLoopCounter;
  } while (innerLoopCounter < 0x40);
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，设置事件处理的基础数据结构。
 * 它会遍历系统节点树，查找事件管理器节点，并进行相应的初始化操作。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *eventHandlerFunction;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  eventHandlerFunction = SystemEventDispatcher;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void** SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSearchManager(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理组件，设置搜索功能的基础结构。
 * 它会遍历系统搜索节点树，进行内存比较，分配必要的内存，并设置搜索节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索管理系统的正常运行
 */
void InitializeSystemSearchManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateE,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x449bafe9b77ddd3c;
  HashBucketNode[7] = 0xc160408bde99e59f;
  HashBucketNode[8] = &SystemDataNodeA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemIndexManager(void)
/**
 * @brief 初始化系统索引管理器
 * 
 * 该函数负责初始化系统的索引管理组件，设置索引功能的基础结构。
 * 它会遍历系统索引节点树，进行内存比较，分配必要的内存，并设置索引节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保索引管理系统的正常运行
 */
void InitializeSystemIndexManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateD,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x406be72011d07d37;
  HashBucketNode[7] = 0x71876af946c867ab;
  HashBucketNode[8] = &SystemDataNodeTertiaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemCacheManager(void)
/**
 * @brief 初始化系统缓存管理器
 * 
 * 该函数负责初始化系统的缓存管理组件，设置缓存功能的基础结构。
 * 它会遍历系统缓存节点树，进行内存比较，分配必要的内存，并设置缓存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保缓存管理系统的正常运行
 */
void InitializeSystemCacheManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateG,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40afa5469b6ac06d;
  HashBucketNode[7] = 0x2f4bab01d34055a5;
  HashBucketNode[8] = &SystemDataNodeQuaternaryRoot;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLogManager(void)
/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志功能的基础结构。
 * 它会遍历系统日志节点树，进行内存比较，分配必要的内存，并设置日志节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemPerformanceMonitor(void)
/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控的基础结构。
 * 它会遍历系统性能监控节点树，进行内存比较，分配必要的内存，并设置性能监控节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源管理的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventDispatcher(void)
/**
 * @brief 初始化系统事件分发器
 * 
 * 该函数负责初始化系统的事件分发组件，设置事件分发的基础结构。
 * 它会遍历系统事件分发节点树，进行内存比较，分配必要的内存，并设置事件分发节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件分发系统的正常运行
 */
void InitializeSystemEventDispatcher(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSecurityManager(void)
/**
 * @brief 初始化系统安全管理器
 * 
 * 该函数负责初始化系统的安全管理组件，设置安全管理的基础结构。
 * 它会遍历系统安全节点树，进行内存比较，分配必要的内存，并设置安全管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保安全管理系统的正常运行
 */
void InitializeSystemSecurityManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置管理的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemNetworkManager(void)
/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络管理的基础结构。
 * 它会遍历系统网络节点树，进行内存比较，分配必要的内存，并设置网络管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStorageManager(void)
/**
 * @brief 初始化系统存储管理器
 * 
 * 该函数负责初始化系统的存储管理组件，设置存储管理的基础结构。
 * 它会遍历系统存储节点树，进行内存比较，分配必要的内存，并设置存储管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保存储管理系统的正常运行
 */
void InitializeSystemStorageManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateO,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40db4257e97d3df8;
  HashBucketNode[7] = 0x81d539e33614429f;
  HashBucketNode[8] = &SystemDataNodeN;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统进程管理器
 * 
 * 该函数负责初始化系统的进程管理组件，设置进程管理的基础结构。
 * 它会遍历系统进程节点树，进行内存比较，分配必要的内存，并设置进程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保进程管理系统的正常运行
 */
void InitializeSystemProcessManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemEventCallbackPointer;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemMemoryComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4e33c4803e67a08f;
  HashBucketNode[7] = 0x703a29a844ce399;
  HashBucketNode[8] = &SystemDataNodeO;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理组件，设置线程管理的基础结构。
 * 它会遍历系统线程节点树，进行内存比较，分配必要的内存，并设置线程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保线程管理系统的正常运行
 */
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventProcessor(void)
// 系统事件处理器初始化函数
// 初始化系统事件处理相关的数据结构和回调函数
void InitializeSystemEventProcessor(void)

{
  char EventNodeFlag;
  void* *eventSystemDataTable;
  int MemoryComparisonResult;
  long long *eventMemoryPointer;
  long long eventSystemTimeValue;
  void* *eventRootNode;
  void* *eventCurrentNode;
  void* *eventNextNode;
  void* *eventPreviousNode;
  code *eventStackPointer;
  
  eventSystemDataTable = (long long*)GetSystemRootPointer();
  eventRootNode = (void* *)*eventSystemDataTable;
  EventNodeFlag = *(char*)((long long)eventRootNode[1] + 0x19);
  eventSearchFunctionPointer = GetSystemSearchFunctionD;
  eventPreviousNode = eventRootNode;
  eventCurrentNode = (void* *)eventRootNode[1];
  while (EventNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      eventNextNode = (void* *)eventCurrentNode[2];
      eventCurrentNode = eventPreviousNode;
    }
    else {
      eventNextNode = (void* *)*eventCurrentNode;
    }
    eventPreviousNode = eventCurrentNode;
    eventCurrentNode = eventNextNode;
    EventNodeFlag = *(char*)((long long)eventNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(eventSystemDataTable);
    AllocateSystemMemory(eventSystemDataTable,&eventAllocatedNode,eventPreviousNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    eventPreviousNode = eventAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  eventPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
// 功能: 初始化系统资源管理器，负责管理系统资源的分配和释放
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
// 功能: 初始化系统内存管理器，负责内存分配、释放和管理
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLogManager(void)
// 功能: 初始化系统日志管理器，负责系统日志的记录和管理
void InitializeSystemLogManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemPerformanceMonitor(void)
// 功能: 初始化系统性能监视器，负责监控系统性能指标
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemSecurityMonitor(void)
// 功能: 初始化系统安全监视器，负责系统安全监控和防护
void InitializeSystemSecurityMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNetworkManager(void)
// 功能: 初始化系统网络管理器，负责网络连接和通信管理
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateE,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x449bafe9b77ddd3c;
  HashBucketNode[7] = 0xc160408bde99e59f;
  HashBucketNode[8] = &SystemDataNodeA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStorageManager(void)
// 功能: 初始化系统存储管理器，负责数据存储和文件系统管理
void InitializeSystemStorageManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerNode(void)
// 功能: 初始化系统内存管理器节点，负责内存管理节点的初始化
void InitializeSystemMemoryManagerNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateO,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40db4257e97d3df8;
  HashBucketNode[7] = 0x81d539e33614429f;
  HashBucketNode[8] = &SystemDataNodeN;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
// 功能: 初始化系统配置管理器，负责系统配置的加载和管理
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemEventCallbackPointer;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemMemoryComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4e33c4803e67a08f;
  HashBucketNode[7] = 0x703a29a844ce399;
  HashBucketNode[8] = &SystemDataNodeO;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
// 功能: 初始化系统线程管理器，负责线程的创建、调度和管理
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateC,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42bea5b911d9c4bf;
  HashBucketNode[7] = 0x1aa83fc0020dc1b6;
  HashBucketNode[8] = &SystemDataNodeSecondaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
// 功能: 初始化系统进程管理器，负责进程的创建、调度和管理
void InitializeSystemProcessManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDeviceManager(void)
// 功能: 初始化系统设备管理器，负责硬件设备的检测和管理
void InitializeSystemDeviceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemServiceManager(void)
// 功能: 初始化系统服务管理器，负责系统服务的启动和管理
void InitializeSystemServiceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDriverManager(void)
// 功能: 初始化系统驱动管理器，负责设备驱动的加载和管理
void InitializeSystemDriverManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统模块管理器
 * 
 * 该函数负责初始化系统模块管理器，包括系统模块的加载、
 * 管理和配置。这是系统初始化过程的重要组成部分。
 * 
 * @return 无返回值
 * @note 此函数在系统启动时调用，用于建立模块管理基础设施
 */
void InitializeSystemModuleManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemComponentManager(void)
// 功能: 初始化系统组件管理器，负责系统组件的注册和管理
void InitializeSystemComponentManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemPluginManager(void)
// 功能: 初始化系统插件管理器，负责系统插件的加载和管理
void InitializeSystemPluginManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置参数的基础结构。
 * 它会创建配置缓冲区，设置配置字符串，并建立配置管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xc;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemConfigurationTemplateB,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry001 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




/**
 * @brief 初始化系统模块加载器
 * 
 * 该函数负责初始化系统的模块加载器组件，设置系统模块加载的基础指针和配置。
 * 它会初始化系统模块相关的全局变量，为后续的模块加载做准备。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化过程中的重要组成部分，确保模块加载系统的正常运行
 */
int InitializeSystemModuleLoader(void)

{
  long long systemModuleStatus;
  void* SystemModuleConfig;
  
  SystemModuleLoaderPrimary = &SystemModuleLoaderConfig;
  SystemModuleLoaderSecondary = &SystemModuleLoaderStatus;

// 函数: void InitializeSystemExtensionManager(void)
// 功能: 初始化系统扩展管理器，负责系统扩展的加载和管理
void InitializeSystemExtensionManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x16;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantA,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry002 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





// 函数: void InitializeSystemLibraryManager(void)
// 功能: 初始化系统库管理器，负责系统库的加载和管理
void InitializeSystemLibraryManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x16;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantB,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry003 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemFrameworkManager(void)
// 功能: 初始化系统框架管理器，负责系统框架的初始化和管理
void InitializeSystemFrameworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统搜索管理器D
 * 
 * 该函数负责初始化系统的搜索管理器组件，设置搜索相关的
 * 数据结构和回调函数。
 */
void InitializeSystemSearchManagerD(void)
{
  char IsSystemNodeActive;
  void** SystemDataTablePointer;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNodePointer;
  void** currentSystemNode;
  void** nextSystemNode;
  void** previousSystemNode;
  void** allocatedSystemNode;
  void* SystemSearchFunctionPointer;
  long long MemoryAllocationSize;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  previousSystemNode = SystemRootNodePointer;
  currentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (IsSystemNodeActive == '\0') {
    MemoryComparisonResult = memcmp(currentSystemNode + 4, &SystemDataComparisonTemplateI, 0x10);
    if (MemoryComparisonResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    IsSystemNodeActive = *(char*)((long long)nextSystemNode + 0x19);
  }
  
  if ((previousSystemNode == SystemRootNodePointer) || 
      (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI, previousSystemNode + 4, 0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &allocatedSystemNode, previousSystemNode, MemoryAllocationSize + 0x20, MemoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x431d7c8d7c475be2;
  previousSystemNode[7] = 0xb97f048d2153e1b0;
  previousSystemNode[8] = &SystemDataNodeF;
  previousSystemNode[9] = 4;
  previousSystemNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEntryPoint(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 初始化系统资源管理器中的资源节点，设置资源节点的配置和回调函数
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存节点
 * 
 * 初始化系统内存管理器中的内存节点，设置内存节点的配置和回调函数
 */
void InitializeSystemMemoryNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *systemInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationCallback = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表节点
 * 
 * 初始化系统数据表管理器中的数据表节点，设置数据表节点的配置和回调函数
 */
void InitializeSystemDataTableNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置节点
 * 
 * 初始化系统配置管理器中的配置节点，设置配置节点的配置数据和回调函数
 */
void InitializeSystemConfigurationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemConfigurationData;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemConfigurationData = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = systemConfigurationData;
  return;
}




// 函数: void InitializeSystemEventNode(void)
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadNode(void)
void InitializeSystemThreadNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateC,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42bea5b911d9c4bf;
  HashBucketNode[7] = 0x1aa83fc0020dc1b6;
  HashBucketNode[8] = &SystemDataNodeSecondaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemPerformanceNode(void)
void InitializeSystemPerformanceNode(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1c;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemInitializationStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry004 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemSecurityNode(void)
void InitializeSystemSecurityNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4fc124d23d41985f;
  HashBucketNode[7] = 0xe2f4a30d6e6ae482;
  HashBucketNode[8] = &GAME_CORE_NODE_DATA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemNetworkNode(void)
void InitializeSystemNetworkNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4770584fbb1df897;
  HashBucketNode[7] = 0x47f249e43f66f2ab;
  HashBucketNode[8] = &SystemResourceNodeTemplateA;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemAudioNode(void)
void InitializeSystemAudioNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateP,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4666df49b97e0f10;
  HashBucketNode[7] = 0x4e4b0d63a6ad1d8f;
  HashBucketNode[8] = &SystemResourceNodeTemplateB;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemInputNode(void)
void InitializeSystemInputNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateQ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46ecbd4daf41613e;
  HashBucketNode[7] = 0xdc42c056bbde8482;
  HashBucketNode[8] = &SystemResourceNodeTemplateC;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemPhysicsNode(void)
void InitializeSystemPhysicsNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemFileSystemNode(void)
void InitializeSystemFileSystemNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDatabaseNode(void)
void InitializeSystemDatabaseNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeStringProcessingSystem(void)
/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置系统配置节点的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeMemoryManagementSystem(void)
/**
 * @brief 初始化系统事件配置管理器
 * 
 * 该函数负责初始化系统的事件配置管理组件，设置事件配置节点的基础结构。
 * 它会遍历系统事件配置节点树，进行内存比较，分配必要的内存，并设置事件配置节点属性。
 * 该函数还负责配置系统事件的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件配置管理系统的正常运行
 */
void InitializeSystemEventConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateR,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x421c3cedd07d816d;
  HashBucketNode[7] = 0xbec25de793b7afa6;
  HashBucketNode[8] = &SystemResourceNodeTemplateD;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeResourceManagementSystem(void)
/**
 * @brief 初始化系统网络配置管理器
 * 
 * 该函数负责初始化系统的网络配置管理组件，设置网络配置节点的基础结构。
 * 它会遍历系统网络配置节点树，进行内存比较，分配必要的内存，并设置网络配置节点属性。
 * 该函数还负责配置系统网络资源的初始化回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络配置管理系统的正常运行
 */
void InitializeSystemNetworkConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateB,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c22bb0c326587ce;
  HashBucketNode[7] = 0x5e3cf00ce2978287;
  HashBucketNode[8] = &SystemResourceNodeTemplateE;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeDataTableManager(void)
/**
 * @brief 初始化系统搜索配置管理器
 * 
 * 该函数负责初始化系统的搜索配置管理组件，设置搜索配置节点的基础结构。
 * 它会遍历系统搜索配置节点树，进行内存比较，分配必要的内存，并设置搜索配置节点属性。
 * 该函数还负责配置系统搜索功能的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索配置管理系统的正常运行
 */
void InitializeSystemSearchConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}





// 函数: void InitializeSystemConfiguration(void)
/**
 * @brief 初始化系统调试信息管理器
 * 
 * 该函数负责初始化系统的调试信息管理组件，设置调试信息的基础结构。
 * 它会配置调试信息的字符串缓冲区，设置调试信息的处理函数，并建立调试信息的管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试信息管理系统的正常运行
 */
void InitializeSystemDebugInfoManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 9;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemConfigurationStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry005 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





// 函数: void InitializeSystemMemoryAllocator(void)
/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志处理的基础结构。
 * 它会配置日志信息的字符串缓冲区，设置日志信息的处理函数，并建立日志信息的管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 8;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemResourceStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry006 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





// 函数: void InitializeSystemStringProcessorA(void)
/**
 * @brief 初始化系统字符串处理器A
 * 
 * 该函数负责初始化系统的字符串处理组件A，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorA(void)

{
  void* SystemRegisterValue;
  void* *SystemStringPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemStringPointer = &SystemStringConstant;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xb;
  strcpy_s(SystemStringBuffer,0x80,&SystemStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemStringProcessorA = SystemStringProcessingCallback(&systemStringPointer);
  return;
}





// 函数: void InitializeSystemStringProcessorB(void)
/**
 * @brief 初始化系统字符串处理器B
 * 
 * 该函数负责初始化系统的字符串处理组件B，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorB(void)

{
  void* SystemRegisterValue;
  void* *SystemStringPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemStringPointer = &SystemStringConstant;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xd;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringTemplateB,SystemRegisterValue,0xfffffffffffffffe);
  SystemStringProcessorB = SystemStringProcessingCallback(&SystemStringPointer);
  return;
}





// 函数: void InitializeSystemStringProcessorC(void)
/**
 * @brief 初始化系统字符串处理器C
 * 
 * 该函数负责初始化系统的字符串处理组件C，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorC(void)

{
  void* SystemRegisterValue;
  void* *SystemStringPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemStringPointer = &SystemStringConstant;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1c;
  strcpy_s(SystemStringBuffer,0x80,&SystemStringTemplateC,SystemRegisterValue,0xfffffffffffffffe);
  SystemStringProcessorC = SystemStringProcessingCallback(&systemStringPointer);
  return;
}





// 函数: void InitializeSystemStringProcessorA(void)
void InitializeSystemStringProcessorA(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x15;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemMemoryStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry007 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





// 函数: void InitializeSystemStringProcessorB(void)
void InitializeSystemStringProcessorB(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xe;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemThreadStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry008 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





/**
 * @brief 初始化系统字符串处理器C
 * 
 * 该函数负责初始化系统的字符串处理组件C，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorC(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1a;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemFileSystemStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry009 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





/**
 * @brief 初始化系统字符串处理器D
 * 
 * 该函数负责初始化系统的字符串处理组件D，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorD(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x13;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemNetworkStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry010 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemStringProcessorE(void)
void InitializeSystemStringProcessorE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorF(void)
void InitializeSystemStringProcessorF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorG(void)
void InitializeSystemStringProcessorG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorH(void)
void InitializeSystemStringProcessorH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorI(void)
void InitializeSystemStringProcessorI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorJ(void)
void InitializeSystemStringProcessorJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorK(void)
void InitializeSystemStringProcessorK(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorL(void)
void InitializeSystemStringProcessorL(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorM(void)
void InitializeSystemStringProcessorM(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorN(void)
void InitializeSystemStringProcessorN(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorO(void)
void InitializeSystemStringProcessorO(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorP(void)
void InitializeSystemStringProcessorP(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorQ(void)
void InitializeSystemStringProcessorQ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorR(void)
void InitializeSystemStringProcessorR(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorS(void)
void InitializeSystemStringProcessorS(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorT(void)
void InitializeSystemStringProcessorT(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorU(void)
void InitializeSystemStringProcessorU(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorV(void)
void InitializeSystemStringProcessorV(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorW(void)
void InitializeSystemStringProcessorW(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorX(void)
void InitializeSystemStringProcessorX(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorY(void)
void InitializeSystemStringProcessorY(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorZ(void)
void InitializeSystemStringProcessorZ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerA(void)
void InitializeSystemMemoryManagerA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerB(void)
void InitializeSystemMemoryManagerB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerC(void)
void InitializeSystemMemoryManagerC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerD(void)
void InitializeSystemMemoryManagerD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerE(void)
void InitializeSystemMemoryManagerE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerF(void)
void InitializeSystemMemoryManagerF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 系统初始化函数 - 内存分配器设置
 * 
 * 该函数负责初始化系统内存分配器，设置内存池和数据结构
 * 用于管理游戏运行时的内存分配和释放
 */
void InitializeSystemMemoryAllocatorSetup(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4fc124d23d41985f;
  HashBucketNode[7] = 0xe2f4a30d6e6ae482;
  HashBucketNode[8] = &GAME_CORE_NODE_DATA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 系统初始化函数 - 数据表配置器
 * 
 * 该函数负责初始化系统数据表配置器，设置数据结构和索引
 * 用于管理游戏运行时的数据存储和检索
 */
void InitializeSystemDataTableConfigurator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4770584fbb1df897;
  HashBucketNode[7] = 0x47f249e43f66f2ab;
  HashBucketNode[8] = &SystemResourceNodeTemplateA;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerG(void)
void InitializeSystemMemoryManagerG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateP,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4666df49b97e0f10;
  HashBucketNode[7] = 0x4e4b0d63a6ad1d8f;
  HashBucketNode[8] = &SystemResourceNodeTemplateB;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerH(void)
void InitializeSystemMemoryManagerH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateQ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46ecbd4daf41613e;
  HashBucketNode[7] = 0xdc42c056bbde8482;
  HashBucketNode[8] = &SystemResourceNodeTemplateC;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerI(void)
void InitializeSystemMemoryManagerI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理组件，设置配置数据节点操作的基础结构。
 * 它会遍历系统配置数据节点树，进行内存比较，分配必要的内存，并设置配置数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置数据节点管理系统的正常运行
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理组件，设置事件数据节点操作的基础结构。
 * 它会遍历系统事件数据节点树，进行内存比较，分配必要的内存，并设置事件数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件数据节点管理系统的正常运行
 */
void InitializeSystemEventDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventSystem(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统资源节点，设置资源节点的相关配置和回调函数。
 * 它会遍历系统资源树，找到合适的位置插入新的资源节点，并设置节点的属性。
 * 
 * @note 这是一个系统资源管理的核心函数，确保资源节点的正确初始化
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemTimerManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理组件，设置内存节点操作的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存节点管理系统的正常运行
 */
void InitializeSystemMemoryNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateR,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x421c3cedd07d816d;
  HashBucketNode[7] = 0xbec25de793b7afa6;
  HashBucketNode[8] = &SystemResourceNodeTemplateD;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemCore(void)
/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理组件，设置设备节点操作的基础结构。
 * 它会遍历系统设备节点树，进行内存比较，分配必要的内存，并设置设备节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保设备节点管理系统的正常运行
 */
void InitializeSystemDeviceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateB,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c22bb0c326587ce;
  HashBucketNode[7] = 0x5e3cf00ce2978287;
  HashBucketNode[8] = &SystemResourceNodeTemplateE;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理组件，设置字符串处理的相关配置。
 * 它会初始化字符串处理所需的数据结构和缓冲区。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessor(void)

{
  void* SystemRegisterValue;
  void* *SystemStackPointerA0;
  uint8_t *SystemStackPointer98;
  uint32_t SystemConfigurationFlag;
  uint8_t SystemStackBuffer88 [136];
  
  SystemStackPointerA0 = &SystemGlobalDataTertiary;
  SystemStackPointer98 = SystemStackBuffer88;
  SystemStackBuffer88[0] = 0;
  SystemConfigurationFlag = 0x16;
  strcpy_s(SystemStackBuffer88,0x80,&SystemSecurityStringTemplate,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry011 = SystemMemoryAllocationFunction(&SystemStackPointerA0);
  return;
}




/**
 * @brief 初始化系统服务管理器
 * 
 * 该函数负责初始化系统的服务管理器组件，设置系统服务管理的基础指针和配置。
 * 它会初始化系统服务相关的全局变量，为后续的服务管理做准备。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化过程中的重要组成部分，确保服务管理系统的正常运行
 */
int InitializeSystemServiceManager(void)

{
  long long systemServiceStatus;
  void* systemServiceConfig;
  
  SystemServiceManagerPrimary = &SystemServiceManagerConfig;
  SystemServiceManagerSecondary = &SystemServiceManagerStatus;

/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理器，设置内存节点的相关配置和状态。
 * 它会初始化内存管理所需的数据结构和节点信息。
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存节点的正确管理
 */
void InitializeSystemMemoryNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4fc124d23d41985f;
  HashBucketNode[7] = 0xe2f4a30d6e6ae482;
  HashBucketNode[8] = &GAME_CORE_NODE_DATA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理器，设置设备节点的相关配置和状态。
 * 它会初始化设备管理所需的数据结构和节点信息。
 * 
 * @note 这是系统设备管理的重要组成部分，确保设备节点的正确管理
 */
void InitializeSystemDeviceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4770584fbb1df897;
  HashBucketNode[7] = 0x47f249e43f66f2ab;
  HashBucketNode[8] = &SystemResourceNodeTemplateA;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理器，设置配置节点的相关配置和状态。
 * 它会初始化配置管理所需的数据结构和节点信息。
 * 
 * @note 这是系统配置管理的重要组成部分，确保配置节点的正确管理
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateP,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4666df49b97e0f10;
  HashBucketNode[7] = 0x4e4b0d63a6ad1d8f;
  HashBucketNode[8] = &SystemResourceNodeTemplateB;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理器，设置事件节点的相关配置和状态。
 * 它会初始化事件管理所需的数据结构和节点信息。
 * 
 * @note 这是系统事件管理的重要组成部分，确保事件节点的正确管理
 */
void InitializeSystemEventDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateQ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46ecbd4daf41613e;
  HashBucketNode[7] = 0xdc42c056bbde8482;
  HashBucketNode[8] = &SystemResourceNodeTemplateC;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryAllocatorNode(void)
/**
 * @brief 初始化系统内存分配器节点
 * 
 * 该函数负责初始化系统的内存分配器节点，设置内存分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入内存分配器节点，
 * 并设置节点的标识符和回调函数。
 */
void InitializeSystemMemoryAllocatorNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点，设置系统配置的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入配置节点，
 * 并设置节点的标识符和配置数据。
 */
void InitializeSystemConfigurationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventNode(void)
/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统的事件节点，设置系统事件处理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入事件节点，
 * 并设置节点的标识符和事件数据。
 */
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceNode(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点，设置系统资源管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源节点，
 * 并设置节点的标识符和资源数据。
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDataNode(void)
/**
 * @brief 初始化系统数据节点
 * 
 * 该函数负责初始化系统的数据节点，设置系统数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据节点，
 * 并设置节点的标识符和数据指针。
 */
void InitializeSystemDataNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateR,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x421c3cedd07d816d;
  HashBucketNode[7] = 0xbec25de793b7afa6;
  HashBucketNode[8] = &SystemResourceNodeTemplateD;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessor(void)
/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理器，设置字符串处理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入字符串处理器节点，
 * 并设置节点的标识符和字符串处理回调函数。
 */
void InitializeSystemStringProcessor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateB,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c22bb0c326587ce;
  HashBucketNode[7] = 0x5e3cf00ce2978287;
  HashBucketNode[8] = &SystemResourceNodeTemplateE;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemMemoryNodeManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理器，设置内存节点管理的基础结构。
 * 它会创建内存节点的标识符，并设置相关的内存管理回调函数。
 */
void InitializeSystemMemoryNodeManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x12;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringTemplateA,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry012 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





// 函数: void InitializeSystemDeviceNodeManager(void)
/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理器，设置设备节点管理的基础结构。
 * 它会创建设备节点的标识符，并设置相关的设备管理回调函数。
 */
void InitializeSystemDeviceNodeManager(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 8;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringTemplateB,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry013 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemConfigurationDataNodeManager(void)
/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理器，设置配置数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入配置数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventDataNodeManager(void)
/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理器，设置事件数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入事件数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemEventDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceDataNodeManager(void)
/**
 * @brief 初始化系统资源数据节点管理器
 * 
 * 该函数负责初始化系统的资源数据节点管理器，设置资源数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemResourceDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDataNodeManager(void)
/**
 * @brief 初始化系统数据节点管理器
 * 
 * 该函数负责初始化系统的数据节点管理器，设置数据节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringDataNodeManager(void)
/**
 * @brief 初始化系统字符串数据节点管理器
 * 
 * 该函数负责初始化系统的字符串数据节点管理器，设置字符串数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入字符串数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemStringDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryDataNodeManager(void)
/**
 * @brief 初始化系统内存数据节点管理器
 * 
 * 该函数负责初始化系统的内存数据节点管理器，设置内存数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入内存数据节点，
 * 并设置节点的标识符和内存管理回调函数。
 */
void InitializeSystemMemoryDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemDeviceDataNodeManager(void)
/**
 * @brief 初始化系统设备数据节点管理器
 * 
 * 该函数负责初始化系统的设备数据节点管理器，设置设备数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入设备数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemDeviceDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统全局数据表
 * 
 * 该函数负责初始化系统的全局数据表指针，设置系统数据访问的入口点。
 * 它会配置全局数据表的引用，确保其他系统组件可以正确访问系统数据。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化的基础步骤，为后续的系统组件初始化提供数据访问支持
 */
int InitializeSystemGlobalDataTable(void)

{
  long long DataTableStatus;
  void* SystemRegisterValue;
  
  SystemGlobalDataPointerD = &SystemMemoryNodeTemplateA;
  SystemGlobalDataReferenceB = &SystemGlobalDataBufferB;

// 函数: void InitializeSystemSearchNodeManager(void)
/**
 * @brief 初始化系统搜索节点管理器
 * 
 * 该函数负责初始化系统的搜索节点管理器，设置搜索节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入搜索节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemSearchNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDebugNodeManager(void)
/**
 * @brief 初始化系统调试节点管理器
 * 
 * 该函数负责初始化系统的调试节点管理器，设置调试节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入调试节点，
 * 并设置节点的标识符和调试回调函数。
 */
void InitializeSystemDebugNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLoggingNodeManager(void)
/**
 * @brief 初始化系统日志节点管理器
 * 
 * 该函数负责初始化系统的日志节点管理器，设置日志节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入日志节点，
 * 并设置节点的标识符和日志回调函数。
 */
void InitializeSystemLoggingNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemPerformanceNodeManager(void)
/**
 * @brief 初始化系统性能节点管理器
 * 
 * 该函数负责初始化系统的性能节点管理器，设置性能节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入性能节点，
 * 并设置节点的标识符和性能监控回调函数。
 */
void InitializeSystemPerformanceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSecurityNodeManager(void)
/**
 * @brief 初始化系统安全节点管理器
 * 
 * 该函数负责初始化系统的安全节点管理器，设置安全节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入安全节点，
 * 并设置节点的标识符和安全检查回调函数。
 */
void InitializeSystemSecurityNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemNetworkNodeManager(void)
/**
 * @brief 初始化系统网络节点管理器
 * 
 * 该函数负责初始化系统的网络节点管理器，设置网络节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入网络节点，
 * 并设置节点的标识符和网络回调函数。
 */
void InitializeSystemNetworkNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadNodeManager(void)
/**
 * @brief 初始化系统线程节点管理器
 * 
 * 该函数负责初始化系统的线程节点管理器，设置线程节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入线程节点，
 * 并设置节点的标识符和线程管理回调函数。
 */
void InitializeSystemThreadNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemProcessNodeManager(void)
/**
 * @brief 初始化系统进程节点管理器
 * 
 * 该函数负责初始化系统的进程节点管理器，设置进程节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入进程节点，
 * 并设置节点的标识符和进程管理回调函数。
 */
void InitializeSystemProcessNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
/**
 * @brief 初始化系统事件管理器G
 * 
 * 该函数负责初始化系统的第七个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDataTableManager(void)
/**
 * @brief 初始化系统事件管理器H
 * 
 * 该函数负责初始化系统的第八个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统事件管理器I
 * 
 * 该函数负责初始化系统的第九个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventManagerJ(void)
// 功能: 初始化系统事件管理器J，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置事件回调指针
void InitializeSystemEventManagerJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventManagerK(void)
// 功能: 初始化系统事件管理器K，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置资源初始化回调
void InitializeSystemEventManagerK(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventManagerL(void)
// 功能: 初始化系统事件管理器L，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置系统回调指针
void InitializeSystemEventManagerL(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemEventManagerM(void)
// 功能: 初始化系统事件管理器M，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置相关系统配置
void InitializeSystemEventManagerM(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemEventManagerN(void)
// 功能: 初始化系统事件管理器N，用于管理特定类型的事件处理
// 该函数会设置系统字符串配置并初始化相关系统组件
void InitializeSystemEventManagerN(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1b;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringTemplateC,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry014 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



/**
 * @brief 初始化系统模块A
 * 
 * 该函数负责初始化系统的A类模块，执行系统预初始化并验证系统配置。
 * 这是系统初始化过程中的重要步骤，确保系统配置的正确性。
 * 
 * @return 返回初始化状态码，0表示成功，非0表示失败
 * @note 此函数在系统启动时调用，用于初始化核心系统组件
 */
int InitializeSystemModuleA(void)

{
  long long systemStatus;
  
  ExecuteSystemPreInitialization();
  systemStatus = ValidateSystemConfiguration(SystemConfigValidatorPrimary);
  return (systemStatus != 0) - 1;
}



/**
 * @brief 初始化系统模块B
 * 
 * 该函数负责初始化系统的B类模块，配置系统模块并验证系统配置。
 * 它会设置系统配置数据表，然后验证配置的正确性。
 * 
 * @return 返回初始化状态码，0表示成功，非0表示失败
 * @note 此函数在系统启动时调用，用于初始化系统配置组件
 */
int InitializeSystemModuleB(void)

{
  long long systemStatus;
  uint8_t SystemConfigBuffer [32];
  
  SystemConfigBuffer[0] = 1;
  ConfigureSystemModule(&SystemConfigDataTableA,SystemConfigBuffer);
  systemStatus = ValidateSystemConfiguration(SystemConfigValidatorSecondary);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleC(void)

{
  long long systemStatus;
  uint8_t SystemConfigBuffer [32];
  
  SystemConfigBuffer[0] = 0;
  ConfigureSystemModule(&SystemConfigDataTableB,SystemConfigBuffer);
  systemStatus = ValidateSystemConfiguration(SystemConfigValidatorTertiary);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleD(void)

{
  long long systemStatus;
  
  systemStatus = ValidateSystemConfiguration(SystemConfigValidatorQuaternary);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleE(void)

{
  long long systemStatus;
  
  InitializeSystemSecurityContext(SYSTEM_SECURITY_CONTEXT_ADDRESS);
  systemStatus = ValidateSystemConfiguration(SystemConfigValidatorQuinary);
  return (systemStatus != 0) - 1;
}




// 函数: void InitializeSystemResourceManagerA(void)
// 功能: 初始化系统资源管理器A，用于管理游戏核心系统资源
// 该函数会创建系统节点并设置游戏核心系统ID和初始化函数
void InitializeSystemResourceManagerA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4fc124d23d41985f;
  HashBucketNode[7] = 0xe2f4a30d6e6ae482;
  HashBucketNode[8] = &GAME_CORE_NODE_DATA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManagerB(void)
// 功能: 初始化系统资源管理器B，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的回调函数
void InitializeSystemResourceManagerB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4770584fbb1df897;
  HashBucketNode[7] = 0x47f249e43f66f2ab;
  HashBucketNode[8] = &SystemResourceNodeTemplateA;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerC(void)
// 功能: 初始化系统资源管理器C，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的配置参数
void InitializeSystemResourceManagerC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateP,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4666df49b97e0f10;
  HashBucketNode[7] = 0x4e4b0d63a6ad1d8f;
  HashBucketNode[8] = &SystemResourceNodeTemplateB;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerD(void)
// 功能: 初始化系统资源管理器D，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的处理函数
void InitializeSystemResourceManagerD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateQ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46ecbd4daf41613e;
  HashBucketNode[7] = 0xdc42c056bbde8482;
  HashBucketNode[8] = &SystemResourceNodeTemplateC;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerE(void)
// 功能: 初始化系统资源管理器E，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的初始化参数
void InitializeSystemResourceManagerE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统配置资源管理器
 * 设置系统配置标识符和相关数据结构
 */
void InitializeSystemResourceManagerF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统事件资源管理器
 * 设置系统事件标识符和相关数据结构
 */
void InitializeSystemResourceManagerG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统资源管理器
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统资源管理器I
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateR,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x421c3cedd07d816d;
  HashBucketNode[7] = 0xbec25de793b7afa6;
  HashBucketNode[8] = &SystemResourceNodeTemplateD;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * 初始化系统资源管理器J
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateB,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c22bb0c326587ce;
  HashBucketNode[7] = 0x5e3cf00ce2978287;
  HashBucketNode[8] = &SystemResourceNodeTemplateE;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





/**
 * 初始化系统资源管理器K
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerK(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x10;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringTemplateD,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry015 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





/**
 * 初始化系统资源管理器L
 * 处理系统资源字符串初始化
 */
void InitializeSystemResourceManagerL(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xf;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantC,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry016 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





/**
 * 初始化系统资源管理器M
 * 处理系统资源字符串初始化
 */
void InitializeSystemResourceManagerM(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x19;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantD,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry017 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





/**
 * 初始化系统资源管理器N
 * 处理系统资源初始化
 */
void InitializeSystemResourceManagerN(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x14;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantE,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryAllocationTableEntry018 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




int InitializeSystemModuleF(void)

{
  long long systemStatus;
  void* SystemRegister;
  
  SystemGlobalDataPointerE = &SystemMemoryNodeTemplateB;
  SystemGlobalDataReferenceC = &SystemGlobalDataBufferC;

/**
 * 初始化系统调试管理器A
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateS,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46c54bc98fc3fc2a;
  HashBucketNode[7] = 0x727b256e3af32585;
  HashBucketNode[8] = &SystemMemoryNodeTemplateC;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统调试管理器B
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateT,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x41ffd0b76c1e136f;
  HashBucketNode[7] = 0x25db30365f277abb;
  HashBucketNode[8] = &SystemMemoryNodeTemplateD;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统调试管理器C
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4fc124d23d41985f;
  HashBucketNode[7] = 0xe2f4a30d6e6ae482;
  HashBucketNode[8] = &GAME_CORE_NODE_DATA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统的资源分配器组件，设置资源分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源分配器节点，
 * 并设置节点的标识符和回调函数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源分配系统的正常运行
 */
void InitializeSystemResourceAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4770584fbb1df897;
  HashBucketNode[7] = 0x47f249e43f66f2ab;
  HashBucketNode[8] = &SystemResourceNodeTemplateA;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表分配器
 * 
 * 该函数负责初始化系统的数据表分配器组件，设置数据表分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据表分配器节点，
 * 并设置节点的标识符和回调函数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据表分配系统的正常运行
 */
void InitializeSystemDataTableAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateP,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4666df49b97e0f10;
  HashBucketNode[7] = 0x4e4b0d63a6ad1d8f;
  HashBucketNode[8] = &SystemResourceNodeTemplateB;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemResourceComponent
// 初始化系统资源组件，负责管理系统资源的分配和释放
void InitializeSystemResourceComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateQ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46ecbd4daf41613e;
  HashBucketNode[7] = 0xdc42c056bbde8482;
  HashBucketNode[8] = &SystemResourceNodeTemplateC;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemAllocatorComponent
// 初始化系统内存分配器组件，负责管理内存分配策略
void InitializeSystemAllocatorComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemConfigurationComponent
// 初始化系统配置组件，负责管理系统配置信息
void InitializeSystemConfigurationComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemCoreComponent
// 初始化系统核心组件，负责管理核心系统功能
void InitializeSystemCoreComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemMemoryComponent
// 初始化系统内存管理组件，负责内存池管理
void InitializeSystemMemoryComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemThreadComponent
// 初始化系统线程组件，负责线程管理和同步
void InitializeSystemThreadComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateR,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x421c3cedd07d816d;
  HashBucketNode[7] = 0xbec25de793b7afa6;
  HashBucketNode[8] = &SystemResourceNodeTemplateD;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemEventComponent
// 初始化系统事件组件，负责事件处理和分发
void InitializeSystemEventComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateB,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c22bb0c326587ce;
  HashBucketNode[7] = 0x5e3cf00ce2978287;
  HashBucketNode[8] = &SystemResourceNodeTemplateE;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemSecurityComponent
// 初始化系统安全组件，负责系统安全策略
void InitializeSystemSecurityComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateS,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46c54bc98fc3fc2a;
  HashBucketNode[7] = 0x727b256e3af32585;
  HashBucketNode[8] = &SystemMemoryNodeTemplateC;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemNetworkComponent
// 初始化系统网络组件，负责网络通信
void InitializeSystemNetworkComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateT,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x41ffd0b76c1e136f;
  HashBucketNode[7] = 0x25db30365f277abb;
  HashBucketNode[8] = &SystemMemoryNodeTemplateD;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemDatabaseComponent
// 初始化系统数据库组件，负责数据存储
void InitializeSystemDatabaseComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateF,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45425dc186a5d575;
  HashBucketNode[7] = 0xfab48faa65382fa5;
  HashBucketNode[8] = &SystemDataNodeM;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemLoggingComponent
// 初始化系统日志组件，负责日志记录
void InitializeSystemLoggingComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateE,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x449bafe9b77ddd3c;
  HashBucketNode[7] = 0xc160408bde99e59f;
  HashBucketNode[8] = &SystemDataNodeA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemPerformanceComponent
// 初始化系统性能监控组件，负责性能分析
void InitializeSystemPerformanceComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateD,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x406be72011d07d37;
  HashBucketNode[7] = 0x71876af946c867ab;
  HashBucketNode[8] = &SystemDataNodeTertiaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemDiagnosticComponent
// 初始化系统诊断组件，负责系统诊断
void InitializeSystemDiagnosticComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateG,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40afa5469b6ac06d;
  HashBucketNode[7] = 0x2f4bab01d34055a5;
  HashBucketNode[8] = &SystemDataNodeQuaternaryRoot;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemDebugComponent
// 初始化系统调试组件，负责调试功能
void InitializeSystemDebugComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemPluginComponent
// 初始化系统插件组件，负责插件管理
void InitializeSystemPluginComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateI,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemDataNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentA(void)
// 功能: 初始化系统子组件A - 负责系统资源初始化回调的设置
// 该函数通过系统根指针遍历系统节点，设置资源初始化相关的回调函数和系统标识
void InitializeSystemSubcomponentA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateJ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemDataNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentB(void)
// 功能: 初始化系统子组件B - 负责系统事件回调的设置
// 该函数通过系统根指针遍历系统节点，设置事件处理相关的回调函数和系统标识
void InitializeSystemSubcomponentB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateK,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDataNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentC(void)
// 功能: 初始化系统子组件C - 负责系统内存管理组件的初始化
// 该函数初始化系统内存管理相关的数据结构和配置参数
void InitializeSystemSubcomponentC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateL,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemDataNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentD(void)
// 功能: 初始化系统子组件D - 负责系统线程管理组件的初始化
// 该函数初始化系统线程管理相关的数据结构和同步机制
void InitializeSystemSubcomponentD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentE(void)
// 功能: 初始化系统子组件E - 负责系统文件管理组件的初始化
// 该函数初始化系统文件管理相关的数据结构和文件句柄
void InitializeSystemSubcomponentE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentF(void)
// 功能: 初始化系统子组件F - 负责系统网络管理组件的初始化
// 该函数初始化系统网络管理相关的数据结构和网络配置
void InitializeSystemSubcomponentF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateC,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42bea5b911d9c4bf;
  HashBucketNode[7] = 0x1aa83fc0020dc1b6;
  HashBucketNode[8] = &SystemDataNodeSecondaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentG(void)
// 功能: 初始化系统子组件G - 负责系统安全管理组件的初始化
// 该函数初始化系统安全管理相关的数据结构和访问控制
void InitializeSystemSubcomponentG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateS,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46c54bc98fc3fc2a;
  HashBucketNode[7] = 0x727b256e3af32585;
  HashBucketNode[8] = &SystemMemoryNodeTemplateC;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentH(void)
// 功能: 初始化系统子组件H - 负责系统日志管理组件的初始化
// 该函数初始化系统日志管理相关的数据结构和日志配置
void InitializeSystemSubcomponentH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateT,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x41ffd0b76c1e136f;
  HashBucketNode[7] = 0x25db30365f277abb;
  HashBucketNode[8] = &SystemMemoryNodeTemplateD;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: int InitializeSystemSynchronizationMechanism(void)
/**
 * @brief 初始化系统同步机制
 * 
 * 该函数负责初始化系统的同步机制，包括互斥锁初始化、
 * 同步数据结构设置和系统同步状态管理。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemSynchronizationMechanism(void)

{
  long long systemInitializationResult;
  
  InitializeSystemSynchronizationData(&SystemSynchronizationDataPrimary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemSynchronizationData(&SystemSynchronizationDataSecondary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemSynchronizationData(&SystemSynchronizationDataTertiary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemMutex(&SystemSynchronizationMutex,2);
  SystemSynchronizationStatusPrimary = 0;
  SystemSynchronizationStatusSecondary = 0;
  SystemSynchronizationStatusTertiary = 0;
  SystemSynchronizationFlagPrimary = 3;
  SystemSynchronizationStatusQuaternary = 0;
  SystemSynchronizationStatusQuinary = 0;
  SystemSynchronizationStatusSenary = 0;
  SystemSynchronizationFlagSecondary = 3;
  SystemSynchronizationStatusSeptenary = 0;
  SystemSynchronizationStatusOctonary = 0;
  SystemSynchronizationFlagTertiary = 3;
  InitializeSystemSynchronizationCore();
  systemInitializationResult = CheckSystemSynchronizationStatus(&SystemSynchronizationControlData);
  return (systemInitializationResult != 0) - 1;
}




// 函数: int InitializeSystemPerformanceMonitor(void)
/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控数据结构
 * 和性能计数器，为系统性能分析提供基础支持。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemPerformanceMonitor(void)

{
  long long systemInitializationResult;
  void* SystemParameter;
  
  SystemPerformanceMonitorData = &SystemPerformanceMonitorConfiguration;
  SystemPerformanceMonitorStatus = &SystemPerformanceMonitorStatusData;

// 函数: void InitializeSystemSubcomponentI(void)
// 功能: 初始化系统子组件I - 负责系统性能监控组件的初始化
// 该函数初始化系统性能监控相关的数据结构和性能计数器
void InitializeSystemSubcomponentI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateS,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46c54bc98fc3fc2a;
  HashBucketNode[7] = 0x727b256e3af32585;
  HashBucketNode[8] = &SystemMemoryNodeTemplateC;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentJ(void)
// 功能: 初始化系统子组件J - 负责系统配置管理组件的初始化
// 该函数初始化系统配置管理相关的数据结构和配置参数
void InitializeSystemSubcomponentJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateT,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x41ffd0b76c1e136f;
  HashBucketNode[7] = 0x25db30365f277abb;
  HashBucketNode[8] = &SystemMemoryNodeTemplateD;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentK(void)
// 功能: 初始化系统子组件K - 负责系统插件管理组件的初始化
// 该函数初始化系统插件管理相关的数据结构和插件接口
void InitializeSystemSubcomponentK(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateS,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46c54bc98fc3fc2a;
  HashBucketNode[7] = 0x727b256e3af32585;
  HashBucketNode[8] = &SystemMemoryNodeTemplateC;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentL(void)
// 功能: 初始化系统子组件L - 负责系统调试管理组件的初始化
// 该函数初始化系统调试管理相关的数据结构和调试工具
void InitializeSystemSubcomponentL(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateT,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x41ffd0b76c1e136f;
  HashBucketNode[7] = 0x25db30365f277abb;
  HashBucketNode[8] = &SystemMemoryNodeTemplateD;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemSubcomponentM(void)
// 功能: 初始化系统子组件M - 负责系统备份管理组件的初始化
// 该函数初始化系统备份管理相关的数据结构和备份策略
void InitializeSystemSubcomponentM(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xd;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantErrorMessageA,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryRegionCacheB = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



/**
 * @brief 初始化系统互斥锁
 * 
 * 该函数负责初始化系统的互斥锁机制，确保多线程环境下的资源同步访问。
 * 它使用 mtx_init_in_situ 函数来初始化互斥锁，并设置适当的同步参数。
 * 
 * @param mutexIdentifier 互斥锁标识符
 * @param mutexType 互斥锁类型
 * @param syncParameter1 同步参数1
 * @param syncParameter2 同步参数2
 * @return int 初始化成功返回0，失败返回-1
 */
int InitializeSystemMutex(void* MutexIdentifier,void* MutexType,void* SyncParameter1,void* SyncParameter2)

{
  long long initializationResult;
  
  _Mtx_init_in_situ(SYSTEM_MUTEX_PRIMARY_ADDRESS,2,SyncParameter1,SyncParameter2,0xfffffffffffffffe);
  initializationResult = InitializeSystemSyncMechanism(SystemSyncCallbackFunction);
  return (initializationResult != 0) - 1;
}




// 函数: void InitializeSystemSubcomponentN(void)
// 功能: 初始化系统子组件N - 负责系统更新管理组件的初始化
// 该函数初始化系统更新管理相关的数据结构和更新机制
void InitializeSystemSubcomponentN(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateS,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46c54bc98fc3fc2a;
  HashBucketNode[7] = 0x727b256e3af32585;
  HashBucketNode[8] = &SystemMemoryNodeTemplateC;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNodeManagerPrimary(void)
/**
 * @brief 初始化系统节点管理器（主节点）
 * 
 * 该函数负责初始化系统的节点管理器主节点，设置节点树结构，
 * 进行内存比较和节点插入操作，确保系统节点管理器的正常运行。
 */
void InitializeSystemNodeManagerPrimary(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateT,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x41ffd0b76c1e136f;
  HashBucketNode[7] = 0x25db30365f277abb;
  HashBucketNode[8] = &SystemMemoryNodeTemplateD;
  HashBucketNode[9] = 2;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSearchManager(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理器，设置搜索相关的数据结构和
 * 搜索函数指针，为系统提供搜索功能支持。
 */
void InitializeSystemSearchManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *systemSearchCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateD,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x406be72011d07d37;
  HashBucketNode[7] = 0x71876af946c867ab;
  HashBucketNode[8] = &SystemDataNodeTertiaryRoot;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统节点管理器
 * 
 * 该函数负责初始化系统的节点管理组件，设置节点管理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点管理系统的正常运行
 */
void InitializeSystemNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateG,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40afa5469b6ac06d;
  HashBucketNode[7] = 0x2f4bab01d34055a5;
  HashBucketNode[8] = &SystemDataNodeQuaternaryRoot;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSyncMechanism(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理组件，设置搜索节点的基础结构。
 * 它会遍历系统搜索节点树，进行内存比较，分配必要的内存，并设置搜索节点属性。
 * 该函数还负责配置系统搜索的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索管理系统的正常运行
 */
void InitializeSystemSearchManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateH,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x43330a43fcdb3653;
  HashBucketNode[7] = 0xdcfdc333a769ec93;
  HashBucketNode[8] = &SystemDataNodeQuinaryRoot;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理组件，设置事件处理节点的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 该函数还负责配置系统事件的回调函数和事件管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *eventSearchFunctionPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  eventSearchFunctionPointer = GetSystemSearchFunctionD;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x431d7c8d7c475be2;
  HashBucketNode[7] = 0xb97f048d2153e1b0;
  HashBucketNode[8] = &SystemEventNodeF;
  HashBucketNode[9] = 4;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源节点的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和资源管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4b2d79e470ee4e2c;
  HashBucketNode[7] = 0x9c552acd3ed5548d;
  HashBucketNode[8] = &SystemResourceNodeG;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统设备管理器
 * 
 * 该函数负责初始化系统的设备管理组件，设置设备节点的基础结构。
 * 它会遍历系统设备节点树，进行内存比较，分配必要的内存，并设置设备节点属性。
 * 该函数还负责配置系统设备的回调函数和设备管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保设备管理系统的正常运行
 */
void InitializeSystemDeviceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  code *deviceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  deviceInitializationCallback = SystemInitializationCallbackB;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDeviceComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDeviceComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x49086ba08ab981a7;
  HashBucketNode[7] = 0xa9191d34ad910696;
  HashBucketNode[8] = &SystemDeviceNodeH;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = deviceEventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理组件，设置内存节点的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 该函数还负责配置系统内存的初始化回调函数和内存管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemMemoryComparisonTemplate,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x402feffe4481676e;
  HashBucketNode[7] = 0xd4c2151109de93a0;
  HashBucketNode[8] = &SystemMemoryNodeI;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = memoryInitializationCallback;
  return;
}




// 函数: 系统数据节点初始化器M
/**
 * @brief 系统数据节点初始化器M
 * 
 * 该函数负责初始化系统数据节点M，在系统数据表中创建和配置
 * 特定的数据节点结构，用于存储系统运行时数据
 */
void SystemDataNodeInitializerM(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemStackPointer = &SystemDataNodeJ;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateM,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4384dcc4b6d3f417;
  HashBucketNode[7] = 0x92a15d52fe2679bd;
  HashBucketNode[8] = &SystemDataNodeK;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源初始化节点
 * 
 * 该函数负责初始化系统资源初始化节点，在系统节点树中查找合适的位置
 * 插入资源初始化节点，并设置节点的标识符和回调函数。
 * 这是系统资源管理的重要组成部分。
 */
void InitializeSystemResourceInitializationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateN,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4140994454d56503;
  HashBucketNode[7] = 0x399eced9bb5517ad;
  HashBucketNode[8] = &SystemDataNodeL;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化游戏核心系统节点
 * 
 * 该函数负责初始化游戏核心系统节点，在系统节点树中查找合适的位置
 * 插入游戏核心系统节点，并设置节点的标识符和事件回调函数。
 * 这是游戏核心系统管理的重要组成部分。
 */
void InitializeGameCoreSystemNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4fc124d23d41985f;
  HashBucketNode[7] = 0xe2f4a30d6e6ae482;
  HashBucketNode[8] = &GAME_CORE_NODE_DATA;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化基础分配器节点
 * 
 * 该函数负责初始化基础分配器节点，在系统节点树中查找合适的位置
 * 插入基础分配器节点，并设置节点的标识符和回调函数。
 * 这是系统内存管理的重要组成部分。
 */
void InitializeBaseAllocatorNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&BASE_ALLOCATOR_ID,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4770584fbb1df897;
  HashBucketNode[7] = 0x47f249e43f66f2ab;
  HashBucketNode[8] = &SystemResourceNodeTemplateA;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表节点
 * 
 * 该函数负责初始化系统数据表节点，在系统节点树中查找合适的位置
 * 插入数据表节点，并设置节点的标识符和回调函数。
 * 这是系统数据管理的重要组成部分。
 */
void InitializeSystemDataTableNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateP,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4666df49b97e0f10;
  HashBucketNode[7] = 0x4e4b0d63a6ad1d8f;
  HashBucketNode[8] = &SystemResourceNodeTemplateB;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 资源初始化回调设置器
/**
 * @brief 资源初始化回调设置器
 * 
 * 该函数负责设置资源初始化的回调函数，配置系统资源管理
 * 的初始化流程，确保资源能够正确加载和初始化
 */
void ResourceInitializationCallbackSetter(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateQ,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x46ecbd4daf41613e;
  HashBucketNode[7] = 0xdc42c056bbde8482;
  HashBucketNode[8] = &SystemResourceNodeTemplateC;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统分配器节点初始化器
/**
 * @brief 系统分配器节点初始化器
 * 
 * 该函数负责初始化系统分配器节点，配置内存分配器的
 * 基础数据结构，为系统内存管理提供支持
 */
void SystemAllocatorNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemAllocatorIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c868a42644030f6;
  HashBucketNode[7] = 0xc29193aa9d9b35b9;
  HashBucketNode[8] = &SystemAllocatorNodeId;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统配置节点初始化器
/**
 * @brief 系统配置节点初始化器
 * 
 * 该函数负责初始化系统配置节点，创建和配置系统的
 * 配置数据结构，用于存储系统运行时的配置信息
 */
void SystemConfigurationNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemConfigurationIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x40ea3a798283cbbb;
  HashBucketNode[7] = 0x7f74eb2c5a7fadae;
  HashBucketNode[8] = &SystemConfigurationData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统事件节点初始化器
/**
 * @brief 系统事件节点初始化器
 * 
 * 该函数负责初始化系统事件节点，创建和配置系统的
 * 事件处理数据结构，用于管理系统事件的分发和处理
 */
void SystemEventNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemEventIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x45b8d074df27d12f;
  HashBucketNode[7] = 0x8d98f4c06880eda4;
  HashBucketNode[8] = &SystemEventData;
  HashBucketNode[9] = 3;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统内存管理节点初始化器
/**
 * @brief 系统内存管理节点初始化器
 * 
 * 该函数负责初始化系统内存管理节点，创建和配置系统的
 * 内存管理数据结构，用于优化内存分配和回收
 */
void SystemMemoryManagementNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemResourceIdentifier,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x42d293584c8cf3e5;
  HashBucketNode[7] = 0x355ffeb2d29e668a;
  HashBucketNode[8] = &SystemRootNodePointer;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统线程管理器初始化器
/**
 * @brief 系统线程管理器初始化器
 * 
 * 该函数负责初始化系统线程管理器，创建和配置系统的
 * 线程管理数据结构，用于管理多线程环境下的任务调度
 */
void SystemThreadManagerInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateR,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x421c3cedd07d816d;
  HashBucketNode[7] = 0xbec25de793b7afa6;
  HashBucketNode[8] = &SystemResourceNodeTemplateD;
  HashBucketNode[9] = 0;
  HashBucketNode[10] = eventCallbackPointer;
  return;
}




// 函数: 系统资源跟踪器初始化器
/**
 * @brief 系统资源跟踪器初始化器
 * 
 * 该函数负责初始化系统资源跟踪器，创建和配置系统的
 * 资源跟踪数据结构，用于监控和管理系统资源的使用情况
 */
void SystemResourceTrackerInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashBucketNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + 0x19);
  SystemInitializationFlag = 0;
  HashBucketNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    MemoryComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (MemoryComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = HashBucketNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    HashBucketNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + 0x19);
  }
  if ((HashBucketNode == SystemRootNode) || (MemoryComparisonResult = memcmp(&SystemDataComparisonTemplateB,HashBucketNode + 4,0x10), MemoryComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,HashBucketNode,MemoryAllocationSize + 0x20,MemoryAllocationSize);
    HashBucketNode = SystemAllocatedNode;
  }
  HashBucketNode[6] = 0x4c22bb0c326587ce;
  HashBucketNode[7] = 0x5e3cf00ce2978287;
  HashBucketNode[8] = &SystemResourceNodeTemplateE;
  HashBucketNode[9] = 1;
  HashBucketNode[10] = resourceInitializationCallback;
  return;
}





// 函数: 系统性能监控器初始化器
/**
 * @brief 系统性能监控器初始化器
 * 
 * 该函数负责初始化系统性能监控器，创建和配置系统的
 * 性能监控数据结构，用于收集和分析系统性能数据
 */
void SystemPerformanceMonitorInitializer(void)

{
  void* SystemRegisterValue;
  void* *SystemDataPointer;
  uint8_t *SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer [136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1b;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantErrorMessageB,SystemRegisterValue,0xfffffffffffffffe);
  SystemMemoryRegionCacheA = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}





// 函数: 系统安全管理器初始化器
/**
 * @brief 系统安全管理器初始化器
 * 
 * 该函数负责初始化系统安全管理器，获取当前进程信息，
 * 为系统安全功能提供基础的进程上下文
 */
void SystemSecurityManagerInitializer(void)

{
  SystemCurrentProcessHandle = GetCurrentProcess();
  return;
}



/**
 * @brief 初始化系统性能计数器
 * 
 * 该函数负责初始化系统的性能计数器组件，设置性能监控的基础结构。
 * 它会调用性能计数器初始化函数，并返回初始化状态。
 * 
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemPerformanceCounters(void)

{
  long long InitializationStatus;
  
  InitializePerformanceCounterHardware();
  InitializationStatus = ValidatePerformanceCounterInitialization(&SystemPerformanceCounterConfig);
  return (InitializationStatus != 0) - 1;
}



/**
 * @brief 初始化系统互斥锁
 * 
 * 该函数负责初始化系统的互斥锁组件，设置线程同步的基础结构。
 * 它会初始化互斥锁，并返回初始化状态。
 * 
 * @param mutexParameter1 互斥锁参数1
 * @param mutexParameter2 互斥锁参数2
 * @param mutexParameter3 互斥锁参数3
 * @param mutexParameter4 互斥锁参数4
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemMutex(void* MutexParameter1,void* MutexParameter2,void* MutexParameter3,void* MutexParameter4)

{
  long long InitializationStatus;
  
  _Mtx_init_in_situ(SYSTEM_MUTEX_SECONDARY_ADDRESS,2,MutexParameter3,MutexParameter4,0xfffffffffffffffe);
  InitializationStatus = ValidateSystemConfiguration(SystemConfigValidatorSenary);
  return (InitializationStatus != 0) - 1;
}



/**
 * @brief 初始化系统信号量
 * 
 * 该函数负责初始化系统的信号量组件，设置线程同步的基础结构。
 * 它会初始化信号量，并返回初始化状态。
 * 
 * @param semaphoreParameter1 信号量参数1
 * @param semaphoreParameter2 信号量参数2
 * @param semaphoreParameter3 信号量参数3
 * @param semaphoreParameter4 信号量参数4
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemSemaphore(void* SemaphoreParameter1,void* SemaphoreParameter2,void* SemaphoreParameter3,void* SemaphoreParameter4)

{
  long long InitializationStatus;
  
  _Mtx_init_in_situ(SYSTEM_MUTEX_TERTIARY_ADDRESS,2,SemaphoreParameter3,SemaphoreParameter4,0xfffffffffffffffe);
  InitializationStatus = ValidateSystemConfiguration(SystemConfigValidatorSeptenary);
  return (InitializationStatus != 0) - 1;
}




/**
 * @brief 初始化系统线程池
 * 
 * 该函数负责初始化系统的线程池组件，设置线程池的基础结构。
 * 它会初始化线程池的全局变量，并返回初始化状态。
 * 
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemThreadPool(void)

{
  long long InitializationStatus;
  
  SystemPerformanceStatusFlag = 3;
  SystemGlobalDataReferenceD = &SystemGlobalDataBufferD;
  SystemPerformanceCounterA = &SystemPerformanceDataBufferA;  // 系统性能计数器数据缓冲区A
  SystemPerformanceCounterB = 0;
  SystemPerformanceCounterC = 0;
  SystemPerformanceCounterD = 0;
  InitializationStatus = ValidateSystemConfiguration(SystemConfigValidatorOctonary);
  return (InitializationStatus != 0) - 1;
}





// 函数: 系统网络管理器初始化器
/**
 * @brief 系统网络管理器初始化器
 * 
 * 该函数负责初始化系统网络管理器，设置网络相关的
 * 基础数据结构和配置，为网络通信功能提供支持
 */
void SystemNetworkManagerInitializer(void)

{
  void* registerR9Value;
  void* *stackPointerParameter;
  uint8_t *StackBufferPointer;
  uint32_t StackBufferSize;
  uint8_t SystemProcessingBuffer [136];
  
  stackPointerParameter = &SystemGlobalDataPointerC;
  StackBufferPointer = StackBuffer;
  SystemProcessingBuffer[0] = 0;
  StackBufferSize = 0x10;
  strcpy_s(SystemProcessingBuffer,0x80,&SystemStringConstantConfigPathC,registerR9Value,0xfffffffffffffffe);
  SystemMemoryRegionCacheC = SystemMemoryAllocationFunction(&stackPointerParameter);
  return;
}




/**
 * 初始化线程本地存储的回调函数表
 * 设置线程本地存储中的函数指针和回调表
 * 
 * @return 成功返回0，失败返回-1
 */
uint64_t InitializeThreadLocalStorageCallbackTable(void)

{
  uint64_t threadLocalStoragePtr;
  int *callbackTable;
  
  threadLocalStoragePtr = *(uint64_t *)((uint64_t)ThreadLocalStoragePointer + (uint64_t)__tls_index * 8);
  *(uint64_t *)(threadLocalStoragePtr + 0x18) = &SystemMemoryAllocatorReference;
  *(uint64_t *)(threadLocalStoragePtr + 0x20) = 0;
  *(uint32_t *)(threadLocalStoragePtr + 0x28) = 0;
  *(uint64_t *)(threadLocalStoragePtr + 0x18) = &SystemGlobalDataReference;
  *(uint64_t *)(threadLocalStoragePtr + 0x30) = 0;
  *(uint64_t *)(threadLocalStoragePtr + 0x20) = 0;
  *(uint32_t *)(threadLocalStoragePtr + 0x28) = 0;
  threadLocalStoragePtr = *(uint64_t *)((uint64_t)ThreadLocalStoragePointer + (uint64_t)__tls_index * 8);
  callbackTable = *(int **)(threadLocalStoragePtr + 0x50);
  if (callbackTable == (int *)0x0) {
    callbackTable = (int *)(threadLocalStoragePtr + 0x60);
  }
  else {
    if (*callbackTable != 0x1e) goto CallbackTableInitializationComplete;
    callbackTable = (int *)malloc(0x100);
    free(0);
    if (callbackTable == (int *)0x0) {
      return 0xffffffff;
    }
    *(uint64_t *)(callbackTable + 2) = *(uint64_t *)(threadLocalStoragePtr + 0x50);
  }
  *callbackTable = 0;
  *(int **)(threadLocalStoragePtr + 0x50) = callbackTable;
CallbackTableInitializationComplete:
  *(code **)(callbackTable + (uint64_t)*callbackTable * 2 + 4) = SystemTableCallbackFunction;
  *callbackTable = *callbackTable + 1;
  return 0;
}





/**
 * 初始化引擎模块A
 * 设置引擎初始化参数和配置
 */
void InitializeEngineModuleA(void)

{
  uint64_t registerR9;
  void *ParameterStackPointer;
  uint8_t *bufferPtr;
  uint32_t bufferSize;
  uint8_t stringBuffer [136];
  
  paramStackPtr = &SystemDataBufferMainTemplateA;
  bufferPtr = stringBuffer;
  stringBuffer[0] = 0;
  bufferSize = 0x17;
  strcpy_s(stringBuffer,0x80,&SystemStringConstantBufferTemplateD,registerR9,0xfffffffffffffffe);
  SystemMemoryRegionCacheD = SystemMemoryAllocationFunction(&paramStackPtr);
  return;
}





/**
 * 初始化引擎模块B
 * 设置引擎初始化参数和配置
 */
void InitializeEngineModuleB(void)

{
  uint64_t registerR9;
  void *ParameterStackPointer;
  uint8_t *bufferPtr;
  uint32_t bufferSize;
  uint8_t stringBuffer [136];
  
  paramStackPtr = &SystemDataBufferMainTemplateA;
  bufferPtr = stringBuffer;
  stringBuffer[0] = 0;
  bufferSize = 0x11;
  strcpy_s(stringBuffer,0x80,&SystemStringConstantBufferSizeE,registerR9,0xfffffffffffffffe);
  SystemMemoryRegionCacheE = SystemMemoryAllocationFunction(&paramStackPtr);
  return;
}




/**
 * 初始化引擎核心系统
 * 设置引擎核心系统的全局变量和初始状态
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeEngineCoreSystem(void)

{
  uint64_t InitializationResult;
  
  SystemPerformanceTimestamp = 3;
  SystemPerformanceCounterE = &SystemPerformanceDataBufferE;  // 系统性能计数器数据缓冲区E
  SystemNetworkBufferPointer = &SystemNetworkDataBuffer;  // 系统网络数据缓冲区
  SystemInitializationStatusFlagA = 0;  // 系统初始化状态标志A
  SystemInitializationStatusFlagB = 0;  // 系统初始化状态标志B
  SystemInitializationStatusFlagC = 0;  // 系统初始化状态标志C
  InitializationResult = ValidateSystemConfiguration(SystemConfigValidatorNonary);
  return (InitializationResult != 0) - 1;
}




/**
 * 初始化系统配置和权限设置
 * 设置系统标志位、初始化权限配置，并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeSystemConfiguration(void)

{
  long long SystemCallbackResult;
  int ConfigurationIndex;
  
  SystemConfigurationSize = 0x100;
  ConfigurationIndex = 0;
  do {
    ConfigureSystemParameters(ConfigurationIndex,0x4000000000000000,0xffff7fff,0);
    ConfigurationIndex = ConfigurationIndex + 1;
  } while (ConfigurationIndex < 0xd);
  *(uint *)(SystemDeviceContextPointer + 0x330) = *(uint *)(SystemDeviceContextPointer + 0x330) | 4;
  SystemDeviceStatusFlag = 0xffffffff;
  SystemCallbackResult = SystemEventCallback(&SystemEventParameterA);
  return (SystemCallbackResult != 0) - 1;
}



/**
 * 初始化引擎模块B
 * 调用引擎初始化函数并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeEngineModuleB(void)

{
  long long CallbackResult;
  
  SystemMemoryManagerInitialize(SYSTEM_MEMORY_MANAGER_ADDRESS);
  CallbackResult = SystemEventCallback(&SystemEventParameterB);
  return (CallbackResult != 0) - 1;
}





/**
 * 设置系统指针A
 * 根据系统配置设置适当的系统指针地址
 * 检查系统状态并选择合适的指针地址
 */
void SetSystemPointerA(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(0);
  SystemDisplayContextA = 0x180be14a8;
  if (systemStatus != 0) {
    SystemDisplayContextA = 0x180be14c0;
  }
  return;
}





/**
 * 设置系统指针B
 * 根据系统配置设置复杂的系统指针地址
 * 首先检查高级配置，然后回退到基础配置
 */
void SetSystemPointerB(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(1);
  if (systemStatus != 0) {
    SystemDisplayContextB = 0x180be15c0;
    return;
  }
  systemStatus = GetSystemStatus(0);
  SystemDisplayContextB = 0x180be14e0;
  if (systemStatus != 0) {
    SystemDisplayContextB = 0x180be1550;
  }
  return;
}





/**
 * 设置渲染系统指针
 * 根据系统配置设置渲染相关的系统指针地址
 */
void SetRenderSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(0);
  SystemAudioContextA = 0x180be1c00;
  if (systemStatus != 0) {
    SystemAudioContextA = 0x180be1c08;
  }
  return;
}





/**
 * 设置音频系统指针
 * 根据系统配置设置音频相关的系统指针地址
 */
void SetAudioSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(0);
  SystemAudioContextB = 0x180be23a0;
  if (systemStatus != 0) {
    SystemAudioContextB = 0x180be23c0;
  }
  return;
}





/**
 * 设置输入系统指针
 * 根据系统配置设置输入相关的系统指针地址
 */
void SetInputSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(0);
  SystemInputContextA = 0x180be2ad8;
  if (systemStatus != 0) {
    SystemInputContextA = 0x180be2af8;
  }
  return;
}





/**
 * 设置物理系统指针
 * 根据系统配置设置物理相关的系统指针地址
 */
void SetPhysicsSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(0);
  PhysicsSystemPointer = 0x180be4710;
  if (systemStatus != 0) {
    PhysicsSystemPointer = 0x180be4728;
  }
  return;
}





/**
 * 设置网络系统指针
 * 根据系统配置设置网络相关的系统指针地址
 * 首先检查高级配置，然后回退到基础配置
 */
void SetNetworkSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(1);
  if (systemStatus != 0) {
    NetworkSystemPointer = 0x180be6078;
    return;
  }
  systemStatus = GetSystemStatus(0);
  NetworkSystemPointer = 0x180be6068;
  if (systemStatus != 0) {
    NetworkSystemPointer = 0x180be6070;
  }
  return;
}



/**
 * 初始化虚拟函数表数组
 * 初始化一个包含16个元素的虚拟函数表数组，并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeVirtualFunctionTableArray(void)

{
  void* *vtablePointer;
  long long VirtualFunctionCounter;
  
  vtablePointer = (void* *)0x180c35590;
  VirtualFunctionCounter = 0x10;
  do {
    SystemVirtualTableInitialize(vtablePointer);
    *vtablePointer = &SystemVirtualTableTemplateA;
    vtablePointer = vtablePointer + 0x2b;
    VirtualFunctionCounter = VirtualFunctionCounter + -1;
  } while (VirtualFunctionCounter != 0);
  VirtualFunctionCounter = ProcessSystemEvent(&SystemEventDataA);
  return (VirtualFunctionCounter != 0) - 1;
}





/**
 * 设置游戏逻辑系统指针
 * 根据系统配置设置游戏逻辑相关的系统指针地址
 */
void SetGameLogicSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(0);
  GameLogicSystemPointer = 0x180bebac8;
  if (systemStatus != 0) {
    GameLogicSystemPointer = 0x180bebad8;
  }
  return;
}





/**
 * 设置UI系统指针
 * 根据系统配置设置UI相关的系统指针地址
 * 按优先级检查不同的系统配置级别
 */
void SetUISystemPointer(void)

{
  int systemStatus;
  
  systemStatus = GetSystemStatus(3);
  if (systemStatus != 0) {
    UISystemPointer = 0x180bebc10;
    return;
  }
  systemStatus = GetSystemStatus(2);
  if (systemStatus != 0) {
    UISystemPointer = 0x180bebbb0;
    return;
  }
  systemStatus = GetSystemStatus(0);
  UISystemPointer = 0x180bebaf0;
  if (systemStatus != 0) {
    UISystemPointer = 0x180bebb50;
  }
  return;
}



/**
 * 初始化调试系统
 * 初始化调试相关的系统组件并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeDebugSystem(void)

{
  long long CallbackResult;
  
  InitializeSystemDatabase(0x180c4f510);
  CallbackResult = ProcessSystemEvent(&SystemEventDataB);
  return (CallbackResult != 0) - 1;
}



/**
 * 初始化线程安全互斥锁
 * 初始化线程安全的互斥锁机制并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeThreadSafetyMutex(void)

{
  long long CallbackResult;
  
  _Mtx_init_in_situ(0x180c82170,2);
  CallbackResult = ProcessSystemEvent(&SystemEventDataC);
  return (CallbackResult != 0) - 1;
}



/**
 * @brief Wots主SDL入口点函数
 * 
 * 这是Wots系统的主SDL入口点函数，负责初始化和启动系统。
 * 
 * @param SystemParameter 系统参数指针
 * @return 无返回值
 * @note 这是系统的主入口函数，处理SDL相关的初始化工作
 */
void WotsMainSDLL(void* SystemParameter)

{
  void* stackVariables [2];
  
  // SDL主入口点初始化

/**
 * 初始化主系统控制器
 * 初始化游戏主系统控制器，处理系统状态和事件管理
 * 
 * @param systemParameter 系统参数
 */
/**
 * @brief 初始化主系统控制器
 * 
 * 此函数负责初始化游戏主系统控制器，处理系统状态和事件管理。
 * 函数会创建系统控制器对象，初始化数据表管理器，并设置系统事件分发器。
 * 
 * @param systemParameter 系统参数，用于配置系统控制器的初始化
 * @note 函数会调用InitializeSystemMemoryPool和InitializeCoreEngine进行基础初始化
 * @note 函数会管理系统全局控制器的生命周期和状态切换
 */
void InitializeMainSystemController(long long systemParameter)
{
  long long SystemObject;
  long long *ControllerPointer;
  bool IsActiveFlag;
  long long *SystemDataBuffer8;
  long long **SystemDataBuffer10;
  long long *SystemDataBuffer18;
  long long* InitializationCounter;
  void* MemoryAllocationFlags;
  
  MemoryAllocationFlags = (void*)0xfffffffffffffffe;
  InitializeSystemMemoryPool();
  InitializationCounter = InitializationCounter + 1;
  InitializeCoreEngine();
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    if ((void* )SystemGlobalControllerPointer == &SystemCoreObjectTemplate) {
      IsActiveFlag = (bool)SystemGlobalControllerPointer[2] != false;
    }
    else {
      IsActiveFlag = (**(code **)((void* )SystemGlobalControllerPointer + 0x68))();
    }
    if (!IsActiveFlag) goto SkipControllerInitialization;
  }
  ControllerPointer = (long long )SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,3,allocationFlags);
  SystemDataBuffer20 = ControllerPointer;
  InitializeSystemDataTableManager(ControllerPointer);
  ControllerPointer = (long long)&SystemVirtualTableTemplateB;
  ControllerPointer[3] = -4;
  SystemDataBuffer10 = (long long )ControllerPointer;
  (**(code **)(ControllerPointer + 0x28))(ControllerPointer);
  SystemDataBuffer10 = (long long )SystemGlobalControllerPointer;
  if (SystemGlobalControllerPointer != (long long )0x0) {
    SystemObject = SystemGlobalControllerPointer;
    SystemGlobalControllerPointer = ControllerPointer;
    (**(code **)(SystemObject + 0x38))();
    ControllerPointer = SystemGlobalControllerPointer;
  }
  SystemGlobalControllerPointer = ControllerPointer;
  if ((void* )SystemGlobalControllerPointer == &SystemVirtualTableTemplateB) {
    if (SystemInitializationFlag != 0) {
      InitializeSystemEventDispatcher();
    }
  }
  else {
    (**(code **)((void* )SystemGlobalControllerPointer + 0x60))();
  }
  ControllerPointer = SystemGlobalControllerPointer;
  SystemDataBuffer18 = SystemGlobalControllerPointer;
  SystemGlobalControllerPointer = (long long )0x0;
  if (ControllerPointer != (long long )0x0) {
    (**(code **)(ControllerPointer + 0x38))();
  }
SkipControllerInitialization:
  SystemThreadSyncBroadcast((void* )(ResourceManagerPointer + 0x20));
  if ((char )(SystemStatusFlagsPointer + 0x1ed) != '\0') {
    ControllerPointer = (long long )SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,3);
    ControllerPointer = (long long)&SystemMemoryTemplateA;
    ControllerPointer = (long long)&SystemMemoryTemplateB;
    (uint32_t )(ControllerPointer + 1) = 0;
    ControllerPointer = (long long)&SystemMemoryTemplateC;
    LOCK();
    (uint8_t )(ControllerPointer + 2) = 0;
    UNLOCK();
    ControllerPointer[3] = -1;
    ControllerPointer = (long long)&SystemMemoryTemplateD;
    ControllerPointer[4] = 0x180c91060;
    SystemDataBuffer20 = ControllerPointer;
    (**(code **)(ControllerPointer + 0x28))(ControllerPointer);
    allocationFlags = SystemAllocationFlagsTemplate;
    SystemDataBuffer10 = &SystemDataBuffer8;
    SystemDataBuffer8 = ControllerPointer;
    (**(code **)(ControllerPointer + 0x28))(ControllerPointer);
    SystemManagerInitialize(allocationFlags,&SystemDataBuffer8);
    (**(code **)(ControllerPointer + 0x38))(ControllerPointer);
  }
  return;
}



/**
 * 内存管理器清理函数
 * 清理内存管理器相关的指针和资源
 * 
 * @param ResourceManagerPointer 内存管理器指针
 * @param cleanupFlags 清理标志
 * @param reservedParam3 保留参数
 * @param reservedParam4 保留参数
 * @return 返回内存管理器指针
 */
void* *
CleanupSystemMemoryManager(void* *memoryManager,ulong long cleanupFlags,void* reservedParam3,void* reservedParam4)

{
  *memoryManager = &SystemMemoryTemplateD;
  *memoryManager = &SystemMemoryTemplateC;
  *memoryManager = &SystemMemoryTemplateB;
  *memoryManager = &SystemMemoryTemplateA;
  if ((cleanupFlags & 1) != 0) {
    free(memoryManager,0x28,reservedParam3,reservedParam4,0xfffffffffffffffe);
  }
  return memoryManager;
}




/**
 * 系统终止函数
 * 终止系统运行，此函数不会返回
 */
void TerminateSystem(void)

{
    SystemDataOperation();
}




/**
 * 设置默认系统指针
 * 设置系统默认的指针地址
 * 
 * @param ResourceManagerPointer 系统指针
 */
void SetDefaultSystemPointer(void* *systemPointer)

{
  *systemPointer = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 初始化系统信息和用户环境
 * 
 * 该函数负责初始化系统信息和用户环境，包括获取计算机名、用户名，
 * 设置系统环境变量和配置参数。这是系统初始化的重要组成部分。
 * 
 * @note 该函数会在系统启动时调用，用于建立基本的系统环境
 */
void InitializeSystemInfoAndUserEnvironment(void)

{
  void* *systemInfoPtr;
  code *systemCallback;
  long long systemHandle;
  int operationResult;
  void* allocationFlags;
  long long *controllerPtr;
  uint8_t StackBuffer248 [32];
  void* *SystemConfigurationTemplatePointer;
  void* *SystemStringTemplatePointer;
  void* *SystemStringTemplatePointer2;
  long long *SystemMemoryOffsetPointer;
  uint32_t GameControllerStatusFlag;
  void* *SystemGlobalDataReferencePointer;
  void* *SystemFunctionPointer;
  uint32_t SystemInitializationFlag;
  ulong long SystemFlags;
  void* *SystemGlobalDataReferencePointer2;
  void* *SystemFunctionPointer2;
  uint32_t SystemDataProcessingFlag;
  ulong long SystemFlags2;
  void* *GameControllerPointer;
  long long SystemMemorySize;
  uint32_t SystemOperationFlags;
  void* SystemMemoryHandle;
  long long *SystemMemoryPointer;
  void* *SystemMemoryTemplatePointer;
  void* *SystemDataBufferPointer;
  uint32_t SystemDataFlags;
  void* SystemDataArray [32];
  long long **ApplicationPointerArray [3];
  uint8_t StackBuffer138 [272];
  ulong long SystemEncryptionKey;
  
  SystemStackFlag = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer248;
  GameControllerStatusFlag = 0;
  if (*(char *)(SystemContextManagerPointer + 0x18) == '\0') {
    InitializeGameController(&GameControllerBuffer);
    (**(code **)(**(long long **)(SystemStatusFlagsPointer + 0x2b0) + 0x98))
              (*(long long **)(SystemStatusFlagsPointer + 0x2b0),&GameControllerBuffer);
    StartInputSystem();
    SystemContextHandle = SystemContextManagerPointer;
    MemoryAllocationSize = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
    AllocatedMemoryPointer = (long long *)AllocateSystemMemory(MemoryAllocationSize,8,SystemContextHandle);
    MemoryBlockPointer = AllocatedMemoryPointer;
    if (AllocatedMemoryPointer != (long long *)0x0) {
      (**(code **)(*AllocatedMemoryPointer + 0x28))(AllocatedMemoryPointer);
    }
    *(uint32_t *)(AllocatedMemoryPointer + 0xd) = 0xbb80073;
    SystemInterfacePointer = *(void* **)(SystemContextHandle + 400);
    InterfaceFunctionPointer = *(code **)*SystemInterfacePointer;
    ComputerNameBufferPointer = &MemoryBufferSize;
    MemoryBufferSize = AllocatedMemoryPointer;
    (**(code **)(*AllocatedMemoryPointer + 0x28))(AllocatedMemoryPointer);
    (*InterfaceFunctionPointer)(SystemInterfacePointer,&MemoryBufferSize);
    (**(code **)(*AllocatedMemoryPointer + 0x38))(AllocatedMemoryPointer);
    ConfigureInputSystem();
    SystemGlobalDataReferencePtr = &SystemGlobalDataReference;
    GlobalDataFlags = 0;
    AlternateStringBuffer = (void* *)0x0;
    SystemDataProcessingFlag = 0;
    SystemGlobalDataReferencePtr2 = &SystemGlobalDataReference;
    GlobalDataFlags2 = 0;
    AlternateStringBuffer2 = (void* *)0x0;
    SystemInitializationFlag = 0;
    StackPointerValue = (long long *)CONCAT44(StackPointerValue._4_4_,0x10);
    OperationResult = GetComputerNameA(ComputerNameBufferPointer,&MemoryBufferSize);
    if (OperationResult == 0) {
      LogSystemError(&SystemStringConstantComputerNameErrorF);
    }
    else {
      if (0xf < ((ulong long)MemoryBufferSize & 0xffffffff)) goto HandleMemoryBufferOverflow;
      *(uint8_t *)((long long)ComputerNameBufferPointer + ((ulong long)MemoryBufferSize & 0xffffffff)) = 0;
      (**(code **)(SystemGlobalDataReferencePtr + 0x10))(&SystemGlobalDataReferencePtr,ComputerNameBufferPointer);
    }
    MemoryBufferSize = (long long *)CONCAT44(MemoryBufferSize._4_4_,0x101);
    OperationResult = GetUserNameA(UserNameBuffer,&MemoryBufferSize);
    if (OperationResult == 0) {
      LogSystemError(&SystemStringConstantUserNameErrorG);
    }
    else {
      if (0x100 < ((ulong long)MemoryBufferSize & 0xffffffff)) {
        ProcessSystemEvent();
HandleMemoryBufferOverflow:
        ProcessSystemEvent();
        ExceptionHandlerFunction = (code *)swi(3);
        (*ExceptionHandlerFunction)();
        return;
      }
      UserNameBuffer[(ulong long)MemoryBufferSize & 0xffffffff] = 0;
      (**(code **)(SystemGlobalDataReferencePtr2 + 0x10))(&SystemGlobalDataReferencePtr2,UserNameBuffer);
    }
    SystemStringTemplatePtr = &SystemStringTemplate;
    if (AlternateStringBuffer2 != (void* *)0x0) {
      SystemStringTemplatePtr = AlternateStringBuffer2;
    }
    SystemStringTemplatePtr2 = &SystemStringTemplate;
    if (AlternateStringBuffer != (void* *)0x0) {
      SystemStringTemplatePtr2 = AlternateStringBuffer;
    }
    SystemConfigurationTemplatePtr = &SystemConfigurationTemplatePrimary;
    SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffffffffffff,4);
    SystemMemoryTemplatePtr = &SystemMemoryTemplateE;
    LocalStackBuffer = StackBuffer170;
    systemFlag178 = 0;
    StackBuffer170[0] = 0;
    GameControllerStatusFlag = 2;
    InitializeGameSettings(&SystemMemoryTemplatePtr,&SystemDataBufferTemplateI,0x130a7);
    SystemStringTemplatePtr2 = &SystemStringTemplate;
    if (LocalStackBuffer != (void* *)0x0) {
      SystemStringTemplatePtr2 = LocalStackBuffer;
    }
    SystemConfigurationTemplatePtr = &SystemConfigurationTemplateSecondary;
    SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffffffffffff,4);
    GameControllerStatusFlag = 0;
    SystemMemoryTemplatePtr = &SystemMemoryAllocatorReference;
    SystemGlobalDataReferencePtr2 = &SystemGlobalDataReference;
    if (AlternateStringBuffer2 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    AlternateStringBuffer2 = (void* *)0x0;
    GlobalDataFlags2 = GlobalDataFlags2 & 0xffffffff00000000;
    SystemGlobalDataReferencePtr2 = &SystemMemoryAllocatorReference;
    SystemGlobalDataReferencePtr = &SystemGlobalDataReference;
    if (AlternateStringBuffer != (void* *)0x0) {
        SystemCleanupFunction();
    }
    AlternateStringBuffer = (void* *)0x0;
    GlobalDataFlags = GlobalDataFlags & 0xffffffff00000000;
    SystemGlobalDataReferencePtr = &SystemMemoryAllocatorReference;
    GameControllerBuffer = &SystemGlobalDataReference;
    if (StackCleanupFlag != 0) {
        SystemCleanupFunction();
    }
    StackCleanupFlag = 0;
    systemFlag1A0 = 0;
    GameControllerBuffer = &SystemMemoryAllocatorReference;
  }
  GameControllerStatusFlag = 0;
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)StackBuffer248);
}





/**
 * @brief 初始化系统调试符号管理器
 * 
 * 该函数负责初始化系统的调试符号处理组件，包括符号表的初始化、
 * 动态库加载、符号搜索路径设置和性能计数器配置。它还会初始化
 * 线程管理器和时间相关功能。
 * 
 * @param systemContext 系统上下文参数
 * @param InitializationFlag 初始化标志
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试功能的正常运行
 */
void InitializeSystemDebugSymbolManager(void* systemContext,long long InitializationFlag)

{
  long long **symbolTablePointer;
  int initializationResult;
  uint symbolFlags;
  uint32_t SymbolOptions;
  void* systemHandle;
  long long *libraryHandle;
  long long performanceFrequency;
  void* *symbolNextNode;
  void* *debugContextPointer;
  void* *threadContextPointer;
  uint8_t* MemoryAllocationFlag;
  char *searchPathPointer;
  void* *stackPointer;
  ulong long systemTimestamp;
  uint stackFlags;
  char ThreadState;
  long long *threadLocalData;
  long long **threadManagerPointer;
  long long performanceCounter;
  void* *StackBufferLarge1;
  void* *StackBufferLarge2;
  uint32_t SystemResourceHandle;
  void* *StackBufferMedium1;
  long long SystemMemorySize;
  uint SystemOperationFlag;
  void* *StackBufferSmall1;
  void* *StackBufferSmall2;
  uint32_t SystemConfigurationFlag;
  void* StackParameter5;
  long long **mutexPointer;
  long long *threadLocalStorage;
  
  StackParameter5 = 0xfffffffffffffffe;
  systemHandle = GetSystemDebugHandle();
  InitializeSystemCore();
  libraryHandle = (long long *)AllocateSystemMemory(SystemMemoryPoolTemplate,0x68,8,3);
  symbolTablePointer = (long long **)(libraryHandle + 1);
  threadLocalData = libraryHandle;
  threadManagerPointer = symbolTablePointer;
  InitializeMutex(symbolTablePointer,2);
  libraryHandle[0xb] = 0;
  libraryHandle[0xc] = 0;
  *(void*2 *)libraryHandle = 0;
  SystemLibraryHandleStorage = libraryHandle;
  if ((char)*libraryHandle != '\0') goto SkipLibraryHandleInitialization;
  mutexPointer = symbolTablePointer;
  initializationResult = LockMutex(symbolTablePointer);
  if (initializationResult != 0) {
    __Throw_C_error_std__YAXH_Z(initializationResult);
  }
  SymSetOptions(0x2017);
  InitializeSystemLogging(&systemGlobalDataPtrB8);
  SearchPathTemplate = &SystemStringTemplate;
  if (CustomSearchPath != (void* *)0x0) {
    SearchPathTemplate = CustomSearchPath;
  }
  SymSetSearchPath(SystemCurrentProcessHandle,SearchPathTemplate);
  LibraryHandle = AllocatedMemoryPointer[0xb];
  if (LibraryHandle == 0) {
    LibraryHandle = LoadLibraryA(&SystemStringConstantLibraryNameH);
    AllocatedMemoryPointer[0xb] = LibraryHandle;
    if (LibraryHandle != 0) goto LibraryHandleLoadedSuccessfully;
    systemGlobalDataPtrB8 = &SystemGlobalDataReference;
    if (alternateBufferPtrB0 != (void* *)0x0) {
        SystemCleanupFunction();
    }
  }
  else {
LibraryHandleLoadedSuccessfully:
    if (AllocatedMemoryPointer[0xc] == 0) {
      FunctionAddress = GetProcAddress(LibraryHandle,&SystemStringConstantFunctionNameI);
      AllocatedMemoryPointer[0xc] = FunctionAddress;
      if (FunctionAddress == 0) {
        systemGlobalDataPtrB8 = &SystemGlobalDataReference;
        if (alternateBufferPtrB0 != (void* *)0x0) {
            SystemCleanupFunction();
        }
        goto SymbolInitializationCleanup;
      }
    }
    SymbolSearchPath = &SystemStringTemplate;
    if (CustomSearchPath != (void* *)0x0) {
      SymbolSearchPath = CustomSearchPath;
    }
    SymbolInitializationResult = SymInitialize(SystemCurrentProcessHandle,SymbolSearchPath,1);
    if (SymbolInitializationResult == 0) {
      systemGlobalDataPtrB8 = &SystemGlobalDataReference;
      if (alternateBufferPtrB0 != (void* *)0x0) {
          SystemCleanupFunction();
      }
    }
    else {
      *(char *)AllocatedMemoryPointer = '\x01';
      systemGlobalDataPtrB8 = &SystemGlobalDataReference;
      if (alternateBufferPtrB0 != (void* *)0x0) {
          SystemCleanupFunction();
      }
    }
  }
SymbolInitializationCleanup:
  UnsignedStackFlagA0 = 0;
  alternateBufferPtrB0 = (void* *)0x0;
  systemGlobalDataPtrB8 = &SystemMemoryAllocatorReference;
  int mutexUnlockResult = _Mtx_unlock(threadMutexPointer);
  if (mutexUnlockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexUnlockResult);
  }
SkipLibraryHandleInitialization:
  void* allocatedMemoryBlock1 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,8,8,3);
  *allocatedMemoryBlock1 = 0;
  void* allocatedMemoryBlock2 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,8,8,3);
  *allocatedMemoryBlock1 = &SystemDebugDataBufferA;
  *allocatedMemoryBlock2 = &SystemDebugDataBufferB;
  void* allocatedMemoryBlock3 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,3);
  uint8_t* allocatedMemoryBlock4 = (uint8_t *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,1,1,3);
  *allocatedMemoryBlock4 = 0;
  allocatedMemoryBlock3[2] = allocatedMemoryBlock4;
  SystemMemoryBlockStorage = allocatedMemoryBlock3;
  *allocatedMemoryBlock3 = allocatedMemoryBlock2;
  allocatedMemoryBlock3[1] = allocatedMemoryBlock1;
  allocatedMemoryBlock3[3] = timerMemoryBlock;
  timerMemoryBlock = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x198,8,3);
  SystemTimerStoragePointer = CreateSystemTimer(timerMemoryBlock);
  counterMemoryBlock = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xa8,8,3);
  SystemCounterStoragePointer = CreateSystemCounter(counterMemoryBlock);
  SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,1,1,3);
  int performanceQueryResult = QueryPerformanceFrequency(&performanceFrequencyData);
  if (performanceQueryResult == 0) {
    InitializeSystemSemaphores(&SystemSemaphoreTemplate);
  }
  SystemPerformanceFrequencyStorage = 1.0 / (double)(long long)performanceFrequencyData;
  timeBeginPeriod(1);
  QueryPerformanceCounter(&performanceCounterData);
  if (SystemPerformanceTimerEnabled != '\0') {
    SystemPerformanceCounterStorage = SystemPerformanceCounterStorage + (performanceCounterData - SystemPerformancePreviousStorage);
  }
  SystemPerformancePreviousStorage = 0;
  SystemPerformanceCurrentStorage = performanceCounterData;

/**
 * 初始化线程管理器
 * 初始化线程管理器并设置线程相关信息
 * 此函数不会返回
 */
void InitializeThreadManager(void)

{
  void* currentThread;
  uint32_t threadResult;
  void* *threadManager;
  void* registerR9;
  void* *errorPtr;
  void* *ThreadStackBuffer60;
  uint32_t ThreadStatusFlags;
  void* ThreadStackPointer50;
  
  errorPtr = &SystemGlobalDataReference;
  ThreadStackPointer50 = 0;
  ThreadStackBuffer60 = (void* *)0x0;
  ThreadStatusFlags = 0;
  threadManager = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,registerR9,0xfffffffffffffffe);
  *(uint8_t *)threadManager = 0;
  ThreadStackBuffer60 = threadManager;
  threadResult = StartSystemThread(threadManager);
  ThreadStackPointer50 = CONCAT44(ThreadStackPointer50._4_4_,threadResult);
  *threadManager = 0x72657472617453;
  ThreadStatusFlags = 7;
  currentThread = GetCurrentThread();
  InitializeSystemThreadContext(currentThread,&errorPtr);
  errorPtr = &SystemGlobalDataReference;
    SystemCleanupFunction(threadManager);
}




/**
 * 最终系统初始化函数
 * 执行最终的系统初始化，等待系统就绪，清理系统资源
 * 
 * @return 初始化结果
 */
uint32_t FinalSystemInitialization(void)

{
  void* *systemPtr;
  code *systemCallback;
  long long **systemController;
  uint32_t initResult;
  int waitResult;
  long long ****systemManager;
  void* allocationFlags;
  long long ****tempManager8;
  long long ***tempManager9;
  long long systemObject;
  char IsActiveFlag;
  long long ****stackManager8;
  long long ***stackManager10;
  long long **stackController18;
  long long ***stackManager20;
  void* systemFlags;
  long long *****systemSuperManager;
  long long ****tempManager14;
  
  systemFlags = 0xfffffffffffffffe;
  if (SystemGlobalControllerPointer != (void* *)0x0) {
    while( true ) {
      if ((void* *)*SystemGlobalControllerPointer == &SystemVirtualTableTemplateB) {
        IsActiveFlag = *(char *)(SystemGlobalControllerPointer + 2) != '\0';
      }
      else {
        IsActiveFlag = (**(code **)((void* *)*SystemGlobalControllerPointer + 0x68))();
      }
      if (IsActiveFlag != '\0') break;
      Sleep(1);
    }
  }
  systemManager = (long long ****)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,3,systemFlags);
  stackManager8 = systemManager;
  InitializeSystemDataTableManager(systemManager);
  *systemManager = (long long ***)&SystemManagerGlobalTable;
  stackManager20 = (long long ***)systemManager;
  (*(code *)(*systemManager)[5])(systemManager);
  systemObject = SystemAllocationFlagsTemplate;
  systemSuperManager = &stackManager8;
  stackManager8 = systemManager;
  (*(code *)(*systemManager)[5])(systemManager);
  SystemManagerInitialize(systemObject,&stackManager8);
  while( true ) {
    if (*systemManager == (long long ***)&SystemManagerGlobalTable) {
      IsActiveFlag = *(char *)(systemManager + 2) != '\0';
    }
    else {
      IsActiveFlag = (*(code *)(*systemManager)[0xd])(systemManager);
    }
    if (IsActiveFlag != '\0') break;
    Sleep(1);
  }
  InitializeSystemManager();
  systemObject = SystemContextManagerPointer;
  allocationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  tempManager8 = (long long ****)AllocateSystemMemory(allocationFlags,2,systemObject);
  tempManager14 = tempManager8;
  if (tempManager8 != (long long ****)0x0) {
    (*(code *)(*tempManager8)[5])(tempManager8);
  }
  systemPtr = *(void* **)(systemObject + 400);
  systemCallback = *(code **)*systemPtr;
  stackManager8 = &stackManager10;
  stackManager10 = (long long ***)tempManager8;
  if (tempManager8 != (long long ****)0x0) {
    (*(code *)(*tempManager8)[5])(tempManager8);
  }
  (*systemCallback)(systemPtr,&stackManager10);
  systemFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,systemFlags,systemSuperManager,tempManager14);
  tempManager9 = (long long ***)AllocateSystemMemory(systemFlags,0,systemObject);
  if (tempManager9 != (long long ***)0x0) {
    (*(code *)(*tempManager9)[5])(tempManager9);
  }
  systemPtr = *(void* **)(systemObject + 400);
  systemCallback = *(code **)*systemPtr;
  stackManager8 = (long long ****)&stackController18;
  stackController18 = (long long **)tempManager9;
  if (tempManager9 != (long long ***)0x0) {
    (*(code *)(*tempManager9)[5])(tempManager9);
  }
  (*systemCallback)(systemPtr,&stackController18);
  ProcessSystemCallback(*(void* *)(systemObject + 400));
  if (tempManager9 != (long long ***)0x0) {
    (*(code *)(*tempManager9)[7])(tempManager9);
  }
  if (tempManager8 != (long long ****)0x0) {
    (*(code *)(*tempManager8)[7])(tempManager8);
  }
  tempManager14 = SystemManagerPointerStorage;
  *(uint8_t *)(SystemManagerPointerStorage[1] + 0x80) = 1;
  while( true ) {
    systemController = *tempManager14[1];
    if (systemController == (long long **)&SystemControllerDefaultTable) {
      IsActiveFlag = *(char *)(tempManager14[1] + 2) != '\0';
    }
    else {
      IsActiveFlag = (*(code *)systemController[0xd])();
    }
    tempManager8 = SystemManagerPointerStorage;
    if (IsActiveFlag != '\0') break;
    Sleep(1);
  }
  stackManager8 = SystemManagerPointerStorage;
  if (SystemManagerPointerStorage != (long long ****)0x0) {
    SystemManagerPointer = __RTCastToVoid(SystemManagerPointerStorage);
    *SystemManagerTable = (long long ***)&SystemManagerCompletionTable;
    PostQueuedCompletionStatus(SystemManagerTable[0x42686],0,0xffffffffffffffff);
    CloseHandle(SystemManagerTable[0x42686]);
    ResourceManagerPointer = (long long ***)(SystemManagerTable + 0x42687);
    if ((long long ***)*ppplStackX_10 != (long long ***)0x0) {
        SystemCleanupFunction();
    }
    ppplStackX_10 = (long long ***)(pppplocalMemoryAddress + 0x4267c);
    _Mtx_destroy_in_situ();
    ppplStackX_10 = (long long ***)(pppplocalMemoryAddress + 0x40070);
    _Mtx_destroy_in_situ();
    ConfigureSystemBuffer(pppplocalMemoryAddress);
    if (allocationFlags != 0) {
        SystemCleanupFunction(allocationFlags);
    }
  }
  pppPrimaryResourcePointer4 = SystemInitializationFlag;
  allocationFlags = SystemAllocationFlagsTemplate;
  SystemManagerPointerStorage = (long long ****)0x0;
  if (SystemAllocationFlagsTemplate != 0) {
    InitializeSystemLogger(SystemAllocationFlagsTemplate);
      SystemCleanupFunction(allocationFlags);
  }
  SystemAllocationFlagsTemplate = 0;
  *(uint32_t *)(SystemInitializationFlag + 0x2d) = 2;
  pppplStackX_8 = pppPrimaryResourcePointer4;
  if (pppPrimaryResourcePointer4 == (long long ****)0x0) {
    SystemInitializationFlag = (long long ****)0x0;
    WaitForSingleObject(SystemSemaphoreHandle,0xffffffff);
    do {
      systemValue = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemValue == 0);
    systemStatus2 = __acrt_iob_func(1);
    fflush(systemStatus2);
    systemStatus2 = __acrt_iob_func(2);
    fflush(systemStatus2);
    unsignedSystemValue4 = SystemGlobalStateStorage;
    (*(code *)(*pppplocalSystemFlags)[7])(pppplocalSystemFlags);
    return unsignedSystemValue4;
  }
  ReleaseSystemResource(pppPrimaryResourcePointer4 + 0x1e);
  ReleaseSystemResource(pppPrimaryResourcePointer4 + 0xf);
  ReleaseSystemResource(pppPrimaryResourcePointer4);
    SystemCleanupFunction(pppPrimaryResourcePointer4);
}



void WotsMain(void* ResourceManagerPointer)

{
  void* LocalStackBuffer [2];
  
                    // 0x45a00  27  WotsMain

/**
 * @brief 执行系统回调函数
 * 
 * 该函数负责执行系统的回调函数，检查参数指针是否有效，然后调用相应的回调函数。
 * 
 * @param callbackParameter 指向回调函数参数的指针
 * @note 这是系统回调机制的重要组成部分，确保回调函数的正确执行
 */
void ExecuteSystemCallback(long long *callbackParameter)

{
  if ((long long *)*callbackParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*callbackParameter + 0x38))();
  }
  return;
}




/**
 * @brief 处理系统字符串复制
 * 
 * 该函数负责处理系统字符串的复制操作，检查源字符串长度，执行字符串复制，
 * 并设置相应的长度标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 * @note 这是系统字符串处理的重要组成部分，确保字符串复制的安全性
 */
void ProcessSystemStringCopy(long long targetBuffer,long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(sourceString + stringLength) != '\0');
  if ((int)stringLength < 0x1000) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
                    000180045b59. Too many branches
                        strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x1000);
    return;
  }
  ProcessSystemStringAllocation(&SystemMemoryTemplateG,0x1000,ConfigurationDataPointer);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 处理系统内存复制
 * 
 * 该函数负责处理系统内存的复制操作，检查复制长度是否安全，执行内存复制，
 * 并设置相应的结束标志。
 * 
 * @param ResourceManagerPointer 目标缓冲区指针
 * @param SourceDataPointer 源数据指针
 * @param BytesToCopy 要复制的字节数
 * @note 这是系统内存处理的重要组成部分，确保内存复制的安全性
 */
void ProcessSystemMemoryCopy(long long ResourceManagerPointer,void* SourceDataPointer,int BytesToCopy)

{
  if (BytesToCopy + 1 < 0x1000) {
      memcpy(*(uint8_t **)(ResourceManagerPointer + 8),SourceDataPointer,(long long)BytesToCopy);
  }
  **(uint8_t **)(ResourceManagerPointer + 8) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
  return;
}




/**
 * @brief 系统内存拷贝操作
 * 
 * 该函数执行系统内存拷贝操作，用于在系统初始化过程中复制内存数据。
 * 
 * @note 这是一个低级别的系统操作函数
 */
void ExecuteSystemMemoryCopyOperation(void)

{
    memcpy();
}




/**
 * @brief 重置系统缓冲区
 * 
 * 该函数负责重置系统缓冲区，将缓冲区内容清零，
 * 并重置相关的偏移量计数器。
 * 
 * @param bufferPointer 指向需要重置的缓冲区的指针
 * @note 这是一个辅助函数，用于清理和重置系统缓冲区状态
 */
void ResetSystemBuffer(uint8_t *bufferPointer)

{
  long long bufferOffset;
  
  *bufferPointer = 0;
  *(uint32_t *)(bufferOffset + 0x10) = 0;
  return;
}




/**
 * @brief 系统初始化完成处理函数
 * 
 * 该函数在系统初始化完成后执行，调用系统的完成处理函数。
 * 
 * @note 这是一个系统完成处理函数，通常在初始化过程结束时调用
 */
void FinalizeSystemInitialization(void)

{
    SystemDataOperation();
}



/**
 * @brief 初始化系统指针池
 * 
 * 该函数负责初始化系统指针池，设置默认的指针地址，
 * 并根据清理标志决定是否释放相关内存资源
 * 
 * @param systemPointerPool 系统指针池指针
 * @param InitializationFlags 初始化标志，用于控制内存清理行为
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回系统指针池指针
 */
void* *
InitializeSystemPointerPool(void* *systemPointerPool,ulong long InitializationFlags,void* reservedParam3,void* reservedParam4)

{
  *systemPointerPool = &SystemMemoryAllocatorReference;
  if ((InitializationFlags & 1) != 0) {
    free(systemPointerPool,0x1018,reservedParam3,reservedParam4,0xfffffffffffffffe);
  }
  return systemPointerPool;
}



/**
 * @brief 清理系统完成端口资源
 * 
 * 该函数负责清理系统的完成端口资源，关闭句柄，销毁互斥体，
 * 并根据标志释放相关内存。这是系统资源清理的重要组成部分。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param cleanupFlags 清理标志，用于控制是否释放内存
 * @return 返回清理后的系统资源指针
 */
void* CleanupSystemCompletionPortResources(void* systemResourcePointer, uint32_t cleanupFlags)

{
  *systemResourcePointer = &SystemCompletionPortTemplate;
  PostQueuedCompletionStatus(systemResourcePointer[0x42686],0,0xffffffffffffffff,0,0xfffffffffffffffe);
  CloseHandle(systemResourcePointer[0x42686]);
  if (systemResourcePointer[0x42687] != 0) {
      TerminateSystemProcess();
  }
  _Mtx_destroy_in_situ();
  _Mtx_destroy_in_situ();
  CleanupSystemResourceData(systemResourcePointer);
  if ((cleanupFlags & 1) != 0) {
    free(systemResourcePointer,0x213458);
  }
  return systemResourcePointer;
}



/**
 * @brief 执行ICALL（内部调用）安全检查
 * 
 * 该函数用于执行内部调用的安全检查，确保调用的合法性
 * 这是.NET运行时安全机制的一部分
 */
void GuardCheckICall(void)

{
  return;
}



/**
 * @brief 系统内存分配器引用管理器
 * 
 * 该函数管理系统内存分配器的引用，根据标志位决定是否释放内存。
 * 
 * @param ResourceManagerPointer 指向内存分配器引用的指针
 * @param MemoryFlags 标志位，控制是否释放内存
 * @param MemoryFreeParam1 内存释放参数1
 * @param MemoryFreeParam2 内存释放参数2
 * @return 返回内存分配器引用指针
 */
void* * SystemMemoryAllocatorReferenceManager(void* *ResourceManagerPointer,ulong long MemoryFlags,void* MemoryFreeParam1,void* MemoryFreeParam2)

{
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  if ((MemoryFlags & 1) != 0) {
    free(ResourceManagerPointer,0x418,MemoryFreeParam1,MemoryFreeParam2,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}




// 函数: void InitializeSystemResources(long long ResourceManagerPointer,long long ResourceFlags)
/**
 * @brief 系统字符串复制处理器
 * 
 * 该函数处理系统字符串复制操作，包括长度验证和安全复制。
 * 当源字符串长度小于0x400时，直接复制；否则调用安全处理函数。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 */
/**
 * @brief 处理系统字符串复制操作
 * 
 * 该函数负责处理系统字符串的复制操作，包括字符串长度计算和
 * 安全复制。当字符串长度超过限制时，会调用字符串分配函数。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 */
void ProcessSystemStringCopy(long long targetBuffer,long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(sourceString + stringLength) != '\0');
  if ((int)stringLength < 0x400) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
                    000180045f19. Too many branches
                        strcpy_s(*(void* *)(targetBuffer + 8),0x400);
    return;
  }
  ProcessSystemStringAllocation(&SystemStringAllocationHandler,0x400,sourceString);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




// 函数: void ProcessSystemConfiguration(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统内存复制处理器
 * 
 * 该函数处理系统内存复制操作，包括边界检查和安全复制。
 * 当复制长度小于0x400时，执行内存复制操作。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 */
void ProcessSystemMemoryCopy(long long targetBuffer,void* sourceData,int copyLength)

{
  if (copyLength + 1 < 0x400) {
      memcpy(*(uint8_t **)(targetBuffer + 8),sourceData,(long long)copyLength);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




// 函数: void ValidateSystemState(void)
/**
 * @brief 执行系统内存复制操作
 * 
 * 该函数执行系统内存复制操作，是一个内存复制的辅助函数。
 */
void ExecuteSystemMemoryCopyOperation(void)

{
    memcpy();
}




// 函数: void SetupSystemMemory(uint8_t *ResourceManagerPointer)
/**
 * @brief 重置系统缓冲区
 * 
 * 该函数重置系统缓冲区，将缓冲区内容清零并重置相关计数器。
 * 
 * @param bufferPointer 缓冲区指针
 */
void ResetSystemBuffer(uint8_t *bufferPointer)

{
  long long systemRegister;
  
  *bufferPointer = 0;
  *(uint32_t *)(systemRegister + 0x10) = 0;
  return;
}





// 函数: void ConfigureSystemParameters(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 处理系统三参数缓冲区操作
 * 
 * 该函数负责处理需要三个参数的系统缓冲区操作，包括内存分配、
 * 数据复制和缓冲区管理。它使用栈缓冲区来处理临时数据，
 * 并执行相应的系统操作。
 * 
 * @param MainParameter 主操作参数
 * @param AuxiliaryParameter 辅助操作参数
 * @param ConfigurationParameter 配置参数
 * 
 * @note 这是一个通用的系统缓冲区处理函数
 */
void ProcessSystemThreeParameterBuffer(long long MainParameter,long long AuxiliaryParameter,long long ConfigurationParameter)

{
  long long StringSearchResult;
  long long StringLengthCounter;
  long long BufferLengthCounter;
  uint8_t StackSecurityBuffer [32];
  void* SystemSecurityFlag;
  void* *SystemMemoryReference;
  uint8_t *SystemBufferPointer;
  uint32_t SystemBufferLength;
  uint8_t SystemDataBuffer [1032];
  ulong long SystemChecksumValue;
  
  SystemSecurityFlag = 0xfffffffffffffffe;
  SystemChecksumValue = SystemEncryptionKeyTemplate ^ (ulong long)StackSecurityBuffer;
  SystemMemoryReference = &SystemMemoryTemplateF;
  SystemBufferPointer = SystemDataBuffer;
  SystemBufferLength = 0;
  SystemDataBuffer[0] = 0;
  StringSearchResult = strstr(*(void* *)(MainParameter + 8));
  if (StringSearchResult != 0) {
    StringLengthCounter = -1;
    BufferLengthCounter = -1;
    do {
      StringLengthCounter = StringLengthCounter + 1;
    } while (*(char *)(AuxiliaryParameter + StringLengthCounter) != '\0');
    do {
      BufferLengthCounter = BufferLengthCounter + 1;
    } while (*(char *)(BufferLengthCounter + ConfigurationParameter) != '\0');
      memcpy(SystemBufferPointer,*(long long *)(MainParameter + 8),StringSearchResult - *(long long *)(MainParameter + 8));
  }
  SystemMemoryReference = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemChecksumValue ^ (ulong long)StackSecurityBuffer);
}




// 函数: void InitializeSystemData(void* *ResourceManagerPointer,uint32_t ConfigurationDataPointer)
/**
 * @brief 释放系统信号量
 * 
 * 该函数负责释放系统信号量，它会重复调用ReleaseSemaphore函数
 * 直到成功释放为止。这确保了信号量的正确释放和系统同步。
 * 
 * @param SemaphoreHandle 信号量句柄指针
 * @param ReleaseCount 释放计数
 * 
 * @note 这是系统同步机制的重要组成部分，确保信号量的正确释放
 */
void ReleaseSystemSemaphore(void* *SemaphoreHandle,uint32_t ReleaseCount)

{
  int ReleaseResult;
  
  do {
    ReleaseResult = ReleaseSemaphore(*SemaphoreHandle,ReleaseCount,0);
  } while (ReleaseResult == 0);
  return;
}




// 函数: void FinalizeSystemSetup(void* *ResourceManagerPointer)
/**
 * @brief 解锁系统互斥锁
 * 
 * 该函数负责解锁系统互斥锁，它会检查互斥锁的状态，
 * 然后调用_Mtx_unlock函数进行解锁操作。如果解锁失败，
 * 会抛出相应的错误。
 * 
 * @param MutexHandle 互斥锁指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确解锁
 */
void UnlockSystemMutex(void* *MutexHandle)

{
  int UnlockResult;
  
  if (*(char *)(MutexHandle + 1) != '\0') {
    UnlockResult = _Mtx_unlock(*MutexHandle);
    if (UnlockResult != 0) {
      __Throw_C_error_std__YAXH_Z(UnlockResult);
    }
  }
  return;
}



/**
 * @brief 等待系统节点就绪
 * 
 * 该函数负责等待系统节点就绪状态，使用互斥锁和条件变量来同步
 * 系统节点的状态变化。这是系统初始化过程中的同步机制。
 * 
 * @param systemNodePointer 系统节点指针
 * @param timeoutParameter 超时参数
 * @param conditionVariable 条件变量
 * @param syncFlag 同步标志
 * @return 成功返回1，失败返回错误代码
 */
uint64_t WaitForSystemNodeReady(long long systemNodePointer, uint64_t timeoutParameter, uint64_t conditionVariable, uint64_t syncFlag)

{
  bool systemNodeReady;
  int mutexLockResult;
  long long mutexHandle;
  uint64_t waitTimeout;
  bool waitFlag;
  
  waitTimeout = 0xfffffffffffffffe;
  mutexHandle = systemNodePointer + 0x48;
  mutexLockResult = _Mtx_lock();
  if (mutexLockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexLockResult);
  }
  waitFlag = true;
  if (*(char *)(systemNodePointer + 0x98) != '\x01') {
    char NodeStatus = *(char *)(systemNodePointer + 0x98);
    while (systemNodeReady == false) {
      mutexLockResult = _Cnd_wait(systemNodePointer,mutexHandle,conditionVariable,syncFlag,waitTimeout,mutexHandle,waitFlag);
      if (mutexLockResult != 0) {
        __Throw_C_error_std__YAXH_Z(mutexLockResult);
      }
      NodeStatus = *(char *)(systemNodePointer + 0x98);
    }
  }
  *(char *)(systemNodePointer + 0x98) = 0;
  mutexLockResult = _Mtx_unlock(mutexHandle);
  if (mutexLockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexLockResult);
  }
  return 1;
}



/**
 * @brief 处理系统节点配置
 * 
 * 该函数负责处理系统节点的配置信息，包括节点回调、参数验证
 * 和配置更新。这是系统配置管理的重要组成部分。
 * 
 * @param nodeConfigPointer 节点配置指针
 * @param parameterBuffer 参数缓冲区
 * @return 返回处理结果状态码
 */
long long ProcessSystemNodeConfiguration(uint32_t* nodeConfigPointer, uint32_t* parameterBuffer)

{
  uint32_t configValue;
  char CallbackResult;
  void* errorStringPointer;
  
  if (*(long long *)(nodeConfigPointer + 0x18) != 0) {
    CallbackResult = (**(code **)(nodeConfigPointer + 0x1a))(parameterBuffer,nodeConfigPointer + 0x14);
    if (CallbackResult == '\0') {
      if (SystemDebugModeEnabled == '\0') {
        errorStringPointer = &SystemErrorMessageTemplate;
        if (*(void **)(nodeConfigPointer + 4) != (void *)0x0) {
          errorStringPointer = *(void **)(nodeConfigPointer + 4);
        }
        LogSystemErrorMessage(&SystemErrorLogBuffer,errorStringPointer);
      }
      *nodeConfigPointer = nodeConfigPointer[0x12];
      return (ulong long)(uint3)((uint)nodeConfigPointer[0x12] >> 8) << 8;
    }
  }
  configValue = *parameterBuffer;
  *nodeConfigPointer = configValue;
  return CONCAT71((uint7)(uint3)((uint)configValue >> 8),1);
}





/**
 * @brief 更新系统配置参数
 * 
 * 该函数负责更新系统的配置参数，执行配置验证回调，
 * 并根据验证结果决定是否应用配置更改。这是系统配置管理的核心功能。
 * 
 * @param configHandle 配置句柄
 * @param configValue 配置值
 */
void UpdateSystemConfigurationParameter(uint64_t configHandle, uint32_t configValue)

{
  long long systemConfigBase;
  char ValidationResult;
  void* errorMessagePointer;
  uint32_t parameterStack [6];
  
  systemConfigBase = SystemConfigurationDataBase;
  if ((*(long long *)(SystemConfigurationDataBase + 0x22f0) != 0) &&
     (parameterStack[0] = configValue, ValidationResult = (**(code **)(SystemConfigurationDataBase + 0x22f8))(parameterStack),
     configValue = parameterStack[0], ValidationResult == '\0')) {
    if (SystemDebugModeEnabled == '\0') {
      errorMessagePointer = &SystemErrorMessageTemplate;
      if (*(void **)(systemConfigBase + 0x22a0) != (void *)0x0) {
        errorMessagePointer = *(void **)(systemConfigBase + 0x22a0);
      }
      LogSystemErrorMessage(&SystemErrorLogBuffer,errorMessagePointer);
    }
    *(uint32_t *)(systemConfigBase + 0x2290) = *(uint32_t *)(systemConfigBase + 0x22d8);
    return;
  }
  *(uint32_t *)(systemConfigBase + 0x2290) = configValue;
  return;
}



/**
 * @brief 释放系统内存资源
 * 
 * 该函数负责释放系统的内存资源，设置资源模板，并根据标志位
 * 决定是否执行内存释放操作。这是系统内存管理的重要组成部分。
 * 
 * @param resourcePointer 资源指针
 * @param freeFlags 释放标志，用于控制是否释放内存
 * @param freeParameter1 释放参数1
 * @param freeParameter2 释放参数2
 * @return 返回处理后的资源指针
 */
void*
ReleaseSystemMemoryResource(void* resourcePointer, uint64_t freeFlags, uint64_t freeParameter1, uint64_t freeParameter2)

{
  *resourcePointer = &SystemMemoryResourceTemplate;
  if ((freeFlags & 1) != 0) {
    free(resourcePointer,0x38,freeParameter1,freeParameter2,0xfffffffffffffffe);
  }
  return resourcePointer;
}




/**
 * @brief 系统字符串复制函数（带长度限制）
 * 
 * 该函数用于将字符串从源地址复制到目标地址，有长度限制。
 * 如果源字符串为空，则清空目标字符串；如果字符串长度超过限制，
 * 则调用系统错误处理函数。
 * 
 * @param ResourceManagerPointer 目标字符串结构体指针
 * @param sourceString 源字符串指针
 * @note 最大字符串长度限制为0x20字节
 */
void ProcessSystemStringCopyWithLimit(long long targetBuffer,long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(sourceString + stringLength) != '\0');
  if ((int)stringLength < 0x20) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
                    0001800463b7. Too many branches
                        strcpy_s(*(void* *)(targetBuffer + 8),0x20);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x20,sourceString);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




// 函数: void SetupSystemMemoryPool(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统内存复制操作（带长度限制）
 * 
 * 该函数执行系统内存复制操作，限制最大复制长度为0x20字节。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 */
void ExecuteSystemMemoryCopyWithLimit(long long targetBuffer,void* sourceData,int copyLength)

{
  if (copyLength + 1 < 0x20) {
      memcpy(*(uint8_t **)(targetBuffer + 8),sourceData,(long long)copyLength);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




/**
 * @brief 系统内存复制操作
 * 
 * 该函数执行系统内存复制操作，用于初始化过程中的数据复制。
 * 
 * @note 这是一个低级别的系统操作函数
 */
void ExecuteSystemMemoryCopy(void)

{
    memcpy();
}




/**
 * @brief 重置系统数据缓冲区
 * 
 * 该函数负责重置系统数据缓冲区，将缓冲区内容清零，
 * 并重置相关的偏移量计数器。
 * 
 * @param dataBufferPointer 指向需要重置的数据缓冲区的指针
 */
void ResetSystemDataBuffer(uint8_t *dataBufferPointer)

{
  long long bufferOffset;
  
  *dataBufferPointer = 0;
  *(uint32_t *)(bufferOffset + 0x10) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统内存分配器的引用，设置内存分配器的
 * 基础结构和相关参数。这是内存管理系统的重要组成部分。
 * 
 * @param memoryAllocatorPointer 内存分配器指针的指针
 * @return 返回初始化后的内存分配器指针
 */
void* * InitializeSystemMemoryAllocatorReference(void* *memoryAllocatorPointer)

{
  *memoryAllocatorPointer = &SystemMemoryAllocatorReference;
  memoryAllocatorPointer[1] = 0;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *memoryAllocatorPointer = &SystemMemoryTemplateE;
  memoryAllocatorPointer[1] = memoryAllocatorPointer + 3;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *(uint8_t *)(memoryAllocatorPointer + 3) = 0;
  return memoryAllocatorPointer;
}





// 函数: void ConfigureSystemBuffers(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统三参数数据处理函数
 * 
 * 该函数处理需要三个参数的系统数据操作，包括内存分配、
 * 数据处理和缓冲区管理。
 * 
 * @param param1 第一个参数
 * @param param2 第二个参数
 * @param param3 第三个参数
 */
void ProcessSystemThreeParameterData(long long sourceStringPointer,long long targetStringPointer,long long searchStringLength)

{
  long long StringSearchResult;
  long long SourceStringLength;
  long long TargetStringLength;
  uint8_t StackSecurityBuffer [32];
  void* SecurityFlags;
  void* *MemoryReference;
  uint8_t *DataBuffer;
  uint32_t BufferLength;
  uint8_t TempDataBuffer [32];
  ulong long ChecksumValue;
  
  SecurityFlags = 0xfffffffffffffffe;
  ChecksumValue = SystemEncryptionKeyTemplate ^ (ulong long)StackSecurityBuffer;
  MemoryReference = &SystemMemoryTemplateE;
  DataBuffer = TempDataBuffer;
  BufferLength = 0;
  TempDataBuffer[0] = 0;
  StringSearchResult = strstr(*(void* *)(param1 + 8));
  if (StringSearchResult != 0) {
    SourceStringLength = -1;
    TargetStringLength = -1;
    do {
      TargetStringLength = TargetStringLength + 1;
    } while (*(char *)(param2 + TargetStringLength) != '\0');
    do {
      SourceStringLength = SourceStringLength + 1;
    } while (*(char *)(SourceStringLength + param3) != '\0');
      memcpy(DataBuffer,*(long long *)(param1 + 8),StringSearchResult - *(long long *)(param1 + 8));
  }
  MemoryReference = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(ChecksumValue ^ (ulong long)StackSecurityBuffer);
}



void* * GetSystemMemoryAllocatorReference(void* *MemoryAllocatorPointer,ulong long MemoryAllocationFlags)

{
  *MemoryAllocatorPointer = &SystemMemoryAllocatorReference;
  if ((MemoryAllocationFlags & 1) != 0) {
    free(MemoryAllocatorPointer,0x18);
  }
  return MemoryAllocatorPointer;
}




// 函数: void UnlockSystemMutex(void* *ResourceManagerPointer)
void UnlockSystemMutex(void* *MutexHandle)

{
  int UnlockResult;
  
  UnlockResult = _Mtx_unlock(*MutexHandle);
  if (UnlockResult != 0) {
    __Throw_C_error_std__YAXH_Z(UnlockResult);
  }
  return;
}




// 函数: void LockSystemMutexAndBroadcast(long long ResourceManagerPointer)
void LockSystemMutexAndBroadcast(long long SystemContextPointer)

{
  int LockResult;
  
  LockResult = _Mtx_lock(SystemContextPointer + 0x48);
  if (LockResult != 0) {
    __Throw_C_error_std__YAXH_Z(LockResult);
  }
  *(uint8_t *)(SystemContextPointer + 0x98) = 1;
  LockResult = _Cnd_broadcast(SystemContextPointer);
  if (LockResult != 0) {
    __Throw_C_error_std__YAXH_Z(LockResult);
  }
  LockResult = _Mtx_unlock(SystemContextPointer + 0x48);
  if (LockResult != 0) {
    __Throw_C_error_std__YAXH_Z(LockResult);
  }
  return;
}




// 函数: void InitializeSystemReferencePointers(void* *ResourceManagerPointer)
void InitializeSystemReferencePointers(void* *SystemReferencePointer)

{
  *SystemReferencePointer = &SystemMemoryTemplateC;
  *SystemReferencePointer = &SystemMemoryTemplateB;
  *SystemReferencePointer = &SystemMemoryTemplateA;
  return;
}



void* *
InitializeSystemReferencePointersWithCleanup(void* *SystemReferencePointer,ulong long CleanupFlags,void* CleanupParameter1,void* CleanupParameter2)

{
  *SystemReferencePointer = &SystemMemoryTemplateC;
  *SystemReferencePointer = &SystemMemoryTemplateB;
  *SystemReferencePointer = &SystemMemoryTemplateA;
  if ((CleanupFlags & 1) != 0) {
    free(SystemReferencePointer,0x20,CleanupParameter1,CleanupParameter2,0xfffffffffffffffe);
  }
  return SystemReferencePointer;
}




// 函数: void ProcessSystemMemoryRange(long long *ResourceManagerPointer)
void ProcessSystemMemoryRange(long long *MemoryRangePointer)

{
  long long MemoryRangeEnd;
  long long CurrentMemoryAddress;
  
  MemoryRangeEnd = MemoryRangePointer[1];
  for (CurrentMemoryAddress = *MemoryRangePointer; CurrentMemoryAddress != MemoryRangeEnd; CurrentMemoryAddress = CurrentMemoryAddress + 0x100) {
    ProcessSystemMemoryPage(CurrentMemoryAddress);
  }
  if (*MemoryRangePointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemDataPointers(long long *ResourceManagerPointer)
void InitializeSystemDataPointers(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 5) {
    *HashEntryStatus = &SystemGlobalDataReference;
    if (HashEntryStatus[1] != 0) {
        SystemCleanupFunction();
    }
    HashEntryStatus[1] = 0;
    *(uint32_t *)(HashEntryStatus + 3) = 0;
    *HashEntryStatus = &SystemMemoryAllocatorReference;
  }
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * 内存管理器 - 释放内存块引用
 * 管理内存块的引用计数，当引用计数为0时释放内存
 * 
 * @param ResourceManagerPointer 内存块指针的指针
 */
void ReleaseMemoryBlockReference(ulong long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = (void* *)*ResourceManagerPointer;
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 系统核心组件初始化函数
 * 
 * 该函数负责初始化游戏系统的核心组件，包括内存管理、数据处理和系统配置。
 * 函数会创建必要的系统对象，初始化内存池，并设置系统参数。
 * 
 * @param ResourceManagerPointer 资源管理器指针，用于管理系统资源
 * @param InitializationFlags 初始化标志，控制初始化过程的不同阶段
 * @return 初始化结果状态码，成功返回0，失败返回错误码
 * 
 * 原始函数名可能为类似FUN_xxxxx的形式，现已重命名为InitializeSystemCoreComponents
 */
int InitializeSystemCoreComponents(long long ResourceManagerPointer,long long InitializationFlags)

{
  void*** SystemResourcePointer;           // 系统资源指针
  long long SystemHandle;                  // 系统句柄
  void** SystemHashNodePointer;            // 系统哈希节点指针
  long long MemoryBufferBase;              // 内存缓冲区基地址
  int SystemResultValue;                    // 系统结果值
  long long LocalSystemFlags;               // 本地系统标志
  long long DataIndex;                     // 数据索引
  ulong long MemoryAddress;                // 内存地址
  void* ****ppppunsignedSystemValue9;
  void* ***encryptionPointerTripleX;
  void* *systemMemoryContext;
  long long LocalMemoryBufferHandle;
  uint32_t LocalInitializationFlags;
  void* LocalSystemContextA;
  void* LocalSystemContextB;
  void* LocalMemoryPointerA;
  void* LocalMemoryPointerB;
  void* LocalMemoryPointerC;
  void* LocalMemoryPointerD;
  void* LocalMemoryPointerE;
  void* LocalMemoryPointerF;
  void* LocalMemoryPointerG;
  void* LocalMemoryPointerH;
  void* LocalMemoryPointerI;
  void* LocalMemoryPointerJ;
  void* LocalMemoryPointerK;
  void* LocalMemoryPointerL;
  void* LocalMemoryPointerM;
  void* LocalMemoryPointerN;
  void* LocalMemoryPointerO;
  void* LocalMemoryParameterC;
  void* LocalMemoryPointerP;
  void* LocalMemoryPointerQ;
  void* LocalMemoryPointerR;
  void* LocalMemoryPointerS;
  void* ***LocalEncryptionContext;
  void* ***LocalSystemContextX;
  void* LocalMemoryPointerT;
  void* LocalMemoryPointerU;
  void* LocalEncryptionValue;
  uint32_t LocalSystemStatus;
  void* LocalSystemHandle;
  
  SystemGlobalHandle = 0xfffffffffffffffe;
  SystemHandle = 0;
  systemMemoryContext = (void* *)&SystemGlobalDataReference;
  LocalSystemContextA = 0;
  LocalMemoryBufferHandle = 0;
  LocalInitializationFlags = 0;
  LocalMemoryPointerB = 0;
  LocalMemoryPointerC = 0;
  LocalMemoryPointerD = 0;
  LocalMemoryPointerE = 0;
  LocalMemoryPointerF = 0;
  LocalMemoryPointerG = 0;
  LocalMemoryPointerH = 0;
  LocalMemoryPointerI = 0;
  LocalMemoryPointerJ = 0;
  LocalSystemStatus = 3;
  LocalMemoryPointerT = 0;
  LocalMemoryPointerU = 0;
  LocalEncryptionValue = 0;
  HashNodePointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    HashNodePointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  encryptionPointerTripleX = &pppEncryptionValue68;
  pppEncryptionValue68 = &pppEncryptionValue68;
  encryptionPointerTriple60 = &pppEncryptionValue68;
  InitializeSystemStructure(&systemMemoryContext,HashNodePointer);
  UnsignedStackFlag118 = 0;
  UnsignedStackFlag110 = 0;
  UnsignedStackFlagC0 = 0;
  UnsignedStackFlagB8 = 0;
  UnsignedStackFlagB0 = 0;
  UnsignedStackFlagA8 = 0;
  UnsignedStackFlagA0 = 0;
  systemConfigurationValue = 0;
  SystemConfigurationValue = 0;
  UnsignedStackFlag88 = 0;
  UnsignedStackFlag80 = 0;
  UnsignedStackFlag78 = 0;
  processFlags70 = 0;
  unsignedSystemValue8 = *(ulong long *)(ResourceManagerPointer + 0x10);
  if (unsignedSystemValue8 < *(ulong long *)(ResourceManagerPointer + 0x18)) {
    *(ulong long *)(ResourceManagerPointer + 0x10) = unsignedSystemValue8 + 0x100;
    ProcessSystemData(unsignedSystemValue8,&systemMemoryContext);
    ppppunsignedSystemValue9 = *(void* *****)(ResourceManagerPointer + 0x10);
    goto MemoryAllocationComplete;
  }
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  localDataIndex = (long long)(unsignedSystemValue8 - bufferBaseAddress) >> 8;
  if (localDataIndex == 0) {
    localDataIndex = 1;
LocalDataPointerCheck:
    localSystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,localDataIndex << 8,*(uint8_t *)(ResourceManagerPointer + 0x20));
    unsignedSystemValue8 = *(ulong long *)(ResourceManagerPointer + 0x10);
    bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  }
  else {
    localDataIndex = localDataIndex * 2;
    if (localDataIndex != 0) goto SystemDataPointerCheck;
  }
  InitializeSystemBuffer(&encryptionPointerTripleX,bufferBaseAddress,unsignedSystemValue8,localSystemHandle);
  pppointerToUnsigned1 = encryptionPointerTripleX;
  ProcessSystemData(encryptionPointerTripleX,&systemMemoryContext);
  ppppunsignedSystemValue9 = (void* ****)(pppointerToUnsigned1 + 0x20);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 0x10);
  localSystemFlags = *(long long *)(ResourceManagerPointer + 8);
  if (localSystemFlags != bufferBaseAddress) {
    do {
      ProcessSystemMemoryPage(localSystemFlags);
      localSystemFlags = localSystemFlags + 0x100;
    } while (localSystemFlags != bufferBaseAddress);
    localSystemFlags = *(long long *)(ResourceManagerPointer + 8);
  }
  if (localSystemFlags != 0) {
      SystemCleanupFunction(localSystemFlags);
  }
  *(long long *)(ResourceManagerPointer + 8) = localSystemHandle;
  *(void* *****)(ResourceManagerPointer + 0x10) = ppppunsignedSystemValue9;
  *(long long *)(ResourceManagerPointer + 0x18) = localDataIndex * 0x100 + localSystemHandle;
SystemValueCalculation:
  systemValue = (int)((ulong long)((long long)ppppunsignedSystemValue9 - *(long long *)(ResourceManagerPointer + 8)) >> 8) + -1;
  *(int *)(ResourceManagerPointer + 0x68) = systemValue;
  encryptionPointerTripleX = &pppEncryptionValue68;
  InitializeAndCleanupSystemMemoryAllocator(&pppEncryptionValue68,processFlags58);
  encryptionPointerTripleX = (void* ***)&systemMemoryContext;
  systemMemoryContext = (void* *)&SystemGlobalDataReference;
  if (LocalStackInitializationFlag == 0) {
    return systemValue;
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemDataBlock(void* *ResourceManagerPointer,void* SourceDataPointer,void* MemoryBufferSize,void* AllocationFlags)
void InitializeSystemDataBlock(void* *ResourceManagerPointer,void* SourceDataPointer,void* MemoryBufferSize,void* AllocationFlags)

{
  InitializeAndCleanupSystemMemoryAllocator(ResourceManagerPointer + 0x1a,ResourceManagerPointer[0x1c],MemoryBufferSize,AllocationFlags,0xfffffffffffffffe);
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}



ulong long CompareSystemDataBlocks(long long ResourceManagerPointer,long long ComparisonDataPointer)

{
  byte *comparisonBytePointer;
  int systemResult;
  long long localResourceOffset;
  byte *sourceBytePointer;
  int systemValue;
  int systemFlag;
  ulong long dataSizeLimit;
  long long localMemoryAddress;
  uint indexCounter;
  ulong long comparisonIndex;
  ulong long loopCounter;
  
  comparisonIndex = (ulong long)*(int *)(ResourceManagerPointer + 0x68);
  localResourceOffset = *(long long *)(ResourceManagerPointer + 8);
  if (comparisonIndex < (ulong long)(*(long long *)(ResourceManagerPointer + 0x10) - localResourceOffset >> 8)) {
    systemValue = *(int *)(ComparisonDataPointer + 0x10);
    systemResult = *(int *)(comparisonIndex * 0x100 + 0x10 + localResourceOffset);
    if (systemResult == systemValue) {
      if (systemResult != 0) {
        sourceBytePointer = *(byte **)(comparisonIndex * 0x100 + 8 + localResourceOffset);
        localMemoryAddress = *(long long *)(ComparisonDataPointer + 8) - (long long)sourceBytePointer;
        do {
          comparisonBytePointer = sourceBytePointer + localMemoryAddress;
          systemValue = (uint)*sourceBytePointer - (uint)*comparisonBytePointer;
          if (systemValue != 0) break;
          sourceBytePointer = sourceBytePointer + 1;
        } while (*comparisonBytePointer != 0);
      }
    }
    else if (systemResult != 0) goto SystemResultCheck;
    if (systemValue == 0) {
SystemResultHandler:
      return comparisonIndex & 0xffffffff;
    }
  }
SystemResultCheck:
  comparisonIndex = 0;
  dataSizeLimit = *(long long *)(ResourceManagerPointer + 0x10) - localResourceOffset >> 8;
  if (dataSizeLimit != 0) {
    systemValue = *(int *)(ComparisonDataPointer + 0x10);
    loopCounter = comparisonIndex;
    do {
      systemResult = *(int *)(loopCounter + 0x10 + localResourceOffset);
      systemFlag = systemValue;
      if (systemResult == systemValue) {
        if (systemResult != 0) {
          sourceBytePointer = *(byte **)(loopCounter + 8 + localResourceOffset);
          localMemoryAddress = *(long long *)(ComparisonDataPointer + 8) - (long long)sourceBytePointer;
          do {
            comparisonBytePointer = sourceBytePointer + localMemoryAddress;
            systemFlag = (uint)*sourceBytePointer - (uint)*comparisonBytePointer;
            if (systemFlag != 0) break;
            sourceBytePointer = sourceBytePointer + 1;
          } while (*comparisonBytePointer != 0);
        }
SystemResultZeroHandler:
        if (systemFlag == 0) {
          *(int *)(ResourceManagerPointer + 0x68) = (int)comparisonIndex;
          goto SystemResultHandler;
        }
      }
      else if (systemResult == 0) goto SystemResultZeroHandler;
      indexCounter = (int)comparisonIndex + 1;
      comparisonIndex = (ulong long)indexCounter;
      loopCounter = loopCounter + 0x100;
    } while ((ulong long)(long long)(int)indexCounter < dataSizeLimit);
  }
  return 0xffffffff;
}





/**
 * 初始化系统控制器
 * 设置系统控制器并分配必要的内存资源
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param SystemConfigurationPointer 系统配置指针
 */
void InitializeSystemController(long long *ResourceManagerPointer,void* *SystemConfigurationPointer)

{
  long long *PrimaryResourcePointer;
  long long *ResourceStackPointer;
  void** HashBucketNode;
  long long *MemoryStackPointer;
  long long **StackReferencePointer;
  uint32_t SystemStatusFlag;
  void* SystemMemoryHandle;
  
  SystemMemoryHandle = 0xfffffffffffffffe;
  SystemStatusFlag = 0;
  ResourceStackPointer = ResourceManagerPointer;
  puStackX_10 = SystemConfigurationPointer;
  SystemMemoryCleanupHandler();
  PrimaryResourcePointer = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,200,8,3,SystemStatusFlag,SystemMemoryHandle);
  ResourceStackPointer = PrimaryResourcePointer;
  InitializeSystemDataTableManager(PrimaryResourcePointer);
  *PrimaryResourcePointer = (long long)&SystemDataTableTemplate;
  PrimaryResourcePointer[0x18] = (long long)&SystemMemoryCleanupCallback;
  MemoryStackPointer = PrimaryResourcePointer;
  (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
  SystemMemoryHandle = SystemAllocationFlagsTemplate;
  StackReferencePointer = &ResourceStackPointer;
  ResourceStackPointer = PrimaryResourcePointer;
  (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
  SystemManagerInitialize(SystemMemoryHandle,&ResourceStackPointer);
  (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer);
  SystemMemoryAllocationCounter = (long long)*(int *)(SystemStatusFlagsPointer + 0x224);
  ConfigureSystemSettings(&SystemConfigurationTemplate,SystemConfigurationPointer);
  *SystemConfigurationPointer = &SystemGlobalDataReference;
  if (SystemConfigurationPointer[1] != 0) {
      SystemCleanupFunction();
  }
  SystemConfigurationPointer[1] = 0;
  *(uint32_t *)(SystemConfigurationPointer + 3) = 0;
  *SystemConfigurationPointer = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 初始化系统核心引擎
 * 
 * 该函数负责初始化系统的核心引擎组件，设置系统启动所需的基础结构。
 * 它会配置内存管理器、初始化系统参数、设置核心服务，并建立系统状态监控。
 * 这是系统初始化过程中的核心函数，确保引擎组件正确启动和运行。
 * 
 * @note 这是系统初始化过程中的关键函数，负责整个引擎的初始化工作
 */
void InitializeSystemCoreEngine(void)

{
  void* systemStatusFlag;
  char InitializationStatus;
  int MemoryComparisonResult;
  long long ***systemMemoryManager;
  ulong long SystemConfigValue;
  long long SystemTimeValue;
  void** SystemCurrentNode;
  uint32_t *systemParameterPointer;
  uint8_t *systemDataBuffer;
  uint32_t systemControlFlag;
  float systemPerformanceValue1;
  float systemPerformanceValue2;
  uint8_t systemSecurityBuffer [32];
  long long systemMemoryHandle;
  long long systemResourceHandle;
  int systemInitStatus;
  void* *systemCallbackPointer;
  uint8_t *systemEventBuffer;
  uint systemEventCounter;
  ulong long systemTimestamp;
  uint32_t systemOperationFlag;
  long long ***systemMemoryPool;
  long long **systemMemoryTable;
  long long ****systemMemoryRoot;
  void* *systemErrorHandler;
  void* systemContext;
  uint32_t systemPriority;
  void* systemSemaphore;
  void* *systemLock;
  long long systemThreadId;
  int systemThreadStatus;
  uint32_t systemThreadFlag;
  void* *systemThreadContext;
  long long systemHeapHandle;
  uint32_t systemHeapSize;
  long long ***systemHeapArray [2];
  void* *systemHeapManager;
  code *systemEntryPoint;
  void* systemEntryPointParam;
  long long **SystemTablePointer;
  void* *systemTableLock;
  uint8_t *systemTableBuffer;
  uint32_t systemTableFlag;
  uint8_t systemTableData [72];
  void* *systemCacheManager;
  uint8_t *systemCacheBuffer;
  uint32_t systemCacheFlag;
  uint8_t systemCacheData [72];
  void* *systemIoManager;
  uint8_t *systemIoBuffer;
  uint32_t systemIoFlag;
  uint8_t systemIoData [72];
  void* *systemNetworkManager;
  uint8_t *systemNetworkBuffer;
  uint32_t systemNetworkFlag;
  uint8_t systemNetworkData [72];
  void* *systemRenderManager;
  uint8_t *systemRenderBuffer;
  uint32_t systemRenderFlag;
  uint8_t systemRenderData [72];
  void* *systemAudioManager;
  uint8_t *systemAudioBuffer;
  uint32_t systemAudioFlag;
  uint8_t systemAudioData [72];
  void* *systemInputManager;
  uint8_t *systemInputBuffer;
  uint32_t systemInputFlag;
  uint8_t systemInputData [648];
  ulong long systemSecurityHash;
  
  systemFlags4f8 = 0xfffffffffffffffe;
  EncryptionValue68 = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer698;
  systemStateFlags5b8 = 0;
  if (*(int *)(SystemStatusFlagsPointer + 0x224) - SystemMemoryAllocationCounter < 0xfb) {
      ValidateSystemChecksum(EncryptionValue68 ^ (ulong long)EncryptionBuffer698);
  }
  *(uint8_t *)(SystemResourceManagerPointer + 0x39) = 1;
  pppbufferBaseAddress = (long long ***)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,200,8,3);
  bufferPointerTriple590 = pppbufferBaseAddress;
  InitializeSystemDataTableManager(pppbufferBaseAddress);
  *pppbufferBaseAddress = (long long **)&SystemDataTableTemplate;
  pppbufferBaseAddress[0x18] = (long long **)&SystemMemoryAllocationCallback;
  bufferPointerDouble4f0 = (long long **)pppbufferBaseAddress;
  (*(code *)(*pppbufferBaseAddress)[5])(pppbufferBaseAddress);
  systemStatus = SystemAllocationFlagsTemplate;
  systemStateFlags5b8 = 1;
  bufferPointerTriple590 = &bufferPointerDouble588;
  bufferPointerDouble588 = (long long **)pppbufferBaseAddress;
  (*(code *)(*pppbufferBaseAddress)[5])(pppbufferBaseAddress);
  SystemManagerInitialize(systemStatus,&bufferPointerDouble588);
  systemStateFlags5b8 = 0;
  (*(code *)(*pppbufferBaseAddress)[7])(pppbufferBaseAddress);
  InitializeSystemContext(&LocalStackConfigurationPointer,&SystemConfigurationTemplate);
  if (IntegerStackInitializationFlag == 0) {
    (**(code **)(LocalStackConfigurationPointer + 0x10))(&LocalStackConfigurationPointer,&SystemRuntimeDataTemplate);
    validationStatusFlag = ValidateSystemConfiguration(&LocalStackConfigurationPointer);
    if (validationStatusFlag == '\0') {
      SetupSystemResources(&LocalStackConfigurationPointer);
    }
  }
  validationStatusFlag = ValidateSystemConfiguration(&LocalStackConfigurationPointer);
  if (validationStatusFlag == '\0') {
    SetupSystemResources(&LocalStackConfigurationPointer);
  }
  SystemDataBufferPointer = &SystemDataBufferTemplateB;
  DataBufferPtr4E0 = DataBuffer4D0;
  DataBuffer4D0[0] = 0;
  configurationFlags4d8 = 0x18;
  strcpy_s(DataBuffer4D0,0x40,&SystemDataBufferTemplateJ);
  InitializeResourceManager(SystemResourceManagerPointer,&SystemDataBufferPointer,&LocalStackConfigurationPointer);
  SystemDataBufferPointer = &SystemMemoryAllocatorReference;
  pEncryptionValue488 = &SystemDataBufferTemplateB;
  DataBufferPtr480 = DataBuffer470;
  DataBuffer470[0] = 0;
  configurationFlags478 = 0xb;
  strcpy_s(DataBuffer470,0x40,&SystemDataBufferTemplateK);
  InitializeResourceManager(SystemResourceManagerPointer,&pEncryptionValue488,&LocalStackConfigurationPointer);
  pEncryptionValue488 = &SystemMemoryAllocatorReference;
  SystemScaleFactorBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr420 = DataBuffer410;
  DataBuffer410[0] = 0;
  configurationFlags418 = 0x18;
  systemOperationFlags = strcpy_s(DataBuffer410,0x40,&SystemDataBufferTemplateJ);
  SystemScaleFactorXStorage = (float)GetSystemScaleFactor(systemOperationFlags,&SystemScaleFactorBuffer);
  SystemScaleFactorXStorage = 1.0 / SystemScaleFactorXStorage;
  SystemScaleFactorBuffer = &SystemMemoryAllocatorReference;
  SystemResolutionFactorBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr3C0 = DataBuffer3B0;
  DataBuffer3B0[0] = 0;
  configurationFlags3b8 = 0xb;
  systemOperationFlags = strcpy_s(DataBuffer3B0,0x40,&SystemDataBufferTemplateK);
  SystemScaleFactorYStorage = (float)GetSystemScaleFactor(systemOperationFlags,&SystemResolutionFactorBuffer);
  SystemScaleFactorYStorage = 1.0 / SystemScaleFactorYStorage;
  SystemResolutionFactorBuffer = &SystemMemoryAllocatorReference;
  HorizontalResolutionBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr360 = DataBuffer350;
  DataBuffer350[0] = 0;
  configurationFlags358 = 0xb;
  systemOperationFlags = strcpy_s(DataBuffer350,0x40,&SystemDataBufferTemplateK);
  horizontalResolutionFactor = (float)GetSystemResolutionFactor(systemOperationFlags,&HorizontalResolutionBuffer);
  HorizontalResolutionBuffer = &SystemMemoryAllocatorReference;
  VerticalResolutionBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr300 = DataBuffer2F0;
  DataBuffer2F0[0] = 0;
  configurationFlags2f8 = 0x18;
  systemOperationFlags = strcpy_s(DataBuffer2F0,0x40,&SystemDataBufferTemplateJ);
  verticalResolutionFactor = (float)GetSystemResolutionFactor(systemOperationFlags,&VerticalResolutionBuffer);
  VerticalResolutionBuffer = &SystemMemoryAllocatorReference;
  currentThreadId = GetSystemInitializationStatus();
  if (0 < SystemConfigDataPointerD) {
    InitializeSystemConfiguration(&SystemConfigurationTemplate,&SystemConfigPathBuffer,0,SystemConfigDataPointerD + -1);
    IntegerStackCounter = IntegerStackCounter + -1;
    localSystemFlags = (long long)IntegerStackCounter;
    systemCounter = -1;
    if (-1 < IntegerStackCounter) {
      do {
        systemCounter = IntegerStackCounter;
        if (*(char *)(LocalStackStringBuffer + localSystemFlags) == '/') break;
        IntegerStackCounter = IntegerStackCounter + -1;
        localSystemFlags = localSystemFlags + -1;
        systemCounter = -1;
      } while (-1 < localSystemFlags);
    }
    InitializeSystemConfiguration(&SystemConfigPathBuffer,&SystemConfigNameBuffer,systemCounter + 1,0xffffffff);
    systemCounter = FindSystemResourceIndex(&SystemResourceTemplate,&SystemConfigNameBuffer);
    if (systemCounter == -1) {
      systemCounter = FindSystemResourceHandle(&SystemResourceTemplate,&SystemConfigNameBuffer);
    }
    localSystemFlags = (long long)systemCounter * 0x100;
    bufferPointerTriple590 = (long long ***)(SystemInitializationDataStart + 0x30 + localSystemFlags);
    bufferPointerQuad580 = arrayPointerTriple518;
    memoryAllocationEnd8 = &SystemStringFormatTemplate;
    charPointer500 = SystemStringFormatProcessor;
    arrayPointerTriple518[0] = (long long ***)&bufferPointerTriple590;
    ProcessSystemResourceData(arrayPointerTriple518);
    *(double *)(localSystemFlags + 0xa0 + SystemInitializationDataStart) = (double)(1.0 / verticalResolutionFactor);
    *(double *)(localSystemFlags + 0xb8 + SystemInitializationDataStart) = (double)(1.0 / horizontalResolutionFactor);
    *(int *)(localSystemFlags + 0xb0 + SystemInitializationDataStart) = (int)(long long)SystemScaleFactorXStorage;
    *(int *)(localSystemFlags + 200 + SystemInitializationDataStart) = (int)(long long)SystemScaleFactorYStorage;
    *(double *)(localSystemFlags + 0x20 + SystemInitializationDataStart) = (double)(currentThreadId >> 0x14);
    pointerUnsigned538 = &SystemGlobalDataReference;
    if (longValue530 != 0) {
        SystemCleanupFunction();
    }
    longValue530 = 0;
    unsignedValue520 = 0;
    pointerUnsigned538 = &SystemMemoryAllocatorReference;
    pointerUnsigned558 = &SystemGlobalDataReference;
    if (LocalStackStringBuffer != 0) {
        SystemCleanupFunction();
    }
    LocalStackStringBuffer = 0;
    unsignedValue540 = 0;
    pointerUnsigned558 = &SystemMemoryAllocatorReference;
  }
  pointerUnsigned578 = &SystemGlobalDataReference;
  unsignedValue560 = 0;
  unsignedValue570 = 0;
  unsignedValue568 = 0;
  pointerUnsigned618 = &SystemGlobalDataReference;
  unsignedValue600 = 0;
  pointerUnsigned610 = (uint8_t *)0x0;
  unsignedValue608 = 0;
  WriteDataToBuffer(&pointerUnsigned618,IntegerStackInitializationFlag);
  if (IntegerStackInitializationFlag != 0) {
      memcpy(pointerUnsigned610,longValue670,IntegerStackInitializationFlag + 1);
  }
  if (longValue670 != 0) {
    unsignedValue608 = 0;
    if (pointerUnsigned610 != (uint8_t *)0x0) {
      *pointerUnsigned610 = 0;
    }
    unsignedValue600 = unsignedValue600 & 0xffffffff;
  }
  InitializeSystemRuntimeState(&LocalStackConfigurationPointer,1);
  systemCounter = unsignedValue608 + 0x11;
  WriteDataToBuffer(&pointerUnsigned618,systemCounter);
  newThreadLocalStorage = (uint32_t *)(pointerUnsigned610 + unsignedValue608);
  *newThreadLocalStorage = 0x69676e65;
  newThreadLocalStorage[1] = 0x635f656e;
  newThreadLocalStorage[2] = 0x69666e6f;
  newThreadLocalStorage[3] = 0x78742e67;
  *(void*2 *)(newThreadLocalStorage + 4) = 0x74;
  unsignedValue608 = systemCounter;
  HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x18,8,3);
  punsignedSystemValue9 = &SystemStringTemplate;
  if (pointerUnsigned610 != (uint8_t *)0x0) {
    punsignedSystemValue9 = pointerUnsigned610;
  }
  *HashBucketNode = 0;
  *(uint8_t *)(HashBucketNode + 2) = 0;
  ConfigureSystemNodeParameters(HashBucketNode,punsignedSystemValue9,&SystemConfigurationDataTemplate);
  RegisterSystemNode(SystemNodeManagerPointer,HashBucketNode);
  if (HashBucketNode[1] != 0) {
    fclose();
    HashBucketNode[1] = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
    if (HashBucketNode[1] != 0) {
      fclose();
      HashBucketNode[1] = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
  }
    SystemCleanupFunction(HashBucketNode);
}



void* *
/**
 * @brief 复制系统数据结构
 * 
 * 该函数负责复制系统数据结构，包括基本数据、标志位和配置信息。
 * 它会递归地复制复杂的数据结构，确保数据的完整性和一致性。
 * 
 * @param ResourceManagerPointer 目标数据结构指针
 * @param sourceDataPointer 源数据结构指针
 * @param copyFlags 复制标志参数
 * @param additionalParams 附加参数
 * @return 返回复制后的目标数据结构指针
 * @note 这是系统数据管理的重要组成部分，确保数据复制的正确性
 */
void* CopySystemDataStructure(void* *ResourceManagerPointer,void* *sourceDataPointer,void* copyFlags,void* additionalParams)

{
  *ResourceManagerPointer = *sourceDataPointer;
  *(uint32_t *)(ResourceManagerPointer + 1) = *(uint32_t *)(sourceDataPointer + 1);
  InitializeSystemResourceExtended(ResourceManagerPointer + 2,sourceDataPointer + 2,copyFlags,additionalParams,0xfffffffffffffffe);
  *(uint32_t *)(ResourceManagerPointer + 0x15) = *(uint32_t *)(sourceDataPointer + 0x15);
  *(uint32_t *)((long long)ResourceManagerPointer + 0xac) = *(uint32_t *)((long long)sourceDataPointer + 0xac);
  ResourceManagerPointer[0x16] = sourceDataPointer[0x16];
  ResourceManagerPointer[0x17] = sourceDataPointer[0x17];
  ResourceManagerPointer[0x18] = sourceDataPointer[0x18];
  *(uint8_t *)(ResourceManagerPointer + 0x19) = *(uint8_t *)(sourceDataPointer + 0x19);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xc9) = *(uint8_t *)((long long)sourceDataPointer + 0xc9);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xca) = *(uint8_t *)((long long)sourceDataPointer + 0xca);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xcb) = *(uint8_t *)((long long)sourceDataPointer + 0xcb);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xcc) = *(uint8_t *)((long long)sourceDataPointer + 0xcc);
  return ResourceManagerPointer;
}




// 函数: void SetSystemMemoryAllocatorReference(long long ResourceManagerPointer)
/**
 * @brief 设置系统内存分配器引用
 * 
 * 该函数负责在指定对象的偏移量0x10处设置系统内存分配器的引用。
 * 这是一个简单的指针设置操作，用于初始化对象的内存分配器引用。
 * 
 * @param systemObject 系统对象指针
 */
void SetSystemMemoryAllocatorReference(long long systemObject)

{
  *(void* **)(systemObject + 0x10) = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 设置系统内存分配器指针
 * 
 * 该函数负责在指定指针位置设置系统内存分配器的指针。
 * 这是一个简单的指针赋值操作，用于初始化内存分配器指针。
 * 
 * @param allocatorPointer 内存分配器指针的指针
 */
void SetSystemMemoryAllocatorPointer(void* *allocatorPointer)

{
  *allocatorPointer = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 系统数据查找和匹配
 * 
 * 该函数负责在系统初始化数据中查找和匹配指定的数据项。
 * 它会遍历系统数据节点，进行字符串比较和数据匹配，找到合适的
 * 数据项后设置相应的参数和回调函数。
 * 
 * @param searchContext 搜索上下文
 * @param searchData 搜索数据
 * @param matchData 匹配数据
 * @param callbackData 回调数据
 */
void SystemDataSearchAndMatch(void* searchContext,void* searchData,long long matchData,void* callbackData)

{
  byte FirstByteValue;
  bool IsMatchFound;
  int MemoryComparisonResult;
  void* *CurrentSearchNode;
  uint ComparisonValue;
  byte *StringComparePointer;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void* *NextSearchNode;
  long long StringLengthDifference;
  void* SystemContextBackup;
  
  searchContextBackup = ResourceManagerPointer;
  systemCounter = FindSystemDataIndex(&SystemResourceTemplate);
  if (systemCounter == -1) {
    systemCounter = FindSystemDataIndexAlternative(&SystemResourceTemplate,ConfigurationDataPointer);
  }
  HashBucketNode = (void* *)(SystemInitializationDataStart + 0xd0 + (long long)systemCounter * 0x100);
  punsignedSystemValue4 = HashBucketNode;
  if ((void* *)HashBucketNode[2] != (void* *)0x0) {
    newThreadLocalStorage = (void* *)HashBucketNode[2];
    do {
      if (*(int *)(AdditionalParameter + 0x10) == 0) {
        punsignedSystemValue9 = (void* *)newThreadLocalStorage[1];
        IsMatchFound = false;
      }
      else {
        if (*(int *)(newThreadLocalStorage + 6) == 0) {
          IsMatchFound = true;
        }
        else {
          byteComparePointer = *(byte **)(AdditionalParameter + 8);
          stringLengthDifference = newThreadLocalStorage[5] - (long long)byteComparePointer;
          do {
            comparisonCharValue = (uint)byteComparePointer[stringLengthDifference];
            systemCounter = *byteComparePointer - comparisonCharValue;
            if (*byteComparePointer != comparisonCharValue) break;
            byteComparePointer = byteComparePointer + 1;
          } while (comparisonCharValue != 0);
          IsMatchFound = 0 < systemCounter;
          if (systemCounter < 1) {
            punsignedSystemValue9 = (void* *)newThreadLocalStorage[1];
            goto SystemNodeTraversalContinue;
          }
        }
        punsignedSystemValue9 = (void* *)*newThreadLocalStorage;
      }
SystemNodeTraversalContinue:
      if (IsMatchFound) {
        newThreadLocalStorage = punsignedSystemValue4;
      }
      punsignedSystemValue4 = newThreadLocalStorage;
      newThreadLocalStorage = punsignedSystemValue9;
    } while (punsignedSystemValue9 != (void* *)0x0);
  }
  if (punsignedSystemValue4 != HashBucketNode) {
    if (*(int *)(punsignedSystemValue4 + 6) == 0) goto SystemNodeDataValidation;
    if (*(int *)(AdditionalParameter + 0x10) != 0) {
      stringComparePointer = (byte *)punsignedSystemValue4[5];
      stringLengthDifference = *(long long *)(AdditionalParameter + 8) - (long long)stringComparePointer;
      do {
        currentCharValue = *stringComparePointer;
        comparisonCharValue = (uint)stringComparePointer[stringLengthDifference];
        if (currentCharValue != comparisonCharValue) break;
        stringComparePointer = stringComparePointer + 1;
      } while (comparisonCharValue != 0);
      if ((int)(currentCharValue - comparisonCharValue) < 1) goto SystemNodeDataValidation;
    }
  }
  punsignedSystemValue4 = (void* *)GetSystemNodeDataPointer(HashBucketNode,&searchContextBackup);
  punsignedSystemValue4 = (void* *)*punsignedSystemValue4;
SystemNodeDataValidation:
  SetSystemNodeRuntimeData(punsignedSystemValue4 + 8,AdditionalParameter);
  punsignedSystemValue4[0xc] = ConfigurationFlag;
  return;
}





/**
 * @brief 初始化系统配置数据
 * 
 * 该函数负责初始化系统配置数据，从配置数据结构指针中复制各种配置信息
 * 到系统资源指针中。它处理系统内存分配、配置数据复制和系统节点设置。
 * 
 * @param ResourceManagerPointer 系统资源指针，目标配置数据将写入此处
 * @param ConfigurationDataPointer 配置数据结构指针，包含源配置信息
 * @param AdditionalParameter 附加参数，用于配置数据处理的额外参数
 * @param ConfigurationFlag 配置标志，用于控制配置过程的标志位
 * 
 * 该函数执行以下主要操作：
 * - 从配置数据结构中复制内存配置信息
 * - 设置系统节点的运行时数据
 * - 初始化系统内存分配器
 * - 配置系统缓冲区和数据结构
 */
void InitializeSystemConfigurationData(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  double scaleFactorValue;
  char validationStatusFlag;
  double numericValue;
  uint SystemGlobalStateFlag;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  long long localDataIndex;
  uint32_t *newThreadLocalStorage;
  void* *punsignedSystemValue9;
  ulong long systemOperationFlags;
  long long nextDataIndex1;
  ulong long systemStatus2;
  long long nextDataIndex3;
  char *systemFunctionPointer4;
  void* *ThreadLocalStorageEntry;
  uint SystemOperationStatusFlag;
  int SystemErrorStatusFlag;
  void* *pointerUnsignedC8;
  void* *pUnsignedStackFlagC0;
  uint UnsignedStackFlagB8;
  void* UnsignedStackFlagB0;
  void* *pUnsignedStackFlagA8;
  char *charPointerA0;
  uint32_t unsignedValue98;
  ulong long StackParameterC;
  void* *pUnsignedStackFlag88;
  char *charPointer80;
  uint32_t UnsignedStackFlag78;
  ulong long processFlags70;
  
  nextDataIndex1 = SystemStatusFlagsPointer;
  systemStatus2 = 0;
  if (SystemResourceTemplate == '\0') {
    return;
  }
  pointerUnsignedC8 = &SystemGlobalDataReference;
  UnsignedStackFlagB0 = 0;
  pUnsignedStackFlagC0 = (void* *)0x0;
  UnsignedStackFlagB8 = 0;
  systemStatus6 = *(uint *)(SystemStatusFlagsPointer + 0x180);
  systemOperationFlags = (ulong long)systemStatus6;
  if (*(long long *)(SystemStatusFlagsPointer + 0x178) != 0) {
    WriteDataToBuffer(&pointerUnsignedC8,systemOperationFlags,AdditionalParameter,ConfigurationFlag,1,0xfffffffffffffffe);
  }
  if (systemStatus6 != 0) {
      memcpy(pUnsignedStackFlagC0,*(void* *)(nextDataIndex1 + 0x178),systemOperationFlags);
  }
  if (pUnsignedStackFlagC0 != (void* *)0x0) {
    pUnsignedStackFlagC0[systemOperationFlags] = 0;
  }
  UnsignedStackFlagB0 = CONCAT44(*(uint32_t *)(nextDataIndex1 + 0x18c),(uint32_t)UnsignedStackFlagB0);
  UnsignedStackFlagB8 = systemStatus6;
  InitializeSystemDataBuffer(&pointerUnsignedC8,5);
  *(uint32_t *)(pUnsignedStackFlagC0 + UnsignedStackFlagB8) = 0x73676f6c;
  *(void*2 *)((long long)(pUnsignedStackFlagC0 + UnsignedStackFlagB8) + 4) = 0x2f;
  UnsignedStackFlagB8 = 5;
  InitializeSystemDataBuffer(&pointerUnsignedC8,0x18);
  newThreadLocalStorage = (uint32_t *)(pUnsignedStackFlagC0 + UnsignedStackFlagB8);
  *newThreadLocalStorage = 0x66726570;
  newThreadLocalStorage[1] = 0x616d726f;
  newThreadLocalStorage[2] = 0x5f65636e;
  newThreadLocalStorage[3] = 0x2e676f6c;
  newThreadLocalStorage[4] = 0x747874;
  UnsignedStackFlagB8 = 0x18;
  pcurrentThreadId = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x18,8,3);
  punsignedSystemValue9 = &SystemStringTemplate;
  if (pUnsignedStackFlagC0 != (void* *)0x0) {
    punsignedSystemValue9 = pUnsignedStackFlagC0;
  }
  *pcurrentThreadId = 0;
  *(uint8_t *)(pcurrentThreadId + 2) = 0;
  ConfigureSystemNodeParameters(pcurrentThreadId,punsignedSystemValue9,&SystemConfigurationDataTemplate);
  systemStatus6 = 0;
  systemOperationFlags = systemStatus2;
  if (SystemInitializationDataEnd - SystemInitializationDataStart >> 8 != 0) {
    do {
      nextDataIndex3 = SystemInitializationDataStart;
      nextDataIndex1 = 0;
      pUnsignedStackFlag88 = &SystemGlobalDataReference;
      processFlags70 = 0;
      charPointer80 = (char *)0x0;
      UnsignedStackFlag78 = 0;
      InitializeSystemDataBuffer(&pUnsignedStackFlag88,*(uint32_t *)(SystemInitializationDataStart + 0x10 + systemOperationFlags));
      systemStatus7 = *(int *)(nextDataIndex3 + 0x10 + systemOperationFlags);
      if (systemStatus7 != 0) {
          memcpy(charPointer80,*(void* *)(nextDataIndex3 + 8 + systemOperationFlags),systemStatus7 + 1);
      }
      if (*(long long *)(nextDataIndex3 + 8 + systemOperationFlags) != 0) {
        UnsignedStackFlag78 = 0;
        if (charPointer80 != (char *)0x0) {
          *charPointer80 = '\0';
        }
        processFlags70 = processFlags70 & 0xffffffff;
      }
      validationStatusFlag = *charPointer80;
      while (validationStatusFlag != '\0') {
        localSystemFlags = strchr(&SystemCharacterReplacementTable,(int)charPointer80[nextDataIndex1]);
        if (localSystemFlags != 0) {
          charPointer80[nextDataIndex1] = '_';
        }
        nextDataIndex1 = nextDataIndex1 + 1;
        validationStatusFlag = charPointer80[nextDataIndex1];
      }
      systemFunctionPointer4 = "";
      if (charPointer80 != (char *)0x0) {
        systemFunctionPointer4 = charPointer80;
      }
      SetSystemPropertyStringValue(pcurrentThreadId,&SystemPropertyNameTemplate,systemFunctionPointer4);
      scaleFactorValue = *(double *)(nextDataIndex3 + 0xa0 + systemOperationFlags);
      numericValue = (double)*(uint *)(nextDataIndex3 + 0xb0 + systemOperationFlags);
      if (numericValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyNumericTemplate,numericValue);
      }
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyScaleFactorTemplate,scaleFactorValue);
      }
      scaleFactorValue = *(double *)(nextDataIndex3 + 0xb8 + systemOperationFlags);
      numericValue = (double)*(uint *)(nextDataIndex3 + 200 + systemOperationFlags);
      if (numericValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyVerticalScaleTemplate,numericValue);
      }
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyAspectRatioTemplate,scaleFactorValue);
      }
      scaleFactorValue = *(double *)(nextDataIndex3 + 0x20 + systemOperationFlags);
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyWidthTemplate,scaleFactorValue);
      }
      scaleFactorValue = *(double *)(nextDataIndex3 + 0x28 + systemOperationFlags);
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyHeightTemplate,scaleFactorValue);
      }
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x30 + systemOperationFlags);
      scaleFactorValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationSizeTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x38 + systemOperationFlags);
      scaleFactorValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationWidthTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x40 + systemOperationFlags);
      scaleFactorValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationHeightTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x48 + systemOperationFlags);
      scaleFactorValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationDepthTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x50 + systemOperationFlags);
      formatValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationFormatTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x58 + systemOperationFlags);
      formatValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationTypeTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x60 + systemOperationFlags);
      formatValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationModeTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x68 + systemOperationFlags);
      formatValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationSpeedTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 0x70 + systemOperationFlags);
      qualityValue = (double)nextDataIndex1;
      if (nextDataIndex1 < 0) {
        qualityValue = qualityValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(pcurrentThreadId,&SystemConfigurationTemplate,&SystemConfigurationQualityTemplate,
                    (double)(float)(qualityValue * 9.5367431640625e-07));
      alphaValue = *(double *)(nextDataIndex3 + 0x78 + systemOperationFlags);
      if (alphaValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyAlphaTemplate,alphaValue);
      }
      betaValue = *(double *)(nextDataIndex3 + 0x80 + systemOperationFlags);
      if (betaValue != 0.0) {
        SetSystemPropertyNumericValue(pcurrentThreadId,&SystemPropertyTemplate,&SystemPropertyBetaTemplate,betaValue);
      }
      nextDataIndex3 = systemOperationFlags + 0xd0 + nextDataIndex3;
      nextDataIndex1 = *(long long *)(nextDataIndex3 + 8);
      unsignedSystemValue4 = (uint)systemStatus2;
      while (nextDataIndex1 != nextDataIndex3) {
        localSystemFlags = 0;
        pUnsignedStackFlagA8 = &SystemGlobalDataReference;
        SystemConfigurationValue = 0;
        charPointerA0 = (char *)0x0;
        systemConfigurationValue = 0;
        InitializeSystemDataBuffer(&pUnsignedStackFlagA8,*(uint32_t *)(nextDataIndex1 + 0x50));
        if (*(int *)(nextDataIndex1 + 0x50) != 0) {
            memcpy(charPointerA0,*(void* *)(nextDataIndex1 + 0x48),*(int *)(nextDataIndex1 + 0x50) + 1);
        }
        if (*(long long *)(nextDataIndex1 + 0x48) != 0) {
          systemConfigurationValue = 0;
          if (charPointerA0 != (char *)0x0) {
            *charPointerA0 = '\0';
          }
          SystemConfigurationValue = StackParameterC & 0xffffffff;
        }
        validationStatusFlag = *charPointerA0;
        while (validationStatusFlag != '\0') {
          localDataIndex = strchr(&SystemCharacterReplacementTable,(int)charPointerA0[localSystemFlags]);
          if (localDataIndex != 0) {
            charPointerA0[localSystemFlags] = '_';
          }
          localSystemFlags = localSystemFlags + 1;
          validationStatusFlag = charPointerA0[localSystemFlags];
        }
        systemFunctionPointer4 = "";
        if (charPointerA0 != (char *)0x0) {
          systemFunctionPointer4 = charPointerA0;
        }
        SetSystemPropertyPointerValue(pcurrentThreadId,&SystemPropertyTemplate,systemFunctionPointer4,*(void* *)(nextDataIndex1 + 0x60));
        pUnsignedStackFlagA8 = &SystemGlobalDataReference;
        if (charPointerA0 != (char *)0x0) {
            SystemCleanupFunction();
        }
        charPointerA0 = (char *)0x0;
        SystemConfigurationValue = StackParameterC & 0xffffffff00000000;
        pUnsignedStackFlagA8 = &SystemMemoryAllocatorReference;
        nextDataIndex1 = SystemMemoryNodeGetNext(nextDataIndex1);
        unsignedSystemValue4 = systemStatus6;
      }
      FinalizeSystemConfiguration(pcurrentThreadId,&SystemConfigurationTerminator);
      pUnsignedStackFlag88 = &SystemGlobalDataReference;
      if (charPointer80 != (char *)0x0) {
          SystemCleanupFunction();
      }
      charPointer80 = (char *)0x0;
      processFlags70 = processFlags70 & 0xffffffff00000000;
      pUnsignedStackFlag88 = &SystemMemoryAllocatorReference;
      systemStatus6 = unsignedSystemValue4 + 1;
      systemStatus2 = (ulong long)systemStatus6;
      systemOperationFlags = systemOperationFlags + 0x100;
    } while ((ulong long)(long long)(int)systemStatus6 < (ulong long)(SystemInitializationDataEnd - SystemInitializationDataStart >> 8));
  }
  systemStatus7 = 0;
  FinalizeSystemConfiguration(pcurrentThreadId,&SystemConfigurationTerminatorPointer);
  if ((SystemInitializationProgress - SystemInitializationStatusCode) / 0x28 != 0) {
    nextDataIndex1 = 0;
    do {
      localSystemFlags = SystemInitializationStatusCode;
      nextDataIndex3 = 0;
      systemFunctionPointer4 = *(char **)(SystemInitializationStatusCode + 8 + nextDataIndex1);
      validationStatusFlag = *systemFunctionPointer4;
      while (validationStatusFlag != '\0') {
        localDataIndex = strchr(&SystemCharacterReplacementTable,(int)systemFunctionPointer4[nextDataIndex3]);
        if (localDataIndex != 0) {
          *(uint8_t *)(nextDataIndex3 + *(long long *)(localSystemFlags + 8 + nextDataIndex1)) = 0x5f;
        }
        nextDataIndex3 = nextDataIndex3 + 1;
        systemFunctionPointer4 = *(char **)(localSystemFlags + 8 + nextDataIndex1);
        validationStatusFlag = systemFunctionPointer4[nextDataIndex3];
      }
      punsignedSystemValue9 = *(void* **)(SystemInitializationStatusCode + 8 + nextDataIndex1);
      ThreadLocalStorageEntry = &SystemStringTemplate;
      if (punsignedSystemValue9 != (void* *)0x0) {
        ThreadLocalStorageEntry = punsignedSystemValue9;
      }
      SetSystemPropertyPointerValue(pcurrentThreadId,&SystemPropertyTemplate,ThreadLocalStorageEntry,*(void* *)(SystemInitializationStatusCode + 0x20 + nextDataIndex1));
      systemStatus7 = systemStatus7 + 1;
      nextDataIndex1 = nextDataIndex1 + 0x28;
    } while ((ulong long)(long long)systemStatus7 < (ulong long)((SystemInitializationProgress - SystemInitializationStatusCode) / 0x28));
  }
  if (pcurrentThreadId[1] != 0) {
    fclose();
    pcurrentThreadId[1] = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
    if (pcurrentThreadId[1] != 0) {
      fclose();
      pcurrentThreadId[1] = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
  }
    SystemCleanupFunction(pcurrentThreadId);
}




// 函数: void ProcessSystemMemoryRegion(long long *ResourceManagerPointer)
/**
 * @brief 处理系统内存区域
 * 遍历内存区域并调用相应的处理函数
 */
void ProcessSystemMemoryRegion(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x100) {
    ProcessSystemMemoryPage(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemDataTable(long long *ResourceManagerPointer)
/**
 * @brief 初始化系统数据表
 * 初始化系统数据表，设置全局数据引用和内存分配器引用
 */
void InitializeSystemDataTable(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 5) {
    *HashEntryStatus = &SystemGlobalDataReference;
    if (HashEntryStatus[1] != 0) {
        SystemCleanupFunction();
    }
    HashEntryStatus[1] = 0;
    *(uint32_t *)(HashEntryStatus + 3) = 0;
    *HashEntryStatus = &SystemMemoryAllocatorReference;
  }
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: void ProcessSystemExceptionList(ulong long *ResourceManagerPointer)
/**
 * @brief 处理系统异常列表
 * 处理系统异常列表，管理异常处理机制
 */
void ProcessSystemExceptionList(ulong long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = (void* *)*ResourceManagerPointer;
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}





// 函数: void CleanupSystemResource(long long ResourceManagerPointer)
/**
 * @brief 清理系统资源
 * 清理系统资源，关闭文件句柄并释放资源
 */
void CleanupSystemResource(long long ResourceManagerPointer)

{
  if (ResourceManagerPointer != 0) {
    if (*(long long *)(ResourceManagerPointer + 8) != 0) {
      fclose();
      *(void* *)(ResourceManagerPointer + 8) = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
      SystemCleanupFunction(ResourceManagerPointer);
  }
  return;
}



/**
 * 管理系统资源
 * 分配和管理系统资源，包括内存和系统对象
 * 
 * @param ResourceManagerPointer 资源类型参数
 * @param resourceSize 资源大小参数
 * @param resourceConfig 资源配置参数
 * @param resourceFlags 资源标志参数
 * @return 操作结果状态码
 */
long long ManageSystemResources(long long ResourceManagerPointer,long long resourceSize,void* resourceConfig,void* resourceFlags)

{
  void* *resourcePointer;
  uint32_t resourceStatusFlag1;
  uint32_t resourceStatusFlag2;
  uint32_t resourceStatusFlag3;
  void* resourceHandle;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void* *systemConfigPointer;
  void* systemMemoryHandle;
  
  systemMemoryHandle = 0xfffffffffffffffe;
  InitializeSystemMemoryAllocator();
  *(void* *)(ResourceManagerPointer + 0x20) = *(void* *)(ConfigurationDataPointer + 0x20);
  *(void* *)(ResourceManagerPointer + 0x28) = *(void* *)(ConfigurationDataPointer + 0x28);
  resourceHandle = *(void* *)(ConfigurationDataPointer + 0x38);
  *(void* *)(ResourceManagerPointer + 0x30) = *(void* *)(ConfigurationDataPointer + 0x30);
  *(void* *)(ResourceManagerPointer + 0x38) = resourceHandle;
  resourceHandle = *(void* *)(ConfigurationDataPointer + 0x48);
  *(void* *)(ResourceManagerPointer + 0x40) = *(void* *)(ConfigurationDataPointer + 0x40);
  *(void* *)(ResourceManagerPointer + 0x48) = resourceHandle;
  resourceHandle = *(void* *)(ConfigurationDataPointer + 0x58);
  *(void* *)(ResourceManagerPointer + 0x50) = *(void* *)(ConfigurationDataPointer + 0x50);
  *(void* *)(ResourceManagerPointer + 0x58) = resourceHandle;
  resourceStatusFlag1 = *(uint32_t *)(ConfigurationDataPointer + 100);
  resourceStatusFlag2 = *(uint32_t *)(ConfigurationDataPointer + 0x68);
  resourceStatusFlag3 = *(uint32_t *)(ConfigurationDataPointer + 0x6c);
  *(uint32_t *)(ResourceManagerPointer + 0x60) = *(uint32_t *)(ConfigurationDataPointer + 0x60);
  *(uint32_t *)(ResourceManagerPointer + 100) = resourceStatusFlag1;
  *(uint32_t *)(ResourceManagerPointer + 0x68) = resourceStatusFlag2;
  *(uint32_t *)(ResourceManagerPointer + 0x6c) = resourceStatusFlag3;
  *(void* *)(ResourceManagerPointer + 0x70) = *(void* *)(ConfigurationDataPointer + 0x70);
  *(void* *)(ResourceManagerPointer + 0x78) = *(void* *)(ConfigurationDataPointer + 0x78);
  *(void* *)(ResourceManagerPointer + 0x80) = *(void* *)(ConfigurationDataPointer + 0x80);
  *(void* *)(ResourceManagerPointer + 0x88) = *(void* *)(ConfigurationDataPointer + 0x88);
  *(void* *)(ResourceManagerPointer + 0x90) = *(void* *)(ConfigurationDataPointer + 0x90);
  *(uint32_t *)(ResourceManagerPointer + 0x98) = *(uint32_t *)(ConfigurationDataPointer + 0x98);
  *(uint32_t *)(ResourceManagerPointer + 0x9c) = *(uint32_t *)(ConfigurationDataPointer + 0x9c);
  *(void* *)(ResourceManagerPointer + 0xa0) = *(void* *)(ConfigurationDataPointer + 0xa0);
  *(void* *)(ResourceManagerPointer + 0xa8) = *(void* *)(ConfigurationDataPointer + 0xa8);
  *(uint32_t *)(ResourceManagerPointer + 0xb0) = *(uint32_t *)(ConfigurationDataPointer + 0xb0);
  *(uint32_t *)(ResourceManagerPointer + 0xb4) = *(uint32_t *)(ConfigurationDataPointer + 0xb4);
  *(void* *)(ResourceManagerPointer + 0xb8) = *(void* *)(ConfigurationDataPointer + 0xb8);
  *(void* *)(ResourceManagerPointer + 0xc0) = *(void* *)(ConfigurationDataPointer + 0xc0);
  *(uint32_t *)(ResourceManagerPointer + 200) = *(uint32_t *)(ConfigurationDataPointer + 200);
  *(uint32_t *)(ResourceManagerPointer + 0xcc) = *(uint32_t *)(ConfigurationDataPointer + 0xcc);
  pointerToUnsigned1 = (void* *)(ResourceManagerPointer + 0xd0);
  *pointerToUnsigned1 = 0;
  *(void* *)(ResourceManagerPointer + 0xd8) = 0;
  *(void* *)(ResourceManagerPointer + 0xe0) = 0;
  *(void* *)(ResourceManagerPointer + 0xe8) = 0;
  *(void* *)(ResourceManagerPointer + 0xf0) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xf8) = *(uint32_t *)(ConfigurationDataPointer + 0xf8);
  *pointerToUnsigned1 = pointerToUnsigned1;
  *(void* **)(ResourceManagerPointer + 0xd8) = pointerToUnsigned1;
  *(void* *)(ResourceManagerPointer + 0xe0) = 0;
  *(uint8_t *)(ResourceManagerPointer + 0xe8) = 0;
  *(void* *)(ResourceManagerPointer + 0xf0) = 0;
  if (*(long long *)(ConfigurationDataPointer + 0xe0) != 0) {
    punsignedSystemValue9 = (void* *)CreateResourceManagerPointer(pointerToUnsigned1,*(long long *)(ConfigurationDataPointer + 0xe0),pointerToUnsigned1,ConfigurationFlag,systemOperationFlags)
    ;
    *(void* **)(ResourceManagerPointer + 0xe0) = punsignedSystemValue9;
    newThreadLocalStorage = (void* *)*punsignedSystemValue9;
    HashBucketNode = punsignedSystemValue9;
    while (resourceEntryPointer = newThreadLocalStorage, resourceEntryPointer != (void* *)0x0) {
      HashBucketNode = SystemCurrentNode;
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    *pointerToUnsigned1 = HashBucketNode;
    pointerToUnsigned1 = (void* *)punsignedSystemValue9[1];
    while (HashBucketNode = pointerToUnsigned1, HashBucketNode != (void* *)0x0) {
      punsignedSystemValue9 = HashBucketNode;
      pointerToUnsigned1 = (void* *)HashBucketNode[1];
    }
    *(void* **)(ResourceManagerPointer + 0xd8) = punsignedSystemValue9;
    *(void* *)(ResourceManagerPointer + 0xf0) = *(void* *)(ConfigurationDataPointer + 0xf0);
  }
  return ResourceManagerPointer;
}



/**
 * 分配系统资源
 * 根据参数分配系统资源并返回资源指针
 * 
 * @param ResourceManagerPointer 资源指针
 * @param ConfigurationDataPointer 资源大小标志
 * @param AdditionalParameter 资源配置参数
 * @param ConfigurationFlag 资源标志参数
 * @return 分配的资源指针
 */
void* AllocateSystemResources(void* ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,200,AdditionalParameter,ConfigurationFlag,systemStatus);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 系统内存节点查找函数
 * 
 * 该函数在系统内存数据结构中查找指定的节点，进行字符串比较和内存匹配。
 * 它遍历内存链表，比较内存块的内容，并返回找到的节点。
 * 
 * @param ResourceManagerPointer 内存链表头指针
 * @param OutputNodePointer 输出参数，用于返回找到的节点
 * @param ReservedParameter 保留参数
 * @param TargetNodePointer 要查找的节点指针
 * @param SearchParameters 查找参数，包含字符串比较信息
 * @return 返回找到的节点指针
 */
void* * SystemMemoryNodeFinder(long long *ResourceManagerPointer,void* *OutputNodePointer,void* ReservedParameter,long long *TargetNodePointer,
             long long SearchParameters)

{
  byte ByteValue;
  bool ComparisonResult;
  long long *MemoryListNode;
  long long* SystemMemoryPointer;
  byte *StringPointer;
  uint UIntValue;
  long long LongValue;
  void* VoidPointer;
  long long *StackPointer;
  
  MemoryListNode = (long long *)*ResourceManagerPointer;
  if ((TargetNodePointer == MemoryListNode) || (TargetNodePointer == ResourceManagerPointer)) {
    if ((ResourceManagerPointer[4] != 0) && (*(int *)(SearchParameters + 0x10) != 0)) {
      TargetNodePointer = MemoryListNode;
      if (*(int *)(MemoryListNode + 6) != 0) {
        StringPointer = *(byte **)(SearchParameters + 8);
        LongValue = MemoryListNode[5] - (long long)StringPointer;
        do {
          ByteValue = *StringPointer;
          UIntValue = (uint)StringPointer[LongValue];
          if (ByteValue != UIntValue) break;
          StringPointer = StringPointer + 1;
        } while (UIntValue != 0);
        if ((int)(ByteValue - UIntValue) < 1) goto ComparisonResultHandler;
      }
LABEL_TARGET_NODE_VALIDATION_START:
      VoidPointer = 0;
LABEL_TARGET_NODE_VALIDATION_CONTINUE:
      if (TargetNodePointer != (long long *)0x0) {
        ProcessSystemNodeSearch(ResourceManagerPointer,OutputNodePointer,TargetNodePointer,VoidPointer,SearchParameters);
        return OutputNodePointer;
      }
    }
  }
  else {
    MemoryListNode = (long long *)SystemMemoryNodeGetNext(TargetNodePointer);
    if (*(int *)(SearchParameters + 0x10) != 0) {
      if ((int)TargetNodePointer[6] != 0) {
        StringPointer = *(byte **)(SearchParameters + 8);
        LongValue = TargetNodePointer[5] - (long long)StringPointer;
        do {
          ByteValue = *StringPointer;
          UIntValue = (uint)StringPointer[LongValue];
          if (ByteValue != UIntValue) break;
          StringPointer = StringPointer + 1;
        } while (UIntValue != 0);
        if ((int)(ByteValue - UIntValue) < 1) goto ComparisonResultHandler;
      }
      if ((int)MemoryListNode[6] != 0) {
        StringPointer = (byte *)MemoryListNode[5];
        LongValue = *(long long *)(SearchParameters + 8) - (long long)StringPointer;
        do {
          ByteValue = *StringPointer;
          UIntValue = (uint)StringPointer[LongValue];
          if (ByteValue != UIntValue) break;
          StringPointer = StringPointer + 1;
        } while (UIntValue != 0);
        if (0 < (int)(ByteValue - UIntValue)) {
          if (*TargetNodePointer == 0) goto TargetNodeValidationHandler;
          VoidPointer = 1;
          TargetNodePointer = MemoryListNode;
          goto MemoryListNodeAssignment;
        }
      }
    }
  }
ComparisonResultHandler:
  ComparisonResult = true;
  MemoryListNode = (long long *)ResourceManagerPointer[2];
  SystemMemoryPointer = ResourceManagerPointer;
  while (MemoryListNode != (long long *)0x0) {
    SystemMemoryPointer = MemoryListNode;
    if ((int)MemoryListNode[6] == 0) {
      ComparisonResult = false;
MemoryListTraversal:
      MemoryListNode = (long long *)*MemoryListNode;
    }
    else {
      if (*(int *)(SearchParameters + 0x10) == 0) {
        ComparisonResult = true;
      }
      else {
        StringPointer = (byte *)MemoryListNode[5];
        LongValue = *(long long *)(SearchParameters + 8) - (long long)StringPointer;
        do {
          currentChar = *StringPointer;
          hashValue = (uint)StringPointer[LongValue];
          if (currentChar != hashValue) break;
          StringPointer = StringPointer + 1;
        } while (hashValue != 0);
        ComparisonResult = 0 < (int)(currentChar - hashValue);
      }
      if (!ComparisonResult) goto MemoryListTraversal;
      pbufferBaseAddress = (long long *)pbufferBaseAddress[1];
    }
  }
  pbufferBaseAddress = plocalResourceOffset;
  if (ComparisonResult) {
    if (plocalResourceOffset != (long long *)ResourceManagerPointer[1]) {
      pbufferBaseAddress = (long long *)SystemResourceOffsetGet(plocalResourceOffset);
      goto SystemDataValidation;
    }
  }
  else {
SystemDataValidation:
    if (*(int *)(SystemDataStructurePointer + 0x10) == 0) goto SystemDataBufferValidation;
    if ((int)pbufferBaseAddress[6] != 0) {
      StringPointer = *(byte **)(SystemDataStructurePointer + 8);
      localDataIndex = pbufferBaseAddress[5] - (long long)StringPointer;
      do {
        currentChar = *StringPointer;
        hashValue = (uint)StringPointer[localDataIndex];
        if (currentChar != hashValue) break;
        StringPointer = StringPointer + 1;
      } while (hashValue != 0);
      if ((int)(currentChar - hashValue) < 1) goto SystemDataBufferValidation;
    }
  }
  ExecuteSystemNodeProcessing(ResourceManagerPointer,&plStackX_8,plocalResourceOffset,0,SystemDataStructurePointer);
  pbufferBaseAddress = plStackX_8;
SystemDataBufferValidation:
  *ConfigurationDataPointer = pbufferBaseAddress;
  return ConfigurationDataPointer;
}





// 函数: void ProcessSystemDataTransfer(long long ResourceManagerPointer,void* ConfigurationDataPointer,long long AdditionalParameter,void* ConfigurationFlag,
/**
 * @brief 处理系统数据传输
 * 处理系统数据传输，在内存区域之间传输数据
 */
void ProcessSystemDataTransfer(long long ResourceManagerPointer,void* ConfigurationDataPointer,long long AdditionalParameter,void* ConfigurationFlag,
                  long long SystemDataStructurePointer)

{
  byte currentByte;
  byte *stringPointer;
  uint compareValue;
  void* *punsignedSystemValue4;
  long long SystemTimeValue;
  void* hashValue;
  void* unsignedSystemValue7;
  
  unsignedSystemValue7 = 0xfffffffffffffffe;
  hashValue = 0;
  if (((char)ConfigurationFlag != '\0') || (AdditionalParameter == ResourceManagerPointer)) goto SystemThreadInitialization;
  if (*(int *)(AdditionalParameter + 0x30) != 0) {
    if (*(int *)(SystemDataStructurePointer + 0x10) == 0) goto SystemThreadCreation;
    stringPointer = *(byte **)(AdditionalParameter + 0x28);
    localSystemPointer = *(long long *)(SystemDataStructurePointer + 8) - (long long)stringPointer;
    do {
      currentByte = *stringPointer;
      compareValue = (uint)stringPointer[localSystemPointer];
      if (currentByte != compareValue) break;
      stringPointer = stringPointer + 1;
    } while (compareValue != 0);
    if (0 < (int)(currentByte - compareValue)) goto SystemThreadCreation;
  }
  hashValue = 1;
SystemThreadCreation:
  localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,*(uint8_t *)(ResourceManagerPointer + 0x28),ConfigurationFlag,
                        0xfffffffffffffffe);
  InitializeSystemMemoryAllocator(localSystemPointer + 0x20,SystemDataStructurePointer);
  punsignedSystemValue4 = (void* *)(localSystemPointer + 0x40);
  *(void* *)(localSystemPointer + 0x50) = 0;
  *(void* *)(localSystemPointer + 0x58) = 0;
  *(void* *)(localSystemPointer + 0x60) = 0;
  *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
  *(void* *)(localSystemPointer + 0x48) = 0;
  *(uint32_t *)(localSystemPointer + 0x50) = 0;
  *punsignedSystemValue4 = &SystemGlobalDataReference;
  *(void* *)(localSystemPointer + 0x58) = 0;
  *(void* *)(localSystemPointer + 0x48) = 0;
  *(uint32_t *)(localSystemPointer + 0x50) = 0;
    InitializeSystemThreadContext(localSystemPointer,AdditionalParameter,ResourceManagerPointer,hashValue,unsignedSystemValue7,punsignedSystemValue4);
}




void* * CreateResourceManagerPointer(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  void** SystemDataTable;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  HashNodePointer = (void* *)CreateSystemResourceTemplate();
  if (*ConfigurationDataPointer != 0) {
    currentThreadId = InitializeSystemResourceHandle(ResourceManagerPointer,*ConfigurationDataPointer,HashNodePointer,ConfigurationFlag,currentThreadId);
    *HashNodePointer = currentThreadId;
  }
  HashEntryStatus = HashNodePointer;
  for (PrimaryResourcePointer = (long long *)ConfigurationDataPointer[1]; PrimaryResourcePointer != (long long *)0x0; PrimaryResourcePointer = (long long *)PrimaryResourcePointer[1]) {
    punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,*(uint8_t *)(ResourceManagerPointer + 0x28));
    InitializeSystemMemoryAllocator(punsignedSystemValue4 + 4,PrimaryResourcePointer + 4);
    InitializeSystemMemoryAllocator(punsignedSystemValue4 + 8,PrimaryResourcePointer + 8);
    punsignedSystemValue4[0xc] = PrimaryResourcePointer[0xc];
    *punsignedSystemValue4 = 0;
    punsignedSystemValue4[1] = 0;
    punsignedSystemValue4[2] = HashEntryStatus;
    *(char *)(punsignedSystemValue4 + 3) = (char)PrimaryResourcePointer[3];
    HashEntryStatus[1] = punsignedSystemValue4;
    if (*PrimaryResourcePointer != 0) {
      currentThreadId = InitializeSystemResourceHandle(ResourceManagerPointer,*PrimaryResourcePointer,punsignedSystemValue4);
      *punsignedSystemValue4 = currentThreadId;
    }
    HashEntryStatus = punsignedSystemValue4;
  }
  return HashNodePointer;
}




void* * CreateSystemResourceTemplate(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  
  pointerToUnsigned1 = (void* *)
           CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,*(uint8_t *)(ResourceManagerPointer + 0x28),ConfigurationFlag,
                         0xfffffffffffffffe);
  InitializeSystemMemoryAllocator(pointerToUnsigned1 + 4,ConfigurationDataPointer + 0x20);
  InitializeSystemMemoryAllocator(pointerToUnsigned1 + 8,ConfigurationDataPointer + 0x40);
  pointerToUnsigned1[0xc] = *(void* *)(ConfigurationDataPointer + 0x60);
  *pointerToUnsigned1 = 0;
  pointerToUnsigned1[1] = 0;
  pointerToUnsigned1[2] = AdditionalParameter;
  *(uint8_t *)(pointerToUnsigned1 + 3) = *(uint8_t *)(ConfigurationDataPointer + 0x18);
  return pointerToUnsigned1;
}



/**
 * @brief 系统内存块批量初始化函数
 * 
 * 该函数批量初始化系统内存块，设置内存分配器引用和全局数据引用。
 * 它遍历指定的内存区域，为每个内存块设置相应的引用和参数。
 * 
 * @param ResourceManagerPointer 输出参数，用于返回初始化后的内存块
 * @param MemoryRegionStart 内存区域的起始地址
 * @param MemoryRegionEnd 内存区域的结束地址
 * @param MemoryBlockPointer 要初始化的内存块指针
 * @return 返回初始化后的内存块指针
 */
void* * SystemMemoryBatchInitializer(void* *ResourceManagerPointer,long long *MemoryRegionStart,long long *MemoryRegionEnd,void* *MemoryBlockPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  uint32_t allocationContext;
  long long bufferBaseAddress;
  long long *plocalSystemPointer;
  
  *ResourceManagerPointer = MemoryBlockPointer;
  if (MemoryRegionStart != MemoryRegionEnd) {
    plocalSystemPointer = MemoryRegionStart + 0x1b;
    do {
      *MemoryBlockPointer = &SystemMemoryAllocatorReference;
      MemoryBlockPointer[1] = 0;
      *(uint32_t *)(MemoryBlockPointer + 2) = 0;
      *MemoryBlockPointer = &SystemGlobalDataReference;
      MemoryBlockPointer[3] = 0;
      MemoryBlockPointer[1] = 0;
      *(uint32_t *)(MemoryBlockPointer + 2) = 0;
      *(int *)(ConfigurationFlag + 2) = (int)plocalSystemPointer[-0x19];
      ConfigurationFlag[1] = plocalSystemPointer[-0x1a];
      *(uint32_t *)((long long)ConfigurationFlag + 0x1c) = *(uint32_t *)((long long)plocalSystemPointer + -0xbc);
      *(int *)(ConfigurationFlag + 3) = (int)plocalSystemPointer[-0x18];
      *(uint32_t *)(plocalSystemPointer + -0x19) = 0;
      plocalSystemPointer[-0x1a] = 0;
      plocalSystemPointer[-0x18] = 0;
      ConfigurationFlag[4] = plocalSystemPointer[-0x17];
      ConfigurationFlag[5] = plocalSystemPointer[-0x16];
      bufferBaseAddress = plocalSystemPointer[-0x14];
      ConfigurationFlag[6] = plocalSystemPointer[-0x15];
      ConfigurationFlag[7] = bufferBaseAddress;
      bufferBaseAddress = plocalSystemPointer[-0x12];
      ConfigurationFlag[8] = plocalSystemPointer[-0x13];
      ConfigurationFlag[9] = bufferBaseAddress;
      bufferBaseAddress = plocalSystemPointer[-0x10];
      ConfigurationFlag[10] = plocalSystemPointer[-0x11];
      ConfigurationFlag[0xb] = bufferBaseAddress;
      bufferBaseAddress = plocalSystemPointer[-0xe];
      ConfigurationFlag[0xc] = plocalSystemPointer[-0xf];
      ConfigurationFlag[0xd] = bufferBaseAddress;
      ConfigurationFlag[0xe] = plocalSystemPointer[-0xd];
      ConfigurationFlag[0xf] = plocalSystemPointer[-0xc];
      ConfigurationFlag[0x10] = plocalSystemPointer[-0xb];
      ConfigurationFlag[0x11] = plocalSystemPointer[-10];
      ConfigurationFlag[0x12] = plocalSystemPointer[-9];
      *(int *)(ConfigurationFlag + 0x13) = (int)plocalSystemPointer[-8];
      *(uint32_t *)((long long)ConfigurationFlag + 0x9c) = *(uint32_t *)((long long)plocalSystemPointer + -0x3c);
      ConfigurationFlag[0x14] = plocalSystemPointer[-7];
      ConfigurationFlag[0x15] = plocalSystemPointer[-6];
      *(int *)(ConfigurationFlag + 0x16) = (int)plocalSystemPointer[-5];
      *(uint32_t *)((long long)ConfigurationFlag + 0xb4) = *(uint32_t *)((long long)plocalSystemPointer + -0x24);
      ConfigurationFlag[0x17] = plocalSystemPointer[-4];
      ConfigurationFlag[0x18] = plocalSystemPointer[-3];
      *(int *)(ConfigurationFlag + 0x19) = (int)plocalSystemPointer[-2];
      *(uint32_t *)((long long)ConfigurationFlag + 0xcc) = *(uint32_t *)((long long)plocalSystemPointer + -0xc);
      resourcePoolPointer = ConfigurationFlag + 0x1a;
      *resourcePoolPointer = 0;
      ConfigurationFlag[0x1b] = 0;
      ConfigurationFlag[0x1c] = 0;
      ConfigurationFlag[0x1d] = 0;
      ConfigurationFlag[0x1e] = 0;
      *(int *)(ConfigurationFlag + 0x1f) = (int)plocalSystemPointer[4];
      *resourcePoolPointer = (long long)resourcePoolPointer;
      ConfigurationFlag[0x1b] = resourcePoolPointer;
      ConfigurationFlag[0x1c] = 0;
      *(uint8_t *)(ConfigurationFlag + 0x1d) = 0;
      ConfigurationFlag[0x1e] = 0;
      ConfigurationFlag[0x1e] = plocalSystemPointer[3];
      plocalSystemPointer[3] = 0;
      allocationContext = *(uint32_t *)(ConfigurationFlag + 0x1f);
      *(int *)(ConfigurationFlag + 0x1f) = (int)plocalSystemPointer[4];
      *(uint32_t *)(plocalSystemPointer + 4) = allocationContext;
      if (ConfigurationFlag[0x1c] == 0) {
        if (plocalSystemPointer[1] != 0) {
          PrimaryResourcePointer = plocalSystemPointer + -1;
          *resourcePoolPointer = *PrimaryResourcePointer;
          ConfigurationFlag[0x1b] = *plocalSystemPointer;
          bufferBaseAddress = plocalSystemPointer[1];
          ConfigurationFlag[0x1c] = bufferBaseAddress;
          *(long long **)(bufferBaseAddress + 0x10) = resourcePoolPointer;
          *PrimaryResourcePointer = (long long)PrimaryResourcePointer;
          *plocalSystemPointer = (long long)PrimaryResourcePointer;
          plocalSystemPointer[1] = 0;
        }
      }
      else if (plocalSystemPointer[1] == 0) {
        plocalSystemPointer[-1] = *resourcePoolPointer;
        *plocalSystemPointer = ConfigurationFlag[0x1b];
        bufferBaseAddress = ConfigurationFlag[0x1c];
        plocalSystemPointer[1] = bufferBaseAddress;
        *(long long **)(bufferBaseAddress + 0x10) = plocalSystemPointer + -1;
        *resourcePoolPointer = (long long)resourcePoolPointer;
        ConfigurationFlag[0x1b] = resourcePoolPointer;
        ConfigurationFlag[0x1c] = 0;
      }
      else {
        bufferBaseAddress = *resourcePoolPointer;
        PrimaryResourcePointer = plocalSystemPointer + -1;
        *resourcePoolPointer = *PrimaryResourcePointer;
        *PrimaryResourcePointer = bufferBaseAddress;
        bufferBaseAddress = ConfigurationFlag[0x1b];
        ConfigurationFlag[0x1b] = *plocalSystemPointer;
        *plocalSystemPointer = bufferBaseAddress;
        bufferBaseAddress = ConfigurationFlag[0x1c];
        ConfigurationFlag[0x1c] = plocalSystemPointer[1];
        plocalSystemPointer[1] = bufferBaseAddress;
        *(long long **)(ConfigurationFlag[0x1c] + 0x10) = resourcePoolPointer;
        *(long long **)(plocalSystemPointer[1] + 0x10) = PrimaryResourcePointer;
      }
      ConfigurationFlag = ConfigurationFlag + 0x20;
      *ResourceManagerPointer = ConfigurationFlag;
      resourcePoolPointer = plocalSystemPointer + 5;
      plocalSystemPointer = plocalSystemPointer + 0x20;
    } while (resourcePoolPointer != AdditionalParameter);
  }
  return ResourceManagerPointer;
}




// 函数: void ResetSystemMemoryManager(void* *ResourceManagerPointer)
/**
 * @brief 重置系统内存管理器
 * 重置系统内存管理器，销毁互斥锁和条件变量
 */
void ResetSystemMemoryManager(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemMutexTemplate;
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ(ResourceManagerPointer + 4);
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  return;
}



/**
 * @brief 内存释放管理函数
 * 
 * 根据标志位管理内存的释放操作
 * 
 * @param memoryPointer 内存指针
 * @param flags 操作标志位
 * @return 返回内存指针
 */
void* MemoryReleaseManager(void* memoryPointer, unsigned long long flags)

{
  MemoryManagementInternalFunction();
  if ((flags & 1) != 0) {
    free(memoryPointer,0xc0);
  }
  return memoryPointer;
}




// 函数: void LockSystemMutex(long long ResourceManagerPointer,uint8_t ConfigurationDataPointer)
/**
 * @brief 锁定系统互斥锁
 * 锁定系统互斥锁，确保线程安全
 */
void LockSystemMutex(long long ResourceManagerPointer,uint8_t ConfigurationDataPointer)

{
  int systemStatus;
  
  systemStatus = _Mtx_lock(ResourceManagerPointer + 0x48);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  *(uint8_t *)(ResourceManagerPointer + 0x98) = ConfigurationDataPointer;
  systemStatus = _Mtx_unlock(ResourceManagerPointer + 0x48);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  return;
}





// 函数: void ProcessSystemTimestampHandler(void* ResourceManagerPointer,void* *ConfigurationDataPointer,long long *AdditionalParameter)
/**
 * @brief 系统时间戳处理器
 * 
 * 该函数处理系统时间戳相关的操作，包括时间获取、时间比较和时间处理。
 * 它使用系统时间戳来执行各种时间相关的计算和处理。
 * 
 * @param ResourceManagerPointer 系统上下文参数
 * @param ConfigurationDataPointer 输出参数，用于返回处理结果
 * @param AdditionalParameter 时间戳参数
 * 
 * @note 这是系统时间管理的重要组成部分，确保时间相关操作的正确性
 */
void ProcessSystemTimestampHandler(void* ResourceManagerPointer,void* *ConfigurationDataPointer,long long *AdditionalParameter)

{
  int systemStatus;
  uint creationFlags;
  long long localResourceOffset;
  uint8_t EncryptionBuffer58 [32];
  long long longValue38;
  int intValue30;
  ulong long EncryptionKeyValue;
  
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer58;
  if (*AdditionalParameter < 1) {
    longValue38 = 0;
    intValue30 = 0;
  }
  else {
    localResourceOffset = _Xtime_get_ticks();
    localResourceOffset = (localResourceOffset + *AdditionalParameter * 10) * 100;
    longValue38 = localResourceOffset / 1000000000;
    intValue30 = (int)localResourceOffset + (int)longValue38 * -1000000000;
  }
  systemStatus = _Mtx_current_owns(*ConfigurationDataPointer);
  if (systemStatus == 0) {
    __Throw_Cpp_error_std__YAXH_Z(4);
  }
  creationFlags = _Cnd_timedwait(ResourceManagerPointer,*ConfigurationDataPointer,&longValue38);
  if ((creationFlags & 0xfffffffd) != 0) {
    __Throw_C_error_std__YAXH_Z(creationFlags);
  }
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)EncryptionBuffer58);
}



/**
 * @brief 系统初始化数据处理函数
 * 
 * 该函数负责处理系统初始化过程中的数据，包括资源管理和配置处理
 * 用于系统初始化阶段的数据处理和同步操作
 * 
 * @param ResourceManagerPointer 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含系统配置信息
 * @param AdditionalParameter 附加参数，提供额外的配置选项
 * @param ConfigurationFlag 配置标志，指定配置的方式和选项
 * @return 系统状态，返回初始化处理的状态结果
 * 
 * 原始函数名为FUN_180077a60，现已重命名为SystemInitializationProcessData
 */
uint8_t SystemInitializationProcessData(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint8_t systemStatus;
  int systemResult;
  void* timeoutParameter;
  void* allocationContext;
  long long mutexAddress;
  char lockAcquiredFlag;
  
  allocationContext = 0xfffffffffffffffe;
  mutexAddress = ResourceManagerPointer + 0x48;
  lockAcquiredFlag = 0;
  systemResult = _Mtx_lock();
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  lockAcquiredFlag = '\x01';
  if (*(char *)(ResourceManagerPointer + 0x98) == '\x01') {
    systemStatus = 1;
  }
  else {
    timeoutParameter = 1;
    ProcessSystemTimestampHandler(ResourceManagerPointer,&mutexAddress,&timeoutParameter,ConfigurationFlag,allocationContext);
    systemStatus = *(uint8_t *)(ResourceManagerPointer + 0x98);
  }
  *(uint8_t *)(ResourceManagerPointer + 0x98) = 0;
  if (lockAcquiredFlag != '\0') {
    systemResult = _Mtx_unlock(mutexAddress);
    if (systemResult != 0) {
      __Throw_C_error_std__YAXH_Z(systemResult);
    }
  }
  return systemStatus;
}




/**
 * @brief 销毁系统条件变量
 * 
 * 该函数负责销毁系统中的条件变量，释放相关资源。
 * 这是一个清理函数，通常在系统关闭或重置时调用。
 * 
 * @note 这是一个系统清理函数，确保条件变量资源的正确释放
 */
void DestroySystemConditionVariable(void)

{
  _Cnd_destroy_in_situ();
  return;
}





{
  _Cnd_destroy_in_situ();
  return;
}




// 函数: 销毁互斥锁
/**
 * @brief 销毁系统互斥锁
 * 
 * 该函数负责销毁系统中的互斥锁，释放相关资源。
 * 这是线程同步清理工作的一部分。
 * 
 * @note 这是系统资源清理的重要函数，确保互斥锁正确销毁
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: 销毁互斥锁副本
/**
 * @brief 销毁系统互斥锁副本
 * 
 * 该函数负责销毁系统中的互斥锁副本，释放相关资源。
 * 这是线程同步清理工作的另一个部分。
 * 
 * @note 这是系统资源清理的重要函数，确保互斥锁副本正确销毁
 */
void DestroySystemMutexDuplicate(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: 销毁互斥锁和条件变量
/**
 * @brief 销毁系统互斥锁和条件变量
 * 
 * 该函数负责同时销毁系统中的互斥锁和条件变量，释放相关资源。
 * 这是线程同步清理工作的完整部分。
 * 
 * @param conditionVariable 条件变量指针，需要被销毁的条件变量
 * 
 * @note 这是系统资源清理的重要函数，确保互斥锁和条件变量都正确销毁
 */
void DestroySystemMutexAndConditionVariable(void* conditionVariable)

{
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ(conditionVariable);
  return;
}



// 函数: 初始化同步对象
/**
 * @brief 初始化系统同步对象
 * 
 * 该函数负责初始化系统中的同步对象，包括互斥锁和条件变量。
 * 它会设置同步对象的各种属性，包括内存分配器、标志位等。
 * 
 * @param syncObject 同步对象指针，需要被初始化的同步对象
 * @param SyncContextParameter 未知参数1
 * @param SyncConfigurationParameter 未知参数2
 * @param SyncSecurityParameter 未知参数3
 * @return void** 返回初始化后的同步对象指针
 * 
 * @note 这是系统初始化的重要函数，确保同步对象正确初始化
 */
void* *
InitializeSystemSyncObject(void* *syncObject,void* SyncContextParameter,void* SyncConfigurationParameter,void* SyncSecurityParameter)

{
  void* systemErrorFlag;
  
  systemErrorFlag = 0xfffffffffffffffe;
  *syncObject = &SystemMemoryRegionTemplateA;
  *syncObject = &SystemMemoryRegionTemplateB;
  *(uint32_t *)(syncObject + 1) = 0;
  *syncObject = &SystemMemoryAllocatorReference;
  LOCK();
  *(uint8_t *)(syncObject + 2) = 0;
  UNLOCK();
  syncObject[3] = 0xffffffffffffffff;
  *syncObject = &SystemMutexTemplate;
  _Cnd_init_in_situ(syncObject + 4);
  _Mtx_init_in_situ(syncObject + 0xd,2,SyncConfigurationParameter,SyncSecurityParameter,systemErrorFlag);
  *(uint8_t *)(syncObject + 0x17) = 0;
  return syncObject;
}



// 函数: 释放内存并设置分配器
/**
 * @brief 释放内存并设置内存分配器
 * 
 * 该函数负责释放指定的内存，并设置内存分配器引用。
 * 它会根据标志位决定是否执行内存释放操作。
 * 
 * @param memoryBlock 内存块指针，需要被处理的内存块
 * @param memoryFlags 内存标志位，控制内存释放行为
 * @param SyncContextParameter 未知参数1
 * @param SyncConfigurationParameter 未知参数2
 * @return void** 返回处理后的内存块指针
 * 
 * @note 这是内存管理的重要函数，确保内存正确释放和分配器设置
 */
void* *
FreeMemoryAndSetAllocator(void* *memoryBlock,ulong long memoryFlags,void* SyncContextParameter,void* SyncConfigurationParameter)

{
  *memoryBlock = &SystemMemoryAllocatorReference;
  if ((memoryFlags & 1) != 0) {
    free(memoryBlock,0x98,SyncContextParameter,SyncConfigurationParameter,0xfffffffffffffffe);
  }
  return memoryBlock;
}




// 函数: 复制字符串数据
/**
 * @brief 复制字符串数据到指定位置
 * 
 * 该函数负责将字符串数据从源位置复制到目标位置。
 * 它会检查字符串长度，确保不会超过缓冲区大小，并在复制完成后进行清理。
 * 
 * @param targetAddress 目标地址，字符串数据要复制到的位置
 * @param sourceData 源数据，要被复制的字符串数据
 * @param dataLength 数据长度，要复制的数据长度
 * 
 * @note 这是字符串处理的重要函数，确保字符串数据安全复制
 */
void CopyStringData(long long targetAddress,void* sourceData,int dataLength)

{
  if (dataLength + 1 < 0x80) {
      memcpy(*(uint8_t **)(targetAddress + 8),sourceData,(long long)dataLength);
  }
  **(uint8_t **)(targetAddress + 8) = 0;
  *(uint32_t *)(targetAddress + 0x10) = 0;
  return;
}




// 函数: 执行内存复制操作
/**
 * @brief 执行内存复制操作
 * 
 * 该函数负责执行内存复制操作，可能是一个内联函数或者特定平台的内存复制实现。
 * 
 * @note 这是一个不返回的函数，通常用于系统级别的内存操作
 */
void ExecuteMemoryCopyOperation(void)

{
    memcpy();
}




// 函数: 重置数据结构
/**
 * @brief 重置数据结构
 * 
 * 该函数负责重置指定的数据结构，将字节标志位设置为0，
 * 并清除相关的32位字段。
 * 
 * @param dataFlagPointer 数据标志指针，指向需要重置的数据结构
 * 
 * @note 这是数据结构初始化和清理的重要函数
 */
void ResetDataStructure(uint8_t *dataFlagPointer)

{
  long long systemRegisterValue;
  
  *dataFlagPointer = 0;
  *(uint32_t *)(systemRegisterValue + 0x10) = 0;
  return;
}



// 函数: 初始化内存分配器结构
/**
 * @brief 初始化内存分配器结构
 * 
 * 该函数负责初始化内存分配器的数据结构，设置分配器的引用指针，
 * 并配置相关的内存管理参数。
 * 
 * @param memoryAllocator 内存分配器指针，需要被初始化的内存分配器结构
 * @return void** 返回初始化后的内存分配器指针
 * 
 * @note 这是内存管理初始化的重要函数，确保内存分配器正确配置
 */
void* * InitializeMemoryAllocatorStructure(void* *memoryAllocator)

{
  *memoryAllocator = &SystemMemoryAllocatorReference;
  memoryAllocator[1] = 0;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *memoryAllocator = &SystemMemoryRegionTemplateC;
  memoryAllocator[1] = memoryAllocator + 3;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *(uint8_t *)(memoryAllocator + 3) = 0;
  return memoryAllocator;
}





// 函数: void InitializeSystemResource(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统字符串处理和内存管理函数
 * 
 * 该函数处理系统字符串操作，包括字符串搜索、长度计算和内存复制。
 * 它还涉及到内存分配器的引用管理和堆栈操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含字符串处理所需的系统资源
 * @param SourceStringPointer 源字符串指针，用于长度计算和处理
 * @param TargetStringPointer 目标字符串指针，用于长度计算和处理
 */
void SystemStringProcessor(long long ResourceManagerPointer,long long SourceStringPointer,long long TargetStringPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long localResourceOffset;
  uint8_t EncryptionBuffer118 [32];
  void* unsignedValueF8;
  void* *pointerUnsignedE8;
  uint8_t *DataBufferPtrE0;
  uint32_t unsignedValueD8;
  uint8_t DataBufferD0 [136];
  ulong long EncryptionValue48;
  
  unsignedValueF8 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer118;
  pointerUnsignedE8 = &SystemResourceTemplatePrimary;
  DataBufferPtrE0 = DataBufferD0;
  unsignedValueD8 = 0;
  DataBufferD0[0] = 0;
  nextDataIndex = strstr(*(void* *)(ResourceManagerPointer + 8));
  if (nextDataIndex != 0) {
    localSystemHandle = -1;
    localResourceOffset = -1;
    do {
      localResourceOffset = localResourceOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + localResourceOffset) != '\0');
    do {
      localSystemHandle = localSystemHandle + 1;
    } while (*(char *)(localSystemHandle + AdditionalParameter) != '\0');
      memcpy(DataBufferPtrE0,*(long long *)(ResourceManagerPointer + 8),nextDataIndex - *(long long *)(ResourceManagerPointer + 8));
  }
  pointerUnsignedE8 = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)EncryptionBuffer118);
}



// 函数: void InitializeSystemManager(void* *ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存分配器初始化函数
 * 
 * 该函数初始化系统内存分配器，设置内存分配器引用和初始参数。
 * 
 * @param ResourceManagerPointer 指向内存分配器指针的指针
 * @param ConfigurationDataPointer 保留参数
 * @param AdditionalParameter 保留参数
 * @param ConfigurationFlag 保留参数
 * @return 返回初始化后的内存分配器指针
 */
void* * SystemMemoryAllocatorInitializer(void* *ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemResourceTemplatePrimary;
  ResourceManagerPointer[1] = ResourceManagerPointer + 3;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *(uint8_t *)(ResourceManagerPointer + 3) = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  pointerToUnsigned1 = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    pointerToUnsigned1 = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(ResourceManagerPointer[1],0x80,pointerToUnsigned1,ConfigurationFlag,0xfffffffffffffffe);
  return ResourceManagerPointer;
}



void* *
InitializeMemoryAllocatorReference(void* *memoryAllocatorRef,ulong long InitializationFlags,void* reservedParam3,void* reservedParam4)

{
  *memoryAllocatorRef = &SystemMemoryAllocatorReference;
  if ((InitializationFlags & 1) != 0) {
    free(memoryAllocatorRef,0x58,reservedParam3,reservedParam4,0xfffffffffffffffe);
  }
  return memoryAllocatorRef;
}




// 函数: void ProcessSystemStringCopySmall(long long ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串复制处理器（小尺寸）
 * 
 * 该函数处理小尺寸字符串的复制操作，最大长度限制为0x40字节。
 * 它检查源字符串长度，执行字符串复制，并设置相应的长度标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 * 
 * @note 这是系统字符串处理的重要组成部分，专门处理小尺寸字符串的复制
 */
void ProcessSystemStringCopySmall(long long targetBuffer,long long sourceString)

{
  long long nextDataIndex;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  nextDataIndex = -1;
  do {
    nextDataIndex = nextDataIndex + 1;
  } while (*(char *)(ConfigurationDataPointer + nextDataIndex) != '\0');
  if ((int)nextDataIndex < 0x40) {
    *(int *)(ResourceManagerPointer + 0x10) = (int)nextDataIndex;
                    000180049c27. Too many branches
                        strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x40);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x40,ConfigurationDataPointer);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




// 函数: void ProcessSystemMemoryCopySmall(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统内存复制处理器（小尺寸）
 * 
 * 该函数处理小尺寸内存的复制操作，最大长度限制为0x40字节。
 * 它检查复制长度，执行内存复制，并设置相应的结束标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 * 
 * @note 这是系统内存处理的重要组成部分，专门处理小尺寸内存的复制
 */
void ProcessSystemMemoryCopySmall(long long targetBuffer,void* sourceData,int copyLength)

{
  if (AdditionalParameter + 1 < 0x40) {
      memcpy(*(uint8_t **)(ResourceManagerPointer + 8),ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




/**
 * @brief 初始化系统内存复制操作
 * 
 * 该函数负责初始化系统的内存复制操作，通常用于系统启动时的
 * 基础内存设置和数据初始化。
 * 
 * @note 这是一个不返回的函数，通常在系统初始化的关键阶段调用
 */
void InitializeSystemMemoryCopyOperation(void)

{
    memcpy();
}




/**
 * @brief 重置系统字节标志
 * 
 * 该函数负责重置系统的字节标志，将指定参数设置为0，
 * 并清除相关的长度标志。
 * 
 * @param byteFlagPointer 指向需要重置的字节标志的指针
 * @note 这是系统状态管理的重要组成部分，确保标志的正确重置
 */
void ResetSystemByteFlag(uint8_t *byteFlagPointer)

{
  long long systemContextPointer;
  
  *byteFlagPointer = 0;
  *(uint32_t *)(systemContextPointer + 0x10) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统的内存分配器引用，设置内存分配器的基本配置
 * 和引用关系，为系统内存管理提供基础支持。
 * 
 * @param memoryAllocatorPointer 指向内存分配器指针的指针
 * @return 返回初始化后的内存分配器指针
 * @note 这是系统内存管理初始化的重要组成部分
 */
void* * InitializeSystemMemoryAllocatorReference(void* *memoryAllocatorPointer)

{
  *memoryAllocatorPointer = &SystemMemoryAllocatorReference;
  memoryAllocatorPointer[1] = 0;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *memoryAllocatorPointer = &SystemMemoryAllocatorReferenceSecondary;
  memoryAllocatorPointer[1] = memoryAllocatorPointer + 3;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *(uint8_t *)(memoryAllocatorPointer + 3) = 0;
  return memoryAllocatorPointer;
}





/**
 * @brief 处理系统三参数缓冲区
 * 
 * 该函数负责处理系统的三参数缓冲区操作，包括字符串搜索、长度计算
 * 和缓冲区处理等操作。
 * 
 * @param ResourceManagerPointer 主操作参数
 * @param ConfigurationDataPointer 辅助操作参数
 * @param AdditionalParameter 配置参数
 * @note 这是系统缓冲区管理的重要组成部分
 */
void ProcessSystemThreeParameterBuffer(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long localResourceOffset;
  uint8_t EncryptionBufferD8 [32];
  void* UnsignedStackFlagB8;
  void* *pUnsignedStackFlagA8;
  uint8_t *stackParameterA;
  uint32_t unsignedValue98;
  uint8_t aStackParameterC [72];
  ulong long EncryptionValue48;
  
  UnsignedStackFlagB8 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBufferD8;
  pUnsignedStackFlagA8 = &SystemDataBufferTemplateB;
  stackParameterA = aStackParameterC;
  systemConfigurationValue = 0;
  aStackParameterC[0] = 0;
  nextDataIndex = strstr(*(void* *)(ResourceManagerPointer + 8));
  if (nextDataIndex != 0) {
    localSystemHandle = -1;
    localResourceOffset = -1;
    do {
      localResourceOffset = localResourceOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + localResourceOffset) != '\0');
    do {
      localSystemHandle = localSystemHandle + 1;
    } while (*(char *)(localSystemHandle + AdditionalParameter) != '\0');
      memcpy(stackParameterA,*(long long *)(ResourceManagerPointer + 8),nextDataIndex - *(long long *)(ResourceManagerPointer + 8));
  }
  pUnsignedStackFlagA8 = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)EncryptionBufferD8);
}



void* *
InitializeStringBufferWithBackup(void* *stringBuffer,long long stringLength,void* reservedParam3,void* reservedParam4)

{
  long long characterIndex;
  
  *stringBuffer = &SystemMemoryAllocatorReference;
  stringBuffer[1] = 0;
  *(uint32_t *)(stringBuffer + 2) = 0;
  *stringBuffer = &SystemDataBufferBackupTemplateB;
  stringBuffer[1] = stringBuffer + 3;
  *(uint32_t *)(stringBuffer + 2) = 0;
  *(uint8_t *)(stringBuffer + 3) = 0;
  if (stringLength != 0) {
    characterIndex = -1;
    do {
      characterIndex = characterIndex + 1;
    } while (*(char *)(stringLength + characterIndex) != '\0');
    *(int *)(stringBuffer + 2) = (int)characterIndex;
    strcpy_s(stringBuffer[1],0x40,stringLength,reservedParam4,0xfffffffffffffffe);
  }
  return stringBuffer;
}




// 函数: void ResetSystemMemoryAllocator(void* *ResourceManagerPointer)
/**
 * @brief 系统内存分配器重置函数
 * 
 * 该函数重置系统内存分配器，清理内存分配器状态，重置全局数据引用，
 * 并确保内存分配器处于干净的状态。
 * 
 * @param ResourceManagerPointer 指向内存分配器指针的指针
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确重置
 */
void ResetSystemMemoryAllocator(void* *ResourceManagerPointer)

{
  ResourceManagerPointer[4] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 7) = 0;
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void InitializeAndCleanupSystemMemoryAllocator(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存分配器初始化和清理函数
 * 
 * 该函数初始化系统内存分配器，设置内存分配器引用，执行清理操作，
 * 并确保内存分配器处于正确的状态。
 * 
 * @param ResourceManagerPointer 系统上下文参数
 * @param ConfigurationDataPointer 指向内存分配器指针的指针
 * @param AdditionalParameter 清理参数
 * @param ConfigurationFlag 清理参数
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确初始化和清理
 */
void InitializeAndCleanupSystemMemoryAllocator(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  InitializeAndCleanupSystemMemoryAllocator(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  ConfigurationDataPointer[8] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[9] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0xb) = 0;
  ConfigurationDataPointer[8] = &SystemMemoryAllocatorReference;
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




/**
 * @brief 系统数据处理器A
 * 
 * 该函数是系统数据处理的包装函数，负责调用底层数据处理函数。
 * 
 * @param systemParameter 系统参数1
 * @param ConfigurationDataPointer 系统参数2
 * @param AdditionalParameter 系统参数3
 * @param ConfigurationFlag 系统参数4
 * @note 这是系统数据处理层的重要组成部分
 */
void SystemDataProcessorA(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemDataBuffer(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统数据处理器B
 * 
 * 该函数是系统数据处理的包装函数，负责调用底层数据处理函数。
 * 
 * @param systemParameter 系统参数1
 * @param ConfigurationDataPointer 系统参数2
 * @param AdditionalParameter 系统参数3
 * @param ConfigurationFlag 系统参数4
 * @note 这是系统数据处理层的重要组成部分
 */
void SystemDataProcessorB(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemDataBuffer(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统数据处理器C
 * 
 * 该函数是系统数据处理的包装函数，负责调用底层数据处理函数。
 * 
 * @param systemParameter 系统参数1
 * @param ConfigurationDataPointer 系统参数2
 * @param AdditionalParameter 系统参数3
 * @param ConfigurationFlag 系统参数4
 * @note 这是系统数据处理层的重要组成部分
 */
void SystemDataProcessorC(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemDataBuffer(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void CleanupSystemMemoryAllocator(void* *ResourceManagerPointer)
/**
 * @brief 系统内存分配器清理函数
 * 
 * 该函数清理系统内存分配器，重置内存分配器状态，确保内存分配器处于干净的状态。
 * 
 * @param ResourceManagerPointer 指向内存分配器指针的指针
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确清理
 */
void CleanupSystemMemoryAllocator(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ProcessSystemStringCopyMedium(long long ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串复制处理器（中等尺寸）
 * 
 * 该函数处理中等尺寸字符串的复制操作，最大长度限制为0x80字节。
 * 它检查源字符串长度，执行字符串复制，并设置相应的长度标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 * 
 * @note 这是系统字符串处理的重要组成部分，专门处理中等尺寸字符串的复制
 */
void ProcessSystemStringCopyMedium(long long targetBuffer,long long sourceString)

{
  long long nextDataIndex;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  nextDataIndex = -1;
  do {
    nextDataIndex = nextDataIndex + 1;
  } while (*(char *)(sourceString + nextDataIndex) != '\0');
  if ((int)nextDataIndex < 0x80) {
    *(int *)(targetBuffer + 0x10) = (int)nextDataIndex;
                    00018004a1b9. Too many branches
                        strcpy_s(*(void* *)(targetBuffer + 8),0x80);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x80,sourceString);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 销毁系统互斥锁
 * 
 * 该函数负责销毁系统中的互斥锁对象，释放相关资源。
 * 这是一个清理函数，在系统关闭时调用，确保互斥锁资源的正确释放。
 * 
 * @note 这是系统清理过程中的重要组成部分，确保资源的正确释放
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}




/**
 * @brief 系统线程对象管理器
 * 
 * 创建和管理系统线程对象，处理线程池的动态扩展和互斥锁同步
 * 
 * @param threadPoolContext 线程池上下文指针
 * @param threadFlags 线程创建标志位
 * @param threadCallback 线程回调函数指针
 * @param threadParameter 线程参数指针
 * @return 返回创建的线程对象指针
 */
void* SystemThreadObjectManager(long long threadPoolContext, uint32_t threadFlags, void* threadCallback, void* threadParameter)

{
  int systemStatus;
  void* creationFlags;
  long long localResourceOffset;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  void* unsignedSystemValue7;
  
  unsignedSystemValue7 = 0xfffffffffffffffe;
  creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,ConfigurationDataPointer,3,ConfigurationFlag,0xfffffffffffffffe);
  systemStatus = _Mtx_lock(ResourceManagerPointer + 0x28);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  resourceEntryPointer = *(void* **)(ResourceManagerPointer + 0x10);
  if (resourceEntryPointer < *(void* **)(ResourceManagerPointer + 0x18)) {
    *(void* **)(ResourceManagerPointer + 0x10) = resourceEntryPointer + 1;
    *resourceEntryPointer = creationFlags;
    goto SystemResourceAllocationComplete;
  }
  pcurrentThreadId = *(void* **)(ResourceManagerPointer + 8);
  localResourceOffset = (long long)resourceEntryPointer - (long long)pcurrentThreadId >> 3;
  if (localResourceOffset == 0) {
    localResourceOffset = 1;
SystemResourceAllocationHandler:
    punsignedSystemValue4 = (void* *)
             CreateSystemThreadObject(SystemMemoryPoolTemplate,localResourceOffset * 8,*(uint8_t *)(ResourceManagerPointer + 0x20),ConfigurationFlag,unsignedSystemValue7);
    resourceEntryPointer = *(void* **)(ResourceManagerPointer + 0x10);
    pcurrentThreadId = *(void* **)(ResourceManagerPointer + 8);
  }
  else {
    localResourceOffset = localResourceOffset * 2;
    if (localResourceOffset != 0) goto SystemResourceAllocationHandler;
    punsignedSystemValue4 = (void* *)0x0;
  }
  if (pcurrentThreadId != resourceEntryPointer) {
      memmove(punsignedSystemValue4,pcurrentThreadId,(long long)resourceEntryPointer - (long long)pcurrentThreadId);
  }
  *punsignedSystemValue4 = creationFlags;
  if (*(long long *)(ResourceManagerPointer + 8) != 0) {
      SystemCleanupFunction();
  }
  *(void* **)(ResourceManagerPointer + 8) = punsignedSystemValue4;
  *(void* **)(ResourceManagerPointer + 0x10) = punsignedSystemValue4 + 1;
  *(void* **)(ResourceManagerPointer + 0x18) = punsignedSystemValue4 + localResourceOffset;
SystemResourceAllocationComplete:
  systemStatus = _Mtx_unlock(ResourceManagerPointer + 0x28);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  return creationFlags;
}




// 函数: void DestroySystemMutex(void* *ResourceManagerPointer)
/**
 * @brief 系统互斥锁销毁函数
 * 
 * 该函数销毁系统互斥锁，清理互斥锁资源，确保互斥锁处于正确的状态。
 * 
 * @param ResourceManagerPointer 指向互斥锁指针的指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确销毁
 */
void DestroySystemMutex(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemDataBufferTemplateC;
  _Mtx_destroy_in_situ();
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemDataBufferTemplateD;
  return;
}



/**
 * @brief 系统内存分配器
 * 
 * 管理系统内存的分配和释放操作
 * 
 * @param memoryContext 内存上下文指针
 * @param currentThreadId 分配大小
 * @return 返回内存指针
 */
void* SystemMemoryAllocator(void* memoryContext, unsigned long long currentThreadId)

{
  DestroySystemMutex();
  if ((currentThreadId & 1) != 0) {
    free(memoryContext,0x78);
  }
  return memoryContext;
}




// 函数: void InitializeSystemMutex(void* *ResourceManagerPointer)
/**
 * @brief 系统互斥锁初始化函数
 * 
 * 该函数初始化系统互斥锁，设置互斥锁的初始状态。
 * 
 * @param ResourceManagerPointer 指向互斥锁指针的指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确初始化
 */
void InitializeSystemMutex(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemDataBufferTemplateE;
  *ResourceManagerPointer = &SystemDataBufferTemplateF;
  return;
}




/**
 * @brief 系统线程创建器
 * 
 * 该函数负责创建系统线程，分配内存并启动线程执行。
 * 函数会分配线程所需的内存，启动线程，并更新系统资源指针中的线程句柄计数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 线程参数
 * @return 返回分配的内存指针
 * 
 * @note 函数分配0x10字节大小的内存，类型为6
 * @note 函数更新资源指针+8位置的句柄计数
 */
void* CreateSystemThread(long long ResourceManagerPointer,void* ConfigurationDataPointer)

{
  void* threadMemory;
  long long threadHandle;
  
  threadMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,ConfigurationDataPointer,0x10,6);
  threadHandle = StartSystemThread(threadMemory);
  *(long long *)(ResourceManagerPointer + 8) = *(long long *)(ResourceManagerPointer + 8) + threadHandle;
  return threadMemory;
}




// 函数: void StartAndManageSystemThread(long long ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统线程启动和管理函数
 * 
 * 该函数启动系统线程，管理线程生命周期，并处理线程相关的清理操作。
 * 
 * @param ResourceManagerPointer 线程管理器指针
 * @param ConfigurationDataPointer 线程参数
 * 
 * @note 这是系统线程管理的重要组成部分，确保线程的正确启动和清理
 */
void StartAndManageSystemThread(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  
  nextDataIndex = StartSystemThread(ConfigurationDataPointer);
  *(long long *)(ResourceManagerPointer + 8) = *(long long *)(ResourceManagerPointer + 8) - nextDataIndex;
  if (ConfigurationDataPointer != 0) {
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}



void* *
InitializeDataBufferTemplates(void* *dataBufferRef,ulong long InitializationFlags,void* reservedParam3,void* reservedParam4)

{
  *dataBufferRef = &SystemDataBufferInputTemplateE;
  *dataBufferRef = &SystemDataBufferOutputTemplateF;
  if ((InitializationFlags & 1) != 0) {
    free(dataBufferRef,0x10,reservedParam3,reservedParam4,0xfffffffffffffffe);
  }
  return dataBufferRef;
}




bool SystemNodeCheckStatus(void)

{
  char SystemNodeFlag;
  uint32_t *HashEntryStatus;
  void* *HashNodePointer;
  int systemIndex;
  bool systemNodeStatus;
  void* EncryptionValue48;
  long long longValue40;
  void* *pointerUnsigned30;
  void* *pEncryptionKeyValue;
  uint unsignedValue20;
  
  InitializeSystemStringBuffer(&pointerUnsigned30);
  systemIndex = unsignedValue20 + 0x11;
  ProcessSystemStringData(&pointerUnsigned30,systemIndex);
  HashEntryStatus = (uint32_t *)(pEncryptionKeyValue + unsignedValue20);
  *HashEntryStatus = 0x69676e65;
  HashEntryStatus[1] = 0x635f656e;
  HashEntryStatus[2] = 0x69666e6f;
  HashEntryStatus[3] = 0x78742e67;
  *(void*2 *)(HashEntryStatus + 4) = 0x74;
  EncryptionValue48 = 0;
  longValue40 = 0;
  HashNodePointer = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    HashNodePointer = pEncryptionKeyValue;
  }
  unsignedValue20 = systemIndex;
  ValidateSystemStringFormat(&EncryptionValue48,HashNodePointer,&SystemStringConstant);
  if (longValue40 == 0) {
    systemNodeStatus = false;
  }
  else {
    initializationStatusFlag = CheckSystemNodeAvailability(SystemNodeManagerPointer,&EncryptionValue48);
    if (longValue40 != 0) {
      fclose();
      longValue40 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
    systemNodeStatus = initializationStatusFlag != '\0';
  }
  if (longValue40 != 0) {
    fclose();
    longValue40 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (pEncryptionKeyValue != (void* *)0x0) {
      SystemCleanupFunction();
  }
  return systemNodeStatus;
}





/**
 * @brief 系统初始化函数 - 线程池管理器
 * 
 * 该函数负责初始化系统线程池管理器，设置线程池和工作队列
 * 用于管理游戏运行时的多线程任务执行
 */
void InitializeSystemThreadPoolManager(void)

{
  char SystemNodeFlag;
  uint32_t *HashEntryStatus;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  int systemValue;
  uint8_t StackBuffer [32];
  uint32_t EncryptionValue68;
  uint8_t StackBuffer60 [8];
  void* *memoryAllocationBuffer;
  uint unsignedValue50;
  void* unsignedValue40;
  void* *pointerUnsigned38;
  uint8_t *pointerUnsigned30;
  uint32_t EncryptionKeyValue;
  uint8_t aunsignedValue20 [16];
  ulong long unsignedValue10;
  
  unsignedValue40 = 0xfffffffffffffffe;
  unsignedValue10 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer;
  EncryptionValue68 = 0;
  initializationStatusFlag = CheckSystemInitializationStatus();
  if (initializationStatusFlag == '\0') {
    SetSystemInitializationFlag(1);
    CheckSystemInitializationStatus();
  }
  pointerUnsigned38 = &SystemResourceTemplateSecondary;
  pointerUnsigned30 = aunsignedValue20;
  aunsignedValue20[0] = 0;
  EncryptionKeyValue = 6;
  strcpy_s(aunsignedValue20,0x10,&SystemStringConstantWindowTitleJ);
  EncryptionValue68 = 1;
  ProcessSystemWindowTitle(StackBuffer60,&pointerUnsigned38);
  EncryptionValue68 = 0;
  pointerUnsigned38 = &SystemMemoryAllocatorReference;
  systemValue = unsignedValue50 + 0xf;
  ProcessSystemStringData(StackBuffer60,systemValue);
  HashEntryStatus = (uint32_t *)(memoryAllocationBuffer + unsignedValue50);
  *HashEntryStatus = 0x72657375;
  HashEntryStatus[1] = 0x6e6f635f;
  HashEntryStatus[2] = 0x2e676966;
  HashEntryStatus[3] = 0x747874;
  unsignedValue50 = systemValue;
  HashNodePointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x18,8,3);
  punsignedSystemValue4 = &SystemStringTemplate;
  if (memoryAllocationBuffer != (void* *)0x0) {
    punsignedSystemValue4 = memoryAllocationBuffer;
  }
  *HashNodePointer = 0;
  *(uint8_t *)(HashNodePointer + 2) = 0;
  ProcessSystemResourceData(HashNodePointer,punsignedSystemValue4,&SystemResourceTemplateTertiary);
  if (HashNodePointer[1] == 0) {
      SystemCleanupFunction(HashNodePointer);
  }
  ReleaseSystemMemory(SystemMemoryManagerPointer,HashNodePointer);
  ClearSystemMemory(HashNodePointer);
  if (HashNodePointer[1] != 0) {
    fclose();
    HashNodePointer[1] = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
    SystemCleanupFunction(HashNodePointer);
}





/**
 * @brief 初始化系统配置数据结构
 * 
 * 该函数初始化系统的配置数据结构，包括设置系统参数和清零配置缓冲区。
 * 它会分配内存、设置系统参数，并清空配置数据区域。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保系统配置的正确初始化
 */
void InitializeSystemConfigurationData(void)

{
  void* systemConfigPointer;
  
  systemConfigPointer = AllocateSystemMemory(SystemMemoryPoolTemplate,0xd20,8,3);
  SystemConfigParameterA = InitializeSystemParameterA(systemConfigPointer);
  systemConfigPointer = AllocateSystemMemory(SystemMemoryPoolTemplate,0x138,8,3);
  SystemConfigParameterB = InitializeSystemParameterB(systemConfigPointer);
  systemConfigPointer = AllocateSystemMemory(SystemMemoryPoolTemplate,0x50,8,3);
    memset(systemConfigPointer,0,0x50);
}





/**
 * @brief 初始化系统数据清理器
 * 
 * 该函数负责初始化系统的数据清理器，处理字符串数据、创建互斥锁，
 * 并进行系统状态检查和清理操作。
 * 
 * @note 这是系统清理和初始化过程的重要组成部分
 */
void InitializeSystemDataCleaner(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  char *pathStringPointer;
  void* unsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  void* *HashBucketNode;
  int systemCode;
  uint unsignedSystemValue9;
  ulong long systemOperationFlags;
  void* *pEncryptionKeyValue;
  uint unsignedValue20;
  
  InitializeSystemComponents();
  systemCode = 0;
  systemOperationFlags = 0;
  if (unsignedValue20 != 0) {
    localSystemPointer = 0;
    localSystemFlags = 0;
    do {
      initializationStatusFlag = pEncryptionKeyValue[localSystemFlags];
      if (((byte)(initializationStatusFlag + 0x9fU) < 0x1a) ||
         (((byte)(initializationStatusFlag - 0x30U) < 0x30 &&
          ((0x87fffffe03ffU >> ((long long)(char)(initializationStatusFlag - 0x30U) & 0x3fU) & 1) != 0)))) {
        if (localSystemPointer != localSystemFlags) {
          pEncryptionKeyValue[localSystemPointer] = initializationStatusFlag;
        }
        systemCode = systemCode + 1;
        localSystemPointer = localSystemPointer + 1;
      }
      unsignedSystemValue9 = (int)systemOperationFlags + 1;
      systemOperationFlags = (ulong long)unsignedSystemValue9;
      localSystemFlags = localSystemFlags + 1;
    } while (unsignedSystemValue9 < unsignedValue20);
  }
  pEncryptionKeyValue[systemCode] = 0;
  HashEntryStatus = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,CONCAT71((int7)(systemOperationFlags >> 8),3));
  HashBucketNode = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    HashBucketNode = pEncryptionKeyValue;
  }
  ProcessSystemQueue(HashEntryStatus + 1,HashBucketNode);
  pathStringPointer = (char *)HashEntryStatus[2];
  if (*pathStringPointer != '\0') {
    localSystemPointer = 0;
    do {
      localSystemFlags = strchr(&SystemStringConstantF,(int)pathStringPointer[localSystemPointer]);
      if (localSystemFlags != 0) {
        *(uint8_t *)(localSystemPointer + HashEntryStatus[2]) = 0x2f;
      }
      localSystemPointer = localSystemPointer + 1;
      pathStringPointer = (char *)HashEntryStatus[2];
    } while (pathStringPointer[localSystemPointer] != '\0');
  }
  *HashEntryStatus = 0;
  SystemSecondaryStateStorage = HashEntryStatus;
  if (SystemDebugFlag != '\0') {
    GetLastError();
    HashBucketNode = &SystemStringTemplate;
    if ((void* *)HashEntryStatus[2] != (void* *)0x0) {
      HashBucketNode = (void* *)HashEntryStatus[2];
    }
    unsignedSystemValue4 = CreateMutexA(0,0,HashBucketNode);
    *HashEntryStatus = unsignedSystemValue4;
    systemCode = GetLastError();

/**
 * @brief 执行系统最终清理操作
 * 
 * 该函数负责执行系统的最终清理操作，释放系统资源，
 * 清理内存分配，并确保系统安全关闭。
 * 
 * @note 这是系统关闭过程中的重要步骤
 */
void ExecuteSystemFinalCleanup(void)

{
  long long *PrimaryResourcePointer;
  long long localSystemHandle;
  long long localResourceOffset;
  void* SystemRegisterValue;
  void* unsignedSystemValue4;
  
  unsignedSystemValue4 = 0xfffffffffffffffe;
  if ((SystemDeviceManagerPointer != (long long *)0x0) && ((char)SystemDeviceManagerPointer[0x42] == '\0')) {
    (**(code **)(*SystemDeviceManagerPointer + 0x38))();
  }
  localSystemHandle = SystemGraphicsContextPointer;
  (**(code **)(**(long long **)(SystemGraphicsContextPointer + 0x20) + 0x108))
            (*(long long **)(SystemGraphicsContextPointer + 0x20),SystemGraphicsContextPointer + 0xc0);
  PrimaryResourcePointer = *(long long **)(localSystemHandle + 0x30);
  if (PrimaryResourcePointer != (long long *)0x0) {
    localResourceOffset = __RTCastToVoid(PrimaryResourcePointer);
    (**(code **)(*PrimaryResourcePointer + 0x10))(PrimaryResourcePointer,0,*(code **)(*PrimaryResourcePointer + 0x10),SystemRegisterValue,unsignedSystemValue4);
    if (localResourceOffset != 0) {
        SystemCleanupFunction(localResourceOffset);
    }
  }
  *(void* *)(localSystemHandle + 0x30) = 0;
  if (*(void* **)(localSystemHandle + 0x28) != (void* *)0x0) {
    (**(code **)**(void* **)(localSystemHandle + 0x28))();
    *(void* *)(localSystemHandle + 0x28) = 0;
  }
  localSystemHandle = SystemGraphicsContextPointer;
  if (SystemGraphicsContextPointer != 0) {
    StartSystemInitialization();
    *(void* **)(localSystemHandle + 0xc0) = &SystemDataBufferTemplateH;
    DestroySystemMutex(localSystemHandle + 0x48);
    *(void* *)(localSystemHandle + 0x10) = &SystemDataBufferTemplateE;
    *(void* *)(localSystemHandle + 0x10) = &SystemDataBufferTemplateF;
    *(void* **)(localSystemHandle + 8) = &SystemDataBufferTemplateG;
      SystemCleanupFunction(localSystemHandle);
  }
  SystemGraphicsContextPointer = 0;
  timeEndPeriod(1);
  localSystemHandle = SystemInputManagerPointer;
  if (SystemInputManagerPointer != 0) {
    InitializeInputManager(SystemInputManagerPointer);
      SystemCleanupFunction(localSystemHandle);
  }
  SystemInputManagerPointer = 0;
  return;
}



void* *
InitializeSystemPathBuffers(void* *pathBufferRef,void* reservedParam2,void* reservedParam3,void* reservedParam4)

{
  uint32_t *pointerToUnsigned1;
  void** SystemDataTable;
  int MemoryComparisonResult;
  int systemIndex;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemGlobalDataReference;
  ResourceManagerPointer[3] = 0;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  ExecuteSystemCommand(ResourceManagerPointer,0,AdditionalParameter,ConfigurationFlag,0,0xfffffffffffffffe);
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  if ((uint8_t *)ResourceManagerPointer[1] != (uint8_t *)0x0) {
    *(uint8_t *)ResourceManagerPointer[1] = 0;
  }
  systemIndex = *(int *)(ResourceManagerPointer + 2);
  systemCounter = systemIndex + 6;
  ExecuteSystemCommand(ResourceManagerPointer,systemCounter,AdditionalParameter,ConfigurationFlag,1,currentThreadId);
  pointerToUnsigned1 = (uint32_t *)((ulong long)*(uint *)(ResourceManagerPointer + 2) + ResourceManagerPointer[1]);
  *pointerToUnsigned1 = 0x2e2f2e2e;
  *(void*2 *)(pointerToUnsigned1 + 1) = 0x2f2e;
  *(uint8_t *)((long long)pointerToUnsigned1 + 6) = 0;
  *(int *)(ResourceManagerPointer + 2) = systemCounter;
  systemIndex = systemIndex + 0x2a;
  ExecuteSystemCommand(ResourceManagerPointer,systemIndex);
  HashEntryStatus = (void* *)((ulong long)*(uint *)(ResourceManagerPointer + 2) + ResourceManagerPointer[1]);
  *HashEntryStatus = 0x736c6f6f542f2e2e;
  HashEntryStatus[1] = 0x747541747365542f;
  HashEntryStatus[2] = 0x2f6e6f6974616d6f;
  HashEntryStatus[3] = 0x656d686361747441;
  *(uint32_t *)(HashEntryStatus + 4) = 0x2f73746e;
  *(uint8_t *)((long long)HashEntryStatus + 0x24) = 0;
  *(int *)(ResourceManagerPointer + 2) = systemIndex;
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源初始化与验证函数
 * 
 * 该函数负责初始化和验证系统资源，包括节点管理器的检查、
 * 系统配置数据的设置以及资源的分配和清理。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于资源管理
 * @return 返回初始化状态，0表示失败，非0表示成功
 * @note 这是系统初始化过程中的核心函数
 */
void* InitializeSystemResourceValidation(char ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  uint32_t *HashNodePointer;
  void* *punsignedSystemValue4;
  int systemValue;
  void* hashValue;
  void* EncryptionValue48;
  long long longValue40;
  void* *pointerUnsigned30;
  void* *pEncryptionKeyValue;
  uint unsignedValue20;
  
  if (ResourceManagerPointer == '\0') {
    if ((void* *)*SystemNodeManagerPointer == &SystemResourceTemplateQuaternary) {
      if ((SystemNodeManagerPointer[0x16] == 0) && (*(char *)(SystemStatusFlagsPointer + 0x1f0) != '\0')) {
        validationStatusFlag = '\x01';
      }
      else {
        validationStatusFlag = '\0';
      }
    }
    else {
      validationStatusFlag = (**(code **)((void* *)*SystemNodeManagerPointer + 0x28))();
    }
    if (validationStatusFlag == '\0') {
      return 0;
    }
  }
  SetupSystemConfiguration(&pointerUnsigned30);
  systemValue = unsignedValue20 + 0x11;
  ExecuteSystemCommand(&pointerUnsigned30,systemValue);
  HashNodePointer = (uint32_t *)(pEncryptionKeyValue + unsignedValue20);
  *HashNodePointer = 0x69676e65;
  HashNodePointer[1] = 0x635f656e;
  HashNodePointer[2] = 0x69666e6f;
  HashNodePointer[3] = 0x78742e67;
  *(void*2 *)(HashNodePointer + 4) = 0x74;
  EncryptionValue48 = 0;
  longValue40 = 0;
  punsignedSystemValue4 = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    punsignedSystemValue4 = pEncryptionKeyValue;
  }
  unsignedValue20 = systemValue;
  ProcessSystemResourceData(&EncryptionValue48,punsignedSystemValue4,&SystemConfigurationDataTemplate);
  PrimaryResourcePointer = SystemNodeManagerPointer;
  if (longValue40 == 0) {
    hashValue = 3;
  }
  else {
    validationStatusFlag = (**(code **)(*SystemNodeManagerPointer + 0x28))(SystemNodeManagerPointer);
    if (validationStatusFlag != '\0') {
      InitializePrimaryResource(PrimaryResourcePointer,&EncryptionValue48);
    }
    hashValue = 0;
    if (longValue40 != 0) {
      fclose();
      longValue40 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
      hashValue = 0;
    }
  }
  if (longValue40 != 0) {
    fclose();
    longValue40 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (pEncryptionKeyValue == (void* *)0x0) {
    return hashValue;
  }
    SystemCleanupFunction();
}




bool SystemThreadCheckStatus(void)

{
  int systemStatus;
  
  systemStatus = _Thrd_id();
  if (SystemVersionCheckStorage == 0) {
    return systemStatus == *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
  }
  if ((systemStatus != *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48)) && (systemStatus != SystemVersionCheckStorage))
  {
    return false;
  }
  return true;
}





// 函数: void ConfigureAndInitializeSystemMemoryAllocator(void* *ResourceManagerPointer)
/**
 * @brief 系统内存分配器配置和初始化函数
 * 
 * 该函数配置和初始化系统内存分配器，设置内存分配器参数，
 * 执行内存分配操作，并确保内存分配器处于正确的状态。
 * 
 * @param ResourceManagerPointer 指向内存分配器指针的指针
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确配置和初始化
 */
void ConfigureAndInitializeSystemMemoryAllocator(void* *ResourceManagerPointer)

{
  uint systemStatus;
  int systemResult;
  long long localResourceOffset;
  uint unsignedSystemValue4;
  void* *pcurrentThreadId;
  uint8_t StackBuffer [32];
  uint32_t EncryptionValue68;
  void* unsignedValue60;
  void* *memoryAllocationBuffer;
  void* *memoryAllocationEnd;
  void* *pEncryptionValue48;
  uint32_t unsignedValue40;
  void* arrayUnsigned38 [32];
  ulong long unsignedValue18;
  
  unsignedValue60 = 0xfffffffffffffffe;
  unsignedValue18 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemMemoryTemplateE;
  ResourceManagerPointer[1] = ResourceManagerPointer + 3;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *(uint8_t *)(ResourceManagerPointer + 3) = 0;
  systemStatus = *(uint *)(ResourceManagerPointer + 2);
  unsignedSystemValue4 = systemStatus + 7;
  if (unsignedSystemValue4 < 0x1f) {
    *(void* *)((ulong long)systemStatus + ResourceManagerPointer[1]) = 0x32312e322e3176;
    *(uint *)(ResourceManagerPointer + 2) = unsignedSystemValue4;
    systemStatus = unsignedSystemValue4;
  }
  if (systemStatus + 1 < 0x1f) {
    *(void*2 *)((ulong long)systemStatus + ResourceManagerPointer[1]) = 0x2e;
    *(uint *)(ResourceManagerPointer + 2) = systemStatus + 1;
  }
  memoryAllocationEnd = &SystemMemoryTemplateE;
  pEncryptionValue48 = arrayUnsigned38;
  unsignedValue40 = 0;
  arrayUnsigned38[0] = 0;
  EncryptionValue68 = 3;
  memoryAllocationBuffer = ResourceManagerPointer;
  InitializeGameSettings(&memoryAllocationEnd,&SystemDataBufferTemplateI,0x130a7);
  pcurrentThreadId = &SystemStringTemplate;
  if (pEncryptionValue48 != (void* *)0x0) {
    pcurrentThreadId = pEncryptionValue48;
  }
  localResourceOffset = -1;
  do {
    localResourceOffset = localResourceOffset + 1;
  } while (pcurrentThreadId[localResourceOffset] != '\0');
  systemResult = (int)localResourceOffset;
  if ((0 < systemResult) && (*(uint *)(ResourceManagerPointer + 2) + systemResult < 0x1f)) {
      memcpy((ulong long)*(uint *)(ResourceManagerPointer + 2) + ResourceManagerPointer[1],pcurrentThreadId,(long long)(systemResult + 1));
  }
  EncryptionValue68 = 1;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(unsignedValue18 ^ (ulong long)StackBuffer);
}




long long * InitializeGameController(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = (long long)&SystemGlobalDataReference;
  ResourceManagerPointer[3] = 0;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  if (*(char *)(SystemDataManagerPointer + 0x22) != '\0') {
    ProcessDataManager(ResourceManagerPointer,SystemDataManagerPointer + 0x28);
    return ResourceManagerPointer;
  }
  (**(code **)(*ResourceManagerPointer + 0x10))(ResourceManagerPointer,&SystemResourceTemplateQuinary,AdditionalParameter,ConfigurationFlag,1,0xfffffffffffffffe);
  return ResourceManagerPointer;
}





/**
 * @brief 设置系统线程标识符
 * 
 * 该函数负责设置系统的线程标识符，检查当前线程ID是否与主线程匹配，
 * 如果不匹配则更新系统线程标识符。
 * 
 * @param threadIdPointer 指向线程标识符的指针
 * @note 这是系统线程管理的重要组成部分
 */
void SetSystemThreadId(uint32_t *threadIdPointer)

{
  int mainThreadId;
  int currentThreadId;
  
  mainThreadId = *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
  currentThreadId = _Thrd_id();
  if (currentThreadId != mainThreadId) {
    SystemCurrentThreadId = *threadIdPointer;
  }
  return;
}



/**
 * @brief 使用模板初始化系统资源
 * 
 * 该函数使用指定的模板参数来初始化系统资源，包括内存分配器引用、
 * 内存模板和字符串处理器的设置。函数会配置系统资源指针的各种属性，
 * 并根据模板参数进行相应的初始化。
 * 
 * @param systemResourcePointer 系统资源指针的指针
 * @param templateParameter 模板参数，包含配置信息
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回初始化后的系统资源指针
 */
void* *
InitializeSystemResourceWithTemplate(void* *systemResourcePointer, long long templateParameter, void* reservedParam3, void* reservedParam4)

{
  void* *resultPointer;
  
  *systemResourcePointer = &SystemMemoryAllocatorReference;
  systemResourcePointer[1] = 0;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  *systemResourcePointer = &SystemMemoryTemplateE;
  systemResourcePointer[1] = systemResourcePointer + 3;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  *(uint8_t *)(systemResourcePointer + 3) = 0;
  *(uint32_t *)(systemResourcePointer + 2) = *(uint32_t *)(templateParameter + 0x10);
  resultPointer = &SystemStringTemplate;
  if (*(void* **)(templateParameter + 8) != (void* *)0x0) {
    resultPointer = *(void* **)(templateParameter + 8);
  }
  strcpy_s(systemResourcePointer[1], 0x20, resultPointer, reservedParam4, 0xfffffffffffffffe);
  return systemResourcePointer;
}




/**
 * @brief 设置系统字符串处理器入口点
 * 
 * 该函数设置系统字符串处理器的入口点指针，
 * 用于初始化字符串处理子系统。
 * 
 * @param stringProcessorPointer 字符串处理器指针的指针
 */
void SetSystemStringProcessorEntryPoint(void **stringProcessorPointer)

{
  *stringProcessorPointer = &SystemDataBufferTemplateG;
  return;
}




/**
 * @brief 设置系统内存管理器入口点
 * 
 * 该函数设置系统内存管理器的入口点指针，
 * 用于初始化内存管理子系统。
 * 
 * @param memoryManagerPointer 内存管理器指针的指针
 */
void SetSystemMemoryManagerEntryPoint(void **memoryManagerPointer)

{
  *memoryManagerPointer = &SystemDataBufferTemplateH;
  return;
}




// 函数: void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* InitializationFlags)
/**
 * @brief 初始化系统入口点
 * 
 * 该函数负责初始化系统的主要入口点，设置系统上下文和入口点数据。
 * 它会检查系统上下文中的入口点指针，如果存在则调用相应的初始化函数。
 * 
 * @param systemContext 系统上下文指针，包含系统状态和配置信息
 * @param entryPointData 入口点数据指针，包含入口点相关的配置
 * @param memoryPool 内存池指针，用于系统内存分配
 * @param InitializationFlags 初始化标志，控制初始化过程的行为
 */
void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* InitializationFlags)

{
  void* *entryPointPtr;
  
  entryPointPtr = *(void* **)(systemContext + 0x10);
  if (entryPointPtr != (void* *)0x0) {
    InitializeSystemContext(systemContext,*entryPointPtr,memoryPool,InitializationFlags,0xfffffffffffffffe);
      SystemCleanupFunction(entryPointPtr);
  }
  return;
}




/**
 * @brief 系统资源清理器A
 * 
 * 该函数负责清理系统资源，通过检查系统上下文中的资源指针，
 * 并调用相应的清理函数来释放资源。
 * 
 * @param systemContext 系统上下文指针
 * @param resourceParameter 资源参数
 * @param cleanupFlag 清理标志
 * @param cleanupContext 清理上下文
 */
void SystemResourceCleanerA(long long systemContext,void* resourceParameter,void* cleanupFlag,void* cleanupContext)

{
  void* *resourcePointer;
  
  resourcePointer = *(void* **)(systemContext + 0x10);
  if (resourcePointer != (void* *)0x0) {
    SystemResourceCleanupHandler(systemContext,*resourcePointer,cleanupFlag,cleanupContext,0xfffffffffffffffe);
      SystemCleanupFunction(resourcePointer);
  }
  return;
}




/**
 * @brief 系统资源清理器B
 * 
 * 该函数负责清理系统资源，与SystemResourceCleanerA功能相似，
 * 用于不同场景下的资源清理工作。
 * 
 * @param systemContext 系统上下文指针
 * @param resourceParameter 资源参数
 * @param cleanupFlag 清理标志
 * @param cleanupContext 清理上下文
 */
void SystemResourceCleanerB(long long systemContext,void* resourceParameter,void* cleanupFlag,void* cleanupContext)

{
  void* *resourcePointer;
  
  resourcePointer = *(void* **)(systemContext + 0x10);
  if (resourcePointer != (void* *)0x0) {
    SystemResourceCleanupHandler(systemContext,*resourcePointer,cleanupFlag,cleanupContext,0xfffffffffffffffe);
      SystemCleanupFunction(resourcePointer);
  }
  return;
}




/**
 * @brief 系统资源清理处理器
 * 
 * 该函数是系统资源清理的核心处理器，递归地清理系统资源。
 * 它会检查资源指针是否有效，然后递归调用自身进行深度清理。
 * 
 * @param systemContext 系统上下文指针
 * @param resourcePointer 资源指针
 */
void SystemResourceCleanupHandler(void* systemContext,void* *resourcePointer)

{
  if (resourcePointer != (void* *)0x0) {
    SystemResourceCleanupHandler(systemContext,*resourcePointer);
      SystemCleanupFunction(resourcePointer);
  }
  return;
}




/**
 * @brief 系统资源清理执行器
 * 
 * 该函数是系统资源清理的执行器，通过调用资源清理处理器
 * 来执行实际的资源清理工作。
 * 
 * @param systemContext 系统上下文指针
 */
void SystemResourceCleanupExecutor(void* systemContext)

{
  void* *resourcePointer;
  
  SystemResourceCleanupHandler(systemContext,*resourcePointer);
    SystemCleanupFunction();
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，用于系统中的占位或同步操作。
 * 
 * @note 这是一个空操作函数，通常用于系统同步或占位
 */
void SystemNullOperation(void)

{
  return;
}



/**
 * @brief 初始化系统引用指针
 * 
 * 该函数负责初始化系统的引用指针，设置引用关系，
 * 并根据标志决定是否释放内存。
 * 
 * @param referencePointer 指向引用指针的指针
 * @param memoryFlags 内存操作标志，控制是否释放内存
 * @return 返回初始化后的引用指针
 * @note 这是系统引用管理的重要组成部分
 */
void* * InitializeSystemReferencePointer(void* *referencePointer,ulong long memoryFlags)

{
  *referencePointer = &SystemReferenceTemplate;
  if ((memoryFlags & 1) != 0) {
    free(referencePointer,8);
  }
  return referencePointer;
}



/**
 * @brief 系统数据缓冲区模板获取函数
 * 
 * 该函数用于获取系统数据缓冲区模板G的引用，并根据标志位决定是否释放内存。
 * 这是内存管理系统中的一个辅助函数，用于数据缓冲区的初始化和管理。
 * 
 * @param ResourceManagerPointer 输出参数，用于返回数据缓冲区模板的引用
 * @param ConfigurationDataPointer 控制标志位，如果第0位为1则释放内存
 * @return 返回系统数据缓冲区模板的引用
 */
void* * GetSystemDataBufferTemplateG(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemDataBufferTemplateG;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,8);
  }
  return ResourceManagerPointer;
}





/**
 * @brief 初始化游戏设置
 * 
 * 该函数负责初始化游戏的各种设置参数，包括：
 * - 配置资源管理器参数
 * - 处理配置数据指针
 * - 设置附加参数和配置标志
 * - 生成加密密钥用于数据保护
 * 
 * @param ResourceManagerPointer 资源管理器指针，指向系统资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含游戏配置信息
 * @param AdditionalParameter 附加参数，用于额外的初始化配置
 * @param ConfigurationFlag 配置标志，控制初始化过程的行为
 * 
 * @return 无返回值
 * 
 * @note 该函数是游戏初始化过程中的重要环节，确保游戏设置正确配置
 */
void InitializeGameSettings(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  int systemResult;
  ulong long *HashNodePointer;
  long long bufferBaseAddress;
  uint64_t SystemInitializationFlag;
  void* StackParameter1;
  uint8_t EncryptionBuffer [32];
  void* processFlags58;
  void* *memoryAllocationEnd;
  char ConfigurationBuffer [32];
  ulong long EncryptionKeyValue;
  void* StackParameter2;
  
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer;
  StackParameter2 = AdditionalParameter;
  StackParameter1 = ConfigurationFlag;
  HashNodePointer = (ulong long *)SystemGlobalDataAllocate();
  processFlags58 = 0;
  memoryAllocationEnd = &StackParameter2;
  __stdio_common_vsprintf(*HashNodePointer | 1,ConfigurationBuffer,0x20,ConfigurationDataPointer);
  nextDataIndex = -1;
  do {
    bufferBaseAddress = nextDataIndex;
    nextDataIndex = bufferBaseAddress + 1;
  } while (ConfigurationBuffer[bufferBaseAddress + 1] != '\0');
  systemResult = (int)(bufferBaseAddress + 1);
  if ((0 < systemResult) && (*(uint *)(ResourceManagerPointer + 0x10) + systemResult < 0x1f)) {
      memcpy((ulong long)*(uint *)(ResourceManagerPointer + 0x10) + *(long long *)(ResourceManagerPointer + 8),ConfigurationBuffer,
           (long long)((int)bufferBaseAddress + 2));
  }
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)EncryptionBuffer);
}



/**
 * @brief 系统数据缓冲区模板获取函数F
 * 
 * 该函数用于获取系统数据缓冲区模板F的引用，并根据标志位决定是否释放内存。
 * 这是内存管理系统中的一个辅助函数，用于数据缓冲区的初始化和管理。
 * 
 * @param ResourceManagerPointer 输出参数，用于返回数据缓冲区模板的引用
 * @param ConfigurationDataPointer 控制标志位，如果第0位为1则释放内存
 * @return 返回系统数据缓冲区模板的引用
 */
void* * GetSystemDataBufferTemplateF(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemDataBufferTemplateF;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,8);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 系统数据缓冲区模板获取函数D
 * 
 * 该函数用于获取系统数据缓冲区模板D的引用，并根据标志位决定是否释放内存。
 * 这是内存管理系统中的一个辅助函数，用于数据缓冲区的初始化和管理。
 * 
 * @param ResourceManagerPointer 输出参数，用于返回数据缓冲区模板的引用
 * @param ConfigurationDataPointer 控制标志位，如果第0位为1则释放内存
 * @return 返回系统数据缓冲区模板的引用
 */
void* * GetSystemDataBufferTemplateD(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemDataBufferTemplateD;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,8);
  }
  return ResourceManagerPointer;
}



int SystemStringFormatProcess(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  ulong long *HashEntryStatus;
  
  HashEntryStatus = (ulong long *)SystemGlobalDataAllocate();
  systemStatus = __stdio_common_vsprintf(*HashEntryStatus | 1,ResourceManagerPointer,ConfigurationDataPointer,AdditionalParameter,0,ConfigurationFlag);
  if (systemStatus < 0) {
    systemStatus = -1;
  }
  return systemStatus;
}




/**
 * @brief 系统初始化器A
 * 
 * 该函数负责系统的初始化工作，调用核心初始化函数
 * 来完成系统组件的初始化。
 * 
 * @param systemContext 系统上下文指针
 * @param initParameter 初始化参数
 * @param initFlag 初始化标志
 * @param initContext 初始化上下文
 */
void SystemInitializerA(long long systemContext,void* initParameter,void* initFlag,void* initContext)

{
  SystemCoreInitializer(systemContext,*(void* *)(systemContext + 0x10),initFlag,initContext,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统初始化器B
 * 
 * 该函数负责系统的初始化工作，与SystemInitializerA功能相似，
 * 用于不同场景下的系统初始化。
 * 
 * @param systemContext 系统上下文指针
 * @param initParameter 初始化参数
 * @param initFlag 初始化标志
 * @param initContext 初始化上下文
 */
void SystemInitializerB(long long systemContext,void* initParameter,void* initFlag,void* initContext)

{
  SystemCoreInitializer(systemContext,*(void* *)(systemContext + 0x10),initFlag,initContext,0xfffffffffffffffe);
  return;
}





/**
 * @brief 系统数据指针设置器
 * 
 * 该函数负责设置系统数据指针，并解锁系统互斥锁。
 * 
 * @param dataPointer 数据指针参数
 */
void SystemDataPointerSetter(void* *dataPointer)

{
  int mutexUnlockResult;
  
  SystemDataHeaderStorage = *dataPointer;
  mutexUnlockResult = _Mtx_unlock(0x180c91970);
  if (mutexUnlockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexUnlockResult);
  }
  return;
}




/**
 * @brief 系统配置初始化器A
 * 
 * 该函数负责系统配置的初始化工作，调用核心配置初始化函数
 * 来完成系统配置的设置。
 * 
 * @param systemContext 系统上下文指针
 * @param configParameter 配置参数
 * @param configFlag 配置标志
 * @param configContext 配置上下文
 */
void SystemConfigInitializerA(long long systemContext,void* configParameter,void* configFlag,void* configContext)

{
  SystemCoreConfigInitializer(systemContext,*(void* *)(systemContext + 0x10),configFlag,configContext,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统配置初始化器B
 * 
 * 该函数负责系统配置的初始化工作，与SystemConfigInitializerA功能相似，
 * 用于不同场景下的系统配置初始化。
 * 
 * @param systemContext 系统上下文指针
 * @param configParameter 配置参数
 * @param configFlag 配置标志
 * @param configContext 配置上下文
 */
void SystemConfigInitializerB(long long systemContext,void* configParameter,void* configFlag,void* configContext)

{
  SystemCoreConfigInitializer(systemContext,*(void* *)(systemContext + 0x10),configFlag,configContext,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统内存释放器
 * 
 * 该函数负责释放系统内存，调用核心内存释放函数
 * 来完成内存的释放工作。
 * 
 * @param memoryOffset 内存偏移量参数
 */
void SystemMemoryReleaser(long long memoryOffset)

{
  ReleaseSystemMemory(memoryOffset + 0x60);
  return;
}




// 函数: void CleanupSystemResources(long long ResourceManagerPointer)
/**
 * @brief 系统内存偏移处理器
 * 
 * 该函数处理系统内存中的偏移量，通过调用底层内存管理函数来处理
 * 指定偏移位置的操作。
 * 
 * @param memoryOffset 内存偏移量参数
 * @note 这是系统内存管理的重要组成部分，用于处理特定内存位置的操作
 */
void SystemMemoryOffsetHandler(long long memoryOffset)

{
  SystemResourceCleaner(memoryOffset + 0x60);
  return;
}





// 函数: void InitializeResourceHandler(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存区域清理器
 * 
 * 该函数负责清理系统内存区域，包括重置内存指针、清理数据结构、
 * 释放内存资源等操作。它会遍历内存区域中的所有指针，进行安全清理。
 * 
 * @param systemContext 系统上下文指针
 * @param memoryRegion 内存区域指针
 * @param cleanupFlag 清理标志
 * @param cleanupParameter 清理参数
 * @note 这是系统内存管理的关键函数，确保内存资源的正确释放和重置
 */
void SystemMemoryRegionCleaner(void* systemContext,void* memoryRegion,void* cleanupFlag,void* cleanupParameter)

{
  void* *memoryPointer;
  long long systemDataReference;
  int memoryBlockCount;
  long long blockIndex;
  
  systemDataReference = SystemMemoryPoolPointer;
  memoryBlockCount = (int)(*(long long *)(SystemMemoryPoolPointer + 0x38) - *(long long *)(SystemMemoryPoolPointer + 0x30) >> 3);
  blockIndex = 0;
  if (0 < memoryBlockCount) {
    do {
      memoryPointer = *(void* **)(*(long long *)(systemDataReference + 0x30) + blockIndex * 8);
      if (memoryPointer != (void* *)0x0) {
        memoryPointer[4] = &SystemGlobalDataReference;
        if (memoryPointer[5] != 0) {
            SystemCleanupFunction();
        }
        memoryPointer[5] = 0;
        *(uint32_t *)(memoryPointer + 7) = 0;
        memoryPointer[4] = &SystemMemoryAllocatorReference;
        *memoryPointer = &SystemGlobalDataReference;
        if (memoryPointer[1] == 0) {
          memoryPointer[1] = 0;
          *(uint32_t *)(memoryPointer + 3) = 0;
          *memoryPointer = &SystemMemoryAllocatorReference;
            SystemCleanupFunction(memoryPointer);
        }
          SystemCleanupFunction();
      }
      *(void* *)(*(long long *)(systemDataReference + 0x30) + blockIndex * 8) = 0;
      blockIndex = blockIndex + 1;
    } while (blockIndex < memoryBlockCount);
  }
  *(void* *)(systemDataReference + 0x38) = *(void* *)(systemDataReference + 0x30);
  blockIndex = systemDataReference + 0x50;
  ProcessMemoryBlock(blockIndex,*(void* *)(systemDataReference + 0x60),cleanupFlag,cleanupParameter,0xfffffffffffffffe);
  *(long long *)blockIndex = blockIndex;
  *(long long *)(systemDataReference + 0x58) = blockIndex;
  *(void* *)(systemDataReference + 0x60) = 0;
  *(uint8_t *)(systemDataReference + 0x68) = 0;
  *(void* *)(systemDataReference + 0x70) = 0;
  return;
}




// 函数: void CleanupMemoryRegion(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存区域处理器
 * 
 * 该函数处理系统内存区域的操作，通过调用底层的内存处理函数来执行
 * 特定的内存操作任务。
 * 
 * @param memoryRegion 内存区域指针
 * @param memoryOffset 内存偏移量
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统内存管理的辅助函数，用于处理特定的内存区域操作
 */
void SystemMemoryRegionProcessor(long long memoryRegion,void* memoryOffset,void* operationFlag,void* operationParameter)

{
  ReleaseMemoryRegion(memoryRegion,*(void* *)(memoryRegion + 0x10),operationFlag,operationParameter,0xfffffffffffffffe);
  return;
}




// 函数: void FreeMemoryContext(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存区域操作器
 * 
 * 该函数执行系统内存区域的操作，通过调用底层的内存操作函数来处理
 * 指定内存区域的特定操作。
 * 
 * @param memoryContext 内存上下文指针
 * @param memoryTarget 内存目标指针
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统内存管理的核心函数，用于处理内存区域的操作任务
 */
void SystemMemoryRegionOperator(long long memoryContext,void* memoryTarget,void* operationFlag,void* operationParameter)

{
  ReleaseMemoryRegion(memoryContext,*(void* *)(memoryContext + 0x10),operationFlag,operationParameter,0xfffffffffffffffe);
  return;
}



// 函数: void* * GetResourceManagerPointer(void* *ResourceManagerPointer)
/**
 * @brief 系统内存分配器初始化器
 * 
 * 该函数负责初始化系统内存分配器的数据结构，设置内存分配器的引用、
 * 配置参数和初始化内存块。它会设置多个内存区域的配置参数。
 * 
 * @param memoryAllocator 内存分配器指针
 * @return 返回初始化后的内存分配器指针
 * @note 这是系统内存管理的关键初始化函数，确保内存分配器的正确配置
 */
void* * SystemMemoryAllocatorInitializer(void* *memoryAllocator)

{
  *memoryAllocator = &SystemMemoryAllocatorReference;
  memoryAllocator[1] = 0;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *memoryAllocator = &SystemDataBufferTemplateB;
  memoryAllocator[1] = memoryAllocator + 3;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *(uint8_t *)(memoryAllocator + 3) = 0;
  AllocateMemoryBlock(memoryAllocator + 0xb);
  memoryAllocator[0x74] = 0;
  memoryAllocator[0x75] = 0;
  memoryAllocator[0x76] = 0;
  *(uint32_t *)(memoryAllocator + 0x77) = 3;
  memoryAllocator[0x78] = 0;
  memoryAllocator[0x79] = 0;
  memoryAllocator[0x7a] = 0;
  *(uint32_t *)(memoryAllocator + 0x7b) = 3;
  memoryAllocator[0x7c] = 0;
  memoryAllocator[0x7d] = 0;
  memoryAllocator[0x7e] = 0;
  *(uint32_t *)(memoryAllocator + 0x7f) = 3;
  memoryAllocator[0x80] = 0;
  memoryAllocator[0x81] = 0;
  memoryAllocator[0x82] = 0;
  *(uint32_t *)(memoryAllocator + 0x83) = 3;
  memoryAllocator[0x84] = 0;
  memoryAllocator[0x85] = 0;
  memoryAllocator[0x86] = 0;
  *(uint32_t *)(memoryAllocator + 0x87) = 3;
  memoryAllocator[0x88] = 0;
  memoryAllocator[0x89] = 0;
  memoryAllocator[0x8a] = 0;
  *(uint32_t *)(memoryAllocator + 0x8b) = 3;
  memoryAllocator[0x8c] = 0;
  memoryAllocator[0x8d] = 0;
  memoryAllocator[0x8e] = 0;
  *(uint32_t *)(memoryAllocator + 0x8f) = 3;
  return memoryAllocator;
}




// 函数: void InitializeResourcePointer(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统数据表处理器A
 * 
 * 该函数处理系统数据表的操作，遍历数据表中的所有条目，并调用相应的处理函数。
 * 使用0x69作为步长来遍历数据表条目。
 * 
 * @param DataTablePointer 数据表指针
 * @param systemContext 系统上下文
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统数据表处理的核心函数，确保数据表条目的正确处理
 */
void SystemDataTableProcessorA(long long *DataTablePointer,void* systemContext,void* operationFlag,void* operationParameter)

{
  void* *tableEntryPointer;
  void** SystemDataTable;
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  tableEntryPointer = (void* *)DataTablePointer[1];
  for (HashEntryStatus = (void* *)*DataTablePointer; HashEntryStatus != tableEntryPointer; HashEntryStatus = HashEntryStatus + 0x69) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,operationFlag,operationParameter,cleanupFlag);
  }
  if (*DataTablePointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SetupResourcePointer(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统数据表处理器B
 * 
 * 该函数处理系统数据表的操作，遍历数据表中的所有条目，并调用相应的处理函数。
 * 使用0xb作为步长来遍历数据表条目。
 * 
 * @param DataTablePointer 数据表指针
 * @param systemContext 系统上下文
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统数据表处理的辅助函数，用于处理不同结构的数据表
 */
void SystemDataTableProcessorB(long long *DataTablePointer,void* systemContext,void* operationFlag,void* operationParameter)

{
  void* *tableEntryPointer;
  void** SystemDataTable;
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  tableEntryPointer = (void* *)DataTablePointer[1];
  for (HashEntryStatus = (void* *)*DataTablePointer; HashEntryStatus != tableEntryPointer; HashEntryStatus = HashEntryStatus + 0xb) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,operationFlag,operationParameter,cleanupFlag);
  }
  if (*DataTablePointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ReleaseGraphicsContext(long long ResourceManagerPointer)
/**
 * @brief 系统互斥锁内存清理器
 * 
 * 该函数使用互斥锁保护的方式清理系统内存，遍历内存块并进行安全清理。
 * 它会锁定互斥锁，清理内存区域，然后解锁互斥锁。
 * 
 * @param mutexPointer 互斥锁指针
 * @note 这是系统内存管理的线程安全函数，确保内存清理操作的原子性
 */
void SystemMutexMemoryCleaner(long long mutexPointer)

{
  int lockResult;
  long long memoryBase;
  uint entryIndex;
  ulong long memoryOffset;
  ulong long entryCounter;
  
  lockResult = _Mtx_lock(mutexPointer + 0x28);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  entryCounter = 0;
  memoryBase = *(long long *)(mutexPointer + 8);
  memoryOffset = entryCounter;
  if (*(long long *)(mutexPointer + 0x10) - memoryBase >> 3 != 0) {
    do {
      if (*(long long *)(memoryOffset + memoryBase) != 0) {
          SystemCleanupFunction();
      }
      *(void* *)(memoryOffset + *(long long *)(mutexPointer + 8)) = 0;
      entryIndex = (int)entryCounter + 1;
      entryCounter = (ulong long)entryIndex;
      memoryBase = *(long long *)(mutexPointer + 8);
      memoryOffset = memoryOffset + 8;
    } while ((ulong long)(long long)(int)entryIndex <
             (ulong long)(*(long long *)(mutexPointer + 0x10) - memoryBase >> 3));
  }
  *(long long *)(mutexPointer + 0x10) = memoryBase;
  lockResult = _Mtx_unlock(mutexPointer + 0x28);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  return;
}




// 函数: 系统队列处理器 - 处理系统队列中的项目
/**
 * @brief 系统队列处理器
 * 
 * 该函数负责处理系统队列中的项目，根据队列项目的状态执行相应的操作
 * 包括队列清理、回调函数调用和系统资源管理
 * 
 * @param QueuePointer 队列指针，指向需要处理的系统队列
 * 
 * 该函数会检查队列状态，调用相应的回调函数，并管理相关的系统资源
 */
void ProcessSystemQueueItem(long long *QueuePointer)

{
  long long QueueItemValue;
  
  QueueItemValue = *QueuePointer;
  if (QueueItemValue == 0) {
    *QueuePointer = 0;
    if ((long long *)QueuePointer[2] != (long long *)0x0) {
      (**(code **)(*(long long *)QueuePointer[2] + 0x38))();
    }
    if ((long long *)QueuePointer[1] != (long long *)0x0) {
      (**(code **)(*(long long *)QueuePointer[1] + 0x38))();
    }
    return;
  }
  if (*(long long *)(QueueItemValue + 8) != 0) {
      SystemCleanupFunction();
  }
  _Mtx_destroy_in_situ();
    SystemCleanupFunction(QueueItemValue);
}




// 函数: 系统资源清理器 - 清理系统资源并处理异常列表
/**
 * @brief 系统资源清理器
 * 
 * 该函数负责清理系统资源，包括内存释放、异常列表处理和资源句柄管理
 * 它会遍历资源数组，逐个清理资源，并处理相关的异常列表条目
 * 
 * @param ResourceHandle 资源句柄，指向需要清理的资源结构
 * 
 * 该函数会递归清理所有相关资源，并确保系统处于一致状态
 */
void CleanupSystemResources(long long ResourceHandle)

{
  int *ReferenceCount;
  long long ResourcePointer;
  void* *ResourceArray;
  long long ArrayBase;
  ulong long ResourceIndex;
  ulong long ResourceCount;
  
  ResourceCount = *(ulong long *)(ResourceHandle + 0x10);
  ArrayBase = *(long long *)(ResourceHandle + 8);
  ResourceIndex = 0;
  if (ResourceCount != 0) {
    do {
      ResourcePointer = *(long long *)(ArrayBase + ResourceIndex * 8);
      if (ResourcePointer != 0) {
          SystemCleanupFunction(ResourcePointer);
      }
      *(void* *)(ArrayBase + ResourceIndex * 8) = 0;
      ResourceIndex = ResourceIndex + 1;
    } while (ResourceIndex < ResourceCount);
    ResourceCount = *(ulong long *)(ResourceHandle + 0x10);
  }
  *(void* *)(ResourceHandle + 0x18) = 0;
  if ((1 < ResourceCount) && (ResourceArray = *(void* **)(ResourceHandle + 8), ResourceArray != (void* *)0x0)) {
    ResourceCount = (ulong long)ResourceArray & 0xffffffffffc00000;
    if (ResourceCount != 0) {
      ArrayBase = ResourceCount + 0x80 + ((long long)ResourceArray - ResourceCount >> 0x10) * 0x50;
      ArrayBase = ArrayBase - (ulong long)*(uint *)(ArrayBase + 4);
      if ((*(void ***)(ResourceCount + 0x70) == &ExceptionList) && (*(char *)(ArrayBase + 0xe) == '\0')) {
        *ResourceArray = *(void* *)(ArrayBase + 0x20);
        *(void* **)(ArrayBase + 0x20) = ResourceArray;
        ReferenceCount = (int *)(ArrayBase + 0x18);
        *ReferenceCount = *ReferenceCount + -1;
        if (*ReferenceCount == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceCount,CONCAT71(0xff000000,*(void ***)(ResourceCount + 0x70) == &ExceptionList),
                            ResourceArray,ResourceCount,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: 系统队列清理器 - 清理系统队列中的所有项目
/**
 * @brief 系统队列清理器
 * 
 * 该函数负责清理系统队列中的所有项目，遍历整个队列并逐个处理
 * 每个队列项目。最后会调用系统清理函数确保资源正确释放
 * 
 * @param QueueHeader 队列头指针，指向需要清理的队列头部
 * 
 * 该函数会遍历队列中的所有项目，调用队列处理器处理每个项目
 * 最后确保系统资源被正确清理
 */
void CleanupSystemQueue(long long *QueueHeader)

{
  long long QueueEnd;
  long long CurrentItem;
  
  QueueEnd = QueueHeader[1];
  for (CurrentItem = *QueueHeader; CurrentItem != QueueEnd; CurrentItem = CurrentItem + 0x18) {
    ProcessSystemQueueItem(CurrentItem);
  }
  if (*QueueHeader == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SystemDataStructureProcess(long long *ResourceManagerPointer)
void SystemDataStructureProcess(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)ResourceManagerPointer[1];
  for (resourcePoolPointer = (long long *)*ResourceManagerPointer; resourcePoolPointer != PrimaryResourcePointer; resourcePoolPointer = resourcePoolPointer + 1) {
    if ((long long *)*resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*(long long *)*resourcePoolPointer + 0x38))();
    }
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，将其设置为初始状态。
 * 它会清空指针的各个字段，并设置初始化标志位。
 * 
 * @param ResourceManagerPointer 要初始化的系统资源指针
 * @return 返回初始化后的系统资源指针
 * @note 这是系统资源管理的基础初始化函数
 */
void* * ResourceManagerPointerInitializer(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 3;
  return ResourceManagerPointer;
}




// 函数: void ProcessSystemInitializationQueue(long long *queueHeader)
/**
 * @brief 处理系统初始化队列
 * 
 * 该函数负责处理系统初始化队列中的所有项目。它会遍历队列中的每个项目，
 * 调用相应的处理函数，直到所有项目都被处理完毕。
 * 
 * @param queueHeader 队列头指针，包含队列的起始和结束信息
 */
void ProcessSystemInitializationQueue(long long *queueHeader)

{
  long long queueEnd;
  long long currentQueueItem;
  
  queueEnd = queueHeader[1];
  for (currentQueueItem = *queueHeader; currentQueueItem != queueEnd; currentQueueItem = currentQueueItem + 0x18) {
    ProcessQueueItem(currentQueueItem);
  }
  if (*queueHeader == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SystemMemoryInitialize(long long ResourceManagerPointer)
void SystemMemoryInitialize(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemResourceAllocate(long long ResourceManagerPointer)
void SystemResourceAllocate(long long ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  uint8_t aUnsignedStackFlagA8 [8];
  void* *SystemDataPointer;
  uint unsignedValue98;
  void* UnsignedStackFlag88;
  void* UnsignedStackFlag80;
  void* UnsignedStackFlag78;
  uint32_t processFlags70;
  void* EncryptionValue68;
  void* unsignedValue60;
  void* processFlags58;
  uint32_t unsignedValue50;
  void* *pEncryptionValue48;
  long long longValue40;
  uint32_t unsignedValue30;
  void* EncryptionKeyValue;
  
  EncryptionKeyValue = 0xfffffffffffffffe;
  if (ResourceManagerPointer == 0) {

/**
 * @brief 系统资源引用计数管理器
 * 
 * 该函数负责管理系统资源的引用计数，当资源引用计数归零时自动释放资源。
 * 函数会检查资源指针的有效性，计算资源偏移量，并维护引用计数。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * 
 * @note 函数使用位运算计算资源偏移量
 * @note 当引用计数归零时调用ReleaseSystemResource()函数
 * @note 函数处理异常列表和资源释放逻辑
 */
void ManageSystemResourceReferenceCount(ulong long *ResourceManagerPointer)

{
  int *referenceCountPointer;
  void** SystemDataTable;
  long long resourceOffset;
  ulong long memoryRegionMask;
  
  void* resourcePointer = (void* *)*ResourceManagerPointer;
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 系统清理执行器
 * 
 * 该函数负责执行系统清理操作，遍历资源指针数组并调用相应的清理函数。
 * 函数会处理资源释放和系统清理的最后步骤。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 清理参数2
 * @param AdditionalParameter 清理参数3
 * @param ConfigurationFlag 清理参数4
 * 
 * @note 函数使用0xfffffffffffffffe作为清理标志
 * @note 函数最后调用SystemCleanupFunction()进行最终清理
 */
void ExecuteSystemCleanup(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *cleanupArrayEnd;
  void** SystemDataTable;
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  cleanupArrayEnd = (void* *)ResourceManagerPointer[1];
  for (void* *currentCleanupFunction = (void* *)*ResourceManagerPointer; currentCleanupFunction != cleanupArrayEnd; currentCleanupFunction = currentCleanupFunction + 4) {
    (**(code **)*currentCleanupFunction)(currentCleanupFunction,0,AdditionalParameter,ConfigurationFlag,cleanupFlag);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源状态验证器
 * 
 * 该函数负责验证系统资源的状态，检查资源指针的有效性
 * 并执行相应的状态验证操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * @note 函数首先检查资源指针是否为空
 * @note 函数使用系统句柄进行状态验证
 */
void ValidateSystemResourceStatus(long long ResourceManagerPointer)

{
  uint systemStatus;
  long long localSystemHandle;
  
  if (ResourceManagerPointer == 0) {

/**
 * @brief 系统字符串复制处理器
 * 
 * 该函数负责计算字符串长度并将字符串复制到系统数据区域。
 * 函数会计算源字符串的长度，限制最大长度为0x1fff，然后将字符串
 * 复制到预定义的系统数据地址。
 * 
 * @param ResourceManagerPointer 源字符串指针
 * 
 * @note 函数限制字符串最大长度为8191字节(0x1fff)
 * @note 函数将字符串复制到SystemStringBuffer地址
 * @note 函数使用do-while循环计算字符串长度
 */
void CopySystemStringToDataArea(long long ResourceManagerPointer)

{
  uint stringLength;
  long long charIndex;
  
  charIndex = -1;
  do {
    charIndex = charIndex + 1;
  } while (*(char *)(ResourceManagerPointer + charIndex) != '\0');
  stringLength = (uint)charIndex;
  if (0x1fff < stringLength) {
    stringLength = 0x1fff;
  }
    memcpy(&SystemStringBuffer,ResourceManagerPointer,(long long)(int)stringLength);
}




/**
 * @brief 系统事件处理器
 * 
 * 处理系统级事件并执行相应的软件中断操作。
 * 该函数负责事件处理流程的核心调度。
 */
void SystemEventHandler(void)

{
  code *systemFunctionPointer;
  
  ProcessSystemEvent();
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}



/**
 * @brief 初始化系统资源缓冲区
 * 
 * 该函数初始化系统资源缓冲区，设置内存分配器引用、全局数据引用和
 * 各种系统资源的配置。函数会配置多个资源指针并设置相关的属性值。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param reservedParam2 保留参数2
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回初始化后的系统资源指针
 */
uint8_t *
InitializeSystemResourceBuffer(uint8_t *systemResourcePointer, void* reservedParam2, void* reservedParam3, void* reservedParam4)

{
  long long *primaryResourcePointer;
  long long *secondaryResourcePointer;
  long long *resourceAllocatorPointer;
  
  plocalResourceOffset = (long long *)(ResourceManagerPointer + 8);
  *plocalResourceOffset = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  *plocalResourceOffset = (long long)&SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  *(void* **)(ResourceManagerPointer + 0x38) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x40) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x48) = 0;
  *(void* **)(ResourceManagerPointer + 0x38) = &SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x50) = 0;
  *(void* *)(ResourceManagerPointer + 0x40) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x48) = 0;
  *(void* **)(ResourceManagerPointer + 0x58) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x60) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x68) = 0;
  *(void* **)(ResourceManagerPointer + 0x58) = &SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x70) = 0;
  *(void* *)(ResourceManagerPointer + 0x60) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x68) = 0;
  PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x80);
  *PrimaryResourcePointer = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x88) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x90) = 0;
  *PrimaryResourcePointer = (long long)&SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x98) = 0;
  *(void* *)(ResourceManagerPointer + 0x88) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x90) = 0;
  resourcePoolPointer = (long long *)(ResourceManagerPointer + 0xa0);
  *resourcePoolPointer = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0xa8) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xb0) = 0;
  *resourcePoolPointer = (long long)&SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0xb8) = 0;
  *(void* *)(ResourceManagerPointer + 0xa8) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xb0) = 0;
  *ResourceManagerPointer = 0;
  (**(code **)(*plocalResourceOffset + 0x10))(plocalResourceOffset,&SystemResourceInitializationData,&SystemMemoryAllocatorReference,ConfigurationFlag,0xfffffffffffffffe);
  *(void* *)(ResourceManagerPointer + 0x28) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x30) = 0;
  ResourceManagerPointer[0x7c] = 0;
  ResourceManagerPointer[0xc9] = 1;
  (**(code **)(*PrimaryResourcePointer + 0x10))(PrimaryResourcePointer,&SystemResourceTemplate);
  (**(code **)(*resourcePoolPointer + 0x10))(resourcePoolPointer,&SystemStringTemplate);
  *(uint32_t *)(ResourceManagerPointer + 0xc0) = 0x461c4000;
  *(uint32_t *)(ResourceManagerPointer + 0xc4) = 0x461c4000;
  ResourceManagerPointer[200] = 0;
  *(void* *)(ResourceManagerPointer + 0xd0) = 0;
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源复杂初始化器
 * 
 * 该函数负责对系统资源指针进行复杂的初始化操作，包括设置多个内存分配器引用、
 * 全局数据引用和各种配置参数。这是系统初始化过程中的核心函数。
 * 
 * @param ResourceManagerPointer 要初始化的系统资源指针
 * @return 返回初始化后的系统资源指针
 * @note 这是一个复杂的初始化函数，涉及多个系统组件的配置
 */
void* * SystemResourceComplexInitializer(void* *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long *plocalResourceOffset;
  long long bufferBaseAddress;
  uint32_t *pcurrentThreadId;
  void** SystemRootNode;
  long long *plocalDataIndex;
  uint32_t *newThreadLocalStorage;
  uint32_t *punsignedSystemValue9;
  long long allocationFlags;
  void* *ParameterStackArray [3];
  
  *(uint8_t *)((long long)ResourceManagerPointer + 0x1c) = 0;
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  ResourceManagerPointer[8] = 0;
  ResourceManagerPointer[9] = 0;
  ResourceManagerPointer[0xf] = 0;
  ResourceManagerPointer[0x10] = 0;
  ResourceManagerPointer[0x11] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x12) = 3;
  ResourceManagerPointer[0x17] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x18] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x19) = 0;
  ResourceManagerPointer[0x17] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x1a] = 0;
  ResourceManagerPointer[0x18] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x19) = 0;
  ResourceManagerPointer[0x1b] = 0;
  ResourceManagerPointer[0x1c] = 0;
  ResourceManagerPointer[0x1d] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1e) = 3;
  PrimaryResourcePointer = ResourceManagerPointer + 0x21;
  *PrimaryResourcePointer = 0;
  ResourceManagerPointer[0x22] = 0;
  ResourceManagerPointer[0x23] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x24) = 3;
  ResourceManagerPointer[0x29] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x2a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x2b) = 0;
  ResourceManagerPointer[0x29] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x2c] = 0;
  ResourceManagerPointer[0x2a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x2b) = 0;
  resourcePoolPointer = ResourceManagerPointer + 0x2e;
  *resourcePoolPointer = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x2f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x30) = 0;
  *resourcePoolPointer = (long long)&SystemGlobalDataReference;
  ResourceManagerPointer[0x31] = 0;
  ResourceManagerPointer[0x2f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x30) = 0;
  plocalResourceOffset = ResourceManagerPointer + 0x32;
  *plocalResourceOffset = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x33] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x34) = 0;
  *plocalResourceOffset = (long long)&SystemMemoryTemplateE;
  ResourceManagerPointer[0x33] = ResourceManagerPointer + 0x35;
  *(uint32_t *)(ResourceManagerPointer + 0x34) = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x35) = 0;
  plocalDataIndex = ResourceManagerPointer + 0x39;
  *plocalDataIndex = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x3a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x3b) = 0;
  *plocalDataIndex = (long long)&SystemGlobalDataReference;
  ResourceManagerPointer[0x3c] = 0;
  ResourceManagerPointer[0x3a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x3b) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x254) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x25c) = 0;
  ResourceManagerPointer[0x4e] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x4f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x50) = 0;
  ResourceManagerPointer[0x4e] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x51] = 0;
  ResourceManagerPointer[0x4f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x50) = 0;
  ResourceManagerPointer[0x52] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x53] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x54) = 0;
  ResourceManagerPointer[0x52] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x55] = 0;
  ResourceManagerPointer[0x53] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x54) = 0;
  ResourceManagerPointer[0x58] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x59] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x5a) = 0;
  ResourceManagerPointer[0x58] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x5b] = 0;
  ResourceManagerPointer[0x59] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x5a) = 0;
  resourceEntryPointer = ResourceManagerPointer + 0x5c;
  ResourceManagerPointer[0x5f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x61) = 3;
  *resourceEntryPointer = resourceEntryPointer;
  ResourceManagerPointer[0x5d] = resourceEntryPointer;
  ResourceManagerPointer[0x5e] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x5f) = 0;
  ResourceManagerPointer[0x60] = 0;
  ResourceManagerPointer[100] = 0;
  ResourceManagerPointer[0x65] = 0;
  ResourceManagerPointer[0x66] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x67) = 3;
  ResourceManagerPointer[0x69] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x6a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6b) = 0;
  ResourceManagerPointer[0x69] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x6c] = 0;
  ResourceManagerPointer[0x6a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6b) = 0;
  ParameterStackArray[0] = ResourceManagerPointer + 0x6d;
  *ParameterStackArray[0] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x6e] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6f) = 0;
  *ParameterStackArray[0] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x70] = 0;
  ResourceManagerPointer[0x6e] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6f) = 0;
  *(uint32_t *)(ResourceManagerPointer + 4) = 0;
  *ResourceManagerPointer = 0;
  *(uint32_t *)(ResourceManagerPointer + 99) = 0;
  (**(code **)(*plocalDataIndex + 0x10))
            (plocalDataIndex,&SystemResourceTemplateSeptenary,&SystemGlobalDataReference,&SystemMemoryAllocatorReference,0xfffffffffffffffe);
  *(uint32_t *)(ResourceManagerPointer + 0x3d) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x1ed) = 0x1000001;
  ResourceManagerPointer[0x62] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0xc) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 0xffffffff;
  *(uint8_t *)(ResourceManagerPointer + 0x14) = 0;
  ResourceManagerPointer[0x15] = 0;
  ResourceManagerPointer[0x16] = 0;
  *(uint8_t *)((long long)ResourceManagerPointer + 0x1ec) = 0;
  LOCK();
  *(uint8_t *)(ResourceManagerPointer + 0x79) = 0;
  UNLOCK();
  (**(code **)(*plocalResourceOffset + 0x10))(plocalResourceOffset,&SystemResourceConfigurationData);
  (**(code **)(*resourcePoolPointer + 0x10))(resourcePoolPointer,&SystemStringTemplate);
  *(uint8_t *)(ResourceManagerPointer + 0x2d) = 0;
  ResourceManagerPointer[0x13] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1f) = 0x1010101;
  *(void*2 *)((long long)ResourceManagerPointer + 0xfc) = 0x101;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x104) = 0xffffffff;
  allocationFlags = 8;
  do {
    punsignedSystemValue9 = (uint32_t *)ResourceManagerPointer[0x22];
    if (punsignedSystemValue9 < (uint32_t *)ResourceManagerPointer[0x23]) {
      ResourceManagerPointer[0x22] = punsignedSystemValue9 + 1;
      *punsignedSystemValue9 = 0;
    }
    else {
      newThreadLocalStorage = (uint32_t *)*PrimaryResourcePointer;
      bufferBaseAddress = (long long)punsignedSystemValue9 - (long long)newThreadLocalStorage >> 2;
      if (bufferBaseAddress == 0) {
        bufferBaseAddress = 1;
SystemBufferAllocationHandler:
        pcurrentThreadId = (uint32_t *)
                 CreateSystemThreadObject(SystemMemoryPoolTemplate,bufferBaseAddress * 4,*(uint8_t *)(ResourceManagerPointer + 0x24));
        punsignedSystemValue9 = (uint32_t *)ResourceManagerPointer[0x22];
        newThreadLocalStorage = (uint32_t *)*PrimaryResourcePointer;
      }
      else {
        bufferBaseAddress = bufferBaseAddress * 2;
        pcurrentThreadId = (uint32_t *)0x0;
        if (bufferBaseAddress != 0) goto SystemBufferAllocationHandler;
      }
      if (newThreadLocalStorage != punsignedSystemValue9) {
          memmove(pcurrentThreadId,newThreadLocalStorage,(long long)punsignedSystemValue9 - (long long)newThreadLocalStorage);
      }
      *pcurrentThreadId = 0;
      if (*PrimaryResourcePointer != 0) {
          SystemCleanupFunction();
      }
      *PrimaryResourcePointer = (long long)pcurrentThreadId;
      ResourceManagerPointer[0x22] = pcurrentThreadId + 1;
      ResourceManagerPointer[0x23] = pcurrentThreadId + bufferBaseAddress;
    }
    allocationFlags = allocationFlags + -1;
    if (allocationFlags == 0) {
      *(uint32_t *)((long long)ResourceManagerPointer + 0x24) = 0;
      *(uint32_t *)((long long)ResourceManagerPointer + 0x29) = 0x1010101;
      *(uint8_t *)(ResourceManagerPointer + 5) = 1;
      *(uint32_t *)(ResourceManagerPointer + 0x71) = 0x3f800000;
      *(uint8_t *)(ResourceManagerPointer + 0x76) = 1;
      *(uint32_t *)(ResourceManagerPointer + 0x25) = 0;
      ResourceManagerPointer[0x56] = 0;
      *(void* *)((long long)ResourceManagerPointer + 0x224) = 0;
      *(uint8_t *)((long long)ResourceManagerPointer + 0x22c) = 0;
      *(uint32_t *)(ResourceManagerPointer + 0x40) = 0;
      ResourceManagerPointer[0x41] = 0;
      resourceEntryPointer = SystemPerformancePreviousStorage;
      if (SystemPerformancePreviousStorage == (void* *)0x0) {
        QueryPerformanceCounter(ParameterStackArray);
        resourceEntryPointer = ParameterStackArray[0];
      }
      ResourceManagerPointer[0x42] = (double)((long long)resourceEntryPointer - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
      *(uint32_t *)(ResourceManagerPointer + 0x44) = 0;
      *(uint8_t *)((long long)ResourceManagerPointer + 0x264) = 0;
      *(uint32_t *)(ResourceManagerPointer + 0x4d) = 0;
      *(void* *)((long long)ResourceManagerPointer + 500) = 0;
      *(uint8_t *)(ResourceManagerPointer + 0x28) = 0;
      *(uint8_t *)((long long)ResourceManagerPointer + 0x1fc) = 0;
      ResourceManagerPointer[0x7b] = 0;
      ResourceManagerPointer[0x57] = 0;
      allocationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc,4,3);
      *(uint8_t *)(allocationFlags + 8) = 0;
      ResourceManagerPointer[6] = allocationFlags;
      ResourceManagerPointer[0x27] = 0;
      *(uint8_t *)(ResourceManagerPointer + 7) = 0;
      *(uint32_t *)((long long)ResourceManagerPointer + 0x3c) = 0xffffffff;
      ResourceManagerPointer[0x43] = 0;
      *(uint32_t *)(ResourceManagerPointer + 0x26) = 0xffffffff;
      resourceEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,3);
      resourceEntryPointer[1] = 0;
      resourceEntryPointer[2] = 0;
      resourceEntryPointer[3] = 0;
      resourceEntryPointer[4] = 0;
      resourceEntryPointer[5] = 0;
      *resourceEntryPointer = &SystemMemoryTemplateA;
      *resourceEntryPointer = &SystemMemoryTemplateB;
      *(uint32_t *)(resourceEntryPointer + 1) = 0;
      *resourceEntryPointer = &SystemResourceTemplateNonary;
      resourceEntryPointer[2] = 0;
      resourceEntryPointer[3] = 0;
      resourceEntryPointer[4] = 0;
      *(uint32_t *)(resourceEntryPointer + 5) = 3;
      ResourceManagerPointer[0x78] = resourceEntryPointer;
      return ResourceManagerPointer;
    }
  } while( true );
}




/**
 * 系统组件初始化器 - 初始化核心系统组件
 * @brief 执行系统资源回调函数
 * 
 * 该函数负责执行系统资源的回调函数，用于处理系统资源的异步操作。
 * 当系统资源完成某些操作时，会调用此函数来执行相应的回调处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void ExecuteSystemResourceCallback(long long *ResourceManagerPointer)

{
  if ((long long *)*callbackParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*callbackParameter + 0x38))();
  }
  return;
}



/**
 * @brief 系统内存模板管理器
 * 
 * 该函数管理系统内存模板的设置和清理。它会检查系统资源指针的状态，
 * 在需要时进行清理操作，然后设置相应的内存模板引用。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 控制标志位，第0位为1时释放内存
 * @param AdditionalParameter 内存释放参数1
 * @param ConfigurationFlag 内存释放参数2
 * @return 返回处理后的系统资源指针
 * @note 这是内存管理系统的核心函数之一
 */
void* *
SystemMemoryTemplateManager(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ResourceManagerPointer[2] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x30,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统内存模板清理函数
 * 
 * 该函数负责清理系统内存模板，释放相关资源。
 * 当系统资源不再需要时，调用此函数进行内存模板的清理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemMemoryTemplateCleanup(void* *ResourceManagerPointer)

{
  if (ResourceManagerPointer[2] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  return;
}





/**
 * @brief 计算渲染质量设置
 * 
 * 根据系统节点管理器的配置计算渲染质量相关的各种参数，
 * 包括纹理缩放、阴影缩放、基础渲染比例等。
 * 这些参数用于调整游戏的渲染质量和性能。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于存储计算结果
 * 
 * @return 无返回值
 * 
 * @note 计算结果会直接写入系统资源指针指定的内存位置
 */
void CalculateRenderQualitySettings(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  int systemResult;
  int MemoryComparisonResult;
  float renderQualityMultiplier;
  float baseRenderScale;
  float textureScaleFactor;
  float shadowScaleFactor;
  float qualityLevel;
  
  nextDataIndex = SystemNodeManagerPointer;
  systemResult = *(int *)(SystemNodeManagerPointer + 0xd90) + -1;
  systemCounter = 0;
  if ((-1 < systemResult) && (systemCounter = systemResult, 3 < systemResult)) {
    systemCounter = 3;
  }
  qualityLevel = (float)systemCounter;
  shadowScaleFactor = qualityLevel * 1.6750001 + 2.4750001;
  baseRenderScale = qualityLevel * 4.4666667 + 6.6000004;
  textureScaleFactor = qualityLevel * 3.3500001 + 4.9500003;
  renderQualityMultiplier = shadowScaleFactor + textureScaleFactor;
  *(float *)(ResourceManagerPointer + 0x38c) = textureScaleFactor * textureScaleFactor;
  shadowScaleFactor = shadowScaleFactor + renderQualityMultiplier;
  *(float *)(ResourceManagerPointer + 0x390) = renderQualityMultiplier * renderQualityMultiplier;
  renderQualityMultiplier = baseRenderScale + shadowScaleFactor;
  *(float *)(ResourceManagerPointer + 0x394) = shadowScaleFactor * shadowScaleFactor;
  baseRenderScale = baseRenderScale + renderQualityMultiplier;
  *(float *)(ResourceManagerPointer + 0x398) = renderQualityMultiplier * renderQualityMultiplier;
  renderQualityMultiplier = qualityLevel * 13.400001 + 19.800001 + baseRenderScale;
  *(float *)(ResourceManagerPointer + 0x39c) = baseRenderScale * baseRenderScale;
  baseRenderScale = qualityLevel * 17.866667 + 26.400002 + renderQualityMultiplier;
  *(float *)(ResourceManagerPointer + 0x3a0) = renderQualityMultiplier * renderQualityMultiplier;
  *(float *)(ResourceManagerPointer + 0x3a4) = baseRenderScale * baseRenderScale;
  *(uint32_t *)(ResourceManagerPointer + 0x3a8) = 0x7f7fffff;
  *(uint *)(ResourceManagerPointer + 0x3ac) = (uint)(*(int *)(nextDataIndex + 0xd90) == 0);
  return;
}





/**
 * @brief 系统资源清理管理器
 * 
 * 负责管理系统资源的清理和释放，包括内存分配器、音频管理器、渲染管理器
 * 以及其他系统组件的资源回收。确保系统在关闭时正确释放所有资源。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含所有需要清理的系统资源
 */
void SystemResourceCleanupManager(long long *ResourceManagerPointer)
{
  void* *SystemResourceArray;
  long long LocalSystemHandle;
  
  SystemResourceArray = (void* *)ResourceManagerPointer[0x7c];
  if (SystemResourceArray != (void* *)0x0) {
    SystemResourceArray[0x14] = &SystemGlobalDataReference;
    if (SystemResourceArray[0x15] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[0x15] = 0;
    *(uint32_t *)(SystemResourceArray + 0x17) = 0;
    SystemResourceArray[0x14] = &SystemMemoryAllocatorReference;
    SystemResourceArray[0x10] = &SystemGlobalDataReference;
    if (SystemResourceArray[0x11] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[0x11] = 0;
    *(uint32_t *)(SystemResourceArray + 0x13) = 0;
    SystemResourceArray[0x10] = &SystemMemoryAllocatorReference;
    if (SystemResourceArray[0xc] != 0) {
        SystemCleanupFunction();
    }
    SystemMemoryDeallocationFunction();
    SystemMemoryDeallocationFunction();
    *SystemResourceArray = &SystemGlobalDataReference;
    if (SystemResourceArray[1] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[1] = 0;
    *(uint32_t *)(SystemResourceArray + 3) = 0;
    *SystemResourceArray = &SystemMemoryAllocatorReference;
      SystemCleanupFunction(SystemResourceArray);
  }
  ResourceManagerPointer[0x7c] = 0;
  SystemResourceArray = (void* *)ResourceManagerPointer[1];
  if (SystemResourceArray != (void* *)0x0) {
    LocalSystemHandle = __RTCastToVoid(SystemResourceArray);
    *SystemResourceArray = &SystemUnknownDataReference;
    SystemResourceReleaseFunction(SystemAllocationFlagsTemplate,SystemResourceArray[0x28]);
    SystemResourceArray[0x28] = 0;
    SystemResourceArray[0x29] = &SystemGlobalDataReference;
    if (SystemResourceArray[0x2a] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[0x2a] = 0;
    *(uint32_t *)(SystemResourceArray + 0x2c) = 0;
    SystemResourceArray[0x29] = &SystemMemoryAllocatorReference;
    SystemResourceFinalizationFunction();
    if (LocalSystemHandle != 0) {
        SystemCleanupFunction(LocalSystemHandle);
    }
  }
  ResourceManagerPointer[1] = 0;
  LocalSystemHandle = *ResourceManagerPointer;
  if (LocalSystemHandle != 0) {
    SystemResourceHandleCleanupFunction(LocalSystemHandle);
      SystemCleanupFunction(LocalSystemHandle);
  }
  *ResourceManagerPointer = 0;
  LocalSystemHandle = SystemAudioManagerPointer;
  if (SystemAudioManagerPointer != 0) {
    SystemAudioManagerCleanupFunction();
      SystemCleanupFunction(LocalSystemHandle);
  }
  SystemAudioManagerPointer = 0;
  SystemRenderManagerCleanupFunction();
  SystemRenderManagerPointer = 0;
  if (ResourceManagerPointer[6] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[6] = 0;
  ResourceManagerPointer[0x6d] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x6e] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x6e] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x70) = 0;
  ResourceManagerPointer[0x6d] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x69] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x6a] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x6a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6c) = 0;
  ResourceManagerPointer[0x69] = (long long)&SystemMemoryAllocatorReference;
  SystemConfigurationCleanupFunction();
  SystemDataBufferCleanupFunction(ResourceManagerPointer + 0x5c,ResourceManagerPointer[0x5e]);
  ResourceManagerPointer[0x58] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x59] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x59] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x5b) = 0;
  ResourceManagerPointer[0x58] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x52] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x53] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x53] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x55) = 0;
  ResourceManagerPointer[0x52] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x4e] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x4f] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x4f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x51) = 0;
  ResourceManagerPointer[0x4e] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x39] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x3a] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x3a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x3c) = 0;
  ResourceManagerPointer[0x39] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x32] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x2e] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x2f] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x2f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x31) = 0;
  ResourceManagerPointer[0x2e] = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x29] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x2a] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x2a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x2c) = 0;
  ResourceManagerPointer[0x29] = (long long)&SystemMemoryAllocatorReference;
  if (ResourceManagerPointer[0x21] != 0) {
      SystemCleanupFunction();
  }
  SystemFinalCleanupFunction();
  ResourceManagerPointer[0x17] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x18] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x18] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1a) = 0;
  ResourceManagerPointer[0x17] = (long long)&SystemMemoryAllocatorReference;
  if (ResourceManagerPointer[0xf] != 0) {
      SystemCleanupFunction();
  }
  if ((long long *)ResourceManagerPointer[9] != (long long *)0x0) {
    SystemResourceFinalizerCallback();
  }
  return;
}



00018004d2c7)
00018004d2d0)
00018004d2da)
00018004d2df)
00018004d2f2)
00018004d30d)
00018004d328)
00018004d343)
00018004d35e)
00018004d379)
00018004d4a0)


/**
 * @brief 处理系统资源分配
 * 
 * 该函数负责处理系统资源的分配和管理操作。
 * 根据传入的参数分配相应的系统资源，并设置资源状态。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 分配参数
 */
void ProcessSystemResourceAllocation(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  byte systemByteValue;
  uint8_t creationFlags;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  char operationStatusFlag;
  int systemFlag;
  uint32_t unsignedSystemValue7;
  uint unsignedSystemValue8;
  long long resourceCounter;
  long long allocationFlags;
  uint8_t *ThreadLocalStorage;
  char *systemFunctionPointer2;
  uint32_t *pointerToUnsigned13;
  uint8_t *pointerToUnsigned14;
  byte *resourceStringPointer;
  uint8_t *pointerToUnsigned16;
  void* *pointerToUnsigned17;
  void* *pointerToUnsigned18;
  int systemStatus9;
  long long localSystemHandle0;
  ulong long creationFlags1;
  void* *HashEntryStatus2;
  uint creationFlags3;
  long long localSystemHandle4;
  ulong long creationFlags5;
  uint creationFlags6;
  void* creationFlags7;
  ulong long creationFlags8;
  ulong long creationFlags9;
  uint allocationContext0;
  bool isSystemResourceMatch;
  uint32_t extraout_XMM0_Da;
  uint32_t extraout_XMM0_Da_00;
  uint8_t arrayUnsigned368 [32];
  uint8_t unsignedValue348;
  char charValue338;
  char charValue337;
  char arrayChar336 [2];
  uint unsignedValue334;
  void* *pointerUnsigned330;
  char *charPointer328;
  uint unsignedValue320;
  void* unsignedValue318;
  void* *pointerUnsigned310;
  uint8_t *pointerUnsigned308;
  uint unsignedValue300;
  void* unsignedValue2f8;
  ulong long unsignedValue2f0;
  void* *pointerUnsigned2e8;
  uint8_t *pointerUnsigned2e0;
  uint unsignedValue2d8;
  ulong long unsignedValue2d0;
  void* *pointerUnsigned2c8;
  uint8_t *pointerUnsigned2c0;
  uint32_t unsignedValue2b8;
  ulong long unsignedValue2b0;
  void* *pointerUnsigned2a8;
  void* *pointerUnsigned2a0;
  uint unsignedValue298;
  uint32_t unsignedValue290;
  uint32_t EncryptionKeyValuec;
  void* *pEncryptionKeyValue8;
  uint32_t *pEncryptionKeyValue0;
  uint32_t unsignedValue278;
  void* unsignedValue270;
  void* *pointerUnsigned268;
  long long longValue260;
  void* *pointerUnsigned258;
  long long longValue250;
  uint unsignedValue248;
  uint32_t unsignedValue240;
  uint32_t unsignedValue23c;
  void* *pointerUnsigned238;
  long long longValue230;
  uint unsignedValue228;
  uint32_t unsignedValue220;
  void* *SystemStringTemplatePtr;
  long long longValue210;
  uint unsignedValue208;
  uint32_t StackValue200;
  void* *SystemGlobalDataReferencePtr2;
  long long longValue1f0;
  uint StackValue1e8;
  uint32_t GlobalDataFlags2;
  void* *SystemGlobalDataReferencePtr;
  long long longValue1d0;
  uint StackValue1c8;
  uint32_t GlobalDataFlags;
  void* *pointerUnsigned1b8;
  void* *pointerUnsigned1b0;
  int intValue1a8;
  uint32_t systemFlag1A0;
  void* *pSystemStackFlag;
  void* *pointerUnsigned190;
  int intValue188;
  uint32_t unsignedValue180;
  void* *psystemFlag178;
  long long longValue170;
  uint32_t encryptionKeySize;
  void* threadLocalStoragePointer;
  ulong long creationFlagsLength;
  void* *resourceManagerPointer;
  long long systemStatusOffset;
  uint32_t allocationFlags;
  void* *memoryAllocatorPointer;
  long long resourceCounter;
  uint32_t systemConfigFlags;
  void* *systemDataPointer;
  long long operationResult;
  uint32_t bufferFlags;
  void* *dataBufferPointer;
  void* *systemDataBuffer;
  void* systemHandle;
  uint32_t memoryPoolFlags;
  void* *systemResourcePointer;
  long long processStatus;
  uint32_t securityFlags;
  void* systemSemaphore;
  void* *stackParameterB;
  uint8_t *pStackParameterC;
  uint32_t systemStateFlags;
  uint8_t systemStateBuffer [72];
  ulong long encryptionKey;
  
  localSystemHandle4 = SystemStatusFlagsPointer;
  systemSemaphore = 0xfffffffffffffffe;
  encryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)arrayUnsigned368;
  ThreadLocalStorage = (uint8_t *)0x0;
  unsignedValue334 = 0;
  longValue260 = SystemStatusFlagsPointer;
  charValue338 = '\0';
  pointerToUnsigned17 = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    pointerToUnsigned17 = *(void* **)(ConfigurationDataPointer + 8);
  }
  localSystemHandle0 = -1;
  do {
    resourceCounter = localSystemHandle0;
    localSystemHandle0 = resourceCounter + 1;
  } while (pointerToUnsigned17[localSystemHandle0] != '\0');
  creationFlags1 = resourceCounter + 2;
  pointerUnsigned310 = &SystemGlobalDataReference;
  unsignedValue2f8 = 0;
  pointerUnsigned308 = (uint8_t *)0x0;
  unsignedValue300 = 0;
  pointerUnsigned268 = pointerToUnsigned17;
  creationFlagsLength = creationFlags1;
  (**(code **)(*(long long *)(SystemStatusFlagsPointer + 0x2c0) + 0x10))
            ((long long *)(SystemStatusFlagsPointer + 0x2c0),pointerToUnsigned17);
  unsignedValue2f0 = 0;
  pointerToUnsigned14 = ThreadLocalStorage;
  if (creationFlags1 != 0) {
    do {
      systemByteValue = pointerToUnsigned17[unsignedValue2f0];
      unsignedSystemValue8 = (uint)pointerToUnsigned14;
      if ((systemByteValue & 0xdf) == 0) {
        localSystemHandle0 = localSystemHandle4 + 0x2e0;
        resourceCounter = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x40,*(uint8_t *)(localSystemHandle4 + 0x308));
        ProcessResourcePointerOperation(resourceCounter + 0x20,&pointerUnsigned310);
        allocationFlags = SystemResourceAllocator(localSystemHandle0,&charValue337,resourceCounter + 0x20);
        if (charValue337 != '\0') {
          if (allocationFlags == localSystemHandle0) goto ResourceAllocationCheck;
          if (*(int *)(allocationFlags + 0x30) == 0) goto AllocationFlagCheck;
          if (*(int *)(resourceCounter + 0x30) == 0) goto ResourceAllocationCheck;
          resourceStringPointer = *(byte **)(allocationFlags + 0x28);
          localSystemHandle4 = *(long long *)(resourceCounter + 0x28) - (long long)resourceStringPointer;
          goto AllocationHandler;
        }
        SystemUtilityHandler(extraout_XMM0_Da,resourceCounter);
        if (unsignedSystemValue8 == 8) {
          systemFlag = strcmp(ThreadLocalStorage,&SystemResourceTemplateDenary);
          isSystemResourceMatch = systemFlag == 0;
        }
        else {
          isSystemResourceMatch = false;
        }
        if (isSystemResourceMatch) {

/**
 * @brief 更新系统渲染管理器
 * 
 * 该函数负责更新系统渲染管理器的状态和参数。
 * 根据系统资源的信息更新渲染管理器的配置。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void UpdateSystemRenderManager(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  uint32_t creationFlags;
  int MemoryComparisonResult;
  bool isTextureUpdateRequired;
  void* currentThreadId;
  bool isSystemInitialized;
  
  pointerToInteger1 = (int *)(ResourceManagerPointer + 0x3d0);
  if (((int)*(float *)(SystemRenderManagerPointer + 0x17ec) == *(int *)(ResourceManagerPointer + 0x3cc)) &&
     ((int)*(float *)(SystemRenderManagerPointer + 0x17f0) == *pointerToInteger1)) {
    isTextureUpdateRequired = false;
  }
  else {
    isTextureUpdateRequired = true;
    UpdateRenderManagerSystem(SystemRenderManagerPointer,*(int *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1);
  }
  if (*(int *)(*(long long *)(ResourceManagerPointer + 8) + 0x38) == 2) {
    if ((*(char *)(ResourceManagerPointer + 0x3d4) != '\0') || (*(char *)(ResourceManagerPointer + 0x3d5) != '\0')) {
      creationFlags = *(uint32_t *)(SystemNodeManagerPointer + 0x1ea0);
      ProcessNodeManagerOperation(SystemNodeManagerPointer,0);
      ProcessSystemResourceData(*(void* *)(ResourceManagerPointer + 8),*(uint32_t *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1,
                    *(uint8_t *)(ResourceManagerPointer + 0x3d5));
      UpdateTextureManagerSystem(SystemTextureManagerPointer,*(uint32_t *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1,1);
      ProcessNodeManagerOperation(SystemNodeManagerPointer,creationFlags);
      ProcessSystemResourceData(*(void* *)(ResourceManagerPointer + 8),*(uint32_t *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1,
                    *(uint8_t *)(ResourceManagerPointer + 0x3d5));
      isSystemInitialized = true;
      goto ErrorHandler;
    }
  }
  else {
    if (*(char *)(ResourceManagerPointer + 0x3d4) != '\0') {
      systemCounter = *(int *)(SystemNodeManagerPointer + 0x1ea0);
      if ((*(char *)(ResourceManagerPointer + 0x3d5) != '\0') || (isTextureUpdateRequired)) {
        currentThreadId = 1;
      }
      else {
        currentThreadId = 0;
      }
      ProcessSystemResourceData(*(long long *)(ResourceManagerPointer + 8),*(uint32_t *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1,currentThreadId);
      isSystemInitialized = systemCounter == 2;
      goto ErrorHandler;
    }
    if (!isTextureUpdateRequired) {
      return;
    }
  }
  isSystemInitialized = false;
ErrorHandler:
  UpdateTextureManagerSystem(SystemTextureManagerPointer,*(uint32_t *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1,isSystemInitialized);
  if (!isTextureUpdateRequired) {
    return;
  }
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemResourceTemplateUndenary,*(uint32_t *)(ResourceManagerPointer + 0x3cc),*pointerToInteger1);
}




/**
 * @brief 获取系统资源状态
 * 
 * 该函数负责获取当前系统资源的状态信息。
 * 返回系统资源的当前状态值，用于监控系统运行情况。
 * 
 * @return 系统资源状态值
 */
uint32_t GetSystemResourceStatus(void)

{
  uint8_t asystemStatus [16];
  long long localSystemHandle;
  long long localResourceOffset;
  void* *punsignedSystemValue4;
  uint currentThreadId;
  int systemFlag;
  void* *pointerUnsignedC8;
  long long bufferOffset;
  uint stringBufferPosition;
  ulong long stringBufferCapacity;
  void* *stringBufferPointer;
  long long stringBufferOffset;
  uint stringBufferIndex;
  void* StackParameterC;
  void* systemSemaphore;
  uint8_t systemDataBuffer [32];
  uint8_t threadLocalStorageBuffer [40];
  
  localResourceOffset = SystemStatusFlagsPointer;
  systemSemaphore = 0xfffffffffffffffe;
  asystemStatus = *(uint8_t (*) [16])
            (*(long long *)(SystemStatusFlagsPointer + 8) + 0xcc +
            (ulong long)(*(uint *)(*(long long *)(SystemStatusFlagsPointer + 8) + 0x13c) & 1) * 0x48);
  if ((asystemStatus._12_4_ != 0) && (asystemStatus._8_4_ != 0)) {
    pointerUnsignedC8 = &SystemGlobalDataReference;
    UnsignedStackFlagB0 = 0;
    lStack_c0 = 0;
    UnsignedStackFlagB8 = 0;
    ProcessSystemData(&pointerUnsignedC8,asystemStatus._0_4_);
    currentThreadId = UnsignedStackFlagB8 + 1;
    ExecuteSystemCommand(&pointerUnsignedC8,currentThreadId);
    *(void*2 *)((ulong long)UnsignedStackFlagB8 + lStack_c0) = 0x2c;
    UnsignedStackFlagB8 = currentThreadId;
    ProcessSystemData(&pointerUnsignedC8,asystemStatus._0_8_ >> 0x20);
    currentThreadId = UnsignedStackFlagB8 + 1;
    ExecuteSystemCommand(&pointerUnsignedC8,currentThreadId);
    *(void*2 *)((ulong long)UnsignedStackFlagB8 + lStack_c0) = 0x2c;
    UnsignedStackFlagB8 = currentThreadId;
    ProcessSystemData(&pointerUnsignedC8,asystemStatus._8_8_ & 0xffffffff);
    systemFlag = UnsignedStackFlagB8 + 1;
    ExecuteSystemCommand(&pointerUnsignedC8,systemFlag);
    *(void*2 *)((ulong long)UnsignedStackFlagB8 + lStack_c0) = 0x2c;
    UnsignedStackFlagB8 = systemFlag;
    ProcessSystemData(&pointerUnsignedC8,asystemStatus._8_8_ >> 0x20);
    punsignedSystemValue4 = (void* *)CreateSystemObject(aUnsignedStackFlag80,&pointerUnsignedC8);
    ProcessMemoryManagerOperation(SystemMemoryManagerPointer + 0xe30,punsignedSystemValue4);
    *punsignedSystemValue4 = &SystemGlobalDataReference;
    if (punsignedSystemValue4[1] != 0) {
        SystemCleanupFunction();
    }
    punsignedSystemValue4[1] = 0;
    *(uint32_t *)(punsignedSystemValue4 + 3) = 0;
    *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
    pointerUnsignedC8 = &SystemGlobalDataReference;
    if (lStack_c0 != 0) {
        SystemCleanupFunction();
    }
    lStack_c0 = 0;
    UnsignedStackFlagB0 = UnsignedStackFlagB0 & 0xffffffff00000000;
    pointerUnsignedC8 = &SystemMemoryAllocatorReference;
  }
  localSystemHandle = *(long long *)(localResourceOffset + 8);
  asystemStatus = *(uint8_t (*) [16])(localSystemHandle + 0xdc + (ulong long)(*(uint *)(localSystemHandle + 0x13c) & 1) * 0x48);
  if ((asystemStatus._12_4_ != 0) && (asystemStatus._8_4_ != 0)) {
    pUnsignedStackFlagA8 = &SystemGlobalDataReference;
    SystemConfigurationValue = 0;
    lStack_a0 = 0;
    systemConfigurationValue = 0;
    ProcessSystemData(&pUnsignedStackFlagA8,asystemStatus._0_4_);
    currentThreadId = unsignedValue98 + 1;
    ExecuteSystemCommand(&pUnsignedStackFlagA8,currentThreadId);
    *(void*2 *)((ulong long)unsignedValue98 + lStack_a0) = 0x2c;
    unsignedValue98 = currentThreadId;
    ProcessSystemData(&pUnsignedStackFlagA8,asystemStatus._0_8_ >> 0x20);
    currentThreadId = unsignedValue98 + 1;
    ExecuteSystemCommand(&pUnsignedStackFlagA8,currentThreadId);
    *(void*2 *)((ulong long)unsignedValue98 + lStack_a0) = 0x2c;
    unsignedValue98 = currentThreadId;
    ProcessSystemData(&pUnsignedStackFlagA8,asystemStatus._8_8_ & 0xffffffff);
    systemFlag = unsignedValue98 + 1;
    ExecuteSystemCommand(&pUnsignedStackFlagA8,systemFlag);
    *(void*2 *)((ulong long)unsignedValue98 + lStack_a0) = 0x2c;
    unsignedValue98 = systemFlag;
    ProcessSystemData(&pUnsignedStackFlagA8,asystemStatus._8_8_ >> 0x20);
    punsignedSystemValue4 = (void* *)CreateSystemObject(StackBuffer60,&pUnsignedStackFlagA8);
    ProcessMemoryManagerOperation(SystemMemoryManagerPointer + 0xef0,punsignedSystemValue4);
    *punsignedSystemValue4 = &SystemGlobalDataReference;
    if (punsignedSystemValue4[1] != 0) {
        SystemCleanupFunction();
    }
    punsignedSystemValue4[1] = 0;
    *(uint32_t *)(punsignedSystemValue4 + 3) = 0;
    *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
    pUnsignedStackFlagA8 = &SystemGlobalDataReference;
    if (lStack_a0 != 0) {
        SystemCleanupFunction();
    }
  }
  return *(uint32_t *)(*(long long *)(localResourceOffset + 8) + 0x13c);
}



00018004ed08)
00018004ed22)
00018004ed36)
00018004ed44)
00018004ed48)
00018004ed5b)
00018004ed5f)
00018004ed72)
00018004ed76)
00018004ed89)
00018004ed8d)
00018004edbc)
00018004edc0)
00018004edd3)
00018004ee38)
00018004ee52)
00018004ee66)
00018004ee74)
00018004ee78)
00018004ee8b)
00018004ee8f)
00018004eea2)
00018004eea6)
00018004eeb6)
00018004eeba)
00018004eeec)
00018004eef0)
00018004ef03)
00018004ebd5)
00018004ebef)
00018004ec03)
00018004ec11)
00018004ec15)
00018004ec28)
00018004ec2c)
00018004ec3f)
00018004ec43)
00018004ec56)
00018004ec5a)
00018004ec88)
00018004ec90)
00018004eca3)


// 函数: void SystemResourceInitializer(void* ResourceManagerPointer,void* parameter2,void* parameter3,void* parameter4)
/**
 * @brief 系统资源初始化器
 * 
 * 该函数负责初始化系统资源，包括内存分配、缓冲区设置和系统参数配置。
 * 这是系统启动过程中的核心初始化函数。
 * 
 * @param resourceManagerPointer 系统资源指针
 * @param memoryAllocationFlags 内存分配标志
 * @param systemConfiguration 系统配置
 * @param threadParameters 线程参数
 */
void SystemResourceInitializer(void* resourceManagerPointer,void* memoryAllocationFlags,void* systemConfiguration,void* threadParameters)

{
  uint systemStatus;
  uint creationFlags;
  long long localResourceOffset;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  void* *pEncryptionValue68;
  long long LocalMemoryBuffer;
  uint processFlags58;
  void* unsignedValue50;
  
  localResourceOffset = SystemMemoryManagerPointer;
  pEncryptionValue68 = &SystemGlobalDataReference;
  unsignedValue50 = 0;
  LocalMemoryBuffer = 0;
  processFlags58 = 0;
  if (*(int *)(SystemNodeManagerPointer + 0x1ea0) == 0) {
    systemStatus = *(uint *)(SystemMemoryManagerPointer + 0xe40);
    currentThreadId = (ulong long)systemStatus;
    if (*(long long *)(SystemMemoryManagerPointer + 0xe38) != 0) {
      ExecuteSystemCommand(&pEncryptionValue68,currentThreadId,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    }
    if (systemStatus != 0) {
        memcpy(lStack_60,*(void* *)(localResourceOffset + 0xe38),currentThreadId);
    }
    if (lStack_60 != 0) {
      *(uint8_t *)(currentThreadId + lStack_60) = 0;
    }
    unsignedValue50 = CONCAT44(*(uint32_t *)(localResourceOffset + 0xe4c),(uint32_t)unsignedValue50);
  }
  localResourceOffset = SystemMemoryManagerPointer;
  processFlags58 = 0;
  systemStatus = *(uint *)(SystemMemoryManagerPointer + 0xf00);
  currentThreadId = (ulong long)systemStatus;
  if (*(long long *)(SystemMemoryManagerPointer + 0xef8) != 0) {
    ExecuteSystemCommand(&pEncryptionValue68,currentThreadId);
  }
  if (systemStatus != 0) {
      memcpy(lStack_60,*(void* *)(localResourceOffset + 0xef8),currentThreadId);
  }
  if (lStack_60 != 0) {
    *(uint8_t *)(currentThreadId + lStack_60) = 0;
  }
  bufferBaseAddress = SystemMemoryManagerPointer;
  unsignedValue50 = CONCAT44(*(uint32_t *)(localResourceOffset + 0xf0c),(uint32_t)unsignedValue50);
  creationFlags = *(uint *)(SystemMemoryManagerPointer + 0xfc0);
  currentThreadId = (ulong long)creationFlags;
  processFlags58 = systemStatus;
  if (*(long long *)(SystemMemoryManagerPointer + 0xfb8) != 0) {
    ExecuteSystemCommand(&pEncryptionValue68,currentThreadId);
  }
  if (creationFlags != 0) {
      memcpy(lStack_60,*(void* *)(bufferBaseAddress + 0xfb8),currentThreadId);
  }
  if (lStack_60 != 0) {
    *(uint8_t *)(currentThreadId + lStack_60) = 0;
  }
  unsignedValue50 = CONCAT44(*(uint32_t *)(bufferBaseAddress + 0xfcc),(uint32_t)unsignedValue50);
  pEncryptionValue68 = &SystemGlobalDataReference;
  if (lStack_60 != 0) {
    processFlags58 = creationFlags;
      SystemCleanupFunction();
  }
  return;
}





/**
 * 系统清理器 - 执行系统清理操作
 * 负责在系统关闭时清理内存和资源
 * 
 */
void SystemCleanupHandler(void)

{
  int systemStatus;
  long long localSystemHandle;
  long long localResourceOffset;
  long long bufferBaseAddress;
  int *pointerToInteger5;
  void** SystemRootNode;
  uint32_t *HashBucketNode;
  void* *newThreadLocalStorage;
  char systemAvailabilityFlag;
  float FloatScaleFactor;
  uint32_t systemStatus1;
  float FloatRatioValue;
  uint8_t aunsignedValue208 [32];
  long long lStack_1e8;
  long long lStack_1d8;
  long long longValue1d0;
  void* *apStackValue1c8 [10];
  void* systemFlag178;
  uint8_t StackBuffer170 [8];
  void* *puStack_168;
  uint8_t *puStack_160;
  uint32_t uStack_158;
  uint8_t auStack_150 [264];
  ulong long EncryptionValue48;
  
  localResourceOffset = SystemStatusFlagsPointer;
  systemFlag178 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue208;
  if (*(void* **)*SystemMemoryBlockStorage == &SystemMemoryBlockTemplatePrimary) {
    systemAvailabilityFlag = *(int *)(SystemStatusFlags + 0xe0) != 0;
  }
  else {
    systemAvailabilityFlag = (**(code **)(*(void* **)*SystemMemoryBlockStorage + 0x48))();
  }
  if (systemAvailabilityFlag == '\0') {
    SystemRandomSeed = timeGetTime();
  }
  else {
    SystemRandomSeed = 0xb061;
  }
  localSystemHandle = SystemNodeManagerPointer;
  SystemRandomSeed = SystemRandomSeed ^ 0x41c64e6d;
  if ((*(long long *)(SystemMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemNodeManagerPointer + 0x540) < 1)) {
    if (*(int *)(SystemNodeManagerPointer + 0x2140) == 0) {
      FloatScaleFactor = *(float *)(SystemNodeManagerPointer + 0x20d0);
    }
    else {
      FloatScaleFactor = 100.0;
    }
    FloatScaleFactor = FloatScaleFactor * 0.01;
  }
  else {
    FloatScaleFactor = 1.0;
  }
  *(float *)(localResourceOffset + 0x234) = FloatScaleFactor;
  *(uint32_t *)(localResourceOffset + 0x238) = 0x3f800000;
  FloatRatioValue = 1.0;
  if (*(int *)(localSystemHandle + 0x1ea0) == 1) {
    systemStatus = *(int *)(localSystemHandle + 0x1d50);
    pointerToInteger5 = (int *)GetResourceManagerPointer(*(void* *)(SystemStatusFlagsPointer + 8),StackBuffer170);
    FloatRatioValue = (float)systemStatus / (float)*pointerToInteger5;
    FloatScaleFactor = FloatRatioValue * *(float *)(localResourceOffset + 0x234);
    FloatRatioValue = FloatRatioValue * *(float *)(localResourceOffset + 0x238);
  }
  if (0.2 <= FloatScaleFactor) {
    if (1.0 <= FloatScaleFactor) {
      FloatScaleFactor = 1.0;
    }
  }
  else {
    FloatScaleFactor = 0.2;
  }
  *(float *)(localResourceOffset + 0x234) = FloatScaleFactor;
  FloatScaleFactor = 0.2;
  if ((0.2 <= FloatRatioValue) && (FloatScaleFactor = FloatRatioValue, 1.0 <= FloatRatioValue)) {
    FloatScaleFactor = 1.0;
  }
  *(float *)(localResourceOffset + 0x238) = FloatScaleFactor;
  *(uint8_t *)(localResourceOffset + 0x22d) = 0;
  systemStatus1 = log2f();
  *(uint32_t *)(localResourceOffset + 0x230) = systemStatus1;
  systemStatus1 = log2f();
  *(uint32_t *)(localResourceOffset + 0x240) = systemStatus1;
  systemStatus1 = log2f();
  *(uint32_t *)(localResourceOffset + 0x244) = systemStatus1;
  systemStatus1 = log2f();
  *(uint32_t *)(localResourceOffset + 0x248) = systemStatus1;
  systemStatus1 = log2f();
  *(uint32_t *)(localResourceOffset + 0x24c) = systemStatus1;
  systemStatus1 = log2f(*(float *)(SystemNodeManagerPointer + 0x2220) * 0.01);
  *(uint32_t *)(localResourceOffset + 0x23c) = systemStatus1;
  *(void* *)(localResourceOffset + 0x254) = 0x3f8000003f800000;
  lStack_1d8 = 0x3f8000003f800000;
  *(void* *)(localResourceOffset + 0x25c) = 0x3f8000003f800000;
  bufferBaseAddress = SystemMemoryContext;
  localSystemHandle = SystemAllocationFlagsTemplate;
  puStack_168 = &SystemResourceTemplateSecondary;
  puStack_160 = auStack_150;
  auStack_150[0] = 0;
  uStack_158 = 0xd;
  strcpy_s(auStack_150,0x10,&SystemVersionString);
  resourceEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  lStack_1e8 = localSystemHandle + 0x70;
  apStackValue1c8[0] = resourceEntryPointer;
  InitializeSystemMemoryContext(resourceEntryPointer,&puStack_168,3,localSystemHandle + 0x2e0);
  *resourceEntryPointer = &SystemValueReference;
  apStackValue1c8[0] = resourceEntryPointer;
  SetupSystemMemoryAllocator(resourceEntryPointer);
  InitializeSystemHandle(localSystemHandle + 0x48,apStackValue1c8);
  *(void* **)(bufferBaseAddress + 0x18) = resourceEntryPointer;
  puStack_168 = &SystemMemoryAllocatorReference;
  newThreadLocalStorage = &SystemStringTemplate;
  if (*(void* **)(localResourceOffset + 0x278) != (void* *)0x0) {
    newThreadLocalStorage = *(void* **)(localResourceOffset + 0x278);
  }
  (**(code **)(*(long long *)(SystemInputManagerPointer + 0x560) + 0x10))
            ((long long *)(SystemInputManagerPointer + 0x560),newThreadLocalStorage);
  localResourceOffset = SystemResourceContext;
  lStack_1d8 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,3);
  *(void* *)(lStack_1d8 + 0x28) = 3;
  *(uint32_t *)(lStack_1d8 + 0x19) = 0;
  *(void*2 *)(lStack_1d8 + 0x1d) = 0;
  *(uint8_t *)(lStack_1d8 + 0x1f) = 0;
  *(long long *)lStack_1d8 = lStack_1d8;
  *(long long *)(lStack_1d8 + 8) = lStack_1d8;
  *(void* *)(lStack_1d8 + 0x10) = 0;
  *(uint8_t *)(lStack_1d8 + 0x18) = 0;
  *(void* *)(lStack_1d8 + 0x20) = 0;
  *(long long *)(localResourceOffset + 0xa8) = lStack_1d8;
  longValue1d0 = lStack_1d8;
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable1,&SystemCallbackTable1,SystemCallbackHandler1);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable2,&SystemCallbackDataTable2Param,SystemCallbackHandler2);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable3,&SystemCallbackTable3,SystemCallbackHandler3);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable4,&SystemCallbackTable4,SystemCallbackHandler4);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackTable5,&SystemCallbackTable5Data,SystemCallbackHandler5);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable6,&SystemCallbackDataTable6Param,SystemCallbackHandler6);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable7,&SystemCallbackTable7Data,SystemCallbackHandler7);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackTable8,&SystemCallbackTable8Data,SystemCallbackHandler8);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackTable9,&SystemCallbackTable9Data,SystemCallbackHandler9);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemEventCallbackDataTable,&SystemEventCallbackTableData,SystemEventCallbackHandler);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemNetworkCallbackDataTable,&SystemNetworkCallbackTableData,SystemNetworkCallbackHandler);
  HashBucketNode = (uint32_t *)CreateSystemNodePointer(localResourceOffset + 0xe0,&SystemEventCallbackDataTable);
  *HashBucketNode = 1;
  HashBucketNode = (uint32_t *)CreateSystemNodePointer(localResourceOffset + 0xe0,&SystemCallbackDataTable3);
  *HashBucketNode = 1;
  longValue1d0 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x3878,8,3);
    memset(longValue1d0,0,0x3878);
}




// 函数: void SystemMemoryManager(long long ResourceManagerPointer)
/**
 * @brief 系统内存管理器
 * 
 * 该函数负责管理系统内存资源，包括内存分配、释放和优化。
 * 这是内存管理系统的核心函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemMemoryManager(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemMemoryCleanup(long long ResourceManagerPointer)
/**
 * @brief 系统内存清理器
 * 
 * 该函数负责清理系统内存资源，释放不再使用的内存块。
 * 这是内存管理系统的清理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemMemoryCleanup(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}





/**
 * @brief 系统数据初始化器
 * 
 * 负责初始化系统的基础数据结构和配置信息。
 * 该函数在系统启动早期阶段被调用。
 */
void SystemDataInitializer(void)

{
  void* *pointerToUnsigned1;
  char *stringProcessingPointer;
  void* allocationContext;
  long long bufferBaseAddress;
  char operationStatusFlag;
  int systemFlag;
  uint32_t unsignedSystemValue7;
  long long localMemoryAddress;
  long long *presourceCounter;
  uint32_t *pointerToUnsigned10;
  uint8_t aUnsignedStackFlagA8 [32];
  long long *plStack_88;
  long long **pplStack_80;
  void* *pUnsignedStackFlag78;
  uint32_t *pprocessFlags70;
  uint32_t EncryptionValue68;
  void* unsignedValue60;
  void* processFlags58;
  void* *memoryAllocationEnd;
  uint8_t *pEncryptionValue48;
  uint32_t unsignedValue40;
  uint8_t arrayUnsigned38 [16];
  ulong long EncryptionKeyValue;
  
  bufferBaseAddress = SystemStatusFlagsPointer;
  processFlags58 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aUnsignedStackFlagA8;
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  do {
    allocationContext = SystemAllocationFlagsTemplate;
    localMemoryAddress = AllocateSystemMemory(SystemAllocationFlagsTemplate);
    if (localMemoryAddress == 0) break;
    presourceCounter = (long long *)AllocateResourceManagerPointer(allocationContext);
    operationStatusFlag = (**(code **)(*presourceCounter + 0x20))(presourceCounter,1);
  } while (operationStatusFlag != '\0');
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  pointerToUnsigned1 = SystemResourceManagerPointer;
  if (*(char *)(SystemResourceManagerPointer + 7) != '\0') {
    plStack_88 = (long long *)0x180c91970;
    systemFlag = _Mtx_lock(0x180c91970);
    if (systemFlag != 0) {
      __Throw_C_error_std__YAXH_Z(systemFlag);
    }
    ReleaseSystemResource(*(void* *)*pointerToUnsigned1);
    ReleaseSystemResource(*(void* *)pointerToUnsigned1[1]);
    ReleaseSystemResourceHandle(*pointerToUnsigned1);
    ReleaseSystemResourceHandle(pointerToUnsigned1[1]);
    *(uint8_t *)(pointerToUnsigned1 + 7) = 0;
    systemFlag = _Mtx_unlock(0x180c91970);
    if (systemFlag != 0) {
      __Throw_C_error_std__YAXH_Z(systemFlag);
    }
  }
  pointerToUnsigned1 = (void* *)*SystemGlobalPointerTable;
  if (pointerToUnsigned1 != (void* *)0x0) {
    *SystemGlobalPointerTable = 0;
    (**(code **)*pointerToUnsigned1)(pointerToUnsigned1,1);
  }
  presourceCounter = SystemModuleContextPointer;
  allocationContext = SystemAllocationFlagsTemplate;
  plStack_88 = SystemModuleContextPointer;
  if (SystemModuleContextPointer != (long long *)0x0) {
    InitializeSystemModule(*SystemModuleContextPointer);
    *presourceCounter = 0;
    plStack_88 = presourceCounter + 1;
    CleanupSystemMemoryAllocation();
      SystemCleanupFunction(presourceCounter);
  }
  SystemCleanupStatusFlag = (long long *)0x0;
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    pplStack_80 = &plStack_88;
    plStack_88 = SystemGlobalControllerPointer;
    (**(code **)(*SystemGlobalControllerPointer + 0x28))();
    InitializeSystemMemoryContext(allocationContext,&plStack_88,0);
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (*(long long **)(bufferBaseAddress + 0x2b0) != (long long *)0x0) {
    (**(code **)(**(long long **)(bufferBaseAddress + 0x2b0) + 0x20))();
  }
  stringProcessingPointer = *(char **)(SystemMemoryBlockStorage + 0x10);
  if (*stringProcessingPointer != '\0') {
    WSACleanup();
    *pvalidationStatusFlag = '\0';
  }
  allocationContext = SystemAllocationFlagsTemplate;
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    pplStack_80 = &plStack_88;
    plStack_88 = SystemGlobalControllerPointer;
    (**(code **)(*SystemGlobalControllerPointer + 0x28))();
    InitializeSystemMemoryContext(allocationContext,&plStack_88,0);
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  allocationContext = SystemAllocationFlagsTemplate;
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    pplStack_80 = &plStack_88;
    plStack_88 = SystemGlobalControllerPointer;
    (**(code **)(*SystemGlobalControllerPointer + 0x28))();
    InitializeSystemMemoryContext(allocationContext,&plStack_88,0);
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  memoryAllocationEnd = &SystemResourceTemplateSecondary;
  pEncryptionValue48 = arrayUnsigned38;
  arrayUnsigned38[0] = 0;
  unsignedValue40 = 3;
  strcpy_s(arrayUnsigned38,0x10,&SystemVersionString2);
  pUnsignedStackFlag78 = &SystemGlobalDataReference;
  unsignedValue60 = 0;
  pprocessFlags70 = (uint32_t *)0x0;
  EncryptionValue68 = 0;
  pointerToUnsigned10 = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x14,0x13);
  *(uint8_t *)pointerToUnsigned10 = 0;
  pprocessFlags70 = pointerToUnsigned10;
  unsignedSystemValue7 = StartSystemThread(pointerToUnsigned10);
  *pointerToUnsigned10 = 0x706d6554;
  pointerToUnsigned10[1] = 0x7261726f;
  pointerToUnsigned10[2] = 0x73655279;
  pointerToUnsigned10[3] = 0x6372756f;
  pointerToUnsigned10[4] = 0x2f7365;
  EncryptionValue68 = 0x13;
  unsignedValue60._0_4_ = unsignedSystemValue7;
  InitializeSystemStack(&pUnsignedStackFlag78,&memoryAllocationEnd);
  pUnsignedStackFlag78 = &SystemGlobalDataReference;
  if (pprocessFlags70 != (uint32_t *)0x0) {
      SystemCleanupFunction();
  }
  pprocessFlags70 = (uint32_t *)0x0;
  unsignedValue60 = (ulong long)unsignedValue60._4_4_ << 0x20;
  pUnsignedStackFlag78 = &SystemMemoryAllocatorReference;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
    UpdateContextManagerSystem(SystemContextManagerPointer,&ContextManagerConfigurationData);
}





// 函数: void InitializeSystemCore(void)
/**
 * @brief 初始化系统数据结构
 * 
 * 该函数负责初始化系统的核心数据结构，包括数据表、指针数组等。
 * 它会检查系统状态，设置初始化标志，并准备系统运行所需的基础数据结构。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据结构的正确初始化
 */
void InitializeSystemDataStructures(void)

{
  long long *systemDataPointer;
  void** SystemDataTable;
  code *systemCodePointer;
  uint8_t *systemBytePointer;
  void* systemHandle;
  long long systemMemoryBase;
  int systemStatusFlag;
  long long systemCounter;
  long long **systemDoublePointer;
  void*2 *systemTypedPointer;
  uint systemIndex;
  ulong long systemTimestamp;
  float systemFloatValue;
  double systemDoubleValue1;
  double systemDoubleValue2;
  long long **stackDoublePointerX8;
  long long *stackPointerX10;
  long long *stackPointerX18;
  long long stackValueX20;
  long long stackValue90;
  long long stackValue88;
  long long stackValue80;
  long long stackValue78;
  long long ***stackTriplePointer70;
  void* stackHandle68;
  long long **stackDoublePointer60;
  void* stackHandle58;
  ulong long loopCounter;
  
  systemCounter = SystemRuntimeCounter;
  systemMemoryBase = SystemStatusFlagsPointer;
  if (SystemInitializationFlag != '\0') {
    ResetSystemMemoryManager();
    return;
  }
  stackHandle68 = 0xfffffffffffffffe;
  *(void* *)(SystemRuntimeCounter + 0x2038) = *(void* *)(SystemRuntimeCounter + 0x2030);
  systemTypedPointer = (void*2 *)(systemCounter + 0x14);
  systemCounter = 0x100;
  loopCounter = 0;
  do {
    *systemTypedPointer = 0;
    systemTypedPointer = systemTypedPointer + 0xc;
    systemCounter = systemCounter + -1;
  } while (systemCounter != 0);
  ReleaseGraphicsContext(SystemGraphicsContextPointer + 0x48);
  SystemPerformanceCounter1 = 0;
  SystemPerformanceCounter2 = 0;
  if (SystemDebugFlag != '\0') {
    PrimaryResourcePointer = *(long long **)(localSystemFlags + 8);
    ppresourceCounter = (long long **)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x48,8,3);
    *ppresourceCounter = (long long *)&SystemMemoryTemplateA;
    *ppresourceCounter = (long long *)&SystemMemoryTemplateB;
    *(uint32_t *)(ppresourceCounter + 1) = 0;
    *ppresourceCounter = (long long *)&SystemMemoryTemplateC;
    LOCK();
    *(uint8_t *)(ppresourceCounter + 2) = 0;
    UNLOCK();
    ppresourceCounter[3] = (long long *)0xffffffffffffffff;
    *ppresourceCounter = (long long *)&MemoryAllocationPool;
    *(uint32_t *)(ppresourceCounter + 5) = 4;
    ppresourceCounter[4] = PrimaryResourcePointer;
    ppplStack_70 = (long long ***)ppresourceCounter;
    pplStack_60 = ppresourceCounter;
    (*(code *)(*ppresourceCounter)[5])(ppresourceCounter);
    HashEntryStatus = (void* *)PrimaryResourcePointer[0x28];
    pathStringPointer = *(code **)*HashEntryStatus;
    ppplStack_70 = &pplStackX_8;
    pplStackX_8 = ppresourceCounter;
    (*(code *)(*ppresourceCounter)[5])(ppresourceCounter);
    (*pathStringPointer)(HashEntryStatus,&pplStackX_8);
    ProcessSystemCallback(PrimaryResourcePointer[0x28]);
    (*(code *)(*ppresourceCounter)[7])(ppresourceCounter);
  }
  localMemoryAddress = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
  systemStatus3 = systemStatus2;
  if (localMemoryAddress / 0x1c != 0) {
    do {
      ProcessSystemMemory(localMemoryAddress,systemStatus3 * 0x1c + *(long long *)(SystemRenderManagerPointer + 0x10));
      systemStatus1 = (int)systemStatus2 + 1;
      systemStatus2 = (ulong long)systemStatus1;
      localMemoryAddress = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
      systemStatus3 = (long long)(int)systemStatus1;
    } while ((ulong long)(long long)(int)systemStatus1 < (ulong long)(localMemoryAddress / 0x1c));
  }
  *(void* *)(SystemRenderManagerPointer + 0x18) = *(void* *)(SystemRenderManagerPointer + 0x10);
  *(uint8_t *)(*(long long *)(*(long long *)(localSystemFlags + 8) + 0x140) + 0x208) = 1;
  if (*(char *)(localSystemFlags + 0x3c8) != '\0') {
    UpdateSystemRenderManager(localSystemFlags);
    LOCK();
    *(uint8_t *)(localSystemFlags + 0x3c8) = 0;
    UNLOCK();
  }
  localMemoryAddress = SystemMemoryManagerPointer;
  *(void* *)(SystemMemoryManagerPointer + 4) = 0;
  *(void* *)(localMemoryAddress + 0xc) = 0;
  *(void* *)(localMemoryAddress + 0x14) = 0;
  InitializeMemoryBlock(localMemoryAddress + 0x20);
  InitializeMemoryBlock(localMemoryAddress + 0x50);
  LOCK();
  *(uint32_t *)(localMemoryAddress + 0x80) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(localMemoryAddress + 0x84) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(localMemoryAddress + 0x88) = 0;
  UNLOCK();
  localMemoryAddress = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&lStackX_20);
    localMemoryAddress = lStackX_20;
  }
  *(double *)(localSystemFlags + 0x68) = (double)(localMemoryAddress - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
  if (SystemMemoryFlag != '\0') {
    processFlags58 = 0x180c91288;
    systemOffset = _Mtx_lock(0x180c91288);
    if (systemOffset != 0) {
      __Throw_C_error_std__YAXH_Z(systemOffset);
    }

/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统资源分配器，设置内存分配模板和资源指针。
 * 函数会初始化系统数据表，设置图形上下文，并配置资源分配相关的参数。
 * 
 * @param systemResourcePointer 系统资源指针，用于访问和配置系统资源
 * 
 * @note 这是系统资源管理的重要组成部分，确保资源的正确分配和初始化
 */
void InitializeSystemResourceAllocator(long long systemResourcePointer)

{
  long long *primaryResourcePointer;
  void** SystemDataTable;
  code *programCounter;
  uint8_t *systemDataPointer;
  void* systemValuePointer;
  int systemStatus;
  long long localDataIndex;
  long long **memoryAllocationPointer;
  void*2 *systemTypedPointer;
  uint systemValue10;
  ulong long systemValue12;
  float floatValue;
  double doubleValue1;
  double doubleValue2;
  long long **stackPointer8;
  long long *stackPointer10;
  long long *stackPointer18;
  long long stackValue20;
  long long stackValue90;
  long long stackValue88;
  long long stackValue80;
  long long stackValue78;
  long long ***stackPointer70;
  void* stackValue68;
  long long **stackPointer60;
  void* stackValue58;
  ulong long loopCounter;
  
  localDataIndex = SystemRuntimeCounter;
  stackValue68 = 0xfffffffffffffffe;
  *(void* *)(SystemRuntimeCounter + 0x2038) = *(void* *)(SystemRuntimeCounter + 0x2030);
  systemTypedPointer = (void*2 *)(localDataIndex + 0x14);
  localDataIndex = 0x100;
  loopCounter = 0;
  do {
    *systemTypedPointer = 0;
    systemTypedPointer = systemTypedPointer + 0xc;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  ReleaseGraphicsContext(SystemGraphicsContextPointer + 0x48);
  SystemPerformanceCounter1 = 0;
  SystemPerformanceCounter2 = 0;
  if (SystemDebugFlag != '\0') {
    primaryResourcePointer = *(long long **)(systemResourcePointer + 8);
    memoryAllocationPointer = (long long **)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x48,8,3);
    *memoryAllocationPointer = (long long *)&SystemMemoryTemplateA;
    *memoryAllocationPointer = (long long *)&SystemMemoryTemplateB;
    *(uint32_t *)(memoryAllocationPointer + 1) = 0;
    *memoryAllocationPointer = (long long *)&SystemMemoryTemplateC;
    LOCK();
    *(uint8_t *)(memoryAllocationPointer + 2) = 0;
    UNLOCK();
    memoryAllocationPointer[3] = (long long *)0xffffffffffffffff;
    *memoryAllocationPointer = (long long *)&MemoryAllocationPool;
    *(uint32_t *)(memoryAllocationPointer + 5) = 4;
    memoryAllocationPointer[4] = primaryResourcePointer;
    stackPointer70 = (long long ***)memoryAllocationPointer;
    stackPointer60 = memoryAllocationPointer;
    (*(code *)(*memoryAllocationPointer)[5])(memoryAllocationPointer);
    HashEntryStatus = (void* *)primaryResourcePointer[0x28];
    programCounter = *(code **)*HashEntryStatus;
    stackPointer70 = &stackPointer8;
    stackPointer8 = memoryAllocationPointer;
    (*(code *)(*memoryAllocationPointer)[5])(memoryAllocationPointer);
    (*programCounter)(HashEntryStatus,&stackPointer8);
    ProcessSystemCallback(primaryResourcePointer[0x28]);
    (*(code *)(*memoryAllocationPointer)[7])(memoryAllocationPointer);
  }
  localDataIndex = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
  systemValue12 = loopCounter;
  if (localDataIndex / 0x1c != 0) {
    do {
      ProcessSystemMemory(localDataIndex,systemValue12 * 0x1c + *(long long *)(SystemRenderManagerPointer + 0x10));
      systemValue10 = (int)loopCounter + 1;
      loopCounter = (ulong long)systemValue10;
      localDataIndex = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
      systemValue12 = (long long)(int)systemValue10;
    } while ((ulong long)(long long)(int)systemValue10 < (ulong long)(localDataIndex / 0x1c));
  }
  *(void* *)(SystemRenderManagerPointer + 0x18) = *(void* *)(SystemRenderManagerPointer + 0x10);
  *(uint8_t *)(*(long long *)(*(long long *)(systemResourcePointer + 8) + 0x140) + 0x208) = 1;
  if (*(char *)(systemResourcePointer + 0x3c8) != '\0') {
    UpdateSystemRenderManager(systemResourcePointer);
    LOCK();
    *(uint8_t *)(systemResourcePointer + 0x3c8) = 0;
    UNLOCK();
  }
  localDataIndex = SystemMemoryManagerPointer;
  *(void* *)(SystemMemoryManagerPointer + 4) = 0;
  *(void* *)(localDataIndex + 0xc) = 0;
  *(void* *)(localDataIndex + 0x14) = 0;
  InitializeMemoryBlock(localDataIndex + 0x20);
  InitializeMemoryBlock(localDataIndex + 0x50);
  LOCK();
  *(uint32_t *)(localDataIndex + 0x80) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(localDataIndex + 0x84) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(localDataIndex + 0x88) = 0;
  UNLOCK();
  localDataIndex = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&stackValue20);
    localDataIndex = stackValue20;
  }
  *(double *)(systemResourcePointer + 0x68) = (double)(localDataIndex - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
  if (SystemMemoryFlag != '\0') {
    stackValue58 = 0x180c91288;
    systemStatus = _Mtx_lock(0x180c91288);
    if (systemStatus != 0) {
      __Throw_C_error_std__YAXH_Z(systemStatus);
    }

/**
 * @brief 初始化系统数据同步器
 * 
 * 该函数负责初始化系统数据同步器，处理系统数据的同步操作，
 * 包括内存分配、节点遍历和数据同步设置。
 * 
 * @param systemResourcePointer 系统资源指针，用于访问系统资源
 * @param dataSyncPointer 数据同步指针，用于数据同步操作
 * 
 * @note 这是系统数据同步管理的重要组成部分
 */
void InitializeSystemDataSynchronizer(long long systemResourcePointer,void* dataSyncPointer)

{
  long long *primaryResourcePointer;
  char systemFlag1;
  char systemFlag2;
  int systemStatus;
  uint32_t systemValue5;
  uint8_t *systemDataPointer;
  void** SystemCurrentNode;
  void** SystemNextNode;
  long long resourceCounter;
  uint systemValue10;
  long long nextDataIndex2;
  ulong long systemValue13;
  long long *primaryResourcePointer4;
  float floatValue;
  void* systemValue16;
  float floatValue2;
  uint8_t systemBuffer348 [32];
  long long **stackPointer328;
  void* *stackPointer320;
  uint32_t stackValue318;
  void* stackValue308;
  char stackFlag300;
  char StackBuffer2ff [7];
  long long *stackPointer2f8;
  uint32_t stackValue2f0;
  void* *stackPointer2e8;
  void* *stackPointer2e0;
  uint32_t stackValue2d8;
  void* stackValue2d0;
  uint32_t StackBuffer2c8 [2];
  long long *stackPointer2c0;
  void* stackValue2b8;
  void* StackBuffer2a8 [67];
  long long StackBuffer90 [3];
  uint32_t stackValue78;
  ulong long stackValue68;
  ulong long systemValue11;
  
  stackValue2b8 = 0xfffffffffffffffe;
  stackValue68 = SystemEncryptionKeyTemplate ^ (ulong long)systemBuffer348;
  floatValue = (float)dataSyncPointer;
  SystemPerformanceAccumulator1 = (long long)(floatValue * 100000.0);
  SystemPerformanceAccumulator2 = SystemPerformanceAccumulator2 + SystemPerformanceAccumulator1;
  SystemPerformanceValue = floatValue;
  systemValue16 = GetSystemStatusFlags();
  systemValue16 = SynchronizeSystemData(systemValue16,dataSyncPointer);
  systemFlag1 = CheckSystemFlag(systemValue16,0x52);
  systemFlag2 = CheckSystemFlag(1,0x51);
  nextDataIndex2 = 0xe0;
  if (systemFlag2 == '\0') {
    if (systemFlag1 == '\0') goto SystemValidation;
  }
  else {

/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，处理资源的分配和管理。
 * 函数会设置系统数据表，管理资源偏移量，并配置系统参数。
 * 
 * @param systemResourcePointer 系统资源指针，用于访问和配置系统资源
 * 
 * @note 这是系统资源管理的重要组成部分，确保资源的正确管理和分配
 */
void InitializeSystemResourceManager(long long systemResourcePointer)

{
  int *integerPointer;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long systemValue4;
  
  HashEntryStatus = *(void* **)(systemResourcePointer + 0x218);
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 系统资源复制器
 * 
 * 该函数负责复制系统资源，包括内存分配、数据复制和资源管理。
 * 它会创建新的系统资源对象，并复制源资源的所有属性和数据。
 * 
 * @param ResourceManagerPointer 目标资源指针
 * @param ConfigurationDataPointer 源资源指针
 * @return 返回复制后的资源指针
 */
void* * SystemResourceCopier(void* *ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long localSystemHandle;
  long long localResourceOffset;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  long long localSystemFlags;
  uint8_t *HashBucketNode;
  long long localMemoryAddress;
  ulong long unsignedSystemValue9;
  
  HashBucketNode = (uint8_t *)((long long)ResourceManagerPointer + 0xf);
  *ResourceManagerPointer = *ConfigurationDataPointer;
  *(uint32_t *)(ResourceManagerPointer + 1) = *(uint32_t *)(ConfigurationDataPointer + 1);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xc) = *(uint8_t *)((long long)ConfigurationDataPointer + 0xc);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xd) = *(uint8_t *)((long long)ConfigurationDataPointer + 0xd);
  *(uint8_t *)((long long)ResourceManagerPointer + 0xe) = *(uint8_t *)((long long)ConfigurationDataPointer + 0xe);
  localSystemFlags = 0x100;
  do {
    *HashBucketNode = HashBucketNode[(long long)ConfigurationDataPointer - (long long)ResourceManagerPointer];
    HashBucketNode[1] = HashBucketNode[((long long)ConfigurationDataPointer - (long long)ResourceManagerPointer) + 1];
    HashBucketNode = HashBucketNode + 2;
    localSystemFlags = localSystemFlags + -1;
  } while (localSystemFlags != 0);
  *(uint8_t *)((long long)ResourceManagerPointer + 0x20f) = *(uint8_t *)((long long)ConfigurationDataPointer + 0x20f);
  PrimaryResourcePointer = ResourceManagerPointer + 0x43;
  *(uint8_t *)(ResourceManagerPointer + 0x42) = *(uint8_t *)(ConfigurationDataPointer + 0x42);
  *(uint8_t *)((long long)ResourceManagerPointer + 0x211) = *(uint8_t *)((long long)ConfigurationDataPointer + 0x211);
  if (PrimaryResourcePointer != ConfigurationDataPointer + 0x43) {
    localSystemFlags = *PrimaryResourcePointer;
    localSystemHandle = ConfigurationDataPointer[0x44];
    localResourceOffset = ConfigurationDataPointer[0x43];
    localMemoryAddress = localSystemHandle - localResourceOffset;
    unsignedSystemValue9 = localMemoryAddress >> 2;
    if ((ulong long)(ResourceManagerPointer[0x45] - localSystemFlags >> 2) < unsignedSystemValue9) {
      if (unsignedSystemValue9 == 0) {
        localSystemFlags = 0;
      }
      else {
        localSystemFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue9 * 4,*(uint8_t *)(ResourceManagerPointer + 0x46));
      }
      if (localResourceOffset != localSystemHandle) {
          memmove(localSystemFlags,localResourceOffset,localMemoryAddress);
      }
      if (*PrimaryResourcePointer != 0) {
          SystemCleanupFunction();
      }
      localSystemHandle = localSystemFlags + unsignedSystemValue9 * 4;
      *PrimaryResourcePointer = localSystemFlags;
      ResourceManagerPointer[0x44] = localSystemHandle;
      ResourceManagerPointer[0x45] = localSystemHandle;
    }
    else {
      bufferBaseAddress = ResourceManagerPointer[0x44];
      currentThreadId = bufferBaseAddress - localSystemFlags >> 2;
      if (currentThreadId < unsignedSystemValue9) {
        localMemoryAddress = currentThreadId * 4 + localResourceOffset;
        if (localResourceOffset != localMemoryAddress) {
            memmove(localSystemFlags,localResourceOffset);
        }
        if (localMemoryAddress != localSystemHandle) {
            memmove(bufferBaseAddress,localMemoryAddress,localSystemHandle - localMemoryAddress);
        }
        ResourceManagerPointer[0x44] = bufferBaseAddress;
      }
      else {
        if (localResourceOffset != localSystemHandle) {
            memmove(localSystemFlags,localResourceOffset,localMemoryAddress);
        }
        ResourceManagerPointer[0x44] = localSystemFlags;
      }
    }
  }
  return ResourceManagerPointer;
}





// 函数: void SystemResourceManager(long long ResourceManagerPointer)
/**
 * @brief 系统资源管理器
 * 
 * 该函数负责管理系统资源的分配和释放。
 * 这是资源管理系统的核心函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemResourceManager(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long in_RAX;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  long long *threadContextPointer;
  long long *threadDataPointer;
  long long SystemTimeValue;
  ulong long hashValue;
  
  nextDataIndex = systemStringIteratorPtr[1];
  localSystemHandle = *systemStringIteratorPtr;
  localSystemPointer = nextDataIndex - localSystemHandle;
  hashValue = localSystemPointer >> 2;
  if ((ulong long)(in_RAX - ResourceManagerPointer >> 2) < hashValue) {
    if (hashValue == 0) {
      localResourceOffset = 0;
    }
    else {
      localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,hashValue * 4,(char)systemDataIndexPtr[3]);
    }
    if (localSystemHandle != nextDataIndex) {
        memmove(localResourceOffset,localSystemHandle,localSystemPointer);
    }
    if (*systemDataIndexPtr != 0) {
        SystemCleanupFunction();
    }
    nextDataIndex = localResourceOffset + hashValue * 4;
    *systemDataIndexPtr = localResourceOffset;
    systemDataIndexPtr[1] = nextDataIndex;
    systemDataIndexPtr[2] = nextDataIndex;
  }
  else {
    localResourceOffset = systemDataIndexPtr[1];
    unsignedSystemValue4 = localResourceOffset - ResourceManagerPointer >> 2;
    if (unsignedSystemValue4 < hashValue) {
      localSystemPointer = unsignedSystemValue4 * 4 + localSystemHandle;
      if (localSystemHandle != localSystemPointer) {
          memmove(ResourceManagerPointer,localSystemHandle);
      }
      if (localSystemPointer != nextDataIndex) {
          memmove(localResourceOffset,localSystemPointer,nextDataIndex - localSystemPointer);
      }
      systemDataIndexPtr[1] = localResourceOffset;
    }
    else {
      if (localSystemHandle != nextDataIndex) {
          memmove(ResourceManagerPointer,localSystemHandle,localSystemPointer);
      }
      systemDataIndexPtr[1] = ResourceManagerPointer;
    }
  }
  return;
}



/**
 * @brief 系统内存配置器
 * 
 * 负责配置系统内存管理相关的参数和设置。
 * 该函数确保内存分配器能够正确工作。
 */
void SystemMemoryConfigurator(void)

{
  long long MemoryBufferPointer;
  long long SystemHandle;
  long long StackBasePointer;
  long long MemorySizePointer;
  long long *ResourceArrayPointer;
  long long AllocationSize;
  
  if (AllocationSize == 0) {
    SystemHandle = 0;
  }
  else {
    SystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,AllocationSize * 4,(char)ResourceArrayPointer[3]);
  }
  if (MemorySizePointer != StackBasePointer) {
      memmove(SystemHandle);
  }
  if (*ResourceArrayPointer != 0) {
      SystemCleanupFunction();
  }
  MemoryBufferPointer = SystemHandle + AllocationSize * 4;
  *ResourceArrayPointer = SystemHandle;
  ResourceArrayPointer[1] = MemoryBufferPointer;
  ResourceArrayPointer[2] = MemoryBufferPointer;
  return;
}




// 函数: void SystemResourceHandler(long long ResourceManagerPointer)
/**
 * @brief 系统资源处理器
 * 
 * 该函数负责处理系统资源的具体操作。
 * 这是资源处理系统的核心函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemResourceHandler(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  ulong long allocationContext;
  long long systemStackFramePtr;
  long long systemStringIteratorPtr;
  long long systemDataIndexPtr;
  ulong long systemResourceCounter;
  
  localSystemHandle = *(long long *)(systemDataIndexPtr + 8);
  allocationContext = localSystemHandle - ResourceManagerPointer >> 2;
  if (allocationContext < systemResourceCounter) {
    nextDataIndex = allocationContext * 4 + systemStringIteratorPtr;
    if (systemStringIteratorPtr != nextDataIndex) {
        memmove();
    }
    if (nextDataIndex != systemStackFramePtr) {
        memmove(localSystemHandle,nextDataIndex,systemStackFramePtr - nextDataIndex);
    }
    *(long long *)(systemDataIndexPtr + 8) = localSystemHandle;
  }
  else {
    if (systemStringIteratorPtr != systemStackFramePtr) {
        memmove();
    }
    *(long long *)(systemDataIndexPtr + 8) = ResourceManagerPointer;
  }
  return;
}




// 函数: void SystemContextInitializer(void)
/**
 * @brief 系统上下文初始化器
 * 
 * 该函数负责初始化系统上下文环境。
 * 这是上下文管理系统的初始化函数。
 */
void SystemContextInitializer(void)

{
  return;
}



/**
 * @brief 系统资源验证器
 * 
 * 该函数验证系统资源的有效性和完整性。
 * 它会检查资源的状态、属性和关联数据，确保资源处于可用状态。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回验证结果，true表示资源有效，false表示资源无效
 */
bool SystemResourceValidator(long long ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  byte byteValue;
  bool isValidOperation;
  byte *stringPointer;
  uint currentThreadId;
  int systemFlag;
  long long localDataIndex;
  void** SystemNextNode;
  void* *punsignedSystemValue9;
  void* *pointerToUnsigned10;
  void* *ThreadLocalStorage;
  void* *pointerUnsigned30;
  byte *pbStack_28;
  int iStack_20;
  
  pointerToUnsigned1 = (void* *)(ResourceManagerPointer + 0x2e0);
  SetupSystemMemory(&pointerUnsigned30);
  newThreadLocalStorage = *(void* **)(ResourceManagerPointer + 0x2f0);
  ThreadLocalStorage = pointerToUnsigned1;
  if (newThreadLocalStorage != (void* *)0x0) {
    do {
      if (iStack_20 == 0) {
        isValidOperation = false;
        punsignedSystemValue9 = (void* *)newThreadLocalStorage[1];
      }
      else {
        if (*(int *)(newThreadLocalStorage + 6) == 0) {
          isValidOperation = true;
        }
        else {
          stringPointer = pbStack_28;
          do {
            currentThreadId = (uint)stringPointer[newThreadLocalStorage[5] - (long long)pbStack_28];
            systemFlag = *stringPointer - currentThreadId;
            if (*stringPointer != currentThreadId) break;
            stringPointer = stringPointer + 1;
          } while (currentThreadId != 0);
          isValidOperation = 0 < systemFlag;
          if (systemFlag < 1) {
            punsignedSystemValue9 = (void* *)newThreadLocalStorage[1];
            goto SystemValidationCheck;
          }
        }
        punsignedSystemValue9 = (void* *)*newThreadLocalStorage;
      }
SystemValidationCheck:
      pointerToUnsigned10 = newThreadLocalStorage;
      if (isValidOperation) {
        pointerToUnsigned10 = ThreadLocalStorage;
      }
      newThreadLocalStorage = punsignedSystemValue9;
      ThreadLocalStorage = pointerToUnsigned10;
    } while (punsignedSystemValue9 != (void* *)0x0);
    if (pointerToUnsigned10 != pointerToUnsigned1) {
      if (*(int *)(pointerToUnsigned10 + 6) == 0) goto SystemValueValidation;
      if (iStack_20 != 0) {
        stringPointer = (byte *)pointerToUnsigned10[5];
        localDataIndex = (long long)pbStack_28 - (long long)stringPointer;
        do {
          byteValue = *stringPointer;
          currentThreadId = (uint)stringPointer[localDataIndex];
          if (byteValue != currentThreadId) break;
          stringPointer = stringPointer + 1;
        } while (currentThreadId != 0);
        if ((int)(byteValue - currentThreadId) < 1) goto SystemValueValidationCheck;
      }
    }
  }
  pointerToUnsigned10 = pointerToUnsigned1;
SystemValueValidationCheck:
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (pbStack_28 == (byte *)0x0) {
    return pointerToUnsigned10 != pointerToUnsigned1;
  }
    SystemCleanupFunction();
}




void*
/**
 * @brief 系统状态标志处理器
 * 
 * 该函数处理系统状态标志的操作，包括设置、清除和查询状态标志。
 * 它会调用底层的系统函数来处理状态标志的相关操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递操作目标
 * @param AdditionalParameter 参数3，用于传递操作参数
 * @param ConfigurationFlag 参数4，用于传递操作标志
 * @return 返回处理后的结果指针
 */
void* SystemStatusFlagProcessor(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  CreateSystemObject(ConfigurationDataPointer,SystemStatusFlagsPointer + 0x2c0,AdditionalParameter,ConfigurationFlag,0,0xfffffffffffffffe);
  return ConfigurationDataPointer;
}





// 函数: void SystemDataProcessor(long long ResourceManagerPointer)
/**
 * @brief 系统数据处理器
 * 
 * 该函数负责处理系统数据的操作和管理。
 * 这是数据处理系统的核心函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemDataProcessor(long long ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  int systemResult;
  uint8_t aunsignedValue108 [32];
  uint32_t uStack_e8;
  void* UnsignedStackFlagB8;
  long long lStack_b0;
  uint8_t aUnsignedStackFlagA8 [128];
  ulong long EncryptionKeyValue;
  
  UnsignedStackFlagB8 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue108;
  uStack_e8 = 0;
  lStack_b0 = ResourceManagerPointer;
  CreateSystemObject(ResourceManagerPointer,SystemStatusFlagsPointer + 0x170);
  uStack_e8 = 1;
  systemResult = *(int *)(ResourceManagerPointer + 0x10) + 8;
  ExecuteSystemCommand(ResourceManagerPointer,systemResult);
  pointerToUnsigned1 = (void* *)((ulong long)*(uint *)(ResourceManagerPointer + 0x10) + *(long long *)(ResourceManagerPointer + 8));
  *pointerToUnsigned1 = 0x2f73656873617263;
  *(uint8_t *)(pointerToUnsigned1 + 1) = 0;
  *(int *)(ResourceManagerPointer + 0x10) = systemResult;
    memset(aUnsignedStackFlagA8,0,0x80);
}





// 函数: void SystemMemoryAllocator(long long ResourceManagerPointer,long long parameter2,void* parameter3,void* parameter4)
/**
 * @brief 系统内存分配器
 * 
 * 该函数负责分配系统内存资源。
 * 这是内存分配系统的核心函数。
 * 
 * @param resourceManagerPointer 系统资源指针
 * @param allocationSize 分配大小
 * @param memoryPool 内存池
 * @param allocationFlags 分配标志
 */
void SystemMemoryAllocator(long long resourceManagerPointer,long long allocationSize,void* memoryPool,void* allocationFlags)

{
  long long *PrimaryResourcePointer;
  uint32_t creationFlags;
  int MemoryComparisonResult;
  void* *punsignedSystemValue4;
  ulong long currentThreadId;
  long long localSystemFlags;
  void* unsignedSystemValue7;
  void* *pStackParameterC;
  void* *pUnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  void* UnsignedStackFlag78;
  void* *pprocessFlags70;
  void* *pEncryptionValue68;
  uint32_t unsignedValue60;
  void* processFlags58;
  
  unsignedSystemValue7 = 0xfffffffffffffffe;
  PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0xd8);
  localSystemFlags = 0;
  if ((*(long long *)(ResourceManagerPointer + 0xe0) - *PrimaryResourcePointer & 0xffffffffffffffe0U) != 0) {
    InitializeConfigurationData(ConfigurationDataPointer);
    currentThreadId = *(long long *)(ResourceManagerPointer + 0xe0) - *PrimaryResourcePointer >> 5;
    if (0 < (int)currentThreadId) {
      currentThreadId = currentThreadId & 0xffffffff;
      do {
        if (*(ulong long *)(ConfigurationDataPointer + 8) < *(ulong long *)(ConfigurationDataPointer + 0x10)) {
          *(ulong long *)(ConfigurationDataPointer + 8) = *(ulong long *)(ConfigurationDataPointer + 8) + 0x20;
          InitializeSystemMemoryAllocator();
        }
        else {
          ProcessSystemConfiguration(ConfigurationDataPointer,*PrimaryResourcePointer + localSystemFlags);
        }
        localSystemFlags = localSystemFlags + 0x20;
        currentThreadId = currentThreadId - 1;
      } while (currentThreadId != 0);
    }
    return;
  }
  pprocessFlags70 = &SystemGlobalDataReference;
  processFlags58 = 0;
  pEncryptionValue68 = (void* *)0x0;
  unsignedValue60 = 0;
  punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,ConfigurationFlag,0xfffffffffffffffe);
  *(uint8_t *)punsignedSystemValue4 = 0;
  pEncryptionValue68 = punsignedSystemValue4;
  creationFlags = StartSystemThread(punsignedSystemValue4);
  processFlags58 = CONCAT44(processFlags58._4_4_,creationFlags);
  *punsignedSystemValue4 = 0x53454c55444f4d5f;
  *(void*2 *)(punsignedSystemValue4 + 1) = 0x2a5f;
  *(uint8_t *)((long long)punsignedSystemValue4 + 10) = 0;
  unsignedValue60 = 10;
  systemCounter = GetSystemCounter(ResourceManagerPointer + 0x2c0,&pprocessFlags70);
  if (-1 < systemCounter) {
    pSystemConfigurationValue = &SystemGlobalDataReference;
    UnsignedStackFlag78 = 0;
    pUnsignedStackFlag88 = (void* *)0x0;
    UnsignedStackFlag80 = 0;
    punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,ConfigurationFlag,unsignedSystemValue7);
    *(uint8_t *)punsignedSystemValue4 = 0;
    pUnsignedStackFlag88 = punsignedSystemValue4;
    creationFlags = StartSystemThread(punsignedSystemValue4);
    UnsignedStackFlag78 = CONCAT44(UnsignedStackFlag78._4_4_,creationFlags);
    *punsignedSystemValue4 = 0x454c55444f4d5f2a;
    *(void*2 *)(punsignedSystemValue4 + 1) = 0x5f53;
    *(uint8_t *)((long long)punsignedSystemValue4 + 10) = 0;
    UnsignedStackFlag80 = 10;
    GetSystemCounter(ResourceManagerPointer + 0x2c0,&pStackParameterC);
    pSystemConfigurationValue = &SystemGlobalDataReference;
      SystemCleanupFunction(punsignedSystemValue4);
  }
  pprocessFlags70 = &SystemGlobalDataReference;
    SystemCleanupFunction(punsignedSystemValue4);
}




/**
 * @brief 系统资源分配器
 * 
 * 该函数负责分配系统资源，包括内存分配、线程创建和资源初始化。
 * 它会创建必要的系统资源对象，并设置相应的属性和状态。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递分配参数
 * @return 返回分配后的资源指针
 */
void* SystemResourceAllocator(void* ResourceManagerPointer,void* ConfigurationDataPointer)

{
  long long nextDataIndex;
  uint32_t creationFlags;
  int MemoryComparisonResult;
  void* *punsignedSystemValue4;
  void* *pUnsignedStackFlag88;
  void* *pUnsignedStackFlag80;
  uint32_t UnsignedStackFlag78;
  void* processFlags70;
  void* *pEncryptionValue68;
  void* *punsignedValue60;
  uint32_t processFlags58;
  void* unsignedValue50;
  
  nextDataIndex = SystemStatusFlagsPointer;
  if (*(int *)(SystemStatusFlagsPointer + 200) != 0) {
    CreateSystemObject(ConfigurationDataPointer,SystemStatusFlagsPointer + 0xb8);
    return ConfigurationDataPointer;
  }
  pEncryptionValue68 = &SystemGlobalDataReference;
  unsignedValue50 = 0;
  punsignedValue60 = (void* *)0x0;
  processFlags58 = 0;
  punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
  *(uint8_t *)punsignedSystemValue4 = 0;
  punsignedValue60 = punsignedSystemValue4;
  creationFlags = StartSystemThread(punsignedSystemValue4);
  unsignedValue50 = CONCAT44(unsignedValue50._4_4_,creationFlags);
  *punsignedSystemValue4 = 0x53454c55444f4d5f;
  *(void*2 *)(punsignedSystemValue4 + 1) = 0x2a5f;
  *(uint8_t *)((long long)punsignedSystemValue4 + 10) = 0;
  processFlags58 = 10;
  systemCounter = GetSystemCounter(nextDataIndex + 0x2c0,&pEncryptionValue68);
  if (-1 < systemCounter) {
    pUnsignedStackFlag88 = &SystemGlobalDataReference;
    processFlags70 = 0;
    pUnsignedStackFlag80 = (void* *)0x0;
    UnsignedStackFlag78 = 0;
    punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
    *(uint8_t *)punsignedSystemValue4 = 0;
    pUnsignedStackFlag80 = punsignedSystemValue4;
    creationFlags = StartSystemThread(punsignedSystemValue4);
    processFlags70 = CONCAT44(processFlags70._4_4_,creationFlags);
    *punsignedSystemValue4 = 0x454c55444f4d5f2a;
    *(void*2 *)(punsignedSystemValue4 + 1) = 0x5f53;
    *(uint8_t *)((long long)punsignedSystemValue4 + 10) = 0;
    UnsignedStackFlag78 = 10;
    GetSystemCounter(nextDataIndex + 0x2c0,&pUnsignedStackFlag88);
    pUnsignedStackFlag88 = &SystemGlobalDataReference;
      SystemCleanupFunction(punsignedSystemValue4);
  }
  pEncryptionValue68 = &SystemGlobalDataReference;
    SystemCleanupFunction(punsignedSystemValue4);
}





// 函数: void SystemFloatingPointProcessor(long long ResourceManagerPointer,float parameter2,void* parameter3,void* parameter4)
/**
 * @brief 系统浮点数处理器
 * 
 * 该函数负责处理系统中的浮点数运算。
 * 这是浮点数处理系统的核心函数。
 * 
 * @param resourceManagerPointer 系统资源指针
 * @param floatValue 浮点数值
 * @param processingContext 处理上下文
 * @param operationFlags 操作标志
 */
void SystemFloatingPointProcessor(long long resourceManagerPointer,float floatValue,void* processingContext,void* operationFlags)

{
  ulong long systemStatus;
  float calculationResult1;
  float calculationResult2;
  ulong long threadContextValue;
  ulong long currentThreadId;
  int systemFlag;
  uint renderStatusValue1;
  long long localMemoryAddress;
  uint renderStatusValue2;
  void* contextParameter;
  long long allocationFlags;
  uint renderStatus3;
  uint renderStatus4;
  uint renderStatus5;
  bool isSystemConfigured;
  float scaleFactorX;
  float scaleFactorY;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  uint32_t creationFlags1;
  float interpolationFactor5;
  float scaleResult1;
  float scaleResult2;
  
  localMemoryAddress = SystemNodeManagerPointer;
  if ((*(long long *)(SystemMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemNodeManagerPointer + 0x540) < 1)) {
    isSystemConfigured = *(int *)(SystemNodeManagerPointer + 0x2140) != 0;
  }
  else {
    isSystemConfigured = false;
  }
  if (isSystemConfigured) {
    scaleFactorX = (float)exp2f(SystemNodeManagerPointer,contextParameter,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    if (*(char *)(ResourceManagerPointer + 0x22d) == '\0') {
      localMemoryAddress = *(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
      if ((*(int *)(localMemoryAddress + 0x48) < SystemDataValue1) &&
         (CheckSystemDataAvailability(&SystemDataValue1), SystemDataValue1 == -1)) {
        SystemDataValue2 = ConfigurationDataPointer;
        InitializeSystemDataPointer(&SystemDataValue1);
      }
      calculationResult1 = (float)exp2f();
      interpolationFactor1 = (float)exp2f();
      interpolationFactor2 = (float)exp2f();
      interpolationFactor3 = (float)exp2f();
      interpolationFactor4 = (float)exp2f();
      SystemDataValue2 = (1.0 - calculationResult1) * SystemDataValue2 + calculationResult1 * ConfigurationDataPointer;
      calculationResult2 = (float)*(int *)(SystemNodeManagerPointer + 0x21b0);
      if (*(float *)(SystemStatusFlagsPointer + 0x1f8) <= (float)*(int *)(SystemNodeManagerPointer + 0x21b0)) {
        calculationResult2 = *(float *)(SystemStatusFlagsPointer + 0x1f8);
      }
      interpolationFactor5 = *(float *)(SystemNodeManagerPointer + 0x1e30);
      if (0 < *(int *)(SystemNodeManagerPointer + 0x1f80)) {
        interpolationFactor5 = interpolationFactor5 / (float)*(int *)(SystemNodeManagerPointer + 0x1f80);
      }
      scaleFactorY = (float)((int)interpolationFactor5 + -1);
      if (calculationResult2 <= (float)((int)interpolationFactor5 + -1)) {
        scaleFactorY = calculationResult2;
      }
      if ((*(int *)(localMemoryAddress + 0x48) < SystemDataValue3) &&
         (CheckSystemDataAvailability(&SystemDataValue3), SystemDataValue3 == -1)) {
        SystemDataValue4 = scaleFactorY;
        InitializeSystemDataPointer(&SystemDataValue3);
      }
      SystemDataValue4 = (1.0 - calculationResult1) * SystemDataValue4 + scaleFactorY * calculationResult1;
      interpolationFactor2 = ((float)(int)((SystemDataValue2 / SystemDataValue4) / interpolationFactor1) * interpolationFactor1 - 1.0) * interpolationFactor2 *
               interpolationFactor3 + interpolationFactor2;
      if (interpolationFactor2 <= scaleResult1) {
        interpolationFactor2 = scaleResult1;
      }
      if (1.0 <= interpolationFactor2) {
        interpolationFactor2 = 1.0;
      }
      interpolationFactor4 = (float)(int)((interpolationFactor2 + 0.05) / interpolationFactor4) * interpolationFactor4;
      if ((scaleResult1 <= interpolationFactor4) && (scaleResult1 = interpolationFactor4, 1.0 <= interpolationFactor4)) {
        scaleResult1 = 1.0;
      }
      *(float *)(ResourceManagerPointer + 0x238) = scaleResult1;
      creationFlags1 = log2f();
      *(uint32_t *)(ResourceManagerPointer + 0x248) = creationFlags1;
      *(float *)(ResourceManagerPointer + 0x250) = SystemDataValue2;
      allocationFlags = SystemRenderManagerPointer;
      *(uint8_t *)(SystemRenderManagerPointer + 0x162b) = 1;
      localMemoryAddress = SystemNodeManagerPointer;
    }
    else {
      *(float *)(ResourceManagerPointer + 0x238) = scaleResult1;
      localMemoryAddress = SystemNodeManagerPointer;
      allocationFlags = SystemRenderManagerPointer;
    }
  }
  else {
    *(uint32_t *)(ResourceManagerPointer + 0x238) = 0x3f800000;
    allocationFlags = SystemRenderManagerPointer;
  }
  if ((*(long long *)(SystemMemoryContext + 0x7ab8) == 0) || (*(int *)(localMemoryAddress + 0x540) < 1)) {
    if (*(int *)(localMemoryAddress + 0x2140) == 0) {
      scaleResult1 = *(float *)(localMemoryAddress + 0x20d0);
    }
    else {
      scaleResult1 = 100.0;
    }
    scaleResult1 = scaleResult1 * 0.01;
  }
  else {
    scaleResult1 = 1.0;
  }
  *(float *)(ResourceManagerPointer + 0x234) = scaleResult1;
  renderStatus3 = (uint)*(float *)(allocationFlags + 0x17ec);
  renderStatus5 = (uint)*(float *)(allocationFlags + 0x17f0);
  renderStatus4 = renderStatus3;
  renderStatusValue1 = renderStatus5;
  if (1.0 <= scaleResult1) {
    scaleResult1 = 1.0;
    scaleResult2 = 1.0;
  }
  else {
    while (0 < (int)renderStatusValue1) {
      renderStatusValue2 = (int)renderStatus4 % (int)renderStatusValue1;
      renderStatus4 = renderStatusValue1;
      renderStatusValue1 = renderStatusValue2;
    }
    systemFlag = (int)renderStatus3 / (int)renderStatus4;
    scaleResult1 = (float)(int)renderStatus3;
    do {
      renderStatus3 = (uint)(scaleResult1 * scaleResult1);
      if (1 < systemFlag) {
        renderStatus3 = ((renderStatus3 - 1) - (int)(renderStatus3 - 1) % systemFlag) + systemFlag;
      }
      systemStatus = (long long)(int)(((int)renderStatus5 / (int)renderStatus4) * renderStatus3) / (long long)systemFlag;
      renderStatusValue1 = (uint)systemStatus;
      if (((renderStatus3 & 1) == 0) && ((systemStatus & 1) == 0)) goto SystemFlagHandlerCheck;
      scaleResult1 = scaleResult1 + 0.01;
      *(float *)(ResourceManagerPointer + 0x234) = scaleResult1;
    } while (scaleResult1 <= 1.0);
    *(uint32_t *)(ResourceManagerPointer + 0x234) = 0x3f800000;
SystemFlagHandlerCheck:
    scaleResult1 = (float)(int)renderStatus3 / scaleResult1;
    scaleResult2 = (float)(int)renderStatusValue1 / (float)(int)renderStatus5;
    renderStatus5 = renderStatusValue1;
  }
  *(ulong long *)(ResourceManagerPointer + 0x254) = CONCAT44(scaleResult2,scaleResult1);
  scaleResult1 = *(float *)(ResourceManagerPointer + 0x238);
  if (1.0 <= scaleResult1) {
    scaleResult1 = 1.0;
    scaleResult2 = 1.0;
  }
  else {
    currentThreadId = (ulong long)renderStatus5;
    systemStatus = (ulong long)renderStatus3;
    renderStatus4 = renderStatus3;
    renderStatusValue1 = renderStatus5;
    while (threadContextValue = currentThreadId, 0 < (int)renderStatusValue1) {
      renderStatus4 = (uint)threadContextValue;
      systemStatus = (long long)(int)systemStatus % (long long)(int)renderStatus4;
      renderStatusValue1 = (uint)systemStatus;
      currentThreadId = systemStatus & 0xffffffff;
      systemStatus = threadContextValue;
    }
    systemFlag = (int)renderStatus3 / (int)renderStatus4;
    do {
      renderStatusValue1 = (uint)(scaleResult1 * (float)(int)renderStatus3);
      if (1 < systemFlag) {
        renderStatusValue1 = ((renderStatusValue1 - 1) - (int)(renderStatusValue1 - 1) % systemFlag) + systemFlag;
      }
      systemStatus = (long long)(int)(((int)renderStatus5 / (int)renderStatus4) * renderStatusValue1) / (long long)systemFlag;
      if (((renderStatusValue1 & 1) == 0) && ((systemStatus & 1) == 0)) goto SystemFlagHandler;
      scaleResult1 = scaleResult1 + 0.01;
      *(float *)(ResourceManagerPointer + 0x238) = scaleResult1;
    } while (scaleResult1 <= 1.0);
    *(uint32_t *)(ResourceManagerPointer + 0x238) = 0x3f800000;
SystemFlagHandler:
    scaleResult1 = (float)(int)renderStatusValue1 / (float)(int)renderStatus3;
    scaleResult2 = (float)(int)systemStatus / (float)(int)renderStatus5;
  }
  *(ulong long *)(ResourceManagerPointer + 0x25c) = CONCAT44(scaleResult2,scaleResult1);
  return;
}





/**
 * @brief 系统资源和渲染管理处理函数
 * 
 * 该函数负责处理系统资源和渲染管理的复杂逻辑，包括：
 * - 检查系统节点管理器的状态标志
 * - 处理渲染管理器的数据缓冲区
 * - 管理内存分配和资源处理
 * - 计算和调整缩放因子
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ResourceData 资源数据指针
 * @param RenderConfig 渲染配置指针
 * @param OperationFlags 操作标志
 */
void ProcessSystemResourceAndRenderManagement(long long *ResourceManagerPointer,void* ResourceData,void* RenderConfig,uint8_t OperationFlags)
{
  int systemStatusValue;
  long long systemHandle;
  long long renderManagerOffset;
  void* memoryAllocationHandle;
  long long *systemResourcePointer;
  int *resourceCountPointer;
  long long dataBufferPointer;
  ulong long loopCounter;
  uint itemCounter;
  ulong long maxItemCount;
  float scaleFactor1;
  float scaleFactor2;
  long long *StackParameter1;
  long long *StackParameter2;
  long long **StackParameter3;
  long long localBuffer1 [2];
  void* *localBuffer2;
  void* *localBuffer3;
  long long localBuffer4 [2];
  void* *localBuffer5;
  void* *localBuffer6;
  
  systemHandle = SystemStatusFlagsPointer;
  SystemResourceHandle = ResourceManagerPointer;
  if (*(int *)(SystemNodeManagerPointer + 0xd94) != *(int *)(SystemNodeManagerPointer + 0xd90)) {
    ProcessSystemResourceOperation(SystemStatusFlagsPointer,ResourceData,RenderConfig,OperationFlags,0xfffffffffffffffe);
  }
  renderManagerOffset = SystemRenderManagerPointer;
  if (SystemRenderManagerPointer != 0) {
    loopCounter = 0;
    dataBufferPointer = *(long long *)(SystemRenderManagerPointer + 0x1868);
    maxItemCount = loopCounter;
    if (*(long long *)(SystemRenderManagerPointer + 0x1870) - dataBufferPointer >> 3 != 0) {
      do {
        if (*(long long **)(loopCounter + dataBufferPointer) != (long long *)0x0) {
          (**(code **)(**(long long **)(loopCounter + dataBufferPointer) + 0x108))();
        }
        itemCounter = (int)maxItemCount + 1;
        loopCounter = loopCounter + 8;
        dataBufferPointer = *(long long *)(renderManagerOffset + 0x1868);
        maxItemCount = (ulong long)itemCounter;
      } while ((ulong long)(long long)(int)itemCounter <
               (ulong long)(*(long long *)(renderManagerOffset + 0x1870) - dataBufferPointer >> 3));
    }
    (**(code **)(SystemCallbackTable + 0x40))();
  }
  (**(code **)(**(long long **)(systemHandle + 0x2b0) + 0xd0))();
  if (((*(int *)(SystemNodeManagerPointer + 0x4d4) != *(int *)(SystemNodeManagerPointer + 0x4d0)) ||
      (*(int *)(SystemNodeManagerPointer + 0x314) != *(int *)(SystemNodeManagerPointer + 0x310))) ||
     (*(int *)(SystemNodeManagerPointer + 0x544) != *(int *)(SystemNodeManagerPointer + 0x540))) {
    SystemResourceHandle = localBuffer1;
    localBuffer2 = &SystemBuffer1;
    localBuffer3 = &SystemBuffer2;
    ProcessSystemResourceData(localBuffer1);
  }
  if ((SystemAllocationFlags != 0) &&
     ((*(int *)(SystemNodeManagerPointer + 900) != *(int *)(SystemNodeManagerPointer + 0x380) ||
      (*(int *)(SystemNodeManagerPointer + 0x3f4) != *(int *)(SystemNodeManagerPointer + 0x3f0))))) {
    memoryAllocationHandle = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x40,8,3);
    SystemResourceHandle = localBuffer4;
    localBuffer5 = &SystemBuffer3;
    localBuffer6 = &SystemBuffer4;
    systemResourcePointer = (long long *)CreateMemoryAllocationHandle(memoryAllocationHandle,localBuffer4);
    StackParameter2 = systemResourcePointer;
    if (systemResourcePointer != (long long *)0x0) {
      (**(code **)(*systemResourcePointer + 0x28))(systemResourcePointer);
    }
    memoryAllocationHandle = SystemAllocationFlagsTemplate;
    SystemOperationFlag = &SystemResourceHandle;
    SystemResourceHandle = systemResourcePointer;
    if (systemResourcePointer != (long long *)0x0) {
      (**(code **)(*systemResourcePointer + 0x28))(systemResourcePointer);
    }
    SetupMemoryAllocationContext(memoryAllocationHandle,&StackParameter1);
    if (systemResourcePointer != (long long *)0x0) {
      (**(code **)(*systemResourcePointer + 0x38))(systemResourcePointer);
    }
  }
  renderManagerOffset = SystemNodeManagerPointer;
  if ((*(long long *)(SystemMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemNodeManagerPointer + 0x540) < 1)) {
    if (*(int *)(SystemNodeManagerPointer + 0x2140) == 0) {
      scaleFactor1 = *(float *)(SystemNodeManagerPointer + 0x20d0);
    }
    else {
      scaleFactor1 = 100.0;
    }
    scaleFactor1 = scaleFactor1 * 0.01;
  }
  else {
    scaleFactor1 = 1.0;
  }
  *(float *)(systemHandle + 0x234) = scaleFactor1;
  *(uint32_t *)(systemHandle + 0x238) = 0x3f800000;
  scaleFactor2 = 1.0;
  if (*(int *)(renderManagerOffset + 0x1ea0) == 1) {
    systemStatusValue = *(int *)(renderManagerOffset + 0x1d50);
    resourceCountPointer = (int *)GetResourceManagerPointer(*(void* *)(SystemStatusFlagsPointer + 8),&StackParameter2);
    scaleFactor2 = (float)systemStatusValue / (float)*resourceCountPointer;
    scaleFactor1 = scaleFactor2 * *(float *)(systemHandle + 0x234);
    scaleFactor2 = scaleFactor2 * *(float *)(systemHandle + 0x238);
  }
  if (0.2 <= scaleFactor1) {
    if (1.0 <= scaleFactor1) {
      scaleFactor1 = 1.0;
    }
  }
  else {
    scaleFactor1 = 0.2;
  }
  *(float *)(systemHandle + 0x234) = scaleFactor1;
  if (0.2 <= scaleFactor2) {
    if (1.0 <= scaleFactor2) {
      scaleFactor2 = 1.0;
    }
    *(float *)(systemHandle + 0x238) = scaleFactor2;
  }
  else {
    *(uint32_t *)(systemHandle + 0x238) = 0x3e4ccccd;
  }
  return;
}





// 函数: void InitializeSystemResource(void* ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串格式化处理器
 * 
 * 该函数负责处理系统字符串的格式化操作，包括字符串前缀添加、
 * 数据复制和内存管理。它主要用于构建特定格式的字符串数据结构。
 * 
 * @param formatData 格式化数据指针
 * @param stringBuffer 字符串缓冲区指针
 * 
 * @note 该函数在系统初始化过程中用于构建特定的字符串格式
 */
void SystemStringFormatter(void* formatData,long long stringBuffer)

{
  uint32_t *pointerToUnsigned1;
  int systemResult;
  int MemoryComparisonResult;
  uint8_t aStackValue1c8 [32];
  void* **ppuStack_1a8;
  void* systemFlag1A0;
  void* *pSystemStackFlag;
  void* uStack_190;
  int intValue188;
  uint8_t auStack_e8 [16];
  void* *punsignedValueD8;
  void* uStack_d0;
  int iStack_c8;
  ulong long unsignedValue18;
  
  systemFlag1A0 = 0xfffffffffffffffe;
  unsignedValue18 = SystemEncryptionKeyTemplate ^ (ulong long)aStackValue1c8;
  CopySystemDataStructure(auStack_e8,
                (long long)*(int *)(SystemTextureManagerPointer + 0x1d40) * 0xd0 +
                *(long long *)(SystemTextureManagerPointer + 0x1d20));
  InitializeSystemBuffer(&pSystemStackFlag);
  systemResult = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  if (*(uint8_t **)(ConfigurationDataPointer + 8) != (uint8_t *)0x0) {
    **(uint8_t **)(ConfigurationDataPointer + 8) = 0;
    systemResult = *(int *)(ConfigurationDataPointer + 0x10);
  }
  systemCounter = systemResult + 5;
  ExecuteSystemCommand(ConfigurationDataPointer,systemCounter);
  pointerToUnsigned1 = (uint32_t *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8));
  *pointerToUnsigned1 = 0x3a757067;
  *(void*2 *)(pointerToUnsigned1 + 1) = 0x20;
  *(int *)(ConfigurationDataPointer + 0x10) = systemCounter;
  if (0 < iStack_c8) {
    ExecuteSystemCommand(ConfigurationDataPointer,systemCounter + iStack_c8);
      memcpy((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8),uStack_d0,
           (long long)(iStack_c8 + 1));
  }
  ExecuteSystemCommand(ConfigurationDataPointer,systemResult + 6);
  *(void*2 *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8)) = 10;
  *(int *)(ConfigurationDataPointer + 0x10) = systemResult + 6;
  systemCounter = systemResult + 0xb;
  ExecuteSystemCommand(ConfigurationDataPointer,systemCounter);
  pointerToUnsigned1 = (uint32_t *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8));
  *pointerToUnsigned1 = 0x3a757063;
  *(void*2 *)(pointerToUnsigned1 + 1) = 0x20;
  *(int *)(ConfigurationDataPointer + 0x10) = systemCounter;
  if (0 < intValue188) {
    ExecuteSystemCommand(ConfigurationDataPointer,systemCounter + intValue188);
      memcpy((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8),uStack_190,
           (long long)(intValue188 + 1));
  }
  ExecuteSystemCommand(ConfigurationDataPointer,systemResult + 0xc);
  *(void*2 *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8)) = 10;
  *(int *)(ConfigurationDataPointer + 0x10) = systemResult + 0xc;
  pSystemStackFlag = &SystemMemoryAllocatorReference;
  ppuStack_1a8 = &punsignedValueD8;
  punsignedValueD8 = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(unsignedValue18 ^ (ulong long)aStackValue1c8);
}



000180053668)
0001800536a5)
0001800536a9)
0001800536b4)
0001800536b7)
0001800536e1)
0001800536e5)
0001800536f3)
0001800536fb)
000180053702)
00018005370c)
00018005373c)
000180053744)
000180053747)
000180053714)
000180053719)
000180053760)
00018005376e)
0001800537b1)
0001800537b5)
0001800537c0)
0001800537c3)
0001800537ed)
0001800537f1)
0001800537ff)
000180053807)
00018005380c)
00018005381c)
00018005384b)
000180053853)
000180053856)
000180053824)
000180053828)
00018005386f)
00018005387d)
0001800538c8)
0001800538cc)
0001800538d7)
0001800538da)
000180053906)
00018005390a)
000180053918)
000180053921)
000180053925)
000180053931)
000180053962)
00018005396a)
00018005396d)
000180053939)
00018005393e)
000180053987)
000180053996)
0001800539f8)
0001800539fc)
000180053a07)
000180053a0a)
000180053a34)
000180053a38)
000180053a46)
000180053a4e)
000180053a53)
000180053ad8)
000180053a61)
000180053aa2)
000180053aab)
000180053aaf)
000180053a69)
000180053a74)
000180053ade)
000180053b28)
000180053b2c)
000180053b32)
000180053b36)
000180053b60)
000180053b64)
000180053b72)
000180053b7a)
000180053b7e)
000180053b8e)
000180053bbe)
000180053bc6)
000180053bc9)
000180053b97)
000180053b9b)
000180053be2)
000180053bf0)
000180053c4c)
000180053c51)
000180053c5d)
000180053c60)
000180053c8e)
000180053c93)
000180053ca1)
000180053caa)
000180053caf)
000180053cbe)
000180053cf1)
000180053cf9)
000180053cfc)
000180053cc6)
000180053cce)
000180053d15)
000180053d23)
000180053d8b)
000180053d8f)
000180053d9a)
000180053d9d)
000180053dcd)
000180053dd1)
000180053ddf)
000180053de8)
000180053ded)
000180053dfc)
000180053e2f)
000180053e37)
000180053e3a)
000180053e03)
000180053e0b)
000180053e54)
000180053e63)
000180053ead)
000180053eb5)
000180053ee6)
000180053ef5)
000180053f18)
000180053f20)
000180053f43)
000180053f4b)
000180053f74)
000180053f79)
000180053f98)
000180053fa0)
000180053fbc)
000180053fc4)
000180053fe5)
000180053fea)
000180054035)
000180054062)
000180054075)
00018005407a)
0001800540b2)
0001800540b7)
0001800540d9)
0001800540e1)


/**
 * @brief 系统线程对象创建和管理函数
 * 
 * 该函数负责创建和管理系统线程对象，包括：
 * - 初始化系统进程ID和内存分配
 * - 创建系统线程对象和缓冲区
 * - 处理线程启动和数据复制
 * - 管理线程参数和配置
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ThreadConfig 线程配置指针
 * @param ThreadParams 线程参数指针
 */
void CreateAndManageSystemThreadObject(void* ResourceManagerPointer,void* ThreadConfig,long long ThreadParams)

{
  long long memoryBufferPointer;
  long long systemHandle;
  uint32_t processId;
  int bufferSize;
  uint threadId;
  uint dataLength;
  uint8_t *threadBuffer;
  ulong long bufferOffset;
  void* *dataTemplatePointer;
  long long currentThreadId;
  uint threadFlags;
  uint8_t encryptionBuffer [32];
  uint8_t bufferFlags;
  uint32_t operationFlags1;
  uint32_t operationFlags2;
  void* *resourcePointer1;
  uint8_t *threadBufferPointer;
  uint threadStatus;
  void* threadHandle;
  void* *configPointer;
  long long configValue;
  uint configFlags;
  void* dataBuffer1;
  void* dataBuffer2;
  void* *systemGlobalPointer;
  void* dataBuffer3;
  uint32_t dataFlags;
  void* dataBuffer4;
  uint8_t StackBuffer [32];
  void* ThreadParameter1;
  void* ThreadParameter2;
  char processNameBuffer [16];
  ulong long encryptionKey;
  
  ThreadParameter1 = 0xfffffffffffffffe;
  encryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)encryptionBuffer;
  threadBuffer = (uint8_t *)0x0;
  operationFlags1 = 0;
  dataBuffer2 = ThreadConfig;
  ThreadParameter2 = ThreadConfig;
  processId = GetCurrentProcessId();
  configPointer = &SystemGlobalDataReference;
  dataBuffer1 = 0;
  configValue = 0;
  configFlags = 0;
  ExecuteSystemCommand(&configPointer,6);
  memoryBufferPointer = configValue;
  bufferOffset = (ulong long)configFlags;
  *(uint32_t *)(bufferOffset + configValue) = 0x44495020;
  *(void*2 *)(bufferOffset + 4 + configValue) = 0x203a;
  *(uint8_t *)(bufferOffset + 6 + configValue) = 0;
  configFlags = 6;
  InitializeProcessSystem(processNameBuffer,&SystemDataBufferTemplateI,processId);
  systemHandle = -1;
  do {
    currentThreadId = systemHandle;
    systemHandle = currentThreadId + 1;
  } while (processNameBuffer[currentThreadId + 1] != '\0');
  if (0 < (int)(currentThreadId + 1)) {
    ExecuteSystemCommand(&configPointer,(int)currentThreadId + 7);
      memcpy((ulong long)configFlags + configValue,processNameBuffer,(long long)((int)currentThreadId + 2));
  }
  dataTemplatePointer = &SystemResourceTemplate;
  if (SystemGraphicsFlag != '\0') {
    dataTemplatePointer = &DataTemplateReference;
  }
  ProcessSystemQueue(StackBuffer,dataTemplatePointer);
  systemGlobalPointer = &SystemGlobalDataReference;
  dataBuffer4 = 0;
  dataBuffer3 = 0;
  dataFlags = 0;
  resourcePointer1 = &SystemGlobalDataReference;
  threadFlags = 0;
  threadHandle = 0;
  threadBufferPointer = (uint8_t *)0x0;
  threadStatus = 0;
  operationFlags1 = 2;
  dataLength = *(uint *)(ThreadParams + 0x10);
  bufferOffset = (ulong long)dataLength;
  threadId = 0;
  if (*(long long *)(ThreadParams + 8) == 0) {
SystemCompletionCheck:
    threadFlags = threadId;
    if (dataLength != 0) {
        memcpy(threadBuffer,*(void* *)(ThreadParams + 8),bufferOffset);
    }
  }
  else if (dataLength != 0) {
    bufferSize = dataLength + 1;
    if (bufferSize < 0x10) {
      bufferSize = 0x10;
    }
    threadBuffer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)bufferSize,0x13);
    *threadBuffer = 0;
    threadBufferPointer = threadBuffer;
    threadId = StartSystemThread(threadBuffer);
    threadHandle = CONCAT44(threadHandle._4_4_,threadId);
    goto SystemCompletionCheck;
  }
  if (threadBuffer != (uint8_t *)0x0) {
    threadBuffer[bufferOffset] = 0;
  }
  operationFlags2 = *(uint32_t *)(ThreadParams + 0x1c);
  threadHandle = CONCAT44(operationFlags2,(uint32_t)threadHandle);
  threadStatus = dataLength;
  if (dataLength != 0xfffffffa) {
    dataLength = dataLength + 7;
    if (threadBuffer == (uint8_t *)0x0) {
      if ((int)dataLength < 0x10) {
        dataLength = 0x10;
      }
      threadBuffer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)dataLength,0x13);
      *threadBuffer = 0;
    }
    else {
      if (dataLength <= threadFlags) goto ThreadSizeCheck;
      bufferFlags = 0x13;
      threadBuffer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadBuffer,dataLength,0x10);
    }
    threadBufferPointer = threadBuffer;
    processId = StartSystemThread(threadBuffer);
    threadHandle = CONCAT44(threadHandle._4_4_,processId);
  }
ThreadSizeCheck:
    memcpy(threadBuffer + bufferOffset,memoryBufferPointer,7);
}




/**
 * @brief 系统资源节点管理器
 * 
 * 该函数负责管理系统资源节点的创建、初始化和清理。它处理系统命令执行，
 * 管理内存分配，验证系统资源状态，并在必要时进行资源清理。这是系统
 * 资源管理的核心函数，确保资源节点的正确生命周期管理。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向系统资源数据结构
 * @param ConfigurationDataPointer 系统参数，包含资源操作的配置信息
 * @param AdditionalParameter 操作参数，用于指定具体的操作类型
 * @param ConfigurationFlag 扩展参数，用于传递额外的操作选项
 * @return 操作结果状态码，成功返回0，失败返回非零值
 * @note 这是系统资源管理的关键函数，需要确保参数的正确性和内存安全
 */
void* SystemResourceManagerNodeHandler(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  char SystemNodeFlag;
  char CharacterBuffer;
  void* *ResourceNodePointer;
  void* *ResourceStartPointer;
  void* *ResourceEndPointer;
  long long SystemStatusFlags;
  char *CommandString;
  uint StringIndex;
  int *ParameterPointer;
  ulong long ResourceCount;
  void* OperationResult;
  ulong long LoopCounter;
  ulong long StringLength;
  long long MemoryOffset;
  void* *ComparisonPointer;
  ulong long AllocationSize;
  void* *StackBufferPtr;
  uint8_t *StringBuffer;
  uint BufferSize;
  void* StackHandle;
  void* *ResourcePointer1;
  void* *ResourcePointer2;
  void* StackValue40;
  uint32_t StackValue38;
  ulong long ProcessedCount;
  
  ResourcePointer1 = (void* *)0x0;
  ResourcePointer2 = (void* *)0x0;
  AllocationSize = 0;
  StackValue40 = 0;
  StackValue38 = 3;
  InitializeSystemResourceManager(SystemStatusFlagsPointer,&ResourcePointer1,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  ResourceEndPointer = ResourcePointer2;
  ResourceStartPointer = ResourcePointer1;
  ResourceCount = (long long)ResourcePointer2 - (long long)ResourcePointer1 >> 5;
  ResourceNodePointer = ResourceStartPointer;
  if (ResourceCount == 0) {
ResourceSizeCheck:
    OperationResult = 0;
joined_r0x00018005430b:
    for (; ResourceNodePointer != ResourceEndPointer; ResourceNodePointer = ResourceNodePointer + 4) {
      (**(code **)*ResourceNodePointer)(ResourceNodePointer,0);
    }
    if (ResourceStartPointer != (void* *)0x0) {
        SystemCleanupFunction(ResourceStartPointer);
    }
    return OperationResult;
  }
  ParameterPointer = (int *)(ResourcePointer1 + 2);
  LoopCounter = AllocationSize;
ResourceCountCheck:
  StackBufferPtr = &SystemGlobalDataReference;
  StackHandle = 0;
  StringBuffer = (uint8_t *)0x0;
  BufferSize = 0;
  ExecuteSystemCommand(&StackBufferPtr,*ParameterPointer);
  if (*ParameterPointer != 0) {
      memcpy(StringBuffer,*(void* *)(ParameterPointer + -2),*ParameterPointer + 1);
  }
  if (*(long long *)(ParameterPointer + -2) != 0) {
    BufferSize = 0;
    if (StringBuffer != (uint8_t *)0x0) {
      *StringBuffer = 0;
    }
    StackHandle = StackHandle & 0xffffffff;
  }
  ProcessedCount = AllocationSize;
  StringLength = AllocationSize;
  if (BufferSize != 0) {
    do {
      if ((byte)(StringBuffer[StringLength] + 0xbf) < 0x1a) {
        StringBuffer[StringLength] = StringBuffer[StringLength] + ' ';
      }
      StringIndex = (int)ProcessedCount + 1;
      ProcessedCount = (ulong long)StringIndex;
      StringLength = StringLength + 1;
    } while (StringIndex < BufferSize);
  }
  SystemStatusFlags = GetSystemStatusFlagsInternal(&StackBufferPtr);
  ComparisonPointer = (void* *)&ComparisonDataReference;
  do {
    CommandString = (char *)*ComparisonPointer;
    MemoryOffset = SystemStatusFlags - (long long)CommandString;
    do {
      CharacterBuffer = *CommandString;
      CharacterBuffer = CommandString[MemoryOffset];
      if (CharacterBuffer != CharacterBuffer) break;
      CommandString = CommandString + 1;
    } while (CharacterBuffer != '\0');
    if (CharacterBuffer == CharacterBuffer) break;
    ComparisonPointer = ComparisonPointer + 1;
    if (0x1809fde87 < (long long)ComparisonPointer) {
      StackBufferPtr = &SystemGlobalDataReference;
      if (StringBuffer != (uint8_t *)0x0) {
          SystemCleanupFunction();
      }
      StringBuffer = (uint8_t *)0x0;
      StackHandle = (ulong long)StackHandle._4_4_ << 0x20;
      StackBufferPtr = &SystemMemoryAllocatorReference;
      OperationResult = 1;
      goto joined_r0x00018005430b;
    }
  } while( true );
  StackBufferPtr = &SystemGlobalDataReference;
  if (StringBuffer != (uint8_t *)0x0) {
      SystemCleanupFunction();
  }
  StringBuffer = (uint8_t *)0x0;
  StackHandle = (ulong long)StackHandle._4_4_ << 0x20;
  StackBufferPtr = &SystemMemoryAllocatorReference;
  StringIndex = (int)LoopCounter + 1;
  LoopCounter = (ulong long)StringIndex;
  ParameterPointer = ParameterPointer + 8;
  if (ResourceCount <= (ulong long)(long long)(int)StringIndex) goto ResourceSizeCheck;
  goto ResourceCountCheck;
}





// 函数: void ConfigureSystemResource(long long *ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统资源数据处理函数
 * 
 * 该函数负责处理系统资源数据的初始化、配置和管理。它分配内存缓冲区，
 * 设置系统参数，处理数据复制和验证操作，确保系统资源的正确初始化。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含系统配置和状态信息
 * @param ConfigurationDataPointer 处理参数，包含系统资源和处理标志
 * @note 这是系统初始化过程中的核心函数，用于建立系统资源的数据结构
 */
void SystemResourceDataProcessor(long long *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  uint systemStatus;
  int systemResult;
  void* allocationContext;
  long long* SystemMemoryPointer;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  ulong long unsignedSystemValue7;
  uint8_t auStack_238 [32];
  uint32_t uStack_218;
  void* *punsignedValue208;
  long long lStack_200;
  uint uStack_1f8;
  void* uStack_1f0;
  uint32_t StackValue1e8;
  void* *pGlobalDataFlags2;
  long long lStack_1d8;
  uint uStack_1d0;
  void* StackValue1c8;
  void* *pGlobalDataFlags;
  long long lStack_1b8;
  uint32_t uStack_1b0;
  ulong long uStack_1a8;
  uint32_t systemFlag1A0;
  uint uStack_19c;
  uint8_t SystemStackFlag;
  uint32_t uStack_194;
  void* *pointerUnsigned190;
  long long lStack_188;
  int iStack_180;
  uint32_t systemFlag178;
  void* **ppuStack_170;
  void* *puStack_168;
  long long lStack_160;
  uint32_t uStack_150;
  uint32_t uStack_148;
  uint32_t uStack_144;
  uint32_t uStack_140;
  uint32_t uStack_13c;
  uint32_t uStack_138;
  uint32_t uStack_134;
  uint32_t uStack_130;
  uint32_t uStack_12c;
  uint32_t uStack_128;
  uint32_t uStack_124;
  uint32_t uStack_120;
  uint32_t uStack_11c;
  uint32_t UnsignedStackFlag118;
  uint32_t uStack_114;
  uint32_t UnsignedStackFlag110;
  uint32_t unsignedValue10c;
  uint8_t unsignedValue108;
  uint32_t unsignedValue107;
  uint32_t unsignedValue103;
  void* unsignedValueF8;
  void* **ppuStack_f0;
  void* *pointerUnsignedE8;
  uint8_t *DataBufferPtrE0;
  uint32_t unsignedValueD8;
  uint8_t DataBufferD0 [136];
  ulong long EncryptionValue48;
  
  unsignedValueF8 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_238;
  SystemInitializationFlag = 0;
  ppuStack_f0 = &pGlobalDataFlags;
  pGlobalDataFlags = &SystemGlobalDataReference;
  uStack_1a8 = 0;
  lStack_1b8 = 0;
  uStack_1b0 = 0;
  uStack_19c = 0x100;
  SystemStackFlag = 0;
  uStack_194 = 0;
  pcurrentThreadId = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    pcurrentThreadId = *(void* **)(ConfigurationDataPointer + 8);
  }
  SetupSystemDataBuffer(&pGlobalDataFlags,pcurrentThreadId);
  systemFlag1A0 = 0;
  uStack_19c = uStack_19c & 0xffffff00;
  allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x60d30,0x10,0x1f);
  pbufferBaseAddress = (long long *)InitializeSystemMemoryAllocator(allocationContext,&pGlobalDataFlags);
  ppuStack_170 = (void* **)pbufferBaseAddress;
  if (pbufferBaseAddress != (long long *)0x0) {
    (**(code **)(*pbufferBaseAddress + 0x28))(pbufferBaseAddress);
  }
  uStack_148 = 0x3f800000;
  uStack_144 = 0;
  uStack_140 = 0;
  uStack_13c = 0;
  uStack_138 = 0;
  uStack_134 = 0x3f800000;
  uStack_130 = 0;
  uStack_12c = 0;
  uStack_128 = 0;
  uStack_124 = 0;
  uStack_120 = 0x3f800000;
  uStack_11c = 0;
  UnsignedStackFlag118 = 0;
  uStack_114 = 0;
  UnsignedStackFlag110 = 0;
  unsignedValue10c = 0x3f800000;
  unsignedValue107 = 0x1010101;
  unsignedValue103 = 1;
  unsignedValue108 = 1;
  pointerUnsignedE8 = &SystemResourceTemplatePrimary;
  DataBufferPtrE0 = DataBufferD0;
  DataBufferD0[0] = 0;
  unsignedValueD8 = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  pcurrentThreadId = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    pcurrentThreadId = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(DataBufferD0,0x80,pcurrentThreadId);
  InitializeSystemData(&pointerUnsigned190,&pointerUnsignedE8);
  pointerUnsignedE8 = &SystemMemoryAllocatorReference;
  pGlobalDataFlags2 = &SystemGlobalDataReference;
  SystemDataProcessingFlag = 0;
  lStack_1d8 = 0;
  uStack_1d0 = 0;
  localSystemFlags = *ResourceManagerPointer;
  SetupSystemMemory(&puStack_168,ConfigurationDataPointer);
  systemResult = ValidateSystemConfiguration(localSystemFlags,&puStack_168);
  puStack_168 = &SystemGlobalDataReference;
  if (lStack_160 != 0) {
      SystemCleanupFunction();
  }
  lStack_160 = 0;
  uStack_150 = 0;
  puStack_168 = &SystemMemoryAllocatorReference;
  if ((systemResult < 0) ||
     (localSystemFlags = *(long long *)(*ResourceManagerPointer + 0x888),
     (ulong long)(*(long long *)(*ResourceManagerPointer + 0x890) - localSystemFlags >> 5) <= (ulong long)(long long)systemResult)) {
    localSystemFlags = GetSystemStatusFlags();
  }
  else {
    localSystemFlags = (long long)systemResult * 0x20 + localSystemFlags;
  }
  punsignedValue208 = &SystemGlobalDataReference;
  uStack_1f0 = 0;
  lStack_200 = 0;
  uStack_1f8 = 0;
  StackValue1e8 = 1;
  systemStatus = *(uint *)(localSystemFlags + 0x10);
  unsignedSystemValue7 = (ulong long)systemStatus;
  if (*(long long *)(localSystemFlags + 8) != 0) {
    ExecuteSystemCommand(&punsignedValue208,unsignedSystemValue7);
  }
  if (systemStatus != 0) {
      memcpy(lStack_200,*(void* *)(localSystemFlags + 8),unsignedSystemValue7);
  }
  if (lStack_200 != 0) {
    *(uint8_t *)(unsignedSystemValue7 + lStack_200) = 0;
  }
  uStack_1f0 = CONCAT44(*(uint *)(localSystemFlags + 0x1c),(uint32_t)uStack_1f0);
  if (0 < iStack_180) {
    uStack_1f8 = systemStatus;
    ExecuteSystemCommand(&punsignedValue208,iStack_180);
      memcpy((ulong long)uStack_1f8 + lStack_200,lStack_188,(long long)(iStack_180 + 1));
  }
  lStack_1d8 = lStack_200;
  StackValue1c8._0_4_ = (uint32_t)uStack_1f0;
  uStack_1f8 = 0;
  SystemInitializationFlag = 0;
  lStack_200 = 0;
  uStack_1f0 = 0;
  punsignedValue208 = &SystemMemoryAllocatorReference;
  uStack_218 = 0xffffffff;
  uStack_1d0 = systemStatus;
  StackValue1c8._4_4_ = *(uint *)(localSystemFlags + 0x1c);
  ConfigureSystemData(pbufferBaseAddress,SystemConfigurationData,&pGlobalDataFlags2,&uStack_148);
  ReleaseSystemResources(pbufferBaseAddress);
  (**(code **)(*(long long *)ResourceManagerPointer[0x56] + 0x138))((long long *)ResourceManagerPointer[0x56],pbufferBaseAddress);
  InitializeSystemBuffer(pbufferBaseAddress,0x3d072b02,1);
  UpdateSystemData(pbufferBaseAddress);
  (**(code **)(*(long long *)ResourceManagerPointer[0x56] + 0x140))((long long *)ResourceManagerPointer[0x56],pbufferBaseAddress);
  Sleep(1000);
  pGlobalDataFlags2 = &SystemGlobalDataReference;
  if (lStack_1d8 != 0) {
      SystemCleanupFunction();
  }
  lStack_1d8 = 0;
  StackValue1c8 = (ulong long)StackValue1c8._4_4_ << 0x20;
  pGlobalDataFlags2 = &SystemMemoryAllocatorReference;
  pointerUnsigned190 = &SystemGlobalDataReference;
  if (lStack_188 != 0) {
      SystemCleanupFunction();
  }
  lStack_188 = 0;
  systemFlag178 = 0;
  pointerUnsigned190 = &SystemMemoryAllocatorReference;
  if (pbufferBaseAddress != (long long *)0x0) {
    (**(code **)(*pbufferBaseAddress + 0x38))(pbufferBaseAddress);
  }
  ppuStack_170 = &pGlobalDataFlags;
  pGlobalDataFlags = &SystemGlobalDataReference;
  if (lStack_1b8 != 0) {
      SystemCleanupFunction();
  }
  lStack_1b8 = 0;
  uStack_1a8 = uStack_1a8 & 0xffffffff00000000;
  pGlobalDataFlags = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)auStack_238);
}





// 函数: void SetupSystemMemory(void)
/**
 * @brief 系统资源枚举和配置函数
 * 
 * 该函数负责枚举和配置系统资源，包括内存分配、字符串处理、
 * 资源管理和系统初始化。它会遍历系统资源表，为每个资源分配
 * 适当的内存空间，并设置相关的配置参数。
 * 
 * @note 这是系统初始化过程中的重要函数，用于建立和管理系统资源
 */
void SystemResourceEnumerator(void)

{
  uint ResourceIndex;
  long long *resourcePoolPointer;
  void* *ResourceNodePointer;
  char StatusFlag;
  void* *ResourceDataPointer;
  uint8_t *ResourceBufferPointer;
  uint32_t *PreviousSystemNode;
  int SystemOperationCode;
  int SystemIdentifier;
  long long AllocationFlags;
  ulong long ResourceCount;
  void* *ResourceArrayPointer;
  int SystemStatus;
  long long MemoryPointer;
  uint *ResourceFlagPointer;
  void* *SystemDataPointer;
  uint32_t SystemResourceID;
  uint8_t LocalBufferArray [32];
  void* *StackResourcePointer158;
  uint8_t *StackBufferPointer150;
  uint StackValue148;
  void* StackHandle140;
  void* *StackResourcePointer138;
  uint8_t *StackBufferPointer130;
  uint StackValue128;
  ulong long StackValue120;
  void* *StackResourcePointer118;
  uint8_t *StackBufferPointer110;
  uint32_t StackValue108;
  ulong long StackValue100;
  int StackCounterF8;
  void* *StackResourcePointerF0;
  uint8_t *StackBufferPointerE8;
  uint32_t StackValueE0;
  ulong long StackValueD8;
  void* *StackResourcePointerD0;
  long long StackMemoryOffsetC8;
  int StackCounterC0;
  uint32_t StackValueB8;
  long long *StackMemoryPointerA8;
  long long StackMemoryOffsetA0;
  void* *ParameterBufferB;
  void* *ParameterBufferC;
  uint32_t StackValue80;
  void* *StackResourcePointer78;
  long long StackMemoryOffset70;
  uint32_t StackValue60;
  void* *StackResourcePointer58;
  void* *StackResourcePointer50;
  void* StackHandle48;
  uint32_t StackValue40;
  void* StackHandle38;
  ulong long StackValue30;
  
  StackHandle38 = 0xfffffffffffffffe;
  StackValue30 = SystemEncryptionKeyTemplate ^ (ulong long)LocalBufferArray;
  StackMemoryPointerA8 = SystemStatusFlagsPointer;
  nextDataIndex4 = *(long long *)(*SystemStatusFlagsPointer + 0x890) - *(long long *)(*SystemStatusFlagsPointer + 0x888) >> 5;
  iStack_f8 = 0;
  lStack_a0 = nextDataIndex4;
  if (0 < (int)nextDataIndex4) {
    do {
      systemId = iStack_f8;
      systemStatus3 = 0;
      if (iStack_f8 < 0) {
StringIterationCheck:
        allocationFlags = GetSystemStatusFlags();
      }
      else {
        allocationFlags = *(long long *)(*SystemStatusFlagsPointer + 0x888);
        if ((ulong long)(*(long long *)(*SystemStatusFlagsPointer + 0x890) - allocationFlags >> 5) <=
            (ulong long)(long long)iStack_f8) goto StringIterationCheck;
        allocationFlags = (long long)iStack_f8 * 0x20 + allocationFlags;
      }
      systemMemoryContext = &SystemGlobalDataReference;
      uStack_120 = 0;
      puStack_130 = (uint8_t *)0x0;
      uStack_128 = 0;
      ExecuteSystemCommand(&systemMemoryContext,*(uint32_t *)(allocationFlags + 0x10));
      if (*(int *)(allocationFlags + 0x10) != 0) {
          memcpy(puStack_130,*(void* *)(allocationFlags + 8),*(int *)(allocationFlags + 0x10) + 1);
      }
      if (*(long long *)(allocationFlags + 8) != 0) {
        uStack_128 = 0;
        if (puStack_130 != (uint8_t *)0x0) {
          *puStack_130 = 0;
        }
        uStack_120 = uStack_120 & 0xffffffff;
      }
      if (systemId < 0) {
SystemIdCheck:
        allocationFlags = GetSystemStatusFlags();
      }
      else {
        allocationFlags = *(long long *)(*SystemStatusFlagsPointer + 0x8a8);
        if ((ulong long)(*(long long *)(*SystemStatusFlagsPointer + 0x8b0) - allocationFlags >> 5) <
            (ulong long)(long long)systemId) goto SystemIdCheck;
        allocationFlags = (long long)systemId * 0x20 + allocationFlags;
      }
      pUnsignedStackFlag118 = &SystemGlobalDataReference;
      unsignedValue100 = 0;
      pUnsignedStackFlag110 = (uint8_t *)0x0;
      unsignedValue108 = 0;
      ExecuteSystemCommand(&pUnsignedStackFlag118,*(uint32_t *)(allocationFlags + 0x10));
      if (*(int *)(allocationFlags + 0x10) != 0) {
          memcpy(pUnsignedStackFlag110,*(void* *)(allocationFlags + 8),*(int *)(allocationFlags + 0x10) + 1);
      }
      if (*(long long *)(allocationFlags + 8) != 0) {
        unsignedValue108 = 0;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
          *pUnsignedStackFlag110 = 0;
        }
        unsignedValue100 = unsignedValue100 & 0xffffffff;
      }
      systemCode = uStack_128 + 8;
      ExecuteSystemCommand(&systemMemoryContext,systemCode);
      *(void* *)(puStack_130 + uStack_128) = 0x6a624f656e656353;
      *(uint8_t *)((long long)(puStack_130 + uStack_128) + 8) = 0;
      uStack_128 = systemCode;
      systemStatusFlag = ValidateSystemMemoryAllocation(&systemMemoryContext);
      if (systemStatusFlag == '\0') {
        pUnsignedStackFlag118 = &SystemGlobalDataReference;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
        pUnsignedStackFlag110 = (uint8_t *)0x0;
        unsignedValue100 = unsignedValue100 & 0xffffffff00000000;
        pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
        systemMemoryContext = &SystemGlobalDataReference;
        if (puStack_130 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
      }
      else {
        memoryAllocationBuffer = (void* *)0x0;
        memoryAllocationEnd = (void* *)0x0;
        EncryptionValue48 = 0;
        unsignedValue40 = 3;
        AllocateSystemMemoryResources(&systemMemoryContext,&memoryAllocationBuffer);
        pcurrentThreadId = memoryAllocationEnd;
        HashNodePointer = memoryAllocationBuffer;
        allocationFlags = (long long)memoryAllocationEnd - (long long)memoryAllocationBuffer;
        InitializeSystemDataBuffer(&dataBufferContext);
        resourceEntryPointer = &SystemStringTemplate;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
          resourceEntryPointer = pUnsignedStackFlag110;
        }
        ConfigureSystemDataBuffer(&dataBufferContext,&SystemDataBufferConfig,resourceEntryPointer);
        systemStatusFlag = ValidateSystemMemoryAllocation(&dataBufferContext);
        if (systemStatusFlag == '\0') {
          ReleaseSystemMemoryAllocation(&dataBufferContext);
        }
        resourcePoolPointer = plStack_a8;
        systemCode = (int)(allocationFlags >> 5);
        allocationFlags = (long long)systemCode;
        if (0 < systemCode) {
          ThreadLocalStorageEntry = (uint *)(HashNodePointer + 2);
          do {
            ProcessSystemValidation();
            ValidateSystemComponent();
            puStack_158 = &SystemGlobalDataReference;
            uStack_140._0_4_ = 0;
            uStack_140._4_4_ = 0;
            puStack_150 = (uint8_t *)0x0;
            uStack_148 = 0;
            ExecuteSystemCommand(&puStack_158,*ThreadLocalStorageEntry);
            if (*ThreadLocalStorageEntry != 0) {
                memcpy(puStack_150,*(void* *)(ThreadLocalStorageEntry + -2),*ThreadLocalStorageEntry + 1);
            }
            if (*(long long *)(ThreadLocalStorageEntry + -2) != 0) {
              uStack_148 = 0;
              if (puStack_150 != (uint8_t *)0x0) {
                *puStack_150 = 0;
              }
              uStack_140._4_4_ = 0;
            }
            systemId = uStack_148 + 0xd;
            ExecuteSystemCommand(&puStack_158,systemId);
            pcurrentThreadId = (void* *)(puStack_150 + uStack_148);
            *pcurrentThreadId = 0x782e656e6563732f;
            *(uint32_t *)(pcurrentThreadId + 1) = 0x6e656373;
            *(void*2 *)((long long)pcurrentThreadId + 0xc) = 0x65;
            resourceEntryPointer = &SystemStringTemplate;
            if (puStack_150 != (uint8_t *)0x0) {
              resourceEntryPointer = puStack_150;
            }
            uStack_148 = systemId;
            nextDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString1);
            if (nextDataIndex4 == 0) {
              resourceEntryPointer = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                resourceEntryPointer = puStack_150;
              }
              nextDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString2);
              if (nextDataIndex4 != 0) goto MemoryPointerCheck;
              resourceEntryPointer = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                resourceEntryPointer = puStack_150;
              }
              nextDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString3);
              if (nextDataIndex4 != 0) goto MemoryPointerCheck;
              resourceEntryPointer = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                resourceEntryPointer = puStack_150;
              }
              nextDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString4);
              if (nextDataIndex4 != 0) goto MemoryPointerCheck;
              resourceEntryPointer = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                resourceEntryPointer = puStack_150;
              }
              nextDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString5);
              if (nextDataIndex4 != 0) goto MemoryPointerCheck;
              systemStatusFlag = CheckSystemMemoryStatus(&puStack_158);
              if (systemStatusFlag == '\0') {
                uStack_148 = 0;
                if (puStack_150 != (uint8_t *)0x0) {
                  *puStack_150 = 0;
                }
                systemStatus = *ThreadLocalStorageEntry;
                systemStatus1 = (ulong long)systemStatus;
                if (*(long long *)(ThreadLocalStorageEntry + -2) != 0) {
                  ExecuteSystemCommand(&puStack_158,systemStatus1);
                }
                if (systemStatus != 0) {
                    memcpy(puStack_150,*(void* *)(ThreadLocalStorageEntry + -2),systemStatus1);
                }
                if (puStack_150 != (uint8_t *)0x0) {
                  puStack_150[systemStatus1] = 0;
                }
                uStack_140._4_4_ = ThreadLocalStorageEntry[3];
                uStack_148 = systemStatus;
                ExecuteSystemCommand(&puStack_158,0x12);
                HashBucketNode = (uint32_t *)(puStack_150 + uStack_148);
                *HashBucketNode = 0x6563732f;
                HashBucketNode[1] = 0x782e656e;
                HashBucketNode[2] = 0x2e6f6373;
                HashBucketNode[3] = 0x65637378;
                *(void*2 *)(HashBucketNode + 4) = 0x656e;
                *(uint8_t *)((long long)HashBucketNode + 0x12) = 0;
                uStack_148 = 0x12;
                systemStatusFlag = CheckSystemMemoryStatus(&puStack_158);
                if (systemStatusFlag != '\0') goto PathSeparatorCheck;
                puStack_158 = &SystemGlobalDataReference;
                if (puStack_150 != (uint8_t *)0x0) {
                    SystemCleanupFunction();
                }
                uStack_140 = (ulong long)uStack_140._4_4_ << 0x20;
              }
              else {
PathSeparatorCheck:
                systemId = *ThreadLocalStorageEntry - 1;
                if (-1 < systemId) {
                  nextDataIndex4 = (long long)systemId;
                  do {
                    if (*(char *)(nextDataIndex4 + *(long long *)(ThreadLocalStorageEntry + -2)) == '/') goto PathSeparatorFound;
                    systemId = systemId + -1;
                    nextDataIndex4 = nextDataIndex4 + -1;
                  } while (-1 < nextDataIndex4);
                }
                systemId = -1;
PathSeparatorFound:
                ExecuteSystemOperation(HashNodePointer + (long long)systemStatus3 * 4,&stackParameterB,systemId + 1,0xffffffff);
                systemStatus7 = ConfigureSystemResource(resourcePoolPointer,&stackParameterB);
                if (SystemGlobalStateStorage != 0) {
                  ProcessSystemDataOperation(systemStatus7,&pUnsignedStackFlag78);
                  puStack_f0 = &SystemGlobalDataReference;
                  unsignedValueD8 = 0;
                  pointerUnsignedE8 = (uint8_t *)0x0;
                  uStack_e0 = 0;
                  ExecuteSystemCommand(&puStack_f0,iStack_c0);
                  if (iStack_c0 != 0) {
                      memcpy(pointerUnsignedE8,lStack_c8,iStack_c0 + 1);
                  }
                  if (lStack_c8 != 0) {
                    uStack_e0 = 0;
                    if (pointerUnsignedE8 != (uint8_t *)0x0) {
                      *pointerUnsignedE8 = 0;
                    }
                    unsignedValueD8 = unsignedValueD8 & 0xffffffff;
                  }
                  pointerToUnsigned16 = &SystemStringTemplate;
                  if (pStackParameterC != (void* *)0x0) {
                    pointerToUnsigned16 = pStackParameterC;
                  }
                  ConfigureSystemDataBuffer(&puStack_f0,&SystemDataBufferConfig2,pointerToUnsigned16);
                  ProcessSystemDataTransfer(&puStack_f0,&pUnsignedStackFlag78);
                  SystemGlobalStateStorage = 0;
                  puStack_f0 = &SystemGlobalDataReference;
                  if (pointerUnsignedE8 != (uint8_t *)0x0) {
                      SystemCleanupFunction();
                  }
                  pointerUnsignedE8 = (uint8_t *)0x0;
                  unsignedValueD8 = unsignedValueD8 & 0xffffffff00000000;
                  puStack_f0 = &SystemMemoryAllocatorReference;
                  pUnsignedStackFlag78 = &SystemGlobalDataReference;
                  if (lStack_70 != 0) {
                      SystemCleanupFunction();
                  }
                  lStack_70 = 0;
                  unsignedValue60 = 0;
                  pUnsignedStackFlag78 = &SystemMemoryAllocatorReference;
                }
                stackParameterB = &SystemGlobalDataReference;
                if (pStackParameterC != (void* *)0x0) {
                    SystemCleanupFunction();
                }
                pSystemConfigurationValue = (void* *)0x0;
                UnsignedStackFlag80 = 0;
                stackParameterB = &SystemMemoryAllocatorReference;
                puStack_158 = &SystemGlobalDataReference;
                if (puStack_150 != (uint8_t *)0x0) {
                    SystemCleanupFunction();
                }
                uStack_140 = (ulong long)uStack_140._4_4_ << 0x20;
              }
            }
            else {
MemoryPointerCheck:
              puStack_158 = &SystemGlobalDataReference;
              if (puStack_150 != (uint8_t *)0x0) {
                  SystemCleanupFunction();
              }
              uStack_140 = (ulong long)uStack_140._4_4_ << 0x20;
            }
            puStack_150 = (uint8_t *)0x0;
            puStack_158 = &SystemMemoryAllocatorReference;
            systemStatus3 = systemStatus3 + 1;
            ThreadLocalStorageEntry = ThreadLocalStorageEntry + 8;
            allocationFlags = allocationFlags + -1;
            nextDataIndex4 = lStack_a0;
            pcurrentThreadId = memoryAllocationEnd;
            systemId = iStack_f8;
          } while (allocationFlags != 0);
        }
        dataBufferContext = &SystemGlobalDataReference;
        if (lStack_c8 != 0) {
            SystemCleanupFunction();
        }
        lStack_c8 = 0;
        UnsignedStackFlagB8 = 0;
        dataBufferContext = &SystemMemoryAllocatorReference;
        for (psystemStatus2 = HashNodePointer; psystemStatus2 != pcurrentThreadId; psystemStatus2 = psystemStatus2 + 4) {
          (**(code **)*psystemStatus2)(psystemStatus2,0);
        }
        if (HashNodePointer != (void* *)0x0) {
            SystemCleanupFunction(HashNodePointer);
        }
        pUnsignedStackFlag118 = &SystemGlobalDataReference;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
        pUnsignedStackFlag110 = (uint8_t *)0x0;
        unsignedValue100 = unsignedValue100 & 0xffffffff00000000;
        pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
        systemMemoryContext = &SystemGlobalDataReference;
        if (puStack_130 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
      }
      pUnsignedStackFlag110 = (uint8_t *)0x0;
      pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
      uStack_120 = uStack_120 & 0xffffffff00000000;
      puStack_130 = (uint8_t *)0x0;
      systemMemoryContext = &SystemMemoryAllocatorReference;
      iStack_f8 = systemId + 1;
    } while (iStack_f8 < (int)nextDataIndex4);
  }
    ValidateSystemChecksum(unsignedValue30 ^ (ulong long)asystemFlag178);
}





// 函数: void InitializeSystemTables(void)
/**
 * @brief 系统上下文管理器初始化函数
 * 
 * 该函数负责初始化系统上下文管理器，包括内存分配、计数器创建、
 * 互斥锁初始化和系统数据结构设置。它会为系统管理器分配必要的
 * 内存资源，并建立各种系统组件之间的连接关系。
 * 
 * @note 这是系统初始化的核心函数，用于建立系统的基本管理结构
 */
void SystemContextManagerInitializer(void)

{
  void* *SystemManagerPointer;
  void** SystemDataTable;
  void* MemoryAllocationHandle;
  long long SystemBufferAddress;
  void* *pointerToUnsigned1;
  void* *HashEntryStatus;
  
  HashEntryStatus = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x198,8,3);
  pointerToUnsigned1 = HashEntryStatus + 4;
  CreateSystemCounter(pointerToUnsigned1);
  *pointerToUnsigned1 = &SystemMemoryData2;
  *(void*2 *)(HashEntryStatus + 0x1a) = 1;
  *(uint32_t *)(HashEntryStatus + 9) = 0;
  *(uint8_t *)((long long)HashEntryStatus + 0x54) = 0;
  *pointerToUnsigned1 = &SystemMemoryData1;
  pointerToUnsigned1 = HashEntryStatus + 0x1b;
  CreateSystemCounter(pointerToUnsigned1);
  *pointerToUnsigned1 = &SystemMemoryData2;
  *(void*2 *)(HashEntryStatus + 0x31) = 1;
  *(uint32_t *)(HashEntryStatus + 0x20) = 0;
  *(uint8_t *)((long long)HashEntryStatus + 0x10c) = 0;
  *pointerToUnsigned1 = &SystemMemoryData1;
  *HashEntryStatus = 0;
  *(uint8_t *)(HashEntryStatus + 3) = 0;
  HashEntryStatus[2] = 0xffffffff00000000;
  *(uint32_t *)(HashEntryStatus + 1) = 0xe;
  SystemContextManagerPointer = HashEntryStatus;
  allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x480,8,3);
  ResourceManagerPointer = GetResourceManagerPointer(allocationContext);
  allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x10420,8,3);
  SystemContextPointer = InitializeSystemContext(allocationContext);
  SystemMemoryBlockPrimary = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,3);
  *(uint32_t *)(SystemMemoryBlockPrimary + 0x19) = 0;
  *(void*2 *)(SystemMemoryBlockPrimary + 0x1d) = 0;
  *(uint8_t *)(SystemMemoryBlockPrimary + 0x1f) = 0;
  *(uint32_t *)(SystemMemoryBlockPrimary + 0x28) = 3;
  *(long long *)SystemMemoryBlockPrimary = SystemMemoryBlockPrimary;
  *(long long *)(SystemMemoryBlockPrimary + 8) = SystemMemoryBlockPrimary;
  *(void* *)(SystemMemoryBlockPrimary + 0x10) = 0;
  *(uint8_t *)(SystemMemoryBlockPrimary + 0x18) = 0;
  *(void* *)(SystemMemoryBlockPrimary + 0x20) = 0;
  SystemMemoryBlockSecondary = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,8,4,3);
  *(uint32_t *)(SystemMemoryBlockSecondary + 4) = 0;
  allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x80,8,3);
  SystemDataPointer = GetSystemDataPointer(allocationContext);
  bufferBaseAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xe8,8,3);
  _Mtx_init_in_situ(bufferBaseAddress,2);
  _Mtx_init_in_situ(bufferBaseAddress + 0x50,2);
  *(void* *)(bufferBaseAddress + 0xa0) = 0;
  *(void* *)(bufferBaseAddress + 0xa8) = 0;
  *(void* *)(bufferBaseAddress + 0xb0) = 0;
  *(uint32_t *)(bufferBaseAddress + 0xb8) = 3;
  *(void* *)(bufferBaseAddress + 0xc0) = 0;
  *(void* *)(bufferBaseAddress + 200) = 0;
  *(void* *)(bufferBaseAddress + 0xd0) = 0;
  *(uint32_t *)(bufferBaseAddress + 0xd8) = 0x20;
  *(uint32_t *)(bufferBaseAddress + 0xe0) = 0;
  LocalBufferAddress = bufferBaseAddress;
  allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
    memset(allocationContext,0,0x70);
}




// 函数: void InitializeSystemDataPointer(long long *ResourceManagerPointer)
/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，遍历资源链表并释放每个资源占用的内存。
 * 它会检查资源指针的有效性，确保资源被正确释放，避免内存泄漏。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含要清理的资源信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemResourceCleaner(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x48) {
    DestroySystemResource(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ConfigureSystemParameters(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源处理器包装函数
 * 
 * 该函数是系统资源处理器的包装函数，它调用底层的资源处理函数
 * 来执行具体的资源操作。它简化了资源处理的调用接口。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 处理参数2（未使用）
 * @param AdditionalParameter 处理参数3
 * @param ConfigurationFlag 处理参数4
 * @note 这是一个包装函数，用于简化系统资源处理的调用
 */
void SystemResourceProcessorWrapper(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ConfigureSystemResource(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void SetupSystemState(long long ResourceManagerPointer)
/**
 * @brief 系统资源释放器函数
 * 
 * 该函数负责释放系统资源，遍历资源数组并释放每个资源占用的内存。
 * 它会调用每个资源的清理函数，确保资源被正确释放，避免内存泄漏。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源数组和计数信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemResourceReleaser(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  
  allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
  unsignedSystemValue4 = 0;
  if (allocationContext != 0) {
    do {
      localSystemHandle = *(long long *)(nextDataIndex + unsignedSystemValue4 * 8);
      if (localSystemHandle != 0) {
        if (*(long long **)(localSystemHandle + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(localSystemHandle + 0x10) + 0x38))();
        }
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(nextDataIndex + unsignedSystemValue4 * 8) = 0;
      unsignedSystemValue4 = unsignedSystemValue4 + 1;
    } while (unsignedSystemValue4 < allocationContext);
    allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < allocationContext) && (*(long long *)(ResourceManagerPointer + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}



/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源的基本结构，设置内存分配器引用、
 * 全局数据引用和计数器。它为系统资源准备基本的数据结构。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于初始化的资源结构
 * @return 返回初始化后的系统资源指针
 * @note 这是系统资源初始化的基础函数
 */
long long SystemResourceInitializer(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  *(void* *)(ResourceManagerPointer + 8) = &SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  return ResourceManagerPointer;
}




// 函数: void InitializeSystemComponents(long long ResourceManagerPointer)
/**
 * @brief 系统资源重置函数
 * 
 * 该函数负责重置系统资源的状态，清理现有的资源引用，
 * 并重新设置内存分配器和全局数据引用。它确保资源处于初始状态。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含要重置的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源状态的重置
 */
void SystemResourceResetter(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 8) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ConfigureSystemComponents(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源处理器函数
 * 
 * 该函数负责处理系统资源的操作，调用底层的资源处理函数
 * 来执行具体的资源管理任务。它提供了一个统一的资源处理接口。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 处理参数2（未使用）
 * @param AdditionalParameter 处理参数3
 * @param ConfigurationFlag 处理参数4
 * @note 这是系统资源管理的核心处理函数
 */
void SystemResourceHandler(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ConfigureSystemResource(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void CleanupSystemResources(long long ResourceManagerPointer)
/**
 * @brief 系统资源清理器函数
 * 
 * 该函数负责清理系统资源，遍历资源数组并释放每个资源占用的内存。
 * 它会调用每个资源的清理函数，确保资源被正确释放，避免内存泄漏。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源数组和计数信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemResourceCleaner(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  
  allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
  unsignedSystemValue4 = 0;
  if (allocationContext != 0) {
    do {
      localSystemHandle = *(long long *)(nextDataIndex + unsignedSystemValue4 * 8);
      if (localSystemHandle != 0) {
        if (*(long long **)(localSystemHandle + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(localSystemHandle + 0x10) + 0x38))();
        }
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(nextDataIndex + unsignedSystemValue4 * 8) = 0;
      unsignedSystemValue4 = unsignedSystemValue4 + 1;
    } while (unsignedSystemValue4 < allocationContext);
    allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < allocationContext) && (*(long long *)(ResourceManagerPointer + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}





// 函数: void HandleSystemEmergencyExit(void* ResourceManagerPointer,uint32_t ConfigurationDataPointer)
/**
 * @brief 系统紧急退出处理器
 * 
 * 该函数负责处理系统的紧急退出操作，包括清理资源和安全退出。
 * 它会执行清理操作，等待一段时间，然后以指定的退出码退出系统。
 * 
 * @param exitContext 退出上下文指针，包含退出相关的信息
 * @param exitCode 退出码，用于指示退出的原因或状态
 * 
 * @note 该函数用于处理系统异常或紧急情况的退出
 */
void HandleSystemEmergencyExit(void* exitContext,uint32_t exitCode)

{
  code *systemInterruptHandler;
  
  if (SystemCleanupHandler != 0) {
    ExecuteSystemCleanupFunction(SystemCleanupHandler + 8);
  }
  Sleep(2000);
  _Exit(exitCode);
  systemInterruptHandler = (code *)swi(3);
  (*systemInterruptHandler)();
  return;
}





/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统数据管理器，设置数据结构和配置参数。
 * 它会检查系统状态，获取必要的资源，并初始化各种数据字段。
 * 
 * @return 无返回值
 * @note 此函数在系统启动时调用，确保数据管理器正确初始化
 * @warning 调用此函数前必须确保系统资源管理器已准备好
 */
void InitializeSystemDataManager(void)

{
  void** resourceManagerPointer;
  void* previousDataHeader;
  char* systemConfigPointer;
  int mutexLockResult;
  char* dataFieldPointer;
  void* systemRegisterValue;
  void* systemConfigParameter;
  
  systemConfigPointer = SystemConfigurationDataPointer;
  systemConfigParameter = 0xfffffffffffffffe;
  if (*SystemConfigurationDataPointer != '\0') {
    resourceManagerPointer = (void**)*SystemResourceManagerPointer;
    mutexLockResult = _Mtx_lock(0x180c91970);
    if (mutexLockResult != 0) {
      __Throw_C_error_std__YAXH_Z(mutexLockResult);
    }
    previousDataHeader = SystemDataHeaderStorage;
    SystemDataHeaderStorage = *resourceManagerPointer;
    InitializeSystemConfiguration(&SystemConfigData,0,0,systemRegisterValue,systemConfigParameter);
    SetupSystemDataField(&SystemConfigField1,*(uint32_t *)(systemConfigPointer + 4));
    SetupSystemDataField(&SystemConfigField2,*(uint32_t *)(systemConfigPointer + 8));
    SetupSystemDataField(&SystemConfigField3,*(uint32_t *)(systemConfigPointer + 0xc));
    SetupSystemDataField(&SystemConfigField4,*(uint32_t *)(systemConfigPointer + 0x10));
    SetupSystemDataField(&SystemConfigField5,*(uint32_t *)(systemConfigPointer + 0x14));
    SetupSystemDataField(&SystemConfigField6,*(uint32_t *)(systemConfigPointer + 0x18));
    for (dataFieldPointer = *(char **)(systemConfigPointer + 0x28); dataFieldPointer != systemConfigPointer + 0x20;
        dataFieldPointer = (char *)SystemMemoryNodeGetNext(dataFieldPointer)) {
      SetupSystemDataField(&SystemConfigField7,*(uint32_t *)(dataFieldPointer + 0x20),*(uint32_t *)(dataFieldPointer + 0x24));
    }
    for (dataFieldPointer = *(char **)(systemConfigPointer + 0x58); dataFieldPointer != systemConfigPointer + 0x50;
        dataFieldPointer = (char *)SystemMemoryNodeGetNext(dataFieldPointer)) {
      SetupSystemDataField(&SystemConfigField8,*(uint32_t *)(dataFieldPointer + 0x20),*(uint32_t *)(dataFieldPointer + 0x24));
    }
    SetupSystemDataField(&SystemConfigField9,*(uint32_t *)(systemConfigPointer + 0x80));
    SetupSystemDataField(&SystemConfigField10,*(uint32_t *)(systemConfigPointer + 0x84));
    SetupSystemDataField(&SystemConfigField11,*(uint32_t *)(systemConfigPointer + 0x88));
    FinalizeSystemInitialization();
    SystemDataHeaderStorage = previousDataHeader;
    mutexLockResult = _Mtx_unlock(0x180c91970);
    if (mutexLockResult != 0) {
      __Throw_C_error_std__YAXH_Z(mutexLockResult);
    }
  }
  return;
}




/**
 * @brief 系统节点资源处理函数
 * 
 * 该函数负责处理系统节点资源，包括节点比较、内存管理和资源分配。
 * 函数会遍历系统资源指针，比较节点数据，并根据比较结果进行相应的处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 该函数在系统资源管理中起到关键作用
 */
void ProcessSystemNodeResource(long long ResourceManagerPointer)

{
  char SystemNodeFlag;
  char validationStatusFlag;
  int MemoryComparisonResult;
  void* *punsignedSystemValue4;
  ulong long currentThreadId;
  int systemFlag;
  char *resourceStringPointer;
  long long *plocalMemoryAddress;
  long long resourceCounter;
  ulong long systemOperationFlags;
  long long nextDataIndex1;
  long long nextDataIndex2;
  int systemStatus3;
  long long nextDataIndex4;
  int systemStatus5;
  long long nextDataIndex6;
  int systemStatus7;
  ulong long systemStatus8;
  int systemStatus9;
  bool isConfigurationInitialized;
  
  systemOperationFlags = 0;
  resourceCounter = *(long long *)(ResourceManagerPointer + 0x50);
  nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x48);
  if (resourceCounter - nextDataIndex2 >> 3 != 0) {
    systemStatus9 = 1;
    nextDataIndex6 = 8;
    systemStatus8 = systemOperationFlags;
    do {
      systemStatus7 = (int)systemOperationFlags;
      systemFlag = -1;
      if ((ulong long)(long long)systemStatus9 < (ulong long)(resourceCounter - nextDataIndex2 >> 3)) {
        resourceCounter = *(long long *)(ResourceManagerPointer + 0x50);
        nextDataIndex4 = nextDataIndex6;
        systemStatus3 = systemStatus9;
        systemStatus5 = -1;
        do {
          systemFlag = *(int *)(*(long long *)(nextDataIndex4 + nextDataIndex2) + 0x10);
          systemCounter = *(int *)(*(long long *)(systemStatus8 + nextDataIndex2) + 0x10);
          if (systemFlag == systemCounter) {
            if (systemFlag == 0) {
SystemCounterCheck:
              if (systemCounter != 0) goto SystemCounterContinue;
              isConfigurationInitialized = true;
            }
            else {
              resourceStringPointer = *(char **)(*(long long *)(nextDataIndex4 + nextDataIndex2) + 8);
              nextDataIndex1 = *(long long *)(*(long long *)(systemStatus8 + nextDataIndex2) + 8) - (long long)resourceStringPointer;
              do {
                initializationStatusFlag = *resourceStringPointer;
                validationStatusFlag = resourceStringPointer[nextDataIndex1];
                if (initializationStatusFlag != validationStatusFlag) break;
                resourceStringPointer = resourceStringPointer + 1;
              } while (validationStatusFlag != '\0');
              isConfigurationInitialized = initializationStatusFlag == validationStatusFlag;
            }
          }
          else {
            if (systemFlag == 0) goto SystemCounterCheck;
SystemCounterContinue:
            isConfigurationInitialized = false;
          }
          systemFlag = systemStatus3;
          if (!isConfigurationInitialized) {
            systemFlag = systemStatus5;
          }
          systemStatus3 = systemStatus3 + 1;
          nextDataIndex4 = nextDataIndex4 + 8;
          systemStatus5 = systemFlag;
        } while ((ulong long)(long long)systemStatus3 < (ulong long)(resourceCounter - nextDataIndex2 >> 3));
      }
      if (systemFlag != -1) {
        nextDataIndex4 = (long long)systemFlag;
        resourceCounter = *(long long *)(nextDataIndex2 + nextDataIndex4 * 8);
        *(double *)(*(long long *)(systemStatus8 + nextDataIndex2) + 0x40) =
             *(double *)(resourceCounter + 0x40) + *(double *)(*(long long *)(systemStatus8 + nextDataIndex2) + 0x40);
        plocalMemoryAddress = *(long long **)(resourceCounter + 0x48);
        if (plocalMemoryAddress != *(long long **)(resourceCounter + 0x50)) {
          nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x48);
          do {
            *(void* *)(*plocalMemoryAddress + 0x68) = *(void* *)(systemStatus8 + nextDataIndex2);
            plocalMemoryAddress = plocalMemoryAddress + 1;
            nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x48);
          } while (plocalMemoryAddress != *(long long **)(*(long long *)(nextDataIndex2 + nextDataIndex4 * 8) + 0x50));
        }
        resourceCounter = *(long long *)(nextDataIndex2 + nextDataIndex4 * 8);
        ProcessSystemParameters(*(long long *)(systemStatus8 + nextDataIndex2) + 0x48,
                      *(void* *)(*(long long *)(systemStatus8 + nextDataIndex2) + 0x50),
                      *(void* *)(resourceCounter + 0x48),*(void* *)(resourceCounter + 0x50));
        resourceCounter = *(long long *)(*(long long *)(ResourceManagerPointer + 0x48) + nextDataIndex4 * 8);
        *(void* *)(resourceCounter + 0x50) = *(void* *)(resourceCounter + 0x48);
        ProcessMemoryAllocation(*(void* *)(systemStatus8 + *(long long *)(ResourceManagerPointer + 0x48)));
        HandleMemoryOperation(*(void* *)(*(long long *)(ResourceManagerPointer + 0x48) + nextDataIndex4 * 8));
        punsignedSystemValue4 = *(void* **)(*(long long *)(ResourceManagerPointer + 0x48) + nextDataIndex4 * 8);
        if (punsignedSystemValue4 != (void* *)0x0) {
          if (punsignedSystemValue4[9] != 0) {
              SystemCleanupFunction();
          }
          punsignedSystemValue4[4] = &SystemGlobalDataReference;
          if (punsignedSystemValue4[5] == 0) {
            punsignedSystemValue4[5] = 0;
            *(uint32_t *)(punsignedSystemValue4 + 7) = 0;
            punsignedSystemValue4[4] = &SystemMemoryAllocatorReference;
            *punsignedSystemValue4 = &SystemGlobalDataReference;
            if (punsignedSystemValue4[1] == 0) {
              punsignedSystemValue4[1] = 0;
              *(uint32_t *)(punsignedSystemValue4 + 3) = 0;
              *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
                SystemCleanupFunction(punsignedSystemValue4);
            }
              SystemCleanupFunction();
          }
            SystemCleanupFunction();
        }
        *(void* *)(*(long long *)(ResourceManagerPointer + 0x48) + nextDataIndex4 * 8) = 0;
        resourceCounter = *(long long *)(ResourceManagerPointer + 0x48) + nextDataIndex4 * 8;
        systemOperationFlags = resourceCounter + 8;
        currentThreadId = *(ulong long *)(ResourceManagerPointer + 0x50);
        if (systemOperationFlags < currentThreadId) {
            memmove(resourceCounter,systemOperationFlags,currentThreadId - systemOperationFlags);
        }
        resourceCounter = currentThreadId - 8;
        *(long long *)(ResourceManagerPointer + 0x50) = resourceCounter;
        systemStatus7 = systemStatus7 + -1;
        systemStatus9 = systemStatus9 + -1;
        systemStatus8 = systemStatus8 - 8;
        nextDataIndex6 = nextDataIndex6 + -8;
      }
      systemOperationFlags = (ulong long)(systemStatus7 + 1U);
      systemStatus9 = systemStatus9 + 1;
      systemStatus8 = systemStatus8 + 8;
      nextDataIndex6 = nextDataIndex6 + 8;
      nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x48);
    } while ((ulong long)(long long)(int)(systemStatus7 + 1U) < (ulong long)(resourceCounter - nextDataIndex2 >> 3));
  }
  return;
}





/**
 * @brief 系统资源数据管理函数
 * 
 * 该函数负责管理系统资源数据，包括数据表的访问、系统标志的处理
 * 和资源指针的操作。函数会根据传入的参数执行相应的资源管理操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递额外的配置信息
 * @param AdditionalParameter 参数3，用于传递操作标志
 * @param ConfigurationFlag 参数4，用于传递错误处理参数
 * @note 该函数是系统资源管理的核心函数之一
 */
void ManageSystemResourceData(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ulong long *pointerToUnsigned1;
  void** SystemDataTable;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  ulong long currentThreadId;
  long long localSystemFlags;
  uint unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  long long resourceCounter;
  void* systemOperationFlags;
  
  systemOperationFlags = 0xfffffffffffffffe;
  allocationContext = 0;
  pointerToUnsigned1 = (ulong long *)(ResourceManagerPointer + 0x48);
  unsignedSystemValue4 = *pointerToUnsigned1;
  currentThreadId = allocationContext;
  unsignedSystemValue8 = allocationContext;
  if ((long long)(*(long long *)(ResourceManagerPointer + 0x50) - unsignedSystemValue4) >> 3 != 0) {
    do {
      HandleMemoryOperation(*(void* *)(unsignedSystemValue4 + currentThreadId));
      HashEntryStatus = *(void* **)(*pointerToUnsigned1 + currentThreadId);
      if (HashEntryStatus != (void* *)0x0) {
        if (HashEntryStatus[9] != 0) {
            SystemCleanupFunction();
        }
        HashEntryStatus[4] = &SystemGlobalDataReference;
        if (HashEntryStatus[5] == 0) {
          HashEntryStatus[5] = 0;
          *(uint32_t *)(HashEntryStatus + 7) = 0;
          HashEntryStatus[4] = &SystemMemoryAllocatorReference;
          *HashEntryStatus = &SystemGlobalDataReference;
          if (HashEntryStatus[1] == 0) {
            HashEntryStatus[1] = 0;
            *(uint32_t *)(HashEntryStatus + 3) = 0;
            *HashEntryStatus = &SystemMemoryAllocatorReference;
              SystemCleanupFunction(HashEntryStatus);
          }
            SystemCleanupFunction();
        }
          SystemCleanupFunction();
      }
      *(void* *)(*pointerToUnsigned1 + currentThreadId) = 0;
      unsignedSystemValue7 = (int)unsignedSystemValue8 + 1;
      unsignedSystemValue4 = *pointerToUnsigned1;
      currentThreadId = currentThreadId + 8;
      unsignedSystemValue8 = (ulong long)unsignedSystemValue7;
    } while ((ulong long)(long long)(int)unsignedSystemValue7 <
             (ulong long)((long long)(*(long long *)(ResourceManagerPointer + 0x50) - unsignedSystemValue4) >> 3));
  }
  ResizeSystemMemoryPool(pointerToUnsigned1,0);
  unsignedSystemValue4 = *(ulong long *)(ResourceManagerPointer + 0x50);
  currentThreadId = *pointerToUnsigned1;
  unsignedSystemValue7 = *(uint *)(ResourceManagerPointer + 0x60);
  resourceCounter = unsignedSystemValue4 - currentThreadId;
  localSystemFlags = resourceCounter >> 3;
  if (localSystemFlags != 0) {
    allocationContext = CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemFlags * 8,unsignedSystemValue7 & 0xff,ConfigurationFlag,systemOperationFlags,0,0,0,unsignedSystemValue7);
  }
  localSystemFlags = allocationContext + localSystemFlags * 8;
  if (currentThreadId == unsignedSystemValue4) {
    unsignedSystemValue4 = *pointerToUnsigned1;
    *pointerToUnsigned1 = allocationContext;
    *(long long *)(ResourceManagerPointer + 0x50) = localSystemFlags;
    *(long long *)(ResourceManagerPointer + 0x58) = localSystemFlags;
    *(uint *)(ResourceManagerPointer + 0x60) = unsignedSystemValue7;
    if (unsignedSystemValue4 == 0) {
      return;
    }
      SystemCleanupFunction();
  }
    memmove(allocationContext,currentThreadId,resourceCounter,ConfigurationFlag,systemOperationFlags,allocationContext,localSystemFlags,localSystemFlags);
}





/**
 * @brief 系统内存资源初始化函数
 * 
 * 该函数负责初始化系统内存资源，包括内存分配、内存区域设置和
 * 内存管理结构的初始化。函数会配置内存参数并建立内存管理的基本结构。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要初始化的内存资源
 * @note 该函数在系统启动时调用，确保内存资源正确初始化
 */
void InitializeSystemMemoryResource(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  long long localResourceOffset;
  long long* SystemMemoryPointer;
  uint8_t aunsignedValue98 [32];
  long long lStack_78;
  long long *plStack_68;
  long long **pplStack_60;
  void* processFlags58;
  void* *memoryAllocationEnd;
  uint8_t *pEncryptionValue48;
  uint32_t unsignedValue40;
  uint8_t arrayUnsigned38 [16];
  ulong long EncryptionKeyValue;
  
  processFlags58 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue98;
  pbufferBaseAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xd0,8,3);
  pplStack_60 = (long long **)pbufferBaseAddress;
  InitializeSystemDataTableManager(pbufferBaseAddress);
  *pbufferBaseAddress = (long long)&SystemBufferData;
  pbufferBaseAddress[0x18] = 0;
  *(uint32_t *)(pbufferBaseAddress + 0x19) = 0;
  plStack_68 = pbufferBaseAddress;
  (**(code **)(*pbufferBaseAddress + 0x28))(pbufferBaseAddress);
  plStack_68 = (long long *)*ResourceManagerPointer;
  *ResourceManagerPointer = (long long)pbufferBaseAddress;
  if (plStack_68 != (long long *)0x0) {
    (**(code **)(*plStack_68 + 0x38))();
  }
  localResourceOffset = SystemAllocationFlagsTemplate;
  memoryAllocationEnd = &SystemResourceTemplateSecondary;
  pEncryptionValue48 = arrayUnsigned38;
  arrayUnsigned38[0] = 0;
  unsignedValue40 = 0xc;
  strcpy_s(arrayUnsigned38,0x10,&SystemBufferString);
  pbufferBaseAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  lStack_78 = localResourceOffset + 0x70;
  pplStack_60 = (long long **)pbufferBaseAddress;
  InitializeSystemMemoryContext(pbufferBaseAddress,&memoryAllocationEnd,3,localResourceOffset + 0x2e0);
  *pbufferBaseAddress = (long long)&SystemValueReference;
  plStack_68 = pbufferBaseAddress;
  InitializeSystemMemoryContext(pbufferBaseAddress);
  InitializeSystemHandle(localResourceOffset + 0x48,&plStack_68);
  ResourceManagerPointer[1] = (long long)pbufferBaseAddress;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStack_60 = &plStack_68;
  plStack_68 = (long long *)*ResourceManagerPointer;
  if (plStack_68 != (long long *)0x0) {
    (**(code **)(*plStack_68 + 0x28))();
  }
  (*stringProcessingPointer)(pointerToUnsigned1,&plStack_68);
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)aunsignedValue98);
}



/**
 * @brief 系统资源释放处理器
 * 
 * 该函数负责处理系统资源的释放操作，根据参数决定是否释放资源。
 * 它会调用系统资源初始化处理器，并根据参数标志决定是否释放内存。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数标志，用于控制释放行为
 * @param AdditionalParameter 释放参数
 * @param ConfigurationFlag 释放参数
 * @return 返回系统资源指针
 * @note 该函数用于管理系统资源的生命周期
 */
void* ReleaseSystemResourceHandler(void* ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xd0,AdditionalParameter,ConfigurationFlag,systemStatus);
  }
  return ResourceManagerPointer;
}





/**
 * @brief 系统配置参数处理函数
 * 
 * 该函数负责处理系统配置参数，包括参数验证、配置设置和
 * 系统状态的更新。函数会根据传入的系统资源指针进行相应的配置操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含配置信息
 * @note 该函数用于维护系统配置的一致性和正确性
 */
void ProcessSystemConfigurationParameters(long long ResourceManagerPointer)

{
  uint systemStatus;
  double timeElapsed;
  uint allocationContext;
  long long bufferBaseAddress;
  uint32_t *pcurrentThreadId;
  void** SystemRootNode;
  int systemOffset;
  long long localMemoryAddress;
  void* *punsignedSystemValue9;
  uint8_t auStack_c8 [32];
  uint8_t UnsignedStackFlagA8;
  uint8_t UnsignedStackFlagA0;
  void* *stackParameterB;
  void* *pStackParameterC;
  uint UnsignedStackFlag88;
  ulong long UnsignedStackFlag80;
  long long lStack_78;
  long long alStack_70 [2];
  char acStack_60 [16];
  ulong long unsignedValue50;
  
  alStack_70[1] = 0xfffffffffffffffe;
  unsignedValue50 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_c8;
  bufferBaseAddress = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&lStack_78);
    bufferBaseAddress = lStack_78;
  }
  *(double *)(ResourceManagerPointer + 0xc0) = (double)(bufferBaseAddress - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
  LOCK();
  *(uint32_t *)(ResourceManagerPointer + 200) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(ResourceManagerPointer + 0xcc) = 1;
  UNLOCK();
  while( true ) {
    do {
      if (*(int *)(ResourceManagerPointer + 0xcc) == 0) {
          ValidateSystemChecksum(unsignedValue50 ^ (ulong long)auStack_c8);
      }
      Sleep(10);
      bufferBaseAddress = SystemPerformancePreviousStorage;
      if (SystemPerformancePreviousStorage == 0) {
        QueryPerformanceCounter(alStack_70);
        bufferBaseAddress = alStack_70[0];
      }
      timeElapsed = (double)(bufferBaseAddress - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
    } while ((SystemTimeoutFlag == '\0') || (timeElapsed - *(double *)(ResourceManagerPointer + 0xc0) <= 900.0));
    LOCK();
    *(uint32_t *)(ResourceManagerPointer + 200) = 1;
    UNLOCK();
    stackParameterB = &SystemGlobalDataReference;
    UnsignedStackFlag80 = 0;
    pSystemConfigurationValue = (void* *)0x0;
    UnsignedStackFlag88 = 0;
    ExecuteSystemCommand(&stackParameterB,0x1c);
    pcurrentThreadId = (uint32_t *)(pStackParameterC + UnsignedStackFlag88);
    *pcurrentThreadId = 0x73736f50;
    pcurrentThreadId[1] = 0x656c6269;
    pcurrentThreadId[2] = 0x61656420;
    pcurrentThreadId[3] = 0x636f6c64;
    *(void* *)(pcurrentThreadId + 4) = 0x746365746564206b;
    pcurrentThreadId[6] = 0x202c6465;
    *(uint8_t *)(pcurrentThreadId + 7) = 0;
    UnsignedStackFlag88 = 0x1c;
    ExecuteSystemCommand(&stackParameterB,0x3e);
    pcurrentThreadId = (uint32_t *)(pStackParameterC + UnsignedStackFlag88);
    *pcurrentThreadId = 0x69676e65;
    pcurrentThreadId[1] = 0x6420656e;
    pcurrentThreadId[2] = 0x6e206469;
    pcurrentThreadId[3] = 0x7220746f;
    pcurrentThreadId[4] = 0x65646e65;
    pcurrentThreadId[5] = 0x20612072;
    pcurrentThreadId[6] = 0x6d617266;
    pcurrentThreadId[7] = 0x6f662065;
    *(void*2 *)(pcurrentThreadId + 8) = 0x2072;
    *(uint8_t *)((long long)pcurrentThreadId + 0x22) = 0;
    UnsignedStackFlag88 = 0x3e;
    InitializeProcessSystem(acStack_60,&SystemDataBufferTemplateI,900);
    allocationContext = UnsignedStackFlag88;
    bufferBaseAddress = -1;
    do {
      localMemoryAddress = bufferBaseAddress;
      bufferBaseAddress = localMemoryAddress + 1;
    } while (acStack_60[localMemoryAddress + 1] != '\0');
    systemOffset = (int)(localMemoryAddress + 1);
    if (0 < systemOffset) break;
    systemStatus = UnsignedStackFlag88 + 10;
    ExecuteSystemCommand(&stackParameterB,systemStatus);
    resourceEntryPointer = (void* *)(pStackParameterC + UnsignedStackFlag88);
    *resourceEntryPointer = 0x73646e6f63657320;
    *(void*2 *)(resourceEntryPointer + 1) = 0x2021;
    *(uint8_t *)((long long)resourceEntryPointer + 10) = 0;
    UnsignedStackFlag88 = systemStatus;
    ExecuteSystemCommand(&stackParameterB,allocationContext + 0x2b);
    pcurrentThreadId = (uint32_t *)(pStackParameterC + UnsignedStackFlag88);
    *pcurrentThreadId = 0x65766544;
    pcurrentThreadId[1] = 0x65706f6c;
    pcurrentThreadId[2] = 0x6e692072;
    pcurrentThreadId[3] = 0x76726574;
    pcurrentThreadId[4] = 0x69746e65;
    pcurrentThreadId[5] = 0x73206e6f;
    pcurrentThreadId[6] = 0x65676775;
    pcurrentThreadId[7] = 0x64657473;
    *(void*2 *)(pcurrentThreadId + 8) = 0x2e;
    punsignedSystemValue9 = &SystemStringTemplate;
    if (pStackParameterC != (void* *)0x0) {
      punsignedSystemValue9 = pStackParameterC;
    }
    UnsignedStackFlagA0 = 0;
    UnsignedStackFlagA8 = 0;
    UnsignedStackFlag88 = allocationContext + 0x2b;
    (**(code **)(*(long long *)*SystemMemoryBlockStorage + 0x20))
              ((long long *)*SystemMemoryBlockStorage,&SystemBufferConfig,0x175c,punsignedSystemValue9);
    *(double *)(ResourceManagerPointer + 0xc0) = SystemPerformanceTimeElapsed;
    stackParameterB = &SystemGlobalDataReference;
    if (pStackParameterC != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemConfigurationValue = (void* *)0x0;
    UnsignedStackFlag80 = UnsignedStackFlag80 & 0xffffffff00000000;
    stackParameterB = &SystemMemoryAllocatorReference;
  }
  ExecuteSystemCommand(&stackParameterB,UnsignedStackFlag88 + systemOffset);
    memcpy(pStackParameterC + UnsignedStackFlag88,acStack_60,(long long)((int)localMemoryAddress + 2));
}





/**
 * @brief 系统资源缓冲区管理函数
 * 
 * 该函数负责管理系统资源缓冲区，包括缓冲区的分配、配置和清理。
 * 函数会处理系统资源的内存分配，并根据参数执行相应的缓冲区操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递缓冲区配置信息
 * @param AdditionalParameter 参数3，用于传递操作标志
 * @param ConfigurationFlag 参数4，用于传递错误处理参数
 * @note 该函数确保系统资源缓冲区的正确管理和使用
 */
void ManageSystemResourceBuffer(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  char validationStatusFlag;
  uint8_t aunsignedValue30 [16];
  void* *punsignedValue20;
  void* *punsignedValue18;
  
  ExecuteSystemInitialization(ResourceManagerPointer,1,1,ConfigurationFlag,0xfffffffffffffffe);
  if (SystemCleanupHandler != (long long *)0x0) {
    validationStatusFlag = (**(code **)(*SystemCleanupHandler + 0x48))();
    if ((validationStatusFlag != '\0') && (SystemCleanupHandler[2] != 0)) {
      (*(code *)SystemCleanupHandler[0x11])(0);
    }
  }
  punsignedValue20 = &SystemStackData1;
  punsignedValue18 = &SystemStackData2;
  ProcessSystemResourceData(aunsignedValue30);
  *(uint8_t *)(SystemConfigurationBlock + 0x3a0) = 1;
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  ExecuteSystemInitialization();
  nextDataIndex = SystemMemoryContext;
  *(uint8_t *)(SystemMemoryContext + 0x1504) = 0;
  *(uint8_t *)(nextDataIndex + 0x1506) = 0;
  return;
}





/**
 * @brief 系统资源初始化器
 * 
 * 该函数负责初始化系统资源，包括内存分配、参数设置和系统引用配置。
 * 主要用于系统启动阶段的资源准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数指针数组
 * @param AdditionalParameter 参数标志
 * @note 这是系统初始化的核心函数，负责资源的分配和配置
 */
void InitializeSystemResource(void* ResourceManagerPointer,void* *ConfigurationDataPointer,uint32_t AdditionalParameter)

{
  void* systemStatus;
  void* **pHashEntryStatus;
  uint8_t auStack_158 [32];
  void* **psystemMemoryContext;
  void* ***pppuStack_130;
  void* uStack_128;
  void* *puStack_120;
  void* **ppUnsignedStackFlag118;
  void* *punsignedValue108;
  uint8_t *punsignedValue100;
  uint32_t unsignedValueF8;
  uint8_t auStack_f0 [128];
  uint32_t processFlags70;
  void* processFlags58;
  uint32_t unsignedValue50;
  ulong long EncryptionKeyValue;
  
  uStack_128 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)auStack_158;
  psystemMemoryContext = &punsignedValue108;
  punsignedValue108 = &SystemResourceTemplatePrimary;
  punsignedValue100 = auStack_f0;
  unsignedValueF8 = 0;
  auStack_f0[0] = 0;
  processFlags70 = 0x17;
  puStack_120 = ConfigurationDataPointer;
  systemStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,3);
  processFlags58 = CreateSystemObject(systemStatus,ConfigurationDataPointer);
  unsignedValue50 = AdditionalParameter;
  systemStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x100,8,3);
  pHashEntryStatus = (void* **)InitializeResourceContext(systemStatus,&punsignedValue108);
  ppUnsignedStackFlag118 = pHashEntryStatus;
  if (pHashEntryStatus != (void* **)0x0) {
    (**(code **)(*pHashEntryStatus + 0x28))(pHashEntryStatus);
  }
  systemStatus = SystemAllocationFlagsTemplate;
  pppuStack_130 = &psystemMemoryContext;
  psystemMemoryContext = pHashEntryStatus;
  if (pHashEntryStatus != (void* **)0x0) {
    (**(code **)(*pHashEntryStatus + 0x28))(pHashEntryStatus);
  }
  SetupMemoryAllocationContext(systemStatus,&psystemMemoryContext);
  if (pHashEntryStatus != (void* **)0x0) {
    (**(code **)(*pHashEntryStatus + 0x38))(pHashEntryStatus);
  }
  pppuStack_130 = (void* ***)&punsignedValue108;
  punsignedValue108 = &SystemMemoryAllocatorReference;
  *ConfigurationDataPointer = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[1] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 3) = 0;
  *ConfigurationDataPointer = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)auStack_158);
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，将其设置为默认状态。
 * 主要用于资源指针的标准化初始化操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回初始化后的资源指针
 * @note 这是资源指针初始化的标准函数
 */
void* * InitializeResourceManagerPointer(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 3;
  return ResourceManagerPointer;
}



/**
 * @brief 系统资源指针重置器
 * 
 * 该函数负责重置系统资源指针，将其恢复到默认状态。
 * 主要用于资源指针的重置和清理操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回重置后的资源指针
 * @note 这是资源指针重置的标准函数
 */
void* * ResetResourceManagerPointer(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 3;
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源清理触发器
 * 
 * 该函数作为系统资源清理的触发器，调用系统资源清理器来释放资源。
 * 这是一个简单的包装函数，用于在特定时机触发资源清理操作。
 * 
 * @note 这是系统资源管理的辅助函数，用于统一资源清理的调用接口
 */
void SystemResourceCleanupTrigger(void)

{
  SystemResourceCleaner();
  return;
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，将指针数组的前三个元素设置为0，
 * 并将第四个元素设置为10。这用于资源指针的标准化初始化。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @return 返回初始化后的系统资源指针数组
 * @note 这是系统资源管理的基础初始化函数
 */
void* * InitializeResourceManagerPointer(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 10;
  return ResourceManagerPointer;
}



/**
 * @brief 系统资源指针扩展初始化器
 * 
 * 该函数负责对系统资源指针进行扩展初始化，设置多个字段为0，
 * 并进行内存对齐操作。这用于更复杂的资源指针初始化场景。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @return 返回初始化后的系统资源指针数组
 * @note 这是系统资源管理的高级初始化函数，包含内存对齐处理
 */
void* * InitializeResourceManagerPointerExtended(void* *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[4] = 0;
  *(uint32_t *)(ResourceManagerPointer + 5) = 0;
  ResourceManagerPointer[6] = 0;
  ResourceManagerPointer[8] = 0;
  ResourceManagerPointer[0x60f] = 0;
  ResourceManagerPointer[0x610] = 0;
  pointerToUnsigned1 = ResourceManagerPointer + 0xf;
  ResourceManagerPointer[0xc] = pointerToUnsigned1;
  ResourceManagerPointer[0xd] = (ulong long)(-(int)pointerToUnsigned1 & 7) + (long long)pointerToUnsigned1;
  ResourceManagerPointer[0xe] = ResourceManagerPointer + 0x60f;
  ResourceManagerPointer[0x60f] = &SystemResourceData1;
  ResourceManagerPointer[0x610] = AllocateSystemResource;
  return ResourceManagerPointer;
}



/**
 * @brief 系统资源链接管理器
 * 
 * 该函数负责管理系统资源之间的链接关系，包括资源的插入和删除。
 * 它会处理资源的清理和重新链接，确保资源链表的完整性。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向资源链表的头节点
 * @param ConfigurationDataPointer 参数指针，包含要插入或删除的资源信息
 * @return 返回更新后的系统资源指针
 * 
 * @note 这是资源管理系统中的核心函数，用于维护资源链表结构
 */
long long * SystemResourceManagerLink(long long *ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  
  if (ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer);
  }
  PrimaryResourcePointer = (long long *)*ResourceManagerPointer;
  *ResourceManagerPointer = (long long)ConfigurationDataPointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))();
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统字符串处理器
 * 
 * 该函数负责处理系统字符串相关的操作，包括字符串模板的设置和字符串缓冲区的管理。
 * 主要用于系统字符串的处理和配置工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数指针
 * @note 这是系统字符串处理的核心函数
 */
void ProcessSystemString(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  void* *HashEntryStatus;
  
  HashEntryStatus = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    HashEntryStatus = *(void* **)(ConfigurationDataPointer + 8);
  }
  if (HashEntryStatus == (void* *)0x0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  nextDataIndex = -1;
  do {
    nextDataIndex = nextDataIndex + 1;
  } while (HashEntryStatus[nextDataIndex] != '\0');
  if ((int)nextDataIndex < 0x400) {
    *(int *)(ResourceManagerPointer + 0x10) = (int)nextDataIndex;
                    000180056fc2. Too many branches
                        strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x400);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x400);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 系统资源清理器
 * 
 * 该函数负责清理系统资源，遍历资源链表并释放每个资源的内存。
 * 它会调用资源的清理函数或直接释放内存，确保系统资源的正确回收。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向要清理的资源链表
 * @note 这是系统资源管理的重要组成部分，用于释放不再使用的系统资源
 */
void SystemResourceCleaner(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long LocalSystemHandle;
  
  PrimaryResourcePointer = ResourceManagerPointer + 3;
  LocalSystemHandle = *ResourceManagerPointer;
  while ((long long *)LocalSystemHandle != PrimaryResourcePointer) {
    LocalSystemHandle = *(long long *)((ulong long)(-(int)LocalSystemHandle & 7) + LocalSystemHandle);
    if ((code *)ResourceManagerPointer[0x604] == (code *)0x0) {
      free();
    }
    else {
      (*(code *)ResourceManagerPointer[0x604])();
    }
    *ResourceManagerPointer = localSystemHandle;
  }
  *ResourceManagerPointer = (long long)PrimaryResourcePointer;
  ResourceManagerPointer[1] = (ulong long)(-(int)PrimaryResourcePointer & 7) + (long long)PrimaryResourcePointer;
  ResourceManagerPointer[2] = (long long)(ResourceManagerPointer + 0x603);
  return;
}




/**
 * @brief 系统资源链表清理器
 * 
 * 该函数负责清理系统资源链表，遍历链表中的每个资源节点并释放其内存。
 * 它使用特定的链表遍历算法，确保所有资源节点都被正确清理。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于标识要清理的资源链表
 * @note 这是系统资源管理的核心函数，用于清理复杂的资源链表结构
 */
void SystemResourceListCleaner(long long ResourceManagerPointer)

{
  long long ResourceListEnd;
  long long *ResourceListHead;
  
  do {
    ResourceManagerPointer = *(long long *)((ulong long)(-(int)ResourceManagerPointer & 7) + ResourceManagerPointer);
    if ((code *)ResourceListHead[0x604] == (code *)0x0) {
      free();
    }
    else {
      (*(code *)ResourceListHead[0x604])();
    }
    *ResourceListHead = ResourceManagerPointer;
  } while (ResourceManagerPointer != ResourceListEnd);
  *ResourceListHead = ResourceListEnd;
  ResourceListHead[1] = (ulong long)(-(int)ResourceListEnd & 7) + ResourceListEnd;
  ResourceListHead[2] = (long long)(ResourceListHead + 0x603);
  return;
}




/**
 * @brief 系统资源链表初始化器
 * 
 * 该函数负责初始化系统资源链表，设置链表的头指针和基本结构。
 * 这是一个低级别的链表初始化函数，用于准备资源管理的数据结构。
 * 
 * @note 这是系统资源管理的基础函数，用于初始化链表数据结构
 */
void SystemResourceListInitializer(void)

{
  long long ListEndPointer;
  long long *ListHeadPointer;
  
  *ListHeadPointer = ListEndPointer;
  ListHeadPointer[1] = (ulong long)(-(int)ListEndPointer & 7) + ListEndPointer;
  ListHeadPointer[2] = (long long)(ListHeadPointer + 0x603);
  return;
}



/**
 * @brief 系统内存分配器配置器
 * 
 * 该函数负责配置系统内存分配器，设置内存分配器的引用和初始参数。
 * 它会初始化内存分配器的基本结构，并根据需要配置字符串参数。
 * 
 * @param ResourceManagerPointer 内存分配器指针的指针
 * @param ConfigurationDataPointer 配置字符串参数（可选）
 * @param AdditionalParameter 保留参数
 * @param ConfigurationFlag 保留参数
 * @return 返回配置后的内存分配器指针
 * @note 这是系统内存管理的重要函数，用于初始化和配置内存分配器
 */
void* *
SystemMemoryAllocatorConfigurator(void* *ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long stringLength;
  
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemResourceTemplateSecondary;
  ResourceManagerPointer[1] = ResourceManagerPointer + 3;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *(uint8_t *)(ResourceManagerPointer + 3) = 0;
  if (ConfigurationDataPointer != 0) {
    stringLength = -1;
    do {
      stringLength = stringLength + 1;
    } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
    *(int *)(ResourceManagerPointer + 2) = (int)stringLength;
    strcpy_s(ResourceManagerPointer[1],0x10,ConfigurationDataPointer,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源回调执行器
 * 
 * 该函数负责执行系统资源的回调函数，遍历资源链表并调用每个资源的回调函数。
 * 这是一个重要的资源管理函数，用于在特定时机触发资源的回调操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向包含回调函数的资源链表
 * @note 这是系统资源管理的关键函数，用于执行资源的生命周期回调
 */
void SystemResourceCallbackExecutor(long long *ResourceManagerPointer)

{
  void* *ResourceListEnd;
  void** CurrentResourceNode;
  
  ResourceListEnd = (void* *)ResourceManagerPointer[1];
  CurrentResourceNode = (void* *)*ResourceManagerPointer;
  if (CurrentResourceNode != ResourceListEnd) {
    do {
      (**(code **)*CurrentResourceNode)(CurrentResourceNode,0);
      CurrentResourceNode = CurrentResourceNode + 4;
    } while (CurrentResourceNode != ResourceListEnd);
    ResourceManagerPointer[1] = *ResourceManagerPointer;
    return;
  }
  ResourceManagerPointer[1] = (long long)CurrentResourceNode;
  return;
}




/**
 * @brief 系统数据表处理器
 * 
 * 该函数负责处理系统数据表的操作，包括数据表的初始化、配置和管理。
 * 主要用于系统数据结构的设置和维护工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2
 * @param AdditionalParameter 参数3
 * @param ConfigurationFlag 参数4
 * @note 这是系统数据处理的核心函数
 */
void ProcessSystemDataTable(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 0xb) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,AdditionalParameter,ConfigurationFlag,allocationContext);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}





/**
 * @brief 系统资源数组扩展器
 * 
 * 该函数负责扩展系统资源数组，当数组空间不足时进行动态扩容。
 * 主要用于系统资源数组的动态管理和内存分配。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数指针
 * @note 这是系统资源管理的核心函数，负责动态扩容
 */
void ExpandSystemResourceArray(long long *ResourceManagerPointer,uint32_t *ConfigurationDataPointer)

{
  long long nextDataIndex;
  uint32_t *HashEntryStatus;
  uint32_t *HashNodePointer;
  uint32_t *punsignedSystemValue4;
  
  punsignedSystemValue4 = (uint32_t *)ResourceManagerPointer[1];
  if (punsignedSystemValue4 < (uint32_t *)ResourceManagerPointer[2]) {
    ResourceManagerPointer[1] = (long long)(punsignedSystemValue4 + 1);
    *punsignedSystemValue4 = *ConfigurationDataPointer;
    return;
  }
  HashNodePointer = (uint32_t *)*ResourceManagerPointer;
  nextDataIndex = (long long)punsignedSystemValue4 - (long long)HashNodePointer >> 2;
  if (nextDataIndex == 0) {
    nextDataIndex = 1;
  }
  else {
    nextDataIndex = nextDataIndex * 2;
    if (nextDataIndex == 0) {
      HashEntryStatus = (uint32_t *)0x0;
      goto SystemResourceComplete;
    }
  }
  HashEntryStatus = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex * 4,(char)ResourceManagerPointer[3]);
  HashNodePointer = (uint32_t *)*ResourceManagerPointer;
  punsignedSystemValue4 = (uint32_t *)ResourceManagerPointer[1];
SystemResourceComplete:
  if (HashNodePointer != punsignedSystemValue4) {
      memmove(HashEntryStatus,HashNodePointer,(long long)punsignedSystemValue4 - (long long)HashNodePointer);
  }
  *HashEntryStatus = *ConfigurationDataPointer;
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = (long long)HashEntryStatus;
  ResourceManagerPointer[1] = (long long)(HashEntryStatus + 1);
  ResourceManagerPointer[2] = (long long)(HashEntryStatus + nextDataIndex);
  return;
}




/**
 * @brief 系统上下文初始化器
 * 
 * 该函数负责初始化系统上下文，设置系统上下文的基本参数和状态。
 * 主要用于系统上下文的创建和配置工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是系统上下文管理的核心函数
 */
void InitializeSystemContext(long long ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  
  pointerToUnsigned1 = *(void* **)(ResourceManagerPointer + 0x10);
  if (pointerToUnsigned1 != (void* *)0x0) {
    InitializeSystemContext(ResourceManagerPointer,*pointerToUnsigned1);
      SystemCleanupFunction(pointerToUnsigned1);
  }
  *(long long *)ResourceManagerPointer = ResourceManagerPointer;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x18) = 0;
  *(void* *)(ResourceManagerPointer + 0x20) = 0;
  *(long long *)(ResourceManagerPointer + 8) = ResourceManagerPointer;
  return;
}




// 函数: void SystemCleanupWrapper(void)
/**
 * @brief 系统清理包装函数
 * 
 * 该函数是系统清理操作的包装函数，它调用系统清理函数来释放资源
 * 并执行必要的清理操作。确保系统资源被正确释放。
 * 
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemCleanupWrapper(void)

{
  InitializeSystemContext();
    SystemCleanupFunction();
}




// 函数: void SystemNodeInitialize(void)
/**
 * @brief 系统节点初始化函数
 * 
 * 该函数负责初始化系统节点的基本结构，设置节点的自引用指针、
 * 数据指针和状态标志。它为系统节点准备基本的数据结构。
 * 
 * @note 这是系统节点管理的基础函数，用于初始化节点结构
 */
void SystemNodeInitializer(void)

{
  long long systemMemoryBlockPtr;
  
  *(long long *)systemMemoryBlockPtr = systemMemoryBlockPtr;
  *(void* *)(systemMemoryBlockPtr + 0x10) = 0;
  *(uint8_t *)(systemMemoryBlockPtr + 0x18) = 0;
  *(void* *)(systemMemoryBlockPtr + 0x20) = 0;
  *(long long *)(systemMemoryBlockPtr + 8) = systemMemoryBlockPtr;
  return;
}





// 函数: void ResizeSystemMemoryPool(long long *ResourceManagerPointer,ulong long ConfigurationDataPointer)
// 功能: 调整系统内存池大小，处理内存分配和重新分配
void ResizeSystemMemoryPool(long long *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  long long nextDataIndex;
  ulong long creationFlags;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  
  localSystemPointer = ResourceManagerPointer[1];
  localSystemFlags = *ResourceManagerPointer;
  creationFlags = localSystemPointer - localSystemFlags >> 3;
  if (ConfigurationDataPointer <= creationFlags) {
    ResourceManagerPointer[1] = localSystemFlags + ConfigurationDataPointer * 8;
    return;
  }
  unsignedSystemValue4 = ConfigurationDataPointer - creationFlags;
  if (unsignedSystemValue4 <= (ulong long)(ResourceManagerPointer[2] - localSystemPointer >> 3)) {
    if (unsignedSystemValue4 != 0) {
        memset(localSystemPointer,0,unsignedSystemValue4 * 8);
    }
    ResourceManagerPointer[1] = localSystemPointer;
    return;
  }
  allocationContext = creationFlags * 2;
  if (creationFlags == 0) {
    allocationContext = 1;
  }
  if (allocationContext < ConfigurationDataPointer) {
    allocationContext = ConfigurationDataPointer;
  }
  if (allocationContext == 0) {
    nextDataIndex = 0;
  }
  else {
    nextDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,allocationContext * 8,(char)ResourceManagerPointer[3]);
    localSystemFlags = *ResourceManagerPointer;
    localSystemPointer = ResourceManagerPointer[1];
  }
  if (localSystemFlags != localSystemPointer) {
      memmove(nextDataIndex,localSystemFlags,localSystemPointer - localSystemFlags);
  }
  if (unsignedSystemValue4 != 0) {
      memset(nextDataIndex,0,unsignedSystemValue4 * 8);
  }
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = nextDataIndex;
  ResourceManagerPointer[2] = nextDataIndex + allocationContext * 8;
  ResourceManagerPointer[1] = nextDataIndex;
  return;
}





// 函数: void AllocateSystemMemoryBlock(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)
// 功能: 分配系统内存块，处理内存分配和初始化
void AllocateSystemMemoryBlock(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)

{
  long long in_RAX;
  long long nextDataIndex;
  long long *systemMemoryBlockPtr;
  ulong long creationFlags;
  ulong long allocationContext;
  long long systemDataIndexPtr;
  
  allocationContext = ConfigurationDataPointer - ResourceManagerPointer;
  if (allocationContext <= (ulong long)(in_RAX - systemDataIndexPtr >> 3)) {
    if (allocationContext != 0) {
        memset();
    }
    systemMemoryBlockPtr[1] = systemDataIndexPtr;
    return;
  }
  creationFlags = ResourceManagerPointer * 2;
  if (ResourceManagerPointer == 0) {
    creationFlags = 1;
  }
  if (creationFlags < ConfigurationDataPointer) {
    creationFlags = ConfigurationDataPointer;
  }
  if (creationFlags == 0) {
    nextDataIndex = 0;
  }
  else {
    nextDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,creationFlags * 8,(char)systemMemoryBlockPtr[3]);
    ConfigurationFlag = *systemMemoryBlockPtr;
    systemDataIndexPtr = systemMemoryBlockPtr[1];
  }
  if (ConfigurationFlag != systemDataIndexPtr) {
      memmove(nextDataIndex,ConfigurationFlag,systemDataIndexPtr - ConfigurationFlag);
  }
  if (allocationContext != 0) {
      memset(nextDataIndex,0,allocationContext * 8);
  }
  if (*systemMemoryBlockPtr != 0) {
      SystemCleanupFunction();
  }
  *systemMemoryBlockPtr = nextDataIndex;
  systemMemoryBlockPtr[2] = nextDataIndex + creationFlags * 8;
  systemMemoryBlockPtr[1] = nextDataIndex;
  return;
}




// 函数: void SystemMemoryPoolInitialize(void)
/**
 * @brief 系统内存清零函数
 * 
 * 该函数负责清零系统内存区域，确保内存处于初始状态。
 * 它会检查内存指针的有效性，然后执行内存清零操作。
 * 
 * @note 这是系统内存管理的重要组成部分，用于内存初始化
 */
void SystemMemoryZeroer(void)

{
  long long systemMemoryBlockPtr;
  long long systemStringIteratorPtr;
  void* systemDataIndexPtr;
  
  if (systemStringIteratorPtr != 0) {
      memset();
  }
  *(void* *)(systemMemoryBlockPtr + 8) = systemDataIndexPtr;
  return;
}




// 函数: void UpdateSystemMemoryPointer(void* ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)
// 功能: 更新系统内存指针，计算新的内存地址
void UpdateSystemMemoryPointer(void* ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)

{
  long long systemMemoryBlockPtr;
  
  *(long long *)(systemMemoryBlockPtr + 8) = ConfigurationFlag + ConfigurationDataPointer * 8;
  return;
}




// 函数: void ProcessSystemResourceOperation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
// 功能: 处理系统资源操作，调用相关的系统资源处理函数
void ProcessSystemResourceOperation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ConfigureSystemResource(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void CleanupSystemResources(long long *ResourceManagerPointer)
// 功能: 清理系统资源，释放分配的内存和资源
void CleanupSystemResources(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x48) {
    DestroySystemResource(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源处理器
 * 
 * 该函数负责处理系统资源，调用系统资源处理函数来执行具体的资源操作。
 * 它会传递系统资源指针和相关参数给处理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 处理参数
 * @param AdditionalParameter 处理参数
 * @param ConfigurationFlag 处理参数
 * @note 这是系统资源管理的核心处理函数
 */
void ProcessSystemResource(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemConfiguration(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统内存块处理器
 * 
 * 该函数负责处理系统内存块，调用内存块处理函数来执行具体的内存操作。
 * 它会传递系统资源指针和相关参数给内存块处理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 处理参数
 * @param AdditionalParameter 处理参数
 * @param ConfigurationFlag 处理参数
 * @note 这是系统内存管理的核心处理函数
 */
void ProcessSystemMemoryBlock(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessMemoryBlock(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void ReleaseSystemMemoryHandles(long long ResourceManagerPointer)
// 功能: 释放系统内存句柄，清理相关的内存资源
void ReleaseSystemMemoryHandles(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源数组清理器
 * 
 * 该函数负责清理系统资源数组，遍历数组中的每个资源并调用清理函数。
 * 它会确保每个资源都被正确释放，并将数组中的指针设置为0。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源数组信息
 * @note 这是系统资源管理的重要清理函数，用于释放资源数组中的所有资源
 */
void CleanupSystemResourceArray(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemCleanupFunction(void)
/**
 * @brief 系统清理函数
 * 
 * 该函数负责清理系统资源，释放内存和重置系统状态。
 * 用于系统关闭或重启时的资源清理工作。
 */
void SystemCleanupFunction(void)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  long long systemStackFramePtr;
  ulong long systemStringIteratorPtr;
  ulong long systemDataIndexPtr;
  ulong long unsignedSystemValue4;
  long long systemResourceCounter;
  void* systemResourceHandle;
  
  do {
    localResourceOffset = *(long long *)(systemResourceCounter + systemDataIndexPtr * 8);
    if (localResourceOffset != 0) {
        SystemCleanupFunction(localResourceOffset);
    }
    *(void* *)(systemResourceCounter + systemDataIndexPtr * 8) = systemResourceHandle;
    systemDataIndexPtr = systemDataIndexPtr + 1;
  } while (systemDataIndexPtr < systemStringIteratorPtr);
  *(void* *)(systemStackFramePtr + 0x18) = systemResourceHandle;
  if ((1 < *(ulong long *)(systemStackFramePtr + 0x10)) &&
     (HashEntryStatus = *(void* **)(systemStackFramePtr + 8), HashEntryStatus != (void* *)0x0)) {
    unsignedSystemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
    if (unsignedSystemValue4 != 0) {
      localResourceOffset = unsignedSystemValue4 + 0x80 + ((long long)HashEntryStatus - unsignedSystemValue4 >> 0x10) * 0x50;
      localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
      if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
        *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
        *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
        pointerToInteger1 = (int *)(localResourceOffset + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                            HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理相关的数据结构和指针。
 * 用于系统资源管理的前期准备工作。
 */
void InitializeSystemResourceManager(void)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  long long systemStackFramePtr;
  ulong long systemStringIteratorPtr;
  ulong long unsignedSystemValue4;
  void* systemResourceHandle;
  
  *(void* *)(systemStackFramePtr + 0x18) = systemResourceHandle;
  if ((1 < systemStringIteratorPtr) && (HashEntryStatus = *(void* **)(systemStackFramePtr + 8), HashEntryStatus != (void* *)0x0)) {
    unsignedSystemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
    if (unsignedSystemValue4 != 0) {
      localResourceOffset = unsignedSystemValue4 + 0x80 + ((long long)HashEntryStatus - unsignedSystemValue4 >> 0x10) * 0x50;
      localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
      if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
        *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
        *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
        pointerToInteger1 = (int *)(localResourceOffset + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                            HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void InitializeSystemResourceAllocator(void)
/**
 * @brief 系统资源分配器初始化函数
 * 
 * 该函数负责初始化系统资源分配器，设置资源分配相关的数据结构和参数。
 * 用于系统资源分配的前期准备工作。
 */
void InitializeSystemResourceAllocator(void)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  long long systemStackFramePtr;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = *(void* **)(systemStackFramePtr + 8);
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void SystemResourceHandlerDelegate(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源处理委托函数
 * 
 * 该函数是系统资源处理的委托函数，它调用底层的资源处理函数
 * 来执行具体的资源管理任务。它提供了一个统一的资源处理接口。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 处理参数2（未使用）
 * @param AdditionalParameter 处理参数3
 * @param ConfigurationFlag 处理参数4
 * @note 这是系统资源管理的委托处理函数
 */
void SystemResourceHandlerDelegate(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
 */
void SystemResourceHandlerDelegate(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ReleaseMemoryRegion(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void ProcessResourceArrayCleanup(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 资源数组清理处理函数
 * 
 * 该函数遍历资源指针数组，对每个资源调用其清理函数。
 * 主要用于批量处理资源的清理操作，确保所有资源都被正确释放。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源数组信息
 * @param ConfigurationDataPointer 保留参数，当前未使用
 * @param AdditionalParameter 传递给资源清理函数的参数
 * @param ConfigurationFlag 传递给资源清理函数的参数
 * @note 这是资源批量清理的核心函数
 */
void ProcessResourceArrayCleanup(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 0x69) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,AdditionalParameter,ConfigurationFlag,allocationContext);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void CleanupSystemResourceHandles(long long ResourceManagerPointer)
/**
 * @brief 系统资源句柄清理器
 * 
 * 该函数负责清理系统资源句柄数组，遍历所有句柄并调用相应的清理函数。
 * 确保所有系统资源都被正确释放，避免资源泄漏。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含句柄数组信息
 * @note 这是系统资源管理的重要组成部分，用于清理系统句柄
 */
void CleanupSystemResourceHandles(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  
  allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
  unsignedSystemValue4 = 0;
  if (allocationContext != 0) {
    do {
      localSystemHandle = *(long long *)(nextDataIndex + unsignedSystemValue4 * 8);
      if (localSystemHandle != 0) {
        if (*(long long **)(localSystemHandle + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(localSystemHandle + 0x10) + 0x38))();
        }
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(nextDataIndex + unsignedSystemValue4 * 8) = 0;
      unsignedSystemValue4 = unsignedSystemValue4 + 1;
    } while (unsignedSystemValue4 < allocationContext);
    allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < allocationContext) && (*(long long *)(ResourceManagerPointer + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: void SystemQueueProcessor(long long *ResourceManagerPointer)
/**
 * @brief 系统队列处理器
 * 
 * 该函数遍历系统资源队列，对每个队列项调用处理函数。
 * 主要用于批量处理系统队列中的项目。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含队列信息
 * @note 这是系统队列管理的核心函数
 */
void ProcessSystemQueue(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x18) {
    ProcessQueueItem(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SystemBufferCleaner(long long ResourceManagerPointer)
/**
 * @brief 系统缓冲区清理器
 * 
 * 该函数负责清理系统缓冲区中的资源，遍历缓冲区并调用清理函数。
 * 主要用于释放缓冲区占用的资源，避免内存泄漏。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含缓冲区信息
 * @note 这是系统缓冲区管理的重要组成部分
 */
void CleanupSystemBuffer(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void HandleResourceDataProcessing(long long ResourceManagerPointer)
/**
 * @brief 系统资源深度清理器
 * 
 * 该函数负责深度清理系统资源，遍历资源数组并调用清理函数。
 * 主要用于系统关闭时的资源清理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源数组信息
 * @note 这是系统资源深度清理的核心函数
 */
void DeepCleanupSystemResources(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long hashValue;
  
  hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
  currentThreadId = 0;
  if (hashValue != 0) {
    do {
      localSystemHandle = *(long long *)(bufferBaseAddress + currentThreadId * 8);
      if (localSystemHandle != 0) {
          SystemCleanupFunction(localSystemHandle);
      }
      *(void* *)(bufferBaseAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < hashValue);
    hashValue = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < hashValue) && (HashNodePointer = *(void* **)(ResourceManagerPointer + 8), HashNodePointer != (void* *)0x0)) {
    hashValue = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (hashValue != 0) {
      bufferBaseAddress = hashValue + 0x80 + ((long long)HashNodePointer - hashValue >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(hashValue + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(hashValue,CONCAT71(0xff000000,*(void ***)(hashValue + 0x70) == &ExceptionList),
                            HashNodePointer,hashValue,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: 系统内存清理器 - 负责清理系统内存
/**
 * @brief 系统内存清理器
 * 
 * 该函数负责清理系统内存中的无效指针和资源。它会遍历内存块，
 * 检查每个内存块的状态，并清理不再需要的内存资源。
 * 
 * @note 这是系统内存管理的重要组成部分，确保系统内存的有效利用
 */
void SystemMemoryCleanup(void)

{
  int *memoryReferenceCount;
  void** SystemDataTable;
  long long memoryBlockAddress;
  long long memoryBlockBase;
  ulong long memoryBlockCount;
  ulong long memoryBlockIndex;
  ulong long memoryBlockFlags;
  long long memoryBlockPointer;
  void* memoryBlockValue;
  
  do {
    memoryBlockAddress = *(long long *)(memoryBlockPointer + memoryBlockIndex * 8);
    if (memoryBlockAddress != 0) {
        ReleaseMemoryBlock(memoryBlockAddress);
    }
    *(void* *)(memoryBlockPointer + memoryBlockIndex * 8) = memoryBlockValue;
    memoryBlockIndex = memoryBlockIndex + 1;
  } while (memoryBlockIndex < memoryBlockCount);
  *(void* *)(memoryBlockBase + 0x18) = memoryBlockValue;
  if ((1 < *(ulong long *)(memoryBlockBase + 0x10)) &&
     (systemMemoryBlock = *(void* **)(memoryBlockBase + 8), systemMemoryBlock != (void* *)0x0)) {
    memoryBlockFlags = (ulong long)systemMemoryBlock & 0xffffffffffc00000;
    if (memoryBlockFlags != 0) {
      memoryBlockAddress = memoryBlockFlags + 0x80 + ((long long)systemMemoryBlock - memoryBlockFlags >> 0x10) * 0x50;
      memoryBlockAddress = memoryBlockAddress - (ulong long)*(uint *)(memoryBlockAddress + 4);
      if ((*(void ***)(memoryBlockFlags + 0x70) == &ExceptionList) && (*(char *)(memoryBlockAddress + 0xe) == '\0')) {
        *systemMemoryBlock = *(void* *)(memoryBlockAddress + 0x20);
        *(void* **)(memoryBlockAddress + 0x20) = systemMemoryBlock;
        memoryReferenceCount = (int *)(memoryBlockAddress + 0x18);
        *memoryReferenceCount = *memoryReferenceCount + -1;
        if (*memoryReferenceCount == 0) {
          CleanupSystemMemoryManager();
          return;
        }
      }
      else {
        ProcessMemoryBlockException(memoryBlockFlags,CONCAT71(0xff000000,*(void ***)(memoryBlockFlags + 0x70) == &ExceptionList),
                            systemMemoryBlock,memoryBlockFlags,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: 系统资源释放器 - 负责释放系统资源
/**
 * @brief 系统资源释放器
 * 
 * 该函数负责释放系统中的资源，包括内存块、文件句柄、网络连接等。
 * 它会检查资源的使用状态，并安全地释放不再需要的资源。
 * 
 * @note 这是系统资源管理的重要组成部分，确保系统资源的正确释放
 */
void SystemResourceRelease(void)

{
  int *resourceReferenceCount;
  void** SystemDataTable;
  long long resourceAddress;
  long long resourceBase;
  ulong long resourceCount;
  ulong long resourceFlags;
  void* resourceValue;
  
  *(void* *)(resourceBase + 0x18) = resourceValue;
  if ((1 < resourceCount) && (systemResource = *(void* **)(resourceBase + 8), systemResource != (void* *)0x0)) {
    resourceFlags = (ulong long)systemResource & 0xffffffffffc00000;
    if (resourceFlags != 0) {
      resourceAddress = resourceFlags + 0x80 + ((long long)systemResource - resourceFlags >> 0x10) * 0x50;
      resourceAddress = resourceAddress - (ulong long)*(uint *)(resourceAddress + 4);
      if ((*(void ***)(resourceFlags + 0x70) == &ExceptionList) && (*(char *)(resourceAddress + 0xe) == '\0')) {
        *systemResource = *(void* *)(resourceAddress + 0x20);
        *(void* **)(resourceAddress + 0x20) = systemResource;
        resourceReferenceCount = (int *)(resourceAddress + 0x18);
        *resourceReferenceCount = *resourceReferenceCount + -1;
        if (*resourceReferenceCount == 0) {
          CleanupResourceManager();
          return;
        }
      }
      else {
        ProcessResourceException(resourceFlags,CONCAT71(0xff000000,*(void ***)(resourceFlags + 0x70) == &ExceptionList),
                            systemResource,resourceFlags,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemExceptionHandler(void)
/**
 * @brief 系统异常处理函数
 * 
 * 该函数负责处理系统异常，管理异常列表和异常处理逻辑。
 * 用于系统运行时的异常情况处理。
 */
void SystemExceptionHandler(void)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  long long systemStackFramePtr;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = *(void* **)(systemStackFramePtr + 8);
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void ReleaseSystemResources(long long *ResourceManagerPointer)
/**
 * @brief 系统资源释放函数
 * 
 * 该函数负责释放系统资源，遍历资源指针数组并调用相应的释放函数。
 * 用于系统资源管理和内存清理工作。
 */
void ReleaseSystemResources(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)ResourceManagerPointer[1];
  for (resourcePoolPointer = (long long *)*ResourceManagerPointer; resourcePoolPointer != PrimaryResourcePointer; resourcePoolPointer = resourcePoolPointer + 1) {
    if ((long long *)*resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*(long long *)*resourcePoolPointer + 0x38))();
    }
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}





// 函数: void DestroyRenderingSystem(void)
/**
 * @brief 渲染系统销毁函数
 * 
 * 该函数负责销毁渲染系统，清理渲染相关的资源和内存。
 * 用于系统关闭时的渲染资源清理工作。
 */
void DestroyRenderingSystem(void)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = SystemRenderManagerPointer;
  if (SystemRenderManagerPointer == (void* *)0x0) {
    return;
  }
  ReleaseSystemResources();
  if ((long long *)HashEntryStatus[0x30b] != (long long *)0x0) {
    (**(code **)(*(long long *)HashEntryStatus[0x30b] + 0x38))();
  }
  _Mtx_destroy_in_situ();
  if ((long long *)HashEntryStatus[0x300] != (long long *)0x0) {
    (**(code **)(*(long long *)HashEntryStatus[0x300] + 0x38))();
  }
  if ((long long *)HashEntryStatus[0x2d3] != (long long *)0x0) {
    (**(code **)(*(long long *)HashEntryStatus[0x2d3] + 0x38))();
  }
  if ((long long *)HashEntryStatus[0x2c0] != (long long *)0x0) {
    (**(code **)(*(long long *)HashEntryStatus[0x2c0] + 0x38))();
  }
  ExecuteDataOperation(HashEntryStatus + 0x116);
  ProcessDataValidation(HashEntryStatus + 6);
  if (HashEntryStatus[2] != 0) {
      SystemCleanupFunction();
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 处理系统字符串数据
 * 
 * 该函数负责处理系统中的字符串数据，包括字符串的解析、
 * 分配和管理。用于系统字符串操作的核心功能。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递字符串处理的相关数据
 * @param AdditionalParameter 参数3，字符串数据源
 * @param ConfigurationFlag 参数4，字符串处理标志
 * @note 这是字符串处理系统的核心函数
 */
void ProcessSystemStringData(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  char SystemNodeFlag;
  long long localSystemHandle;
  char *pathStringPointer;
  char *psystemStatusFlag;
  void* currentThreadId;
  void* *memoryAllocationEnd;
  long long lStack_48;
  uint32_t unsignedValue40;
  ulong long uStack_38;
  
  currentThreadId = 0xfffffffffffffffe;
  pathStringPointer = *(char **)(ResourceManagerPointer + 8);
  initializationStatusFlag = *pathStringPointer;
  psystemStatusFlag = pathStringPointer;
  if (initializationStatusFlag != '\0') {
    do {
      localSystemHandle = strchr(AdditionalParameter,(int)initializationStatusFlag);
      if ((localSystemHandle != 0) && (psystemStatusFlag != pathStringPointer)) {
        memoryAllocationEnd = &SystemGlobalDataReference;
        uStack_38 = 0;
        lStack_48 = 0;
        unsignedValue40 = 0;
        ProcessSystemMemoryAllocation(&memoryAllocationEnd,psystemStatusFlag,(int)pathStringPointer - (int)psystemStatusFlag,ConfigurationFlag,currentThreadId);
        psystemStatusFlag = pathStringPointer + 1;
        if (*(ulong long *)(ConfigurationDataPointer + 8) < *(ulong long *)(ConfigurationDataPointer + 0x10)) {
          *(ulong long *)(ConfigurationDataPointer + 8) = *(ulong long *)(ConfigurationDataPointer + 8) + 0x20;
          InitializeSystemMemoryAllocator();
        }
        else {
          ProcessSystemConfiguration(ConfigurationDataPointer,&memoryAllocationEnd);
        }
        memoryAllocationEnd = &SystemGlobalDataReference;
        if (lStack_48 != 0) {
            SystemCleanupFunction();
        }
        lStack_48 = 0;
        uStack_38 = uStack_38 & 0xffffffff00000000;
        memoryAllocationEnd = &SystemMemoryAllocatorReference;
      }
      pathStringPointer = pathStringPointer + 1;
      initializationStatusFlag = *pathStringPointer;
    } while (initializationStatusFlag != '\0');
    if (psystemStatusFlag != pathStringPointer) {
      memoryAllocationEnd = &SystemGlobalDataReference;
      uStack_38 = 0;
      lStack_48 = 0;
      unsignedValue40 = 0;
      ProcessSystemMemoryAllocation(&memoryAllocationEnd,psystemStatusFlag,(int)pathStringPointer - (int)psystemStatusFlag,ConfigurationFlag,currentThreadId);
      if (*(ulong long *)(ConfigurationDataPointer + 8) < *(ulong long *)(ConfigurationDataPointer + 0x10)) {
        *(ulong long *)(ConfigurationDataPointer + 8) = *(ulong long *)(ConfigurationDataPointer + 8) + 0x20;
        InitializeSystemMemoryAllocator();
      }
      else {
        ProcessSystemConfiguration(ConfigurationDataPointer,&memoryAllocationEnd);
      }
      memoryAllocationEnd = &SystemGlobalDataReference;
      if (lStack_48 != 0) {
          SystemCleanupFunction();
      }
    }
  }
  return;
}




long long * InitializeSystemModule(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter)

{
  byte isByteValid;
  uint creationFlags;
  long long localResourceOffset;
  long long bufferBaseAddress;
  byte *pisMemoryReady;
  long long localSystemFlags;
  void* unsignedSystemValue7;
  char acStackX_8 [8];
  
  localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x40,*(uint8_t *)(ResourceManagerPointer + 0x28));
  CreateSystemObject(localResourceOffset + 0x20,AdditionalParameter);
  bufferBaseAddress = SystemResourceAllocator(ResourceManagerPointer,acStackX_8,localResourceOffset + 0x20);
  if (acStackX_8[0] == '\0') {
    ProcessExtraOutputResource();
    *ConfigurationDataPointer = bufferBaseAddress;
    *(uint8_t *)(ConfigurationDataPointer + 1) = 0;
    return ConfigurationDataPointer;
  }
  if (bufferBaseAddress != ResourceManagerPointer) {
    if (*(int *)(bufferBaseAddress + 0x30) == 0) {
SystemMemoryCheck:
      unsignedSystemValue7 = 1;
      goto SystemMemoryComplete;
    }
    if (*(int *)(localResourceOffset + 0x30) != 0) {
      pisMemoryReady = *(byte **)(bufferBaseAddress + 0x28);
      localSystemFlags = *(long long *)(localResourceOffset + 0x28) - (long long)pisMemoryReady;
      do {
        isByteValid = *pisMemoryReady;
        creationFlags = (uint)pisMemoryReady[localSystemFlags];
        if (isByteValid != creationFlags) break;
        pisMemoryReady = pisMemoryReady + 1;
      } while (creationFlags != 0);
      if ((int)(isByteValid - creationFlags) < 1) goto SystemMemoryCheck;
    }
  }
  unsignedSystemValue7 = 0;
SystemMemoryComplete:
    ConfigureSystemResourceHandle(localResourceOffset,bufferBaseAddress,ResourceManagerPointer,unsignedSystemValue7);
}




/**
 * @brief 清理系统资源处理器
 * 
 * 该函数负责清理系统资源处理器，包括释放内存、
 * 重置指针和清理相关数据结构。当系统资源不再需要时调用。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是资源管理系统的重要组成部分
 */
void CleanupSystemResourceHandler(void* *ResourceManagerPointer)

{
  if (ResourceManagerPointer == (void* *)0x0) {
    return;
  }
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[4] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 7) = 0;
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ResourceManagerPointer);
}




/**
 * @brief 初始化系统资源处理器
 * 
 * 该函数负责初始化系统资源处理器，设置内存分配器、
 * 数据表和相关配置。用于系统资源管理的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，初始化标志
 * @param AdditionalParameter 参数3，初始化数据源
 * @param ConfigurationFlag 参数4，初始化配置
 * @return 返回初始化后的系统资源处理器指针
 * @note 这是资源管理系统的初始化函数
 */
void* * InitializeSystemResourceHandler(void* *ResourceManagerPointer,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = &SystemResourceData2;
  ReleaseSystemResourceHandle(SystemAllocationFlagsTemplate,ResourceManagerPointer[0x28],AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  ResourceManagerPointer[0x28] = 0;
  ResourceManagerPointer[0x29] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[0x2a] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x2a] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x2c) = 0;
  ResourceManagerPointer[0x29] = &SystemMemoryAllocatorReference;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x170);
  }
  return ResourceManagerPointer;
}




// 函数: void ProcessSystemResourceData(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemResourceData(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  ProcessSystemResourceInitialization();
  ProcessSystemResourceInitialization();
  ResourceManagerPointer[0x123] = (long long)&SystemGlobalDataReference;
  if (ResourceManagerPointer[0x124] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x124] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x126) = 0;
  ResourceManagerPointer[0x123] = (long long)&SystemMemoryAllocatorReference;
  ProcessMemoryBlock(ResourceManagerPointer + 0x11d,ResourceManagerPointer[0x11f],AdditionalParameter,ConfigurationFlag,allocationContext);
  if (ResourceManagerPointer[0x119] == 0) {
    CleanupSystemMemoryAllocation();
    CleanupSystemMemoryAllocation();
    ProcessSystemResourceExtension(ResourceManagerPointer + 0x10b,ResourceManagerPointer[0x10d]);
    ResourceManagerPointer[0x87] = (long long)&SystemMemoryAllocatorReference;
    ResourceManagerPointer[4] = (long long)&SystemMemoryAllocatorReference;
    allocationContext = 0xfffffffffffffffe;
    pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
    for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 4) {
      (**(code **)*HashEntryStatus)(HashEntryStatus,0,AdditionalParameter,ConfigurationFlag,allocationContext);
    }
    if (*ResourceManagerPointer == 0) {
      return;
    }
      SystemCleanupFunction();
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemResource(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源初始化器函数
 * 
 * 该函数负责初始化系统资源，配置资源参数并设置初始化标志。
 * 它会调用资源初始化子函数，确保资源被正确初始化。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含资源的配置信息
 * @param AdditionalParameter 保留参数，用于扩展功能
 * @param ConfigurationFlag 保留参数，用于扩展功能
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确初始化
 */
void InitializeSystemResource(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceExtension(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void ReleaseResourceManagerPointer(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ReleaseResourceManagerPointer(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  
  pointerToUnsigned1 = *(void* **)(ResourceManagerPointer + 0x10);
  if (pointerToUnsigned1 != (void* *)0x0) {
    ConfigureSystemResourceData(ResourceManagerPointer,*pointerToUnsigned1,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    ValidateSystemResourceConfiguration(pointerToUnsigned1);
      SystemCleanupFunction(pointerToUnsigned1);
  }
  return;
}




// 函数: void InitializeSystemResourceStream(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemResourceStream(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceExtension(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void CleanupSystemResourceStream(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void CleanupSystemResourceStream(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  
  pointerToUnsigned1 = *(void* **)(ResourceManagerPointer + 0x10);
  if (pointerToUnsigned1 != (void* *)0x0) {
    ConfigureSystemResourceData(ResourceManagerPointer,*pointerToUnsigned1,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    ValidateSystemResourceConfiguration(pointerToUnsigned1);
      SystemCleanupFunction(pointerToUnsigned1);
  }
  return;
}




// 函数: void FinalizeSystemResourceCleanup(long long *ResourceManagerPointer)
void FinalizeSystemResourceCleanup(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long localResourceOffset;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  void** SystemCurrentNode;
  
  InitializeConfigurationData();
  nextDataIndex = *ResourceManagerPointer;
  *ResourceManagerPointer = 0;
  localSystemHandle = ResourceManagerPointer[1];
  ResourceManagerPointer[1] = 0;
  localResourceOffset = ResourceManagerPointer[2];
  ResourceManagerPointer[2] = 0;
  localSystemFlags = ResourceManagerPointer[3];
  *(int *)(ResourceManagerPointer + 3) = (int)ResourceManagerPointer[3];
  punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
  *ResourceManagerPointer = nextDataIndex;
  pcurrentThreadId = (void* *)ResourceManagerPointer[1];
  ResourceManagerPointer[1] = localSystemHandle;
  ResourceManagerPointer[2] = localResourceOffset;
  *(int *)(ResourceManagerPointer + 3) = (int)localSystemFlags;
  for (HashBucketNode = punsignedSystemValue4; HashBucketNode != pcurrentThreadId; HashBucketNode = HashBucketNode + 4) {
    (**(code **)*HashBucketNode)(HashBucketNode,0);
  }
  if (punsignedSystemValue4 != (void* *)0x0) {
      SystemCleanupFunction(punsignedSystemValue4);
  }
  return;
}




// 函数: void ProcessSystemMemoryAllocation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemMemoryAllocation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceExtension(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void ReleaseSystemMemoryAllocation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ReleaseSystemMemoryAllocation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  
  pointerToUnsigned1 = *(void* **)(ResourceManagerPointer + 0x10);
  if (pointerToUnsigned1 != (void* *)0x0) {
    ConfigureSystemResourceData(ResourceManagerPointer,*pointerToUnsigned1,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    ValidateSystemResourceConfiguration(pointerToUnsigned1);
      SystemCleanupFunction(pointerToUnsigned1);
  }
  return;
}



/**
 * @brief 系统资源管理器查找函数
 * 
 * 该函数负责在系统资源管理器中查找和配置资源节点。
 * 通过遍历资源链表，根据配置参数查找匹配的资源节点，
 * 并返回相应的配置数据指针。
 * 
 * @param resourcePointer 系统资源指针，指向资源链表的头部
 * @param configDataPointer 配置数据指针，用于存储找到的配置数据
 * @param additionalParameter 额外参数，包含查找条件和配置信息
 * @return 配置数据指针，指向找到的配置数据
 * 
 * 原始函数名为FUN_180058080，现已重命名为FindSystemResourceNode
 */
void* * FindSystemResourceNode(void* *resourcePointer,void* *configDataPointer,long long additionalParameter)

{
  byte comparisonByte;
  bool isMatchFound;
  byte *dataBuffer;
  uint comparisonValue;
  int comparisonResult;
  long long offsetDifference;
  void** currentNode;
  void** nextNode;
  void* *resultNode;
  void* *currentSearchNode;
  
  if ((void* *)resourcePointer[2] != (void* *)0x0) {
    void* *previousNode = (void* *)resourcePointer[2];
    currentSearchNode = resourcePointer;
    do {
      if (*(int *)(additionalParameter + 0x10) == 0) {
        void* *nextNodePointer = (void* *)previousNode[1];
        isMatchFound = false;
      }
      else {
        if (*(int *)(previousNode + 6) == 0) {
          isMatchFound = true;
        }
        else {
          dataBuffer = *(byte **)(additionalParameter + 8);
          offsetDifference = previousNode[5] - (long long)dataBuffer;
          do {
            comparisonValue = (uint)dataBuffer[offsetDifference];
            comparisonResult = *dataBuffer - comparisonValue;
            if (*dataBuffer != comparisonValue) break;
            dataBuffer = dataBuffer + 1;
          } while (comparisonValue != 0);
          isMatchFound = 0 < comparisonResult;
          if (comparisonResult < 1) {
            void* *nextNodePointer = (void* *)previousNode[1];
            goto SystemResourceNodeCheck;
          }
        }
        void* *nextNodePointer = (void* *)*previousNode;
      }
SystemResourceNodeCheck:
      punsignedSystemValue9 = HashBucketNode;
      if (isSystemActive) {
        punsignedSystemValue9 = pointerToUnsigned10;
      }
      HashBucketNode = newThreadLocalStorage;
      pointerToUnsigned10 = punsignedSystemValue9;
    } while (newThreadLocalStorage != (void* *)0x0);
    if (punsignedSystemValue9 != ResourceManagerPointer) {
      if (*(int *)(punsignedSystemValue9 + 6) == 0) {
SystemResourceNodeValidation:
        *ConfigurationDataPointer = punsignedSystemValue9;
        return ConfigurationDataPointer;
      }
      if (*(int *)(AdditionalParameter + 0x10) != 0) {
        pisOperationComplete = (byte *)punsignedSystemValue9[5];
        localSystemFlags = *(long long *)(AdditionalParameter + 8) - (long long)pisOperationComplete;
        do {
          isByteValid = *pisOperationComplete;
          unsignedSystemValue4 = (uint)pisOperationComplete[localSystemFlags];
          if (isByteValid != unsignedSystemValue4) break;
          pisOperationComplete = pisOperationComplete + 1;
        } while (unsignedSystemValue4 != 0);
        if ((int)(isByteValid - unsignedSystemValue4) < 1) goto SystemResourceNodeValidation;
      }
    }
  }
  *ConfigurationDataPointer = ResourceManagerPointer;
  return ConfigurationDataPointer;
}




// 函数: void InitializeSystemResourceManager(ulong long *ResourceManagerPointer)
void InitializeSystemResourceManager(ulong long *ResourceManagerPointer)

{
  int *resourceCounter;
  ulong long systemValue1;
  ulong long systemValue2;
  void* *resourcePointer;
  ulong long systemValue3;
  long long systemFlags;
  
  ResourceManagerPointer[1] = *ResourceManagerPointer;
  systemValue1 = *ResourceManagerPointer;
  *ResourceManagerPointer = 0;
  systemValue2 = ResourceManagerPointer[1];
  ResourceManagerPointer[1] = 0;
  systemValue3 = ResourceManagerPointer[2];
  ResourceManagerPointer[2] = 0;
  systemFlags = ResourceManagerPointer[3];
  *(int *)(ResourceManagerPointer + 3) = (int)ResourceManagerPointer[3];
  resourcePointer = (void* *)*ResourceManagerPointer;
  *ResourceManagerPointer = systemValue1;
  ResourceManagerPointer[1] = systemValue2;
  ResourceManagerPointer[2] = systemValue3;
  *(int *)(ResourceManagerPointer + 3) = (int)systemFlags;
  if (resourcePointer == (void* *)0x0) {
    return;
  }
  systemValue1 = (ulong long)resourcePointer & 0xffffffffffc00000;
  if (systemValue1 != 0) {
    systemFlags = systemValue1 + 0x80 + ((long long)resourcePointer - systemValue1 >> 0x10) * 0x50;
    systemFlags = systemFlags - (ulong long)*(uint *)(systemFlags + 4);
    if ((*(void ***)(systemValue1 + 0x70) == &ExceptionList) && (*(char *)(systemFlags + 0xe) == '\0')) {
      *resourcePointer = *(void* *)(systemFlags + 0x20);
      *(void* **)(systemFlags + 0x20) = resourcePointer;
      resourceCounter = (int *)(systemFlags + 0x18);
      *resourceCounter = *resourceCounter + -1;
      if (*resourceCounter == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(systemValue1,CONCAT71(0xff000000,*(void ***)(systemValue1 + 0x70) == &ExceptionList),
                          resourcePointer,systemValue1,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void ProcessSystemResourceDataTransfer(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemResourceDataTransfer(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer != (void* *)0x0) {
    ConfigureSystemResource(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    if ((long long *)ConfigurationDataPointer[0x17] != (long long *)0x0) {
      (**(code **)(*(long long *)ConfigurationDataPointer[0x17] + 0x38))();
    }
    ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}




// 函数: void ProcessSystemConfiguration(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统配置数据处理函数
 * 
 * 该函数负责处理系统配置数据，包括配置验证、数据清理和资源释放。
 * 它会递归处理配置数据，确保所有相关资源都被正确处理。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含系统资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含系统的配置信息
 * @param AdditionalParameter 保留参数，用于扩展功能
 * @param ConfigurationFlag 保留参数，用于扩展功能
 * @note 这是系统配置管理的重要组成部分，用于确保配置数据的正确处理
 */
void ProcessSystemConfigurationData(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessSystemConfiguration(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  ProcessSystemDataConfiguration(ConfigurationDataPointer + 8);
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




// 函数: void ProcessMemoryBlock(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessMemoryBlock(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessMemoryBlock(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




// 函数: void ReleaseMemoryRegion(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ReleaseMemoryRegion(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ReleaseMemoryRegion(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  if (ConfigurationDataPointer[8] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}





// 函数: void ProcessSystemResourceAllocation(void* *ResourceManagerPointer,long long ConfigurationDataPointer)
void ProcessSystemResourceAllocation(void* *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  void** SystemCurrentNode;
  
  HashBucketNode = (void* *)ResourceManagerPointer[1];
  punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
  localSystemPointer = ((long long)HashBucketNode - (long long)punsignedSystemValue4) / 0x28;
  HashEntryStatus = (void* *)0x0;
  if (localSystemPointer == 0) {
    localSystemPointer = 1;
  }
  else {
    localSystemPointer = localSystemPointer * 2;
    if (localSystemPointer == 0) goto SystemPointerCheck;
  }
  HashEntryStatus = (void* *)
           CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemPointer * 0x28,*(uint8_t *)(ResourceManagerPointer + 3),punsignedSystemValue4,
                         0xfffffffffffffffe);
  HashBucketNode = (void* *)ResourceManagerPointer[1];
  punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
SystemPointerCheck:
  HashNodePointer = HashEntryStatus;
  if (punsignedSystemValue4 != HashBucketNode) {
    localSystemFlags = (long long)HashEntryStatus - (long long)punsignedSystemValue4;
    punsignedSystemValue4 = punsignedSystemValue4 + 1;
    do {
      *HashNodePointer = &SystemMemoryAllocatorReference;
      *(void* *)(localSystemFlags + (long long)punsignedSystemValue4) = 0;
      *(uint32_t *)(localSystemFlags + 8 + (long long)punsignedSystemValue4) = 0;
      *HashNodePointer = &SystemGlobalDataReference;
      *(void* *)(localSystemFlags + 0x10 + (long long)punsignedSystemValue4) = 0;
      *(void* *)(localSystemFlags + (long long)punsignedSystemValue4) = 0;
      *(uint32_t *)(localSystemFlags + 8 + (long long)punsignedSystemValue4) = 0;
      *(uint32_t *)(localSystemFlags + 8 + (long long)punsignedSystemValue4) = *(uint32_t *)(punsignedSystemValue4 + 1);
      *(void* *)(localSystemFlags + (long long)punsignedSystemValue4) = *punsignedSystemValue4;
      *(uint32_t *)(localSystemFlags + 0x14 + (long long)punsignedSystemValue4) = *(uint32_t *)((long long)punsignedSystemValue4 + 0x14);
      *(uint32_t *)(localSystemFlags + 0x10 + (long long)punsignedSystemValue4) = *(uint32_t *)(punsignedSystemValue4 + 2);
      *(uint32_t *)(punsignedSystemValue4 + 1) = 0;
      *punsignedSystemValue4 = 0;
      punsignedSystemValue4[2] = 0;
      *(uint32_t *)(localSystemFlags + 0x18 + (long long)punsignedSystemValue4) = *(uint32_t *)(punsignedSystemValue4 + 3);
      HashNodePointer = HashNodePointer + 5;
      pointerToUnsigned1 = punsignedSystemValue4 + 4;
      punsignedSystemValue4 = punsignedSystemValue4 + 5;
    } while (pointerToUnsigned1 != HashBucketNode);
  }
  *HashNodePointer = &SystemMemoryAllocatorReference;
  HashNodePointer[1] = 0;
  *(uint32_t *)(HashNodePointer + 2) = 0;
  *HashNodePointer = &SystemGlobalDataReference;
  HashNodePointer[3] = 0;
  HashNodePointer[1] = 0;
  *(uint32_t *)(HashNodePointer + 2) = 0;
  *(uint32_t *)(HashNodePointer + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  HashNodePointer[1] = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)((long long)HashNodePointer + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(HashNodePointer + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  *(uint32_t *)(HashNodePointer + 4) = *(uint32_t *)(ConfigurationDataPointer + 0x20);
  HashBucketNode = (void* *)ResourceManagerPointer[1];
  punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
  if (punsignedSystemValue4 != HashBucketNode) {
    do {
      *punsignedSystemValue4 = &SystemGlobalDataReference;
      if (punsignedSystemValue4[1] != 0) {
          SystemCleanupFunction();
      }
      punsignedSystemValue4[1] = 0;
      *(uint32_t *)(punsignedSystemValue4 + 3) = 0;
      *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
      punsignedSystemValue4 = punsignedSystemValue4 + 5;
    } while (punsignedSystemValue4 != HashBucketNode);
    punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
  }
  if (punsignedSystemValue4 == (void* *)0x0) {
    *ResourceManagerPointer = HashEntryStatus;
    ResourceManagerPointer[1] = HashNodePointer + 5;
    ResourceManagerPointer[2] = HashEntryStatus + localSystemPointer * 5;
    return;
  }
    SystemCleanupFunction(punsignedSystemValue4);
}




/**
 * @brief 系统资源验证器函数
 * 
 * 该函数负责验证系统资源的完整性和有效性。
 * 它会检查资源指针的有效性，并调用相应的验证函数。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要验证的资源信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的有效性
 */
void ValidateSystemResource(long long ResourceManagerPointer)

{
  if (*(long long **)(ResourceManagerPointer + 0x10) != (long long *)0x0) {
    (**(code **)(**(long long **)(ResourceManagerPointer + 0x10) + 0x38))();
  }
  return;
}




// 函数: void ProcessSystemResourceExtension(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源扩展处理器函数
 * 
 * 该函数负责处理系统资源的扩展操作，包括配置数据处理和资源管理。
 * 它会递归处理配置数据，并确保资源被正确初始化和配置。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含系统资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @note 这是系统资源管理的重要组成部分，用于处理资源的扩展操作
 */
void ProcessSystemResourceExtension(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessSystemResourceExtension(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  if (ConfigurationDataPointer[8] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




// 函数: void ConfigureSystemResourceData(void* ResourceManagerPointer,void* *ConfigurationDataPointer)
/**
 * @brief 系统配置数据清理器函数
 * 
 * 该函数负责清理系统配置数据，递归处理配置数据指针数组。
 * 它会释放配置数据占用的内存，确保系统资源被正确清理。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含系统资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含需要清理的配置信息
 * @note 这是系统配置管理的重要组成部分，用于确保配置数据的正确清理
 */
void CleanupSystemConfigurationData(void* ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  if (ConfigurationDataPointer != (void* *)0x0) {
    CleanupSystemConfigurationData(ResourceManagerPointer,*ConfigurationDataPointer);
    ValidateSystemResourceConfiguration(ConfigurationDataPointer);
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}




// 函数: void ReleaseSystemResourceHandle(void* ResourceManagerPointer)
/**
 * @brief 系统资源最终清理器函数
 * 
 * 该函数负责系统资源的最终清理操作，包括配置数据的清理和内存释放。
 * 它会调用配置数据清理函数，确保所有相关资源都被正确释放。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要清理的资源信息
 * @note 这是系统资源管理的最后清理步骤，用于确保资源的完全释放
 */
void FinalCleanupSystemResource(void* ResourceManagerPointer)

{
  void* *systemMemoryBlockPtr;
  
  ConfigureSystemResourceData(ResourceManagerPointer,*systemMemoryBlockPtr);
  ValidateSystemResourceConfiguration();
    SystemCleanupFunction();
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何操作。
 * 主要用于占位或作为默认的空处理函数。
 */
void SystemNullOperation(void)

{
  return;
}




/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，包括设置全局数据引用和内存分配器引用。
 * 在初始化过程中会检查资源状态，如果发现异常则调用清理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 资源参数指针
 */
void SystemResourceInitializer(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  if (*(long long *)(ConfigurationDataPointer + 0x40) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(ConfigurationDataPointer + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ConfigurationDataPointer + 0x28) = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0x38) = 0;
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemMemoryAllocatorReference;
  if (ConfigurationDataPointer != 0) {
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}





/**
 * @brief 系统资源数组管理函数
 * 
 * 该函数负责管理系统资源数组，包括创建、扩展和清理资源数组。
 * 它会根据需要分配新的内存空间，并处理现有资源的迁移和清理。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 起始参数
 * @param AdditionalParameter 结束参数
 */
void SystemResourceArrayManager(long long *ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  void* *resourcePointer1;
  long long localSystemHandle;
  void* *resourcePointer3;
  void* *resourcePointer4;
  ulong long resourceCapacity;
  ulong long requiredCapacity;
  long long resourceOffset;
  
  requiredCapacity = AdditionalParameter - ConfigurationDataPointer >> 5;
  if ((ulong long)(ResourceManagerPointer[2] - *ResourceManagerPointer >> 5) < requiredCapacity) {
    if (requiredCapacity == 0) {
      localSystemHandle = 0;
    }
    else {
      localSystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,requiredCapacity << 5,(char)ResourceManagerPointer[3]);
    }
    if (ConfigurationDataPointer != AdditionalParameter) {
      resourceOffset = localSystemHandle - ConfigurationDataPointer;
      do {
        CreateSystemObject(resourceOffset + ConfigurationDataPointer,ConfigurationDataPointer);
        ConfigurationDataPointer = ConfigurationDataPointer + 0x20;
      } while (ConfigurationDataPointer != AdditionalParameter);
    }
    resourcePointer1 = (void* *)ResourceManagerPointer[1];
    resourcePointer4 = (void* *)*ResourceManagerPointer;
    if (resourcePointer4 != resourcePointer1) {
      do {
        (**(code **)*resourcePointer4)(resourcePointer4,0);
        resourcePointer4 = resourcePointer4 + 4;
      } while (resourcePointer4 != resourcePointer1);
      resourcePointer4 = (void* *)*ResourceManagerPointer;
    }
    if (resourcePointer4 != (void* *)0x0) {
        SystemCleanupFunction(resourcePointer4);
    }
    *ResourceManagerPointer = localSystemHandle;
    localSystemHandle = requiredCapacity * 0x20 + localSystemHandle;
    ResourceManagerPointer[2] = localSystemHandle;
    ResourceManagerPointer[1] = localSystemHandle;
  }
  else {
    resourceCapacity = ResourceManagerPointer[1] - *ResourceManagerPointer >> 5;
    if (resourceCapacity < requiredCapacity) {
      localSystemHandle = resourceCapacity * 0x20 + ConfigurationDataPointer;
      SetupSystemDataHandler(ConfigurationDataPointer,localSystemHandle);
      localSystemHandle = AllocateSystemMemoryBlock(localSystemHandle,AdditionalParameter,ResourceManagerPointer[1]);
      ResourceManagerPointer[1] = localSystemHandle;
    }
    else {
      resourcePointer3 = (void* *)SetupSystemDataHandler(ConfigurationDataPointer,AdditionalParameter);
      resourcePointer1 = (void* *)ResourceManagerPointer[1];
      for (resourcePointer4 = resourcePointer3; resourcePointer4 != resourcePointer1; resourcePointer4 = resourcePointer4 + 4) {
        (**(code **)*resourcePointer4)(resourcePointer4,0);
      }
      ResourceManagerPointer[1] = (long long)resourcePointer3;
    }
  }
  return;
}





/**
 * @brief 系统资源数组创建函数
 * 
 * 该函数负责创建系统资源数组，包括分配内存空间和初始化资源对象。
 * 它会根据指定的大小创建系统线程对象，并设置相应的资源指针。
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void SystemResourceArrayCreator(long long ResourceManagerPointer)

{
  void* *resourcePointer1;
  long long localSystemHandle;
  long long resourceStartOffset;
  void* *resourcePointer3;
  long long resourceSize;
  long long *resourceArrayPointer;
  long long bufferAddress;
  long long resourceEndOffset;
  
  if (resourceSize == 0) {
    localSystemHandle = 0;
  }
  else {
    localSystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceSize << 5,*(uint8_t *)(ResourceManagerPointer + 0x18));
  }
  if (resourceStartOffset != resourceEndOffset) {
    bufferAddress = localSystemHandle - resourceStartOffset;
    do {
      CreateSystemObject(bufferAddress + resourceStartOffset,resourceStartOffset);
      resourceStartOffset = resourceStartOffset + 0x20;
    } while (resourceStartOffset != resourceEndOffset);
  }
  resourcePointer1 = (void* *)resourceArrayPointer[1];
  resourcePointer3 = (void* *)*resourceArrayPointer;
  if (resourcePointer3 != resourcePointer1) {
    do {
      (**(code **)*resourcePointer3)(resourcePointer3,0);
      resourcePointer3 = resourcePointer3 + 4;
    } while (resourcePointer3 != resourcePointer1);
    resourcePointer3 = (void* *)*resourceArrayPointer;
  }
  if (resourcePointer3 == (void* *)0x0) {
    *resourceArrayPointer = localSystemHandle;
    localSystemHandle = resourceSize * 0x20 + localSystemHandle;
    resourceArrayPointer[2] = localSystemHandle;
    resourceArrayPointer[1] = localSystemHandle;
    return;
  }
    SystemCleanupFunction(resourcePointer3);
}




// 函数: void InitializeSystemTables(void)
// 功能: 初始化系统表，设置系统数据结构和表
void InitializeSystemTables(void)

{
  void* *pointerToUnsigned1;
  long long systemMemoryBlockPtr;
  void** SystemDataTable;
  long long systemStringIteratorPtr;
  long long *systemDataIndexPtr;
  long long systemAllocationOffset;
  long long localResourceOffset;
  long long systemResourceHandle;
  
  localResourceOffset = systemAllocationOffset - systemMemoryBlockPtr;
  do {
    CreateSystemObject(localResourceOffset + systemMemoryBlockPtr,systemMemoryBlockPtr);
    systemMemoryBlockPtr = systemMemoryBlockPtr + 0x20;
  } while (systemMemoryBlockPtr != systemResourceHandle);
  pointerToUnsigned1 = (void* *)systemDataIndexPtr[1];
  HashEntryStatus = (void* *)*systemDataIndexPtr;
  if (HashEntryStatus != pointerToUnsigned1) {
    do {
      (**(code **)*HashEntryStatus)(HashEntryStatus,0);
      HashEntryStatus = HashEntryStatus + 4;
    } while (HashEntryStatus != pointerToUnsigned1);
    HashEntryStatus = (void* *)*systemDataIndexPtr;
  }
  if (HashEntryStatus != (void* *)0x0) {
      SystemCleanupFunction(HashEntryStatus);
  }
  *systemDataIndexPtr = systemAllocationOffset;
  localResourceOffset = systemStringIteratorPtr * 0x20 + systemAllocationOffset;
  systemDataIndexPtr[2] = localResourceOffset;
  systemDataIndexPtr[1] = localResourceOffset;
  return;
}




// 函数: void FinalizeSystemInitialization(void)
// 功能: 完成系统初始化，清理临时资源
void FinalizeSystemInitialization(void)

{
  long long nextDataIndex;
  void** SystemDataTable;
  void* *HashNodePointer;
  long long systemStringIteratorPtr;
  long long *systemDataIndexPtr;
  long long systemAllocationOffset;
  
  HashEntryStatus = (void* *)systemDataIndexPtr[1];
  HashNodePointer = (void* *)*systemDataIndexPtr;
  if (HashNodePointer != HashEntryStatus) {
    do {
      (**(code **)*HashNodePointer)(HashNodePointer,0);
      HashNodePointer = HashNodePointer + 4;
    } while (HashNodePointer != HashEntryStatus);
    HashNodePointer = (void* *)*systemDataIndexPtr;
  }
  if (HashNodePointer != (void* *)0x0) {
      SystemCleanupFunction(HashNodePointer);
  }
  *systemDataIndexPtr = systemAllocationOffset;
  nextDataIndex = systemStringIteratorPtr * 0x20 + systemAllocationOffset;
  systemDataIndexPtr[2] = nextDataIndex;
  systemDataIndexPtr[1] = nextDataIndex;
  return;
}




/**
 * @brief 系统资源处理器
 * 
 * 该函数负责处理系统资源，包括资源的分配、清理和状态管理。
 * 它会根据资源的状态和容量需求，执行相应的资源操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 处理参数
 * @param AdditionalParameter 资源大小参数
 */
void SystemResourceProcessor(long long ResourceManagerPointer,void* ConfigurationDataPointer,long long AdditionalParameter)

{
  void* *resourcePointer1;
  void** SystemDataTable;
  void* resourceHandle;
  long long resourceOffset;
  void* *resourcePointer4;
  ulong long resourceCapacity;
  ulong long requiredSize;
  long long resourceArrayPointer;
  
  resourceCapacity = *(long long *)(ResourceManagerPointer + 8) - AdditionalParameter >> 5;
  if (resourceCapacity < requiredSize) {
    SetupSystemDataHandler();
    resourceHandle = AllocateSystemMemoryBlock(resourceCapacity * 0x20 + resourceOffset);
    *(void* *)(resourceArrayPointer + 8) = resourceHandle;
  }
  else {
    HashEntryStatus = (void* *)SetupSystemDataHandler();
    resourcePointer1 = *(void* **)(resourceArrayPointer + 8);
    for (resourcePointer4 = HashEntryStatus; resourcePointer4 != resourcePointer1; resourcePointer4 = resourcePointer4 + 4) {
      (**(code **)*resourcePointer4)(resourcePointer4,0);
    }
    *(void* **)(resourceArrayPointer + 8) = HashEntryStatus;
  }
  return;
}





// 函数: void ProcessSystemParameters(long long *ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter,long long ConfigurationFlag)
/**
 * @brief 系统资源范围处理器函数
 * 
 * 该函数负责处理指定范围内的系统资源，包括资源验证和配置操作。
 * 它会检查资源范围的有效性，并对范围内的资源进行处理。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于指定处理范围
 * @param ConfigurationFlag 配置标志，用于控制处理行为
 * @note 这是系统资源管理的重要组成部分，用于处理指定范围内的资源
 */
void ProcessSystemResourceRange(long long *ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter,long long ConfigurationFlag)

{
  void* systemStatus;
  long long localSystemHandle;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  ulong long currentThreadId;
  
  if (AdditionalParameter == ConfigurationFlag) {
    return;
  }
  localSystemHandle = ResourceManagerPointer[1];
  currentThreadId = ConfigurationFlag - AdditionalParameter >> 3;
  if ((ulong long)(ResourceManagerPointer[2] - localSystemHandle >> 3) < currentThreadId) {
    localResourceOffset = *ResourceManagerPointer;
    localSystemHandle = localSystemHandle - localResourceOffset >> 3;
    unsignedSystemValue4 = localSystemHandle * 2;
    if (localSystemHandle == 0) {
      unsignedSystemValue4 = 1;
    }
    if (unsignedSystemValue4 <= localSystemHandle + currentThreadId) {
      unsignedSystemValue4 = localSystemHandle + currentThreadId;
    }
    if (unsignedSystemValue4 == 0) {
      systemStatus = 0;
    }
    else {
      systemStatus = CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue4 * 8,(char)ResourceManagerPointer[3]);
      localResourceOffset = *ResourceManagerPointer;
    }
    if (localResourceOffset != ConfigurationDataPointer) {
        memmove(systemStatus,localResourceOffset,ConfigurationDataPointer - localResourceOffset);
    }
      memmove(systemStatus,AdditionalParameter,ConfigurationFlag - AdditionalParameter);
  }
  unsignedSystemValue4 = localSystemHandle - ConfigurationDataPointer >> 3;
  if (currentThreadId < unsignedSystemValue4) {
    localResourceOffset = localSystemHandle + currentThreadId * -8;
    if (localResourceOffset != localSystemHandle) {
        memmove(localSystemHandle,localResourceOffset,currentThreadId * 8);
    }
      memmove(localSystemHandle - ((localSystemHandle + currentThreadId * -8) - ConfigurationDataPointer & 0xfffffffffffffff8),ConfigurationDataPointer);
  }
  localResourceOffset = AdditionalParameter + unsignedSystemValue4 * 8;
  if (localResourceOffset != ConfigurationFlag) {
      memmove(localSystemHandle,localResourceOffset,ConfigurationFlag - localResourceOffset);
  }
  if (ConfigurationDataPointer != localSystemHandle) {
      memmove(localSystemHandle + (currentThreadId - unsignedSystemValue4) * 8,ConfigurationDataPointer,localSystemHandle - ConfigurationDataPointer);
  }
    memmove(ConfigurationDataPointer + (unsignedSystemValue4 - (localResourceOffset - AdditionalParameter >> 3)) * 8,AdditionalParameter,localResourceOffset - AdditionalParameter);
}





/**
 * @brief 系统资源数据复制器函数
 * 
 * 该函数负责复制系统资源数据，包括内存移动和数据重组操作。
 * 它会处理不同区域的数据复制，确保数据被正确移动和重组。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于指定复制操作
 * @param ConfigurationFlag 配置标志，用于控制复制行为
 * @note 这是系统资源管理的重要组成部分，用于处理数据的复制和重组
 */
void CopySystemResourceData(long long *ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter,long long ConfigurationFlag)

{
  void* newMemoryBuffer;
  long long resourceStartAddress;
  long long resourceEndAddress;
  ulong long sourceOffset;
  ulong long targetOffset;
  
  resourceStartAddress = ResourceManagerPointer[1];
  targetOffset = ConfigurationFlag - AdditionalParameter >> 3;
  if ((ulong long)(ResourceManagerPointer[2] - resourceStartAddress >> 3) < targetOffset) {
    resourceEndAddress = *ResourceManagerPointer;
    resourceStartAddress = resourceStartAddress - resourceEndAddress >> 3;
    sourceOffset = resourceStartAddress * 2;
    if (resourceStartAddress == 0) {
      sourceOffset = 1;
    }
    if (sourceOffset <= resourceStartAddress + targetOffset) {
      sourceOffset = resourceStartAddress + targetOffset;
    }
    if (sourceOffset == 0) {
      newMemoryBuffer = 0;
    }
    else {
      newMemoryBuffer = CreateSystemThreadObject(SystemMemoryPoolTemplate,sourceOffset * 8,(char)ResourceManagerPointer[3]);
      resourceEndAddress = *ResourceManagerPointer;
    }
    if (resourceEndAddress != ConfigurationDataPointer) {
        memmove(newMemoryBuffer,resourceEndAddress,ConfigurationDataPointer - resourceEndAddress);
    }
      memmove(newMemoryBuffer,AdditionalParameter,ConfigurationFlag - AdditionalParameter);
  }
  sourceOffset = resourceStartAddress - ConfigurationDataPointer >> 3;
  if (targetOffset < sourceOffset) {
    resourceEndAddress = resourceStartAddress + targetOffset * -8;
    if (resourceEndAddress != resourceStartAddress) {
        memmove(resourceStartAddress,resourceEndAddress,targetOffset * 8);
    }
      memmove(resourceStartAddress - ((resourceStartAddress + targetOffset * -8) - ConfigurationDataPointer & 0xfffffffffffffff8),ConfigurationDataPointer);
  }
  resourceEndAddress = AdditionalParameter + sourceOffset * 8;
  if (resourceEndAddress != ConfigurationFlag) {
      memmove(resourceStartAddress,resourceEndAddress,ConfigurationFlag - resourceEndAddress);
  }
  if (ConfigurationDataPointer != resourceStartAddress) {
      memmove(resourceStartAddress + (targetOffset - sourceOffset) * 8,ConfigurationDataPointer,resourceStartAddress - ConfigurationDataPointer);
  }
    memmove(ConfigurationDataPointer + (sourceOffset - (resourceEndAddress - AdditionalParameter >> 3)) * 8,AdditionalParameter,resourceEndAddress - AdditionalParameter);
}





/**
 * @brief 系统资源大小计算器函数
 * 
 * 该函数负责计算系统资源的大小和空间需求。
 * 它会根据资源指针计算所需的内存空间，并进行相应的调整。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @note 这是系统资源管理的重要组成部分，用于计算资源空间需求
 */
void CalculateSystemResourceSize(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  void* memoryBuffer;
  long long additionalOffset;
  long long targetAddress;
  long long *resourceArray;
  ulong long calculatedSize;
  
  ResourceManagerPointer = ResourceManagerPointer >> 3;
  calculatedSize = ResourceManagerPointer * 2;
  if (ResourceManagerPointer == 0) {
    calculatedSize = 1;
  }
  if (calculatedSize <= (ulong long)(ResourceManagerPointer + additionalOffset)) {
    calculatedSize = ResourceManagerPointer + additionalOffset;
  }
  if (calculatedSize == 0) {
    memoryBuffer = 0;
  }
  else {
    memoryBuffer = CreateSystemThreadObject(SystemMemoryPoolTemplate,calculatedSize * 8,(char)resourceArray[3]);
    ConfigurationDataPointer = *resourceArray;
  }
  if (ConfigurationDataPointer != targetAddress) {
      memmove(memoryBuffer,ConfigurationDataPointer,targetAddress - ConfigurationDataPointer);
  }
    memmove(memoryBuffer);
}




// 函数: void ResetSystemState(void)
// 功能: 重置系统状态，清理系统状态
void ResetSystemState(void)

{
  return;
}




// 函数: void ClearSystemCache(void)
// 功能: 清除系统缓存，释放缓存资源
void ClearSystemCache(void)

{
  return;
}




// 函数: void DestroySystemResource(long long ResourceManagerPointer)
// 功能: 销毁系统资源，释放相关资源
void DestroySystemResource(long long ResourceManagerPointer)

{
  FreeSystemMemoryPool();
  *(void* *)(ResourceManagerPointer + 8) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ReleaseResourceManagerPointer(void* *ResourceManagerPointer)
/**
 * @brief 释放系统资源指针
 * 
 * 该函数负责释放系统资源指针，调用相关的清理函数
 * 并将资源指针重置为系统内存分配器引用
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void ReleaseResourceManagerPointer(void* *ResourceManagerPointer)
{
  if ((long long *)ResourceManagerPointer[0x13] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x13] + 0x38))();
  }
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ResetResourceManagerPointer(void* *ResourceManagerPointer)
/**
 * @brief 重置系统资源指针
 * 
 * 该函数负责重置系统资源指针，清理相关资源
 * 并将指针重置为适当的系统引用
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void ResetResourceManagerPointer(void* *ResourceManagerPointer)
{
  ProcessSystemDataConfiguration(ResourceManagerPointer + 4);
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void SetupSystemResourceNode(void* *ResourceManagerPointer)
/**
 * @brief 清理系统资源指针
 * 
 * 该函数负责清理系统资源指针，处理资源释放
 * 并将指针重置为系统内存分配器引用
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void CleanupResourceManagerPointer(void* *ResourceManagerPointer)
{
  if (ResourceManagerPointer[4] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ProcessSystemResourceData(long long *ResourceManagerPointer)
/**
 * @brief 清理系统资源内存区域
 * 
 * 该函数负责清理系统资源的内存区域，遍历内存块并释放资源
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void CleanupSystemResourceMemoryRegion(long long *ResourceManagerPointer)
{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x548) {
    FinalizeSystemMemoryAllocation(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ProcessSystemDataConfiguration(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 销毁系统资源互斥锁
 * 
 * 该函数负责销毁系统资源的互斥锁，清理相关的内存块
 * 并处理系统资源的释放
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 */
void DestroySystemResourceMutex(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
{
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  _Mtx_destroy_in_situ();
  ProcessMemoryBlock(ResourceManagerPointer + 0xf0,*(void* *)(ResourceManagerPointer + 0x100),AdditionalParameter,ConfigurationFlag,cleanupFlag);
  ProcessMemoryBlock(ResourceManagerPointer + 0xc0,*(void* *)(ResourceManagerPointer + 0xd0));
  ProcessMemoryBlock(ResourceManagerPointer + 0x90,*(void* *)(ResourceManagerPointer + 0xa0));
  InitializeSystemConfigurationDataRecursive(ResourceManagerPointer + 0x60,*(void* )(ResourceManagerPointer + 0x70));
  ProcessSystemResourceExtension(ResourceManagerPointer + 0x30,*(void* *)(ResourceManagerPointer + 0x40));
  InitializeSystemConfigurationDataRecursive(ResourceManagerPointer,*(void* )(ResourceManagerPointer + 0x10));
  return;
}




// 函数: void ExecuteSystemConfiguration(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 处理系统资源初始化
 * 
 * 该函数负责处理系统资源的初始化过程
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 */
void ProcessSystemResourceInitialization(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
{
  InitializeSystemConfigurationDataRecursive(ResourceManagerPointer,*(void* )(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




// 函数: void ConfigureSystemParameters(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 执行系统资源配置
 * 
 * 该函数负责执行系统资源的配置过程
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 */
void ExecuteSystemResourceConfiguration(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
{
  InitializeSystemConfigurationDataRecursive(ResourceManagerPointer,*(void* )(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 执行配置数据回调函数
 * 
 * 该函数负责执行配置数据指针指向的回调函数，
 * 用于系统配置和初始化过程中的回调处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针，指向要执行的回调函数
 * 
 * 原始函数名为FUN_180058f00，现已重命名为ExecuteConfigurationDataCallback
 */
void ExecuteConfigurationDataCallback(void* ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  (*(code *)*ConfigurationDataPointer)();
  return;
}



00018017747d)
000180177a18)
000180177a22)
000180177a2e)
000180177a35)
000180177581)
000180177590)
00018017759c)
0001801775a3)
0001801775b3)
0001801775c0)
0001801775cc)
0001801775d3)
000180177263)
000180177296)
00018017726a)
000180177274)
000180177280)
000180177287)
000180177290)
000180177298)
00018017753a)
000180177540)
000180177550)
00018017755c)
000180177563)
0001801772c2)
0001801772d0)
0001801772dc)
0001801772e3)
00018017764c)
00018017749a)
0001801774a8)
0001801774aa)
000180176fc3)
000180177722)
00018017729d)
00018017766b)
000180177677)
000180177679)
00018017739f)
0001801773a6)
0001801773b0)
0001801773bc)
0001801773c3)
00018017731b)
000180177321)
000180177330)
00018017733c)
000180177343)
00018017734b)
000180177356)
000180177360)
00018017736c)
000180177373)
00018017737b)
000180177385)
0001801773cb)
000180177381)
0001801773cd)
0001801773d6)
0001801773da)
0001801773e4)
0001801773eb)
000180177400)
00018017740c)
000180177413)
00018017741e)
000180177417)
000180177420)


/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，包括内存分配、数据结构设置
 * 和系统状态配置。这是一个复杂的系统初始化函数，涉及多层级的
 * 资源管理和内存操作。
 * 
 * @param resourcePointer 系统资源指针，指向需要初始化的资源结构
 * 
 * 原始函数名为FUN_180059000，现已重命名为InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(long long *resourcePointer)

{
  void* *******systemDataHierarchy;
  void** dataTable;
  void* *resourceNode;
  void* *memoryBlock;
  void* *allocationUnit;
  void** rootSystemNode;
  uint32_t systemStatusFlags;
  int operationCode;
  void* allocatedMemory;
  long long allocationFlags;
  uint8_t *dataBuffer;
  long long memoryPointer;
  void* *systemHandle;
  void* *******systemDataStructure;
  long long *primaryResourcePointer;
  uint systemValue;
  void* *resultPointer;
  long long secondaryMemoryPointer;
  void* ******systemManagementTable;
  int systemResult;
  uint *statusIndicator;
  ulong long systemData1;
  ulong long systemData2;
  ulong long systemData3;
  ulong long systemData4;
  bool isOperationComplete;
  uint8_t StackBuffer1 [32];
  void* *stackPointer1;
  uint8_t *stackPointer2;
  uint32_t stackValue1;
  ulong long stackValue2;
  uint stackValue3;
  int stackValue4;
  int stackValue5;
  long long stackValue6;
  void* ******stackManagement1;
  void* ******stackManagement2;
  void* ******stackManagement3;
  void* stackPointer3;
  void* stackPointer4;
  uint32_t stackValue7;
  void* *stackPointer5;
  void* *stackPointer6;
  uint32_t stackValue8;
  ulong long stackValue9;
  long long stackValue10;
  void* *stackPointer7;
  void* *stackPointer8;
  void* stackPointer9;
  uint32_t stackValue11;
  void* *stackPointer10;
  long long stackValue12;
  uint32_t stackValue13;
  long long stackValue14;
  ulong long stackValue15;
  long long stackValue16;
  void* *stackPointer11;
  void* *stackPointer12;
  void* *stackPointer13;
  void* stackPointer14;
  void* *stackPointer15;
  uint8_t *stackPointer16;
  uint32_t stackValue17;
  uint8_t StackBuffer2 [16];
  void* stackPointer17;
  void* stackPointer18;
  uint32_t stackValue18;
  uint32_t stackValue19;
  ulong long stackValue20;
  void* stackPointer21;
  
  stackPointer21 = 0x180059023;
  allocatedMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x270,8,3);
  stackPointer21 = 0x18005902b;
  allocationFlags = InitializeMemoryAllocationFlags(allocatedMemory);
  systemStatusFlags = *(uint32_t *)(SystemNodeManagerPointer + 0x1dc0);
  SystemAllocationFlags = allocationFlags;
  *(uint32_t *)(allocationFlags + 0x1e0) = *(uint32_t *)(SystemNodeManagerPointer + 0x1d50);
  *(uint32_t *)(allocationFlags + 0x1e4) = systemStatusFlags;
  stackPointer21 = 0x180059066;
  (**(code **)(**(long long **)(*resourcePointer + 0x2b0) + 0xf8))();
  stackPointer14 = 0xfffffffffffffffe;
  stackValue20 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer1;
  stackValue3 = 0;
  stackValue10 = SystemAllocationFlags;
  *(void* *)(SystemAllocationFlags + 0xf0) = 0;
  stackValue7 = 3;
  stackManagement1 = &stackManagement1;
  stackManagement2 = &stackManagement1;
  stackManagement3 = (void* *******)0x0;
  stackPointer3 = 0;
  stackPointer4 = 0;
  stackValue16 = *SystemStatusFlagsPointer;
  stackValue5 = 0;
  allocationFlags = *(long long *)(stackValue16 + 0x8a8);
  if (*(long long *)(stackValue16 + 0x8b0) - allocationFlags >> 5 != 0) {
    stackValue6 = 0;
    do {
      memoryPointer = stackValue6;
      operationCode = stackValue5;
      resultPointer = *(void* **)(stackValue6 * 0x20 + 8 + allocationFlags);
      systemHandle = &SystemStringTemplate;
      if (resultPointer != (void* *)0x0) {
        systemHandle = resultPointer;
      }
      stackPointer1 = &SystemGlobalDataReference;
      uStack_380 = 0;
      puStack_390 = (uint8_t *)0x0;
      uStack_388 = 0;
      if (pointerToUnsigned13 != (void* *)0x0) {
        allocationFlags = -1;
        do {
          nextDataIndex8 = allocationFlags;
          allocationFlags = nextDataIndex8 + 1;
        } while (pointerToUnsigned13[allocationFlags] != '\0');
        if ((int)allocationFlags != 0) {
          systemResult0 = (int)nextDataIndex8 + 2;
          systemCode = systemResult0;
          if (systemResult0 < 0x10) {
            systemCode = 0x10;
          }
          ThreadLocalStorage = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,0x13);
          *ThreadLocalStorage = 0;
          puStack_390 = ThreadLocalStorage;
          unsignedSystemValue7 = StartSystemThread(ThreadLocalStorage);
          uStack_380 = CONCAT44(uStack_380._4_4_,unsignedSystemValue7);
            memcpy(ThreadLocalStorage,pointerToUnsigned13,systemResult0);
        }
      }
      uStack_388 = 0;
      InitializeSystemGlobalData(&SystemGlobalDataReference,&pointerUnsigned2e8,&puStack_398);
      puStack_390 = (uint8_t *)0x0;
      uStack_380 = uStack_380 & 0xffffffff00000000;
      puStack_398 = &SystemMemoryAllocatorReference;
      pointerUnsigned308 = (void* *)0x0;
      DataBufferPtr300 = (void* *)0x0;
      unsignedValue2f8 = 0;
      unsignedValue2f0 = 3;
      punsignedValue290 = &SystemResourceTemplateSecondary;
      pEncryptionKeyValue8 = aunsignedValue278;
      aunsignedValue278[0] = 0;
      EncryptionKeyValue0 = 4;
      strcpy_s(aunsignedValue278,0x10,&SystemResourceString1);
      ProcessSystemResourceQueue(&pointerUnsigned2e8,&pointerUnsigned308,&punsignedValue290);
      punsignedValue290 = &SystemMemoryAllocatorReference;
      iStack_374 = 0;
      lStack_2c8 = 0;
      uStack_2c0 = (long long)DataBufferPtr300 - (long long)pointerUnsigned308 >> 5;
      HashEntryStatus = pointerUnsigned308;
      HashNodePointer = pointerUnsigned308;
      punsignedSystemValue4 = DataBufferPtr300;
      if (uStack_2c0 != 0) {
        do {
          allocationFlags = lStack_2c8;
          HashEntryStatus = pointerUnsigned308;
          systemCode = iStack_374;
          pointerToUnsigned17 = &SystemStringTemplate;
          if ((void* *)pointerUnsigned308[lStack_2c8 * 4 + 1] != (void* *)0x0) {
            pointerToUnsigned17 = (void* *)pointerUnsigned308[lStack_2c8 * 4 + 1];
          }
          nextDataIndex2 = strrchr(pointerToUnsigned17,0x2f);
          if (nextDataIndex2 == 0) {
            pointerToUnsigned17 = &SystemStringTemplate;
            if ((void* *)HashEntryStatus[allocationFlags * 4 + 1] != (void* *)0x0) {
              pointerToUnsigned17 = (void* *)HashEntryStatus[allocationFlags * 4 + 1];
            }
          }
          else {
            pointerToUnsigned17 = (void* *)(nextDataIndex2 + 1);
          }
          pointerToUnsigned13 = (void* *)strchr(pointerToUnsigned17,0x2e);
          if (pointerToUnsigned13 == (void* *)0x0) {
            pointerToUnsigned13 = &SystemStringTemplate;
            if ((void* *)HashEntryStatus[allocationFlags * 4 + 1] != (void* *)0x0) {
              pointerToUnsigned13 = (void* *)HashEntryStatus[allocationFlags * 4 + 1];
            }
            pointerToUnsigned13 = pointerToUnsigned13 + *(int *)(HashEntryStatus + allocationFlags * 4 + 2);
          }
          if ((long long)pointerToUnsigned13 - (long long)pointerToUnsigned17 != 0) {
              memcpy(&uStack_268,pointerToUnsigned17,(long long)pointerToUnsigned13 - (long long)pointerToUnsigned17);
          }
                              uStack_268._0_1_ = 0;
          systemStatus6 = 0;
          unsignedSystemValue7 = 0;
          pointerUnsigned330 = &SystemGlobalDataReference;
          unsignedValue318 = 0;
          puStack_328 = (void* *)0x0;
          unsignedValue320 = 0;
          nextDataIndex2 = -1;
          do {
            nextDataIndex8 = nextDataIndex2;
            nextDataIndex2 = nextDataIndex8 + 1;
          } while (*(char*)((long long)&uStack_268 + nextDataIndex8 + 1) != '\0');
          if ((int)(nextDataIndex8 + 1) != 0) {
            systemResult0 = (int)nextDataIndex8 + 2;
            systemCode = systemResult0;
            if (systemResult0 < 0x10) {
              systemCode = 0x10;
            }
            puStack_328 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,0x13);
            *puStack_328 = 0;
            creationFlags2 = (ulong long)puStack_328 & 0xffffffffffc00000;
            if (creationFlags2 != 0) {
              allocationFlags = ((long long)puStack_328 - creationFlags2 >> 0x10) * 0x50 + 0x80 + creationFlags2;
              HashEntryStatus1 = (uint *)(allocationFlags - (ulong long)*(uint *)(allocationFlags + 4));
              if ((*(byte *)((long long)HashEntryStatus1 + 0xe) & 2) == 0) {
                systemStatus6 = HashEntryStatus1[7];
                if (0x3ffffff < systemStatus6) {
                  systemStatus6 = *HashEntryStatus1 << 0x10;
                }
              }
              else {
                systemStatus6 = HashEntryStatus1[7];
                if (systemStatus6 < 0x4000000) {
                  creationFlags3 = (ulong long)systemStatus6;
                }
                else {
                  creationFlags3 = (ulong long)*HashEntryStatus1 << 0x10;
                }
                if (0x3ffffff < systemStatus6) {
                  systemStatus6 = *HashEntryStatus1 << 0x10;
                }
                systemStatus6 = systemStatus6 - (int)(((long long)puStack_328 -
                                        (((long long)((long long)HashEntryStatus1 + (-0x80 - creationFlags2)) / 0x50) *
                                         0x10000 + creationFlags2)) % creationFlags3);
              }
            }
            unsignedValue318 = CONCAT44(unsignedValue318._4_4_,systemStatus6);
              memcpy(puStack_328,&uStack_268,systemResult0);
          }
          unsignedValue320 = 0;
          pppppppointerToUnsigned14 = &pppppDataBufferPtr360;
          for (pppppppointerToUnsigned1 = (void* *******)ppppppuStack_350;
              pppppppointerToUnsigned1 != (void* *******)0x0;
              pppppppointerToUnsigned1 = (void* *******)pppppppointerToUnsigned1[1]) {
            pppppppointerToUnsigned14 = pppppppointerToUnsigned1;
          }
          if ((pppppppointerToUnsigned14 == &pppppDataBufferPtr360) ||
             (nextDataIndex2 = allocationFlags, *(int *)(pppppppointerToUnsigned14 + 6) != 0)) {
            if ((pppppppointerToUnsigned14 != (void* *******)pppppDataBufferPtr360) &&
               (pppppppointerToUnsigned14 != &pppppDataBufferPtr360)) {
              SystemMemoryNodeGetNext(pppppppointerToUnsigned14);
            }
            isSystemActive6 = true;
            pppppppointerToUnsigned14 = &pppppDataBufferPtr360;
            pppppppointerToUnsigned1 = (void* *******)ppppppuStack_350;
            while (pppppppointerToUnsigned1 != (void* *******)0x0) {
              isSystemActive6 = *(int *)(pppppppointerToUnsigned1 + 6) != 0;
              pppppppointerToUnsigned14 = pppppppointerToUnsigned1;
              if (isSystemActive6) {
                pppppppointerToUnsigned1 = (void* *******)pppppppointerToUnsigned1[1];
              }
              else {
                pppppppointerToUnsigned1 = (void* *******)*pppppppointerToUnsigned1;
              }
            }
            nextDataIndex2 = lStack_2c8;
            systemCode = iStack_374;
            if (isSystemActive6) {
              if (pppppppointerToUnsigned14 == (void* *******)ppppppuStack_358) {
                if ((pppppppointerToUnsigned14 != &pppppDataBufferPtr360) && (*(int *)(pppppppointerToUnsigned14 + 6) == 0)) {
                  unsignedSystemValue7 = 1;
                }
                allocationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x60,(uint8_t)uStack_338);
                punsignedValue2b0 = (void* *)(allocationFlags + 0x20);
                *punsignedValue2b0 = &SystemMemoryAllocatorReference;
                *(void* *)(allocationFlags + 0x28) = 0;
                *(uint32_t *)(allocationFlags + 0x30) = 0;
                *punsignedValue2b0 = &SystemGlobalDataReference;
                *(void* *)(allocationFlags + 0x38) = 0;
                *(void* *)(allocationFlags + 0x28) = 0;
                *(uint32_t *)(allocationFlags + 0x30) = 0;
                pointerUnsigned2a8 = punsignedValue2b0;
                ExecuteSystemCommand(punsignedValue2b0,0);
                pointerUnsigned2a0 = (void* *)(allocationFlags + 0x40);
                *pointerUnsigned2a0 = &SystemMemoryAllocatorReference;
                *(void* *)(allocationFlags + 0x48) = 0;
                *(uint32_t *)(allocationFlags + 0x50) = 0;
                *pointerUnsigned2a0 = &SystemGlobalDataReference;
                *(void* *)(allocationFlags + 0x58) = 0;
                *(void* *)(allocationFlags + 0x48) = 0;
                *(uint32_t *)(allocationFlags + 0x50) = 0;
                  ConfigureSystemResourceHandle(allocationFlags,pppppppointerToUnsigned14,&pppppDataBufferPtr360,unsignedSystemValue7);
              }
              pppppppointerToUnsigned14 = (void* *******)SystemResourceOffsetGet(pppppppointerToUnsigned14);
              nextDataIndex2 = lStack_2c8;
              systemCode = iStack_374;
            }
          }
          systemStatus6 = *(uint *)(HashEntryStatus + allocationFlags * 4 + 2);
          creationFlags2 = (ulong long)systemStatus6;
          if (HashEntryStatus[allocationFlags * 4 + 1] != 0) {
            ExecuteSystemCommand(pppppppointerToUnsigned14 + 8,creationFlags2);
          }
          if (systemStatus6 != 0) {
              memcpy(pppppppointerToUnsigned14[9],HashEntryStatus[allocationFlags * 4 + 1],creationFlags2);
          }
          *(uint32_t *)(pppppppointerToUnsigned14 + 10) = 0;
          if (pppppppointerToUnsigned14[9] != (void* ******)0x0) {
            *(uint8_t *)(creationFlags2 + (long long)pppppppointerToUnsigned14[9]) = 0;
          }
          *(uint32_t *)((long long)pppppppointerToUnsigned14 + 0x5c) =
               *(uint32_t *)((long long)HashEntryStatus + allocationFlags * 0x20 + 0x1c);
          puStack_328 = (void* *)0x0;
          unsignedValue318 = unsignedValue318 & 0xffffffff00000000;
          pointerUnsigned330 = &SystemMemoryAllocatorReference;
          iStack_374 = systemCode + 1;
          lStack_2c8 = nextDataIndex2 + 1;
          HashEntryStatus = pointerUnsigned308;
          HashNodePointer = pointerUnsigned308;
          punsignedSystemValue4 = DataBufferPtr300;
          systemCode = iStack_370;
          nextDataIndex2 = lStack_368;
        } while ((ulong long)(long long)iStack_374 < uStack_2c0);
      }
      for (; resourceEntryPointer = DataBufferPtr300, pcurrentThreadId = pointerUnsigned308, HashEntryStatus != DataBufferPtr300; HashEntryStatus = HashEntryStatus + 4)
      {
        pointerUnsigned308 = HashNodePointer;
        DataBufferPtr300 = punsignedSystemValue4;
        (**(code **)*HashEntryStatus)(HashEntryStatus,0);
        HashNodePointer = pointerUnsigned308;
        punsignedSystemValue4 = DataBufferPtr300;
        DataBufferPtr300 = resourceEntryPointer;
        pointerUnsigned308 = pcurrentThreadId;
      }
      if (pointerUnsigned308 != (void* *)0x0) {
        pointerUnsigned308 = HashNodePointer;
        DataBufferPtr300 = punsignedSystemValue4;
          SystemCleanupFunction(pcurrentThreadId);
      }
      pointerUnsigned2e8 = &SystemGlobalDataReference;
      if (lStack_2e0 != 0) {
        pointerUnsigned308 = HashNodePointer;
        DataBufferPtr300 = punsignedSystemValue4;
          SystemCleanupFunction();
      }
      lStack_2e0 = 0;
      unsignedValue2d0 = 0;
      pointerUnsigned2e8 = &SystemMemoryAllocatorReference;
      iStack_370 = systemCode + 1;
      lStack_368 = nextDataIndex2 + 1;
      allocationFlags = *(long long *)(lStack_2b8 + 0x8a8);
      pointerUnsigned308 = HashNodePointer;
      DataBufferPtr300 = punsignedSystemValue4;
    } while ((ulong long)(long long)iStack_370 <
             (ulong long)(*(long long *)(lStack_2b8 + 0x8b0) - allocationFlags >> 5));
  }
  EncryptionValue48 = 0x3f8000003f800000;
  unsignedValue40 = 0x3f000000;
  uStack_3c = 0;
  if ((void* *******)ppppppuStack_358 != &pppppDataBufferPtr360) {
    allocationFlags = lStack_310 + 0x150;
    pppppppointerToUnsigned14 = (void* *******)ppppppuStack_358;
    nextDataIndex2 = lStack_310;
    lStack_368 = allocationFlags;
    do {
      PrimaryResourcePointer5 = (long long *)FindSystemResourceNode(allocationFlags,&pointerUnsigned2a0,pppppppointerToUnsigned14 + 4);
      if (*PrimaryResourcePointer5 != allocationFlags) {
        isSystemActive6 = false;
        creationFlags3 = 0;
        nextDataIndex8 = *(long long *)(nextDataIndex2 + 0xc0);
        creationFlags2 = creationFlags3;
        if (*(long long *)(nextDataIndex2 + 200) - nextDataIndex8 >> 3 != 0) {
          do {
            allocationFlags = *(long long *)(nextDataIndex8 + creationFlags3);
            puStack_398 = &SystemGlobalDataReference;
            uStack_380 = 0;
            puStack_390 = (uint8_t *)0x0;
            uStack_388 = 0;
            if (*(int *)(allocationFlags + 0xb8) != 0) {
              systemCode = *(int *)(allocationFlags + 0xb8) + 1;
              if (systemCode < 0x10) {
                systemCode = 0x10;
              }
              puStack_390 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,0x13);
              *puStack_390 = 0;
              creationFlags4 = (ulong long)puStack_390 & 0xffffffffffc00000;
              if (creationFlags4 == 0) {
                systemStatus6 = 0;
              }
              else {
                nextDataIndex2 = ((long long)puStack_390 - creationFlags4 >> 0x10) * 0x50 + 0x80 + creationFlags4;
                HashEntryStatus1 = (uint *)(nextDataIndex2 - (ulong long)*(uint *)(nextDataIndex2 + 4));
                if ((*(byte *)((long long)HashEntryStatus1 + 0xe) & 2) == 0) {
                  systemStatus6 = HashEntryStatus1[7];
                  if (0x3ffffff < systemStatus6) {
                    systemStatus6 = *HashEntryStatus1 << 0x10;
                  }
                }
                else {
                  systemStatus6 = HashEntryStatus1[7];
                  if (systemStatus6 < 0x4000000) {
                    creationFlags5 = (ulong long)systemStatus6;
                  }
                  else {
                    creationFlags5 = (ulong long)*HashEntryStatus1 << 0x10;
                  }
                  if (0x3ffffff < systemStatus6) {
                    systemStatus6 = *HashEntryStatus1 << 0x10;
                  }
                  systemStatus6 = systemStatus6 - (int)(((long long)puStack_390 -
                                          (((long long)((long long)HashEntryStatus1 + (-0x80 - creationFlags4)) / 0x50)
                                           * 0x10000 + creationFlags4)) % creationFlags5);
                }
              }
              uStack_380 = CONCAT44(uStack_380._4_4_,systemStatus6);
              if (*(int *)(allocationFlags + 0xb8) != 0) {
                  memcpy(puStack_390,*(void* *)(allocationFlags + 0xb0),*(int *)(allocationFlags + 0xb8) + 1);
              }
            }
            if (*(long long *)(allocationFlags + 0xb0) != 0) {
              uStack_388 = 0;
              if (puStack_390 != (uint8_t *)0x0) {
                *puStack_390 = 0;
              }
              uStack_380 = uStack_380 & 0xffffffff;
            }
            uStack_378 = uStack_378 & 0xfffffffd;
            puStack_398 = &SystemGlobalDataReference;
            if (puStack_390 != (uint8_t *)0x0) {
                SystemCleanupFunction(puStack_390);
            }
            puStack_390 = (uint8_t *)0x0;
            uStack_380 = uStack_380 & 0xffffffff00000000;
            puStack_398 = &SystemMemoryAllocatorReference;
            nextDataIndex2 = lStack_310;
            allocationFlags = lStack_368;
            if (*(int *)(pppppppointerToUnsigned14 + 6) == 0) {
              isSystemActive6 = true;
              break;
            }
            systemStatus6 = (int)creationFlags2 + 1;
            creationFlags2 = (ulong long)systemStatus6;
            creationFlags3 = creationFlags3 + 8;
            nextDataIndex8 = *(long long *)(lStack_310 + 0xc0);
          } while ((ulong long)(long long)(int)systemStatus6 <
                   (ulong long)(*(long long *)(lStack_310 + 200) - nextDataIndex8 >> 3));
        }
        if (!isSystemActive6) {
          unsignedSystemValue9 = CalculateSystemMemorySize(&uStack_268,pppppppointerToUnsigned14 + 8);
          SetupSystemMemory(&pointerUnsigned330,unsignedSystemValue9);
          uStack_268 = &SystemMemoryAllocatorReference;
          ppppppointerToUnsigned19 = (void* ******)&SystemStringTemplate;
          if (pppppppointerToUnsigned14[5] != (void* ******)0x0) {
            ppppppointerToUnsigned19 = pppppppointerToUnsigned14[5];
          }
          ProcessSystemQueue(&pointerUnsigned308,ppppppointerToUnsigned19);
          pointerToUnsigned17 = &SystemStringTemplate;
          if (puStack_328 != (void* *)0x0) {
            pointerToUnsigned17 = puStack_328;
          }
          ProcessSystemQueue(&pointerUnsigned2e8,pointerToUnsigned17);
          InitializeSystemMemoryContext(nextDataIndex2,&pointerUnsigned2e8,&pointerUnsigned308,&EncryptionValue48);
          pointerUnsigned2e8 = &SystemGlobalDataReference;
          if (lStack_2e0 != 0) {
              SystemCleanupFunction();
          }
          lStack_2e0 = 0;
          unsignedValue2d0 = 0;
          pointerUnsigned2e8 = &SystemMemoryAllocatorReference;
          pointerUnsigned308 = (void* *)&SystemGlobalDataReference;
          if (DataBufferPtr300 != (void* *)0x0) {
              SystemCleanupFunction();
          }
          DataBufferPtr300 = (void* *)0x0;
          unsignedValue2f0 = 0;
          pointerUnsigned308 = (void* *)&SystemMemoryAllocatorReference;
          pointerUnsigned330 = &SystemGlobalDataReference;
          if (puStack_328 != (void* *)0x0) {
              SystemCleanupFunction();
          }
          puStack_328 = (void* *)0x0;
          unsignedValue318 = unsignedValue318 & 0xffffffff00000000;
          pointerUnsigned330 = &SystemMemoryAllocatorReference;
        }
      }
      pppppppointerToUnsigned14 = (void* *******)SystemMemoryNodeGetNext(pppppppointerToUnsigned14);
    } while (pppppppointerToUnsigned14 != &pppppDataBufferPtr360);
  }
  ProcessSystemResourceInitialization(&pppppDataBufferPtr360);
    ValidateSystemChecksum(uStack_38 ^ (ulong long)aconfigurationFlags3b8);
}



/**
 * @brief 系统资源分配器
 * 
 * 该函数负责分配和管理系统资源，包括内存分配、资源引用计数管理
 * 和资源池维护。这是系统资源管理的核心函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，通常为状态标志
 * @param AdditionalParameter 参数3，通常为资源偏移量
 * @return 返回分配的资源指针
 * @note 这是资源管理系统的核心分配函数
 */
void* * SystemResourceAllocator(void* *ResourceManagerPointer,uint8_t *ConfigurationDataPointer,long long AdditionalParameter)

{
  byte isByteValid;
  bool isSystemActive;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  uint currentThreadId;
  byte *pisThreadActive;
  long long localDataIndex;
  
  isSystemActive = true;
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[2];
  HashNodePointer = ResourceManagerPointer;
  while (punsignedSystemValue4 != (void* *)0x0) {
    HashNodePointer = punsignedSystemValue4;
    if (*(int *)(punsignedSystemValue4 + 6) == 0) {
      isSystemActive = false;
SystemResourceLoop:
      punsignedSystemValue4 = (void* *)*punsignedSystemValue4;
    }
    else {
      if (*(int *)(AdditionalParameter + 0x10) == 0) {
        isSystemActive = true;
      }
      else {
        pisThreadActive = (byte *)punsignedSystemValue4[5];
        localDataIndex = *(long long *)(AdditionalParameter + 8) - (long long)pisThreadActive;
        do {
          isByteValid = *pisThreadActive;
          currentThreadId = (uint)pisThreadActive[localDataIndex];
          if (isByteValid != currentThreadId) break;
          pisThreadActive = pisThreadActive + 1;
        } while (currentThreadId != 0);
        isSystemActive = 0 < (int)(isByteValid - currentThreadId);
      }
      if (!isSystemActive) goto SystemResourceLoop;
      punsignedSystemValue4 = (void* *)punsignedSystemValue4[1];
    }
  }
  punsignedSystemValue4 = HashNodePointer;
  if (isSystemActive) {
    if (HashNodePointer == (void* *)ResourceManagerPointer[1]) {
      *ConfigurationDataPointer = 1;
      return HashNodePointer;
    }
    punsignedSystemValue4 = (void* *)SystemResourceOffsetGet(HashNodePointer);
  }
  if (*(int *)(AdditionalParameter + 0x10) != 0) {
    if (*(int *)(punsignedSystemValue4 + 6) != 0) {
      pisThreadActive = *(byte **)(AdditionalParameter + 8);
      localDataIndex = punsignedSystemValue4[5] - (long long)pisThreadActive;
      do {
        isByteValid = *pisThreadActive;
        currentThreadId = (uint)pisThreadActive[localDataIndex];
        if (isByteValid != currentThreadId) break;
        pisThreadActive = pisThreadActive + 1;
      } while (currentThreadId != 0);
      if ((int)(isByteValid - currentThreadId) < 1) goto SystemResourceProcess;
    }
    *ConfigurationDataPointer = 1;
    return HashNodePointer;
  }
SystemResourceProcess:
  *ConfigurationDataPointer = 0;
  return punsignedSystemValue4;
}




// 函数: void FreeSystemMemoryPool(long long *ResourceManagerPointer)
// 功能: 释放系统内存池，清理内存资源
void FreeSystemMemoryPool(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x548) {
    FinalizeSystemMemoryAllocation(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ConfigureSystemResource(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
// 功能: 配置系统资源，设置资源参数
void ConfigureSystemResource(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  InitializeSystemConfigurationDataRecursive(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}



/**
 * @brief 系统资源数据复制器函数
 * 
 * 该函数负责在系统资源之间复制数据，包括配置数据和资源信息的复制。
 * 它会遍历资源指针数组，并执行相应的复制操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含源资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于控制复制行为
 * @return 返回处理后的额外参数指针
 * 
 * 原始函数名为SetupSystemDataHandler，现已重命名为CopySystemResourceData
 */
long long CopySystemResourceData(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  uint systemStatus;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  localResourceOffset = ConfigurationDataPointer - ResourceManagerPointer >> 5;
  if (0 < localResourceOffset) {
    resourcePoolPointer = (long long *)(ResourceManagerPointer + 8);
    ResourceManagerPointer = AdditionalParameter - ResourceManagerPointer;
    do {
      systemStatus = *(uint *)(resourcePoolPointer + 1);
      unsignedSystemValue4 = (ulong long)systemStatus;
      if (*resourcePoolPointer != 0) {
        ExecuteSystemCommand(AdditionalParameter,unsignedSystemValue4);
      }
      if (systemStatus != 0) {
          memcpy(*(void* *)(ResourceManagerPointer + (long long)resourcePoolPointer),*resourcePoolPointer,unsignedSystemValue4);
      }
      *(uint32_t *)(ResourceManagerPointer + 8 + (long long)resourcePoolPointer) = 0;
      if (*(long long *)(ResourceManagerPointer + (long long)resourcePoolPointer) != 0) {
        *(uint8_t *)(unsignedSystemValue4 + *(long long *)(ResourceManagerPointer + (long long)resourcePoolPointer)) = 0;
      }
      localResourceOffset = localResourceOffset + -1;
      *(uint32_t *)(ResourceManagerPointer + 0x14 + (long long)resourcePoolPointer) = *(uint32_t *)((long long)resourcePoolPointer + 0x14);
      AdditionalParameter = AdditionalParameter + 0x20;
      resourcePoolPointer = resourcePoolPointer + 4;
    } while (0 < localResourceOffset);
  }
  return AdditionalParameter;
}



/**
 * @brief 系统资源数据处理器函数
 * 
 * 该函数负责处理系统资源数据，包括数据的复制、移动和配置。
 * 它会遍历资源指针数组，并执行相应的数据处理操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于控制处理行为
 * @return 返回处理后的额外参数指针
 * 
 * 原始函数名为FUN_18005926c，现已重命名为ProcessSystemResourceDataInternal
 */
long long ProcessSystemResourceDataInternal(long long ResourceManagerPointer,void* ConfigurationDataPointer,long long AdditionalParameter)

{
  uint systemStatus;
  long long *resourcePoolPointer;
  long long systemStackFramePtr;
  long long systemStringIteratorPtr;
  ulong long allocationContext;
  
  resourcePoolPointer = (long long *)(ResourceManagerPointer + 8);
  AdditionalParameter = AdditionalParameter - ResourceManagerPointer;
  do {
    systemStatus = *(uint *)(resourcePoolPointer + 1);
    allocationContext = (ulong long)systemStatus;
    if (*resourcePoolPointer != 0) {
      ExecuteSystemCommand(systemStringIteratorPtr,allocationContext);
    }
    if (systemStatus != 0) {
        memcpy(*(void* *)(AdditionalParameter + (long long)resourcePoolPointer),*resourcePoolPointer,allocationContext);
    }
    *(uint32_t *)(AdditionalParameter + 8 + (long long)resourcePoolPointer) = 0;
    if (*(long long *)(AdditionalParameter + (long long)resourcePoolPointer) != 0) {
      *(uint8_t *)(allocationContext + *(long long *)(AdditionalParameter + (long long)resourcePoolPointer)) = 0;
    }
    systemStackFramePtr = systemStackFramePtr + -1;
    *(uint32_t *)(AdditionalParameter + 0x14 + (long long)resourcePoolPointer) = *(uint32_t *)((long long)resourcePoolPointer + 0x14);
    systemStringIteratorPtr = systemStringIteratorPtr + 0x20;
    resourcePoolPointer = resourcePoolPointer + 4;
  } while (0 < systemStackFramePtr);
  return systemStringIteratorPtr;
}




// 函数: void SystemNoOperation(void)
/**
 * @brief 系统空操作函数
 * 
 * 这是一个空操作函数，不执行任何操作，直接返回。
 * 主要用于占位或兼容性目的。
 * 
 * @note 这是系统中的空操作函数
 */
void SystemNoOperation(void)

{
  return;
}



long long CreateSystemObjectsBatch(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  if (ResourceManagerPointer != ConfigurationDataPointer) {
    do {
      CreateSystemObject(AdditionalParameter,ResourceManagerPointer);
      ResourceManagerPointer = ResourceManagerPointer + 0x20;
      AdditionalParameter = AdditionalParameter + 0x20;
    } while (ResourceManagerPointer != ConfigurationDataPointer);
  }
  return AdditionalParameter;
}




/**
 * @brief 移动系统资源数据
 * 
 * 该函数负责将系统资源数据从源地址移动到目标地址，
 * 用于系统资源的重新分配和数据迁移。
 * 
 * @param ResourceManagerPointer 源资源指针
 * @param ConfigurationDataPointer 配置数据指针（用作结束地址）
 * @param AdditionalParameter 目标参数指针
 * 
 * 原始函数名为FUN_180059350，现已重命名为MoveSystemResourceData
 */
void MoveSystemResourceData(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter)

{
  if (ResourceManagerPointer != ConfigurationDataPointer) {
    memmove(AdditionalParameter,ResourceManagerPointer,ConfigurationDataPointer - ResourceManagerPointer);
  }
  return;
}




/**
 * @brief 初始化系统资源指针
 * 
 * 该函数负责初始化系统资源指针，设置全局数据引用和内存分配器引用，
 * 用于系统资源管理的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * 
 * 原始函数名为FUN_180059380，现已重命名为InitializeResourceManagerPointer
 */
void InitializeResourceManagerPointer(void* *ResourceManagerPointer)

{
  if (ResourceManagerPointer[4] != 0) {
    SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
    SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 递归初始化系统配置数据
 * 
 * 该函数负责递归地初始化系统配置数据，设置全局数据引用和内存分配器引用，
 * 用于系统配置的深度初始化处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_1800593f0，现已重名为InitializeSystemConfigurationDataRecursive
 */
void InitializeSystemConfigurationDataRecursive(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  InitializeSystemConfigurationDataRecursive(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  StartSystemInitialization();
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
    SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
  SystemCleanupFunction(ConfigurationDataPointer);
}




/**
 * @brief 配置系统资源内存区域
 * 
 * 该函数负责配置系统资源的内存区域，设置内存区域参数和引用，
 * 用于系统内存管理和资源分配。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * 
 * 原始函数名为FinalizeSystemMemoryAllocation，现已重命名为ConfigureSystemResourceMemoryRegions
 */
void ConfigureSystemResourceMemoryRegions(void* *ResourceManagerPointer)

{
  ConfigureSystemMemoryRegion(ResourceManagerPointer + 0x7d,0x58,4,InitializeDriverSystem,0xfffffffffffffffe);
  ConfigureSystemMemoryRegion(ResourceManagerPointer + 0x51,0x58,4,InitializeDriverSystem);
  ConfigureSystemMemoryRegion(ResourceManagerPointer + 0x11,0x20,0x10,CleanupSystemResources);
  ResourceManagerPointer[8] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[9] != 0) {
    SystemCleanupFunction();
  }
  ResourceManagerPointer[9] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xb) = 0;
  ResourceManagerPointer[8] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[4] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[5] != 0) {
    SystemCleanupFunction();
  }
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 7) = 0;
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
    SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源初始化器函数
 * 
 * 该函数负责初始化系统资源，设置全局数据引用和内存分配器。
 * 它会启动系统初始化过程，并设置系统资源的基本结构。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于存储系统资源信息
 * 
 * 原始函数名为FUN_1800595c0，现已重命名为InitializeSystemResources
 */
void InitializeSystemResources(void* *ResourceManagerPointer)

{
  StartSystemInitialization();
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，遍历系统资源并调用清理函数。
 * 它会遍历系统资源链表，对每个资源调用清理函数，最后进行系统清理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_180059620，现已重命名为CleanupSystemResources
 */
void CleanupSystemResources(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x50) {
    ResetSystemResources(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源遍历清理器函数
 * 
 * 该函数负责遍历系统资源并清理每个资源项。
 * 它会遍历资源指针数组，对每个资源调用清理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要清理的资源
 * 
 * 原始函数名为FUN_180059640，现已重命名为CleanupSystemResourcesIterator
 */
void CleanupSystemResourcesIterator(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  for (localSystemHandle = *ResourceManagerPointer; localSystemHandle != nextDataIndex; localSystemHandle = localSystemHandle + 0x50) {
    ResetSystemResources(localSystemHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源重置器函数
 * 
 * 该函数负责重置系统资源，将资源指针重置为初始状态。
 * 它会重置全局数据引用和内存分配器，并清理资源状态。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要重置的资源信息
 * 
 * 原始函数名为FUN_1800596a0，现已重命名为ResetSystemResources
 */
void ResetSystemResources(void* *ResourceManagerPointer)

{
  ResourceManagerPointer[4] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 7) = 0;
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源清理验证器函数
 * 
 * 该函数负责验证系统资源的清理状态，并在必要时进行清理。
 * 它会检查资源状态，销毁互斥锁，确保资源被正确清理。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要验证的资源信息
 * 
 * 原始函数名为FUN_180059730，现已重命名为ValidateSystemResourceCleanup
 */
void ValidateSystemResourceCleanup(long long ResourceManagerPointer)

{
  if (*(long long *)(ResourceManagerPointer + 8) != 0) {
      SystemCleanupFunction();
  }
  _Mtx_destroy_in_situ();
  return;
}



/**
 * @brief 系统资源数据复制器函数
 * 
 * 该函数负责在系统资源之间复制数据，包括配置数据和资源信息的复制。
 * 它会遍历资源指针数组，并执行相应的复制操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含源资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于控制复制行为
 * @return 返回处理后的资源指针
 * 
 * 原始函数名为FUN_180059780，现已重命名为CopySystemResourceDataExtended
 */
void* * CopySystemResourceDataExtended(void* *ResourceManagerPointer,void* *ConfigurationDataPointer,void* *AdditionalParameter)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  long long localResourceOffset;
  
  if (ResourceManagerPointer != ConfigurationDataPointer) {
    localResourceOffset = (long long)AdditionalParameter - (long long)ResourceManagerPointer;
    HashEntryStatus = ResourceManagerPointer + 1;
    do {
      *AdditionalParameter = &SystemMemoryAllocatorReference;
      *(void* *)(localResourceOffset + (long long)HashEntryStatus) = 0;
      *(uint32_t *)(localResourceOffset + 8 + (long long)HashEntryStatus) = 0;
      *AdditionalParameter = &SystemGlobalDataReference;
      *(void* *)(localResourceOffset + 0x10 + (long long)HashEntryStatus) = 0;
      *(void* *)(localResourceOffset + (long long)HashEntryStatus) = 0;
      *(uint32_t *)(localResourceOffset + 8 + (long long)HashEntryStatus) = 0;
      *(uint32_t *)(localResourceOffset + 8 + (long long)HashEntryStatus) = *(uint32_t *)(HashEntryStatus + 1);
      *(void* *)(localResourceOffset + (long long)HashEntryStatus) = *HashEntryStatus;
      *(uint32_t *)(localResourceOffset + 0x14 + (long long)HashEntryStatus) = *(uint32_t *)((long long)HashEntryStatus + 0x14);
      *(uint32_t *)(localResourceOffset + 0x10 + (long long)HashEntryStatus) = *(uint32_t *)(HashEntryStatus + 2);
      *(uint32_t *)(HashEntryStatus + 1) = 0;
      *HashEntryStatus = 0;
      HashEntryStatus[2] = 0;
      AdditionalParameter = AdditionalParameter + 4;
      pointerToUnsigned1 = HashEntryStatus + 3;
      HashEntryStatus = HashEntryStatus + 4;
    } while (pointerToUnsigned1 != ConfigurationDataPointer);
  }
  return AdditionalParameter;
}





// 函数: void ProcessSystemConfiguration(long long *ResourceManagerPointer,void* ConfigurationDataPointer)
void ProcessSystemConfiguration(long long *ResourceManagerPointer,void* ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  long long localSystemHandle;
  long long localResourceOffset;
  long long bufferBaseAddress;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  
  localResourceOffset = ResourceManagerPointer[1];
  bufferBaseAddress = *ResourceManagerPointer;
  localSystemFlags = localResourceOffset - bufferBaseAddress >> 5;
  if (localSystemFlags == 0) {
    localSystemFlags = 1;
  }
  else {
    localSystemFlags = localSystemFlags * 2;
    if (localSystemFlags == 0) {
      localSystemHandle = 0;
      goto SystemResourceConfiguration;
    }
  }
  localSystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemFlags << 5,(char)ResourceManagerPointer[3]);
  localResourceOffset = ResourceManagerPointer[1];
  bufferBaseAddress = *ResourceManagerPointer;
SystemResourceConfiguration:
  localResourceOffset = CopySystemResourceDataExtended(bufferBaseAddress,localResourceOffset,localSystemHandle);
  CreateSystemObject(localResourceOffset,ConfigurationDataPointer);
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  pcurrentThreadId = (void* *)*ResourceManagerPointer;
  if (pcurrentThreadId != pointerToUnsigned1) {
    do {
      (**(code **)*pcurrentThreadId)(pcurrentThreadId,0);
      pcurrentThreadId = pcurrentThreadId + 4;
    } while (pcurrentThreadId != pointerToUnsigned1);
    pcurrentThreadId = (void* *)*ResourceManagerPointer;
  }
  if (pcurrentThreadId == (void* *)0x0) {
    *ResourceManagerPointer = localSystemHandle;
    ResourceManagerPointer[2] = localSystemFlags * 0x20 + localSystemHandle;
    ResourceManagerPointer[1] = localResourceOffset + 0x20;
    return;
  }
    SystemCleanupFunction(pcurrentThreadId);
}



/**
 * @brief 系统内存分配器引用设置函数
 * 
 * 该函数负责设置系统内存分配器的引用，并根据配置数据指针
 * 决定是否释放内存资源。这是内存管理系统的核心函数之一。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于设置内存分配器引用
 * @param ConfigurationDataPointer 配置数据指针，包含配置标志位
 * @param AdditionalParameter 额外参数，用于内存释放操作
 * @param ConfigurationFlag 配置标志，用于控制释放行为
 * @return 返回更新后的系统资源指针
 * 
 * 原始函数名为FUN_180059900，现已重命名为InitializeSystemMemoryAllocatorReference
 */
void* *InitializeSystemMemoryAllocatorReference(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x28,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}




// 函数: void ProcessSystemResourceString(long long ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串处理和缓冲区初始化函数
 * 
 * 该函数负责处理系统字符串操作，包括字符串长度计算、
 * 内存缓冲区初始化和字符串复制操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180059940，现已重命名为ProcessSystemStringAndInitializeBuffer
 */
void ProcessSystemStringAndInitializeBuffer(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  
  if (ConfigurationDataPointer == 0) {
    *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
    **(uint8_t **)(ResourceManagerPointer + 8) = 0;
    return;
  }
  nextDataIndex = -1;
  do {
    nextDataIndex = nextDataIndex + 1;
  } while (*(char *)(ConfigurationDataPointer + nextDataIndex) != '\0');
  if ((int)nextDataIndex < 0x10) {
    *(int *)(ResourceManagerPointer + 0x10) = (int)nextDataIndex;
                    000180059977. Too many branches
                        strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x10);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x10,ConfigurationDataPointer);
  *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
  **(uint8_t **)(ResourceManagerPointer + 8) = 0;
  return;
}




/**
 * @brief 系统缓冲区数据复制函数
 * 
 * 该函数负责将配置数据复制到系统缓冲区中，支持不同大小的数据复制。
 * 当数据大小超过缓冲区容量时，会调用系统内存处理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含目标缓冲区信息
 * @param ConfigurationDataPointer 配置数据指针，包含要复制的数据
 * @param AdditionalParameter 额外参数，指定要复制的数据大小
 * 
 * 原始函数名为FUN_1800599c0，现已重命名为CopySystemBufferData
 */
void CopySystemBufferData(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)

{
  if (AdditionalParameter + 1 < 0x10) {
      memcpy(*(uint8_t **)(ResourceManagerPointer + 8),ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




// 函数: void ClearSystemMemoryBuffer(void)
/**
 * @brief 清除系统内存缓冲区
 * 
 * 该函数负责清除系统内存缓冲区的内容，使用memcpy操作进行内存清理。
 * 这是系统内存管理的重要组成部分，用于重置和清理内存区域。
 * 
 * @note 这是一个不返回的函数，执行后会直接跳转到其他代码位置
 */
void ClearSystemMemoryBuffer(void)

{
    memcpy();
}




// 函数: void ClearSystemResourceFlags(uint8_t *ResourceManagerPointer)
/**
 * @brief 清除系统资源标志
 * 
 * 该函数负责清除系统资源的标志位，将指定的系统资源指针清零。
 * 主要用于资源重置和清理操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是系统资源管理的清理函数
 */
void ClearSystemResourceFlags(uint8_t *ResourceManagerPointer)

{
  long long systemDataIndexPtr;
  
  *ResourceManagerPointer = 0;
  *(uint32_t *)(systemDataIndexPtr + 0x10) = 0;
  return;
}





// 函数: void HandleSystemResourceEncryption(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统资源处理和加密操作函数
 * 
 * 该函数负责处理系统资源，执行加密操作和数据处理。
 * 涉及内存分配、加密模板处理和资源管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 * 原始函数名为FUN_180059a20，现已重命名为ProcessSystemResourceWithEncryption
 */
void ProcessSystemResourceWithEncryption(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long localResourceOffset;
  uint8_t aunsignedValue98 [32];
  void* UnsignedStackFlag78;
  void* *pprocessFlags70;
  uint8_t *pEncryptionValue68;
  uint32_t unsignedValue60;
  uint8_t EncryptionBuffer58 [16];
  ulong long EncryptionValue48;
  
  UnsignedStackFlag78 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue98;
  pprocessFlags70 = &SystemResourceTemplateSecondary;
  pEncryptionValue68 = EncryptionBuffer58;
  unsignedValue60 = 0;
  EncryptionBuffer58[0] = 0;
  nextDataIndex = strstr(*(void* *)(ResourceManagerPointer + 8));
  if (nextDataIndex != 0) {
    localSystemHandle = -1;
    localResourceOffset = -1;
    do {
      localResourceOffset = localResourceOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + localResourceOffset) != '\0');
    do {
      localSystemHandle = localSystemHandle + 1;
    } while (*(char *)(localSystemHandle + AdditionalParameter) != '\0');
      memcpy(pEncryptionValue68,*(long long *)(ResourceManagerPointer + 8),nextDataIndex - *(long long *)(ResourceManagerPointer + 8));
  }
  pprocessFlags70 = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)aunsignedValue98);
}




// 函数: void AllocateSystemResource(void* *ResourceManagerPointer)
void AllocateSystemResource(void* *ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  ulong long allocationContext;
  
  if (ResourceManagerPointer == (void* *)0x0) {
    return;
  }
  allocationContext = (ulong long)ResourceManagerPointer & 0xffffffffffc00000;
  if (allocationContext != 0) {
    localSystemHandle = allocationContext + 0x80 + ((long long)ResourceManagerPointer - allocationContext >> 0x10) * 0x50;
    localSystemHandle = localSystemHandle - (ulong long)*(uint *)(localSystemHandle + 4);
    if ((*(void ***)(allocationContext + 0x70) == &ExceptionList) && (*(char *)(localSystemHandle + 0xe) == '\0')) {
      *ResourceManagerPointer = *(void* *)(localSystemHandle + 0x20);
      *(void* **)(localSystemHandle + 0x20) = ResourceManagerPointer;
      pointerToInteger1 = (int *)(localSystemHandle + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(allocationContext,CONCAT71(0xff000000,*(void ***)(allocationContext + 0x70) == &ExceptionList),
                          ResourceManagerPointer,allocationContext,0xfffffffffffffffe);
    }
  }
  return;
}





// 函数: void InitializeSystemThreadStructure(void)
/**
 * @brief 初始化系统线程结构
 * 
 * 该函数负责初始化系统线程的内存结构，分配必要的内存空间
 * 并设置线程对象的初始参数。这是系统线程管理的重要组成部分。
 * 
 * @note 这是系统初始化过程中的关键函数，确保线程管理系统的正常运行
 */
void InitializeSystemThreadStructure(void)

{
  long long nextDataIndex;
  
  nextDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x1ae8,10);
  if (nextDataIndex == 0) {
    return;
  }
  *(void* *)(nextDataIndex + 0x100) = 0;
  *(void* *)(nextDataIndex + 0x108) = 0;
  *(uint32_t *)(nextDataIndex + 0x130) = 0;
  *(void* *)(nextDataIndex + 0x138) = 0;
  *(void*2 *)(nextDataIndex + 0x140) = 0x100;
  *(void* *)(nextDataIndex + 0x248) = 0;
  *(void* *)(nextDataIndex + 0x250) = 0;
  *(uint32_t *)(nextDataIndex + 0x278) = 0;
  *(void* *)(nextDataIndex + 0x280) = 0;
  *(void*2 *)(nextDataIndex + 0x288) = 0x100;
  *(void* *)(nextDataIndex + 0x390) = 0;
  *(void* *)(nextDataIndex + 0x398) = 0;
  *(uint32_t *)(nextDataIndex + 0x3c0) = 0;
  *(void* *)(nextDataIndex + 0x3c8) = 0;
  *(void*2 *)(nextDataIndex + 0x3d0) = 0x100;
  *(void* *)(nextDataIndex + 0x4d8) = 0;
  *(void* *)(nextDataIndex + 0x4e0) = 0;
  *(uint32_t *)(nextDataIndex + 0x508) = 0;
  *(void* *)(nextDataIndex + 0x510) = 0;
  *(void*2 *)(nextDataIndex + 0x518) = 0x100;
  *(void* *)(nextDataIndex + 0x620) = 0;
  *(void* *)(nextDataIndex + 0x628) = 0;
  *(uint32_t *)(nextDataIndex + 0x650) = 0;
  *(void* *)(nextDataIndex + 0x658) = 0;
  *(void*2 *)(nextDataIndex + 0x660) = 0x100;
  *(void* *)(nextDataIndex + 0x768) = 0;
  *(void* *)(nextDataIndex + 0x770) = 0;
  *(uint32_t *)(nextDataIndex + 0x798) = 0;
  *(void* *)(nextDataIndex + 0x7a0) = 0;
  *(void*2 *)(nextDataIndex + 0x7a8) = 0x100;
  *(void* *)(nextDataIndex + 0x8b0) = 0;
  *(void* *)(nextDataIndex + 0x8b8) = 0;
  *(uint32_t *)(nextDataIndex + 0x8e0) = 0;
  *(void* *)(nextDataIndex + 0x8e8) = 0;
  *(void*2 *)(nextDataIndex + 0x8f0) = 0x100;
  *(void* *)(nextDataIndex + 0x9f8) = 0;
  *(void* *)(nextDataIndex + 0xa00) = 0;
  *(uint32_t *)(nextDataIndex + 0xa28) = 0;
  *(void* *)(nextDataIndex + 0xa30) = 0;
  *(void*2 *)(nextDataIndex + 0xa38) = 0x100;
  *(void* *)(nextDataIndex + 0xb40) = 0;
  *(void* *)(nextDataIndex + 0xb48) = 0;
  *(uint32_t *)(nextDataIndex + 0xb70) = 0;
  *(void* *)(nextDataIndex + 0xb78) = 0;
  *(void*2 *)(nextDataIndex + 0xb80) = 0x100;
  *(void* *)(nextDataIndex + 0xc88) = 0;
  *(void* *)(nextDataIndex + 0xc90) = 0;
  *(uint32_t *)(nextDataIndex + 0xcb8) = 0;
  *(void* *)(nextDataIndex + 0xcc0) = 0;
  *(void*2 *)(nextDataIndex + 0xcc8) = 0x100;
  *(void* *)(nextDataIndex + 0xdd0) = 0;
  *(void* *)(nextDataIndex + 0xdd8) = 0;
  *(uint32_t *)(nextDataIndex + 0xe00) = 0;
  *(void* *)(nextDataIndex + 0xe08) = 0;
  *(void*2 *)(nextDataIndex + 0xe10) = 0x100;
  *(void* *)(nextDataIndex + 0xf18) = 0;
  *(void* *)(nextDataIndex + 0xf20) = 0;
  *(uint32_t *)(nextDataIndex + 0xf48) = 0;
  *(void* *)(nextDataIndex + 0xf50) = 0;
  *(void*2 *)(nextDataIndex + 0xf58) = 0x100;
  *(void* *)(nextDataIndex + 0x1060) = 0;
  *(void* *)(nextDataIndex + 0x1068) = 0;
  *(uint32_t *)(nextDataIndex + 0x1090) = 0;
  *(void* *)(nextDataIndex + 0x1098) = 0;
  *(void*2 *)(nextDataIndex + 0x10a0) = 0x100;
  *(void* *)(nextDataIndex + 0x11a8) = 0;
  *(void* *)(nextDataIndex + 0x11b0) = 0;
  *(uint32_t *)(nextDataIndex + 0x11d8) = 0;
  *(void* *)(nextDataIndex + 0x11e0) = 0;
  *(void*2 *)(nextDataIndex + 0x11e8) = 0x100;
  *(void* *)(nextDataIndex + 0x12f0) = 0;
  *(void* *)(nextDataIndex + 0x12f8) = 0;
  *(uint32_t *)(nextDataIndex + 0x1320) = 0;
  *(void* *)(nextDataIndex + 0x1328) = 0;
  *(void*2 *)(nextDataIndex + 0x1330) = 0x100;
  *(void* *)(nextDataIndex + 0x1438) = 0;
  *(void* *)(nextDataIndex + 0x1440) = 0;
  *(uint32_t *)(nextDataIndex + 0x1468) = 0;
  *(void* *)(nextDataIndex + 0x1470) = 0;
  *(void*2 *)(nextDataIndex + 0x1478) = 0x100;
  *(void* *)(nextDataIndex + 0x1580) = 0;
  *(void* *)(nextDataIndex + 0x1588) = 0;
  *(uint32_t *)(nextDataIndex + 0x15b0) = 0;
  *(void* *)(nextDataIndex + 0x15b8) = 0;
  *(void*2 *)(nextDataIndex + 0x15c0) = 0x100;
  *(void* *)(nextDataIndex + 0x16c8) = 0;
  *(void* *)(nextDataIndex + 0x16d0) = 0;
  *(uint32_t *)(nextDataIndex + 0x16f8) = 0;
  *(void* *)(nextDataIndex + 0x1700) = 0;
  *(void*2 *)(nextDataIndex + 0x1708) = 0x100;
  *(void* *)(nextDataIndex + 0x1810) = 0;
  *(void* *)(nextDataIndex + 0x1818) = 0;
  *(uint32_t *)(nextDataIndex + 0x1840) = 0;
  *(void* *)(nextDataIndex + 0x1848) = 0;
  *(void*2 *)(nextDataIndex + 0x1850) = 0x100;
  *(void* *)(nextDataIndex + 0x1958) = 0;
  *(void* *)(nextDataIndex + 0x1960) = 0;
  *(uint32_t *)(nextDataIndex + 0x1988) = 0;
  *(void* *)(nextDataIndex + 0x1990) = 0;
  *(void*2 *)(nextDataIndex + 0x1998) = 0x100;
  *(void* *)(nextDataIndex + 0x1aa0) = 0;
  *(void* *)(nextDataIndex + 0x1aa8) = 0;
  *(uint32_t *)(nextDataIndex + 0x1ad0) = 0;
  *(void* *)(nextDataIndex + 0x1ad8) = 0;
  *(void*2 *)(nextDataIndex + 0x1ae0) = 0x100;
  return;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，释放内存和关闭文件句柄
 * 用于游戏退出时的资源回收和系统清理
 * 
 * @param ResourceHandle 资源句柄指针
 */
void CleanupSystemResources(long long *ResourceHandle)

{
  int *pointerToInteger1;
  char *stringProcessingPointer;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  
  HashNodePointer = (void* *)*ResourceManagerPointer;
  if (HashNodePointer != (void* *)0x0) {
    if ((void* *)HashNodePointer[3] != (void* *)0x0) {
      *(void* *)HashNodePointer[3] = 0;
    }
    (**(code **)*HashNodePointer)(HashNodePointer,0);
      SystemCleanupFunction(HashNodePointer);
  }
  if ((ResourceManagerPointer[6] != 0) && (*(long long *)(ResourceManagerPointer[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = ResourceManagerPointer[5];
  while (bufferBaseAddress != 0) {
    stringProcessingPointer = (char *)(bufferBaseAddress + 0x141);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x138);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = (void* *)ResourceManagerPointer[3];
  if (HashNodePointer == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
  if (currentThreadId != 0) {
    bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
    bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
      *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
      *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
      pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          HashNodePointer,currentThreadId,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void InitializeSystemDataPointer(long long *ResourceManagerPointer)
/**
 * @brief 初始化系统数据指针
 * 
 * 该函数负责初始化系统数据指针，设置系统资源的内存布局和数据结构。
 * 这是系统数据管理的重要组成部分，确保数据访问的正确性和效率。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要初始化的系统资源
 * @note 这是系统初始化过程中的关键函数，确保数据管理系统的正常运行
 */
void InitializeSystemDataPointer(long long *ResourceManagerPointer)

{
  int *systemIntegerPointer;
  char *systemCharacterPointer;
  void* *systemResourcePointer;
  long long systemBufferAddress;
  ulong long systemUnsignedValue;
  
  HashNodePointer = (void* *)*ResourceManagerPointer;
  if (HashNodePointer != (void* *)0x0) {
    if ((void* *)HashNodePointer[3] != (void* *)0x0) {
      *(void* *)HashNodePointer[3] = 0;
    }
    (**(code **)*HashNodePointer)(HashNodePointer,0);
      SystemCleanupFunction(HashNodePointer);
  }
  if ((ResourceManagerPointer[6] != 0) && (*(long long *)(ResourceManagerPointer[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = ResourceManagerPointer[5];
  while (bufferBaseAddress != 0) {
    stringProcessingPointer = (char *)(bufferBaseAddress + 0x141);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x138);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = (void* *)ResourceManagerPointer[3];
  if (HashNodePointer == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
  if (currentThreadId != 0) {
    bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
    bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
      *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
      *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
      pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          HashNodePointer,currentThreadId,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void ReleaseSystemResourceReference(void)
/**
 * @brief 释放系统资源引用
 * 
 * 该函数负责释放系统资源的引用，将资源指针清零并调用清理函数。
 * 主要用于资源管理和内存释放操作。
 * 
 * @note 这是系统资源管理的释放函数
 */
void ReleaseSystemResourceReference(void)

{
  void* *systemMemoryBlockPtr;
  
  if ((void* *)systemMemoryBlockPtr[3] != (void* *)0x0) {
    *(void* *)systemMemoryBlockPtr[3] = 0;
  }
  (**(code **)*systemMemoryBlockPtr)();
    SystemCleanupFunction();
}




// 函数: void CleanupSystemBuffers(void)
/**
 * @brief 系统清理和缓冲区处理函数
 * 
 * 该函数负责系统清理操作，处理缓冲区和内存管理。
 * 涉及系统资源的释放和内存区域的清理。
 * 
 * 原始函数名为FUN_180059f4f，现已重命名为CleanupSystemAndProcessBuffers
 */
void CleanupSystemAndProcessBuffers(void)

{
  int *pointerToInteger1;
  char *stringProcessingPointer;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  long long systemStringIteratorPtr;
  ulong long currentThreadId;
  
  if ((*(long long *)(systemStringIteratorPtr + 0x30) != 0) &&
     (*(long long *)(*(long long *)(systemStringIteratorPtr + 0x30) + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = *(long long *)(systemStringIteratorPtr + 0x28);
  while (bufferBaseAddress != 0) {
    stringProcessingPointer = (char *)(bufferBaseAddress + 0x141);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x138);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = *(void* **)(systemStringIteratorPtr + 0x18);
  if (HashNodePointer != (void* *)0x0) {
    currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
    if (currentThreadId != 0) {
      bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
        pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                            HashNodePointer,currentThreadId,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void ManageSystemResourceWithException(void* *ResourceManagerPointer)
/**
 * @brief 系统资源指针管理和异常处理函数
 * 
 * 该函数负责管理系统资源指针，处理异常列表和内存地址计算。
 * 涉及系统资源的分配、释放和异常处理机制。
 * 
 * @param ResourceManagerPointer 系统资源指针的指针
 * 
 * 原始函数名为FUN_180059fb0，现已重命名为ManageResourceManagerPointerWithExceptionHandling
 */
void ManageResourceManagerPointerWithExceptionHandling(void* *ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  ulong long allocationContext;
  
  allocationContext = (ulong long)ResourceManagerPointer & 0xffffffffffc00000;
  if (allocationContext != 0) {
    localSystemHandle = allocationContext + 0x80 + ((long long)ResourceManagerPointer - allocationContext >> 0x10) * 0x50;
    localSystemHandle = localSystemHandle - (ulong long)*(uint *)(localSystemHandle + 4);
    if ((*(void ***)(allocationContext + 0x70) == &ExceptionList) && (*(char *)(localSystemHandle + 0xe) == '\0')) {
      *ResourceManagerPointer = *(void* *)(localSystemHandle + 0x20);
      *(void* **)(localSystemHandle + 0x20) = ResourceManagerPointer;
      pointerToInteger1 = (int *)(localSystemHandle + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(allocationContext,CONCAT71(0xff000000,*(void ***)(allocationContext + 0x70) == &ExceptionList),
                          ResourceManagerPointer,allocationContext,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 系统资源清理和销毁函数
 * 
 * 该函数负责清理和销毁系统资源，包括互斥锁、条件变量和内存缓冲区。
 * 它会递归地清理所有关联的资源，确保系统资源的正确释放。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要清理的资源信息
 * 
 * 原始函数名为FUN_180059fc0，现已重命名为CleanupAndDestroySystemResources
 */
void CleanupAndDestroySystemResources(long long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  char *stringProcessingPointer;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  HashNodePointer = (void* *)*ResourceManagerPointer;
  if (HashNodePointer != (void* *)0x0) {
    if ((void* *)HashNodePointer[3] != (void* *)0x0) {
      *(void* *)HashNodePointer[3] = 0;
    }
    (**(code **)*HashNodePointer)(HashNodePointer,0);
      SystemCleanupFunction(HashNodePointer);
  }
  if ((ResourceManagerPointer[6] != 0) && (*(long long *)(ResourceManagerPointer[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = ResourceManagerPointer[5];
  while (bufferBaseAddress != 0) {
    stringProcessingPointer = (char *)(bufferBaseAddress + 0x141);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x138);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = (void* *)ResourceManagerPointer[3];
  if (HashNodePointer == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
  if (currentThreadId != 0) {
    bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
    bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
      *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
      *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
      pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          HashNodePointer,currentThreadId,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void ProcessSystemResourceCleanup(long long ResourceManagerPointer)
/**
 * @brief 处理系统资源清理
 * 
 * 该函数负责处理系统资源的清理操作，包括资源引用计数的管理和资源释放。
 * 主要用于系统资源的生命周期管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是系统资源管理的清理函数
 */
void ProcessSystemResourceCleanup(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = *(void* **)(ResourceManagerPointer + 0x18);
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void CleanupSystemResourceArray(long long ResourceManagerPointer)
/**
 * @brief 清理系统资源数组
 * 
 * 该函数负责清理系统资源数组中的所有资源，遍历数组并释放每个资源。
 * 主要用于系统资源的批量清理和内存管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是系统资源管理的批量清理函数
 */
void CleanupSystemResourceArray(long long ResourceManagerPointer)

{
  ulong long systemStatus;
  long long localSystemHandle;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  systemStatus = *(ulong long *)(ResourceManagerPointer + 0x10);
  localSystemHandle = *(long long *)(ResourceManagerPointer + 8);
  unsignedSystemValue4 = 0;
  if (systemStatus == 0) {
    *(void* *)(ResourceManagerPointer + 0x18) = 0;
  }
  else {
    do {
      localResourceOffset = *(long long *)(localSystemHandle + unsignedSystemValue4 * 8);
      if (localResourceOffset != 0) {
        if (*(long long *)(localResourceOffset + 0x18) != 0) {
            SystemCleanupFunction();
        }
          SystemCleanupFunction(localResourceOffset);
      }
      *(void* *)(localSystemHandle + unsignedSystemValue4 * 8) = 0;
      unsignedSystemValue4 = unsignedSystemValue4 + 1;
    } while (unsignedSystemValue4 < systemStatus);
    *(void* *)(ResourceManagerPointer + 0x18) = 0;
  }
  return;
}




// 函数: void ValidateResourceManagerPointer(long long ResourceManagerPointer)
/**
 * @brief 验证系统资源指针
 * 
 * 该函数负责验证系统资源指针的有效性，检查资源指针的完整性和状态。
 * 主要用于系统资源的安全检查和错误预防。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是系统资源管理的验证函数
 */
void ValidateResourceManagerPointer(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  CleanupSystemAndProcessBuffers();
  if ((1 < *(ulong long *)(ResourceManagerPointer + 0x10)) &&
     (HashEntryStatus = *(void* **)(ResourceManagerPointer + 8), HashEntryStatus != (void* *)0x0)) {
    unsignedSystemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
    if (unsignedSystemValue4 != 0) {
      localResourceOffset = unsignedSystemValue4 + 0x80 + ((long long)HashEntryStatus - unsignedSystemValue4 >> 0x10) * 0x50;
      localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
      if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
        *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
        *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
        pointerToInteger1 = (int *)(localResourceOffset + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                            HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源表验证和清理函数
 * 
 * 该函数负责验证系统资源表的有效性，并清理无效的资源条目。
 * 它会遍历资源表，检查每个资源的状态，并进行必要的清理操作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源表信息
 * 
 * 原始函数名为FUN_18005a130，现已重命名为ValidateAndCleanupSystemResourceTable
 */
void ValidateAndCleanupSystemResourceTable(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  CleanupSystemAndProcessBuffers();
  if ((1 < *(ulong long *)(ResourceManagerPointer + 0x10)) &&
     (HashEntryStatus = *(void* **)(ResourceManagerPointer + 8), HashEntryStatus != (void* *)0x0)) {
    unsignedSystemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
    if (unsignedSystemValue4 != 0) {
      localResourceOffset = unsignedSystemValue4 + 0x80 + ((long long)HashEntryStatus - unsignedSystemValue4 >> 0x10) * 0x50;
      localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
      if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
        *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
        *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
        pointerToInteger1 = (int *)(localResourceOffset + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                            HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源异常处理函数
 * 
 * 该函数负责处理系统资源的异常情况，包括资源释放和异常检查。
 * 它会检查资源指针的有效性，并在必要时调用系统清理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要处理的资源信息
 * @note 这是系统资源异常处理的重要组成部分
 */
void HandleSystemResourceException(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  CleanupSystemAndProcessBuffers();
  if ((1 < *(ulong long *)(ResourceManagerPointer + 0x10)) &&
     (HashEntryStatus = *(void* **)(ResourceManagerPointer + 8), HashEntryStatus != (void* *)0x0)) {
    unsignedSystemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
    if (unsignedSystemValue4 != 0) {
      localResourceOffset = unsignedSystemValue4 + 0x80 + ((long long)HashEntryStatus - unsignedSystemValue4 >> 0x10) * 0x50;
      localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
      if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
        *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
        *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
        pointerToInteger1 = (int *)(localResourceOffset + 0x18);
        *pointerToInteger1 = *pointerToInteger1 + -1;
        if (*pointerToInteger1 == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                            HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}



/**
 * @brief 系统资源释放处理器函数
 * 
 * 该函数负责处理系统资源的释放操作，根据配置标志决定是否释放资源。
 * 它会初始化系统资源处理器，并在条件满足时释放指定的资源。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要释放的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含释放操作的配置信息
 * @param AdditionalParameter 额外参数，用于扩展释放功能
 * @param ConfigurationFlag 配置标志，用于控制释放行为
 * @return 返回处理后的系统资源指针
 * @note 这是系统资源管理的重要组成部分，用于处理资源的释放操作
 */
void* ReleaseSystemResourceHandler(void* ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xc0,AdditionalParameter,ConfigurationFlag,systemStatus);
  }
  return ResourceManagerPointer;
}





/**
 * @brief 系统资源初始化和清理函数
 * 
 * 该函数负责初始化系统资源结构，包括内存分配、线程初始化和资源清理。
 * 它会设置各种系统参数，初始化互斥锁和条件变量，并分配必要的内存空间。
 * 
 * @param ResourceManagerPointer 系统资源指针的指针，包含需要初始化的资源信息
 * @note 这是系统资源初始化的重要组成部分，用于设置系统资源的基础结构
 */
void InitializeAndCleanupSystemResource(void* *ResourceManagerPointer)

{
  ulong long systemStatus;
  void* creationFlags;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  void** SystemCurrentNode;
  long long localMemoryAddress;
  
  allocationContext = 0;
  *ResourceManagerPointer = 0;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  ResourceManagerPointer[2] = 0;
  ResourceManagerPointer[5] = 0;
  pcurrentThreadId = ResourceManagerPointer + 0xb;
  localMemoryAddress = 0x20;
  localSystemFlags = 0x20;
  HashBucketNode = pcurrentThreadId;
  do {
    SystemResourceCleanup(HashBucketNode);
    HashBucketNode = HashBucketNode + 2;
    localSystemFlags = localSystemFlags + -1;
  } while (localSystemFlags != 0);
  *(void* *)((long long)ResourceManagerPointer + 0x25c) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x4b) = 0;
  ResourceManagerPointer[7] = 0;
  ResourceManagerPointer[8] = 0x20;
  ResourceManagerPointer[9] = pcurrentThreadId;
  do {
    *(uint32_t *)pcurrentThreadId = 0;
    pcurrentThreadId = pcurrentThreadId + 2;
    localMemoryAddress = localMemoryAddress + -1;
  } while (localMemoryAddress != 0);
  ResourceManagerPointer[10] = 0;
  ResourceManagerPointer[6] = ResourceManagerPointer + 8;
  ResourceManagerPointer[4] = 0x15;
  localSystemFlags = InitializeSystemThreadStructure();
  ResourceManagerPointer[3] = localSystemFlags;
  if (localSystemFlags == 0) {
    ResourceManagerPointer[4] = 0;
    systemStatus = allocationContext;
  }
  else {
    systemStatus = ResourceManagerPointer[4];
  }
  unsignedSystemValue4 = allocationContext;
  if (systemStatus != 0) {
    do {
      *(uint8_t *)(unsignedSystemValue4 + 0x141 + ResourceManagerPointer[3]) = 0;
      allocationContext = allocationContext + 1;
      unsignedSystemValue4 = unsignedSystemValue4 + 0x148;
    } while (allocationContext < (ulong long)ResourceManagerPointer[4]);
  }
  _Cnd_init_in_situ();
  _Mtx_init_in_situ(ResourceManagerPointer + 0x56,2);
  ResourceManagerPointer[0x60] = 0;
  ResourceManagerPointer[0x61] = 0;
  ResourceManagerPointer[0x62] = 0;
  *(uint32_t *)(ResourceManagerPointer + 99) = 3;
  ResourceManagerPointer[0x65] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6a) = 0x3f800000;
  *(void* *)((long long)ResourceManagerPointer + 0x354) = 0x40000000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x35c) = 3;
  ResourceManagerPointer[0x68] = 1;
  ResourceManagerPointer[0x67] = &SystemNullPointer;
  ResourceManagerPointer[0x69] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6b) = 0;
  creationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,4);
    memset(creationFlags,0,0xc0);
}



/**
 * @brief 系统资源多重清理和释放函数
 * 
 * 该函数负责对系统资源进行多重清理操作，包括调用多个清理函数。
 * 它会按顺序清理不同偏移量的资源，并在条件满足时释放整个资源。
 * 
 * @param ResourceManagerPointer 系统资源指针的指针，包含需要清理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含清理操作的配置信息
 * @return 返回清理后的系统资源指针
 * @note 这是系统资源清理的重要组成部分，用于处理复杂的多重清理操作
 */
void* * CleanupAndReleaseMultipleSystemResources(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemMemoryData3;
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xa4);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x8c);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x7e);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x70);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x62);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x54);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x46);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x38);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x2a);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x1c);
  FinalizeSystemResourceCleanup(ResourceManagerPointer);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x590);
  }
  return ResourceManagerPointer;
}





/**
 * @brief 系统线程创建和初始化函数
 * 
 * 该函数负责创建和初始化系统线程，设置线程参数和标志。
 * 它会创建线程对象，启动线程，并设置线程的标识信息。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含线程所需的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含线程的配置信息
 * @param AdditionalParameter 额外参数，用于扩展线程功能
 * @param ConfigurationFlag 配置标志，用于控制线程行为
 * @note 这是系统线程管理的重要组成部分，用于创建和初始化系统线程
 */
void CreateAndInitializeSystemThread(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t systemStatus;
  void** SystemDataTable;
  void* *memoryAllocationEnd;
  void* *pEncryptionValue48;
  uint32_t unsignedValue40;
  void* uStack_38;
  
  memoryAllocationEnd = &SystemGlobalDataReference;
  uStack_38 = 0;
  pEncryptionValue48 = (void* *)0x0;
  unsignedValue40 = 0;
  HashEntryStatus = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,ConfigurationFlag,0xfffffffffffffffe);
  *(uint8_t *)HashEntryStatus = 0;
  pEncryptionValue48 = HashEntryStatus;
  systemStatus = StartSystemThread(HashEntryStatus);
  uStack_38 = CONCAT44(uStack_38._4_4_,systemStatus);
  *HashEntryStatus = 0x6320726f74696445;
  *(uint32_t *)(HashEntryStatus + 1) = 0x69666e6f;
  *(void*2 *)((long long)HashEntryStatus + 0xc) = 0x67;
  unsignedValue40 = 0xd;
  ManageSystemResource(ResourceManagerPointer,&memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
    SystemCleanupFunction(HashEntryStatus);
}



/**
 * @brief 系统资源处理和释放函数
 * 
 * 该函数负责处理系统资源并根据配置标志决定是否释放资源。
 * 它会调用资源处理函数，并在条件满足时释放指定的资源。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要处理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含处理操作的配置信息
 * @return 返回处理后的系统资源指针
 * @note 这是系统资源管理的重要组成部分，用于处理和释放资源
 */
void* ProcessAndReleaseSystemResource(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  InitializeSystemResourceProcessor();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xa90);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源批量处理和清理函数
 * 
 * 该函数负责对系统资源进行批量处理和清理操作，包括多个偏移量的资源处理。
 * 它会按顺序处理不同位置的资源，并进行必要的清理和检查。
 * 
 * @param ResourceManagerPointer 系统资源指针的指针，包含需要处理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含处理操作的配置信息
 * @param AdditionalParameter 额外参数，用于扩展处理功能
 * @param ConfigurationFlag 配置标志，用于控制处理行为
 * @note 这是系统资源批量处理的重要组成部分，用于处理复杂的资源清理操作
 */
void ProcessAndCleanupBatchSystemResources(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = &SystemConfigDataTemplateA;
  InitializeSystemResourceA(ResourceManagerPointer + 0x143);
  InitializeSystemResourceA(ResourceManagerPointer + 0x134);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x126);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x118);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x10a);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xfc);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xee);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xe0);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xd2);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xc4);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xb6);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0xa8);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x9a);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x8c);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x7e);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x70);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x62);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x54);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x46);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x38);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x2a);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x1c);
  *ResourceManagerPointer = &SystemMemoryPoolTemplateA;
  ResourceManagerPointer[0x18] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[0x19] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x19] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1b) = 0;
  ResourceManagerPointer[0x18] = &SystemMemoryAllocatorReference;
  ProcessSystemResourceConfiguration(ResourceManagerPointer + 0x12,ResourceManagerPointer[0x14],AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  if (ResourceManagerPointer[0xd] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[5] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * @brief 系统资源指针配置函数
 * 
 * 该函数负责配置系统资源指针，设置资源参数和属性
 * 用于系统资源的前期配置和准备工作
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005aaf0，现已重命名为ConfigureResourceManagerPointer
 */
void ConfigureResourceManagerPointer(long long systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)
{
  if (*(code **)(systemResourcePointer + 0x10) != (code *)0x0) {
    (**(code **)(systemResourcePointer + 0x10))(systemResourcePointer, 0, 0, configurationFlag, 0xfffffffffffffffe);
  }
  return;
}




/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理参数
 * 用于系统资源管理的前期准备工作
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005ab20，现已重命名为InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(long long systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)
{
  if (*(code **)(systemResourcePointer + 0x10) != (code *)0x0) {
    (**(code **)(systemResourcePointer + 0x10))(systemResourcePointer, 0, 0, configurationFlag, 0xfffffffffffffffe);
  }
  return;
}




/**
 * @brief 系统资源初始化函数A
 * 
 * 该函数负责初始化系统资源，设置系统全局数据引用和内存分配器
 * 用于系统资源管理的前期准备工作
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * 
 * 原始函数名为FUN_18005ab50，现已重命名为InitializeSystemResourceA
 */
void InitializeSystemResourceA(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(ResourceManagerPointer + 0x68) != (code *)0x0) {
    (**(code **)(ResourceManagerPointer + 0x68))(ResourceManagerPointer + 0x58,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  *(void* *)(ResourceManagerPointer + 0x30) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x38) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x38) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x48) = 0;
  *(void* *)(ResourceManagerPointer + 0x30) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x10) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x18) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x28) = 0;
  *(void* *)(ResourceManagerPointer + 0x10) = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 系统资源初始化函数B
 * 
 * 该函数负责初始化系统资源，创建系统线程并设置线程相关的数据结构
 * 用于系统资源管理中的线程初始化工作
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * 
 * 原始函数名为FUN_18005ac00，现已重命名为InitializeSystemResourceB
 */
void InitializeSystemResourceB(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t systemStatus;
  uint32_t *HashEntryStatus;
  void* *memoryAllocationEnd;
  uint32_t *pEncryptionValue48;
  uint32_t unsignedValue40;
  void* uStack_38;
  
  memoryAllocationEnd = &SystemGlobalDataReference;
  uStack_38 = 0;
  pEncryptionValue48 = (uint32_t *)0x0;
  unsignedValue40 = 0;
  HashEntryStatus = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x13,0x13,ConfigurationFlag,0xfffffffffffffffe);
  *(uint8_t *)HashEntryStatus = 0;
  pEncryptionValue48 = HashEntryStatus;
  systemStatus = StartSystemThread(HashEntryStatus);
  uStack_38 = CONCAT44(uStack_38._4_4_,systemStatus);
  *HashEntryStatus = 0x65766544;
  HashEntryStatus[1] = 0x6d706f6c;
  HashEntryStatus[2] = 0x20746e65;
  HashEntryStatus[3] = 0x666e6f63;
  *(void*2 *)(HashEntryStatus + 4) = 0x6769;
  *(uint8_t *)((long long)HashEntryStatus + 0x12) = 0;
  unsignedValue40 = 0x12;
  ManageSystemResource(ResourceManagerPointer,&memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
    SystemCleanupFunction(HashEntryStatus);
}



/**
 * @brief 系统资源管理器函数
 * 
 * 该函数负责管理系统资源的生命周期，包括资源的创建、使用和释放。
 * 它会根据配置数据标志决定是否释放资源内存。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @return 返回系统资源指针
 * 
 * 原始函数名为FUN_18005b520，现已重命名为ManageSystemResource
 */
void* ManageSystemResource(void* systemResourcePointer, unsigned long long configurationDataPointer)

{
  CleanupSystemResource();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x13c0);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，调用系统内存分配器清理函数
 * 并对资源指针进行重置和初始化操作。
 * 
 * @param systemResourcePointer 系统资源指针的指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005b560，现已重命名为CleanupSystemResource
 */
void CleanupSystemResource(void** systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)

{
  *systemResourcePointer = &SystemMemoryManagerTemplateA;
  CleanupSystemMemoryAllocation();
  CleanupSystemMemoryAllocation();
  ExecuteSystemResourceOperation((long long)*systemResourcePointer + 0x262, configurationDataPointer, additionalParameter, configurationFlag);
  ExecuteSystemResourceOperation((long long)*systemResourcePointer + 0x254, configurationDataPointer, additionalParameter, configurationFlag);
  ExecuteSystemResourceOperation((long long)*systemResourcePointer + 0x246, configurationDataPointer, additionalParameter, configurationFlag);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x238);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x22a);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x21c);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x20e);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x1f6);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x1de);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x1c6);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x1b8);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x1aa);
  ExecuteSystemResourceOperation(ResourceManagerPointer + 0x19c);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x184);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x16c);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x154);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x13c);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x124);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x10c);
  InitializeSystemResourceManager(ResourceManagerPointer + 0xf4);
  InitializeSystemResourceManager(ResourceManagerPointer + 0xdc);
  InitializeSystemResourceManager(ResourceManagerPointer + 0xc4);
  InitializeSystemResourceManager(ResourceManagerPointer + 0xac);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x94);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x7c);
  InitializeSystemResourceManager(ResourceManagerPointer + 100);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x4c);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x34);
  InitializeSystemResourceManager(ResourceManagerPointer + 0x1c);
  *ResourceManagerPointer = &SystemMemoryPoolTemplateA;
  ResourceManagerPointer[0x18] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[0x19] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x19] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1b) = 0;
  ResourceManagerPointer[0x18] = &SystemMemoryAllocatorReference;
  ProcessSystemResourceConfiguration(ResourceManagerPointer + 0x12,ResourceManagerPointer[0x14],AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  if (ResourceManagerPointer[0xd] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[5] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  return;
}



/**
 * @brief 初始化系统资源指针结构
 * 
 * 该函数负责初始化系统资源指针结构，设置内存分配器引用和全局数据引用。
 * 它会配置资源结构的各个字段，包括内存分配器、全局数据和防护检查。
 * 
 * @param ResourceManagerPointer 系统资源指针，需要初始化的资源结构
 * @return 返回初始化后的系统资源指针
 */
long long InitializeResourceManagerPointerStructure(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  *(void* *)(ResourceManagerPointer + 8) = &SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  *(void* *)(ResourceManagerPointer + 0x28) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x30) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x38) = 0;
  *(void* *)(ResourceManagerPointer + 0x28) = &SystemGlobalDataReference;
  *(void* *)(ResourceManagerPointer + 0x40) = 0;
  *(void* *)(ResourceManagerPointer + 0x30) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x38) = 0;
  *(void* *)(ResourceManagerPointer + 0x60) = 0;
  *(code **)(ResourceManagerPointer + 0x68) = _guard_check_icall;
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源执行器函数
 * 
 * 该函数负责执行系统资源操作，调用资源指针中的函数指针
 * 并设置系统全局数据引用和内存分配器引用。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005b7c0，现已重命名为ExecuteSystemResourceOperation
 */
void ExecuteSystemResourceOperation(long long systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)

{
  if (*(code **)(ResourceManagerPointer + 0x60) != (code *)0x0) {
    (**(code **)(ResourceManagerPointer + 0x60))(ResourceManagerPointer + 0x50,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  *(void* *)(ResourceManagerPointer + 0x28) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x30) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x30) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x40) = 0;
  *(void* *)(ResourceManagerPointer + 0x28) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 8) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  return;
}



/**
 * @brief 系统资源指针初始化函数
 * 
 * 该函数负责初始化系统资源指针，设置内存分配器引用和全局数据引用。
 * 它会重置资源指针的各种状态和标志位。
 * 
 * @param systemResourcePointer 系统资源指针的指针
 * @return 返回系统资源指针的指针
 * 
 * 原始函数名为FUN_18005b870，现已重命名为InitializeResourceManagerPointer
 */
void** InitializeResourceManagerPointer(void** systemResourcePointer)

{
  *systemResourcePointer = &SystemMemoryAllocatorReference;
  systemResourcePointer[1] = 0;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  *systemResourcePointer = &SystemGlobalDataReference;
  systemResourcePointer[3] = 0;
  systemResourcePointer[1] = 0;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  systemResourcePointer[4] = &SystemMemoryAllocatorReference;
  systemResourcePointer[5] = 0;
  *(uint32_t *)(systemResourcePointer + 6) = 0;
  systemResourcePointer[4] = &SystemGlobalDataReference;
  systemResourcePointer[7] = 0;
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 6) = 0;
  ResourceManagerPointer[8] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[9] = 0;
  *(uint32_t *)(ResourceManagerPointer + 10) = 0;
  ResourceManagerPointer[8] = &SystemGlobalDataReference;
  ResourceManagerPointer[0xb] = 0;
  ResourceManagerPointer[9] = 0;
  *(uint32_t *)(ResourceManagerPointer + 10) = 0;
  ResourceManagerPointer[0xc] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0xd] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xe) = 0;
  ResourceManagerPointer[0xc] = &SystemGlobalDataReference;
  ResourceManagerPointer[0xf] = 0;
  ResourceManagerPointer[0xd] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xe) = 0;
  ResourceManagerPointer[0x10] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[0x11] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x12) = 0;
  ResourceManagerPointer[0x10] = &SystemGlobalDataReference;
  ResourceManagerPointer[0x13] = 0;
  ResourceManagerPointer[0x11] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x12) = 0;
  ResourceManagerPointer[0x16] = 0;
  ResourceManagerPointer[0x17] = _guard_check_icall;
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置系统资源指针和内存分配器。
 * 用于系统资源管理的前期准备工作，确保资源分配的正确性。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005b960，现已重命名为InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  // 初始化第四组系统资源
  if ((code *)ResourceManagerPointer[0x16] != (code *)0x0) {
    (*(code *)ResourceManagerPointer[0x16])(ResourceManagerPointer + 0x14, 0, 0, ConfigurationFlag, 0xfffffffffffffffe);
  }
  
  // 设置全局数据引用和内存分配器
  ResourceManagerPointer[0x10] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[0x11] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x11] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x13) = 0;
  ResourceManagerPointer[0x10] = &SystemMemoryAllocatorReference;
  
  // 初始化第三组系统资源
  ResourceManagerPointer[0xc] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[0xd] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0xd] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xf) = 0;
  ResourceManagerPointer[0xc] = &SystemMemoryAllocatorReference;
  
  // 初始化第二组系统资源
  ResourceManagerPointer[8] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[9] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xb) = 0;
  ResourceManagerPointer[8] = &SystemMemoryAllocatorReference;
  
  // 初始化第一组系统资源
  ResourceManagerPointer[4] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 7) = 0;
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  
  // 初始化主系统资源
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  
  return;
}





/**
 * @brief 系统线程初始化函数
 * 
 * 该函数负责初始化系统线程，创建线程对象并启动线程执行。
 * 用于系统并发处理和多任务管理的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005ba80，现已重命名为InitializeSystemThread
 */
void InitializeSystemThread(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t threadStatus;
  void** SystemDataTable;
  void* *memoryAllocationEnd;
  void* *threadContextPointer;
  uint32_t threadConfiguration;
  void* threadHandle;
  
  // 初始化内存分配和线程上下文
  memoryAllocationEnd = &SystemGlobalDataReference;
  threadHandle = 0;
  threadContextPointer = (void* *)0x0;
  threadConfiguration = 0;
  
  // 创建系统线程对象
  void* *threadObject = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate, 0x10, 0x13, ConfigurationFlag, 0xfffffffffffffffe);
  *(uint8_t *)threadObject = 0;
  threadContextPointer = threadObject;
  
  // 启动系统线程
  threadStatus = StartSystemThread(threadObject);
  threadHandle = CONCAT44(threadHandle._4_4_, threadStatus);
  
  // 设置线程标识符
  *threadObject = 0x6e6f632072657355;
  *(uint32_t *)(threadObject + 1) = 0x676966;
  threadConfiguration = 0xb;
  
  // 调用系统线程处理函数
  ManageSystemResource(ResourceManagerPointer, &memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
  
  SystemCleanupFunction(threadObject);
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，设置指针的基本结构和初始值。
 * 它会将资源指针的所有字段重置为零，并设置标准大小标识符。
 * 
 * @param ResourceManagerPointer 系统资源指针，需要被初始化的资源指针
 * @return 初始化后的系统资源指针
 * 
 * 原始函数名为FUN_18005c060，现已重命名为InitializeResourceManagerPointer
 */
void* * InitializeResourceManagerPointer(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0x24;
  return ResourceManagerPointer;
}



long long InitializeSystemContext(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  InitializeSystemMemoryBlock(ResourceManagerPointer,0x20,0x400,InitializeSystemDataBlock,ReleaseSystemMemoryBlock);
  InitializeSystemMemoryBlock(ResourceManagerPointer + 0x8000,0x20,0x400,InitializeSystemDataBlock,ReleaseSystemMemoryBlock);
  *(void* *)(ResourceManagerPointer + 0x10400) = 0;
  *(void* *)(ResourceManagerPointer + 0x10408) = 0;
  *(void* *)(ResourceManagerPointer + 0x10410) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x10418) = 0x24;
  nextDataIndex = ResourceManagerPointer + 0x10002;
  localSystemHandle = 8;
  do {
    *(void* *)(nextDataIndex + -2) = 0;
    *(void* *)(nextDataIndex + 6) = 0;
    *(void* *)(nextDataIndex + 0xe) = 0;
    *(void* *)(nextDataIndex + 0x16) = 0;
    *(void* *)(nextDataIndex + 0x1e) = 0;
    *(void* *)(nextDataIndex + 0x26) = 0;
    *(void* *)(nextDataIndex + 0x2e) = 0;
    *(void* *)(nextDataIndex + 0x36) = 0;
    *(void* *)(nextDataIndex + 0x3e) = 0;
    *(void* *)(nextDataIndex + 0x46) = 0;
    *(void* *)(nextDataIndex + 0x4e) = 0;
    *(void* *)(nextDataIndex + 0x56) = 0;
    *(void* *)(nextDataIndex + 0x5e) = 0;
    *(void* *)(nextDataIndex + 0x66) = 0;
    *(void* *)(nextDataIndex + 0x6e) = 0;
    *(void* *)(nextDataIndex + 0x76) = 0;
    nextDataIndex = nextDataIndex + 0x80;
    localSystemHandle = localSystemHandle + -1;
  } while (localSystemHandle != 0);
  return ResourceManagerPointer;
}




void*
ProcessSystemDataOperation(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  CreateSystemObject(ConfigurationDataPointer,SystemContextManagerPointer + 0xe0,AdditionalParameter,ConfigurationFlag,0,0xfffffffffffffffe);
  return ConfigurationDataPointer;
}



/**
 * @brief 系统资源内存模板配置器
 * 
 * 该函数负责配置系统资源的内存模板，设置内存模板的引用和初始化参数。
 * 它会根据配置标志决定是否释放资源内存，并设置标准的内存模板引用。
 * 
 * @param ResourceManagerPointer 系统资源指针，需要配置的资源
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于扩展配置
 * @param ConfigurationFlag 配置标志，控制配置行为
 * @return 配置后的系统资源指针
 * 
 * 原始函数名为FUN_18005c210，现已重命名为ConfigureSystemResourceMemoryTemplate
 */
void* * ConfigureSystemResourceMemoryTemplate(void* *ResourceManagerPointer,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if ((code *)ResourceManagerPointer[6] != (code *)0x0) {
    (*(code *)ResourceManagerPointer[6])(ResourceManagerPointer + 4,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x40);
  }
  return ResourceManagerPointer;
}



void* *
CreateMemoryAllocationHandle(void* *ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(ResourceManagerPointer + 2) = 0;
  UNLOCK();
  ResourceManagerPointer[3] = 0xffffffffffffffff;
  *ResourceManagerPointer = &SystemDataStructureTemplateA;
  pointerToUnsigned1 = ResourceManagerPointer + 4;
  ResourceManagerPointer[6] = 0;
  ResourceManagerPointer[7] = _guard_check_icall;
  if (pointerToUnsigned1 != ConfigurationDataPointer) {
    if ((code *)ResourceManagerPointer[6] != (code *)0x0) {
      (*(code *)ResourceManagerPointer[6])(pointerToUnsigned1,0,0,ConfigurationFlag,0xfffffffffffffffe);
    }
    stringProcessingPointer = (code *)ConfigurationDataPointer[2];
    if (stringProcessingPointer != (code *)0x0) {
      (*stringProcessingPointer)(pointerToUnsigned1,ConfigurationDataPointer,1);
      stringProcessingPointer = (code *)ConfigurationDataPointer[2];
    }
    ResourceManagerPointer[6] = stringProcessingPointer;
    ResourceManagerPointer[7] = ConfigurationDataPointer[3];
  }
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 初始化系统数据引用
 * 
 * 该函数负责初始化系统数据的引用，设置系统数据指针和内存分配器引用。
 * 主要用于系统数据结构的初始化和配置。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向系统资源数据结构
 * 
 * 原始函数名为FUN_18005c380，现已重命名为InitializeSystemDataReference
 */
void InitializeSystemDataReference(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 0x18) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x20) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x20) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x30) = 0;
  *(void* *)(ResourceManagerPointer + 0x18) = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 清理系统资源指针
 * 
 * 该函数负责清理系统资源指针，重置系统数据引用和内存分配器引用。
 * 主要用于系统资源的清理和释放工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源数据结构
 * 
 * 原始函数名为FUN_18005c3d0，现已重命名为CleanupResourceManagerPointer
 */
void CleanupResourceManagerPointer(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  
  nextDataIndex = ResourceManagerPointer[1];
  localSystemHandle = *ResourceManagerPointer;
  if (localSystemHandle == nextDataIndex) {
    ResourceManagerPointer[1] = localSystemHandle;
  }
  else {
    do {
      *(void* *)(localSystemHandle + 0x18) = &SystemGlobalDataReference;
      if (*(long long *)(localSystemHandle + 0x20) != 0) {
          SystemCleanupFunction();
      }
      *(void* *)(localSystemHandle + 0x20) = 0;
      *(uint32_t *)(localSystemHandle + 0x30) = 0;
      *(void* *)(localSystemHandle + 0x18) = &SystemMemoryAllocatorReference;
      localSystemHandle = localSystemHandle + 0x50;
    } while (localSystemHandle != nextDataIndex);
    ResourceManagerPointer[1] = *ResourceManagerPointer;
  }
  return;
}



/**
 * @brief 释放系统资源配置
 * 
 * 该函数负责释放系统资源配置，包括清理内存和调用资源释放函数。
 * 它会根据配置标志决定是否完全释放资源内存。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 返回系统资源指针
 */
long long ReleaseSystemResourceConfiguration(long long ResourceManagerPointer,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(ResourceManagerPointer + 0xd0) != (code *)0x0) {
    (**(code **)(ResourceManagerPointer + 0xd0))(ResourceManagerPointer + 0xc0,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  ReleaseSystemResources(ResourceManagerPointer);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xe8);
  }
  return ResourceManagerPointer;
}




// 函数: void ProcessSystemResourceDataA(long long ResourceManagerPointer)
/**
 * @brief 系统资源锁定管理器函数
 * 
 * 该函数负责管理系统资源的锁定和解锁操作，包括线程同步和条件变量广播。
 * 它会确保资源在多线程环境下的安全访问，并正确处理同步状态。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源的基本信息和同步对象
 * @note 这是系统资源管理的重要组成部分，用于处理线程同步和资源锁定
 */
void ManageSystemResourceLock(long long ResourceManagerPointer)

{
  long long synchronizationObject;
  int lockResult;
  
  // 调用系统资源清理回调函数
  (**(code **)(ResourceManagerPointer + 0xd8))(ResourceManagerPointer + 0xc0);
  
  // 获取同步对象指针
  synchronizationObject = *(long long *)(ResourceManagerPointer + 0xe0);
  
  // 锁定互斥量
  lockResult = _Mtx_lock(synchronizationObject + 0x48);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  
  // 设置同步状态标志
  *(uint8_t *)(synchronizationObject + 0x98) = 1;
  
  // 广播条件变量通知等待的线程
  lockResult = _Cnd_broadcast(synchronizationObject);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  
  // 解锁互斥量
  lockResult = _Mtx_unlock(synchronizationObject + 0x48);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  
  return;
}



// 函数: void* *InitializeSystemDataTableManager(void* *ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统数据表管理器函数
 * 
 * 该函数负责初始化系统数据表管理器，设置系统资源指针和配置数据。
 * 它会处理数据表的初始化、配置和回调函数的设置。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @return 系统资源指针数组
 * @note 这是系统数据管理的重要组成部分，用于初始化数据表管理器
 */
void* *
InitializeSystemDataTableManager(void* *ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *dataTablePointer;
  code *configurationCallback;
  void* recursiveFlag;
  
  // 设置递归调用标志
  recursiveFlag = 0xfffffffffffffffe;
  
  // 初始化系统数据表管理器（递归调用保护）
  InitializeSystemDataTableManager();
  
  // 设置系统资源指针到默认数据表
  *ResourceManagerPointer = &SystemGlobalDataTableReference;
  
  // 获取数据表指针
  dataTablePointer = ResourceManagerPointer + 0x18;
  
  // 初始化回调函数指针和完整性检查
  ResourceManagerPointer[0x1a] = 0;
  ResourceManagerPointer[0x1b] = _guard_check_icall;
  
  // 如果数据表指针与配置数据指针不同，则进行配置
  if (dataTablePointer != ConfigurationDataPointer) {
    // 调用现有的回调函数（如果存在）
    if ((code *)ResourceManagerPointer[0x1a] != (code *)0x0) {
      (*(code *)ResourceManagerPointer[0x1a])(dataTablePointer,0,0,ConfigurationFlag,recursiveFlag);
    }
    
    // 获取配置回调函数
    configurationCallback = (code *)ConfigurationDataPointer[2];
    if (configurationCallback != (code *)0x0) {
      (*configurationCallback)(dataTablePointer,ConfigurationDataPointer,1);
      configurationCallback = (code *)ConfigurationDataPointer[2];
    }
    
    // 设置回调函数和完整性检查函数
    ResourceManagerPointer[0x1a] = configurationCallback;
    ResourceManagerPointer[0x1b] = ConfigurationDataPointer[3];
  }
  
  // 设置额外参数
  ResourceManagerPointer[0x1c] = AdditionalParameter;
  
  // 调用配置完成回调函数（如果存在）
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  
  return ResourceManagerPointer;
}





/**
 * 处理系统资源数据
 * 
 * 该函数负责处理系统资源数据，包括数据分配、加密和配置。
 * 主要用于系统资源的管理和处理操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18005c650，现已重命名为ProcessSystemResourceData
 */
void ProcessSystemResourceData(long long *ResourceManagerPointer)

{
  int systemStatus;
  long long localSystemHandle;
  int MemoryComparisonResult;
  void* unsignedSystemValue4;
  long long *plocalSystemPointer;
  code *configurationStringPointer;
  uint8_t auStack_128 [32];
  long long *plStack_108;
  long long **pplStack_100;
  long long alStack_f8 [2];
  code *pcStack_e8;
  code *pcStack_e0;
  void* unsignedValueD8;
  long long *plStack_d0;
  long long *plStack_c8;
  long long alStack_b8 [9];
  long long alStack_70 [10];
  uint8_t unsignedValue20;
  ulong long unsignedValue18;
  
  unsignedValueD8 = 0xfffffffffffffffe;
  unsignedValue18 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_128;
  systemStatus = *(int *)(*(long long *)(*(long long *)(SystemAllocationFlagsTemplate + 8) + 8) + 0x48);
  plStack_d0 = ResourceManagerPointer;
  systemCounter = _Thrd_id();
  if (systemCounter == systemStatus) {
    (*(code *)ResourceManagerPointer[3])(ResourceManagerPointer);
  }
  else {
    plStack_108 = alStack_b8;
    _Cnd_init_in_situ(alStack_b8);
    plStack_108 = alStack_70;
    _Mtx_init_in_situ(alStack_70,2);
    unsignedValue20 = 0;
    unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xe8,8,3);
    plStack_108 = alStack_f8;
    pcStack_e8 = (code *)0x0;
    pcStack_e0 = _guard_check_icall;
    if (alStack_f8 != ResourceManagerPointer) {
      configurationStringPointer = (code *)ResourceManagerPointer[2];
      if (configurationStringPointer != (code *)0x0) {
        (*configurationStringPointer)(alStack_f8,ResourceManagerPointer,1);
        configurationStringPointer = (code *)ResourceManagerPointer[2];
      }
      pcStack_e0 = (code *)ResourceManagerPointer[3];
      pcStack_e8 = configurationStringPointer;
    }
    plocalSystemPointer = (long long *)ProcessSystemResourceData(unsignedSystemValue4,alStack_f8,alStack_b8);
    plStack_c8 = plocalSystemPointer;
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
    }
    localSystemHandle = SystemAllocationFlagsTemplate;
    pplStack_100 = &plStack_108;
    plStack_108 = plocalSystemPointer;
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
    }
    SetupMemoryAllocationContext(localSystemHandle,&plStack_108);
    ConfigureSystemResources(alStack_b8);
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x38))(plocalSystemPointer);
    }
    pplStack_100 = (long long **)alStack_70;
    _Mtx_destroy_in_situ(alStack_70);
    pplStack_100 = (long long **)alStack_b8;
    _Cnd_destroy_in_situ(alStack_b8);
  }
  if ((code *)ResourceManagerPointer[2] != (code *)0x0) {
    (*(code *)ResourceManagerPointer[2])(ResourceManagerPointer,0,0);
  }
    ValidateSystemChecksum(unsignedValue18 ^ (ulong long)auStack_128);
}





/**
 * @brief 系统资源时间戳生成器函数
 * 
 * 该函数负责生成系统资源的时间戳，用于标识资源的创建时间。
 * 它会检查系统内存块的状态，并根据不同的状态生成不同的时间戳。
 * 
 * @param ResourcePointer 资源指针，用于存储生成的时间戳
 * @note 这是系统资源管理的重要组成部分，用于时间戳生成和资源标识
 */
void GenerateSystemResourceTimestamp(uint *ResourcePointer)

{
  uint currentTimeStamp;
  char systemStatusFlag;
  
  if (*(void* **)*SystemMemoryBlockStorage == &SystemMemoryBlockTemplatePrimary) {
    systemStatusFlag = *(int *)(SystemStatusFlags + 0xe0) != 0;
  }
  else {
    systemStatusFlag = (**(code **)(*(void* **)*SystemMemoryBlockStorage + 0x48))();
  }
  if (systemStatusFlag != '\0') {
    *ResourcePointer = 0x41c6fe0c;
    return;
  }
  currentTimeStamp = timeGetTime();
  *ResourcePointer = currentTimeStamp ^ 0x41c64e6d;
  return;
}



void* ProcessMemoryManagerOperation(long long ResourceManagerPointer,void* ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void* *HashEntryStatus;
  
  if (*(long long *)(ResourceManagerPointer + 0xb0) != 0) {
    initializationStatusFlag = (**(code **)(ResourceManagerPointer + 0xb8))(ConfigurationDataPointer);
    if (initializationStatusFlag == '\0') {
      if (SystemInitializationFlag == '\0') {
        HashEntryStatus = &SystemStringTemplate;
        if (*(void* **)(ResourceManagerPointer + 0x48) != (void* *)0x0) {
          HashEntryStatus = *(void* **)(ResourceManagerPointer + 0x48);
        }
        InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,HashEntryStatus);
      }
      ProcessDataManager(ResourceManagerPointer,ResourceManagerPointer + 0x80);
      return 0;
    }
  }
  ProcessDataManager(ResourceManagerPointer,ConfigurationDataPointer);
  return 1;
}





/**
 * @brief 系统资源状态管理器函数
 * 
 * 该函数负责管理系统资源的状态，包括状态的检查、比较和更新。
 * 它会创建系统线程对象，并根据状态值进行相应的资源管理操作。
 * 
 * @param ResourcePointer 资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param StatusPointer 状态指针，指向需要管理的状态值
 * @note 这是系统资源管理的重要组成部分，用于状态管理和资源控制
 */
void ManageSystemResourceStatus(void* *ResourcePointer,void* ConfigurationDataPointer,int *StatusPointer)

{
  int resourceStatus;
  bool statusComparisonResult;
  void* *currentResourceNode;
  long long threadObjectAddress;
  void* *nextResourceNode;
  void* insertionPosition;
  
  threadObjectAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x28,*(uint8_t *)(ResourcePointer + 5));
  resourceStatus = *StatusPointer;
  statusComparisonResult = true;
  *(int *)(threadObjectAddress + 0x20) = resourceStatus;
  nextResourceNode = (void* *)ResourcePointer[2];
  currentResourceNode = ResourcePointer;
  while (nextResourceNode != (void* *)0x0) {
    statusComparisonResult = resourceStatus < *(int *)(nextResourceNode + 4);
    currentResourceNode = nextResourceNode;
    if (resourceStatus < *(int *)(nextResourceNode + 4)) {
      nextResourceNode = (void* *)nextResourceNode[1];
    }
    else {
      nextResourceNode = (void* *)*nextResourceNode;
    }
  }
  nextResourceNode = currentResourceNode;
  if (statusComparisonResult) {
    if (currentResourceNode == (void* *)ResourcePointer[1]) goto ResourceNodeComparison;
    nextResourceNode = (void* *)SystemResourceOffsetGet(currentResourceNode);
  }
  if (*(int *)(threadObjectAddress + 0x20) <= *(int *)(nextResourceNode + 4)) {
      SystemCleanupFunction(threadObjectAddress);
  }
ResourceNodeComparison:
  if ((currentResourceNode == ResourcePointer) || (*(int *)(threadObjectAddress + 0x20) < *(int *)(currentResourceNode + 4))) {
    insertionPosition = 0;
  }
  else {
    insertionPosition = 1;
  }
    ConfigureSystemResourceHandle(threadObjectAddress,currentResourceNode,ResourcePointer,insertionPosition);
}




// 函数: void ProcessNodeManagerOperation(long long ResourceManagerPointer,uint32_t ConfigurationDataPointer)
void ProcessNodeManagerOperation(long long ResourceManagerPointer,uint32_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void* *HashEntryStatus;
  uint32_t auStackX_10 [6];
  
  if ((*(long long *)(ResourceManagerPointer + 0x1f00) != 0) &&
     (auStackX_10[0] = ConfigurationDataPointer, initializationStatusFlag = (**(code **)(ResourceManagerPointer + 0x1f08))(auStackX_10),
     ConfigurationDataPointer = auStackX_10[0], initializationStatusFlag == '\0')) {
    if (SystemInitializationFlag == '\0') {
      HashEntryStatus = &SystemStringTemplate;
      if (*(void* **)(ResourceManagerPointer + 0x1eb0) != (void* *)0x0) {
        HashEntryStatus = *(void* **)(ResourceManagerPointer + 0x1eb0);
      }
      InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,HashEntryStatus);
    }
    *(uint32_t *)(ResourceManagerPointer + 0x1ea0) = *(uint32_t *)(ResourceManagerPointer + 0x1ee8);
    return;
  }
  *(uint32_t *)(ResourceManagerPointer + 0x1ea0) = ConfigurationDataPointer;
  return;
}



/**
 * @brief 系统资源配置器
 * 
 * 该函数负责配置系统资源，设置内存分配器引用和全局数据引用。
 * 它会从配置数据中提取参数并应用到系统资源结构中，同时清理配置数据。
 * 
 * @param ResourceManagerPointer 系统资源指针，需要配置的资源
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @return 配置后的系统资源指针
 * 
 * 原始函数名为FUN_18005caa0，现已重命名为ConfigureSystemResources
 */
void* * ConfigureSystemResources(void* *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemGlobalDataReference;
  ResourceManagerPointer[3] = 0;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  ResourceManagerPointer[1] = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)((long long)ResourceManagerPointer + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(ResourceManagerPointer + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 6) = 0;
  ResourceManagerPointer[4] = &SystemGlobalDataReference;
  ResourceManagerPointer[7] = 0;
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 6) = 0;
  *(uint32_t *)(ResourceManagerPointer + 6) = *(uint32_t *)(ConfigurationDataPointer + 0x30);
  ResourceManagerPointer[5] = *(void* *)(ConfigurationDataPointer + 0x28);
  *(uint32_t *)((long long)ResourceManagerPointer + 0x3c) = *(uint32_t *)(ConfigurationDataPointer + 0x3c);
  *(uint32_t *)(ResourceManagerPointer + 7) = *(uint32_t *)(ConfigurationDataPointer + 0x38);
  *(uint32_t *)(ConfigurationDataPointer + 0x30) = 0;
  *(void* *)(ConfigurationDataPointer + 0x28) = 0;
  *(void* *)(ConfigurationDataPointer + 0x38) = 0;
  return ResourceManagerPointer;
}



/**
 * @brief 重置系统资源数据结构
 * 
 * 该函数负责重置系统资源数据结构，清理全局数据引用并重置相关字段。
 * 它会检查系统资源状态，并在必要时调用清理函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回重置后的系统资源指针
 */
long long ResetSystemResourceDataStructure(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 0x40) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x48) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x58) = 0;
  *(void* *)(ResourceManagerPointer + 0x40) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x28) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x38) = 0;
  *(void* *)(ResourceManagerPointer + 0x20) = &SystemMemoryAllocatorReference;
  return ResourceManagerPointer;
}





/**
 * @brief 系统资源分配配置器函数
 * 
 * 该函数负责配置系统资源的分配，包括资源的创建、分配和配置。
 * 它会处理系统数据管理器指针，并根据配置标志进行相应的资源分配操作。
 * 
 * @param ResourcePointer 资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于指定分配操作
 * @param ConfigurationFlag 配置标志，用于控制分配行为
 * @note 这是系统资源管理的重要组成部分，用于资源分配和配置
 */
void ConfigureSystemResourceAllocation(void* **ResourcePointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  byte comparisonByte1;
  uint comparisonValue2;
  long long dataManagerOffset;
  void* **allocatedResourcePointer;
  byte *resourceDataPointer;
  void* **systemDataManagerPointer;
  long long dataOffset;
  void* allocationResult;
  void* **resourceReference;
  char configurationFlagBuffer [8];
  uint32_t allocationFlags;
  void* *configurationDataObject;
  long long stackOffset60;
  void* *additionalParameterObject;
  long long stackOffset40;
  uint32_t stackOffset30;
  
  dataManagerOffset = SystemDataManagerPointer;
  configurationFlagBuffer[0] = (char)ConfigurationFlag;
  allocationResult = 0;
  systemDataManagerPointer = (void* **)(SystemDataManagerPointer + 0x70);
  resourceReference = ResourcePointer;
  FindSystemResourceNode(systemDataManagerPointer,&resourceReference,ConfigurationDataPointer,ConfigurationFlag,0,0xfffffffffffffffe);
  if (resourceReference != systemDataManagerPointer) {
    ProcessDataManager(resourceReference + 8,AdditionalParameter);
    return;
  }
  CreateSystemObject(&configurationDataObject,ConfigurationDataPointer);
  CreateSystemObject(&additionalParameterObject,AdditionalParameter);
  allocationFlags = 1;
  dataManagerOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x60,*(uint8_t *)(dataManagerOffset + 0x98));
  ConfigureSystemResourceMemoryAllocator(dataManagerOffset + 0x20,&configurationDataObject);
  allocatedResourcePointer = (void* **)SystemResourceAllocator(systemDataManagerPointer,configurationFlagBuffer,dataManagerOffset + 0x20);
  if (configurationFlagBuffer[0] == '\0') {
    ValidateSystemResourceConfiguration(dataManagerOffset);
    if (dataManagerOffset != 0) {
        SystemCleanupFunction(dataManagerOffset);
    }
    resourceReference = &additionalParameterObject;
    additionalParameterObject = &SystemGlobalDataReference;
    if (stackOffset40 == 0) {
      stackOffset40 = 0;
      stackOffset30 = 0;
      additionalParameterObject = &SystemMemoryAllocatorReference;
      resourceReference = &configurationDataObject;
      configurationDataObject = &SystemGlobalDataReference;
      if (stackOffset60 == 0) {
        return;
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  if (allocatedResourcePointer == systemDataManagerPointer) goto DataManagerCheck;
  if (*(int *)(allocatedResourcePointer + 6) != 0) {
    if (*(int *)(dataManagerOffset + 0x30) == 0) goto DataManagerCheck;
    resourceDataPointer = allocatedResourcePointer[5];
    dataOffset = *(long long *)(dataManagerOffset + 0x28) - (long long)resourceDataPointer;
    do {
      comparisonByte1 = *resourceDataPointer;
      comparisonValue2 = (uint)resourceDataPointer[dataOffset];
      if (comparisonByte1 != comparisonValue2) break;
      resourceDataPointer = resourceDataPointer + 1;
    } while (comparisonValue2 != 0);
    if (0 < (int)(comparisonByte1 - comparisonValue2)) goto DataManagerCheck;
  }
  allocationResult = 1;
DataManagerCheck:
    ConfigureSystemResourceHandle(dataManagerOffset,allocatedResourcePointer,systemDataManagerPointer,allocationResult,allocationFlags);
}



/**
 * @brief 系统资源内存分配器配置器
 * 
 * 该函数负责配置系统资源的内存分配器，设置内存模板引用和分配器引用。
 * 它会根据配置标志决定是否释放资源内存，并设置标准的内存模板。
 * 
 * @param ResourceManagerPointer 系统资源指针，需要配置的资源
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于扩展配置
 * @param ConfigurationFlag 配置标志，控制配置行为
 * @return 配置后的系统资源指针
 * 
 * 原始函数名为FUN_18005cdb0，现已重命名为ConfigureSystemResourceMemoryAllocator
 */
void* *
ConfigureSystemResourceMemoryAllocator(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ResourceManagerPointer[4] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x100,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}



void* * InitializeResourceContext(void* *ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  void* creationFlags;
  
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(ResourceManagerPointer + 2) = 0;
  UNLOCK();
  ResourceManagerPointer[3] = 0xffffffffffffffff;
  *ResourceManagerPointer = &SystemFunctionPointerTableA;
  pointerToUnsigned1 = ResourceManagerPointer + 4;
  *pointerToUnsigned1 = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[5] = 0;
  *(uint32_t *)(ResourceManagerPointer + 6) = 0;
  *pointerToUnsigned1 = &SystemResourceTemplatePrimary;
  ResourceManagerPointer[5] = ResourceManagerPointer + 7;
  *(uint32_t *)(ResourceManagerPointer + 6) = 0;
  *(uint8_t *)(ResourceManagerPointer + 7) = 0;
  creationFlags = ConfigurationDataPointer[1];
  *pointerToUnsigned1 = *ConfigurationDataPointer;
  ResourceManagerPointer[5] = creationFlags;
  creationFlags = ConfigurationDataPointer[3];
  ResourceManagerPointer[6] = ConfigurationDataPointer[2];
  ResourceManagerPointer[7] = creationFlags;
  creationFlags = ConfigurationDataPointer[5];
  ResourceManagerPointer[8] = ConfigurationDataPointer[4];
  ResourceManagerPointer[9] = creationFlags;
  creationFlags = ConfigurationDataPointer[7];
  ResourceManagerPointer[10] = ConfigurationDataPointer[6];
  ResourceManagerPointer[0xb] = creationFlags;
  creationFlags = ConfigurationDataPointer[9];
  ResourceManagerPointer[0xc] = ConfigurationDataPointer[8];
  ResourceManagerPointer[0xd] = creationFlags;
  creationFlags = ConfigurationDataPointer[0xb];
  ResourceManagerPointer[0xe] = ConfigurationDataPointer[10];
  ResourceManagerPointer[0xf] = creationFlags;
  creationFlags = ConfigurationDataPointer[0xd];
  ResourceManagerPointer[0x10] = ConfigurationDataPointer[0xc];
  ResourceManagerPointer[0x11] = creationFlags;
  creationFlags = ConfigurationDataPointer[0xf];
  ResourceManagerPointer[0x12] = ConfigurationDataPointer[0xe];
  ResourceManagerPointer[0x13] = creationFlags;
  creationFlags = ConfigurationDataPointer[0x11];
  ResourceManagerPointer[0x14] = ConfigurationDataPointer[0x10];
  ResourceManagerPointer[0x15] = creationFlags;
  creationFlags = ConfigurationDataPointer[0x13];
  ResourceManagerPointer[0x16] = ConfigurationDataPointer[0x12];
  ResourceManagerPointer[0x17] = creationFlags;
  creationFlags = ConfigurationDataPointer[0x15];
  ResourceManagerPointer[0x18] = ConfigurationDataPointer[0x14];
  ResourceManagerPointer[0x19] = creationFlags;
  creationFlags = ConfigurationDataPointer[0x17];
  ResourceManagerPointer[0x1a] = ConfigurationDataPointer[0x16];
  ResourceManagerPointer[0x1b] = creationFlags;
  creationFlags = ConfigurationDataPointer[0x19];
  ResourceManagerPointer[0x1c] = ConfigurationDataPointer[0x18];
  ResourceManagerPointer[0x1d] = creationFlags;
  creationFlags = ConfigurationDataPointer[0x1b];
  ResourceManagerPointer[0x1e] = ConfigurationDataPointer[0x1a];
  ResourceManagerPointer[0x1f] = creationFlags;
  *(uint32_t *)(ResourceManagerPointer + 0x17) = *(uint32_t *)(ConfigurationDataPointer + 0x13);
  return ResourceManagerPointer;
}



/**
 * @brief 系统资源状态获取器
 * 
 * 该函数负责获取系统资源的状态信息，使用互斥锁确保线程安全。
 * 它会锁定系统资源，获取状态值，然后解锁资源，确保操作的原子性。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含互斥锁和状态信息
 * @return 系统资源状态值
 * 
 * 原始函数名为FUN_18005cf50，现已重命名为GetSystemResourceStatus
 */
uint32_t GetSystemResourceStatus(long long ResourceManagerPointer)

{
  int systemStatus;
  uint32_t creationFlags;
  
  systemStatus = _Mtx_lock(ResourceManagerPointer + 0x9f0);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  creationFlags = CheckSystemInputManagerStatus();
  systemStatus = _Mtx_unlock(ResourceManagerPointer + 0x9f0);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  return creationFlags;
}




/**
 * @brief 系统输入管理器状态检查器
 * 
 * 该函数负责检查系统输入管理器的状态，通过多个互斥锁确保线程安全。
 * 它会检查输入管理器的不同部分，获取各个状态值并返回综合结果。
 * 
 * @return 系统输入管理器的综合状态值
 * 
 * 原始函数名为FUN_18005cfc0，现已重命名为CheckSystemInputManagerStatus
 */
int CheckSystemInputManagerStatus(void)

{
  long long nextDataIndex;
  long long localSystemHandle;
  int MemoryComparisonResult;
  int systemIndex;
  int systemValue;
  int systemFlag;
  int systemOffset;
  
  localSystemHandle = SystemInputManagerPointer;
  nextDataIndex = SystemInputManagerPointer + 0x770;
  systemCounter = _Mtx_lock(nextDataIndex);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  systemCounter = CheckSystemInputManagerStatus();
  systemIndex = _Mtx_unlock(nextDataIndex);
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  systemIndex = _Mtx_lock(localSystemHandle + 0x7c0);
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  systemIndex = CheckSystemInputManagerStatus();
  systemValue = _Mtx_unlock(localSystemHandle + 0x7c0);
  if (systemValue != 0) {
    __Throw_C_error_std__YAXH_Z(systemValue);
  }
  systemValue = GetSystemResourceStatus(localSystemHandle);
  systemFlag = _Mtx_lock(localSystemHandle + 0x950);
  if (systemFlag != 0) {
    __Throw_C_error_std__YAXH_Z(systemFlag);
  }
  systemFlag = CheckSystemInputManagerStatus();
  systemOffset = _Mtx_unlock(localSystemHandle + 0x950);
  if (systemOffset != 0) {
    __Throw_C_error_std__YAXH_Z(systemOffset);
  }
  return systemFlag + systemIndex + systemCounter + systemValue;
}





/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，设置资源参数和配置选项
 * 用于系统资源管理的前期准备工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_18005d0e0，现已重命名为InitializeSystemResources
 */
void InitializeSystemResources(ulong long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  char SystemNodeStatusFlag;
  uint SystemConfigurationValue;
  ulong long SystemResourceHandle;
  ulong long *SystemResourceHandlePointer;
  long long SystemTimestamp;
  long long LocalSystemFlags;
  int SystemMemoryOffset;
  int SystemErrorCode;
  float SystemFloatValue1;
  float SystemFloatValue2;
  double SystemDoubleValue;
  ulong long SystemUlongValue;
  uint8_t SystemBuffer1 [32];
  void* SystemPointer1;
  double *SystemDoublePointer;
  char SystemMainBuffer [1024];
  ulong long uStack_38;
  void* unsignedValue30;
  void* LocalSystemPointer;
  
  SystemMemoryOffset = -1;
  SystemErrorCode = -1;
  SystemConfigurationValue = (uint)ResourceManagerPointer;
  SystemResourceHandle = ResourceManagerPointer & 0xffffffff;
  while (SystemConfigurationValue != 0) {
    SystemErrorCode = SystemErrorCode + 1;
    SystemConfigurationValue = (uint)SystemResourceHandle >> 1;
    SystemResourceHandle = (ulong long)SystemConfigurationValue;
  }
  SystemConfigurationValue = 0x400;
  do {
    SystemMemoryOffset = SystemMemoryOffset + 1;
    SystemConfigurationValue = SystemConfigurationValue >> 1;
  } while (SystemConfigurationValue != 0);
  SystemNodeStatusFlag = (&SystemFormatDataArray)[SystemErrorCode / SystemMemoryOffset];
  SystemPointer1 = 0x18005d147;
  SystemFloatValue1 = (float)powf(0x44800000);
  SystemFloatValue2 = (float)(long long)ResourceManagerPointer;
  if ((long long)ResourceManagerPointer < 0) {
    SystemFloatValue2 = SystemFloatValue2 + 1.8446744e+19;
  }
  SystemUlongValue = (ulong long)(uint)(int)SystemNodeStatusFlag;
  SystemDoubleValue = (double)(SystemFloatValue1 * SystemFloatValue2);
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)SystemBuffer1;
  SystemResourceHandlePointer = (ulong long *)SystemGlobalDataAllocate();
  LocalSystemPointer = 0;
  SystemPointer1 = 0;
  SystemDoublePointer = &SystemDoubleValue;
  SystemErrorCode = __stdio_common_vsprintf(*SystemResourceHandlePointer | 1,0,0,&SystemFormatString);
  if (SystemErrorCode < 0) {
    SystemErrorCode = -1;
  }
  if (SystemErrorCode < 0x400) {
    SystemPointer1 = 0;
    SystemDoublePointer = &SystemDoubleValue;
    __stdio_common_vsprintf(*SystemResourceHandlePointer | 1,SystemMainBuffer,0x400,&SystemFormatString);
    LocalSystemPointer = -1;
    do {
      LocalSystemFlags = LocalSystemPointer;
      LocalSystemPointer = LocalSystemFlags + 1;
    } while (SystemMainBuffer[LocalSystemFlags + 1] != '\0');
    SystemErrorCode = (int)(LocalSystemFlags + 1);
    if (0 < SystemErrorCode) {
      ExecuteSystemCommand(ConfigurationDataPointer,*(int *)(ConfigurationDataPointer + 0x10) + SystemErrorCode);
        memcpy((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8),SystemMainBuffer,
             (long long)((int)LocalSystemFlags + 2));
    }
  }
  else {
    systemCode = systemCode + 1;
    if (systemCode != 0) {
      localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,3);
    }
    FormatSystemResourceOutput(localSystemPointer,(long long)systemCode,&SystemFormatString,&dStackX_18);
    SearchSystemResourceString(ConfigurationDataPointer,localSystemPointer);
    if (localSystemPointer != 0) {
        SystemCleanupFunction(localSystemPointer);
    }
  }
    ValidateSystemChecksum(uStack_38 ^ (ulong long)aconfigurationFlags478);
}



/**
 * @brief 传输系统资源配置数据
 * 
 * 该函数负责传输系统资源配置数据，将配置数据从一个资源复制到另一个资源。
 * 它会清理源资源配置，并将目标配置数据复制到源资源中。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 返回系统资源指针
 */
long long TransferSystemResourceConfigurationData(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  if (*(long long *)(ResourceManagerPointer + 8) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  *(void* *)(ResourceManagerPointer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x10) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  *(void* *)(ResourceManagerPointer + 8) = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)(ResourceManagerPointer + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(ResourceManagerPointer + 0x18) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  return ResourceManagerPointer;
}




/**
 * @brief 处理额外输出资源
 * 
 * 该函数负责处理系统中的额外输出资源，包括资源初始化、
 * 内存分配和状态设置。用于系统资源管理的辅助操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，通常为缓冲区指针
 * @note 这是资源管理系统的辅助处理函数
 */
void ProcessExtraOutputResource(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(ConfigurationDataPointer + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ConfigurationDataPointer + 0x28) = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0x38) = 0;
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemMemoryAllocatorReference;
  if (ConfigurationDataPointer != 0) {
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}




/**
 * @brief 处理系统资源配置
 * 
 * 该函数负责处理系统资源的配置操作，包括递归处理配置数据、
 * 设置全局数据引用和内存分配器引用。这是系统资源管理的核心函数。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数会递归调用自身处理配置数据
 * @warning 此函数包含不返回的子程序调用，可能导致程序终止
 * 
 * 原始函数名为FUN_18005d260，现已重命名为ProcessSystemResourceConfiguration
 */
void ProcessSystemResourceConfiguration(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessSystemResourceConfiguration(ResourceManagerPointer,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




/**
 * @brief 处理系统资源配置包装函数
 * 
 * 该函数是ProcessSystemResourceConfiguration的包装函数，用于处理系统资源指针
 * 偏移位置的配置数据。简化了配置数据的访问和传递。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数内部调用ProcessSystemResourceConfiguration处理配置数据
 * 
 * 原始函数名为FUN_18005d310，现已重命名为ProcessSystemResourceConfigurationWrapper
 */
void ProcessSystemResourceConfigurationWrapper(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceConfiguration(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 处理系统资源配置包装函数B
 * 
 * 该函数是ProcessSystemResourceConfiguration的第二个包装函数，功能与第一个包装函数相同，
 * 用于处理系统资源指针偏移位置的配置数据。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数内部调用ProcessSystemResourceConfiguration处理配置数据
 * 
 * 原始函数名为FUN_18005d330，现已重命名为ProcessSystemResourceConfigurationWrapperB
 */
void ProcessSystemResourceConfigurationWrapperB(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceConfiguration(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 处理系统资源配置包装函数C
 * 
 * 该函数是ProcessSystemResourceConfiguration的第三个包装函数，功能与前两个包装函数相同，
 * 用于处理系统资源指针偏移位置的配置数据。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数内部调用ProcessSystemResourceConfiguration处理配置数据
 * 
 * 原始函数名为FUN_18005d360，现已重命名为ProcessSystemResourceConfigurationWrapperC
 */
void ProcessSystemResourceConfigurationWrapperC(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceConfiguration(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x10),AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  return;
}




/**
 * @brief 系统资源格式化输出函数
 * 
 * 该函数负责格式化输出系统资源信息，使用标准输出流打印资源相关的调试信息。
 * 它会分配全局数据缓冲区，并通过格式化字符串输出系统状态。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含格式化字符串
 * @param ConfigurationDataPointer 配置数据指针，用于格式化参数
 * @param AdditionalParameter 额外参数，用于格式化参数
 * @param ConfigurationFlag 配置标志，用于格式化参数
 * @note 此函数使用标准输出流进行格式化输出
 * 
 * 原始函数名为FUN_18005d3a0，现已重命名为FormatSystemResourceOutput
 */
void FormatSystemResourceOutput(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* standardOutputHandle;
  void** globalDataBuffer;
  void* formatParameter1;
  uint64_t SystemInitializationFlag;
  void* formatParameter3;
  
  formatParameter1 = ConfigurationDataPointer;
  formatParameter2 = AdditionalParameter;
  formatParameter3 = ConfigurationFlag;
  standardOutputHandle = __acrt_iob_func(1);
  globalDataBuffer = (void* *)SystemGlobalDataAllocate();
  __stdio_common_vfprintf(*globalDataBuffer,standardOutputHandle,ResourceManagerPointer,0,&formatParameter1);
  return;
}



/**
 * @brief 系统资源字符串搜索函数
 * 
 * 该函数负责在系统资源中搜索指定的字符串。它会遍历资源表，
 * 比较字符串长度和内容，返回匹配的资源指针。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源表信息
 * @param ConfigurationDataPointer 要搜索的字符串指针
 * @return 匹配的资源指针，如果未找到则返回NULL
 * @note 此函数使用字符串长度和内容比较进行精确匹配
 * 
 * 原始函数名为FUN_18005d400，现已重命名为SearchSystemResourceString
 */
void* * SearchSystemResourceString(long long ResourceManagerPointer,char *ConfigurationDataPointer)

{
  char *stringEndPointer;
  char currentChar;
  void* *resourceTablePointer;
  char *resourceString;
  long long stringLength;
  char *searchString;
  
  if (ConfigurationDataPointer == (char *)0x0) {
    return *(void* **)(ResourceManagerPointer + 0x58);
  }
  currentChar = *ConfigurationDataPointer;
  searchString = ConfigurationDataPointer;
  while (currentChar != '\0') {
    searchString = searchString + 1;
    currentChar = *searchString;
  }
  resourceTablePointer = *(void* **)(ResourceManagerPointer + 0x58);
  do {
    if (resourceTablePointer == (void* *)0x0) {
      return (void* *)0x0;
    }
    resourceString = (char *)*resourceTablePointer;
    if (resourceString == (char *)0x0) {
      stringLength = 0;
      resourceString = (char *)0x180d48d24;
    }
    else {
      stringLength = resourceTablePointer[2];
    }
    if (stringLength == (long long)searchString - (long long)ConfigurationDataPointer) {
      stringEndPointer = resourceString + stringLength;
      if (stringEndPointer <= resourceString) {
        return resourceTablePointer;
      }
      stringLength = (long long)ConfigurationDataPointer - (long long)resourceString;
      while (*resourceString == resourceString[stringLength]) {
        resourceString = resourceString + 1;
        if (stringEndPointer <= resourceString) {
          return resourceTablePointer;
        }
      }
    }
    resourceTablePointer = (void* *)resourceTablePointer[0xb];
  } while( true );
}



/**
 * @brief 系统资源字符串比较搜索函数
 * 
 * 该函数负责在系统资源中搜索并比较字符串。它会遍历配置数据指针链表，
 * 比较字符串长度和内容，返回匹配的配置数据指针。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针链表
 * @return 匹配的配置数据指针，如果未找到则返回NULL
 * @note 此函数使用字符串长度和内容比较进行精确匹配
 * 
 * 原始函数名为FUN_18005d430，现已重命名为SearchAndCompareSystemResourceString
 */
void* * SearchAndCompareSystemResourceString(void* ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  char *stringEndPointer;
  char *resourceString;
  long long stringLength;
  long long searchStringLength;
  long long stringOffset;
  
  if (ConfigurationDataPointer != (void* *)0x0) {
    do {
      resourceString = (char *)*ConfigurationDataPointer;
      if (resourceString == (char *)0x0) {
        stringLength = 0;
        resourceString = (char *)0x180d48d24;
      }
      else {
        stringLength = ConfigurationDataPointer[2];
      }
      if (stringLength == searchStringLength) {
        stringEndPointer = resourceString + stringLength;
        if (stringEndPointer <= resourceString) {
          return ConfigurationDataPointer;
        }
        stringOffset = stringOffset - (long long)resourceString;
        while (*resourceString == resourceString[stringOffset]) {
          resourceString = resourceString + 1;
          if (stringEndPointer <= resourceString) {
            return ConfigurationDataPointer;
          }
        }
      }
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
    } while (ConfigurationDataPointer != (void* *)0x0);
  }
  return (void* *)0x0;
}



/**
 * @brief 系统资源数据指针查找函数
 * 
 * 该函数负责在系统资源中查找和匹配数据指针，通过遍历配置数据指针
 * 来定位所需的资源数据。该函数包含内存块操作和指针比较逻辑。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 匹配的数据指针，如果未找到则返回NULL
 * 
 * 原始函数名为FUN_18005d484，现已重命名为FindSystemResourceDataPointer
 */
void* * FindSystemResourceDataPointer(void* ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  char *memoryBlockPointer1;
  char *memoryBlockPointer2;
  char *systemMemoryBlockPtr;
  long long localResourceOffset;
  long long targetOffset;
  long long comparisonOffset;
  
  while( true ) {
    do {
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
      if (ConfigurationDataPointer == (void* *)0x0) {
        return (void* *)0x0;
      }
      if ((char *)*ConfigurationDataPointer == (char *)0x0) {
        localResourceOffset = 0;
        memoryBlockPointer2 = systemMemoryBlockPtr;
      }
      else {
        localResourceOffset = ConfigurationDataPointer[2];
        memoryBlockPointer2 = (char *)*ConfigurationDataPointer;
      }
    } while (localResourceOffset != targetOffset);
    memoryBlockPointer1 = memoryBlockPointer2 + localResourceOffset;
    if (memoryBlockPointer1 <= memoryBlockPointer2) break;
    localResourceOffset = comparisonOffset - (long long)memoryBlockPointer2;
    while (*memoryBlockPointer2 == memoryBlockPointer2[localResourceOffset]) {
      memoryBlockPointer2 = memoryBlockPointer2 + 1;
      if (memoryBlockPointer1 <= memoryBlockPointer2) {
        return ConfigurationDataPointer;
      }
    }
  }
  return ConfigurationDataPointer;
}



/**
 * @brief 获取系统资源数据指针
 * 
 * 该函数从系统资源指针的指定偏移量处获取数据指针
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 数据指针
 * 
 * 原始函数名为FUN_18005d498，现已重命名为GetSystemResourceDataPointer
 */
void* GetSystemResourceDataPointer(long long ResourceManagerPointer)

{
  return *(void* *)(ResourceManagerPointer + 0x58);
}



/**
 * @brief 查找系统资源字符串匹配
 * 
 * 该函数在系统资源中查找与指定配置数据字符串匹配的资源
 * 支持字符串长度计算和比较操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据字符串指针
 * @param AdditionalParameter 额外参数（字符串长度）
 * @return 匹配的资源指针，未找到返回NULL
 * 
 * 原始函数名为FUN_18005d4b0，现已重命名为FindSystemResourceStringMatch
 */
void* * FindSystemResourceStringMatch(long long ResourceManagerPointer,char *ConfigurationDataPointer,long long AdditionalParameter)

{
  char *stringEndPointer;
  char currentChar;
  void* *resourcePointer;
  char *resourceString;
  long long stringLength;
  
  if (ConfigurationDataPointer == (char *)0x0) {
    return *(void* **)(ResourceManagerPointer + 0x30);
  }
  if (AdditionalParameter == 0) {
    currentChar = *ConfigurationDataPointer;
    resourceString = ConfigurationDataPointer;
    while (currentChar != '\0') {
      resourceString = resourceString + 1;
      currentChar = *resourceString;
    }
    AdditionalParameter = (long long)resourceString - (long long)ConfigurationDataPointer;
  }
  resourcePointer = *(void* **)(ResourceManagerPointer + 0x30);
  do {
    if (resourcePointer == (void* *)0x0) {
      return (void* *)0x0;
    }
    resourceString = (char *)*resourcePointer;
    if (resourceString == (char *)0x0) {
      stringLength = 0;
      resourceString = (char *)0x180d48d24;
    }
    else {
      stringLength = resourcePointer[2];
    }
    if (stringLength == AdditionalParameter) {
      stringEndPointer = resourceString + stringLength;
      if (stringEndPointer <= resourceString) {
        return resourcePointer;
      }
      stringLength = (long long)ConfigurationDataPointer - (long long)resourceString;
      while (*resourceString == resourceString[stringLength]) {
        resourceString = resourceString + 1;
        if (stringEndPointer <= resourceString) {
          return resourcePointer;
        }
      }
    }
    resourcePointer = (void* *)resourcePointer[0xb];
  } while( true );
}



/**
 * @brief 在配置数据中查找匹配的资源
 * 
 * 该函数在配置数据指针链表中查找与指定参数匹配的资源
 * 支持字符串比较和资源匹配操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（用于匹配）
 * @return 匹配的配置数据指针，未找到返回NULL
 * 
 * 原始函数名为FUN_18005d4e0，现已重命名为FindMatchingConfigurationResource
 */
void* * FindMatchingConfigurationResource(void* ResourceManagerPointer,void* *ConfigurationDataPointer,long long AdditionalParameter)

{
  char *stringEndPointer;
  char *configString;
  long long configLength;
  long long systemResourceValue;
  
  if (ConfigurationDataPointer != (void* *)0x0) {
    do {
      configString = (char *)*ConfigurationDataPointer;
      if (configString == (char *)0x0) {
        configLength = 0;
        configString = (char *)0x180d48d24;
      }
      else {
        configLength = ConfigurationDataPointer[2];
      }
      if (configLength == AdditionalParameter) {
        stringEndPointer = configString + configLength;
        if (stringEndPointer <= configString) {
          return ConfigurationDataPointer;
        }
        configLength = systemResourceValue - (long long)configString;
        while (*configString == configString[configLength]) {
          configString = configString + 1;
          if (stringEndPointer <= configString) {
            return ConfigurationDataPointer;
          }
        }
      }
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
    } while (ConfigurationDataPointer != (void* *)0x0);
  }
  return (void* *)0x0;
}



/**
 * @brief 查找配置数据中的匹配资源
 * 
 * 该函数在配置数据指针链表中查找与指定参数匹配的资源
 * 通过遍历链表和字符串比较来实现资源匹配
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（用于匹配）
 * @return 匹配的配置数据指针，未找到返回NULL
 * 
 * 原始函数名为FUN_18005d534，现已重命名为FindMatchingConfigurationDataResource
 */
void* * FindMatchingConfigurationDataResource(void* ResourceManagerPointer,void* *ConfigurationDataPointer,long long AdditionalParameter)

{
  char *stringEndPointer;
  char *configString;
  char *systemMemoryBlockPtr;
  long long configLength;
  long long systemResourceValue;
  
  while( true ) {
    do {
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
      if (ConfigurationDataPointer == (void* *)0x0) {
        return (void* *)0x0;
      }
      if ((char *)*ConfigurationDataPointer == (char *)0x0) {
        configLength = 0;
        configString = systemMemoryBlockPtr;
      }
      else {
        configLength = ConfigurationDataPointer[2];
        configString = (char *)*ConfigurationDataPointer;
      }
    } while (configLength != AdditionalParameter);
    stringEndPointer = configString + configLength;
    if (stringEndPointer <= configString) break;
    configLength = systemResourceValue - (long long)configString;
    while (*configString == configString[configLength]) {
      configString = configString + 1;
      if (stringEndPointer <= configString) {
        return ConfigurationDataPointer;
      }
    }
  }
  return ConfigurationDataPointer;
}



/**
 * @brief 获取系统资源配置指针
 * 
 * 该函数从系统资源指针的指定偏移量处获取配置指针
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 配置指针
 * 
 * 原始函数名为FUN_18005d548，现已重命名为GetSystemResourceConfigurationPointer
 */
void* GetSystemResourceConfigurationPointer(long long ResourceManagerPointer)

{
  return *(void* *)(ResourceManagerPointer + 0x30);
}




/**
 * @brief 执行系统资源迭代器操作
 * 
 * 该函数负责遍历系统资源数组，对每个资源执行指定的操作
 * 通过迭代器模式处理系统资源集合中的每个元素
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * @note 此函数会遍历整个资源数组并执行操作
 * @warning 如果系统资源指针为空，函数会直接返回
 */
void ExecuteSystemResourceIterator(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *resourceIteratorEnd;
  void** systemDataTable;
  void* operationFlags;
  
  operationFlags = 0xfffffffffffffffe;
  resourceIteratorEnd = (void* *)ResourceManagerPointer[1];
  for (resourceIterator = (void* *)*ResourceManagerPointer; resourceIterator != resourceIteratorEnd; resourceIterator = resourceIterator + 4) {
    (**(code **)*resourceIterator)(resourceIterator,0,AdditionalParameter,ConfigurationFlag,operationFlags);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void CleanupSystemMemoryAllocation(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void CleanupSystemMemoryAllocation(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 4) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,AdditionalParameter,ConfigurationFlag,allocationContext);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}



/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置虚拟表和处理器
 * 根据配置标志决定是否释放系统资源
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return void* 返回系统资源指针
 * @note 此函数会设置系统虚拟表并初始化资源处理器
 * @warning 如果配置标志第一位为1，会释放系统资源
 */
void* *
InitializeSystemResourceManager(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* operationFlags;
  
  operationFlags = 0xfffffffffffffffe;
  *ResourceManagerPointer = &SystemVirtualTableTemplateB;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xc0,AdditionalParameter,ConfigurationFlag,operationFlags);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 初始化系统同步对象
 * 
 * 该函数负责初始化系统同步对象，包括信号量和各种句柄
 * 设置系统资源的基本配置和同步机制
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return uint8_t* 返回系统资源指针
 * @note 此函数会创建信号量并初始化系统同步机制
 * @warning 函数会关闭现有的系统句柄并重新初始化
 */
uint8_t * InitializeSystemSynchronizationObjects(uint8_t *ResourceManagerPointer)

{
  void* semaphoreHandle;
  
  *(void* *)(ResourceManagerPointer + 8) = 0;
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 3;
  *(void* *)(ResourceManagerPointer + 0x28) = 0;
  *(void* *)(ResourceManagerPointer + 0x30) = 0;
  *(void* *)(ResourceManagerPointer + 0x38) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x40) = 3;
  *(void* *)(ResourceManagerPointer + 0x48) = 0;
  *(void* *)(ResourceManagerPointer + 0x50) = 0;
  *(void* *)(ResourceManagerPointer + 0x58) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x60) = 3;
  semaphoreHandle = CreateSemaphoreW(0,0,0x7fffffff,0,0xfffffffffffffffe);
  *(void* *)(ResourceManagerPointer + 0x68) = semaphoreHandle;
  semaphoreHandle = CreateSemaphoreW(0,0,0x7fffffff,0);
  *(void* *)(ResourceManagerPointer + 0x70) = semaphoreHandle;
  CloseSystemHandle(ResourceManagerPointer + 0x78);
  CloseSystemHandle(ResourceManagerPointer + 0x2e0);
  CloseSystemHandle(ResourceManagerPointer + 0x548);
  *(uint32_t *)(ResourceManagerPointer + 0x7b0) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x7b4) = 0x1000;
  *ResourceManagerPointer = 0;
  return ResourceManagerPointer;
}




/**
 * @brief 关闭系统句柄
 * 
 * 该函数负责关闭系统句柄，释放相关资源
 * 确保系统资源被正确清理
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 无返回值
 * @note 此函数会调用系统API关闭句柄
 * @warning 关闭后的句柄将不再有效
 */
void CloseSystemHandle(void* *ResourceManagerPointer)

{
  CloseHandle(*ResourceManagerPointer);
  return;
}





// 函数: void InitializeSystemLogger(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemLogger(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long *plocalResourceOffset;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  int systemFlag;
  long long localDataIndex;
  
  localSystemPointer = SystemMemoryPoolTemplate;
  if (*(code **)(SystemMemoryPoolTemplate + 0x20) != (code *)0x0) {
    (**(code **)(SystemMemoryPoolTemplate + 0x20))(SystemMemoryPoolTemplate + 0x10,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  *(void* *)(localSystemPointer + 0x20) = 0;
  *(code **)(localSystemPointer + 0x28) = _guard_check_icall;
  systemFlag = 0;
  PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 8);
  if (*(long long *)(ResourceManagerPointer + 0x10) - *PrimaryResourcePointer >> 3 != 0) {
    localSystemPointer = 0;
    do {
      ManageSystemThreads(*(void* )(*PrimaryResourcePointer + localSystemPointer));
      systemFlag = systemFlag + 1;
      localSystemPointer = localSystemPointer + 8;
    } while ((ulong long)(long long)systemFlag < (ulong long)(*(long long *)(ResourceManagerPointer + 0x10) - *PrimaryResourcePointer >> 3))
    ;
  }
  systemFlag = 0;
  resourcePoolPointer = (long long *)(ResourceManagerPointer + 0x28);
  if (*(long long *)(ResourceManagerPointer + 0x30) - *resourcePoolPointer >> 3 != 0) {
    localSystemPointer = 0;
    do {
      ManageSystemThreads(*(void* )(*resourcePoolPointer + localSystemPointer));
      systemFlag = systemFlag + 1;
      localSystemPointer = localSystemPointer + 8;
    } while ((ulong long)(long long)systemFlag < (ulong long)(*(long long *)(ResourceManagerPointer + 0x30) - *resourcePoolPointer >> 3))
    ;
  }
  systemFlag = 0;
  plocalResourceOffset = (long long *)(ResourceManagerPointer + 0x48);
  if (*(long long *)(ResourceManagerPointer + 0x50) - *plocalResourceOffset >> 3 != 0) {
    localSystemPointer = 0;
    do {
      ManageSystemThreads(*(void* )(*plocalResourceOffset + localSystemPointer));
      systemFlag = systemFlag + 1;
      localSystemPointer = localSystemPointer + 8;
    } while ((ulong long)(long long)systemFlag < (ulong long)(*(long long *)(ResourceManagerPointer + 0x50) - *plocalResourceOffset >> 3))
    ;
  }
  systemFlag = 0;
  localSystemPointer = *PrimaryResourcePointer;
  if (*(long long *)(ResourceManagerPointer + 0x10) - localSystemPointer >> 3 != 0) {
    localDataIndex = 0;
    do {
      pbufferBaseAddress = *(long long **)(localDataIndex + localSystemPointer);
      if (pbufferBaseAddress != (long long *)0x0) {
        localSystemPointer = __RTCastToVoid(pbufferBaseAddress);
        (**(code **)(*pbufferBaseAddress + 0x28))(pbufferBaseAddress,0);
        if (localSystemPointer != 0) {
            SystemCleanupFunction(localSystemPointer);
        }
      }
      *(void* *)(localDataIndex + *PrimaryResourcePointer) = 0;
      systemFlag = systemFlag + 1;
      localDataIndex = localDataIndex + 8;
      localSystemPointer = *PrimaryResourcePointer;
    } while ((ulong long)(long long)systemFlag < (ulong long)(*(long long *)(ResourceManagerPointer + 0x10) - localSystemPointer >> 3));
  }
  systemFlag = 0;
  localSystemPointer = *resourcePoolPointer;
  if (*(long long *)(ResourceManagerPointer + 0x30) - localSystemPointer >> 3 != 0) {
    localDataIndex = 0;
    do {
      pbufferBaseAddress = *(long long **)(localSystemPointer + localDataIndex);
      if (pbufferBaseAddress != (long long *)0x0) {
        localSystemPointer = __RTCastToVoid(pbufferBaseAddress);
        (**(code **)(*pbufferBaseAddress + 0x28))(pbufferBaseAddress,0);
        if (localSystemPointer != 0) {
            SystemCleanupFunction(localSystemPointer);
        }
      }
      *(void* *)(localDataIndex + *resourcePoolPointer) = 0;
      systemFlag = systemFlag + 1;
      localDataIndex = localDataIndex + 8;
      localSystemPointer = *resourcePoolPointer;
    } while ((ulong long)(long long)systemFlag < (ulong long)(*(long long *)(ResourceManagerPointer + 0x30) - localSystemPointer >> 3));
  }
  systemFlag = 0;
  localSystemPointer = *plocalResourceOffset;
  if (*(long long *)(ResourceManagerPointer + 0x50) - localSystemPointer >> 3 != 0) {
    localDataIndex = 0;
    do {
      pbufferBaseAddress = *(long long **)(localSystemPointer + localDataIndex);
      if (pbufferBaseAddress != (long long *)0x0) {
        localSystemPointer = __RTCastToVoid(pbufferBaseAddress);
        (**(code **)(*pbufferBaseAddress + 0x28))(pbufferBaseAddress,0);
        if (localSystemPointer != 0) {
            SystemCleanupFunction(localSystemPointer);
        }
      }
      *(void* *)(localDataIndex + *plocalResourceOffset) = 0;
      systemFlag = systemFlag + 1;
      localDataIndex = localDataIndex + 8;
      localSystemPointer = *plocalResourceOffset;
    } while ((ulong long)(long long)systemFlag < (ulong long)(*(long long *)(ResourceManagerPointer + 0x50) - localSystemPointer >> 3));
  }
  SuspendSystemThreads(ResourceManagerPointer + 0x548);
  SuspendSystemThreads(ResourceManagerPointer + 0x2e0);
  SuspendSystemThreads(ResourceManagerPointer + 0x78);
  CloseHandle(*(void* *)(ResourceManagerPointer + 0x70));
  CloseHandle(*(void* *)(ResourceManagerPointer + 0x68));
  if (*plocalResourceOffset != 0) {
      SystemCleanupFunction();
  }
  if (*resourcePoolPointer != 0) {
      SystemCleanupFunction();
  }
  if (*PrimaryResourcePointer != 0) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: void ProcessSystemResourceThreadManagement(long long ResourceManagerPointer)
/**
 * @brief 处理系统资源线程管理
 * 
 * 该函数负责处理系统资源的线程管理，包括线程计数、线程句柄管理
 * 以及线程资源的分配和释放操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 */
void ProcessSystemResourceThreadManagement(long long ResourceManagerPointer)

{
  long long ThreadHandlePointer;
  long long CurrentThreadHandle;
  int ThreadCount;
  long long ThreadIndex;
  
  CurrentThreadHandle = GetCurrentThread();
  ThreadCount = (int)(*(long long *)(ResourceManagerPointer + 0x10) - *(long long *)(ResourceManagerPointer + 8) >> 3);
  if (0 < ThreadCount) {
    ThreadIndex = 0;
    do {
      ThreadHandlePointer = *(long long *)(*(long long *)(*(long long *)(ResourceManagerPointer + 8) + ThreadIndex * 8) + 0x40);
      if ((ThreadHandlePointer != 0) && (ThreadHandlePointer != CurrentThreadHandle)) {
        SuspendThread();
      }
      ThreadIndex = ThreadIndex + 1;
    } while (ThreadIndex < ThreadCount);
  }
  return;
}




// 函数: void GlobalThreadManager(void)
/**
 * @brief 全局线程管理器
 * 
 * 该函数负责全局线程管理，遍历所有线程并挂起非当前线程
 * 用于系统级别的线程控制和资源管理
 * 
 */
void GlobalThreadManager(void)

{
  long long ThreadHandlePointer;
  long long ThreadIndex;
  long long StackFramePointer;
  long long StringIteratorPtr;
  long long DataIndexPtr;
  
  ThreadIndex = 0;
  do {
    ThreadHandlePointer = *(long long *)(*(long long *)(*(long long )(StringIteratorPtr + 8) + ThreadIndex * 8) + 0x40);
    if ((ThreadHandlePointer != 0) && (ThreadHandlePointer != StackFramePointer)) {
      SuspendThread();
    }
    ThreadIndex = ThreadIndex + 1;
  } while (ThreadIndex < DataIndexPtr);
  return;
}




// 函数: void SystemNoOperationC(void)
/**
 * @brief 系统空操作函数C
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 * 原始函数名为FUN_18005db19，现已重命名为SystemNoOperationC
 */
void SystemNoOperationC(void)

{
  return;
}




/**
 * @brief 系统线程恢复函数
 * 
 * 该函数负责恢复系统中暂停的线程，遍历线程池并恢复所有非当前线程的线程
 * 用于系统线程管理和调度
 * 
 * @param ResourceManagerPointer 系统资源指针，包含线程池信息
 * 
 * 原始函数名为FUN_18005db30，现已重命名为ResumeSystemThreads
 */
void ResumeSystemThreads(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  int MemoryComparisonResult;
  long long bufferBaseAddress;
  
  localSystemHandle = GetCurrentThread();
  systemCounter = (int)(*(long long *)(ResourceManagerPointer + 0x10) - *(long long *)(ResourceManagerPointer + 8) >> 3);
  if (0 < systemCounter) {
    bufferBaseAddress = 0;
    do {
      nextDataIndex = *(long long *)(*(long long *)(*(long long *)(ResourceManagerPointer + 8) + bufferBaseAddress * 8) + 0x40);
      if ((nextDataIndex != 0) && (nextDataIndex != localSystemHandle)) {
        ResumeThread();
      }
      bufferBaseAddress = bufferBaseAddress + 1;
    } while (bufferBaseAddress < systemCounter);
  }
  return;
}




/**
 * @brief 系统线程恢复函数B
 * 
 * 该函数负责恢复系统中暂停的线程，遍历线程池并恢复所有非指定线程的线程
 * 用于系统线程管理和调度
 * 
 * @note 这是一个系统线程恢复函数，使用寄存器变量进行线程管理
 * 
 * 原始函数名为FUN_18005db5e，现已重命名为ResumeSystemThreadsB
 */
void ResumeSystemThreadsB(void)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long systemStackFramePtr;
  long long systemStringIteratorPtr;
  long long systemDataIndexPtr;
  
  localSystemHandle = 0;
  do {
    nextDataIndex = *(long long *)(*(long long *)(*(long long *)(systemStringIteratorPtr + 8) + localSystemHandle * 8) + 0x40);
    if ((nextDataIndex != 0) && (nextDataIndex != systemStackFramePtr)) {
      ResumeThread();
    }
    localSystemHandle = localSystemHandle + 1;
  } while (localSystemHandle < systemDataIndexPtr);
  return;
}




/**
 * @brief 系统空操作函数D
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 * 原始函数名为FUN_18005db99，现已重命名为SystemNoOperationD
 */
void SystemNoOperationD(void)

{
  return;
}





// 函数: void InitializeAndConfigureSystemResources(void)
/**
 * @brief 系统资源初始化和配置函数
 * 
 * 该函数负责初始化系统资源并进行配置，包括内存分配、缓冲区设置
 * 和系统参数配置等操作
 * 
 */
void InitializeAndConfigureSystemResources(void)

{
  long long *PrimaryResourcePointer;
  int SystemResult;
  void* SystemValue3;
  void* *SystemValue4Pointer;
  long long SystemTimeValue;
  long long DataPointer;
  ulong long SystemValue8;
  ulong long SystemValue9;
  long long AllocationFlags;
  long long MemoryPointer1;
  int SystemStatus2;
  uint SystemValue13;
  ulong long SystemValue14;
  void* **SystemValue15Pointer;
  uint8_t StackBuffer1b8 [32];
  long long StackValue198;
  long long StackValue190;
  long long StackValue188;
  long long StackValue178;
  void* **StackPointer170;
  void* StackValue168;
  void* *StackPointer160;
  uint8_t *StackPointer158;
  uint StackValue150;
  uint8_t StackBuffer148 [16];
  void* *SystemMemoryContext;
  uint8_t *StackPointer130;
  uint32_t StackValue128;
  uint8_t StackBuffer120 [24];
  void* *StackBuffer108 [19];
  int StackValue70;
  void* StackValue58;
  char StackBuffer48 [16];
  ulong long StackValue38;
  long long SystemFlags;
  
  AllocationFlags = SystemAllocationFlagsTemplate;
  StackValue168 = 0xfffffffffffffffe;
  StackValue38 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer1b8;
  StackValue178 = SystemAllocationFlagsTemplate;
  InitializeSystemBuffer(StackBuffer108);
  SystemStatus2 = StackValue70 + -1;
  if (*(int *)(AllocationFlags + 0x7b4) < StackValue70 + -1) {
    SystemStatus2 = *(int *)(AllocationFlags + 0x7b4);
  }
  SystemResult = 3;
  if (3 < SystemStatus2) {
    SystemResult = SystemStatus2;
  }
  SystemValue15Pointer = (void* **)(AllocationFlags + 8);
  MemoryPointer1 = (long long)SystemResult;
  StackPointer170 = SystemValue15Pointer;
  ResizeSystemMemoryPool(SystemValue15Pointer,MemoryPointer1);
  allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  unsignedSystemValue9 = 0;
  puStack_160 = &SystemResourceTemplateSecondary;
  puStack_158 = auStack_148;
  auStack_148[0] = 0;
  uStack_150 = 4;
  strcpy_s(auStack_148,0x10,&SystemStringData1);
  lStack_198 = allocationFlags + 0x78;
  lStack_190 = allocationFlags + 0x548;
  lStack_188 = allocationFlags + 0x68;
  allocationContext = ProcessSystemResources(allocationContext,&puStack_160,0,0);
  *(void* *)*pThreadLocalStorageEntry = allocationContext;
  puStack_160 = &SystemMemoryAllocatorReference;
  punsignedSystemValue4 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  systemMemoryContext = &SystemResourceTemplateSecondary;
  puStack_130 = auStack_120;
  auStack_120[0] = 0;
  uStack_128 = 6;
  processFlags58 = punsignedSystemValue4;
  strcpy_s(auStack_120,0x10,&SystemStringData2);
  lStack_198 = allocationFlags + 0x78;
  lStack_190 = allocationFlags + 0x548;
  lStack_188 = allocationFlags + 0x68;
  InitializeSystemMemoryContext(punsignedSystemValue4,&systemMemoryContext,1);
  *punsignedSystemValue4 = &SystemStringFormatTemplateA;
  *(void* **)((long long)*pThreadLocalStorageEntry + 8) = punsignedSystemValue4;
  systemMemoryContext = &SystemMemoryAllocatorReference;
  systemStatus2 = 2;
  *(uint32_t *)(lStack_178 + 0x7b0) = 2;
  if (2 < nextDataIndex1) {
    allocationFlags = 2;
    do {
      puStack_160 = &SystemResourceTemplateSecondary;
      puStack_158 = auStack_148;
      auStack_148[0] = 0;
      uStack_150 = 7;
      strcpy_s(auStack_148,0x10,&SystemVersionStringA);
      InitializeProcessSystem(&processFlags58,&SystemDataBufferTemplateI,systemStatus2 + -1);
      localSystemFlags = -1;
      do {
        localSystemPointer = localSystemFlags + 1;
        localDataIndex = localSystemFlags + 1;
        localSystemFlags = localSystemPointer;
      } while (*(char*)((long long)&processFlags58 + localDataIndex) != '\0');
      systemResult = (int)localSystemPointer;
      if ((0 < systemResult) && (uStack_150 + systemResult < 0xf)) {
          memcpy(puStack_158 + uStack_150,&processFlags58,(long long)(systemResult + 1));
      }
      allocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
      lStack_188 = lStack_178 + 0x68;
      lStack_190 = lStack_178 + 0x548;
      lStack_198 = lStack_178 + 0x78;
      allocationContext = ExtendSystemMemoryContext(allocationContext,&puStack_160,2,systemStatus2);
      *(void* *)((long long)*pThreadLocalStorageEntry + allocationFlags * 8) = allocationContext;
      puStack_160 = &SystemMemoryAllocatorReference;
      systemStatus2 = systemStatus2 + 1;
      allocationFlags = allocationFlags + 1;
    } while (allocationFlags < nextDataIndex1);
  }
  allocationFlags = lStack_178;
  systemResult = (int)(iStack_70 + (iStack_70 >> 0x1f & 3U)) >> 2;
  systemStatus2 = 2;
  if ((1 < systemResult) && (systemStatus2 = systemResult, 4 < systemResult)) {
    systemStatus2 = 4;
  }
  PrimaryResourcePointer = (long long *)(lStack_178 + 0x28);
  nextDataIndex1 = (long long)systemStatus2;
  ResizeSystemMemoryPool(PrimaryResourcePointer,nextDataIndex1);
  if (0 < nextDataIndex1) {
    unsignedSystemValue8 = unsignedSystemValue9;
    systemStatus4 = unsignedSystemValue9;
    do {
      puStack_160 = &SystemResourceTemplateSecondary;
      puStack_158 = auStack_148;
      auStack_148[0] = 0;
      uStack_150 = 10;
      strcpy_s(auStack_148,0x10,&SystemVersionStringB);
      InitializeProcessSystem(arrayChar48,&SystemDataBufferTemplateI,unsignedSystemValue8);
      localSystemFlags = -1;
      do {
        localDataIndex = localSystemFlags;
        localSystemFlags = localDataIndex + 1;
      } while (arrayChar48[localDataIndex + 1] != '\0');
      systemStatus2 = (int)(localDataIndex + 1);
      if ((0 < systemStatus2) && (uStack_150 + systemStatus2 < 0xf)) {
          memcpy(puStack_158 + uStack_150,arrayChar48,(long long)((int)localDataIndex + 2));
      }
      punsignedSystemValue4 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
      lStack_198 = allocationFlags + 0x70;
      processFlags58 = punsignedSystemValue4;
      InitializeSystemMemoryContext(punsignedSystemValue4,&puStack_160,4,lStack_178 + 0x2e0);
      *punsignedSystemValue4 = &SystemFunctionPointerA;
      *(void* **)(*PrimaryResourcePointer + systemStatus4 * 8) = punsignedSystemValue4;
      puStack_160 = &SystemMemoryAllocatorReference;
      unsignedSystemValue8 = (ulong long)((int)unsignedSystemValue8 + 1);
      systemStatus4 = systemStatus4 + 1;
      pThreadLocalStorageEntry = ppuStack_170;
    } while ((long long)systemStatus4 < nextDataIndex1);
  }
  unsignedSystemValue8 = unsignedSystemValue9;
  systemStatus4 = unsignedSystemValue9;
  if (((long long *)pThreadLocalStorageEntry)[1] - (long long)*pThreadLocalStorageEntry >> 3 != 0) {
    do {
      ProcessSystemResource(*(void* *)((long long)*pThreadLocalStorageEntry + unsignedSystemValue8));
      systemStatus3 = (int)systemStatus4 + 1;
      unsignedSystemValue8 = unsignedSystemValue8 + 8;
      systemStatus4 = (ulong long)systemStatus3;
    } while ((ulong long)(long long)(int)systemStatus3 <
             (ulong long)(((long long *)pThreadLocalStorageEntry)[1] - (long long)*pThreadLocalStorageEntry >> 3));
  }
  unsignedSystemValue8 = unsignedSystemValue9;
  if (*(long long *)(allocationFlags + 0x30) - *PrimaryResourcePointer >> 3 != 0) {
    do {
      ProcessPrimarySystemResource(*(void* *)(*PrimaryResourcePointer + unsignedSystemValue9));
      systemStatus3 = (int)unsignedSystemValue8 + 1;
      unsignedSystemValue9 = unsignedSystemValue9 + 8;
      unsignedSystemValue8 = (ulong long)systemStatus3;
    } while ((ulong long)(long long)(int)systemStatus3 <
             (ulong long)(*(long long *)(allocationFlags + 0x30) - *PrimaryResourcePointer >> 3));
  }
  ppuStack_170 = apunsignedValue108;
  apunsignedValue108[0] = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(uStack_38 ^ (ulong long)auStack_1b8);
}





/**
 * @brief 处理系统资源信号量和配置数据
 * 
 * 该函数负责处理系统资源的信号量操作，并根据线程本地存储的状态
 * 选择不同的资源处理路径，包括资源偏移处理和缓冲区配置
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005e110，现已重命名为ProcessSystemResourceSemaphore
 */
void ProcessSystemResourceSemaphore(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint ThreadLocalStorageIndex;
  int SemaphoreReleaseResult;
  long long ResourceOffset;
  long long BufferAddress;
  void* ConfigurationMask;
  
  ConfigurationMask = (void*)0xfffffffffffffffe;
  (**(code **)(*(long long *)*ConfigurationDataPointer + 0x78))();
  ThreadLocalStorageIndex = *(uint *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8)
                   + 0xc);
  if (ThreadLocalStorageIndex == 0xffffffff) {
    ResourceOffset = GetResourceOffsetHandler(ResourceManagerPointer + 0x78);
    if (ResourceOffset != 0) {
      ProcessResourceConfiguration(ResourceOffset,ConfigurationDataPointer);
    }
  }
  else {
    ResourceOffset = *(long long *)(*(long long *)(*(long long *)(ResourceManagerPointer + 8) + (ulong long)ThreadLocalStorageIndex * 8) + 0x70);
    BufferAddress = ResourceOffset + -8;
    if (ResourceOffset == 0) {
      BufferAddress = 0;
    }
    ConfigureSystemBuffer(BufferAddress,ConfigurationDataPointer,(ulong long)__tls_index,ConfigurationFlag,ConfigurationMask);
  }
  do {
    SemaphoreReleaseResult = ReleaseSemaphore(*(void* *)(ResourceManagerPointer + 0x68),1);
  } while (SemaphoreReleaseResult == 0);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 处理扩展系统资源信号量
 * 
 * 该函数负责处理扩展系统资源的信号量操作，处理特定的系统句柄
 * 并释放相关资源，适用于更复杂的系统资源管理场景
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005e1d0，现已重命名为ProcessExtendedSystemResourceSemaphore
 */
void ProcessExtendedSystemResourceSemaphore(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemStatus;
  long long SystemHandle;
  void* ConfigurationMask;
  
  ConfigurationMask = (void*)0xfffffffffffffffe;
  (**(code **)(*(long long *)*ConfigurationDataPointer + 0x78))();
  SystemHandle = GetResourceOffsetHandler(ResourceManagerPointer + 0x548);
  if (SystemHandle != 0) {
    ProcessResourceConfiguration(SystemHandle,ConfigurationDataPointer);
  }
  do {
    SystemStatus = ReleaseSemaphore(*(void* *)(ResourceManagerPointer + 0x68),1,0,ConfigurationFlag,ConfigurationMask);
  } while (SystemStatus == 0);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}





/**
 * @brief 处理带整型参数的系统资源
 * 
 * 该函数负责处理带整型参数的系统资源操作，根据线程本地存储状态
 * 选择不同的资源处理路径，适用于需要整型参数的资源管理场景
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 整型额外参数
 * 
 * 原始函数名为FUN_18005e250，现已重命名为ProcessSystemResourceWithIntParameter
 */
void ProcessSystemResourceWithIntParameter(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)

{
  uint ThreadLocalStorageIndex;
  int SystemResult;
  long long ResourceOffset;
  long long BufferAddress;
  
  ThreadLocalStorageIndex = *(uint *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8)
                   + 0xc);
  if (ThreadLocalStorageIndex == 0xffffffff) {
    ResourceOffset = GetResourceOffsetHandler(ResourceManagerPointer + 0x78);
    if (ResourceOffset != 0) {
      ProcessResourceWithParameter(ResourceOffset,ConfigurationDataPointer,(long long)AdditionalParameter);
    }
  }
  else {
    ResourceOffset = *(long long *)(*(long long *)(*(long long *)(ResourceManagerPointer + 8) + (ulong long)ThreadLocalStorageIndex * 8) + 0x70);
    BufferAddress = ResourceOffset + -8;
    if (ResourceOffset == 0) {
      BufferAddress = 0;
    }
    ConfigureBufferWithParameter(BufferAddress,ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  do {
    SystemResult = ReleaseSemaphore(*(void* *)(ResourceManagerPointer + 0x68),AdditionalParameter,0);
  } while (SystemResult == 0);
  return;
}




// 函数: void SystemManagerInitialize(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void SystemManagerInitialize(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = (void* *)**(void* **)(ResourceManagerPointer + 8);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)*ConfigurationDataPointer;
  plStackX_10 = ConfigurationDataPointer;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  (*stringProcessingPointer)(pointerToUnsigned1,&plStackX_8,AdditionalParameter,ConfigurationFlag,allocationContext);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




// 函数: void SetupMemoryAllocationContext(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void SetupMemoryAllocationContext(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = *(void* **)(*(long long *)(ResourceManagerPointer + 8) + 8);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)*ConfigurationDataPointer;
  plStackX_10 = ConfigurationDataPointer;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  (*stringProcessingPointer)(pointerToUnsigned1,&plStackX_8,AdditionalParameter,ConfigurationFlag,allocationContext);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 初始化系统资源配置
 * 
 * 该函数负责初始化系统资源配置，设置系统参数和属性
 * 用于系统资源管理的前期准备工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005e3e0，现已重命名为InitializeSystemResourceConfiguration
 */
void InitializeSystemResourceConfiguration(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *systemResourcePointer;
  code *systemCodePointer;
  long long *configurationDataPointer;
  long long *configurationDataBackup;
  long long **configurationDataRef;
  void* systemConfigurationFlag;
  
  systemConfigurationFlag = 0xfffffffffffffffe;
  systemResourcePointer = *(void* **)(*(long long *)(ResourceManagerPointer + 8) + 0x10);
  systemCodePointer = *(code **)*systemResourcePointer;
  configurationDataRef = &configurationDataPointer;
  configurationDataPointer = (long long *)*ConfigurationDataPointer;
  configurationDataBackup = ConfigurationDataPointer;
  if (configurationDataPointer != (long long *)0x0) {
    (**(code **)(*configurationDataPointer + 0x28))();
  }
  (*systemCodePointer)(systemResourcePointer,&configurationDataPointer,AdditionalParameter,ConfigurationFlag,systemConfigurationFlag);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 释放系统资源信号量
 * 
 * 该函数负责释放系统资源信号量，清理系统资源和同步对象
 * 用于系统资源管理的清理工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18005e450，现已重命名为ReleaseSystemResourceSemaphore
 */
void ReleaseSystemResourceSemaphore(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  long long systemHandle;
  void* systemConfigurationFlag;
  
  systemConfigurationFlag = 0xfffffffffffffffe;
  (**(code **)(*(long long *)*ConfigurationDataPointer + 0x78))();
  systemHandle = CreateSystemResourceHandle(ResourceManagerPointer + 0x2e0);
  if (systemHandle != 0) {
    ConfigureSystemResourceHandle(systemHandle,ConfigurationDataPointer);
  }
  do {
    systemStatus = ReleaseSemaphore(*(void* *)(ResourceManagerPointer + 0x70),1,0,ConfigurationFlag,systemConfigurationFlag);
  } while (systemStatus == 0);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 创建系统资源句柄
 * 
 * 该函数负责创建系统资源句柄，分配内存并初始化系统上下文
 * 用于系统资源管理的前期准备工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源句柄指针
 * 
 * 原始函数名为FUN_18005e4d0，现已重命名为CreateSystemResourceHandle
 */
void* * CreateSystemResourceHandle(long long ResourceManagerPointer,void* ConfigurationDataPointer)

{
  void* *systemResourceHandle;
  void* *systemHandleRef;
  
  systemResourceHandle = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  systemHandleRef = systemResourceHandle;
  InitializeSystemMemoryContext(systemResourceHandle,ConfigurationDataPointer,3,ResourceManagerPointer + 0x2e0,ResourceManagerPointer + 0x70);
  *systemResourceHandle = &SystemValueReference;
  systemHandleRef = systemResourceHandle;
  ProcessSystemResourceHandle(systemResourceHandle);
  InitializeSystemHandle(ResourceManagerPointer + 0x48,&systemHandleRef);
  return systemResourceHandle;
}




/**
 * @brief 释放系统资源句柄
 * 
 * 该函数负责释放系统资源句柄，清理系统资源和内存
 * 用于系统资源管理的清理工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为ReleaseSystemResourceHandle，已优化变量命名
 */
void ReleaseSystemResourceHandle(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long *primaryResourcePointer;
  ulong long systemResourceSize;
  long long resourceOffset;
  long long* systemMemoryPointer;
  int resourceIndex;
  ulong long resourceCount;
  
  resourceIndex = 0;
  primaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x48);
  resourceCount = *(long long *)(ResourceManagerPointer + 0x50) - (long long)primaryResourcePointer >> 3;
  systemMemoryPointer = primaryResourcePointer;
  if (resourceCount != 0) {
    do {
      if ((long long *)*systemMemoryPointer == ConfigurationDataPointer) {
        ReleaseSystemResource(primaryResourcePointer[resourceIndex]);
        systemResourceSize = *(ulong long *)(ResourceManagerPointer + 0x50);
        resourceOffset = *(long long *)(ResourceManagerPointer + 0x48) + (long long)resourceIndex * 8;
        resourceCount = resourceOffset + 8;
        if (resourceCount < systemResourceSize) {
            memmove(resourceOffset,resourceCount,systemResourceSize - resourceCount);
        }
        *(ulong long *)(ResourceManagerPointer + 0x50) = systemResourceSize - 8;
        break;
      }
      resourceIndex = resourceIndex + 1;
      systemMemoryPointer = systemMemoryPointer + 1;
    } while ((ulong long)(long long)resourceIndex < resourceCount);
  }
  if (ConfigurationDataPointer != (long long *)0x0) {
    resourceOffset = __RTCastToVoid(ConfigurationDataPointer);
    (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer,0);
    if (resourceOffset != 0) {
        SystemCleanupFunction(resourceOffset);
    }
  }
  return;
}




/**
 * @brief 清理系统资源配置
 * 
 * 该函数负责清理系统资源配置，释放相关资源和内存
 * 用于系统资源管理的清理工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_18005e57a，现已重命名为CleanupSystemResourceConfiguration
 */
void CleanupSystemResourceConfiguration(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long *primaryResourcePointer;
  ulong long systemResourceSize;
  long long resourceOffset;
  long long* systemMemoryPointer;
  int resourceIndex;
  ulong long resourceCount;
  
  resourceIndex = 0;
  primaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x48);
  resourceCount = *(long long *)(ResourceManagerPointer + 0x50) - (long long)primaryResourcePointer >> 3;
  systemMemoryPointer = primaryResourcePointer;
  if (resourceCount != 0) {
    do {
      if ((long long *)*systemMemoryPointer == ConfigurationDataPointer) {
        ReleaseSystemResource(primaryResourcePointer[resourceIndex]);
        systemResourceSize = *(ulong long *)(ResourceManagerPointer + 0x50);
        resourceOffset = *(long long *)(ResourceManagerPointer + 0x48) + (long long)resourceIndex * 8;
        resourceCount = resourceOffset + 8;
        if (resourceCount < systemResourceSize) {
            memmove(resourceOffset,resourceCount,systemResourceSize - resourceCount);
        }
        *(ulong long *)(ResourceManagerPointer + 0x50) = systemResourceSize - 8;
        break;
      }
      resourceIndex = resourceIndex + 1;
      systemMemoryPointer = systemMemoryPointer + 1;
    } while ((ulong long)(long long)resourceIndex < resourceCount);
  }
  if (ConfigurationDataPointer != (long long *)0x0) {
    resourceOffset = __RTCastToVoid(ConfigurationDataPointer);
    (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer,0);
    if (resourceOffset != 0) {
        SystemCleanupFunction(resourceOffset);
    }
  }
  return;
}




/**
 * @brief 清理系统数据索引
 * 
 * 该函数负责清理系统数据索引，释放相关内存资源
 * 用于系统数据管理的清理工作
 * 
 * 原始函数名为FUN_18005e5ff，现已重命名为CleanupSystemDataIndex
 */
void CleanupSystemDataIndex(void)

{
  long long memoryPointer;
  long long *systemDataIndexPointer;
  
  memoryPointer = __RTCastToVoid();
  (**(code **)(*systemDataIndexPointer + 0x28))();
  if (memoryPointer != 0) {
      SystemCleanupFunction(memoryPointer);
  }
  return;
}





/**
 * @brief 处理系统纹理管理器锁操作
 * 
 * 该函数负责处理系统纹理管理器的锁操作，包括获取锁和释放锁。
 * 用于同步纹理管理器的访问，确保线程安全。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含纹理管理器信息
 * 
 * 原始函数名为FUN_18005e630，现已重命名为ProcessSystemTextureManagerLock
 */
void ProcessSystemTextureManagerLock(long long ResourceManagerPointer)

{
  int systemStatus;
  long long localSystemHandle;
  
  ProcessSystemCallback(*(void* *)(*(long long *)(ResourceManagerPointer + 8) + 8));
  localSystemHandle = SystemTextureManagerPointer + 0x20;
  systemStatus = _Mtx_lock(localSystemHandle);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  systemStatus = _Mtx_unlock(localSystemHandle);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
    return;
  }
  return;
}




// 函数: void InitializeSystemMemoryContext(void* ResourceManagerPointer,long long *ConfigurationDataPointer,uint8_t AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemMemoryContext(void* ResourceManagerPointer,long long *ConfigurationDataPointer,uint8_t AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  long long *resourcePoolPointer;
  char characterProcessingFlag;
  void* unsignedSystemValue4;
  
  unsignedSystemValue4 = 0xfffffffffffffffe;
  while( true ) {
    systemFunctionPointer = *(code **)(*(long long *)*ConfigurationDataPointer + 0x68);
    if (systemFunctionPointer == (code *)&SystemFunctionPointer1) {
      characterProcessingFlag = (char)((long long *)*ConfigurationDataPointer)[2] != '\0';
    }
    else {
      characterProcessingFlag = (*systemFunctionPointer)();
    }
    if (characterProcessingFlag != '\0') break;
    resourcePoolPointer = (long long *)AllocateResourceManagerPointer(ResourceManagerPointer);
    characterProcessingFlag = (**(code **)(*resourcePoolPointer + 0x20))(resourcePoolPointer,AdditionalParameter,*(code **)(*resourcePoolPointer + 0x20),ConfigurationFlag,unsignedSystemValue4);
    if (characterProcessingFlag == '\0') {
      systemFunctionPointer = *(code **)(*(long long *)*ConfigurationDataPointer + 0x80);
      if (systemFunctionPointer == (code *)&SystemFunctionPointer2) {
        ProcessConfigurationData((long long *)*ConfigurationDataPointer + 4);
      }
      else {
        (*systemFunctionPointer)();
      }
    }
  }
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 处理系统资源分配和回调执行
 * 
 * 该函数负责处理系统资源的分配、回调函数的执行和资源管理。
 * 根据不同的系统标志和配置数据，执行相应的资源分配和回调操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数，控制回调处理方式
 * 
 * 原始函数名为FUN_18005e770，现已重命名为ProcessSystemResourceAllocationAndCallback
 */
void ProcessSystemResourceAllocationAndCallback(void* ResourceManagerPointer,long long *ConfigurationDataPointer,char AdditionalParameter)

{
  code *systemFunctionPointer;
  bool isSystemActive;
  long long *plocalResourceOffset;
  ulong long unsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  char resourceStatusFlag;
  
  localSystemFlags = ConfigurationDataPointer[1];
  localSystemPointer = *ConfigurationDataPointer;
  do {
    isSystemActive = false;
    unsignedSystemValue4 = 0;
    if (localSystemFlags - localSystemPointer >> 3 == 0) {
      return;
    }
    do {
      plocalResourceOffset = *(long long **)(unsignedSystemValue4 * 8 + localSystemPointer);
      systemFunctionPointer = *(code **)(*plocalResourceOffset + 0x68);
      if (systemFunctionPointer == (code *)&SystemFunctionPointer1) {
        resourceStatusFlag = (char)plocalResourceOffset[2] != '\0';
      }
      else {
        resourceStatusFlag = (*systemFunctionPointer)();
      }
      if (resourceStatusFlag == '\0') {
        isSystemActive = true;
        plocalResourceOffset = (long long *)AllocateResourceManagerPointer(ResourceManagerPointer);
        if (AdditionalParameter == '\0') {
          resourceStatusFlag = (**(code **)(*plocalResourceOffset + 0x20))(plocalResourceOffset,0);
        }
        else {
          resourceStatusFlag = GetSystemStatusValue();
        }
        if (resourceStatusFlag == '\0') {
          plocalResourceOffset = *(long long **)(unsignedSystemValue4 * 8 + *ConfigurationDataPointer);
          systemFunctionPointer = *(code **)(*plocalResourceOffset + 0x80);
          if (systemFunctionPointer == (code *)&SystemFunctionPointer2) {
            ProcessConfigurationData(plocalResourceOffset + 4);
          }
          else {
            (*systemFunctionPointer)();
          }
        }
      }
      localSystemFlags = ConfigurationDataPointer[1];
      unsignedSystemValue4 = (ulong long)((int)unsignedSystemValue4 + 1);
      localSystemPointer = *ConfigurationDataPointer;
    } while (unsignedSystemValue4 < (ulong long)(localSystemFlags - localSystemPointer >> 3));
  } while (isSystemActive);
  return;
}



long long AllocateResourceManagerPointer(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  int systemResult;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  
  unsignedSystemValue4 = 0;
  allocationContext = unsignedSystemValue4;
  if (*(long long *)(ResourceManagerPointer + 0x10) - *(long long *)(ResourceManagerPointer + 8) >> 3 != 0) {
    do {
      systemResult = _Thrd_id();
      nextDataIndex = *(long long *)(*(long long *)(ResourceManagerPointer + 8) + allocationContext * 8);
      if (*(int *)(nextDataIndex + 0x48) == systemResult) {
        return nextDataIndex;
      }
      allocationContext = (ulong long)((int)allocationContext + 1);
    } while (allocationContext < (ulong long)(*(long long *)(ResourceManagerPointer + 0x10) - *(long long *)(ResourceManagerPointer + 8) >> 3));
  }
  if (*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x28) >> 3 != 0) {
    do {
      systemResult = _Thrd_id();
      nextDataIndex = *(long long *)(*(long long *)(ResourceManagerPointer + 0x28) + unsignedSystemValue4 * 8);
      if (*(int *)(nextDataIndex + 0x48) == systemResult) {
        return nextDataIndex;
      }
      unsignedSystemValue4 = (ulong long)((int)unsignedSystemValue4 + 1);
    } while (unsignedSystemValue4 < (ulong long)(*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x28) >> 3)
            );
  }
  return 0;
}




/**
 * @brief 系统资源指针管理函数
 * 
 * 该函数负责管理系统资源指针，执行指针操作和资源管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 处理后的资源指针
 * 
 * 原始函数名为FUN_18005e950，现已重命名为ManageResourceManagerPointer
 */
void* * ManageResourceManagerPointer(void* *ResourceManagerPointer)

{
  void* resourceHandle;
  ulong long resourceIndex;
  void* *HashNodePointer;
  ulong long unsignedSystemValue4;
  ulong long currentThreadId;
  void** SystemRootNode;
  long long localDataIndex;
  long long localMemoryAddress;
  
  currentThreadId = 0;
  HashNodePointer = ResourceManagerPointer + 0xb;
  *ResourceManagerPointer = 0;
  localMemoryAddress = 0x20;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  ResourceManagerPointer[2] = 0;
  ResourceManagerPointer[5] = 0;
  localDataIndex = 0x20;
  resourceEntryPointer = HashNodePointer;
  do {
    SystemResourceCleanup(resourceEntryPointer);
    resourceEntryPointer = resourceEntryPointer + 2;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  *(void* *)((long long)ResourceManagerPointer + 0x25c) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x4b) = 0;
  ResourceManagerPointer[7] = 0;
  ResourceManagerPointer[8] = 0x20;
  ResourceManagerPointer[9] = HashNodePointer;
  do {
    *(uint32_t *)HashNodePointer = 0;
    systemStatus = SystemMemoryPoolTemplate;
    HashNodePointer = HashNodePointer + 2;
    localMemoryAddress = localMemoryAddress + -1;
  } while (localMemoryAddress != 0);
  localDataIndex = 6;
  ResourceManagerPointer[10] = 0;
  ResourceManagerPointer[6] = ResourceManagerPointer + 8;
  ResourceManagerPointer[4] = 6;
  creationFlags = CreateSystemThreadObject(systemStatus,0x7b0,10);
  unsignedSystemValue4 = currentThreadId;
  if (creationFlags != 0) {
    HashNodePointer = (void* *)(creationFlags + 0x108);
    do {
      HashNodePointer[-1] = 0;
      *HashNodePointer = 0;
      *(uint32_t *)(HashNodePointer + 5) = 0;
      HashNodePointer[6] = 0;
      *(void*2 *)(HashNodePointer + 7) = 0x100;
      HashNodePointer = HashNodePointer + 0x29;
      localDataIndex = localDataIndex + -1;
      unsignedSystemValue4 = creationFlags;
    } while (localDataIndex != 0);
  }
  ResourceManagerPointer[3] = unsignedSystemValue4;
  if (unsignedSystemValue4 == 0) {
    ResourceManagerPointer[4] = 0;
    unsignedSystemValue4 = currentThreadId;
  }
  else {
    unsignedSystemValue4 = ResourceManagerPointer[4];
  }
  creationFlags = currentThreadId;
  if (unsignedSystemValue4 != 0) {
    do {
      creationFlags = creationFlags + 1;
      *(uint8_t *)(currentThreadId + 0x141 + ResourceManagerPointer[3]) = 0;
      currentThreadId = currentThreadId + 0x148;
    } while (creationFlags < (ulong long)ResourceManagerPointer[4]);
  }
  return ResourceManagerPointer;
}





// 函数: void InitializeSystemHandle(ulong long *ResourceManagerPointer,void* *ConfigurationDataPointer)
void InitializeSystemHandle(ulong long *ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  long long nextDataIndex;
  void** SystemDataTable;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
  if (punsignedSystemValue4 < (void* *)ResourceManagerPointer[2]) {
    ResourceManagerPointer[1] = (ulong long)(punsignedSystemValue4 + 1);
    *punsignedSystemValue4 = *ConfigurationDataPointer;
    return;
  }
  HashNodePointer = (void* *)*ResourceManagerPointer;
  nextDataIndex = (long long)punsignedSystemValue4 - (long long)HashNodePointer >> 3;
  if (nextDataIndex == 0) {
    nextDataIndex = 1;
  }
  else {
    nextDataIndex = nextDataIndex * 2;
    if (nextDataIndex == 0) {
      HashEntryStatus = (void* *)0x0;
      goto SystemResourceExpansion;
    }
  }
  HashEntryStatus = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex * 8,(char)ResourceManagerPointer[3]);
  HashNodePointer = (void* *)*ResourceManagerPointer;
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
SystemResourceExpansion:
  if (HashNodePointer != punsignedSystemValue4) {
      memmove(HashEntryStatus,HashNodePointer,(long long)punsignedSystemValue4 - (long long)HashNodePointer);
  }
  *HashEntryStatus = *ConfigurationDataPointer;
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = (ulong long)HashEntryStatus;
  ResourceManagerPointer[1] = (ulong long)(HashEntryStatus + 1);
  ResourceManagerPointer[2] = (ulong long)(HashEntryStatus + nextDataIndex);
  return;
}




/**
 * @brief 查找线程本地存储资源
 * 
 * 该函数负责查找线程本地存储资源，通过线程ID哈希值在资源表中查找对应的资源。
 * 它会遍历资源节点，使用哈希算法快速定位线程特定的资源数据。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回找到的线程本地存储资源地址
 */
long long FindThreadLocalStorageResource(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  uint *HashEntryStatus;
  ulong long *HashNodePointer;
  ulong long unsignedSystemValue4;
  uint currentThreadId;
  ulong long hashValue;
  ulong long *HashBucketNode;
  long long localMemoryAddress;
  ulong long unsignedSystemValue9;
  ulong long systemOperationFlags;
  uint systemStatus1;
  bool isByteValid2;
  char acStackX_8 [16];
  
  currentThreadId = GetCurrentThreadId();
  systemStatus1 = (currentThreadId >> 0x10 ^ currentThreadId) * -0x7a143595;
  systemStatus1 = (systemStatus1 >> 0xd ^ systemStatus1) * -0x3d4d51cb;
  systemOperationFlags = (ulong long)(systemStatus1 >> 0x10 ^ systemStatus1);
  HashBucketNode = *(ulong long **)(ResourceManagerPointer + 0x30);
  for (HashNodePointer = HashBucketNode; hashValue = systemOperationFlags, HashNodePointer != (ulong long *)0x0; HashNodePointer = (ulong long *)HashNodePointer[2])
  {
    while( true ) {
      hashValue = hashValue & *HashNodePointer - 1;
      systemStatus1 = *(uint *)(hashValue * 0x10 + HashNodePointer[1]);
      if (systemStatus1 == currentThreadId) {
        localMemoryAddress = *(long long *)(HashNodePointer[1] + 8 + hashValue * 0x10);
        if (HashNodePointer == HashBucketNode) {
          return localMemoryAddress;
        }
        do {
          systemOperationFlags = systemOperationFlags & *HashBucketNode - 1;
          if (*(int *)(HashBucketNode[1] + systemOperationFlags * 0x10) == 0) {
            HashEntryStatus = (uint *)(HashBucketNode[1] + systemOperationFlags * 0x10);
            LOCK();
            isByteValid2 = *HashEntryStatus == 0;
            if (isByteValid2) {
              *HashEntryStatus = currentThreadId;
            }
            UNLOCK();
            if (isByteValid2) {
              *(long long *)(HashBucketNode[1] + 8 + systemOperationFlags * 0x10) = localMemoryAddress;
              return localMemoryAddress;
            }
          }
          systemOperationFlags = systemOperationFlags + 1;
        } while( true );
      }
      if (systemStatus1 == 0) break;
      hashValue = hashValue + 1;
    }
  }
  LOCK();
  PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x38);
  localMemoryAddress = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  hashValue = localMemoryAddress + 1;
  do {
    if (*HashBucketNode >> 1 <= hashValue) {
      LOCK();
      HashEntryStatus = (uint *)(ResourceManagerPointer + 600);
      systemStatus1 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus | 1;
      UNLOCK();
      if ((systemStatus1 & 1) == 0) {
        HashNodePointer = *(ulong long **)(ResourceManagerPointer + 0x30);
        HashBucketNode = HashNodePointer;
        unsignedSystemValue9 = *HashNodePointer;
        if (*HashNodePointer >> 1 <= hashValue) {
          do {
            unsignedSystemValue4 = unsignedSystemValue9;
            unsignedSystemValue9 = unsignedSystemValue4 * 2;
          } while ((unsignedSystemValue4 & 0x7fffffffffffffff) <= hashValue);
          HashBucketNode = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue4 * 0x20 + 0x1f,10);
          if (HashBucketNode == (ulong long *)0x0) {
            LOCK();
            *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + -1;
            UNLOCK();
            *(uint32_t *)(ResourceManagerPointer + 600) = 0;
            return 0;
          }
          *HashBucketNode = unsignedSystemValue9;
          HashBucketNode[1] = (ulong long)(-(int)(HashBucketNode + 3) & 7) + (long long)(HashBucketNode + 3);
          localMemoryAddress = 0;
          for (; unsignedSystemValue9 != 0; unsignedSystemValue9 = unsignedSystemValue9 - 1) {
            *(void* *)(localMemoryAddress + 8 + HashBucketNode[1]) = 0;
            *(uint32_t *)(localMemoryAddress + HashBucketNode[1]) = 0;
            localMemoryAddress = localMemoryAddress + 0x10;
          }
          HashBucketNode[2] = (ulong long)HashNodePointer;
          *(ulong long **)(ResourceManagerPointer + 0x30) = HashBucketNode;
        }
        *(uint32_t *)(ResourceManagerPointer + 600) = 0;
      }
    }
    if (hashValue < (*HashBucketNode >> 2) + (*HashBucketNode >> 1)) {
      localMemoryAddress = AllocateSystemMemory(ResourceManagerPointer,0,stackValue8);
      if (localMemoryAddress == 0) {
        LOCK();
        *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + -1;
        UNLOCK();
        return 0;
      }
      if (acStackX_8[0] != '\0') {
        LOCK();
        *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + -1;
        UNLOCK();
      }
      do {
        systemOperationFlags = systemOperationFlags & *HashBucketNode - 1;
        if (*(int *)(HashBucketNode[1] + systemOperationFlags * 0x10) == 0) {
          HashEntryStatus = (uint *)(HashBucketNode[1] + systemOperationFlags * 0x10);
          LOCK();
          isByteValid2 = *HashEntryStatus == 0;
          if (isByteValid2) {
            *HashEntryStatus = currentThreadId;
          }
          UNLOCK();
          if (isByteValid2) {
            *(long long *)(HashBucketNode[1] + 8 + systemOperationFlags * 0x10) = localMemoryAddress;
            return localMemoryAddress;
          }
        }
        systemOperationFlags = systemOperationFlags + 1;
      } while( true );
    }
    HashBucketNode = *(ulong long **)(ResourceManagerPointer + 0x30);
  } while( true );
}




/**
 * @brief 分配系统资源标识符
 * 
 * 该函数负责分配系统资源标识符，使用原子操作确保线程安全。
 * 它会递增资源计数器，并返回新的资源标识符。
 * 
 * @return 返回分配的系统资源标识符
 */
long long AllocateSystemResourceId(void)

{
  long long *PrimaryResourcePointer;
  uint *HashEntryStatus;
  int *pointerToInteger3;
  uint unsignedSystemValue4;
  ulong long *pcurrentThreadId;
  ulong long hashValue;
  long long localDataIndex;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  ulong long systemStringIteratorPtr;
  ulong long *systemDataIndexPtr;
  long long systemResourceCounter;
  int systemResourceHandleD;
  bool isByteValid0;
  char InputStackParameter50;
  
  LOCK();
  PrimaryResourcePointer = (long long *)(systemResourceCounter + 0x38);
  localDataIndex = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  unsignedSystemValue9 = localDataIndex + 1;
  while( true ) {
    if (*systemDataIndexPtr >> 1 <= unsignedSystemValue9) {
      LOCK();
      HashEntryStatus = (uint *)(systemResourceCounter + 600);
      unsignedSystemValue4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus | 1;
      UNLOCK();
      if ((unsignedSystemValue4 & 1) == 0) {
        pcurrentThreadId = *(ulong long **)(systemResourceCounter + 0x30);
        systemDataIndexPtr = pcurrentThreadId;
        unsignedSystemValue8 = *pcurrentThreadId;
        if (*pcurrentThreadId >> 1 <= unsignedSystemValue9) {
          do {
            hashValue = unsignedSystemValue8;
            unsignedSystemValue8 = hashValue * 2;
          } while ((hashValue & 0x7fffffffffffffff) <= unsignedSystemValue9);
          systemDataIndexPtr = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,hashValue * 0x20 + 0x1f,10);
          if (systemDataIndexPtr == (ulong long *)0x0) {
            LOCK();
            *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
            UNLOCK();
            *(uint32_t *)(systemResourceCounter + 600) = 0;
            return 0;
          }
          *systemDataIndexPtr = unsignedSystemValue8;
          systemDataIndexPtr[1] = (ulong long)(-(int)(systemDataIndexPtr + 3) & 7) + (long long)(systemDataIndexPtr + 3);
          localDataIndex = 0;
          for (; unsignedSystemValue8 != 0; unsignedSystemValue8 = unsignedSystemValue8 - 1) {
            *(void* *)(localDataIndex + 8 + systemDataIndexPtr[1]) = 0;
            *(uint32_t *)(localDataIndex + systemDataIndexPtr[1]) = 0;
            localDataIndex = localDataIndex + 0x10;
          }
          systemDataIndexPtr[2] = (ulong long)pcurrentThreadId;
          *(ulong long **)(systemResourceCounter + 0x30) = systemDataIndexPtr;
        }
        *(uint32_t *)(systemResourceCounter + 600) = 0;
      }
    }
    if (unsignedSystemValue9 < (*systemDataIndexPtr >> 2) + (*systemDataIndexPtr >> 1)) break;
    systemDataIndexPtr = *(ulong long **)(systemResourceCounter + 0x30);
  }
  localDataIndex = AllocateSystemMemory();
  if (localDataIndex == 0) {
    LOCK();
    *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
    UNLOCK();
    return 0;
  }
  if (InputStackParameter50 != '\0') {
    LOCK();
    *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
    UNLOCK();
  }
  do {
    unsignedSystemValue9 = systemStringIteratorPtr & *systemDataIndexPtr - 1;
    if (*(int *)(systemDataIndexPtr[1] + unsignedSystemValue9 * 0x10) == 0) {
      pointerToInteger3 = (int *)(systemDataIndexPtr[1] + unsignedSystemValue9 * 0x10);
      LOCK();
      isByteValid0 = *pointerToInteger3 == 0;
      if (isByteValid0) {
        *pointerToInteger3 = systemResourceHandleD;
      }
      UNLOCK();
      if (isByteValid0) {
        *(long long *)(systemDataIndexPtr[1] + 8 + unsignedSystemValue9 * 0x10) = localDataIndex;
        return localDataIndex;
      }
    }
    systemStringIteratorPtr = unsignedSystemValue9 + 1;
  } while( true );
}



/**
 * @brief 系统资源分配和数据处理函数
 * 
 * 该函数负责处理系统资源的分配和数据处理，包括内存管理、
 * 数据索引和资源分配池的管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @return 分配的资源指针
 * 
 * 原始函数名为FUN_18005ecfc，现已重命名为AllocateSystemResourceAndProcessData
 */
void* AllocateSystemResourceAndProcessData(void* ResourceManagerPointer,void* ConfigurationDataPointer,long long *AdditionalParameter)

{
  int *resourceStatusPtr;
  void* allocatedResource;
  long long resourceOffset;
  ulong long stringIterator;
  ulong long hashIndex;
  long long *dataIndexPtr;
  int resourceHandle;
  bool allocationSuccess;
  
  creationFlags = *(void* *)(AdditionalParameter[1] + 8 + in_RAX * 0x10);
  if (AdditionalParameter == systemDataIndexPtr) {
    return creationFlags;
  }
  do {
    allocationContext = systemStringIteratorPtr & *systemDataIndexPtr - 1U;
    if (*(int *)(systemDataIndexPtr[1] + allocationContext * 0x10) == 0) {
      pointerToInteger1 = (int *)(systemDataIndexPtr[1] + allocationContext * 0x10);
      LOCK();
      isResourceAvailable = *pointerToInteger1 == 0;
      if (isResourceAvailable) {
        *pointerToInteger1 = systemResourceHandleD;
      }
      UNLOCK();
      if (isResourceAvailable) {
        *(void* *)(systemDataIndexPtr[1] + 8 + allocationContext * 0x10) = creationFlags;
        return creationFlags;
      }
    }
    systemStringIteratorPtr = allocationContext + 1;
  } while( true );
}




/**
 * @brief 管理系统资源分配池
 * 
 * 该函数负责管理系统资源分配池，处理资源的分配和释放。
 * 它会检查资源池的状态，并根据需要调用资源分配函数。
 * 
 * @return 返回系统资源管理状态
 */
long long ManageSystemResourceAllocationPool(void)

{
  uint *pointerToUnsigned1;
  int *pointerToInteger2;
  uint allocationContext;
  ulong long *punsignedSystemValue4;
  ulong long currentThreadId;
  long long localSystemFlags;
  ulong long unsignedSystemValue7;
  ulong long systemStackFramePtr;
  ulong long systemStringIteratorPtr;
  ulong long *systemDataIndexPtr;
  uint32_t unsignedSystemValue8;
  long long systemAllocationOffset;
  long long systemResourceCounter;
  int systemResourceHandleD;
  bool isSystemBusy;
  char InputStackParameter50;
  
  while( true ) {
    do {
      unsignedSystemValue8 = (uint32_t)systemAllocationOffset;
      *(uint32_t *)(systemResourceCounter + 600) = unsignedSystemValue8;
      do {
        do {
          if (systemStackFramePtr < (*systemDataIndexPtr >> 2) + (*systemDataIndexPtr >> 1)) {
            localSystemFlags = AllocateSystemMemory();
            if (localSystemFlags == 0) {
              LOCK();
              *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
              UNLOCK();
              return 0;
            }
            if (InputStackParameter50 != (char)systemAllocationOffset) {
              LOCK();
              *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
              UNLOCK();
            }
            do {
              unsignedSystemValue7 = systemStringIteratorPtr & *systemDataIndexPtr - 1;
              if (*(int *)(systemDataIndexPtr[1] + unsignedSystemValue7 * 0x10) == 0) {
                pointerToInteger2 = (int *)(systemDataIndexPtr[1] + unsignedSystemValue7 * 0x10);
                LOCK();
                isSystemBusy = *pointerToInteger2 == 0;
                if (isSystemBusy) {
                  *pointerToInteger2 = systemResourceHandleD;
                }
                UNLOCK();
                if (isSystemBusy) {
                  *(long long *)(systemDataIndexPtr[1] + 8 + unsignedSystemValue7 * 0x10) = localSystemFlags;
                  return localSystemFlags;
                }
              }
              systemStringIteratorPtr = unsignedSystemValue7 + 1;
            } while( true );
          }
          systemDataIndexPtr = *(ulong long **)(systemResourceCounter + 0x30);
        } while (systemStackFramePtr < *systemDataIndexPtr >> 1);
        LOCK();
        pointerToUnsigned1 = (uint *)(systemResourceCounter + 600);
        allocationContext = *pointerToUnsigned1;
        *pointerToUnsigned1 = *pointerToUnsigned1 | 1;
        UNLOCK();
      } while ((allocationContext & 1) != 0);
      punsignedSystemValue4 = *(ulong long **)(systemResourceCounter + 0x30);
      systemDataIndexPtr = punsignedSystemValue4;
      unsignedSystemValue7 = *punsignedSystemValue4;
    } while (systemStackFramePtr < *punsignedSystemValue4 >> 1);
    do {
      currentThreadId = unsignedSystemValue7;
      unsignedSystemValue7 = currentThreadId * 2;
    } while ((currentThreadId & 0x7fffffffffffffff) <= systemStackFramePtr);
    systemDataIndexPtr = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId * 0x20 + 0x1f,10);
    if (systemDataIndexPtr == (ulong long *)0x0) break;
    *systemDataIndexPtr = unsignedSystemValue7;
    systemDataIndexPtr[1] = (ulong long)(-(int)(systemDataIndexPtr + 3) & 7) + (long long)(systemDataIndexPtr + 3);
    localSystemFlags = systemAllocationOffset;
    for (; unsignedSystemValue7 != 0; unsignedSystemValue7 = unsignedSystemValue7 - 1) {
      *(long long *)(localSystemFlags + 8 + systemDataIndexPtr[1]) = systemAllocationOffset;
      *(uint32_t *)(localSystemFlags + systemDataIndexPtr[1]) = unsignedSystemValue8;
      localSystemFlags = localSystemFlags + 0x10;
    }
    systemDataIndexPtr[2] = (ulong long)punsignedSystemValue4;
    *(ulong long **)(systemResourceCounter + 0x30) = systemDataIndexPtr;
  }
  LOCK();
  *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
  UNLOCK();
  *(uint32_t *)(systemResourceCounter + 600) = unsignedSystemValue8;
  return 0;
}




/**
 * @brief 创建和初始化系统线程对象
 * 
 * 该函数负责创建和初始化系统线程对象，根据不同的配置数据
 * 创建不同类型的线程对象，并进行相应的初始化设置。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针，决定创建的线程对象类型
 * @param AdditionalParameter 附加参数指针，用于返回创建状态
 * @return 创建的线程对象指针，创建失败时返回NULL
 * 
 * 原始函数名为FUN_18005ee30，现已重命名为CreateAndInitializeSystemThreadObject
 */
void* * CreateAndInitializeSystemThreadObject(long long *ResourceManagerPointer,char ConfigurationDataPointer,uint8_t *AdditionalParameter)

{
  long long *PrimaryResourcePointer;
  void** SystemDataTable;
  long long localResourceOffset;
  long long bufferBaseAddress;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  ulong long unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  bool isSystemBusy;
  
  resourceEntryPointer = (void* *)0x0;
  HashEntryStatus = (void* *)*ResourceManagerPointer;
  do {
    if (HashEntryStatus == (void* *)0x0) {
      *AdditionalParameter = 0;
      if (ConfigurationDataPointer == '\0') {
        HashEntryStatus = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,10,0,0xfffffffffffffffe);
        if (HashEntryStatus == (void* *)0x0) {
          return (void* *)0x0;
        }
        HashEntryStatus[1] = 0;
        *(uint8_t *)(HashEntryStatus + 2) = 0;
        HashEntryStatus[3] = 0;
        *HashEntryStatus = &SystemFunctionPointerB;
        HashEntryStatus[4] = 0;
        HashEntryStatus[5] = 0;
        HashEntryStatus[6] = 0;
        HashEntryStatus[7] = 0;
        HashEntryStatus[8] = 0;
        *(uint8_t *)(HashEntryStatus + 9) = 0;
        HashEntryStatus[10] = ResourceManagerPointer;
        *HashEntryStatus = &SystemFunctionPointerC;
        HashEntryStatus[0xb] = 0x20;
        HashEntryStatus[0xc] = 0;
        ExpandSystemResourceAllocator(HashEntryStatus);
      }
      else {
        HashEntryStatus = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x88,10,0,0xfffffffffffffffe);
        if (HashEntryStatus == (void* *)0x0) {
          return (void* *)0x0;
        }
        HashEntryStatus[1] = 0;
        *(uint8_t *)(HashEntryStatus + 2) = 0;
        HashEntryStatus[3] = 0;
        *HashEntryStatus = &SystemFunctionPointerB;
        HashEntryStatus[4] = 0;
        HashEntryStatus[5] = 0;
        HashEntryStatus[6] = 0;
        HashEntryStatus[7] = 0;
        HashEntryStatus[8] = 0;
        *(uint8_t *)(HashEntryStatus + 9) = 1;
        HashEntryStatus[10] = ResourceManagerPointer;
        *HashEntryStatus = &SystemFunctionPointerD;
        HashEntryStatus[0xb] = 0;
        HashEntryStatus[0xc] = 0;
        HashEntryStatus[0xd] = 0x10;
        HashEntryStatus[0xe] = 0;
        HashEntryStatus[0xf] = 0;
        HashEntryStatus[0x10] = 0;
        unsignedSystemValue7 = ResourceManagerPointer[4] - 1U | ResourceManagerPointer[4] - 1U >> 1;
        unsignedSystemValue7 = unsignedSystemValue7 | unsignedSystemValue7 >> 2;
        unsignedSystemValue7 = unsignedSystemValue7 | unsignedSystemValue7 >> 4;
        unsignedSystemValue8 = 1;
        do {
          unsignedSystemValue7 = unsignedSystemValue7 | unsignedSystemValue7 >> (((byte)unsignedSystemValue8 & 7) << 3);
          unsignedSystemValue8 = unsignedSystemValue8 * 2;
        } while (unsignedSystemValue8 < 8);
        unsignedSystemValue8 = unsignedSystemValue7 + 1 >> 1;
        if ((ulong long)HashEntryStatus[0xd] < unsignedSystemValue8) {
          HashEntryStatus[0xd] = unsignedSystemValue8;
        }
        InitializeSystemComponent(HashEntryStatus,0);
      }
      pcurrentThreadId = resourceEntryPointer;
      if (HashEntryStatus != (void* *)0x0) {
        LOCK();
        *(int *)(ResourceManagerPointer + 1) = (int)ResourceManagerPointer[1] + 1;
        UNLOCK();
        localResourceOffset = *ResourceManagerPointer;
        do {
          pcurrentThreadId = (void* *)(localResourceOffset + 8);
          if (localResourceOffset == 0) {
            pcurrentThreadId = resourceEntryPointer;
          }
          HashEntryStatus[1] = pcurrentThreadId;
          LOCK();
          bufferBaseAddress = *ResourceManagerPointer;
          isSystemBusy = localResourceOffset == bufferBaseAddress;
          if (isSystemBusy) {
            *ResourceManagerPointer = (long long)HashEntryStatus;
            bufferBaseAddress = localResourceOffset;
          }
          UNLOCK();
          localResourceOffset = bufferBaseAddress;
          pcurrentThreadId = HashEntryStatus;
        } while (!isSystemBusy);
      }
      return pcurrentThreadId;
    }
    if ((*(char *)(HashEntryStatus + 2) != '\0') && (*(char *)(HashEntryStatus + 9) == ConfigurationDataPointer)) {
      LOCK();
      isSystemBusy = *(char *)(HashEntryStatus + 2) == '\x01';
      if (isSystemBusy) {
        *(char *)(HashEntryStatus + 2) = '\0';
      }
      UNLOCK();
      if (isSystemBusy) {
        *AdditionalParameter = 1;
        return HashEntryStatus;
      }
    }
    PrimaryResourcePointer = HashEntryStatus + 1;
    HashEntryStatus = (void* *)(*PrimaryResourcePointer + -8);
    if (*PrimaryResourcePointer == 0) {
      HashEntryStatus = resourceEntryPointer;
    }
  } while( true );
}



/**
 * @brief 执行系统资源配置操作
 * 
 * 该函数负责执行系统资源的配置操作，包括资源状态检查、
 * 配置标志处理和资源分配操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 操作结果指针
 * 
 * 原始函数名为FUN_18005f040，现已重命名为ExecuteSystemResourceConfigurationOperation
 */
void* ExecuteSystemResourceConfigurationOperation(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ulong long systemStatus;
  char validationStatusFlag;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  ulong long *pcurrentThreadId;
  ulong long hashValue;
  ulong long unsignedSystemValue7;
  
  systemStatus = *(ulong long *)(ResourceManagerPointer + 0x20);
  unsignedSystemValue7 = (ulong long)((uint)systemStatus & 0x1f);
  if ((systemStatus & 0x1f) == 0) {
    hashValue = 0;
    if (*(long long *)(ResourceManagerPointer + 0x40) == 0) {
ResourceOperationLoop:
      if ((((*(long long *)(ResourceManagerPointer + 0x28) - systemStatus) - 0x20 < 0x8000000000000001) ||
          (((*(long long *)(ResourceManagerPointer + 0x80) == 0 ||
            (*(long long *)(ResourceManagerPointer + 0x60) == *(long long *)(ResourceManagerPointer + 0x68))) &&
           (charResult = InitializeSystemComponent(ResourceManagerPointer,*(void* *)(ResourceManagerPointer + 0x60),unsignedSystemValue7,ConfigurationFlag,
                                  0xfffffffffffffffe), charResult == '\0')))) ||
         (localResourceOffset = GetSystemResourceOffset(*(void* *)(ResourceManagerPointer + 0x50)), localResourceOffset == 0)) {
        return 0;
      }
      do {
        *(uint8_t *)(localResourceOffset + 0x110 + hashValue) = 0;
        hashValue = hashValue + 1;
      } while (hashValue != 0x20);
      if (*(long long *)(ResourceManagerPointer + 0x40) == 0) {
        *(long long *)(localResourceOffset + 0x100) = localResourceOffset;
      }
      else {
        *(void* *)(localResourceOffset + 0x100) = *(void* *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100);
        *(long long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100) = localResourceOffset;
      }
      *(long long *)(ResourceManagerPointer + 0x40) = localResourceOffset;
      *(long long *)(ResourceManagerPointer + 0x60) = *(long long *)(ResourceManagerPointer + 0x60) + 1;
    }
    else {
      unsignedSystemValue4 = hashValue;
      do {
        if (*(char *)(*(long long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100) + 0x110 + unsignedSystemValue4) == '\0')
        goto ResourceOperationLoop;
        unsignedSystemValue4 = unsignedSystemValue4 + 1;
      } while (unsignedSystemValue4 < 0x20);
      localResourceOffset = *(long long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100);
      *(long long *)(ResourceManagerPointer + 0x40) = localResourceOffset;
      do {
        *(uint8_t *)(localResourceOffset + 0x110 + hashValue) = 0;
        hashValue = hashValue + 1;
      } while (hashValue != 0x20);
    }
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    **(long long **)(ResourceManagerPointer + 0x40) = (long long)ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
    pcurrentThreadId = (ulong long *)
             (*(long long *)(ResourceManagerPointer + 0x70) * 0x10 +
             *(long long *)(*(long long *)(ResourceManagerPointer + 0x58) + 0x10));
    *pcurrentThreadId = systemStatus;
    pcurrentThreadId[1] = *(ulong long *)(ResourceManagerPointer + 0x40);
    *(void* *)(*(long long *)(ResourceManagerPointer + 0x58) + 8) = *(void* *)(ResourceManagerPointer + 0x70);
    *(ulong long *)(ResourceManagerPointer + 0x70) =
         *(long long *)(ResourceManagerPointer + 0x68) - 1U & *(long long *)(ResourceManagerPointer + 0x70) + 1U;
  }
  else {
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    *(long long **)(*(long long *)(ResourceManagerPointer + 0x40) + unsignedSystemValue7 * 8) = ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
  }
  *(ulong long *)(ResourceManagerPointer + 0x20) = systemStatus + 1;
  return 1;
}



/**
 * @brief 处理系统资源句柄操作
 * 
 * 该函数负责处理系统资源句柄的操作，包括句柄的创建、配置和管理。
 * 主要用于系统资源句柄的生命周期管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 操作结果指针
 * 
 * 原始函数名为FUN_18005f220，现已重命名为ProcessSystemResourceHandleOperation
 */
void* ProcessSystemResourceHandleOperation(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  ulong long systemStatus;
  char validationStatusFlag;
  long long *plocalResourceOffset;
  ulong long unsignedSystemValue4;
  ulong long uStackX_18;
  long long *plStackX_20;
  
  systemStatus = *(ulong long *)(ResourceManagerPointer + 0x20);
  unsignedSystemValue4 = (ulong long)((uint)systemStatus & 0x1f);
  if ((systemStatus & 0x1f) != 0) {
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    *(long long **)(*(long long *)(ResourceManagerPointer + 0x40) + unsignedSystemValue4 * 8) = ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
ResourceProcessingLoop:
    *(ulong long *)(ResourceManagerPointer + 0x20) = systemStatus + 1;
    return 1;
  }
  if (0x8000000000000000 < (*(long long *)(ResourceManagerPointer + 0x28) - systemStatus) - 0x20) {
    charResult = ConfigureSystemSettings(ResourceManagerPointer,&stackValue18,systemStatus,unsignedSystemValue4,0xfffffffffffffffe);
    if (validationStatusFlag != '\0') {
      plocalResourceOffset = (long long *)GetResourceOffsetPointer(*(void* *)(ResourceManagerPointer + 0x50));
      if (plocalResourceOffset != (long long *)0x0) {
        plocalResourceOffset[0x21] = 0;
        ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
        *plocalResourceOffset = (long long)ConfigurationDataPointer;
        if (ConfigurationDataPointer != (long long *)0x0) {
          plStackX_20 = plocalResourceOffset;
          (**(code **)(*ConfigurationDataPointer + 0x28))();
        }
        *(long long **)(uStackX_18 + 8) = plocalResourceOffset;
        *(long long **)(ResourceManagerPointer + 0x40) = plocalResourceOffset;
        goto ResourceProcessingLoop;
      }
      plocalResourceOffset = *(long long **)(ResourceManagerPointer + 0x60);
      plocalResourceOffset[1] = *plocalResourceOffset - 1U & plocalResourceOffset[1] - 1U;
      *(void* *)(uStackX_18 + 8) = 0;
    }
  }
  return 0;
}




/**
 * @brief 扩展系统资源分配器
 * 
 * 该函数负责扩展系统资源分配器，增加资源容量和处理能力。
 * 主要用于系统资源的动态扩展和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 扩展后的资源指针
 * 
 * 原始函数名为FUN_18005f340，现已重命名为ExpandSystemResourceAllocator
 */
void* ExpandSystemResourceAllocator(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  long long localSystemHandle;
  void* allocationContext;
  void* *punsignedSystemValue4;
  ulong long currentThreadId;
  ulong long hashValue;
  void** SystemCurrentNode;
  void** SystemNextNode;
  long long resourceCounter;
  
  localSystemHandle = *(long long *)(ResourceManagerPointer + 0x68);
  *(long long *)(ResourceManagerPointer + 0x68) = localSystemHandle * 2;
  punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemHandle * 0x20 + 0x27,10);
  if (punsignedSystemValue4 == (void* *)0x0) {
    *(ulong long *)(ResourceManagerPointer + 0x68) = *(ulong long *)(ResourceManagerPointer + 0x68) >> 1;
    return 0;
  }
  resourceCounter = 0;
  HashBucketNode = (void* *)((ulong long)(-(int)(punsignedSystemValue4 + 4) & 7) + (long long)(punsignedSystemValue4 + 4));
  if (*(long long *)(ResourceManagerPointer + 0x60) != 0) {
    currentThreadId = *(long long *)(ResourceManagerPointer + 0x70) - *(long long *)(ResourceManagerPointer + 0x60) & localSystemHandle - 1U;
    newThreadLocalStorage = HashBucketNode;
    do {
      resourceCounter = resourceCounter + 1;
      hashValue = currentThreadId + 1 & localSystemHandle - 1U;
      pointerToUnsigned1 = (void* *)(*(long long *)(ResourceManagerPointer + 0x78) + currentThreadId * 0x10);
      allocationContext = pointerToUnsigned1[1];
      *newThreadLocalStorage = *pointerToUnsigned1;
      newThreadLocalStorage[1] = allocationContext;
      currentThreadId = hashValue;
      newThreadLocalStorage = newThreadLocalStorage + 2;
    } while (hashValue != *(ulong long *)(ResourceManagerPointer + 0x70));
  }
  *punsignedSystemValue4 = *(void* *)(ResourceManagerPointer + 0x68);
  punsignedSystemValue4[1] = ConfigurationDataPointer + -1;
  punsignedSystemValue4[2] = HashBucketNode;
  allocationContext = *(void* *)(ResourceManagerPointer + 0x80);
  punsignedSystemValue4[3] = allocationContext;
  *(long long *)(ResourceManagerPointer + 0x70) = resourceCounter;
  *(void* **)(ResourceManagerPointer + 0x78) = HashBucketNode;
  *(void* **)(ResourceManagerPointer + 0x80) = punsignedSystemValue4;
  *(void* **)(ResourceManagerPointer + 0x58) = punsignedSystemValue4;
  return CONCAT71((int7)((ulong long)allocationContext >> 8),1);
}




/**
 * @brief 系统资源分配器扩展函数
 * 
 * 该函数负责扩展系统资源分配器的容量，创建新的线程对象并重新分配资源
 * 用于系统资源管理中的动态扩容操作
 * 
 * @param ResourceManagerPointer 系统资源指针，包含当前资源分配器状态
 * @return 扩展后的资源指针，失败时返回0
 * 
 * 原始函数名为FUN_18005f430，现已重命名为ExpandSystemResourceAllocator
 */
void* * ExpandSystemResourceAllocator(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  ulong long creationFlags;
  long long localResourceOffset;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  ulong long unsignedSystemValue7;
  long long localMemoryAddress;
  long long resourceCounter;
  void* *pointerToUnsigned10;
  void* *ThreadLocalStorage;
  
  PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x60);
  if (PrimaryResourcePointer == (long long *)0x0) {
    localResourceOffset = *(long long *)(ResourceManagerPointer + 0x58);
    localMemoryAddress = localResourceOffset;
    resourceCounter = 0;
  }
  else {
    localMemoryAddress = *PrimaryResourcePointer;
    localResourceOffset = *(long long *)(ResourceManagerPointer + 0x58);
    resourceCounter = localMemoryAddress;
  }
  punsignedSystemValue4 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(localResourceOffset + localMemoryAddress * 2) * 8 + 0x36,10);
  pointerToUnsigned10 = punsignedSystemValue4;
  if (punsignedSystemValue4 != (void* *)0x0) {
    ThreadLocalStorage = (void* *)((ulong long)(-(int)(punsignedSystemValue4 + 5) & 7) + (long long)(punsignedSystemValue4 + 5));
    pointerToUnsigned10 = (void* *)
              ((ulong long)(-(int)(ThreadLocalStorage + localMemoryAddress * 2) & 7) + (long long)(ThreadLocalStorage + localMemoryAddress * 2));
    if (PrimaryResourcePointer != (long long *)0x0) {
      creationFlags = PrimaryResourcePointer[1];
      unsignedSystemValue7 = creationFlags;
      resourceEntryPointer = pointerToUnsigned10;
      do {
        unsignedSystemValue7 = *PrimaryResourcePointer - 1U & unsignedSystemValue7 + 1;
        *resourceEntryPointer = *(void* *)(PrimaryResourcePointer[3] + unsignedSystemValue7 * 8);
        resourceEntryPointer = resourceEntryPointer + 1;
      } while (unsignedSystemValue7 != creationFlags);
    }
    if (localMemoryAddress != 0) {
      resourceEntryPointer = pointerToUnsigned10 + resourceCounter;
      pcurrentThreadId = ThreadLocalStorage;
      do {
        *pcurrentThreadId = 1;
        *resourceEntryPointer = pcurrentThreadId;
        resourceEntryPointer = resourceEntryPointer + 1;
        pcurrentThreadId = pcurrentThreadId + 2;
        localMemoryAddress = localMemoryAddress + -1;
      } while (localMemoryAddress != 0);
    }
    punsignedSystemValue4[4] = PrimaryResourcePointer;
    punsignedSystemValue4[2] = ThreadLocalStorage;
    punsignedSystemValue4[3] = pointerToUnsigned10;
    *punsignedSystemValue4 = *(void* *)(ResourceManagerPointer + 0x58);
    punsignedSystemValue4[1] = *(long long *)(ResourceManagerPointer + 0x58) - 1U & resourceCounter - 1U;
    pointerToUnsigned10 = (void* *)CONCAT71((int7)(resourceCounter - 1U >> 8),1);
    *(void* **)(ResourceManagerPointer + 0x60) = punsignedSystemValue4;
    *(long long *)(ResourceManagerPointer + 0x58) = *(long long *)(ResourceManagerPointer + 0x58) << 1;
  }
  return pointerToUnsigned10;
}



/**
 * @brief 系统资源分配器扩展函数B
 * 
 * 该函数负责扩展系统资源分配器的容量，使用寄存器变量进行高效的资源分配
 * 用于系统资源管理中的动态扩容操作
 * 
 * @note 这是一个系统资源分配器扩展函数，使用寄存器变量进行优化
 * 
 * 原始函数名为FUN_18005f490，现已重命名为ExpandSystemResourceAllocatorB
 */
void* ExpandSystemResourceAllocatorB(void)

{
  ulong long systemStatus;
  long long in_RAX;
  void** SystemDataTable;
  void* *HashNodePointer;
  ulong long unsignedSystemValue4;
  long long systemMemoryBlockPtr;
  long long systemStackFramePtr;
  long long systemStringIteratorPtr;
  long long *systemDataIndexPtr;
  void* *in_R9;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  
  resourceEntryPointer = (void* *)((ulong long)(-(int)in_RAX & 7) + in_RAX);
  pcurrentThreadId = (void* *)
           ((ulong long)(-(int)(resourceEntryPointer + systemMemoryBlockPtr * 2) & 7) + (long long)(resourceEntryPointer + systemMemoryBlockPtr * 2));
  if (systemDataIndexPtr != (long long *)0x0) {
    systemStatus = systemDataIndexPtr[1];
    unsignedSystemValue4 = systemStatus;
    HashNodePointer = pcurrentThreadId;
    do {
      unsignedSystemValue4 = *systemDataIndexPtr - 1U & unsignedSystemValue4 + 1;
      *HashNodePointer = *(void* *)(systemDataIndexPtr[3] + unsignedSystemValue4 * 8);
      HashNodePointer = HashNodePointer + 1;
    } while (unsignedSystemValue4 != systemStatus);
  }
  if (systemMemoryBlockPtr != 0) {
    HashNodePointer = pcurrentThreadId + systemStackFramePtr;
    HashEntryStatus = resourceEntryPointer;
    do {
      *HashEntryStatus = 1;
      *HashNodePointer = HashEntryStatus;
      HashNodePointer = HashNodePointer + 1;
      HashEntryStatus = HashEntryStatus + 2;
      systemMemoryBlockPtr = systemMemoryBlockPtr + -1;
    } while (systemMemoryBlockPtr != 0);
  }
  in_R9[4] = systemDataIndexPtr;
  in_R9[2] = resourceEntryPointer;
  in_R9[3] = pcurrentThreadId;
  *in_R9 = *(void* *)(systemStringIteratorPtr + 0x58);
  in_R9[1] = *(long long *)(systemStringIteratorPtr + 0x58) - 1U & systemStackFramePtr - 1U;
  *(void* **)(systemStringIteratorPtr + 0x60) = in_R9;
  *(long long *)(systemStringIteratorPtr + 0x58) = *(long long *)(systemStringIteratorPtr + 0x58) << 1;
  return CONCAT71((int7)(systemStackFramePtr - 1U >> 8),1);
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 * 原始函数名为FUN_18005f54c，现已重命名为SystemNoOperation
 */
void SystemNoOperation(void)

{
  return;
}




/**
 * @brief 系统资源数据处理函数
 * 
 * 该函数负责处理系统资源数据，包括内存分配、数据操作和资源管理。
 * 该函数包含复杂的内存操作和数据处理逻辑。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 处理结果状态码
 * 
 * 原始函数名为FUN_18005f570，现已重命名为ProcessSystemResourceData
 */
ulong long ProcessSystemResourceData(long long ResourceManagerPointer,long long *ConfigurationDataPointer,long long AdditionalParameter)

{
  uint *systemDataPointer1;
  uint32_t *systemDataPointer2;
  uint systemStatusValue1;
  uint systemStatusValue2;
  long long *localSystemMemoryPointer;
  uint32_t systemMemoryOffset1;
  uint32_t systemMemoryOffset2;
  uint32_t systemMemoryOffset3;
  long long *localResourceDataPointer;
  ulong long systemResourceValue1;
  long long localMemoryAddress1;
  ulong long systemResourceValue2;
  ulong long systemResourceValue3;
  ulong long systemResourceValue4;
  ulong long systemResourceValue5;
  ulong long *systemResourcePointer1;
  ulong long systemResourceValue6;
  ulong long systemResourceValue7;
  ulong long systemResourceValue8;
  uint32_t *systemDataPointer3;
  uint32_t *systemDataPointer4;
  long long systemHandle1;
  long long systemHandle2;
  ulong long systemResourceValue9;
  bool operationStatus;
  ulong long stackParameter1;
  ulong long stackParameter2;
  
  creationFlags5 = *(ulong long *)(ResourceManagerPointer + 0x20);
  systemStatus3 = *(ulong long *)(ResourceManagerPointer + 0x40);
  systemStatus6 = *(ulong long *)(ResourceManagerPointer + 0x70);
  systemStatus2 = *(ulong long *)(ResourceManagerPointer + 0x60);
  systemStatus8 = 0;
  systemStatus9 = AdditionalParameter + creationFlags5;
  UnsignedStackFlag78 = creationFlags5 - 1 & 0xffffffffffffffe0;
  localSystemHandle4 = (systemStatus9 - 1 & 0xffffffffffffffe0) - UnsignedStackFlag78;
  systemOperationFlags = systemStatus8;
  creationFlags0 = systemStatus8;
  systemStatus5 = systemStatus3;
  if (localSystemHandle4 != 0) {
    do {
      EncryptionValue68 = systemStatus6;
      creationFlags0 = systemOperationFlags;
      if ((*(long long *)(ResourceManagerPointer + 0x40) == 0) ||
         (systemStatus5 = *(ulong long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100), systemStatus4 = systemStatus8,
         systemStatus5 == systemOperationFlags)) goto joined_r0x00018005f6ef;
      do {
        if (*(char *)(systemStatus5 + 0x110 + systemStatus4) == '\0') goto joined_r0x00018005f6ef;
        systemStatus4 = systemStatus4 + 1;
      } while (systemStatus4 < 0x20);
      UnsignedStackFlag78 = UnsignedStackFlag78 + 0x20;
      creationFlags0 = *(ulong long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100);
      *(ulong long *)(ResourceManagerPointer + 0x40) = creationFlags0;
      pointerToUnsigned17 = (ulong long *)
                (*(long long *)(*(long long *)(ResourceManagerPointer + 0x58) + 0x10) +
                *(long long *)(ResourceManagerPointer + 0x70) * 0x10);
      *pointerToUnsigned17 = UnsignedStackFlag78;
      pointerToUnsigned17[1] = *(ulong long *)(ResourceManagerPointer + 0x40);
      *(ulong long *)(ResourceManagerPointer + 0x70) =
           *(long long *)(ResourceManagerPointer + 0x68) - 1U & *(long long *)(ResourceManagerPointer + 0x70) + 1U;
      if (systemOperationFlags != 0) {
        creationFlags0 = systemOperationFlags;
      }
      localSystemHandle4 = localSystemHandle4 + -0x20;
      systemOperationFlags = creationFlags0;
    } while (localSystemHandle4 != 0);
SystemHandleCheck:
    localSystemHandle4 = 0;
    systemStatus6 = creationFlags0;
    while( true ) {
      do {
        *(uint8_t *)(systemStatus6 + 0x110 + localSystemHandle4) = 0;
        localSystemHandle4 = localSystemHandle4 + 1;
      } while (localSystemHandle4 != 0x20);
      systemStatus5 = *(ulong long *)(ResourceManagerPointer + 0x40);
      if (systemStatus6 == systemStatus5) break;
      systemStatus6 = *(ulong long *)(systemStatus6 + 0x100);
      localSystemHandle4 = 0;
    }
  }
  *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus3;
  if ((creationFlags5 & 0x1f) == 0) {
    if (creationFlags0 != 0) {
      systemStatus3 = creationFlags0;
    }
    *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus3;
  }
  while( true ) {
    systemStatus6 = (creationFlags5 & 0xffffffffffffffe0) + 0x20;
    systemStatus3 = systemStatus9;
    if (systemStatus9 - systemStatus6 < 0x8000000000000001) {
      systemStatus3 = systemStatus6;
    }
    for (; creationFlags5 != systemStatus3; creationFlags5 = creationFlags5 + 1) {
      plocalSystemPointer = (long long *)*ConfigurationDataPointer;
      *(long long **)(*(long long *)(ResourceManagerPointer + 0x40) + (ulong long)((uint)creationFlags5 & 0x1f) * 8) = plocalSystemPointer;
      if (plocalSystemPointer != (long long *)0x0) {
        (**(code **)(*plocalSystemPointer + 0x28))();
      }
      ConfigurationDataPointer = ConfigurationDataPointer + 1;
    }
    systemStatus3 = *(ulong long *)(ResourceManagerPointer + 0x40);
    if (systemStatus3 == systemStatus5) break;
    *(void* *)(ResourceManagerPointer + 0x40) = *(void* *)(systemStatus3 + 0x100);
  }
  if (creationFlags0 != 0) {
    systemStatus3 = *(long long *)(ResourceManagerPointer + 0x68) - 1;
    *(ulong long *)(*(long long *)(ResourceManagerPointer + 0x58) + 8) = *(long long *)(ResourceManagerPointer + 0x70) - 1U & systemStatus3;
  }
  *(ulong long *)(ResourceManagerPointer + 0x20) = systemStatus9;
  return CONCAT71((int7)(systemStatus3 >> 8),1);
joined_r0x00018005f6ef:
  if (localSystemHandle4 == 0) goto SystemHandleCheck;
  localSystemHandle4 = localSystemHandle4 + -0x20;
  UnsignedStackFlag78 = UnsignedStackFlag78 + 0x20;
  systemStatus5 = (*(long long *)(ResourceManagerPointer + 0x28) - UnsignedStackFlag78) - 0x20;
  plocalSystemPointer = (long long *)(ResourceManagerPointer + 0x68);
  if ((*(long long *)(ResourceManagerPointer + 0x80) == 0) || (*(long long *)(ResourceManagerPointer + 0x60) == *plocalSystemPointer)) {
    if (0x8000000000000000 < systemStatus5) {
      nextDataIndex1 = *plocalSystemPointer;
      *plocalSystemPointer = nextDataIndex1 * 2;
      presourceCounter = (long long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex1 * 0x20 + 0x27,10);
      if (presourceCounter != (long long *)0x0) {
        HashEntryStatus2 = (uint32_t *)((ulong long)(-(int)(presourceCounter + 4) & 7) + (long long)(presourceCounter + 4));
        localSystemHandle3 = 0;
        if (*(long long *)(ResourceManagerPointer + 0x60) != 0) {
          systemStatus6 = *(long long *)(ResourceManagerPointer + 0x70) - *(long long *)(ResourceManagerPointer + 0x60) & nextDataIndex1 - 1U;
          HashEntryStatus1 = HashEntryStatus2;
          do {
            HashEntryStatus = (uint32_t *)(*(long long *)(ResourceManagerPointer + 0x78) + systemStatus6 * 0x10);
            hashValue = HashEntryStatus[1];
            unsignedSystemValue7 = HashEntryStatus[2];
            unsignedSystemValue8 = HashEntryStatus[3];
            *HashEntryStatus1 = *HashEntryStatus;
            HashEntryStatus1[1] = hashValue;
            HashEntryStatus1[2] = unsignedSystemValue7;
            HashEntryStatus1[3] = unsignedSystemValue8;
            localSystemHandle3 = localSystemHandle3 + 1;
            HashEntryStatus1 = HashEntryStatus1 + 4;
            systemStatus6 = systemStatus6 + 1 & nextDataIndex1 - 1U;
          } while (systemStatus6 != *(ulong long *)(ResourceManagerPointer + 0x70));
        }
        *presourceCounter = *plocalSystemPointer;
        presourceCounter[1] = systemStatus2 - 1;
        presourceCounter[2] = (long long)HashEntryStatus2;
        presourceCounter[3] = *(long long *)(ResourceManagerPointer + 0x80);
        *(long long *)(ResourceManagerPointer + 0x70) = localSystemHandle3;
        *(uint32_t **)(ResourceManagerPointer + 0x78) = HashEntryStatus2;
        *(long long **)(ResourceManagerPointer + 0x80) = presourceCounter;
        *(long long **)(ResourceManagerPointer + 0x58) = presourceCounter;
        systemStatus6 = systemStatus2;
        EncryptionValue68 = systemStatus2;
        goto SystemValueProcessing;
      }
      *(ulong long *)(ResourceManagerPointer + 0x68) = *(ulong long *)(ResourceManagerPointer + 0x68) >> 1;
      systemStatus6 = EncryptionValue68;
    }
SystemValueValidation:
    *(ulong long *)(ResourceManagerPointer + 0x70) = systemStatus6;
    *(ulong long *)(ResourceManagerPointer + 0x60) = systemStatus2;
    if (systemStatus3 == 0) {
      systemStatus3 = creationFlags0;
    }
    *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus3;
SystemValueCheck:
    return systemStatus2 & 0xffffffffffffff00;
  }
  if (systemStatus5 < 0x8000000000000001) goto SystemValueValidation;
SystemValueProcessing:
  nextDataIndex1 = *(long long *)(ResourceManagerPointer + 0x50);
  if (*(ulong long *)(nextDataIndex1 + 0x20) <= *(ulong long *)(nextDataIndex1 + 0x10)) {
ResourceAllocationLoop:
    systemOperationFlags = *(ulong long *)(nextDataIndex1 + 0x28);
ResourceOperationCheck:
    systemStatus5 = systemOperationFlags;
    if (systemStatus5 != 0) {
      pointerToUnsigned1 = (uint *)(systemStatus5 + 0x130);
      unsignedSystemValue4 = *pointerToUnsigned1;
      if ((unsignedSystemValue4 & 0x7fffffff) == 0) {
ResourceAllocationRetry:
        systemOperationFlags = *(ulong long *)(nextDataIndex1 + 0x28);
      }
      else {
        LOCK();
        allocationContext = *pointerToUnsigned1;
        if (unsignedSystemValue4 == allocationContext) {
          *pointerToUnsigned1 = unsignedSystemValue4 + 1;
        }
        UNLOCK();
        if (unsignedSystemValue4 != allocationContext) goto ResourceAllocationRetry;
        LOCK();
        systemOperationFlags = *(ulong long *)(nextDataIndex1 + 0x28);
        isSystemActive6 = systemStatus5 == systemOperationFlags;
        if (isSystemActive6) {
          *(ulong long *)(nextDataIndex1 + 0x28) = *(ulong long *)(systemStatus5 + 0x138);
          systemOperationFlags = systemStatus5;
        }
        UNLOCK();
        if (isSystemActive6) {
          LOCK();
          *pointerToUnsigned1 = *pointerToUnsigned1 - 2;
          UNLOCK();
          if (systemStatus5 != 0) goto ResourceInitializationComplete;
          goto ResourceCleanupComplete;
        }
        LOCK();
        unsignedSystemValue4 = *pointerToUnsigned1;
        *pointerToUnsigned1 = *pointerToUnsigned1 - 1;
        UNLOCK();
        if (unsignedSystemValue4 == 0x80000001) {
          systemStatus8 = *(ulong long *)(nextDataIndex1 + 0x28);
          do {
            *(ulong long *)(systemStatus5 + 0x138) = systemStatus8;
            *pointerToUnsigned1 = 1;
            LOCK();
            systemStatus4 = *(ulong long *)(nextDataIndex1 + 0x28);
            isSystemActive6 = systemStatus8 == systemStatus4;
            if (isSystemActive6) {
              *(ulong long *)(nextDataIndex1 + 0x28) = systemStatus5;
              systemStatus4 = systemStatus8;
            }
            UNLOCK();
            if (isSystemActive6) break;
            LOCK();
            unsignedSystemValue4 = *pointerToUnsigned1;
            *pointerToUnsigned1 = *pointerToUnsigned1 + 0x7fffffff;
            UNLOCK();
            systemStatus8 = systemStatus4;
          } while (unsignedSystemValue4 == 1);
        }
      }
      goto ResourceOperationCheck;
    }
ResourceCleanupComplete:
    systemStatus5 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x148,CONCAT71((int7)(systemStatus5 >> 8),10));
    if (systemStatus5 != 0) {
      *(void* *)(systemStatus5 + 0x100) = 0;
      *(void* *)(systemStatus5 + 0x108) = 0;
      *(uint32_t *)(systemStatus5 + 0x130) = 0;
      *(void* *)(systemStatus5 + 0x138) = 0;
      *(void*2 *)(systemStatus5 + 0x140) = 0x100;
      goto ResourceInitializationComplete;
    }
ResourceConfigurationComplete:
    *(ulong long *)(ResourceManagerPointer + 0x70) = systemStatus6;
    *(ulong long *)(ResourceManagerPointer + 0x60) = systemStatus2;
    systemStatus2 = systemStatus3;
    if (systemStatus3 == 0) {
      systemStatus2 = creationFlags0;
    }
    *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus2;
    goto SystemValueCheck;
  }
  LOCK();
  pointerToUnsigned17 = (ulong long *)(nextDataIndex1 + 0x10);
  systemStatus5 = *pointerToUnsigned17;
  *pointerToUnsigned17 = *pointerToUnsigned17 + 1;
  UNLOCK();
  if ((*(ulong long *)(nextDataIndex1 + 0x20) <= systemStatus5) ||
     (systemStatus5 = systemStatus5 * 0x148 + *(long long *)(nextDataIndex1 + 0x18), systemStatus5 == 0)) goto ResourceAllocationLoop;
ResourceInitializationComplete:
  nextDataIndex1 = 0;
  if (systemStatus5 == 0) goto ResourceConfigurationComplete;
  do {
    *(uint8_t *)(systemStatus5 + 0x110 + nextDataIndex1) = 1;
    nextDataIndex1 = nextDataIndex1 + 1;
  } while (nextDataIndex1 != 0x20);
  if (*(long long *)(ResourceManagerPointer + 0x40) == 0) {
    *(ulong long *)(systemStatus5 + 0x100) = systemStatus5;
  }
  else {
    *(void* *)(systemStatus5 + 0x100) = *(void* *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100);
    *(ulong long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100) = systemStatus5;
  }
  *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus5;
  if (creationFlags0 != 0) {
    systemStatus5 = creationFlags0;
  }
  *(long long *)(ResourceManagerPointer + 0x60) = *(long long *)(ResourceManagerPointer + 0x60) + 1;
  pointerToUnsigned17 = (ulong long *)
            (*(long long *)(*(long long *)(ResourceManagerPointer + 0x58) + 0x10) +
            *(long long *)(ResourceManagerPointer + 0x70) * 0x10);
  *pointerToUnsigned17 = UnsignedStackFlag78;
  pointerToUnsigned17[1] = *(ulong long *)(ResourceManagerPointer + 0x40);
  *(ulong long *)(ResourceManagerPointer + 0x70) = *(long long *)(ResourceManagerPointer + 0x70) + 1U & *plocalSystemPointer - 1U;
  creationFlags0 = systemStatus5;
  goto joined_r0x00018005f6ef;
}




/**
 * @brief 系统资源数据扩展处理函数
 * 
 * 该函数负责扩展处理系统资源数据，包括更多的内存操作和数据管理功能。
 * 该函数是对ProcessSystemResourceData函数的扩展和补充。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 处理结果状态码
 * 
 * 原始函数名为FUN_18005fb30，现已重命名为ProcessSystemResourceDataExtended
 */
ulong long ProcessSystemResourceDataExtended(long long ResourceManagerPointer,long long *ConfigurationDataPointer,long long AdditionalParameter)

{
  ulong long *systemResourcePointer1;
  uint *systemDataPointer1;
  uint systemStatusValue1;
  uint systemStatusValue2;
  long long *localSystemMemoryPointer;
  long long systemOperationFlags;
  ulong long systemResourceValue1;
  ulong long unsignedSystemValue8;
  char systemAvailabilityFlag;
  ulong long systemOperationFlags;
  ulong long systemStatus1;
  ulong long systemStatus2;
  ulong long systemStatus3;
  ulong long systemStatus4;
  ulong long systemStatus5;
  ulong long systemStatus6;
  ulong long systemStatus7;
  ulong long systemStatus8;
  long long nextDataIndex9;
  ulong long *HashEntryStatus0;
  bool isSystemActive1;
  
  systemStatus6 = *(ulong long *)(ResourceManagerPointer + 0x20);
  systemStatus7 = *(ulong long *)(ResourceManagerPointer + 0x40);
  systemStatus3 = systemStatus6 + AdditionalParameter;
  systemStatus8 = systemStatus6 - 1 & 0xffffffffffffffe0;
  nextDataIndex9 = (systemStatus3 - 1 & 0xffffffffffffffe0) - systemStatus8;
  systemStatus4 = systemStatus7;
  systemOperationFlags = systemStatus8;
  unsignedSystemValue7 = 0;
  while( true ) {
    if (nextDataIndex9 == 0) {
      *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus7;
      if ((systemStatus6 & 0x1f) == 0) {
        if (unsignedSystemValue7 != 0) {
          systemStatus7 = unsignedSystemValue7;
        }
        *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus7;
      }
      while( true ) {
        systemOperationFlags = (systemStatus6 & 0xffffffffffffffe0) + 0x20;
        systemStatus7 = systemStatus3;
        if (systemStatus3 - systemOperationFlags < 0x8000000000000001) {
          systemStatus7 = systemOperationFlags;
        }
        for (; systemStatus6 != systemStatus7; systemStatus6 = systemStatus6 + 1) {
          plocalSystemPointer = (long long *)*ConfigurationDataPointer;
          *(long long **)(*(long long *)(ResourceManagerPointer + 0x40) + (ulong long)((uint)systemStatus6 & 0x1f) * 8) =
               plocalSystemPointer;
          if (plocalSystemPointer != (long long *)0x0) {
            (**(code **)(*plocalSystemPointer + 0x28))();
          }
          ConfigurationDataPointer = ConfigurationDataPointer + 1;
        }
        systemStatus7 = *(ulong long *)(ResourceManagerPointer + 0x40);
        if (systemStatus7 == systemStatus4) break;
        *(void* *)(ResourceManagerPointer + 0x40) = *(void* *)(systemStatus7 + 0x100);
      }
      *(ulong long *)(ResourceManagerPointer + 0x20) = systemStatus3;
      return CONCAT71((int7)(systemStatus7 >> 8),1);
    }
    nextDataIndex9 = nextDataIndex9 + -0x20;
    systemOperationFlags = systemOperationFlags + 0x20;
    unsignedSystemValue8 = unsignedSystemValue7;
    if (((*(long long *)(ResourceManagerPointer + 0x28) - systemOperationFlags) - 0x20 < 0x8000000000000001) ||
       (plocalSystemPointer = *(long long **)(ResourceManagerPointer + 0x60), plocalSystemPointer == (long long *)0x0))
    goto joined_r0x00018005fdcd;
    systemStatus4 = *plocalSystemPointer - 1U & plocalSystemPointer[1] + 1U;
    HashEntryStatus0 = *(ulong long **)(plocalSystemPointer[3] + systemStatus4 * 8);
    if ((*HashEntryStatus0 == 1) || (HashEntryStatus0[1] == 0)) {
      *HashEntryStatus0 = systemOperationFlags;
      plocalSystemPointer[1] = systemStatus4;
    }
    else {
      charOutput = ExpandSystemResourceAllocator(ResourceManagerPointer);
      if (charOutput == '\0') goto joined_r0x00018005fdcd;
      plocalSystemPointer = *(long long **)(ResourceManagerPointer + 0x60);
      systemStatus4 = *plocalSystemPointer - 1U & plocalSystemPointer[1] + 1U;
      HashEntryStatus0 = *(ulong long **)(plocalSystemPointer[3] + systemStatus4 * 8);
      *HashEntryStatus0 = systemOperationFlags;
      plocalSystemPointer[1] = systemStatus4;
    }
    localSystemFlags = *(long long *)(ResourceManagerPointer + 0x50);
    if (*(ulong long *)(localSystemFlags + 0x20) <= *(ulong long *)(localSystemFlags + 0x10)) break;
    LOCK();
    pointerToUnsigned1 = (ulong long *)(localSystemFlags + 0x10);
    systemStatus4 = *pointerToUnsigned1;
    *pointerToUnsigned1 = *pointerToUnsigned1 + 1;
    UNLOCK();
    if ((*(ulong long *)(localSystemFlags + 0x20) <= systemStatus4) ||
       (systemStatus4 = systemStatus4 * 0x148 + *(long long *)(localSystemFlags + 0x18), systemStatus4 == 0)) break;
ResourceValidationComplete:
    if (systemStatus4 == 0) goto ResourceMemoryCheck;
ResourceDataInitialization:
    *(void* *)(systemStatus4 + 0x108) = 0;
    *(void* *)(systemStatus4 + 0x100) = 0;
    HashEntryStatus0[1] = systemStatus4;
    if (((systemStatus6 & 0x1f) != 0) || (unsignedSystemValue7 != 0)) {
      *(ulong long *)(*(long long *)(ResourceManagerPointer + 0x40) + 0x100) = systemStatus4;
    }
    *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus4;
    if (unsignedSystemValue7 == 0) {
      unsignedSystemValue7 = systemStatus4;
    }
  }
  systemStatus1 = *(ulong long *)(localSystemFlags + 0x28);
ResourceOperationValidation:
  systemStatus4 = systemStatus1;
  if (systemStatus4 != 0) {
    HashEntryStatus = (uint *)(systemStatus4 + 0x130);
    unsignedSystemValue4 = *HashEntryStatus;
    if ((unsignedSystemValue4 & 0x7fffffff) == 0) {
ResourceOperationRetry:
      systemStatus1 = *(ulong long *)(localSystemFlags + 0x28);
    }
    else {
      LOCK();
      allocationContext = *HashEntryStatus;
      if (unsignedSystemValue4 == allocationContext) {
        *HashEntryStatus = unsignedSystemValue4 + 1;
      }
      UNLOCK();
      if (unsignedSystemValue4 != allocationContext) goto ResourceOperationRetry;
      LOCK();
      systemStatus1 = *(ulong long *)(localSystemFlags + 0x28);
      isSystemActive1 = systemStatus4 == systemStatus1;
      if (isSystemActive1) {
        *(ulong long *)(localSystemFlags + 0x28) = *(ulong long *)(systemStatus4 + 0x138);
        systemStatus1 = systemStatus4;
      }
      UNLOCK();
      if (isSystemActive1) {
        LOCK();
        *HashEntryStatus = *HashEntryStatus - 2;
        UNLOCK();
        if (systemStatus4 != 0) goto ResourceDataInitialization;
        goto ResourceThreadCreation;
      }
      LOCK();
      unsignedSystemValue4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus - 1;
      UNLOCK();
      if (unsignedSystemValue4 == 0x80000001) {
        systemStatus5 = *(ulong long *)(localSystemFlags + 0x28);
        do {
          *(ulong long *)(systemStatus4 + 0x138) = systemStatus5;
          *HashEntryStatus = 1;
          LOCK();
          systemStatus2 = *(ulong long *)(localSystemFlags + 0x28);
          isSystemActive1 = systemStatus5 == systemStatus2;
          if (isSystemActive1) {
            *(ulong long *)(localSystemFlags + 0x28) = systemStatus4;
            systemStatus2 = systemStatus5;
          }
          UNLOCK();
          if (isSystemActive1) break;
          LOCK();
          unsignedSystemValue4 = *HashEntryStatus;
          *HashEntryStatus = *HashEntryStatus + 0x7fffffff;
          UNLOCK();
          systemStatus5 = systemStatus2;
        } while (unsignedSystemValue4 == 1);
      }
    }
    goto ResourceOperationValidation;
  }
ResourceThreadCreation:
  systemStatus4 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x148,CONCAT71((int7)((ulong long)localSystemFlags >> 8),10));
  if (systemStatus4 != 0) {
    *(void* *)(systemStatus4 + 0x100) = 0;
    *(void* *)(systemStatus4 + 0x108) = 0;
    *(uint32_t *)(systemStatus4 + 0x130) = 0;
    *(void* *)(systemStatus4 + 0x138) = 0;
    *(void*2 *)(systemStatus4 + 0x140) = 0x100;
    goto ResourceValidationComplete;
  }
ResourceMemoryCheck:
  plocalSystemPointer = *(long long **)(ResourceManagerPointer + 0x60);
  plocalSystemPointer[1] = plocalSystemPointer[1] - 1U & *plocalSystemPointer - 1U;
  HashEntryStatus0[1] = 0;
joined_r0x00018005fdcd:
  for (; unsignedSystemValue8 != 0; unsignedSystemValue8 = *(ulong long *)(unsignedSystemValue8 + 0x100)) {
    systemStatus8 = systemStatus8 + 0x20;
    plocalSystemPointer = *(long long **)(ResourceManagerPointer + 0x60);
    *(void* *)
     (*(long long *)
       (plocalSystemPointer[3] +
       ((systemStatus8 - **(long long **)(plocalSystemPointer[3] + plocalSystemPointer[1] * 8) >> 5) + plocalSystemPointer[1] & *plocalSystemPointer - 1U) * 8)
     + 8) = 0;
    plocalSystemPointer = *(long long **)(ResourceManagerPointer + 0x60);
    plocalSystemPointer[1] = plocalSystemPointer[1] - 1U & *plocalSystemPointer - 1U;
  }
  systemStatus3 = InitializeSystemResourceHandle(*(void* *)(ResourceManagerPointer + 0x50),unsignedSystemValue7);
  *(ulong long *)(ResourceManagerPointer + 0x40) = systemStatus7;
  return systemStatus3 & 0xffffffffffffff00;
}




/**
 * @brief 从资源池分配资源
 * 
 * 该函数负责从资源池中分配资源，使用原子操作确保线程安全。
 * 它会检查资源池的容量，并返回可用的资源地址。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回分配的资源地址，如果没有可用资源则返回0
 */
long long AllocateFromResourcePool(long long ResourceManagerPointer)

{
  ulong long *pointerToUnsigned1;
  uint *HashEntryStatus;
  uint allocationContext;
  ulong long unsignedSystemValue4;
  uint currentThreadId;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  long long resourceCounter;
  bool isByteValid0;
  
  if (*(ulong long *)(ResourceManagerPointer + 0x10) < *(ulong long *)(ResourceManagerPointer + 0x20)) {
    LOCK();
    pointerToUnsigned1 = (ulong long *)(ResourceManagerPointer + 0x10);
    unsignedSystemValue4 = *pointerToUnsigned1;
    *pointerToUnsigned1 = *pointerToUnsigned1 + 1;
    UNLOCK();
    if ((unsignedSystemValue4 < *(ulong long *)(ResourceManagerPointer + 0x20)) &&
       (localSystemFlags = unsignedSystemValue4 * 0x148 + *(long long *)(ResourceManagerPointer + 0x18), localSystemFlags != 0)) {
      return localSystemFlags;
    }
  }
  localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28);
ResourcePoolAllocation:
  do {
    resourceCounter = localSystemFlags;
    if (resourceCounter == 0) {
ResourceCreation:
      localSystemFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x148,10);
      if (localSystemFlags == 0) {
        return 0;
      }
      *(void* *)(localSystemFlags + 0x100) = 0;
      *(void* *)(localSystemFlags + 0x108) = 0;
      *(uint32_t *)(localSystemFlags + 0x130) = 0;
      *(void* *)(localSystemFlags + 0x138) = 0;
      *(void*2 *)(localSystemFlags + 0x140) = 0x100;
      return localSystemFlags;
    }
    HashEntryStatus = (uint *)(resourceCounter + 0x130);
    currentThreadId = *HashEntryStatus;
    if ((currentThreadId & 0x7fffffff) == 0) {
ResourceAllocationCheck:
      localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28);
      goto ResourcePoolAllocation;
    }
    LOCK();
    allocationContext = *HashEntryStatus;
    if (currentThreadId == allocationContext) {
      *HashEntryStatus = currentThreadId + 1;
    }
    UNLOCK();
    if (currentThreadId != allocationContext) goto ResourceAllocationCheck;
    LOCK();
    localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28);
    isByteValid0 = resourceCounter == localSystemFlags;
    if (isByteValid0) {
      *(long long *)(ResourceManagerPointer + 0x28) = *(long long *)(resourceCounter + 0x138);
      localSystemFlags = resourceCounter;
    }
    UNLOCK();
    if (isByteValid0) {
      LOCK();
      *HashEntryStatus = *HashEntryStatus - 2;
      UNLOCK();
      if (resourceCounter != 0) {
        return resourceCounter;
      }
      goto ResourceCreation;
    }
    LOCK();
    currentThreadId = *HashEntryStatus;
    *HashEntryStatus = *HashEntryStatus - 1;
    UNLOCK();
    if (currentThreadId == 0x80000001) {
      localMemoryAddress = *(long long *)(ResourceManagerPointer + 0x28);
      do {
        *(long long *)(resourceCounter + 0x138) = localMemoryAddress;
        *HashEntryStatus = 1;
        LOCK();
        localDataIndex = *(long long *)(ResourceManagerPointer + 0x28);
        isByteValid0 = localMemoryAddress == localDataIndex;
        if (isByteValid0) {
          *(long long *)(ResourceManagerPointer + 0x28) = resourceCounter;
          localDataIndex = localMemoryAddress;
        }
        UNLOCK();
        if (isByteValid0) break;
        LOCK();
        currentThreadId = *HashEntryStatus;
        *HashEntryStatus = *HashEntryStatus + 0x7fffffff;
        UNLOCK();
        localMemoryAddress = localDataIndex;
      } while (currentThreadId == 1);
    }
  } while( true );
}



/**
 * @brief 系统资源内存处理函数
 * 
 * 该函数负责处理系统资源的内存分配和管理，包括主资源指针和辅助资源指针的操作。
 * 该函数包含复杂的内存管理和指针操作逻辑。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 处理结果状态码
 * 
 * 原始函数名为FUN_180060080，现已重命名为ProcessSystemResourceMemory
 */
ulong long ProcessSystemResourceMemory(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter)

{
  long long *primaryResourcePointer;
  long long *secondaryResourcePointer;
  long long localResourceOffset;
  void* *systemDataPointer;
  ulong long systemResourceValue;
  ulong long systemStatusValue;
  
  primaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x60);
  if (primaryResourcePointer != (long long *)0x0) {
    systemStatusValue = *primaryResourcePointer - 1U & primaryResourcePointer[1] + 1U;
    secondaryResourcePointer = *(long long **)(primaryResourcePointer[3] + systemStatusValue * 8);
    *ConfigurationDataPointer = (long long)secondaryResourcePointer;
    if ((*secondaryResourcePointer == 1) || (*(long long *)(*ConfigurationDataPointer + 8) == 0)) {
      systemDataPointer = (void* *)*ConfigurationDataPointer;
      *systemDataPointer = AdditionalParameter;
      primaryResourcePointer[1] = systemStatusValue;
      return CONCAT71((int7)((ulong long)systemDataPointer >> 8),1);
    }
    systemResourceValue = GetSystemResourceStatus();
    if ((char)systemResourceValue != '\0') {
      primaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x60);
      systemStatusValue = *primaryResourcePointer - 1U & primaryResourcePointer[1] + 1U;
      localResourceOffset = primaryResourcePointer[3];
      systemDataPointer = *(void* **)(localResourceOffset + systemStatusValue * 8);
      *ConfigurationDataPointer = (long long)systemDataPointer;
      *systemDataPointer = AdditionalParameter;
      primaryResourcePointer[1] = systemStatusValue;
      return CONCAT71((int7)((ulong long)localResourceOffset >> 8),1);
    }
  }
  return systemResourceValue & 0xffffffffffffff00;
}



/**
 * @brief 初始化系统资源上下文
 * 
 * 该函数负责初始化系统资源上下文，设置资源的环境和状态。
 * 主要用于系统资源的上下文管理和初始化。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 初始化后的上下文指针
 * 
 * 原始函数名为FUN_1800601c0，现已重命名为InitializeSystemResourceContext
 */
void* InitializeSystemResourceContext(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x88);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源清理器函数
 * 
 * 该函数负责清理系统资源，包括内存释放和资源回收操作。
 * 它会遍历资源链表，释放不再使用的资源，并更新系统状态。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要清理的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的生命周期管理
 */
void CleanupSystemResources(void* *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  int *ResourceCounterPointer;
  int MemoryComparisonResult;
  uint ResourceIndex;
  ulong long ResourceHashValue;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  long long resourceCounter;
  ulong long ResourceTableSize;
  long long NextResourcePointer;
  bool IsResourceMatch;
  
  *ResourceManagerPointer = &SystemResourceTableA;
  if (ResourceManagerPointer[8] != 0) {
    nextDataIndex1 = 0;
    if ((ResourceManagerPointer[5] & 0x1f) != 0) {
      systemOperationFlags = ResourceManagerPointer[0xe] - ResourceManagerPointer[0xc];
      currentThreadId = ResourceManagerPointer[0xd] - 1;
      while( true ) {
        systemOperationFlags = systemOperationFlags & currentThreadId;
        if ((ulong long)((*(long long *)(ResourceManagerPointer[0xf] + systemOperationFlags * 0x10) + 0x20) - ResourceManagerPointer[5]) <
            0x8000000000000001) break;
        currentThreadId = systemOperationFlags + 1;
        systemOperationFlags = ResourceManagerPointer[0xd] - 1;
      }
      nextDataIndex1 = *(long long *)(ResourceManagerPointer[0xf] + 8 + systemOperationFlags * 0x10);
    }
    resourceCounter = ResourceManagerPointer[8];
LAB_1800602a0:
    resourceCounter = *(long long *)(resourceCounter + 0x100);
    currentThreadId = 0;
    do {
      if (*(char *)(resourceCounter + 0x110 + currentThreadId) == '\0') {
        currentThreadId = 0;
        if (resourceCounter == nextDataIndex1) {
          currentThreadId = (ulong long)((uint)ResourceManagerPointer[5] & 0x1f);
        }
        if ((ResourceManagerPointer[4] & 0x1f) == 0) {
          systemOperationFlags = 0x20;
        }
        else {
          systemOperationFlags = (ulong long)((uint)ResourceManagerPointer[4] & 0x1f);
        }
        goto LAB_1800602f0;
      }
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < 0x20);
    goto LAB_18006031a;
  }
LAB_18006039b:
  if (ResourceManagerPointer[0x10] == 0) {
    *ResourceManagerPointer = &SystemResourceTableB;
    return;
  }
    SystemCleanupFunction();
  while( true ) {
    unsignedSystemValue4 = (uint)currentThreadId;
    currentThreadId = currentThreadId + 1;
    PrimaryResourcePointer = *(long long **)(resourceCounter + (ulong long)(unsignedSystemValue4 & 0x1f) * 8);
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
    if (currentThreadId == 0x20) break;
LAB_1800602f0:
    if ((resourceCounter == ResourceManagerPointer[8]) && (currentThreadId == systemOperationFlags)) break;
  }
LAB_18006031a:
  localDataIndex = ResourceManagerPointer[8];
  if (resourceCounter == localDataIndex) goto code_r0x000180060327;
  goto LAB_1800602a0;
code_r0x000180060327:
  if (localDataIndex != 0) {
    do {
      nextDataIndex1 = *(long long *)(localDataIndex + 0x100);
      if (*(char *)(localDataIndex + 0x141) != '\0') {
          SystemCleanupFunction();
      }
      resourceCounter = ResourceManagerPointer[10];
      LOCK();
      pointerToInteger2 = (int *)(localDataIndex + 0x130);
      systemCounter = *pointerToInteger2;
      *pointerToInteger2 = *pointerToInteger2 + -0x80000000;
      UNLOCK();
      if (systemCounter == 0) {
        localMemoryAddress = *(long long *)(resourceCounter + 0x28);
        do {
          *(long long *)(localDataIndex + 0x138) = localMemoryAddress;
          *(uint32_t *)(localDataIndex + 0x130) = 1;
          PrimaryResourcePointer = (long long *)(resourceCounter + 0x28);
          LOCK();
          localSystemFlags = *PrimaryResourcePointer;
          isByteValid2 = localMemoryAddress == localSystemFlags;
          if (isByteValid2) {
            *PrimaryResourcePointer = localDataIndex;
            localSystemFlags = localMemoryAddress;
          }
          UNLOCK();
          if (isByteValid2) break;
          LOCK();
          pointerToInteger2 = (int *)(localDataIndex + 0x130);
          systemCounter = *pointerToInteger2;
          *pointerToInteger2 = *pointerToInteger2 + 0x7fffffff;
          UNLOCK();
          localMemoryAddress = localSystemFlags;
        } while (systemCounter == 1);
      }
      localDataIndex = nextDataIndex1;
    } while (nextDataIndex1 != ResourceManagerPointer[8]);
  }
  goto LAB_18006039b;
}



/**
 * @brief 初始化系统资源上下文函数
 * 
 * 该函数负责初始化系统资源上下文，包括资源分配和配置。
 * 该函数会根据配置数据指针的标志来决定是否释放资源。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_1800603e0，现已重命名为InitializeSystemResourceContext
 */
void* InitializeSystemResourceContext(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  ValidateSystemResourceContext();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x68);
  }
  return ResourceManagerPointer;
}




// 函数: void AllocateSystemResources(void* *ResourceManagerPointer)
/**
 * @brief 系统资源分配器函数
 * 
 * 该函数负责分配系统资源，包括内存分配和资源初始化操作。
 * 它会处理资源表的分配，并设置相应的资源参数。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要分配的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的分配和初始化
 */
void AllocateSystemResources(void* *ResourceManagerPointer)

{
  int *pointerToInteger1;
  int systemResult;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  long long *plocalSystemPointer;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  long long resourceCounter;
  ulong long systemOperationFlags;
  bool isByteValid1;
  
  *ResourceManagerPointer = &SystemResourceTableC;
  allocationContext = ResourceManagerPointer[4];
  resourceCounter = 0;
  unsignedSystemValue4 = ResourceManagerPointer[5];
  for (systemOperationFlags = unsignedSystemValue4; systemOperationFlags != allocationContext; systemOperationFlags = systemOperationFlags + 1) {
    if ((systemOperationFlags & 0x1f) == 0) {
      if (resourceCounter != 0) {
        localSystemFlags = ResourceManagerPointer[10];
        LOCK();
        pointerToInteger1 = (int *)(resourceCounter + 0x130);
        systemResult = *pointerToInteger1;
        *pointerToInteger1 = *pointerToInteger1 + -0x80000000;
        UNLOCK();
        if (systemResult == 0) {
          localMemoryAddress = *(long long *)(localSystemFlags + 0x28);
          do {
            *(long long *)(resourceCounter + 0x138) = localMemoryAddress;
            *(uint32_t *)(resourceCounter + 0x130) = 1;
            plocalSystemPointer = (long long *)(localSystemFlags + 0x28);
            LOCK();
            localDataIndex = *plocalSystemPointer;
            isByteValid1 = localMemoryAddress == localDataIndex;
            if (isByteValid1) {
              *plocalSystemPointer = resourceCounter;
              localDataIndex = localMemoryAddress;
            }
            UNLOCK();
            if (isByteValid1) break;
            LOCK();
            pointerToInteger1 = (int *)(resourceCounter + 0x130);
            systemResult = *pointerToInteger1;
            *pointerToInteger1 = *pointerToInteger1 + 0x7fffffff;
            UNLOCK();
            localMemoryAddress = localDataIndex;
          } while (systemResult == 1);
        }
      }
LAB_1800604d1:
      plocalSystemPointer = (long long *)ResourceManagerPointer[0xc];
      resourceCounter = *(long long *)
               (*(long long *)
                 (plocalSystemPointer[3] +
                 (((systemOperationFlags & 0xffffffffffffffe0) - **(long long **)(plocalSystemPointer[3] + plocalSystemPointer[1] * 8) >> 5)
                  + plocalSystemPointer[1] & *plocalSystemPointer - 1U) * 8) + 8);
    }
    else if (resourceCounter == 0) goto LAB_1800604d1;
    plocalSystemPointer = *(long long **)(resourceCounter + (ulong long)((uint)systemOperationFlags & 0x1f) * 8);
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x38))();
    }
  }
  resourceCounter = ResourceManagerPointer[8];
  if ((resourceCounter != 0) && ((unsignedSystemValue4 != allocationContext || ((allocationContext & 0x1f) != 0)))) {
    localSystemFlags = ResourceManagerPointer[10];
    LOCK();
    pointerToInteger1 = (int *)(resourceCounter + 0x130);
    systemResult = *pointerToInteger1;
    *pointerToInteger1 = *pointerToInteger1 + -0x80000000;
    UNLOCK();
    if (systemResult == 0) {
      localMemoryAddress = *(long long *)(localSystemFlags + 0x28);
      do {
        *(long long *)(resourceCounter + 0x138) = localMemoryAddress;
        *(uint32_t *)(resourceCounter + 0x130) = 1;
        plocalSystemPointer = (long long *)(localSystemFlags + 0x28);
        LOCK();
        localDataIndex = *plocalSystemPointer;
        isByteValid1 = localMemoryAddress == localDataIndex;
        if (isByteValid1) {
          *plocalSystemPointer = resourceCounter;
          localDataIndex = localMemoryAddress;
        }
        UNLOCK();
        if (isByteValid1) break;
        LOCK();
        pointerToInteger1 = (int *)(resourceCounter + 0x130);
        systemResult = *pointerToInteger1;
        *pointerToInteger1 = *pointerToInteger1 + 0x7fffffff;
        UNLOCK();
        localMemoryAddress = localDataIndex;
      } while (systemResult == 1);
    }
  }
  if (ResourceManagerPointer[0xc] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemResourceTableB;
  return;
}



/**
 * @brief 配置系统资源数据函数
 * 
 * 该函数负责配置系统资源数据，设置资源表和配置参数。
 * 该函数会根据配置数据指针的标志来决定是否释放资源。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_1800605d0，现已重命名为ConfigureSystemResourceData
 */
void* * ConfigureSystemResourceData(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemResourceTableB;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x58);
  }
  return ResourceManagerPointer;
}




// 函数: void ConfigureSystemResources(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源配置器函数
 * 
 * 该函数负责配置系统资源，设置资源参数和属性。
 * 它会处理资源的初始化配置，并设置相应的标志位。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要配置的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置参数
 * @param AdditionalParameter 额外参数，用于特殊配置
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @note 这是系统资源管理的重要组成部分，用于资源的配置和初始化
 */
void ConfigureSystemResources(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  char SystemNodeFlag;
  void* ConfigurationMask;
  
  ConfigurationMask = 0xfffffffffffffffe;
  *ResourceManagerPointer = &SystemResourcePrimaryTemplate;
  charStatus = ConfigureSystemResourceContext(ResourceManagerPointer,1,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  while (charStatus != '\0') {
    charStatus = ConfigureSystemResourceContext(ResourceManagerPointer,1,AdditionalParameter,ConfigurationFlag,ConfigurationMask);
  }
  if (ResourceManagerPointer[1] == 0) {
    ResourceManagerPointer[1] = 0;
    _Mtx_destroy_in_situ();
    _Cnd_destroy_in_situ(ResourceManagerPointer + 0x2a);
    _Mtx_destroy_in_situ();
    FinalizeSystemResourceConfiguration();
    if (ResourceManagerPointer[0xe] != 0) {
      *(void* *)(ResourceManagerPointer[0xe] + 0x10) = 0;
      *(uint8_t *)(ResourceManagerPointer[0xe] + 8) = 1;
    }
    ResourceManagerPointer[2] = &SystemMemoryAllocatorReference;
    return;
  }
  if (*(int *)(ResourceManagerPointer[1] + 8) == 0) {
      SystemCleanupFunction();
  }
    terminate();
}



/**
 * @brief 释放系统资源内存
 * 
 * 该函数负责释放系统资源的内存，根据配置标志决定是否执行释放操作。
 * 主要用于系统资源的内存管理和清理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 释放后的资源指针
 * 
 * 原始函数名为FUN_180060630，现已重命名为ReleaseSystemResourceMemory
 */
void* ReleaseSystemResourceMemory(void* ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  CleanupSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x208,AdditionalParameter,ConfigurationFlag,systemStatus);
  }
  return ResourceManagerPointer;
}



int InitializeProcessSystem(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  ulong long *HashEntryStatus;
  uint64_t SystemInitializationFlag;
  void* uStackX_20;
  
  uStackX_18 = AdditionalParameter;
  uStackX_20 = ConfigurationFlag;
  HashEntryStatus = (ulong long *)SystemGlobalDataAllocate();
  systemStatus = __stdio_common_vsprintf(*HashEntryStatus | 1,ResourceManagerPointer,0xffffffffffffffff,ConfigurationDataPointer,0,&uStackX_18);
  if (systemStatus < 0) {
    systemStatus = -1;
  }
  return systemStatus;
}





// 函数: void InitializeSystemResource(long long *ResourceManagerPointer)
/**
 * @brief 系统资源初始化器函数
 * 
 * 该函数负责初始化系统资源，设置资源的基本参数和状态。
 * 它会处理资源的预初始化工作，为后续的资源分配做准备。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要初始化的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的初始化和准备
 */
void InitializeSystemResource(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  int MemoryComparisonResult;
  void* uStackX_8;
  long long *plStack_20;
  char cStack_18;
  
  if ((char)ResourceManagerPointer[0xb] != '\0') {
    PrimaryResourcePointer = (long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
    do {
      charResult = (**(code **)(*ResourceManagerPointer + 0x20))(ResourceManagerPointer,1);
      if (validationStatusFlag == '\0') {
        ReleaseSystemResourceHandle(*(void* *)(*PrimaryResourcePointer + 0x10),0);
        plStack_20 = ResourceManagerPointer + 0x33;
        cStack_18 = 0;
        systemCounter = _Mtx_lock();
        if (systemCounter != 0) {
          __Throw_C_error_std__YAXH_Z(systemCounter);
        }
        cStack_18 = '\x01';
        if ((char)ResourceManagerPointer[0x3d] == '\x01') {
          *(uint8_t *)(ResourceManagerPointer + 0x3d) = 0;
        }
        else {
          uStackX_8 = 0x32;
          ProcessSystemTimestampHandler(ResourceManagerPointer + 0x2a,&plStack_20,&uStackX_8);
          *(uint8_t *)(ResourceManagerPointer + 0x3d) = 0;
          if (cStack_18 == '\0') goto LAB_1800607cc;
        }
        systemCounter = _Mtx_unlock(plStack_20);
        if (systemCounter != 0) {
          __Throw_C_error_std__YAXH_Z(systemCounter);
        }
      }
LAB_1800607cc:
    } while ((char)ResourceManagerPointer[0xb] != '\0');
  }
  return;
}



/**
 * @brief 处理系统资源分配请求
 * 
 * 该函数负责处理系统资源的分配请求，根据配置数据决定资源的分配策略。
 * 主要用于系统资源的动态分配和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的资源指针
 * 
 * 原始函数名为FUN_1800607f0，现已重命名为ProcessSystemResourceAllocationRequest
 */
void* ProcessSystemResourceAllocationRequest(long long ResourceManagerPointer,char ConfigurationDataPointer)

{
  long long nextDataIndex;
  int systemResult;
  long long *plocalResourceOffset;
  void* unsignedSystemValue4;
  long long *plStackX_18;
  
  plStackX_18 = (long long *)0x0;
  plocalResourceOffset = (long long *)0x0;
  if (ConfigurationDataPointer != '\0') {
    if (*(int *)(ResourceManagerPointer + 0x140) < 1) {
      plocalResourceOffset = (long long *)0x0;
    }
    else {
      systemResult = _Mtx_lock(ResourceManagerPointer + 0xf0);
      if (systemResult != 0) {
        __Throw_C_error_std__YAXH_Z(systemResult);
      }
      if ((*(long long *)(ResourceManagerPointer + 200) - *(long long *)(ResourceManagerPointer + 0xd0) >> 3) +
          ((*(long long *)(ResourceManagerPointer + 0xe0) - *(long long *)(ResourceManagerPointer + 0xc0) >> 3) + -1) * 0x20 +
          (*(long long *)(ResourceManagerPointer + 0xb8) - (long long)*(long long **)(ResourceManagerPointer + 0xa8) >> 3) != 0) {
        plStackX_18 = (long long *)**(long long **)(ResourceManagerPointer + 0xa8);
        if (plStackX_18 != (long long *)0x0) {
          (**(code **)(*plStackX_18 + 0x28))(plStackX_18);
        }
        plocalResourceOffset = *(long long **)(ResourceManagerPointer + 0xa8);
        if (plocalResourceOffset + 1 == *(long long **)(ResourceManagerPointer + 0xb8)) {
          if ((long long *)*plocalResourceOffset != (long long *)0x0) {
            (**(code **)(*(long long *)*plocalResourceOffset + 0x38))();
          }
          if (*(long long *)(ResourceManagerPointer + 0xb0) != 0) {
              SystemCleanupFunction();
          }
          plocalResourceOffset = (long long *)(*(long long *)(ResourceManagerPointer + 0xc0) + 8);
          *(long long **)(ResourceManagerPointer + 0xc0) = plocalResourceOffset;
          nextDataIndex = *plocalResourceOffset;
          *(long long *)(ResourceManagerPointer + 0xb0) = nextDataIndex;
          *(long long *)(ResourceManagerPointer + 0xb8) = nextDataIndex + 0x100;
          *(void* *)(ResourceManagerPointer + 0xa8) = *(void* *)(ResourceManagerPointer + 0xb0);
        }
        else {
          *(long long **)(ResourceManagerPointer + 0xa8) = plocalResourceOffset + 1;
          if ((long long *)*plocalResourceOffset != (long long *)0x0) {
            (**(code **)(*(long long *)*plocalResourceOffset + 0x38))();
          }
        }
      }
      systemResult = _Mtx_unlock(ResourceManagerPointer + 0xf0);
      if (systemResult != 0) {
        __Throw_C_error_std__YAXH_Z(systemResult);
      }
      plocalResourceOffset = plStackX_18;
      if (plStackX_18 != (long long *)0x0) {
        (**(code **)(*plStackX_18 + 0x60))(plStackX_18);
        (**(code **)(*plStackX_18 + 0x70))(plStackX_18);
        LOCK();
        *(int *)(ResourceManagerPointer + 0x140) = *(int *)(ResourceManagerPointer + 0x140) + -1;
        UNLOCK();
        unsignedSystemValue4 = 1;
        goto LAB_180060993;
      }
    }
  }
  plStackX_18 = plocalResourceOffset;
  unsignedSystemValue4 = 0;
LAB_180060993:
  if (plStackX_18 != (long long *)0x0) {
    (**(code **)(*plStackX_18 + 0x38))(plStackX_18);
  }
  return unsignedSystemValue4;
}



/**
 * @brief 初始化系统资源并执行同步操作
 * 
 * 该函数负责初始化系统资源，等待同步对象，并执行相关的回调函数。
 * 主要用于系统资源的初始化和同步处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 初始化结果状态码，true表示成功，false表示失败
 * 
 * 原始函数名为FUN_1800609c0，现已重命名为InitializeSystemResourceAndSynchronize
 */
bool InitializeSystemResourceAndSynchronize(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  long long *plStackX_8;
  
  plStackX_8 = (long long *)0x0;
  WaitForSingleObject(**(void* **)(ResourceManagerPointer + 0x1f0),1,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  charResult = ProcessSystemResourceData(*(void* *)(ResourceManagerPointer + 0x60),ResourceManagerPointer + 0x78,&plStackX_8);
  PrimaryResourcePointer = plStackX_8;
  if (validationStatusFlag != '\0') {
    (**(code **)(*plStackX_8 + 0x60))(plStackX_8);
    (**(code **)(*PrimaryResourcePointer + 0x70))(PrimaryResourcePointer);
  }
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer);
  }
  return charResult != '\0';
}



/**
 * @brief 获取系统资源状态值
 * 
 * 该函数负责获取系统资源的状态值，用于资源管理和状态监控。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源状态值
 * 
 * 原始函数名为FUN_180060a50，现已重命名为GetSystemResourceStatusValue
 */
ulong long GetSystemResourceStatusValue(long long *ResourceManagerPointer,uint *ConfigurationDataPointer)

{
  uint systemStatus;
  uint creationFlags;
  long long localResourceOffset;
  ulong long in_RAX;
  ulong long *punsignedSystemValue4;
  ulong long *pcurrentThreadId;
  ulong long *resourceEntryPointer;
  ulong long unsignedSystemValue7;
  ulong long *newThreadLocalStorage;
  uint unsignedSystemValue9;
  ulong long systemOperationFlags;
  
  localResourceOffset = *ResourceManagerPointer;
  if ((*(long long *)(ConfigurationDataPointer + 6) == 0) && (localResourceOffset == 0)) {
    return in_RAX & 0xffffffffffffff00;
  }
  systemStatus = *(uint *)(ResourceManagerPointer + 1);
  creationFlags = *(uint *)(ResourceManagerPointer + 0x4c);
  newThreadLocalStorage = (ulong long *)0x0;
  punsignedSystemValue4 = *(ulong long **)(ConfigurationDataPointer + 6);
  if (*(ulong long **)(ConfigurationDataPointer + 6) == (ulong long *)0x0) {
    pcurrentThreadId = (ulong long *)(localResourceOffset + 8);
    if (localResourceOffset == 0) {
      pcurrentThreadId = newThreadLocalStorage;
    }
    *(ulong long **)(ConfigurationDataPointer + 6) = pcurrentThreadId;
    unsignedSystemValue9 = (systemStatus - *ConfigurationDataPointer % systemStatus) - 1;
    systemOperationFlags = (ulong long)unsignedSystemValue9;
    punsignedSystemValue4 = pcurrentThreadId;
    if (unsignedSystemValue9 != 0) {
      do {
        if (punsignedSystemValue4 == (ulong long *)0x0) {
          punsignedSystemValue4 = (ulong long *)&SystemDataBufferPtr;
        }
        resourceEntryPointer = (ulong long *)(*punsignedSystemValue4 - 8);
        if (*punsignedSystemValue4 == 0) {
          SystemCurrentNode = SystemNextNode;
        }
        punsignedSystemValue4 = resourceEntryPointer + 1;
        if (resourceEntryPointer == (ulong long *)0x0) {
          punsignedSystemValue4 = newThreadLocalStorage;
        }
        *(ulong long **)(ConfigurationDataPointer + 6) = punsignedSystemValue4;
        if (punsignedSystemValue4 == (ulong long *)0x0) {
          *(ulong long **)(ConfigurationDataPointer + 6) = pcurrentThreadId;
          punsignedSystemValue4 = pcurrentThreadId;
        }
        systemOperationFlags = systemOperationFlags - 1;
      } while (systemOperationFlags != 0);
    }
  }
  unsignedSystemValue9 = creationFlags - ConfigurationDataPointer[1];
  systemOperationFlags = (ulong long)unsignedSystemValue9;
  if (systemStatus <= unsignedSystemValue9) {
    systemOperationFlags = (ulong long)unsignedSystemValue9 % (ulong long)systemStatus;
  }
  unsignedSystemValue7 = systemOperationFlags;
  if ((int)systemOperationFlags != 0) {
    do {
      if (punsignedSystemValue4 == (ulong long *)0x0) {
        punsignedSystemValue4 = (ulong long *)&SystemDataBufferPtr;
      }
      systemOperationFlags = *punsignedSystemValue4;
      pcurrentThreadId = (ulong long *)(systemOperationFlags - 8);
      if (systemOperationFlags == 0) {
        pcurrentThreadId = newThreadLocalStorage;
      }
      punsignedSystemValue4 = newThreadLocalStorage;
      if (pcurrentThreadId != (ulong long *)0x0) {
        punsignedSystemValue4 = pcurrentThreadId + 1;
      }
      *(ulong long **)(ConfigurationDataPointer + 6) = punsignedSystemValue4;
      if (punsignedSystemValue4 == (ulong long *)0x0) {
        punsignedSystemValue4 = (ulong long *)(localResourceOffset + 8);
        if (localResourceOffset == 0) {
          punsignedSystemValue4 = newThreadLocalStorage;
        }
        *(ulong long **)(ConfigurationDataPointer + 6) = punsignedSystemValue4;
      }
      unsignedSystemValue7 = unsignedSystemValue7 - 1;
    } while (unsignedSystemValue7 != 0);
  }
  ConfigurationDataPointer[1] = creationFlags;
  ConfigurationDataPointer[2] = 0;
  *(ulong long **)(ConfigurationDataPointer + 4) = punsignedSystemValue4;
  return CONCAT71((int7)(systemOperationFlags >> 8),1);
}



/**
 * @brief 处理系统资源数据交换
 * 
 * 该函数负责处理系统资源数据的交换操作，包括内存指针的重新分配
 * 和资源的清理释放。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 处理后的系统资源指针
 * 
 * 原始函数名为FUN_180060b80，现已重命名为ProcessSystemResourceDataExchange
 */
long long * ProcessSystemResourceDataExchange(long long *ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long nextDataIndex;
  long long *resourcePoolPointer;
  
  nextDataIndex = *ConfigurationDataPointer;
  *ConfigurationDataPointer = 0;
  resourcePoolPointer = (long long *)*ResourceManagerPointer;
  *ResourceManagerPointer = nextDataIndex;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  return ResourceManagerPointer;
}



/**
 * @brief 释放系统资源并返回指针
 * 
 * 该函数负责释放系统资源，并返回资源指针。
 * 主要用于系统资源的清理和释放操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_180060bd0，现已重命名为ReleaseSystemResourceAndReturnPointer
 */
long long * ReleaseSystemResourceAndReturnPointer(long long *ResourceManagerPointer)

{
  if ((long long *)*ResourceManagerPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ResourceManagerPointer + 0x38))();
  }
  return ResourceManagerPointer;
}



/**
 * @brief 分配系统资源内存
 * 
 * 该函数负责分配系统资源的内存，包括内存块的分配和管理。
 * 主要用于系统资源的内存分配操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的内存指针，失败时返回0
 * 
 * 原始函数名为FUN_180060c60，现已重命名为AllocateSystemResourceMemory
 */
void* AllocateSystemResourceMemory(long long ResourceManagerPointer,void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *HashEntryStatus;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  ulong long unsignedSystemValue7;
  
  if (*(char *)(ResourceManagerPointer + 0x48) == '\0') {
    if ((ulong long)
        ((*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x38)) -
        *(long long *)(ResourceManagerPointer + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x30);
    localResourceOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((localResourceOffset - *(long long *)(ResourceManagerPointer + 0x20)) - *(long long *)(ResourceManagerPointer + 0x38))) {
      LOCK();
      HashEntryStatus = (ulong long *)(ResourceManagerPointer + 0x28);
      unsignedSystemValue4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x60);
      localResourceOffset = *(long long *)
               (PrimaryResourcePointer[3] +
               (((unsignedSystemValue4 & 0xffffffffffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 8);
      localSystemFlags = *(long long *)(localResourceOffset + 8);
      PrimaryResourcePointer = (long long *)(localSystemFlags + (ulong long)((uint)unsignedSystemValue4 & 0x1f) * 8);
      ConfigureSystemDataBuffer(ConfigurationDataPointer,PrimaryResourcePointer);
      PrimaryResourcePointer = (long long *)*PrimaryResourcePointer;
      if (PrimaryResourcePointer != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer + 0x38))();
      }
      LOCK();
      PrimaryResourcePointer = (long long *)(localSystemFlags + 0x108);
      localSystemPointer = *PrimaryResourcePointer;
      *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
      UNLOCK();
      if (localSystemPointer == 0x1f) {
        *(void* *)(localResourceOffset + 8) = 0;
        ReleaseSystemResourceHandle(*(void* *)(ResourceManagerPointer + 0x50),localSystemFlags);
      }
      return 1;
    }
  }
  else {
    if ((ulong long)
        ((*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x38)) -
        *(long long *)(ResourceManagerPointer + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x30);
    localResourceOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((localResourceOffset - *(long long *)(ResourceManagerPointer + 0x20)) - *(long long *)(ResourceManagerPointer + 0x38))) {
      LOCK();
      HashEntryStatus = (ulong long *)(ResourceManagerPointer + 0x28);
      unsignedSystemValue4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x58);
      unsignedSystemValue7 = (ulong long)((uint)unsignedSystemValue4 & 0x1f);
      localResourceOffset = *(long long *)
               (PrimaryResourcePointer[2] + 8 +
               (((unsignedSystemValue4 & 0xffffffffffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
      PrimaryResourcePointer = (long long *)(localResourceOffset + unsignedSystemValue7 * 8);
      ConfigureSystemDataBuffer(ConfigurationDataPointer,PrimaryResourcePointer);
      PrimaryResourcePointer = (long long *)*PrimaryResourcePointer;
      if (PrimaryResourcePointer != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer + 0x38))();
      }
      *(uint8_t *)((localResourceOffset - unsignedSystemValue7) + 0x12f) = 1;
      return 1;
    }
  }
  LOCK();
  *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + 1;
  UNLOCK();
  return 0;
}



/**
 * @brief 获取系统数据索引指针
 * 
 * 该函数负责获取系统数据索引指针，处理字符串迭代器和数据索引
 * 用于系统数据管理和索引操作
 * 
 * @return 系统数据索引指针
 * 
 * 原始函数名为FUN_180060d76，现已重命名为GetSystemDataIndexPointer
 */
void* GetSystemDataIndexPointer(void)

{
  ulong long *pointerToUnsigned1;
  ulong long creationFlags;
  long long localResourceOffset;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  long long localSystemFlags;
  ulong long systemStringIteratorPtr;
  long long systemDataIndexPtr;
  
  LOCK();
  pointerToUnsigned1 = (ulong long *)(systemDataIndexPtr + 0x28);
  creationFlags = *pointerToUnsigned1;
  *pointerToUnsigned1 = *pointerToUnsigned1 + (systemStringIteratorPtr & 0xffffffff);
  UNLOCK();
  pbufferBaseAddress = *(long long **)(systemDataIndexPtr + 0x60);
  localSystemPointer = *(long long *)
           (pbufferBaseAddress[3] +
           (((creationFlags & 0xffffffffffffffe0) - **(long long **)(pbufferBaseAddress[3] + pbufferBaseAddress[1] * 8) >> 5) +
            pbufferBaseAddress[1] & *pbufferBaseAddress - 1U) * 8);
  localSystemFlags = *(long long *)(localSystemPointer + 8);
  InitializeSystemDataBuffer();
  pbufferBaseAddress = *(long long **)(localSystemFlags + (ulong long)((uint)creationFlags & 0x1f) * 8);
  if (pbufferBaseAddress != (long long *)0x0) {
    (**(code **)(*pbufferBaseAddress + 0x38))();
  }
  LOCK();
  pbufferBaseAddress = (long long *)(localSystemFlags + 0x108);
  localResourceOffset = *pbufferBaseAddress;
  *pbufferBaseAddress = *pbufferBaseAddress + systemStringIteratorPtr;
  UNLOCK();
  if (localResourceOffset == 0x1f) {
    *(void* *)(localSystemPointer + 8) = 0;
    ReleaseSystemResourceHandle(*(void* *)(systemDataIndexPtr + 0x50),localSystemFlags);
  }
  return 1;
}



/**
 * @brief 更新系统字符串索引
 * 
 * 该函数负责更新系统字符串的索引，通过加法操作来维护字符串数据的索引状态。
 * 主要用于系统字符串管理的数据同步。
 * 
 * @return 更新状态码，0表示成功
 * 
 * 原始函数名为FUN_180060e22，现已重命名为UpdateSystemStringIndex
 */
uint8_t UpdateSystemStringIndex(void)

{
  long long systemStringIteratorPtr;
  long long systemDataIndexPtr;
  
  LOCK();
  *(long long *)(systemDataIndexPtr + 0x38) = *(long long *)(systemDataIndexPtr + 0x38) + systemStringIteratorPtr;
  UNLOCK();
  return 0;
}



/**
 * @brief 系统资源分配和同步函数
 * 
 * 该函数负责分配系统资源并进行同步操作，包括内存分配、资源验证
 * 和状态同步。用于系统资源的动态分配和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 分配的资源指针或错误代码
 * 
 * 原始函数名为FUN_180060e40，现已重命名为AllocateAndSynchronizeSystemResource
 */
void* AllocateAndSynchronizeSystemResource(void* *ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter)

{
  char SystemNodeFlag;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  long long* SystemMemoryPointer;
  long long *plocalSystemPointer;
  long long *plocalSystemFlags;
  
  if (((*(long long *)(ConfigurationDataPointer + 0x18) == 0) || (*(int *)(ConfigurationDataPointer + 4) != *(int *)(ResourceManagerPointer + 0x4c)))
     && (charStatus = ValidateSystemResourceStatus(), charStatus == '\0')) {
    return 0;
  }
  plocalSystemFlags = (long long *)0x0;
  pbufferBaseAddress = (long long *)(*(long long *)(ConfigurationDataPointer + 0x10) + -8);
  if (*(long long *)(ConfigurationDataPointer + 0x10) == 0) {
    pbufferBaseAddress = plocalSystemFlags;
  }
  charStatus = ProcessSystemBufferAllocation(pbufferBaseAddress,AdditionalParameter);
  if (initializationStatusFlag == '\0') {
    pbufferBaseAddress = (long long *)*ResourceManagerPointer;
    resourcePoolPointer = *(long long **)(ConfigurationDataPointer + 0x10);
    if (resourcePoolPointer == (long long *)0x0) {
      resourcePoolPointer = (long long *)&SystemDataBufferPtr;
    }
    localResourceOffset = *resourcePoolPointer;
    while( true ) {
      resourcePoolPointer = (long long *)(localResourceOffset + -8);
      if (localResourceOffset == 0) {
        resourcePoolPointer = plocalSystemFlags;
      }
      plocalSystemPointer = pbufferBaseAddress;
      if (resourcePoolPointer != (long long *)0x0) {
        plocalSystemPointer = resourcePoolPointer;
      }
      resourcePoolPointer = (long long *)(*(long long *)(ConfigurationDataPointer + 0x10) + -8);
      if (*(long long *)(ConfigurationDataPointer + 0x10) == 0) {
        resourcePoolPointer = plocalSystemFlags;
      }
      if (plocalSystemPointer == resourcePoolPointer) {
        return 0;
      }
      charStatus = ProcessSystemBufferAllocation(plocalSystemPointer,AdditionalParameter);
      if (charStatus != '\0') break;
      localResourceOffset = plocalSystemPointer[1];
    }
    *(uint32_t *)(ConfigurationDataPointer + 8) = 1;
    pbufferBaseAddress = plocalSystemPointer + 1;
    if (plocalSystemPointer == (long long *)0x0) {
      pbufferBaseAddress = plocalSystemFlags;
    }
    *(long long **)(ConfigurationDataPointer + 0x10) = pbufferBaseAddress;
  }
  else {
    *(int *)(ConfigurationDataPointer + 8) = *(int *)(ConfigurationDataPointer + 8) + 1;
    if (*(int *)(ConfigurationDataPointer + 8) == 0x100) {
      LOCK();
      *(int *)(ResourceManagerPointer + 0x4c) = *(int *)(ResourceManagerPointer + 0x4c) + 1;
      UNLOCK();
    }
  }
  return 1;
}



/**
 * @brief 执行系统资源操作并返回状态
 * 
 * 该函数负责执行系统资源的操作，包括资源初始化、配置和状态检查。
 * 主要用于系统资源的管理和控制。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 操作状态，true表示成功，false表示失败
 * 
 * 原始函数名为FUN_180060f50，现已重命名为ExecuteSystemResourceOperation
 */
bool ExecuteSystemResourceOperation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  long long *plStackX_8;
  
  plStackX_8 = (long long *)0x0;
  charResult = ProcessSystemResourceData(*(void* *)(ResourceManagerPointer + 0x60),ResourceManagerPointer + 0x78,&plStackX_8,ConfigurationFlag,
                        0xfffffffffffffffe);
  PrimaryResourcePointer = plStackX_8;
  if (validationStatusFlag != '\0') {
    (**(code **)(*plStackX_8 + 0x60))(plStackX_8);
    (**(code **)(*PrimaryResourcePointer + 0x70))(PrimaryResourcePointer);
  }
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer);
  }
  return charResult != '\0';
}





// 函数: void SynchronizeSystemResources(long long *ResourceManagerPointer,long long *ConfigurationDataPointer)
/**
 * @brief 系统资源同步器函数
 * 
 * 该函数负责同步系统资源，确保资源状态的一致性。
 * 它会处理资源数据的同步操作，保持资源的最新状态。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要同步的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含同步所需的配置信息
 * @note 这是系统资源管理的重要组成部分，用于资源的同步和状态管理
 */
void SynchronizeSystemResources(long long *ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long localSystemHandle;
  long long *plocalResourceOffset;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  ulong long unsignedSystemValue9;
  void* systemOperationFlags;
  
  systemOperationFlags = 0xfffffffffffffffe;
  plocalResourceOffset = (long long *)ResourceManagerPointer[6];
  PrimaryResourcePointer = plocalResourceOffset + 1;
  if (PrimaryResourcePointer == (long long *)ResourceManagerPointer[8]) {
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer);
    }
    localDataIndex = *ResourceManagerPointer;
    bufferBaseAddress = ResourceManagerPointer[1];
    if (bufferBaseAddress <= (ResourceManagerPointer[9] - localDataIndex >> 3) + 1) {
      localSystemFlags = ResourceManagerPointer[5];
      unsignedSystemValue9 = localSystemFlags - localDataIndex >> 3;
      localMemoryAddress = ResourceManagerPointer[9] - localSystemFlags >> 3;
      localSystemHandle = localMemoryAddress * 8 + 8;
      if (unsignedSystemValue9 != 0) {
        currentThreadId = unsignedSystemValue9 >> 1;
        if (currentThreadId < 2) {
          currentThreadId = 1;
        }
          memmove(localDataIndex + (unsignedSystemValue9 - currentThreadId) * 8,localSystemFlags,localSystemHandle);
      }
      localSystemFlags = bufferBaseAddress;
      if (bufferBaseAddress == 0) {
        localSystemFlags = 1;
      }
      localSystemFlags = bufferBaseAddress + 2 + localSystemFlags;
      localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemFlags * 8,(char)ResourceManagerPointer[10],localDataIndex,systemOperationFlags);
      PrimaryResourcePointer = (long long *)(localDataIndex + (ResourceManagerPointer[5] - *ResourceManagerPointer >> 3) * 8);
      if (*ResourceManagerPointer != 0) {
          memcpy(PrimaryResourcePointer,ResourceManagerPointer[5],localSystemHandle);
      }
      *ResourceManagerPointer = localDataIndex;
      ResourceManagerPointer[1] = localSystemFlags;
      ResourceManagerPointer[5] = (long long)PrimaryResourcePointer;
      localDataIndex = *PrimaryResourcePointer;
      ResourceManagerPointer[3] = localDataIndex;
      ResourceManagerPointer[4] = localDataIndex + 0x100;
      ResourceManagerPointer[9] = (long long)(PrimaryResourcePointer + localMemoryAddress);
      localDataIndex = PrimaryResourcePointer[localMemoryAddress];
      ResourceManagerPointer[7] = localDataIndex;
      ResourceManagerPointer[8] = localDataIndex + 0x100;
    }
    systemOperationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x100,(char)ResourceManagerPointer[10]);
    *(void* *)(ResourceManagerPointer[9] + 8) = systemOperationFlags;
    *(long long **)ResourceManagerPointer[6] = ConfigurationDataPointer;
    localDataIndex = ResourceManagerPointer[9];
    ResourceManagerPointer[9] = localDataIndex + 8;
    localDataIndex = *(long long *)(localDataIndex + 8);
    ResourceManagerPointer[7] = localDataIndex;
    ResourceManagerPointer[8] = localDataIndex + 0x100;
    ResourceManagerPointer[6] = localDataIndex;
  }
  else {
    ResourceManagerPointer[6] = (long long)PrimaryResourcePointer;
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    *plocalResourceOffset = (long long)ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
  }
  return;
}





// 函数: void ValidateSystemResourceEx(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源验证器函数
 * 
 * 该函数负责验证系统资源的有效性和完整性。
 * 它会检查资源的状态和配置，确保资源可用。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要验证的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含验证所需的配置信息
 * @param AdditionalParameter 额外参数，用于特殊验证
 * @param ConfigurationFlag 配置标志，用于控制验证行为
 * @note 这是系统资源管理的重要组成部分，用于资源的验证和检查
 */
void ValidateSystemResourceEx(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  long long localSystemHandle;
  long long localResourceOffset;
  int systemIndex;
  long long SystemTimeValue;
  void* hashValue;
  uint8_t unsignedSystemValue7;
  
  hashValue = 0xfffffffffffffffe;
  localSystemPointer = ResourceManagerPointer + 0xf0;
  systemIndex = _Mtx_lock();
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  unsignedSystemValue7 = 1;
  InitializeSystemResourcePool(ResourceManagerPointer + 0x98,ConfigurationDataPointer);
  LOCK();
  *(int *)(ResourceManagerPointer + 0x140) = *(int *)(ResourceManagerPointer + 0x140) + 1;
  UNLOCK();
  pointerToUnsigned1 = *(void* **)(ResourceManagerPointer + 0x1f0);
  localSystemHandle = *(long long *)(SystemAllocationFlagsTemplate + 0x10);
  localResourceOffset = *(long long *)(SystemAllocationFlagsTemplate + 8);
  do {
    systemIndex = ReleaseSemaphore(*pointerToUnsigned1,localSystemHandle - localResourceOffset >> 3 & 0xffffffff,0,ConfigurationFlag,hashValue,localSystemPointer,unsignedSystemValue7);
  } while (systemIndex == 0);
  SystemThreadSyncBroadcast(ResourceManagerPointer + 0x150);
  systemIndex = _Mtx_unlock(localSystemPointer);
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




// 函数: void ReleaseSystemResourceEx(void* *ResourceManagerPointer)
/**
 * @brief 系统资源释放器函数
 * 
 * 该函数负责释放系统资源，清理内存和句柄。
 * 它会处理资源的释放操作，确保资源被正确清理。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要释放的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的释放和清理
 */
void ReleaseSystemResourceEx(void* *ResourceManagerPointer)

{
  CloseHandle(*ResourceManagerPointer);
  return;
}




// 函数: void ResetSystemResource(void* *ResourceManagerPointer)
/**
 * @brief 系统资源重置器函数
 * 
 * 该函数负责重置系统资源，恢复资源到初始状态。
 * 它会处理资源的重置操作，确保资源可以重新使用。
 * 
 * @param ResourceManagerPointer 系统资源指针数组，包含需要重置的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的重置和恢复
 */
void ResetSystemResource(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemMemoryData2;
  if (*(char*)((long long)ResourceManagerPointer + 0xb1) != '\0') {
    ValidateSystemMemoryStatus();
  }
  _Mtx_destroy_in_situ();
  *ResourceManagerPointer = &SystemResourceSecondaryTemplate;
  ResourceManagerPointer[7] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[8] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[8] = 0;
  *(uint32_t *)(ResourceManagerPointer + 10) = 0;
  ResourceManagerPointer[7] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[2] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[2] = 0;
  *(uint32_t *)(ResourceManagerPointer + 4) = 0;
  ResourceManagerPointer[1] = &SystemMemoryAllocatorReference;
  return;
}



/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统内存管理器，设置系统资源指针和内存数据。
 * 主要用于系统内存管理的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_180061300，现已重命名为InitializeSystemMemoryManager
 */
void* *
InitializeSystemMemoryManager(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  *ResourceManagerPointer = &SystemMemoryData2;
  if (*(char*)((long long)ResourceManagerPointer + 0xb1) != '\0') {
    ValidateSystemMemoryStatus();
  }
  _Mtx_destroy_in_situ();
  ReleaseSystemResourceManager(ResourceManagerPointer);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xb8,AdditionalParameter,ConfigurationFlag,systemStatus);
  }
  return ResourceManagerPointer;
}





// 函数: void StartInputSystem(void* ResourceManagerPointer,long long ConfigurationDataPointer)
void StartInputSystem(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  void* *HashNodePointer;
  uint8_t auStack_268 [32];
  long long lStack_248;
  void* *pointerUnsigned238;
  uint8_t auStack_230 [8];
  long long lStack_228;
  uint unsignedValue220;
  long long longValue210;
  uint8_t aunsignedValue208 [80];
  void* uStack_1b8;
  void* *puStack_1a8;
  uint8_t *psystemFlag1A0;
  uint32_t SystemStackFlag;
  uint8_t auStack_190 [88];
  uint8_t StackBuffer138 [256];
  ulong long uStack_38;
  
  localSystemHandle = SystemContextManagerPointer;
  nextDataIndex = SystemAllocationFlagsTemplate;
  uStack_1b8 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_268;
  longValue210 = SystemContextManagerPointer;
  puStack_1a8 = &SystemResourceTemplateSecondary;
  psystemFlag1A0 = auStack_190;
  auStack_190[0] = 0;
  SystemStackFlag = 6;
  strcpy_s(auStack_190,0x10,&SystemStringPathTemplate);
  HashNodePointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  lStack_248 = nextDataIndex + 0x70;
  pointerUnsigned238 = HashNodePointer;
  InitializeSystemMemoryContext(HashNodePointer,&puStack_1a8,3,nextDataIndex + 0x2e0);
  *HashNodePointer = &SystemValueReference;
  pointerUnsigned238 = HashNodePointer;
  ProcessHashNodeData(HashNodePointer);
  InitializeSystemHandle(nextDataIndex + 0x48,&pointerUnsigned238);
  *(void* **)(localSystemHandle + 400) = HashNodePointer;
  puStack_1a8 = &SystemMemoryAllocatorReference;
  ExecuteSystemConfigurationUpdate(SystemStatusFlagsPointer + 0x170,auStack_230,&SystemConfigurationData);
  if (0 < *(int *)(ConfigurationDataPointer + 0x10)) {
    ExecuteSystemCommand(auStack_230,unsignedValue220 + *(int *)(ConfigurationDataPointer + 0x10));
      memcpy((ulong long)unsignedValue220 + lStack_228,*(void* *)(ConfigurationDataPointer + 8),
           (long long)(*(int *)(ConfigurationDataPointer + 0x10) + 1));
  }
  InitializeSystemMemoryPool(aunsignedValue208,auStack_230);
  ConfigureSystemMemoryPool(aunsignedValue208,1);
    memset(StackBuffer138,0,0x100);
}





// 函数: void ValidateSystemComponent(long long *ResourceManagerPointer)
void ValidateSystemComponent(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  long long localResourceOffset;
  void* unsignedSystemValue4;
  long long *plocalSystemPointer;
  long long *plocalSystemFlags;
  long long *plocalDataIndex;
  long long *plStackX_8;
  long long **pplStackX_10;
  long long *plStackX_18;
  long long *plStackX_20;
  
  localResourceOffset = SystemContextManagerPointer;
  plStackX_8 = ResourceManagerPointer;
  unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,0xfffffffffffffffe);
  plocalSystemPointer = (long long *)AllocateSystemMemory(unsignedSystemValue4,0,localResourceOffset);
  plStackX_18 = plocalSystemPointer;
  if (plocalSystemPointer != (long long *)0x0) {
    (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
  }
  pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plocalSystemPointer;
  if (plocalSystemPointer != (long long *)0x0) {
    (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
  }
  (*pcharResult)(pointerToUnsigned1,&plStackX_8);
  unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  plocalSystemFlags = (long long *)AllocateSystemMemory(unsignedSystemValue4,4,localResourceOffset);
  plStackX_20 = plocalSystemFlags;
  if (plocalSystemFlags != (long long *)0x0) {
    (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
  }
  pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plocalSystemFlags;
  if (plocalSystemFlags != (long long *)0x0) {
    (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
  }
  (*pcharResult)(pointerToUnsigned1,&plStackX_8);
  unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  plocalDataIndex = (long long *)AllocateSystemMemory(unsignedSystemValue4,0,localResourceOffset);
  if (plocalDataIndex != (long long *)0x0) {
    pplStackX_10 = (long long **)plocalDataIndex;
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  plStackX_18 = plocalDataIndex;
  if (plocalSystemPointer != (long long *)0x0) {
    pplStackX_10 = (long long **)plocalSystemPointer;
    (**(code **)(*plocalSystemPointer + 0x38))(plocalSystemPointer);
  }
  pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plocalDataIndex;
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  (*pcharResult)(pointerToUnsigned1,&plStackX_8);
  ProcessSystemCallback(*(void* *)(localResourceOffset + 400));
  if (plocalSystemFlags != (long long *)0x0) {
    (**(code **)(*plocalSystemFlags + 0x38))(plocalSystemFlags);
  }
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x38))(plocalDataIndex);
  }
  return;
}





/**
 * @brief 初始化系统上下文管理器
 * 
 * 该函数负责初始化系统上下文管理器，分配系统内存并设置上下文管理所需的资源。
 * 主要用于系统上下文的创建和管理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向系统资源数据结构
 * 
 * 原始函数名为ProcessSystemValidation，现已重命名为InitializeSystemContextManager
 */
void InitializeSystemContextManager(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  long long localResourceOffset;
  void* unsignedSystemValue4;
  long long *plocalSystemPointer;
  long long *plocalSystemFlags;
  long long *plocalDataIndex;
  long long *plStackX_8;
  long long **pplStackX_10;
  long long *plStackX_18;
  long long *plStackX_20;
  
  localResourceOffset = SystemContextManagerPointer;
  plStackX_8 = ResourceManagerPointer;
  unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,0xfffffffffffffffe);
  plocalSystemPointer = (long long *)AllocateSystemMemory(unsignedSystemValue4,0,localResourceOffset);
  plStackX_18 = plocalSystemPointer;
  if (plocalSystemPointer != (long long *)0x0) {
    (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
  }
  pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plocalSystemPointer;
  if (plocalSystemPointer != (long long *)0x0) {
    (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
  }
  (*pcharResult)(pointerToUnsigned1,&plStackX_8);
  unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  plocalSystemFlags = (long long *)AllocateSystemMemory(unsignedSystemValue4,3,localResourceOffset);
  plStackX_20 = plocalSystemFlags;
  if (plocalSystemFlags != (long long *)0x0) {
    (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
  }
  pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plocalSystemFlags;
  if (plocalSystemFlags != (long long *)0x0) {
    (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
  }
  (*pcharResult)(pointerToUnsigned1,&plStackX_8);
  unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  plocalDataIndex = (long long *)AllocateSystemMemory(unsignedSystemValue4,0,localResourceOffset);
  if (plocalDataIndex != (long long *)0x0) {
    pplStackX_10 = (long long **)plocalDataIndex;
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  plStackX_18 = plocalDataIndex;
  if (plocalSystemPointer != (long long *)0x0) {
    pplStackX_10 = (long long **)plocalSystemPointer;
    (**(code **)(*plocalSystemPointer + 0x38))(plocalSystemPointer);
  }
  pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
  stringProcessingPointer = *(code **)*pointerToUnsigned1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plocalDataIndex;
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  (*pcharResult)(pointerToUnsigned1,&plStackX_8);
  ProcessSystemCallback(*(void* *)(localResourceOffset + 400));
  if (plocalSystemFlags != (long long *)0x0) {
    (**(code **)(*plocalSystemFlags + 0x38))(plocalSystemFlags);
  }
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x38))(plocalDataIndex);
  }
  return;
}




/**
 * @brief 执行系统数据操作
 * 
 * 该函数负责执行系统数据操作，处理系统级别的数据操作
 * 用于系统数据的管理和执行
 * 
 * @note 这是一个系统数据操作函数，用于系统数据管理的执行工作
 */
void ExecuteSystemDataOperation(void)

{
    SystemDataOperation();
}




/**
 * @brief 处理系统资源配置操作
 * 
 * 该函数负责处理系统资源配置操作，执行系统级别的资源配置
 * 用于系统资源的管理和配置
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_1800622d0，现已重命名为ProcessSystemResourceConfigurationOperation
 */
void ProcessSystemResourceConfigurationOperation(void* ResourceManagerPointer,void* ConfigurationDataPointer,uint32_t AdditionalParameter,void* ConfigurationFlag)

{
  ExecuteSystemDataOperation(ResourceManagerPointer,ConfigurationDataPointer,0xffffffff00000000,AdditionalParameter,ConfigurationFlag,&stack0x00000028);
  return;
}




// 函数: void UpdateContextManagerSystem(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void UpdateContextManagerSystem(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint64_t SystemInitializationFlag;
  void* uStackX_20;
  
  uStackX_18 = AdditionalParameter;
  uStackX_20 = ConfigurationFlag;
  ConfigureSystemResourceManager(ResourceManagerPointer,0,0xffffffff00000000,0xd,ConfigurationDataPointer,&uStackX_18);
  return;
}




/**
 * @brief 系统资源管理器更新函数
 * 
 * 该函数负责更新系统资源管理器，处理资源分配和配置
 * 用于系统资源管理器的动态更新
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_180062340，现已重命名为UpdateSystemResourceManager
 */
void UpdateSystemResourceManager(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* uStackX_20;
  
  uStackX_20 = ConfigurationFlag;
  ExecuteSystemDataOperation(ResourceManagerPointer,ConfigurationDataPointer,0xffffffff00000000,0xd,AdditionalParameter,&uStackX_20);
  return;
}




/**
 * @brief 系统管理器设置函数
 * 
 * 该函数负责设置系统管理器的状态和标志
 * 用于系统管理器的初始化和配置
 * 
 * @note 这是一个简单的系统管理器设置函数
 * 
 * 原始函数名为FUN_180062380，现已重命名为ConfigureSystemManager
 */
void ConfigureSystemManager(void)

{
  ExecuteSystemDataOperation();
  return;
}




// 函数: void SystemManagerSetFlags(void)
void SystemManagerSetFlags(void)

{
  InitializeSystemResourceManager();
  return;
}





// 函数: void InitializeSystemManager(long long *ResourceManagerPointer)
void InitializeSystemManager(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  long long localResourceOffset;
  void* unsignedSystemValue4;
  long long *plocalSystemPointer;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  
  localResourceOffset = SystemContextManagerPointer;
  if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
    plStackX_8 = ResourceManagerPointer;
    unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,0xfffffffffffffffe);
    plocalSystemPointer = (long long *)AllocateSystemMemory(unsignedSystemValue4,6,localResourceOffset);
    plStackX_10 = plocalSystemPointer;
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
    }
    pointerToUnsigned1 = *(void* **)(localResourceOffset + 400);
    stringProcessingPointer = *(code **)*pointerToUnsigned1;
    pplStackX_18 = &plStackX_8;
    plStackX_8 = plocalSystemPointer;
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x28))(plocalSystemPointer);
    }
    (*pcharResult)(pointerToUnsigned1,&plStackX_8);
    ProcessSystemCallback(*(void* *)(localResourceOffset + 400));
    if (plocalSystemPointer != (long long *)0x0) {
      (**(code **)(*plocalSystemPointer + 0x38))(plocalSystemPointer);
    }
  }
  return;
}





// 函数: void ConfigureInputSystem(void)
void ConfigureInputSystem(void)

{
  uint8_t aunsignedValue208 [48];
  uint32_t uStack_1d8;
  void* uStack_190;
  void* unsignedValue188;
  void* unsignedValue180;
  void* systemFlag178;
  uint8_t StackBuffer138 [256];
  ulong long uStack_38;
  
  systemFlag178 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue208;
  uStack_1d8 = 0;
  unsignedValue180 = SystemContextManagerPointer;
  uStack_190 = _time64(0);
  unsignedValue188 = _localtime64(&uStack_190);
    memset(StackBuffer138,0,0xff);
}





/**
 * @brief 处理系统资源计数器
 * 
 * 该函数负责处理系统资源的计数器操作，包括资源计数器的递增、
 * 校验和验证以及系统对象的创建。用于系统资源的统计和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于管理资源计数器
 * 
 * 原始函数名为FUN_180062920，现已重命名为ProcessSystemResourceCounter
 */
void ProcessSystemResourceCounter(int *ResourceManagerPointer)

{
  char SystemNodeFlag;
  char validationStatusFlag;
  uint32_t allocationContext;
  long long bufferBaseAddress;
  uint32_t *pcurrentThreadId;
  char *pcharSignal;
  void** SystemCurrentNode;
  int systemCode;
  ulong long unsignedSystemValue9;
  uint8_t auStack_1f8 [64];
  void*2 auStack_1b8 [4];
  void* *pointerUnsigned1b0;
  uint32_t *puStack_1a8;
  uint32_t systemFlag1A0;
  void* SystemStackFlag;
  uint32_t uStack_190;
  void* *SystemMemoryTemplatePtr;
  long long lStack_180;
  uint32_t uStack_170;
  long long lStack_168;
  long long lStack_160;
  void* uStack_158;
  uint32_t uStack_150;
  void* uStack_148;
  ulong long uStack_38;
  
  uStack_148 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_1f8;
  systemCode = 0;
  uStack_190 = 0;
  *ResourceManagerPointer = *ResourceManagerPointer + 1;
  if ((*(long long *)(ResourceManagerPointer + 4) != 0) && (*(long long *)(ResourceManagerPointer + 2) != 0)) {
      ValidateSystemChecksum(uStack_38 ^ (ulong long)auStack_1f8);
  }
  lStack_168 = 0;
  lStack_160 = 0;
  uStack_158 = 0;
  uStack_150 = 3;
  bufferBaseAddress = CreateSystemObject(&SystemMemoryTemplatePtr,SystemStatusFlagsPointer + 0x2c0);
  uStack_190 = 1;
  auStack_1b8[0] = 0x20;
  if (*(long long *)(bufferBaseAddress + 8) != 0) {
    ProcessSystemBufferData(bufferBaseAddress,&lStack_168,auStack_1b8);
  }
  uStack_190 = 0;
  SystemMemoryTemplatePtr = &SystemGlobalDataReference;
  if (lStack_180 != 0) {
      SystemCleanupFunction();
  }
  lStack_180 = 0;
  uStack_170 = 0;
  SystemMemoryTemplatePtr = &SystemMemoryAllocatorReference;
  pointerUnsigned1b0 = &SystemGlobalDataReference;
  SystemStackFlag = 0;
  puStack_1a8 = (uint32_t *)0x0;
  systemFlag1A0 = 0;
  pcurrentThreadId = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x13,0x13);
  *(uint8_t *)pcurrentThreadId = 0;
  puStack_1a8 = pcurrentThreadId;
  allocationContext = StartSystemThread(pcurrentThreadId);
  SystemStackFlag = CONCAT44(SystemStackFlag._4_4_,allocationContext);
  *pcurrentThreadId = 0x5f657375;
  pcurrentThreadId[1] = 0x65726170;
  pcurrentThreadId[2] = 0x635f746e;
  pcurrentThreadId[3] = 0x6f736e6f;
  *(void*2 *)(pcurrentThreadId + 4) = 0x656c;
  *(uint8_t *)((long long)pcurrentThreadId + 0x12) = 0;
  systemFlag1A0 = 0x12;
  unsignedSystemValue9 = lStack_160 - lStack_168 >> 5;
  if (unsignedSystemValue9 != 0) {
    HashBucketNode = (void* *)(lStack_168 + 8);
    do {
      if (*(int *)(HashBucketNode + 1) == 0x12) {
        pcharSignal = (char *)*HashBucketNode;
        bufferBaseAddress = (long long)pcurrentThreadId - (long long)pcharSignal;
        do {
          charStatus = *pcharSignal;
          charResult = pcharSignal[bufferBaseAddress];
          if (initializationStatusFlag != validationStatusFlag) break;
          pcharSignal = pcharSignal + 1;
        } while (validationStatusFlag != '\0');
        if (charStatus == charResult) break;
      }
      systemCode = systemCode + 1;
      HashBucketNode = HashBucketNode + 4;
    } while ((ulong long)(long long)systemCode < unsignedSystemValue9);
  }
  pointerUnsigned1b0 = &SystemGlobalDataReference;
    SystemCleanupFunction(pcurrentThreadId);
}




/**
 * @brief 系统控制台文本属性设置函数
 * 
 * 该函数根据配置数据指针的值来设置控制台文本属性，包括颜色和样式。
 * 用于系统输出和用户界面的显示控制。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针（用于选择文本属性）
 * @return 设置结果（成功返回1，失败返回0）
 * 
 * 原始函数名为FUN_180062ee0，现已重命名为SetSystemConsoleTextAttribute
 */
void* SetSystemConsoleTextAttribute(void* ResourceManagerPointer,uint32_t ConfigurationDataPointer)

{
  void*2 systemStatus;
  int systemResult;
  
  switch(ConfigurationDataPointer) {
  case 0:
    systemStatus = 4;
    break;
  case 1:
    systemStatus = 2;
    break;
  case 2:
    systemStatus = 1;
    break;
  case 3:
    systemStatus = 0xc;
    break;
  case 4:
    systemStatus = 10;
    break;
  case 5:
    systemStatus = 9;
    break;
  case 6:
    systemStatus = 3;
    break;
  case 7:
    systemStatus = 0xb;
    break;
  case 8:
    systemStatus = 6;
    break;
  case 9:
    systemStatus = 0xe;
    break;
  case 10:
    systemStatus = 5;
    break;
  case 0xb:
    systemStatus = 0xd;
    break;
  case 0xc:
    systemStatus = 7;
    break;
  default:
    systemStatus = 0xf;
  }
  systemResult = SetConsoleTextAttribute(ConsoleHandle,systemStatus);
  if (systemResult == 0) {
    InitializeSystemConfigurationData(&SystemConfigurationData);
    return 0;
  }
  return 1;
}





/**
 * @brief 分发系统资源和创建线程
 * 
 * 该函数负责分发系统资源，根据不同的系统状态创建相应的线程。
 * 处理系统资源的分配、线程创建和初始化工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源状态和配置信息
 * 
 * 原始函数名为FUN_180062fd0，现已重命名为DispatchSystemResourcesAndCreateThreads
 */
void DispatchSystemResourcesAndCreateThreads(long long ResourceManagerPointer)

{
  uint systemStatus;
  uint creationFlags;
  uint32_t allocationContext;
  int systemIndex;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  long long *plocalDataIndex;
  int systemCode;
  void* *punsignedSystemValue9;
  void* *pointerToUnsigned10;
  uint auStackX_8 [4];
  uint8_t auStackX_18 [8];
  uint auStackX_20 [2];
  void* *pprocessFlags70;
  void* *pEncryptionValue68;
  uint32_t unsignedValue60;
  void* processFlags58;
  
  systemStatus = *(uint *)(ResourceManagerPointer + 0x28);
  if (systemStatus < 9) {
    switch(systemStatus) {
    case 1:
      auStackX_8[0] = auStackX_8[0] & 0xffffff00;
      punsignedSystemValue9 = &SystemStringTemplate;
      if (*(void* **)(ResourceManagerPointer + 0x38) != (void* *)0x0) {
        punsignedSystemValue9 = *(void* **)(ResourceManagerPointer + 0x38);
      }
      ProcessSystemMemoryOperation(*(long long *)(ResourceManagerPointer + 0x20) + 0x20,punsignedSystemValue9,auStackX_8);
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x20);
      (**(code **)(*plocalDataIndex + 0x108))(plocalDataIndex,1);
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x20);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam1);
      pprocessFlags70 = &SystemGlobalDataReference;
      processFlags58 = 0;
      pEncryptionValue68 = (void* *)0x0;
      unsignedValue60 = 0;
      pcurrentThreadId = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
      *(uint8_t *)pcurrentThreadId = 0;
      pEncryptionValue68 = pcurrentThreadId;
      allocationContext = StartSystemThread(pcurrentThreadId);
      processFlags58 = CONCAT44(processFlags58._4_4_,allocationContext);
      *pcurrentThreadId = 0x73726f7272655f;
      unsignedValue60 = 7;
      systemCode = *(int *)(ResourceManagerPointer + 0x40) + -1;
      if (-1 < systemCode) {
        localSystemFlags = (long long)systemCode;
        do {
          if (*(char *)(localSystemFlags + *(long long *)(ResourceManagerPointer + 0x38)) == '_') goto code_r0x0001800630e9;
          systemCode = systemCode + -1;
          localSystemFlags = localSystemFlags + -1;
        } while (-1 < localSystemFlags);
      }
      systemCode = -1;
code_r0x0001800630e9:
      ExecuteSystemCodeOperation(ResourceManagerPointer + 0x30,systemCode,&pprocessFlags70);
      pprocessFlags70 = &SystemGlobalDataReference;
        SystemCleanupFunction(pcurrentThreadId);
    case 2:
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam2);
      ValidateSystemMemoryStatus(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8);
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x20);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam2);
      ValidateSystemMemoryStatus(*(long long *)(ResourceManagerPointer + 0x20) + 0x20);
      if (((*(byte *)(*(long long *)(ResourceManagerPointer + 0x20) + 8) & 2) != 0) &&
         (iRam0000000180c912e0 = iRam0000000180c912e0 + -1, iRam0000000180c912e0 == 0)) {
        ConsoleHandle = 0;
        lRam0000000180c912e8 = 0;
        LOCK();
        SystemGlobalCounter = 0;
        UNLOCK();
        FreeConsole();
      }
      *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x20) + 8) = 0xe;
      *(void* *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x10) = 0xffffffff00000000;
      *(uint8_t *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x18) = 0;
      **(void* **)(ResourceManagerPointer + 0x20) = 0;
      break;
    case 3:
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam2);
      ValidateSystemMemoryStatus(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8);
      CleanupSystemMemoryResources(*(long long *)(ResourceManagerPointer + 0x20) + 0xe0);
      break;
    case 4:
      auStackX_18[0] = 0;
      punsignedSystemValue9 = *(void* **)(*(long long *)(ResourceManagerPointer + 0x20) + 0xe8);
      pointerToUnsigned10 = &SystemStringTemplate;
      if (punsignedSystemValue9 != (void* *)0x0) {
        pointerToUnsigned10 = punsignedSystemValue9;
      }
      ProcessSystemMemoryOperation(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8,pointerToUnsigned10,auStackX_18);
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x108))(plocalDataIndex,1);
      plocalDataIndex = (long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam1);
      break;
    case 5:
      systemCode = *(int *)(ResourceManagerPointer + 0x58);
      if ((*(int *)(SystemStatusFlags + 0x150) <= systemCode) &&
         (pcurrentThreadId = *(void* **)(ResourceManagerPointer + 0x20),
         (*(ulong long *)(ResourceManagerPointer + 0x60) & pcurrentThreadId[2]) != 0)) {
        creationFlags = *(uint *)(ResourceManagerPointer + 0x40);
        punsignedSystemValue9 = &SystemStringTemplate;
        if (*(void* **)(ResourceManagerPointer + 0x38) != (void* *)0x0) {
          punsignedSystemValue9 = *(void* **)(ResourceManagerPointer + 0x38);
        }
        if ((*(byte *)(pcurrentThreadId + 1) & 2) != 0) {
          ExecuteSystemFunctionCall((ulong long)*(uint *)(&SystemFunctionTablePtr + (long long)(int)systemStatus * 4) +
                        0x180000000,*(uint32_t *)(ResourceManagerPointer + 0x50));
          systemIndex = WriteConsoleA(ConsoleHandle,punsignedSystemValue9,creationFlags,auStackX_20,0);
          if ((systemIndex == 0) || (auStackX_20[0] < creationFlags)) {
            InitializeSystemConfigurationData(&SystemDataBufferTemplateA,punsignedSystemValue9);
          }
          systemIndex = SetConsoleTextAttribute(ConsoleHandle,0xf);
          if (systemIndex == 0) {
            InitializeSystemConfigurationData(&SystemConfigurationData);
          }
        }
        if ((*(byte *)(pcurrentThreadId + 1) & 8) != 0) {
          (**(code **)(pcurrentThreadId[4] + 0x70))(pcurrentThreadId + 4,punsignedSystemValue9);
          if (1 < systemCode) {
            (**(code **)(pcurrentThreadId[0x1b] + 0x70))(pcurrentThreadId + 0x1b,punsignedSystemValue9);
          }
        }
        if ((code *)*pcurrentThreadId != (code *)0x0) {
          (*(code *)*pcurrentThreadId)(punsignedSystemValue9);
        }
      }
      break;
    case 6:
      if ((*(byte *)(*(long long *)(ResourceManagerPointer + 0x20) + 8) & 8) != 0) {
        (**(code **)(*(long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x20) + 0x118))();
        (**(code **)(*(long long *)(*(long long *)(ResourceManagerPointer + 0x20) + 0xd8) + 0x118))();
      }
      break;
    case 7:
      *(void* *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x10) = *(void* *)(ResourceManagerPointer + 0x60);
      break;
    case 8:
      if ((ConsoleHandle != 0) && (lRam0000000180c912e8 != 0)) {
        auStackX_8[0] = *(uint *)(ResourceManagerPointer + 0x68);
        SetConsoleScreenBufferSize(ConsoleHandle,auStackX_8[0]);
      }
    }
  }
  else {
    ConfigureSystemParameters(&SystemConfigurationParam3);
  }
  return;
}



/**
 * @brief 格式化系统资源字符串
 * 
 * 该函数负责格式化系统资源的字符串，使用类似printf的格式化功能。
 * 主要用于系统资源字符串的格式化和输出。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 格式化结果状态码，-1表示失败
 * 
 * 原始函数名为FUN_1800634b0，现已重命名为FormatSystemResourceString
 */
int FormatSystemResourceString(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  void** SystemDataTable;
  void* uStackX_20;
  
  uStackX_20 = ConfigurationFlag;
  HashEntryStatus = (void* *)SystemGlobalDataAllocate();
  systemStatus = __stdio_common_vsprintf_s(*HashEntryStatus,ResourceManagerPointer,ConfigurationDataPointer,AdditionalParameter,0,&uStackX_20);
  if (systemStatus < 0) {
    systemStatus = -1;
  }
  return systemStatus;
}



/**
 * @brief 搜索系统资源
 * 
 * 该函数负责在系统资源中搜索匹配的配置数据，通过遍历资源表
 * 和比较配置参数来查找符合条件的系统资源。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源表信息
 * @param ConfigurationDataPointer 配置数据指针，包含搜索条件
 * @return 找到的资源索引或相关状态信息
 * 
 * 原始函数名为FUN_180063510，现已重命名为SearchSystemResource
 */
ulong long SearchSystemResource(long long *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  byte *pisByteValid;
  uint creationFlags;
  uint allocationContext;
  long long bufferBaseAddress;
  ulong long in_RAX;
  byte *pisMemoryReady;
  uint hashValue;
  ulong long unsignedSystemValue7;
  long long localMemoryAddress;
  int systemId;
  long long allocationFlags;
  
  bufferBaseAddress = *ResourceManagerPointer;
  systemId = 0;
  unsignedSystemValue7 = ResourceManagerPointer[1] - bufferBaseAddress >> 5;
  if (unsignedSystemValue7 != 0) {
    creationFlags = *(uint *)(ConfigurationDataPointer + 0x10);
    allocationFlags = 0;
    do {
      allocationContext = *(uint *)(allocationFlags + 0x10 + bufferBaseAddress);
      pisMemoryReady = (byte *)(ulong long)allocationContext;
      hashValue = creationFlags;
      if (allocationContext == creationFlags) {
        if (allocationContext != 0) {
          pisMemoryReady = *(byte **)(allocationFlags + 8 + bufferBaseAddress);
          localMemoryAddress = *(long long *)(ComparisonDataPointer + 8) - (long long)pisMemoryReady;
          do {
            pisByteValid = pisMemoryReady + localMemoryAddress;
            hashValue = (uint)*pisMemoryReady - (uint)*pisByteValid;
            if (hashValue != 0) break;
            pisMemoryReady = pisMemoryReady + 1;
          } while (*pisByteValid != 0);
        }
LAB_18006357e:
        if (hashValue == 0) {
          return CONCAT71((int7)((ulong long)pisMemoryReady >> 8),1);
        }
      }
      else if (allocationContext == 0) goto LAB_18006357e;
      systemId = systemId + 1;
      allocationFlags = allocationFlags + 0x20;
      in_RAX = (ulong long)systemId;
    } while (in_RAX < unsignedSystemValue7);
  }
  return in_RAX & 0xffffffffffffff00;
}




/**
 * @brief 初始化系统字符串格式化
 * 
 * 该函数负责初始化系统字符串格式化功能，调用相应的
 * 格式化初始化函数来设置字符串处理环境。
 * 
 * 原始函数名为FUN_1800635c0，现已重命名为InitializeSystemStringFormatting
 */
void InitializeSystemStringFormatting(void)

{
  FinalizeSystemInitialization();
  return;
}



/**
 * @brief 格式化系统资源字符串（扩展版本）
 * 
 * 该函数负责格式化系统资源的字符串，使用扩展的格式化功能。
 * 主要用于系统资源字符串的格式化和输出，支持额外的格式化选项。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 格式化结果状态码，-1表示失败
 * 
 * 原始函数名为FUN_1800635e0，现已重命名为FormatSystemResourceStringExtended
 */
int FormatSystemResourceStringExtended(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  ulong long *HashEntryStatus;
  
  HashEntryStatus = (ulong long *)SystemGlobalDataAllocate();
  systemStatus = __stdio_common_vsprintf(*HashEntryStatus | 2,ResourceManagerPointer,ConfigurationDataPointer,AdditionalParameter,0,ConfigurationFlag);
  if (systemStatus < 0) {
    systemStatus = -1;
  }
  return systemStatus;
}



/**
 * @brief 配置系统资源
 * 
 * 该函数负责配置系统资源，设置系统全局数据引用和内存分配器引用。
 * 主要用于系统资源的配置和初始化。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_180063650，现已重命名为ConfigureSystemResources
 */
void* *
ConfigureSystemResources(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ResourceManagerPointer[6] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[7] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[7] = 0;
  *(uint32_t *)(ResourceManagerPointer + 9) = 0;
  ResourceManagerPointer[6] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x70,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}



void* *
AllocateSystemMemory(void* *ResourceManagerPointer,uint32_t ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(ResourceManagerPointer + 2) = 0;
  UNLOCK();
  ResourceManagerPointer[3] = 0xffffffffffffffff;
  *ResourceManagerPointer = &SystemMemoryBufferTemplate;
  PrimaryResourcePointer = ResourceManagerPointer + 6;
  *PrimaryResourcePointer = (long long)&SystemMemoryAllocatorReference;
  ResourceManagerPointer[7] = 0;
  *(uint32_t *)(ResourceManagerPointer + 8) = 0;
  *PrimaryResourcePointer = (long long)&SystemGlobalDataReference;
  ResourceManagerPointer[9] = 0;
  ResourceManagerPointer[7] = 0;
  *(uint32_t *)(ResourceManagerPointer + 8) = 0;
  *(uint32_t *)(ResourceManagerPointer + 5) = ConfigurationDataPointer;
  ResourceManagerPointer[4] = AdditionalParameter;
  (**(code **)(*PrimaryResourcePointer + 0x10))(PrimaryResourcePointer,&SystemStringTemplate,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  *(uint32_t *)(ResourceManagerPointer + 10) = 0xd;
  *(void* *)((long long)ResourceManagerPointer + 0x54) = 0xe;
  ResourceManagerPointer[0xc] = 0xffffffff00000000;
  *(uint32_t *)(ResourceManagerPointer + 0xd) = 0;
  return ResourceManagerPointer;
}



/**
 * InitializeSecurityCallbackStructure - 初始化安全回调结构
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回初始化后的系统资源指针
 * 
 * 原始函数名为FUN_1800637c0，现已重命名为InitializeSecurityCallbackStructure
 */
long long InitializeSecurityCallbackStructure(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(code **)(ResourceManagerPointer + 0x18) = SystemSecurityValidationCallback;
  return ResourceManagerPointer;
}



/**
 * InitializeGuardCallbackStructure - 初始化保护回调结构
 * @param ResourceManagerPointer 系统资源指针
 * @return 返回初始化后的系统资源指针
 * 
 * 原始函数名为FUN_1800637f0，现已重命名为InitializeGuardCallbackStructure
 */
long long InitializeGuardCallbackStructure(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(code **)(ResourceManagerPointer + 0x18) = _guard_check_icall;
  return ResourceManagerPointer;
}





/**
 * InitializeSecurityContext - 初始化安全上下文
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_180063820，现已重命名为InitializeSecurityContext
 */
void InitializeSecurityContext(void* ResourceManagerPointer)

{
  uint8_t securityBuffer [96];
  uint8_t configurationBuffer [64];
  void* stackValue1;
  void* contextValue;
  uint8_t memoryBuffer [512];
  ulong long securityKey;
  
  stackValue1 = 0xfffffffffffffffe;
  securityKey = SystemEncryptionKeyTemplate ^ (ulong long)securityBuffer;
  contextValue = ResourceManagerPointer;
  CreateSystemObject(configurationBuffer,SystemContextManagerPointer + 0x28);
    memset(memoryBuffer,0,0x200);
}





/**
 * ConfigureSecurityParameters - 配置安全参数
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180063b30，现已重命名为ConfigureSecurityParameters
 */
void ConfigureSecurityParameters(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  char *stringPointer;
  void* *dataPointer;
  long long stringLength;
  long long loopCounter1;
  long long SystemTimeValue;
  long long fileHandle;
  void* stackValue1;
  long long outputStream;
  void* *stackPointer1;
  void* *stackPointer2;
  uint32_t stackValue2;
  
  stackValue1 = 0;
  outputStream = 0;
  AllocateSystemStackMemory(ResourceManagerPointer,&stackPointer1,&SystemStackAllocationTemplate);
  dataPointer = &SystemStringTemplate;
  if (stackPointer2 != (void* *)0x0) {
    dataPointer = stackPointer2;
  }
  ProcessSystemResourceData(&stackValue1,dataPointer,&SystemEventTemplate);
  fileHandle = outputStream;
  SystemTimeValue = -1;
  stringLength = SystemTimeValue;
  loopCounter1 = SystemTimeValue;
  if (ConfigurationDataPointer != 0) {
    do {
      stringLength = stringLength + 1;
    } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
    if (stringLength != 0) {
      fwrite(ConfigurationDataPointer,stringLength,1,outputStream);
    }
  }
  do {
    stringLength = loopCounter1 + 1;
    stringPointer = (char *)(loopCounter1 + 0x180c84871);
    loopCounter1 = stringLength;
  } while (*stringPointer != '\0');
  if (stringLength != 0) {
    fwrite(&SystemFileTemplateBuffer,0x30,1,fileHandle);
    fwrite(&SystemStringBuffer,stringLength,1,fileHandle);

/**
 * @brief 系统资源清理和验证函数
 * 
 * 该函数负责清理系统资源，包括：
 * 1. 遍历和清理系统资源表
 * 2. 验证系统内存完整性
 * 3. 执行系统清理回调函数
 * 4. 释放系统资源并重置状态
 * 
 * 主要用于系统关闭或重置时的资源清理工作
 * 
 * @note 此函数包含复杂的资源管理逻辑和内存验证机制
 * @warning 调用此函数会释放所有系统资源，可能导致系统状态重置
 * 
 * 原始函数名为FUN_180063cf0，现已重命名为CleanupAndValidateSystemResources
 */
void CleanupAndValidateSystemResources(void)

{
  void* *pointerToUnsigned1;
  bool isSystemActive;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  int systemFlag;
  long long localDataIndex;
  long long localMemoryAddress;
  void* *punsignedSystemValue9;
  uint systemOperationFlags;
  void* *psystemStatus2;
  ulong long systemStatus3;
  int systemStatus4;
  long long nextDataIndex5;
  uint systemStatus6;
  uint8_t aunsignedValue2f8 [32];
  void* *punsignedValue2d8;
  void* *punsignedValue2d0;
  void* uStack_2c8;
  uint32_t uStack_2c0;
  void* *punsignedValue2b0;
  void* *pointerUnsigned2a8;
  void* uStack_2a0;
  uint32_t unsignedValue298;
  void* *punsignedValue290;
  long long lStack_288;
  uint32_t unsignedValue278;
  void* unsignedValue270;
  uint8_t auStack_268 [32];
  long long lStack_248;
  uint8_t auStack_238 [512];
  ulong long uStack_38;
  ulong long systemStatus1;
  
  unsignedValue270 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue2f8;
  systemStatus1 = 0;
  InitializeSystemStackPointer(&punsignedValue290);
  punsignedValue2d8 = (void* *)0x0;
  punsignedValue2d0 = (void* *)0x0;
  uStack_2c8 = 0;
  uStack_2c0 = 3;
  punsignedValue2b0 = (void* *)0x0;
  pointerUnsigned2a8 = (void* *)0x0;
  uStack_2a0 = 0;
  unsignedValue298 = 3;
  ConfigureSystemStackAllocation(&punsignedValue290,&punsignedValue2d8,&punsignedValue2b0);
  systemStatus4 = -1;
  nextDataIndex5 = -0x8000000000000000;
  systemStatus6 = (uint)((long long)punsignedValue2d0 - (long long)punsignedValue2d8 >> 5);
  systemStatus3 = systemStatus1;
  HashNodePointer = punsignedValue2d0;
  psystemStatus2 = punsignedValue2b0;
  punsignedSystemValue4 = pointerUnsigned2a8;
  if (systemStatus6 != 0) {
    do {
      systemFlag = *(int *)((long long)punsignedValue2d8 + systemStatus3 + 0x10);
      if (systemFlag < 4) {
LAB_180063de9:
        isSystemActive = false;
      }
      else {
        localDataIndex = 0;
        do {
          localMemoryAddress = localDataIndex + 1;
          if (*(char *)(*(long long *)((long long)punsignedValue2d8 + systemStatus3 + 8) + (long long)(systemFlag + -4) +
                       localDataIndex) != (&SystemMemoryOffsetTable)[localDataIndex]) goto LAB_180063de9;
          localDataIndex = localMemoryAddress;
        } while (localMemoryAddress != 5);
        isSystemActive = true;
      }
      if (isSystemActive) {
        pointerToUnsigned1 = *(void* **)((long long)punsignedValue2d8 + systemStatus3 + 8);
        punsignedSystemValue9 = &SystemStringTemplate;
        if (pointerToUnsigned1 != (void* *)0x0) {
          punsignedSystemValue9 = pointerToUnsigned1;
        }
        systemFlag = _stat64i32(punsignedSystemValue9,auStack_268);
        if ((systemFlag != -1) && (nextDataIndex5 < lStack_248)) {
          nextDataIndex5 = lStack_248;
          systemStatus4 = (int)systemStatus1;
        }
      }
      systemOperationFlags = (int)systemStatus1 + 1;
      systemStatus1 = (ulong long)systemOperationFlags;
      systemStatus3 = systemStatus3 + 0x20;
    } while (systemOperationFlags < systemStatus6);
    HashNodePointer = punsignedValue2d0;
    psystemStatus2 = punsignedValue2b0;
    punsignedSystemValue4 = pointerUnsigned2a8;
    if (-1 < systemStatus4) {
        memset(auStack_238,0,0x200);
    }
  }
  for (; pcurrentThreadId = pointerUnsigned2a8, punsignedValue2d0 = HashNodePointer, psystemStatus2 != pointerUnsigned2a8; psystemStatus2 = psystemStatus2 + 4)
  {
    pointerUnsigned2a8 = punsignedSystemValue4;
    (**(code **)*psystemStatus2)(psystemStatus2,0);
    HashNodePointer = punsignedValue2d0;
    punsignedSystemValue4 = pointerUnsigned2a8;
    pointerUnsigned2a8 = pcurrentThreadId;
  }
  if (punsignedValue2b0 == (void* *)0x0) {
    punsignedValue2b0 = (void* *)0x0;
    pointerUnsigned2a8 = punsignedSystemValue4;
    for (psystemStatus2 = punsignedValue2d8; psystemStatus2 != HashNodePointer; psystemStatus2 = psystemStatus2 + 4) {
      (**(code **)*psystemStatus2)(psystemStatus2,0);
    }
    if (punsignedValue2d8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    punsignedValue290 = &SystemGlobalDataReference;
    if (lStack_288 != 0) {
        SystemCleanupFunction();
    }
    lStack_288 = 0;
    unsignedValue278 = 0;
    punsignedValue290 = &SystemMemoryAllocatorReference;
      ValidateSystemChecksum(uStack_38 ^ (ulong long)aunsignedValue2f8);
  }
  pointerUnsigned2a8 = punsignedSystemValue4;
    SystemCleanupFunction();
}





/**
 * @brief 系统资源初始化和配置函数
 * 
 * 该函数负责初始化和配置系统资源，包括：
 * 1. 设置系统配置参数
 * 2. 初始化系统数据表和缓冲区
 * 3. 处理系统资源数据
 * 4. 初始化主要资源组件
 * 5. 管理文件句柄和引用计数
 * 
 * 主要用于系统资源的初始化和配置工作
 * 
 * @param ResourceManagerPointer 系统资源指针，用于标识和访问系统资源
 * 
 * @note 此函数包含复杂的资源初始化逻辑和文件句柄管理
 * @warning 调用此函数会修改系统状态，需要在合适的上下文中调用
 * 
 * 原始函数名为FUN_180064010，现已重命名为InitializeAndConfigureSystemResources
 */
void InitializeAndConfigureSystemResources(void* ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  uint8_t auStack_358 [64];
  void* *punsignedValue318;
  void* *pointerUnsigned310;
  void* unsignedValue308;
  uint32_t unsignedValue300;
  void* unsignedValue2f8;
  long long lStack_2f0;
  void* uStack_2e0;
  long long lStack_2d8;
  void* *pointerUnsigned2c0;
  void* *punsignedValue2b8;
  void* unsignedValue2b0;
  uint32_t uStack_2a8;
  void* *pointerUnsigned2a0;
  long long lStack_298;
  uint32_t EncryptionKeyValue8;
  void* *pEncryptionKeyValue0;
  void* *punsignedValue278;
  uint32_t uStack_268;
  void* *puStack_260;
  void* *pointerUnsigned258;
  uint32_t unsignedValue248;
  void* unsignedValue240;
  uint8_t auStack_238 [512];
  ulong long uStack_38;
  
  unsignedValue240 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_358;
  SetupSystemConfiguration(&pointerUnsigned2a0);
  punsignedValue318 = (void* *)0x0;
  pointerUnsigned310 = (void* *)0x0;
  unsignedValue308 = 0;
  unsignedValue300 = 3;
  pointerUnsigned2c0 = (void* *)0x0;
  punsignedValue2b8 = (void* *)0x0;
  unsignedValue2b0 = 0;
  uStack_2a8 = 3;
  ConfigureSystemStackAllocation(&pointerUnsigned2a0,&punsignedValue318,&pointerUnsigned2c0);
  HashEntryStatus = punsignedValue2b8;
  pointerToUnsigned1 = pointerUnsigned310;
  punsignedSystemValue4 = pointerUnsigned2c0;
  if ((int)((long long)pointerUnsigned310 - (long long)punsignedValue318 >> 5) != 0) {
      memset(auStack_238,0,0x200);
  }
  for (; pointerUnsigned310 = pointerToUnsigned1, punsignedSystemValue4 != HashEntryStatus; punsignedSystemValue4 = punsignedSystemValue4 + 4) {
    (**(code **)*punsignedSystemValue4)(punsignedSystemValue4,0);
    pointerToUnsigned1 = pointerUnsigned310;
  }
  if (pointerUnsigned2c0 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned2c0 = (void* *)0x0;
  for (punsignedSystemValue4 = punsignedValue318; punsignedSystemValue4 != pointerToUnsigned1; punsignedSystemValue4 = punsignedSystemValue4 + 4) {
    (**(code **)*punsignedSystemValue4)(punsignedSystemValue4,0);
  }
  if (punsignedValue318 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned2a0 = &SystemGlobalDataReference;
  if (lStack_298 != 0) {
      SystemCleanupFunction();
  }
  lStack_298 = 0;
  EncryptionKeyValue8 = 0;
  pointerUnsigned2a0 = &SystemMemoryAllocatorReference;
  unsignedValue2f8 = 0;
  lStack_2f0 = 0;
  AllocateSystemStackMemory(ResourceManagerPointer,&pEncryptionKeyValue0,&SystemDataBufferTemplate1);
  HashNodePointer = &SystemStringTemplate;
  if (punsignedValue278 != (void* *)0x0) {
    HashNodePointer = punsignedValue278;
  }
  ProcessSystemResourceData(&unsignedValue2f8,HashNodePointer,&SystemEventTemplate);
  InitializePrimaryResource(SystemNodeManagerPointer,&unsignedValue2f8);
  if (lStack_2f0 != 0) {
    fclose();
    lStack_2f0 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  pEncryptionKeyValue0 = &SystemGlobalDataReference;
  if (punsignedValue278 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  punsignedValue278 = (void* *)0x0;
  uStack_268 = 0;
  pEncryptionKeyValue0 = &SystemMemoryAllocatorReference;
  if (lStack_2f0 != 0) {
    fclose();
    lStack_2f0 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  uStack_2e0 = 0;
  lStack_2d8 = 0;
  ConfigureSystemResources(ResourceManagerPointer,&puStack_260,&SystemDataBufferTemplate2);
  HashNodePointer = &SystemStringTemplate;
  if (pointerUnsigned258 != (void* *)0x0) {
    HashNodePointer = pointerUnsigned258;
  }
  ProcessSystemResourceData(&uStack_2e0,HashNodePointer,&SystemEventTemplate);
  InitializePrimaryResource(SystemMemoryManagerPointer,&uStack_2e0);
  if (lStack_2d8 != 0) {
    fclose();
    lStack_2d8 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  puStack_260 = &SystemGlobalDataReference;
  if (pointerUnsigned258 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned258 = (void* *)0x0;
  unsignedValue248 = 0;
  puStack_260 = &SystemMemoryAllocatorReference;
  if (lStack_2d8 != 0) {
    fclose();
    lStack_2d8 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
    ValidateSystemChecksum(uStack_38 ^ (ulong long)auStack_358);
}




/**
 * @brief 系统数据操作执行函数
 * 
 * 该函数负责执行系统数据操作，调用核心的数据处理功能
 * 用于系统运行时的数据处理和管理
 * 
 * @note 这是一个简化的系统操作函数，主要用于触发数据操作
 * @warning 调用此函数会执行系统数据操作，可能影响系统状态
 * 
 * 原始函数名为FUN_180064400，现已重命名为ExecuteSystemDataOperation
 */
void ExecuteSystemDataOperation(void)

{
    SystemDataOperation();
}




/**
 * @brief 系统资源处理和数据管理函数
 * 
 * 该函数负责处理系统资源并管理相关数据，包括：
 * 1. 执行系统数据操作
 * 2. 初始化系统管理器
 * 3. 处理内存分配和缓冲区
 * 4. 配置系统数据缓冲区
 * 5. 管理文件操作和引用计数
 * 6. 清理系统资源
 * 
 * 主要用于系统资源的综合处理和管理
 * 
 * @param ResourceManagerPointer 系统资源指针，用于标识和访问系统资源
 * @return 处理结果状态码，表示操作的成功或失败状态
 * 
 * @note 此函数包含复杂的资源管理和数据处理逻辑
 * @warning 调用此函数会执行系统资源处理，可能影响系统状态
 * 
 * 原始函数名为FUN_1800649d0，现已重命名为ProcessAndManageSystemResources
 */
ulong long ProcessAndManageSystemResources(void* ResourceManagerPointer)

{
  char SystemNodeFlag;
  ulong long creationFlags;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void* *systemGlobalDataPtrB8;
  long long lStack_b0;
  int iStack_a8;
  ulong long UnsignedStackFlagA0;
  void* *stackParameterB;
  void* *pStackParameterC;
  void* UnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  void* UnsignedStackFlag78;
  long long lStack_70;
  void* *memoryAllocationBuffer;
  void* *memoryAllocationEnd;
  uint32_t unsignedValue40;
  void* uStack_38;
  
  uStack_38 = 0xfffffffffffffffe;
  stackParameterB = (void* *)0x0;
  pSystemConfigurationValue = (void* *)0x0;
  UnsignedStackFlag88 = 0;
  UnsignedStackFlag80 = 3;
  SystemConfigurationResult = ConfigureSystemResourceManager(&stackParameterB);
  HashBucketNode = pStackParameterC;
  resourceEntryPointer = stackParameterB;
  if ((SystemConfigurationResult == '\0') || (stackParameterB == pStackParameterC)) {
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemDataBufferTemplate3);
    creationFlags = InitializeSystemManager();
    punsignedSystemValue4 = resourceEntryPointer;
  }
  else {
    SystemMemoryAllocationFlag = 0;
    SystemMemoryAllocationHandle = 0;
    InitializeSystemMemoryAllocation(ResourceManagerPointer,&memoryAllocationBuffer,&SystemDataBufferTemplate4);
    HashNodePointer = &SystemStringTemplate;
    if (memoryAllocationEnd != (void* *)0x0) {
      HashNodePointer = memoryAllocationEnd;
    }
    ProcessSystemResourceData(&SystemMemoryAllocationFlag,HashNodePointer,&SystemEventTemplate);
    creationFlags = (long long)HashBucketNode - (long long)resourceEntryPointer >> 5;
    systemGlobalDataPtrB8 = &SystemGlobalDataReference;
    SystemMemoryAllocationOffset = 0;
    SystemMemoryAllocationSize = 0;
    SystemMemoryAllocationCount = 0;
    if ((int)creationFlags != 0) {
      punsignedSystemValue4 = resourceEntryPointer + 1;
      creationFlags = creationFlags & 0xffffffff;
      do {
        HashNodePointer = &SystemStringTemplate;
        if ((void* *)*punsignedSystemValue4 != (void* *)0x0) {
          HashNodePointer = (void* *)*punsignedSystemValue4;
        }
        ConfigureSystemDataBuffer(&systemGlobalDataPtrB8,&SystemDataBufferTemplateA,HashNodePointer);
        punsignedSystemValue4 = punsignedSystemValue4 + 4;
        creationFlags = creationFlags - 1;
      } while (creationFlags != 0);
    }
    localSystemPointer = SystemMemoryAllocationHandle;
    creationFlags = fwrite(SystemMemoryAllocationSize,1,(long long)SystemMemoryAllocationCount,SystemMemoryAllocationHandle);
    if (localSystemPointer != 0) {
      fclose(localSystemPointer);
      SystemMemoryAllocationHandle = 0;
      LOCK();
      creationFlags = (ulong long)SystemReferenceCounterStorage;
      UNLOCK();
      localSystemPointer = 0;
      resourceEntryPointer = stackParameterB;
      HashBucketNode = pStackParameterC;
      SystemReferenceCounterStorage = SystemReferenceCounterStorage - 1;
    }
    systemGlobalDataPtrB8 = &SystemGlobalDataReference;
    if (lStack_b0 != 0) {
        SystemCleanupFunction();
    }
    lStack_b0 = 0;
    UnsignedStackFlagA0 = UnsignedStackFlagA0 & 0xffffffff00000000;
    systemGlobalDataPtrB8 = &SystemMemoryAllocatorReference;
    memoryAllocationBuffer = &SystemGlobalDataReference;
    if (memoryAllocationEnd != (void* *)0x0) {
        SystemCleanupFunction();
    }
    memoryAllocationEnd = (void* *)0x0;
    unsignedValue40 = 0;
    memoryAllocationBuffer = &SystemMemoryAllocatorReference;
    punsignedSystemValue4 = resourceEntryPointer;
    if (localSystemPointer != 0) {
      creationFlags = fclose(localSystemPointer);
      lStack_70 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage - 1;
      UNLOCK();
      resourceEntryPointer = stackParameterB;
      HashBucketNode = pStackParameterC;
      punsignedSystemValue4 = stackParameterB;
    }
  }
  for (; resourceEntryPointer != HashBucketNode; resourceEntryPointer = SystemCurrentNode + 4) {
    creationFlags = (**(code **)*resourceEntryPointer)(resourceEntryPointer,0);
  }
  if (punsignedSystemValue4 != (void* *)0x0) {
      SystemCleanupFunction(punsignedSystemValue4);
  }
  return creationFlags;
}





/**
 * @brief 系统资源数据配置和管理函数
 * 
 * 该函数负责配置和管理系统资源数据，包括：
 * 1. 初始化配置数据
 * 2. 处理字符串和缓冲区数据
 * 3. 执行内存分配和管理
 * 4. 配置系统资源指针
 * 5. 管理数据缓冲区和线程对象
 * 
 * 主要用于系统资源数据的配置和管理工作
 * 
 * @param ResourceManagerPointer 系统资源指针数组，用于存储和管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含系统配置信息
 * @param AdditionalParameter 额外参数，用于传递额外的配置信息
 * 
 * @note 此函数包含复杂的数据配置和内存管理逻辑
 * @warning 调用此函数会修改系统资源配置，可能影响系统状态
 * 
 * 原始函数名为FUN_180064c00，现已重命名为ConfigureAndManageSystemResourceData
 */
void ConfigureAndManageSystemResourceData(long long *ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  uint systemStatus;
  int systemResult;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  uint8_t *pcurrentThreadId;
  void* *resourceEntryPointer;
  uint *HashBucketNode;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  long long allocationFlags;
  long long nextDataIndex1;
  long long nextDataIndex2;
  ulong long systemStatus3;
  void* *pointerToUnsigned14;
  uint8_t encryptionBuffer [32];
  long long hashNodeOffset;
  void* *punsignedValue108;
  uint8_t *punsignedValue100;
  uint32_t unsignedValueF8;
  void* uStack_f0;
  uint32_t uStack_e8;
  void* *dataBufferPointer;
  void* unsignedValueD8;
  void* *dataBufferContext;
  uint8_t uStack_c8;
  void*7 uStack_c7;
  void* *systemGlobalDataPtrB8;
  ulong long threadBufferSize;
  uint UnsignedStackFlagA8;
  uint32_t uStack_a4;
  uint32_t UnsignedStackFlagA0;
  uint32_t uStack_9c;
  ulong long systemConfigurationValue;
  ulong long StackParameterC;
  uint8_t UnsignedStackFlag88;
  void*7 uStack_87;
  long long dataBufferLength;
  ulong long processFlags70;
  uint EncryptionValue68;
  uint32_t uStack_64;
  uint32_t unsignedValue60;
  uint32_t uStack_5c;
  ulong long processFlags58;
  ulong long unsignedValue50;
  ulong long EncryptionValue48;
  
  unsignedValueD8 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)encryptionBuffer;
  uStack_e8 = 0;
  InitializeConfigurationData();
  resourceEntryPointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    resourceEntryPointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  systemGlobalDataPtrB8 = (void* *)0x0;
  UnsignedStackFlagB0 = 0xf;
  uStack_c8 = 0;
  allocationFlags = -1;
  nextDataIndex2 = -1;
  do {
    nextDataIndex2 = nextDataIndex2 + 1;
  } while (resourceEntryPointer[nextDataIndex2] != '\0');
  ReallocateSystemDataBuffer(&uStack_c8);
  resourceEntryPointer = &SystemStringTemplate;
  if (*(void* **)(AdditionalParameter + 8) != (void* *)0x0) {
    resourceEntryPointer = *(void* **)(AdditionalParameter + 8);
  }
  lStack_78 = 0;
  processFlags70 = 0xf;
  UnsignedStackFlag88 = 0;
  do {
    allocationFlags = allocationFlags + 1;
  } while (resourceEntryPointer[allocationFlags] != '\0');
  ReallocateSystemDataBuffer(&UnsignedStackFlag88,resourceEntryPointer,allocationFlags);
  nextDataIndex2 = lStack_78;
  systemStatus = UnsignedStackFlagA8;
  systemConfigurationValue = 0;
  SystemConfigurationValue = 0xf;
  UnsignedStackFlagA8 = UnsignedStackFlagA8 & 0xffffff00;
  allocationFlags = CONCAT71(uStack_87,UnsignedStackFlag88);
  unsignedSystemValue9 = CONCAT44(uStack_a4,systemStatus) & 0xffffffffffffff00;
  pcurrentThreadId = &uStack_c8;
  if (0xf < threadBufferSize) {
    pcurrentThreadId = (uint8_t *)CONCAT71(uStack_c7,uStack_c8);
  }
  hashNodeOffset = dataBufferLength;
  HashNodePointer = (void* *)InitializeSystemResource(pcurrentThreadId,systemGlobalDataPtrB8);
  dataBufferPointer = HashNodePointer;
  if (HashNodePointer == (void* *)0xffffffffffffffff) {
    if (0xf < StackParameterC) {
      unsignedSystemValue8 = StackParameterC + 1;
      systemStatus3 = unsignedSystemValue9;
      if (0xfff < unsignedSystemValue8) {
        unsignedSystemValue8 = StackParameterC + 0x28;
        systemStatus3 = *(ulong long *)(unsignedSystemValue9 - 8);
        if (0x1f < (unsignedSystemValue9 - systemStatus3) - 8) {
            _invalid_parameter_noinfo_noreturn();
        }
      }
      free(systemStatus3,unsignedSystemValue8);
    }
    systemConfigurationValue = 0;
    SystemConfigurationValue = 0xf;
    UnsignedStackFlagA8 = UnsignedStackFlagA8 & 0xffffff00;
    if (0xf < processFlags70) {
      unsignedSystemValue9 = processFlags70 + 1;
      nextDataIndex2 = allocationFlags;
      if (0xfff < unsignedSystemValue9) {
        unsignedSystemValue9 = processFlags70 + 0x28;
        nextDataIndex2 = *(long long *)(allocationFlags + -8);
        if (0x1f < (allocationFlags - nextDataIndex2) - 8U) {
            _invalid_parameter_noinfo_noreturn();
        }
      }
      free(nextDataIndex2,unsignedSystemValue9);
    }
    lStack_78 = 0;
    processFlags70 = 0xf;
    UnsignedStackFlag88 = 0;
    if (0xf < threadBufferSize) {
      unsignedSystemValue9 = UnsignedStackFlagB0 + 1;
      nextDataIndex2 = CONCAT71(uStack_c7,uStack_c8);
      allocationFlags = nextDataIndex2;
      if (0xfff < unsignedSystemValue9) {
        unsignedSystemValue9 = UnsignedStackFlagB0 + 0x28;
        allocationFlags = *(long long *)(nextDataIndex2 + -8);
        if (0x1f < (nextDataIndex2 - allocationFlags) - 8U) {
            _invalid_parameter_noinfo_noreturn();
        }
      }
      free(allocationFlags,unsignedSystemValue9);
    }
    systemGlobalDataPtrB8 = (void* *)0x0;
    UnsignedStackFlagB0 = 0xf;
    uStack_c8 = 0;
      ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)encryptionBuffer);
  }
  processFlags58 = 0;
  unsignedValue50 = 0xf;
  EncryptionValue68 = EncryptionValue68 & 0xffffff00;
  punsignedSystemValue4 = HashNodePointer;
  if (systemGlobalDataPtrB8 < HashNodePointer) {
    punsignedSystemValue4 = systemGlobalDataPtrB8;
  }
  pcurrentThreadId = &uStack_c8;
  if (0xf < threadBufferSize) {
    pcurrentThreadId = (uint8_t *)CONCAT71(uStack_c7,uStack_c8);
  }
  ReallocateSystemDataBuffer(&EncryptionValue68,pcurrentThreadId,punsignedSystemValue4);
  uStack_e8 = 1;
  FreeSystemResourceMemory(&UnsignedStackFlagA8);
  unsignedSystemValue9 = processFlags58;
  systemStatus = EncryptionValue68;
  UnsignedStackFlagA8 = EncryptionValue68;
  uStack_a4 = uStack_64;
  UnsignedStackFlagA0 = unsignedValue60;
  uStack_9c = uStack_5c;
  SystemConfigurationValue = unsignedValue50;
  uStack_e8 = 0;
  processFlags58 = 0;
  unsignedValue50 = 0xf;
  EncryptionValue68 = EncryptionValue68 & 0xffffff00;
  systemConfigurationValue = unsignedSystemValue9;
  if (unsignedSystemValue9 == 0) goto LAB_180065009;
  allocationFlags = 0;
  punsignedValue108 = &SystemGlobalDataReference;
  uStack_f0 = 0;
  punsignedValue100 = (uint8_t *)0x0;
  unsignedValueF8 = 0;
  systemConfigurationValue._0_4_ = (int)unsignedSystemValue9;
  systemResult = (int)systemConfigurationValue;
  systemConfigurationValue = unsignedSystemValue9;
  ExecuteSystemCommand(&punsignedValue108,unsignedSystemValue9 & 0xffffffff);
  if (systemResult != 0) {
    HashBucketNode = &UnsignedStackFlagA8;
    if (0xf < StackParameterC) {
      HashBucketNode = (uint *)CONCAT44(uStack_64,systemStatus);
    }
      memcpy(punsignedValue100,HashBucketNode,unsignedSystemValue9 & 0xffffffff);
  }
  unsignedValueF8 = 0;
  if (punsignedValue100 != (uint8_t *)0x0) {
    *punsignedValue100 = 0;
  }
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
  if (punsignedSystemValue4 < (void* *)ResourceManagerPointer[2]) {
    ResourceManagerPointer[1] = (long long)(punsignedSystemValue4 + 4);
    *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
    punsignedSystemValue4[1] = 0;
    *(uint32_t *)(punsignedSystemValue4 + 2) = 0;
    *punsignedSystemValue4 = &SystemGlobalDataReference;
    punsignedSystemValue4[3] = 0;
    punsignedSystemValue4[1] = 0;
    *(uint32_t *)(punsignedSystemValue4 + 2) = 0;
    *(uint32_t *)(punsignedSystemValue4 + 2) = 0;
    punsignedSystemValue4[1] = punsignedValue100;
    *(uint32_t *)((long long)punsignedSystemValue4 + 0x1c) = uStack_f0._4_4_;
    *(uint32_t *)(punsignedSystemValue4 + 3) = (uint32_t)uStack_f0;
    unsignedValueF8 = 0;
    punsignedValue100 = (uint8_t *)0x0;
    uStack_f0 = 0;
    dataBufferPointer = punsignedSystemValue4;
  }
  else {
    nextDataIndex2 = *ResourceManagerPointer;
    nextDataIndex1 = (long long)punsignedSystemValue4 - nextDataIndex2 >> 5;
    if (nextDataIndex1 == 0) {
      nextDataIndex1 = 1;
LAB_180064eed:
      allocationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex1 << 5,(char)ResourceManagerPointer[3]);
      punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
      nextDataIndex2 = *ResourceManagerPointer;
    }
    else {
      nextDataIndex1 = nextDataIndex1 * 2;
      if (nextDataIndex1 != 0) goto LAB_180064eed;
    }
    dataBufferContext = (void* *)CopySystemResourceDataExtended(nextDataIndex2,punsignedSystemValue4,allocationFlags);
    *dataBufferContext = &SystemMemoryAllocatorReference;
    dataBufferContext[1] = 0;
    *(uint32_t *)(dataBufferContext + 2) = 0;
    *dataBufferContext = &SystemGlobalDataReference;
    dataBufferContext[3] = 0;
    dataBufferContext[1] = 0;
    *(uint32_t *)(dataBufferContext + 2) = 0;
    *(uint32_t *)(dataBufferContext + 2) = unsignedValueF8;
    dataBufferContext[1] = punsignedValue100;
    *(uint32_t *)((long long)dataBufferContext + 0x1c) = uStack_f0._4_4_;
    *(uint32_t *)(dataBufferContext + 3) = (uint32_t)uStack_f0;
    unsignedValueF8 = 0;
    punsignedValue100 = (uint8_t *)0x0;
    uStack_f0 = 0;
    pointerToUnsigned14 = dataBufferContext + 4;
    HashNodePointer = (void* *)ResourceManagerPointer[1];
    punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
    if (punsignedSystemValue4 != HashNodePointer) {
      do {
        (**(code **)*punsignedSystemValue4)(punsignedSystemValue4,0);
        punsignedSystemValue4 = punsignedSystemValue4 + 4;
      } while (punsignedSystemValue4 != HashNodePointer);
      punsignedSystemValue4 = (void* *)*ResourceManagerPointer;
    }
    if (punsignedSystemValue4 != (void* *)0x0) {
        SystemCleanupFunction(punsignedSystemValue4);
    }
    *ResourceManagerPointer = allocationFlags;
    ResourceManagerPointer[1] = (long long)pointerToUnsigned14;
    ResourceManagerPointer[2] = nextDataIndex1 * 0x20 + allocationFlags;
    nextDataIndex2 = lStack_78;
    HashNodePointer = DataBufferPtrE0;
  }
  punsignedValue108 = &SystemGlobalDataReference;
  if (punsignedValue100 != (uint8_t *)0x0) {
      SystemCleanupFunction();
  }
  punsignedValue100 = (uint8_t *)0x0;
  uStack_f0 = uStack_f0 & 0xffffffff00000000;
  punsignedValue108 = &SystemMemoryAllocatorReference;
LAB_180065009:
  punsignedSystemValue4 = (void* *)(nextDataIndex2 + (long long)HashNodePointer);
  if (systemGlobalDataPtrB8 < (void* *)(nextDataIndex2 + (long long)HashNodePointer)) {
    punsignedSystemValue4 = systemGlobalDataPtrB8;
  }
  pcurrentThreadId = &uStack_c8;
  if (0xf < threadBufferSize) {
    pcurrentThreadId = (uint8_t *)CONCAT71(uStack_c7,uStack_c8);
  }
  systemGlobalDataPtrB8 = (void* *)((long long)systemGlobalDataPtrB8 - (long long)punsignedSystemValue4);
    memmove(pcurrentThreadId,pcurrentThreadId + (long long)punsignedSystemValue4,(long long)systemGlobalDataPtrB8 + 1);
}



0001800654e7)
0001800654f0)


/**
 * @brief 释放系统资源
 * 
 * 该函数负责释放系统资源，包括内存清理、资源句柄释放和相关数据结构的销毁。
 * 主要用于系统资源的清理和释放操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 无返回值
 * 
 * 原始函数名为FUN_180065160，现已重命名为ReleaseSystemResource
 */
void ReleaseSystemResource(void* ResourceManagerPointer)

{
  byte *pisByteValid;
  int systemResult;
  bool isOperationComplete;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  char resourceStatusFlag;
  int systemCode;
  long long resourceCounter;
  ulong long systemOperationFlags;
  void* systemStatus1;
  ulong long systemStatus2;
  byte *pisByteValid3;
  long long nextDataIndex4;
  int systemStatus5;
  void* *pointerToUnsigned16;
  void* *pointerToUnsigned17;
  void* *pointerToUnsigned18;
  void* *pointerToUnsigned19;
  uint32_t creationFlags0;
  uint8_t arrayUnsigned368 [32];
  void* *punsignedValue348;
  void*2 auStack_338 [2];
  void*2 aunsignedValue334 [2];
  void* *pointerUnsigned330;
  long long lStack_328;
  int iStack_320;
  ulong long unsignedValue318;
  uint32_t uStack_310;
  void* *pointerUnsigned308;
  void* *DataBufferPtr300;
  uint32_t unsignedValue2f8;
  ulong long unsignedValue2f0;
  void* *pointerUnsigned2e8;
  void* *pointerUnsigned2e0;
  uint32_t unsignedValue2d8;
  ulong long unsignedValue2d0;
  ulong long uStack_2c8;
  void* *pointerUnsigned2c0;
  void* unsignedValue2b8;
  uint32_t unsignedValue2b0;
  ulong long uStack_2a8;
  void* *pointerUnsigned2a0;
  char *pcStack_298;
  int iStack_290;
  uint32_t EncryptionKeyValue8;
  void* EncryptionKeyValue0;
  long long lStack_278;
  long long lStack_268;
  void* *puStack_260;
  void* *pointerUnsigned258;
  void* uStack_250;
  uint32_t unsignedValue248;
  void* *punsignedValue240;
  long long lStack_238;
  uint32_t unsignedValue228;
  void* *SystemStringTemplatePtr2;
  void* *SystemStringTemplatePtr;
  void* uStack_210;
  uint32_t unsignedValue208;
  void* *pStackValue200;
  void* *SystemGlobalDataReferencePtr2;
  uint32_t StackValue1e8;
  void* *pGlobalDataFlags2;
  void* *SystemGlobalDataReferencePtr;
  uint32_t StackValue1c8;
  void* *pGlobalDataFlags;
  void* *pointerUnsigned1b8;
  uint32_t uStack_1a8;
  void* *psystemFlag1A0;
  void* *pSystemStackFlag;
  uint32_t unsignedValue188;
  void* *LocalStackBuffer;
  void* *psystemFlag178;
  uint32_t uStack_168;
  void* *puStack_160;
  void* *puStack_158;
  void* uStack_150;
  uint32_t uStack_148;
  void* *puStack_140;
  void* *systemMemoryContext;
  void* uStack_130;
  uint32_t uStack_128;
  void* uStack_120;
  void* *pUnsignedStackFlag118;
  uint8_t *pUnsignedStackFlag110;
  uint32_t unsignedValue108;
  uint8_t aunsignedValue100 [16];
  void* *puStack_f0;
  uint8_t *pointerUnsignedE8;
  uint32_t uStack_e0;
  uint8_t EncryptionBufferD8 [16];
  void* *pointerUnsignedC8;
  void* *pUnsignedStackFlagC0;
  uint32_t UnsignedStackFlagB8;
  void* aUnsignedStackFlagB0 [40];
  uint32_t StackBuffer [14];
  ulong long unsignedValue50;
  ulong long uStack_38;
  
  uStack_120 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)arrayUnsigned368;
  uStack_310 = 0;
  ConfigureSystemResources(ResourceManagerPointer,&LocalStackBuffer,&SystemDataBufferTemplate5);
  EncryptionKeyValue0 = 0;
  lStack_278 = 0;
  pointerToUnsigned16 = &SystemStringTemplate;
  if (psystemFlag178 != (void* *)0x0) {
    pointerToUnsigned16 = psystemFlag178;
  }
  creationFlags0 = ProcessSystemResourceData(&EncryptionKeyValue0,pointerToUnsigned16,&SystemEventTemplate);
  pointerUnsigned330 = &SystemGlobalDataReference;
  unsignedValue318 = 0;
  lStack_328 = 0;
  iStack_320 = 0;
  InitializeCreationFlags(creationFlags0,&pStackValue200);
  if ((SystemCleanupHandler == (long long *)0x0) ||
     (charBuffer = (**(code **)(*SystemCleanupHandler + 0x28))(), charBuffer == '\0')) {
    pointerToUnsigned16 = &SystemUnsigned16Data1;
  }
  else {
    resourceCounter = (**(code **)(SystemCallbackTable + 0x30))();
    pointerToUnsigned16 = &SystemStringTemplate;
    if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
      pointerToUnsigned16 = *(void* **)(resourceCounter + 8);
    }
  }
  ProcessSystemQueue(&pGlobalDataFlags,pointerToUnsigned16);
  if ((SystemCleanupHandler == (long long *)0x0) ||
     (charBuffer = (**(code **)(*SystemCleanupHandler + 0x28))(), charBuffer == '\0')) {
    pointerToUnsigned16 = &SystemUnsigned16Data2;
  }
  else {
    resourceCounter = (**(code **)(SystemCallbackTable + 0x20))();
    pointerToUnsigned16 = &SystemStringTemplate;
    if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
      pointerToUnsigned16 = *(void* **)(resourceCounter + 8);
    }
  }
  ProcessSystemQueue(&pGlobalDataFlags2,pointerToUnsigned16);
  pointerUnsignedC8 = &SystemMemoryTemplateE;
  pUnsignedStackFlagC0 = aUnsignedStackFlagB0;
  UnsignedStackFlagB8 = 0;
  aUnsignedStackFlagB0[0] = 0;
  uStack_310 = 4;
  InitializeGameSettings(&pointerUnsignedC8,&SystemDataBufferTemplateI,0x130a7);
  punsignedValue348 = &SystemStringTemplate;
  if (pUnsignedStackFlagC0 != (void* *)0x0) {
    punsignedValue348 = pUnsignedStackFlagC0;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate4);
  uStack_310 = 0;
  pointerUnsignedC8 = &SystemMemoryAllocatorReference;
  punsignedValue348 = &SystemDataArrayTemplate5;
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate6);
  punsignedValue348 = &SystemStringTemplatePtr;
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate1);
  punsignedValue348 = &SystemStringTemplate;
  if (pointerUnsigned1b8 != (void* *)0x0) {
    punsignedValue348 = pointerUnsigned1b8;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate3);
  punsignedValue348 = &SystemStringTemplate;
  if (SystemGlobalDataReferencePtr != (void* *)0x0) {
    punsignedValue348 = SystemGlobalDataReferencePtr;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate2);
  pGlobalDataFlags2 = &SystemGlobalDataReference;
  if (SystemGlobalDataReferencePtr != (void* *)0x0) {
      SystemCleanupFunction();
  }
  SystemGlobalDataReferencePtr = (void* *)0x0;
  SystemDataProcessingFlag = 0;
  pGlobalDataFlags2 = &SystemMemoryAllocatorReference;
  pGlobalDataFlags = &SystemGlobalDataReference;
  if (pointerUnsigned1b8 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  GameControllerBuffer = (void* *)0x0;
  uStack_1a8 = 0;
  pGlobalDataFlags = &SystemMemoryAllocatorReference;
  pointerUnsigned2c0 = &SystemGlobalDataReference;
  uStack_2a8 = 0;
  unsignedValue2b8 = 0;
  unsignedValue2b0 = 0;
  pointerUnsigned2e8 = &SystemGlobalDataReference;
  unsignedValue2d0 = 0;
  pointerUnsigned2e0 = (void* *)0x0;
  unsignedValue2d8 = 0;
  pointerUnsigned308 = &SystemGlobalDataReference;
  unsignedValue2f0 = 0;
  DataBufferPtr300 = (void* *)0x0;
  unsignedValue2f8 = 0;
  systemOperationFlags = GetSystemStatusFlags();
  ConfigureSystemDataBuffer(&pointerUnsigned2e8,&SystemDataBufferSizeTemplate,systemOperationFlags / 0x100000 & 0xffffffff);
  StackBuffer[0] = 0x48;
  systemStatus1 = GetCurrentProcess();
  systemCode = K32GetProcessMemoryInfo(systemStatus1,StackBuffer,0x48);
  systemOperationFlags = 0;
  if (systemCode != 0) {
    systemOperationFlags = unsignedValue50;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned308,&SystemDataBufferSizeTemplate,systemOperationFlags / 0x100000 & 0xffffffff);
  punsignedValue348 = &SystemStringTemplate;
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataBufferFinalTemplate);
  punsignedValue348 = &SystemStringTemplate;
  if (pointerUnsigned2e0 != (void* *)0x0) {
    punsignedValue348 = pointerUnsigned2e0;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemConfigParam1);
  punsignedValue348 = &SystemStringTemplate;
  if (DataBufferPtr300 != (void* *)0x0) {
    punsignedValue348 = DataBufferPtr300;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemConfigParam2);
  resourceCounter = SystemStatusFlagsPointer;
  pointerUnsigned308 = &SystemGlobalDataReference;
  if (DataBufferPtr300 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  DataBufferPtr300 = (void* *)0x0;
  unsignedValue2f0 = unsignedValue2f0 & 0xffffffff00000000;
  pointerUnsigned308 = &SystemMemoryAllocatorReference;
  pointerUnsigned2e8 = &SystemGlobalDataReference;
  if (pointerUnsigned2e0 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned2e0 = (void* *)0x0;
  unsignedValue2d0 = unsignedValue2d0 & 0xffffffff00000000;
  pointerUnsigned2e8 = &SystemMemoryAllocatorReference;
  unsignedValue2b8 = 0;
  uStack_2a8 = uStack_2a8 & 0xffffffff00000000;
  pointerUnsigned2c0 = &SystemMemoryAllocatorReference;
  nextDataIndex4 = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&lStack_268);
    nextDataIndex4 = lStack_268;
  }
  punsignedValue348 = (void* *)
                ((double)(nextDataIndex4 - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage - *(double *)(resourceCounter + 0x210));
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemConfigBufferTemplate1,&SystemGlobalDataReference,&SystemConfigBufferTemplate2);
  punsignedValue348 = &SystemStringTemplate;
  if (SystemGlobalDataReferencePtr2 != (void* *)0x0) {
    punsignedValue348 = SystemGlobalDataReferencePtr2;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemConfigParam3);
  SystemStringTemplatePtr2 = (void* *)0x0;
  SystemStringTemplatePtr = (void* *)0x0;
  uStack_210 = 0;
  unsignedValue208 = 3;
  puStack_160 = (void* *)0x0;
  puStack_158 = (void* *)0x0;
  uStack_150 = 0;
  uStack_148 = 3;
  puStack_f0 = &SystemResourceTemplateSecondary;
  pointerUnsignedE8 = EncryptionBufferD8;
  EncryptionBufferD8[0] = 0;
  uStack_e0 = 9;
  strcpy_s(EncryptionBufferD8,0x10,&SystemStringTemplate1);
  ProcessSystemResourceTemplate(&puStack_160,&pStackValue200,&puStack_f0);
  pointerToUnsigned18 = puStack_158;
  pointerToUnsigned19 = puStack_160;
  if (1 < (ulong long)((long long)puStack_158 - (long long)puStack_160 >> 5)) {
    pUnsignedStackFlag118 = &SystemResourceTemplateSecondary;
    pUnsignedStackFlag110 = aunsignedValue100;
    aunsignedValue100[0] = 0;
    unsignedValue108 = 1;
    strcpy_s(aunsignedValue100,0x10,&SystemStringConstantG);
    ProcessSystemResourceTemplate(&SystemStringTemplatePtr2,pointerToUnsigned19 + 4,&pUnsignedStackFlag118);
    pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
  }
  puStack_f0 = &SystemMemoryAllocatorReference;
  punsignedSystemValue4 = SystemStringTemplatePtr2;
  for (pointerToUnsigned17 = pointerToUnsigned19; SystemStringTemplatePtr2 = punsignedSystemValue4, pointerToUnsigned17 != pointerToUnsigned18; pointerToUnsigned17 = pointerToUnsigned17 + 4) {
    (**(code **)*pointerToUnsigned17)(pointerToUnsigned17,0);
    punsignedSystemValue4 = SystemStringTemplatePtr2;
  }
  if (pointerToUnsigned19 != (void* *)0x0) {
      SystemCleanupFunction(pointerToUnsigned19);
  }
  systemOperationFlags = (long long)SystemStringTemplatePtr - (long long)punsignedSystemValue4 >> 5;
  if (systemOperationFlags != 0) {
    if ((SystemCleanupHandler == (long long *)0x0) ||
       (charBuffer = (**(code **)(*SystemCleanupHandler + 0x28))(), charBuffer == '\0')) {
      pointerToUnsigned16 = &SystemUnsigned16Data3;
    }
    else {
      resourceCounter = (**(code **)(SystemCallbackTable + 0x28))();
      pointerToUnsigned16 = &SystemStringTemplate;
      if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
        pointerToUnsigned16 = *(void* **)(resourceCounter + 8);
      }
    }
    ProcessSystemQueue(&punsignedValue240,pointerToUnsigned16);
    puStack_260 = (void* *)0x0;
    pointerUnsigned258 = (void* *)0x0;
    uStack_250 = 0;
    unsignedValue248 = 3;
    auStack_338[0] = 10;
    if (lStack_238 != 0) {
      ProcessSystemMemoryBuffer(&punsignedValue240,&puStack_260,auStack_338);
    }
    systemStatus2 = (long long)pointerUnsigned258 - (long long)puStack_260 >> 5;
    pointerToUnsigned19 = puStack_260;
    pointerToUnsigned18 = puStack_260;
    pointerToUnsigned17 = pointerUnsigned258;
    if ((int)systemStatus2 != 0) {
      uStack_2c8 = systemStatus2 & 0xffffffff;
      do {
        puStack_140 = (void* *)0x0;
        systemMemoryContext = (void* *)0x0;
        uStack_130 = 0;
        uStack_128 = 3;
        aunsignedValue334[0] = 0x23;
        if (pointerToUnsigned19[1] != 0) {
          ProcessSystemMemoryBuffer(pointerToUnsigned19,&puStack_140,aunsignedValue334);
        }
        pcurrentThreadId = systemMemoryContext;
        pointerToUnsigned17 = puStack_140;
        pointerToUnsigned18 = puStack_140;
        if (((long long)systemMemoryContext - (long long)puStack_140 & 0xffffffffffffffe0U) == 0x40) {
          CreateSystemObject(&pointerUnsigned2a0,puStack_140);
          if (pcStack_298 != (char *)0x0) {
            iStack_290 = 0;
            nextDataIndex4 = 0;
            resourceCounter = 0;
            charBuffer = *pcStack_298;
            while (charBuffer != '\0') {
              if (' ' < pcStack_298[resourceCounter]) {
                if (nextDataIndex4 != resourceCounter) {
                  pcStack_298[nextDataIndex4] = pcStack_298[resourceCounter];
                }
                iStack_290 = iStack_290 + 1;
                nextDataIndex4 = nextDataIndex4 + 1;
              }
              resourceCounter = resourceCounter + 1;
              charBuffer = pcStack_298[resourceCounter];
            }
            pcStack_298[nextDataIndex4] = '\0';
          }
          systemCode = 0;
          if (systemOperationFlags != 0) {
            pointerToUnsigned18 = punsignedSystemValue4 + 1;
            do {
              systemResult = *(int *)(pointerToUnsigned18 + 1);
              systemStatus5 = iStack_290;
              if (systemResult == iStack_290) {
                if (systemResult != 0) {
                  pisByteValid3 = (byte *)*pointerToUnsigned18;
                  resourceCounter = (long long)pcStack_298 - (long long)pisByteValid3;
                  do {
                    pisByteValid = pisByteValid3 + resourceCounter;
                    systemStatus5 = (uint)*pisByteValid3 - (uint)*pisByteValid;
                    if (systemStatus5 != 0) break;
                    pisByteValid3 = pisByteValid3 + 1;
                  } while (*pisByteValid != 0);
                }
LAB_180065a3e:
                if (systemStatus5 == 0) {
                  punsignedValue348 = &SystemStringTemplate;
                  if ((void* *)pointerToUnsigned17[5] != (void* *)0x0) {
                    punsignedValue348 = (void* *)pointerToUnsigned17[5];
                  }
                  pointerToUnsigned16 = &SystemStringTemplate;
                  if ((void* *)pointerToUnsigned17[1] != (void* *)0x0) {
                    pointerToUnsigned16 = (void* *)pointerToUnsigned17[1];
                  }
                  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemConfigParam4,pointerToUnsigned16);
                  break;
                }
              }
              else if (systemResult == 0) goto LAB_180065a3e;
              systemCode = systemCode + 1;
              pointerToUnsigned18 = pointerToUnsigned18 + 4;
            } while ((ulong long)(long long)systemCode < systemOperationFlags);
          }
          pointerUnsigned2a0 = &SystemGlobalDataReference;
          if (pcStack_298 != (char *)0x0) {
              SystemCleanupFunction();
          }
          pcStack_298 = (char *)0x0;
          EncryptionKeyValue8 = 0;
          pointerUnsigned2a0 = &SystemMemoryAllocatorReference;
          for (pointerToUnsigned18 = pointerToUnsigned17; pointerToUnsigned18 != pcurrentThreadId; pointerToUnsigned18 = pointerToUnsigned18 + 4) {
            (**(code **)*pointerToUnsigned18)(pointerToUnsigned18,0);
          }
        }
        else {
          for (; pointerToUnsigned18 != pcurrentThreadId; pointerToUnsigned18 = pointerToUnsigned18 + 4) {
            (**(code **)*pointerToUnsigned18)(pointerToUnsigned18,0);
          }
        }
        if (pointerToUnsigned17 != (void* *)0x0) {
            SystemCleanupFunction(pointerToUnsigned17);
        }
        pointerToUnsigned19 = pointerToUnsigned19 + 4;
        uStack_2c8 = uStack_2c8 - 1;
      } while (uStack_2c8 != 0);
      uStack_2c8 = 0;
      pointerToUnsigned19 = puStack_260;
      pointerToUnsigned18 = puStack_260;
      pointerToUnsigned17 = pointerUnsigned258;
    }
    for (; resourceEntryPointer = pointerUnsigned258, pcurrentThreadId = puStack_260, pointerToUnsigned19 != pointerUnsigned258; pointerToUnsigned19 = pointerToUnsigned19 + 4
        ) {
      puStack_260 = pointerToUnsigned18;
      pointerUnsigned258 = pointerToUnsigned17;
      (**(code **)*pointerToUnsigned19)(pointerToUnsigned19,0);
      pointerToUnsigned18 = puStack_260;
      pointerToUnsigned17 = pointerUnsigned258;
      pointerUnsigned258 = resourceEntryPointer;
      puStack_260 = pcurrentThreadId;
    }
    if (puStack_260 != (void* *)0x0) {
      puStack_260 = pointerToUnsigned18;
      pointerUnsigned258 = pointerToUnsigned17;
        SystemCleanupFunction(pcurrentThreadId);
    }
    punsignedValue240 = &SystemGlobalDataReference;
    if (lStack_238 != 0) {
      puStack_260 = pointerToUnsigned18;
      pointerUnsigned258 = pointerToUnsigned17;
        SystemCleanupFunction();
    }
    lStack_238 = 0;
    unsignedValue228 = 0;
    punsignedValue240 = &SystemMemoryAllocatorReference;
    puStack_260 = pointerToUnsigned18;
    pointerUnsigned258 = pointerToUnsigned17;
  }
  if ((SystemCallbackTable == 0) || (*(int *)(SystemStatusFlagsPointer + 0x340) == 0)) {
    isOperationComplete = false;
  }
  else {
    isOperationComplete = true;
  }
  if (((SystemStatusFlagsPointer != 0) && (*(int *)(SystemStatusFlagsPointer + 0x340) == 1)) && (isOperationComplete)) {
    resourceCounter = (**(code **)(SystemCallbackTable + 0x18))();
    pointerToUnsigned16 = &SystemStringTemplate;
    if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
      pointerToUnsigned16 = *(void* **)(resourceCounter + 8);
    }
    ProcessSystemQueue(&psystemFlag1A0,pointerToUnsigned16);
    pointerToUnsigned16 = &SystemStringTemplate;
    if (pSystemStackFlag != (void* *)0x0) {
      pointerToUnsigned16 = pSystemStackFlag;
    }
    ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemConfigBufferTemplate3,pointerToUnsigned16);
    psystemFlag1A0 = &SystemGlobalDataReference;
    if (pSystemStackFlag != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemStackFlag = (void* *)0x0;
    unsignedValue188 = 0;
    psystemFlag1A0 = &SystemMemoryAllocatorReference;
  }
  resourceCounter = lStack_278;
  fwrite(lStack_328,1,(long long)iStack_320,lStack_278);
  pointerToUnsigned19 = SystemStringTemplatePtr;
  pointerToUnsigned18 = punsignedSystemValue4;
  if (resourceCounter != 0) {
    fclose(resourceCounter);
    lStack_278 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
    resourceCounter = 0;
    punsignedSystemValue4 = SystemStringTemplatePtr2;
    pointerToUnsigned19 = SystemStringTemplatePtr;
    pointerToUnsigned18 = SystemStringTemplatePtr2;
  }
  for (; pointerToUnsigned17 = SystemStringTemplatePtr, punsignedSystemValue4 != SystemStringTemplatePtr; punsignedSystemValue4 = punsignedSystemValue4 + 4) {
    SystemStringTemplatePtr = pointerToUnsigned19;
    (**(code **)*punsignedSystemValue4)(punsignedSystemValue4,0);
    pointerToUnsigned19 = SystemStringTemplatePtr;
    SystemStringTemplatePtr = pointerToUnsigned17;
  }
  if (pointerToUnsigned18 != (void* *)0x0) {
    SystemStringTemplatePtr = pointerToUnsigned19;
      SystemCleanupFunction(pointerToUnsigned18);
  }
  pStackValue200 = &SystemGlobalDataReference;
  if (SystemGlobalDataReferencePtr2 != (void* *)0x0) {
    SystemStringTemplatePtr = pointerToUnsigned19;
      SystemCleanupFunction();
  }
  SystemGlobalDataReferencePtr2 = (void* *)0x0;
  SystemInitializationFlag = 0;
  pStackValue200 = &SystemMemoryAllocatorReference;
  pointerUnsigned330 = &SystemGlobalDataReference;
  if (lStack_328 == 0) {
    lStack_328 = 0;
    unsignedValue318 = unsignedValue318 & 0xffffffff00000000;
    pointerUnsigned330 = &SystemMemoryAllocatorReference;
    SystemStringTemplatePtr = pointerToUnsigned19;
    if (resourceCounter != 0) {
      fclose(resourceCounter);
      lStack_278 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
    LocalStackBuffer = &SystemGlobalDataReference;
    if (psystemFlag178 == (void* *)0x0) {
      psystemFlag178 = (void* *)0x0;
      uStack_168 = 0;
      LocalStackBuffer = &SystemMemoryAllocatorReference;
        ValidateSystemChecksum(uStack_38 ^ (ulong long)arrayUnsigned368);
    }
      SystemCleanupFunction();
  }
  SystemStringTemplatePtr = pointerToUnsigned19;
    SystemCleanupFunction();
}





/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统资源分配器，设置资源分配所需的内存和数据结构。
 * 主要用于系统资源的分配和管理工作。
 * 
 * 原始函数名为FUN_180065d50，现已重命名为InitializeSystemResourceAllocator
 */
void InitializeSystemResourceAllocator(void)

{
  uint8_t auStack_2c8 [104];
  void* uStack_260;
  void* uStack_258;
  uint32_t uStack_250;
  uint32_t uStack_24c;
  uint32_t unsignedValue248;
  uint32_t uStack_244;
  uint32_t unsignedValue240;
  uint32_t unsignedValue23c;
  uint32_t uStack_238;
  uint32_t uStack_234;
  uint32_t uStack_230;
  uint8_t uStack_22c;
  uint8_t aunsignedValue228 [512];
  ulong long EncryptionKeyValue;
  
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)auStack_2c8;
  uStack_230 = 0x22657865;
  uStack_260 = 0x736172435c2e2e22;
  uStack_258 = 0x6564616f6c705568;
  uStack_22c = 0;
  unsignedValue240 = 0x616f6c70;
  unsignedValue23c = 0x2e726564;
  uStack_238 = 0x6c627550;
  uStack_234 = 0x2e687369;
  uStack_250 = 0x75502e72;
  uStack_24c = 0x73696c62;
  unsignedValue248 = 0x72435c68;
  uStack_244 = 0x55687361;
    memset(aunsignedValue228,0,0x80);
}





/**
 * @brief 初始化系统资源对象
 * 
 * 该函数负责初始化系统资源对象，包括对象的创建、配置和初始化。
 * 主要用于系统资源对象的初始化和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 * 原始函数名为FUN_180065f00，现已重命名为InitializeSystemResourceObject
 */
void InitializeSystemResourceObject(void* ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  char validationStatusFlag;
  void* allocationContext;
  long long bufferBaseAddress;
  int systemValue;
  long long *plStack_b0;
  void* *pUnsignedStackFlagA8;
  long long lStack_a0;
  uint unsignedValue98;
  void* *pUnsignedStackFlag88;
  long long lStack_80;
  uint32_t processFlags70;
  void* **ppEncryptionValue68;
  long long **pplStack_60;
  uint32_t unsignedValue50;
  void* EncryptionValue48;
  
  EncryptionValue48 = 0xfffffffffffffffe;
  plStack_b0 = *(long long **)(SystemMemoryBlockStorage + 0x18);
  CreateSystemObject(&pUnsignedStackFlagA8,SystemStatusFlagsPointer + 0x170,AdditionalParameter,ConfigurationFlag,0);
  systemValue = unsignedValue98 + 3;
  ExecuteSystemCommand(&pUnsignedStackFlagA8,systemValue);
  *(uint32_t *)((ulong long)unsignedValue98 + lStack_a0) = 0x706d74;
  unsignedValue98 = systemValue;
  SystemValidationResult = ValidateSystemMemoryAllocation(&pUnsignedStackFlagA8);
  if (validationStatusFlag == '\0') {
    ReleaseSystemMemoryAllocation(&pUnsignedStackFlagA8);
  }
  ppEncryptionValue68 = &pUnsignedStackFlagA8;
  pplStack_60 = &plStack_b0;
  ExecuteSystemResourceCommand(&ppEncryptionValue68,SystemNodeManagerPointer,&SystemNodeManagerConfig);
  ExecuteSystemResourceCommand(&ppEncryptionValue68,SystemMemoryManagerPointer,&SystemMemoryManagerConfig);
  systemFunctionPointer = *(code **)(*plStack_b0 + 0x40);
  allocationContext = CreateSystemObject(&ppEncryptionValue68,SystemContextManagerPointer + 0x28);
  (*systemFunctionPointer)(plStack_b0,allocationContext);
  ppEncryptionValue68 = (void* **)&SystemGlobalDataReference;
  if (pplStack_60 != (long long **)0x0) {
      SystemCleanupFunction();
  }
  pplStack_60 = (long long **)0x0;
  unsignedValue50 = 0;
  ppEncryptionValue68 = (void* **)&SystemMemoryAllocatorReference;
  systemFunctionPointer = *(code **)(*plStack_b0 + 0x40);
  allocationContext = CreateSystemObject(&pUnsignedStackFlag88,SystemContextManagerPointer + 0xe0);
  (*systemFunctionPointer)(plStack_b0,allocationContext);
  pUnsignedStackFlag88 = &SystemGlobalDataReference;
  if (lStack_80 != 0) {
      SystemCleanupFunction();
  }
  lStack_80 = 0;
  processFlags70 = 0;
  pUnsignedStackFlag88 = &SystemMemoryAllocatorReference;
  if (sourceString == 0) {
    bufferBaseAddress = AllocateSystemMemory(SystemAllocationFlagsTemplate);
    (**(code **)(*plStack_b0 + 8))(plStack_b0,ResourceManagerPointer,*(uint32_t *)(bufferBaseAddress + 0x38));
  }
  else {
    systemFunctionPointer = *(code **)(*plStack_b0 + 0x10);
    allocationContext = ProcessSystemQueue(&pUnsignedStackFlag88,ConfigurationDataPointer);
    (*systemFunctionPointer)(plStack_b0,ResourceManagerPointer,allocationContext);
    pUnsignedStackFlag88 = &SystemGlobalDataReference;
    if (lStack_80 != 0) {
        SystemCleanupFunction();
    }
    lStack_80 = 0;
    processFlags70 = 0;
    pUnsignedStackFlag88 = &SystemMemoryAllocatorReference;
  }
  CleanupSystemMemoryBuffer(&pUnsignedStackFlagA8);
  pUnsignedStackFlagA8 = &SystemGlobalDataReference;
  if (lStack_a0 != 0) {
      SystemCleanupFunction();
  }
  return;
}





/**
 * @brief 执行系统资源命令
 * 
 * 该函数负责执行系统资源的命令，包括命令的解析、执行和结果处理。
 * 主要用于系统资源命令的执行和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 * 原始函数名为FUN_180066140，现已重命名为ExecuteSystemResourceCommand
 */
void ExecuteSystemResourceCommand(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint systemStatus;
  long long localSystemHandle;
  void* *HashNodePointer;
  ulong long unsignedSystemValue4;
  void* UnsignedStackFlag88;
  long long lStack_80;
  void* *pprocessFlags70;
  long long lStack_68;
  uint unsignedValue60;
  void* processFlags58;
  void* *memoryAllocationEnd;
  void* *pEncryptionValue48;
  uint32_t uStack_38;
  
  SystemMemoryAllocationFlag = 0;
  SystemMemoryAllocationHandle = 0;
  localSystemHandle = *ResourceManagerPointer;
  pprocessFlags70 = &SystemGlobalDataReference;
  SystemMemoryAllocationValue = 0;
  SystemMemoryAllocationPointer = 0;
  SystemMemoryAllocationStatus = 0;
  systemStatus = *(uint *)(localSystemHandle + 0x10);
  unsignedSystemValue4 = (ulong long)systemStatus;
  if (*(long long *)(localSystemHandle + 8) != 0) {
    ExecuteSystemCommand(&pprocessFlags70,unsignedSystemValue4,AdditionalParameter,ConfigurationFlag,1,0xfffffffffffffffe);
  }
  if (systemStatus != 0) {
      memcpy(lStack_68,*(void* *)(localSystemHandle + 8),unsignedSystemValue4);
  }
  if (lStack_68 != 0) {
    *(uint8_t *)(unsignedSystemValue4 + lStack_68) = 0;
  }
  unsignedValue60 = systemStatus;
  processFlags58._4_4_ = *(uint *)(localSystemHandle + 0x1c);
  ExecuteSystemCommand(&pprocessFlags70,1);
  *(void*2 *)((ulong long)unsignedValue60 + lStack_68) = 0x5c;
  unsignedValue60 = 1;
  ConfigureSystemResources(&pprocessFlags70,&memoryAllocationEnd,AdditionalParameter);
  pprocessFlags70 = &SystemGlobalDataReference;
  if (lStack_68 != 0) {
      SystemCleanupFunction();
  }
  lStack_68 = 0;
  processFlags58 = (ulong long)processFlags58._4_4_ << 0x20;
  pprocessFlags70 = &SystemMemoryAllocatorReference;
  HashNodePointer = &SystemStringTemplate;
  if (pEncryptionValue48 != (void* *)0x0) {
    HashNodePointer = pEncryptionValue48;
  }
  ProcessSystemResourceData(&UnsignedStackFlag88,HashNodePointer,&SystemEventTemplate,ConfigurationFlag,0);
  InitializePrimaryResource(ConfigurationDataPointer,&UnsignedStackFlag88);
  if (lStack_80 != 0) {
    fclose();
    lStack_80 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  (**(code **)(**(long long **)ResourceManagerPointer[1] + 0x40))(*(long long **)ResourceManagerPointer[1],&memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
  if (pEncryptionValue48 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pEncryptionValue48 = (void* *)0x0;
  uStack_38 = 0;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
  if (lStack_80 != 0) {
    fclose();
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  return;
}



0001800665ec)
0001800665f5)


// 函数: void ProcessSystemResourceConfiguration(void* ResourceManagerPointer,void* ConfigurationDataPointer,char AdditionalParameter,char ConfigurationFlag,
void ProcessSystemResourceConfiguration(void* ResourceManagerPointer,void* ConfigurationDataPointer,char AdditionalParameter,char ConfigurationFlag,
                  void* SystemContextPointer)

{
  char SystemNodeFlag;
  int systemResult;
  uint32_t allocationContext;
  int systemIndex;
  void* currentThreadId;
  ulong long hashValue;
  uint8_t auStack_1f8 [32];
  void* *SystemGlobalDataReferencePtr;
  void* *AlternateStringBuffer;
  void* *pStackValue1c8;
  void* *pointerUnsigned1b8;
  long long StackCleanupFlag;
  uint32_t uStack_1a8;
  void* systemFlag1A0;
  void* *pSystemStackFlag;
  long long lStack_190;
  uint32_t unsignedValue180;
  void* *psystemFlag178;
  void* *puStack_170;
  uint32_t uStack_168;
  ulong long uStack_160;
  void* *puStack_158;
  void* *puStack_150;
  uint32_t uStack_148;
  ulong long uStack_140;
  void* *systemMemoryContext;
  long long LocalStackInitializationFlag;
  uint32_t uStack_120;
  void* *pUnsignedStackFlag110;
  long long lStack_108;
  uint32_t unsignedValueF8;
  void* *puStack_f0;
  long long lStack_e8;
  uint32_t unsignedValueD8;
  void* *dataBufferContext;
  void* *pointerUnsignedC8;
  uint32_t UnsignedStackFlagB8;
  void* UnsignedStackFlagB0;
  void* **ppUnsignedStackFlagA8;
  uint32_t aunsignedValue98 [14];
  ulong long unsignedValue60;
  ulong long EncryptionValue48;
  
  UnsignedStackFlagB0 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_1f8;
  charStatus = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  systemIndex = 0;
  if (initializationStatusFlag != '\0') {
    ProcessSystemQueue(&GameControllerBuffer,&SystemStringBuffer);
    InitializeGameController(&GameControllerBuffer,0);
    GameControllerBuffer = &SystemGlobalDataReference;
    if (StackCleanupFlag != 0) {
        SystemCleanupFunction();
    }
    StackCleanupFlag = 0;
    systemFlag1A0 = (ulong long)systemFlag1A0._4_4_ << 0x20;
    GameControllerBuffer = &SystemMemoryAllocatorReference;
    goto LAB_180066971;
  }
  if (((SystemDebugFlag != '\0') || (SystemVerboseFlag != '\0')) ||
     (*(int *)(SystemMemoryManagerPointer + 0x10e0) == 1)) {
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemConfigParam5);
    InitializeSystemManager();
    goto LAB_180066971;
  }
  if ((AdditionalParameter == '\0') && (SystemDebugFlag == '\0')) {
    if (((SystemInitializationFlag == '\0') || (systemResult = IsDebuggerPresent(), systemResult != 0)) &&
       (SystemSilentMode == '\0')) {
      allocationContext = MessageBoxA(0,&SystemMessageTitle,&SystemMessageText,0x40004);
      switch(allocationContext) {
      case 1:
        break;
      default:
        systemIndex = 1;
        break;
      case 4:
        systemIndex = 2;
        break;
      case 5:
        systemIndex = 3;
        break;
      case 6:
        systemIndex = 4;
        break;
      case 7:
        systemIndex = 5;
      }
      if (systemIndex == 4) goto LAB_18006650a;
    }
    else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
      pStackValue1c8 = &SystemMessageTitle;
      AlternateStringBuffer = &SystemMessageText;
      SystemGlobalDataReferencePtr = &SystemStackDataTemplate1;
      SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd);
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam1);
  }
  else {
LAB_18006650a:
    InitializeSystemStackFlag(&pSystemStackFlag);
    currentThreadId = ProcessSystemQueue(&systemMemoryContext,&SystemQueueConfigPtr);
    systemIndex = GetSystemCounter(&pSystemStackFlag,currentThreadId);
    systemMemoryContext = &SystemGlobalDataReference;
    if (LocalStackInitializationFlag != 0) {
        SystemCleanupFunction();
    }
    LocalStackInitializationFlag = 0;
    uStack_120 = 0;
    systemMemoryContext = &SystemMemoryAllocatorReference;
    ExecuteSystemOperation(&pSystemStackFlag,&dataBufferContext,systemIndex + 7,0xffffffff);
    GameControllerBuffer = &SystemGlobalDataReference;
    systemFlag1A0 = 0;
    StackCleanupFlag = 0;
    uStack_1a8 = 0;
    puStack_158 = &SystemGlobalDataReference;
    uStack_140 = 0;
    puStack_150 = (void* *)0x0;
    uStack_148 = 0;
    psystemFlag178 = &SystemGlobalDataReference;
    uStack_160 = 0;
    puStack_170 = (void* *)0x0;
    uStack_168 = 0;
    hashValue = CalculateSystemHashValue();
    ConfigureSystemDataBuffer(&puStack_158,&SystemDataBufferSizeTemplate,hashValue / 0x100000 & 0xffffffff);
    aunsignedValue98[0] = 0x48;
    currentThreadId = GetCurrentProcess();
    systemIndex = K32GetProcessMemoryInfo(currentThreadId,aunsignedValue98,0x48);
    hashValue = 0;
    if (systemIndex != 0) {
      hashValue = unsignedValue60;
    }
    ConfigureSystemDataBuffer(&psystemFlag178,&SystemDataBufferSizeTemplate,hashValue / 0x100000 & 0xffffffff);
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemConfigurationTerminator);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    if (puStack_150 != (void* *)0x0) {
      SystemGlobalDataReferencePtr = puStack_150;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam2);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    if (puStack_170 != (void* *)0x0) {
      SystemGlobalDataReferencePtr = puStack_170;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam3);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam4);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    if (pointerUnsignedC8 != (void* *)0x0) {
      SystemGlobalDataReferencePtr = pointerUnsignedC8;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam5);
    SystemGlobalDataReferencePtr = &SystemStackDataTemplate2;
    if (AdditionalParameter != '\0') {
      SystemGlobalDataReferencePtr = &SystemStackDataTemplate3;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam6);
    InitializeSystemManager();
    if (((ConfigurationFlag == '\0') || (SystemDebugFlagPtr != '\0')) || (*(int *)(SystemMemoryManagerPointer + 0x1150) != 0))
    {
      ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam7);
      InitializeSystemManager();
    }
    else {
      ProcessSystemStackConfiguration(&pSystemStackFlag);
    }
    ppUnsignedStackFlagA8 = &systemMemoryContext;
    currentThreadId = CreateSystemObject(&systemMemoryContext,&pSystemStackFlag);
    InitializeSecurityContext(currentThreadId);
    ConfigureSecurityParameters(&pSystemStackFlag,SystemContextPointer);
    CleanupAndValidateSystemResources(&pSystemStackFlag);
    SetupSystemConfiguration(&systemMemoryContext);
    ConfigureSystemResources(&systemMemoryContext,&puStack_f0,&SystemMemoryBufferTemplate1);
    ConfigureSystemResources(&pSystemStackFlag,&pUnsignedStackFlag110,&SystemMemoryBufferTemplate1);
    ProcessSystemDataTransfer(&pUnsignedStackFlag110,&puStack_f0);
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    if (lStack_108 != 0) {
        SystemCleanupFunction();
    }
    lStack_108 = 0;
    unsignedValueF8 = 0;
    pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
    puStack_f0 = &SystemGlobalDataReference;
    if (lStack_e8 != 0) {
        SystemCleanupFunction();
    }
    lStack_e8 = 0;
    unsignedValueD8 = 0;
    puStack_f0 = &SystemMemoryAllocatorReference;
    systemMemoryContext = &SystemGlobalDataReference;
    if (LocalStackInitializationFlag != 0) {
        SystemCleanupFunction();
    }
    LocalStackInitializationFlag = 0;
    uStack_120 = 0;
    systemMemoryContext = &SystemMemoryAllocatorReference;
    InitializeAndConfigureSystemResources(&pSystemStackFlag);
    ProcessAndManageSystemResources(&pSystemStackFlag);
    ReleaseSystemResource(&pSystemStackFlag);
    InitializeSystemResourceAllocator(&pSystemStackFlag,ConfigurationDataPointer,AdditionalParameter,0);
    psystemFlag178 = &SystemGlobalDataReference;
    if (puStack_170 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    puStack_170 = (void* *)0x0;
    uStack_160 = uStack_160 & 0xffffffff00000000;
    psystemFlag178 = &SystemMemoryAllocatorReference;
    puStack_158 = &SystemGlobalDataReference;
    if (puStack_150 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    puStack_150 = (void* *)0x0;
    uStack_140 = uStack_140 & 0xffffffff00000000;
    puStack_158 = &SystemMemoryAllocatorReference;
    StackCleanupFlag = 0;
    systemFlag1A0 = systemFlag1A0 & 0xffffffff00000000;
    GameControllerBuffer = &SystemMemoryAllocatorReference;
    dataBufferContext = &SystemGlobalDataReference;
    if (pointerUnsignedC8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pointerUnsignedC8 = (void* *)0x0;
    UnsignedStackFlagB8 = 0;
    dataBufferContext = &SystemMemoryAllocatorReference;
    pSystemStackFlag = &SystemGlobalDataReference;
    if (lStack_190 != 0) {
        SystemCleanupFunction();
    }
    lStack_190 = 0;
    unsignedValue180 = 0;
    pSystemStackFlag = &SystemMemoryAllocatorReference;
  }
LAB_180066971:
    ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)auStack_1f8);
}





// 函数: void ConfigureSystemDataProcessing(void* ResourceManagerPointer,void* ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag,
void ConfigureSystemDataProcessing(void* ResourceManagerPointer,void* ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag,
                  void* SystemProcessingContext)

{
  long long nextDataIndex;
  char validationStatusFlag;
  int MemoryComparisonResult;
  uint32_t unsignedSystemValue4;
  void* *pcurrentThreadId;
  int systemFlag;
  long long localDataIndex;
  void* *SystemDataPointer;
  void* *stackParameterB;
  uint32_t SystemConfigurationValue;
  void* UnsignedStackFlag88;
  uint8_t aUnsignedStackFlag80 [72];
  
  charResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if (validationStatusFlag == '\0') {
    if ((SystemVerboseFlagPtr == '\0') && (*(int *)(SystemMemoryManagerPointer + 0x10e0) != 1)) {
      systemCounter = 0;
      if ((AdditionalParameter != '\0') || (SystemDebugFlag != '\0')) {
LAB_180066bf4:
        InitializeSystemCounter(aUnsignedStackFlag80);
        stackParameterA = &SystemGlobalDataReference;
        UnsignedStackFlag88 = 0;
        stackParameterB = (void* *)0x0;
        SystemConfigurationValue = 0;
        pcurrentThreadId = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
        *(uint8_t *)pcurrentThreadId = 0;
        stackParameterB = pcurrentThreadId;
        unsignedSystemValue4 = StartSystemThread(pcurrentThreadId);
        UnsignedStackFlag88 = CONCAT44(UnsignedStackFlag88._4_4_,unsignedSystemValue4);
        *pcurrentThreadId = 0x73656873617263;
        SystemConfigurationValue = 7;
        GetSystemCounter(aUnsignedStackFlag80,&stackParameterA);
        stackParameterA = &SystemGlobalDataReference;
          SystemCleanupFunction(pcurrentThreadId);
      }
      if (((SystemInitializationFlag == '\0') || (systemFlag = IsDebuggerPresent(), systemFlag != 0)) &&
         (SystemSilentMode == '\0')) {
        unsignedSystemValue4 = MessageBoxA(0,&SystemMessageTitle,&SystemMessageText,0x40004);
        switch(unsignedSystemValue4) {
        case 1:
          break;
        default:
          systemCounter = 1;
          break;
        case 4:
          systemCounter = 2;
          break;
        case 5:
          systemCounter = 3;
          break;
        case 6:
          systemCounter = 4;
          break;
        case 7:
          systemCounter = 5;
        }
        if (systemCounter == 4) goto LAB_180066bf4;
      }
      else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
        SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,&SystemMessageText,
                      &SystemMessageTitle);
      }
      ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam1);
    }
    else {
      ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemConfigParam5);
      InitializeSystemManager();
    }
  }
  else {
    stackParameterA = &SystemGlobalDataReference;
    UnsignedStackFlag88 = 0;
    stackParameterB = (void* *)0x0;
    SystemConfigurationValue = 0;
    nextDataIndex = -1;
    do {
      localDataIndex = nextDataIndex;
      nextDataIndex = localDataIndex + 1;
    } while (*(char *)(localDataIndex + 0x180c84871) != '\0');
    if ((int)(localDataIndex + 1) != 0) {
      systemFlag = (int)localDataIndex + 2;
      systemCounter = systemFlag;
      if (systemFlag < 0x10) {
        systemCounter = 0x10;
      }
      stackParameterB = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCounter,0x13);
      *(uint8_t *)stackParameterB = 0;
      unsignedSystemValue4 = StartSystemThread(stackParameterB);
      UnsignedStackFlag88 = CONCAT44(UnsignedStackFlag88._4_4_,unsignedSystemValue4);
        memcpy(stackParameterB,&SystemStringBuffer,systemFlag);
    }
    SystemConfigurationValue = 0;
    InitializeSystemResourceObject(&stackParameterA,SystemParameter);
    stackParameterA = &SystemGlobalDataReference;
    if (stackParameterB != (void* *)0x0) {
        SystemCleanupFunction();
    }
  }
  return;
}




/**
 * @brief 空操作函数
 * 
 * 该函数是一个空操作函数，什么都不做，直接返回。
 * 主要用于占位或作为默认的处理函数。
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_180066dd0，现已重命名为EmptyOperation
 */
void EmptyOperation(void)

{
  return;
}





/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括内存分配器、数据表和资源偏移的设置。
 * 主要用于系统资源管理器的初始化和配置。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 * 原始函数名为FUN_180066df0，现已重命名为InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(long long *ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  void** SystemDataTable;
  long long localResourceOffset;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
  nextDataIndex = 0;
  if (punsignedSystemValue4 < (void* *)ResourceManagerPointer[2]) {
    ResourceManagerPointer[1] = (long long)(punsignedSystemValue4 + 4);
    *punsignedSystemValue4 = &SystemMemoryAllocatorReference;
    punsignedSystemValue4[1] = 0;
    *(uint32_t *)(punsignedSystemValue4 + 2) = 0;
    *punsignedSystemValue4 = &SystemGlobalDataReference;
    punsignedSystemValue4[3] = 0;
    punsignedSystemValue4[1] = 0;
    *(uint32_t *)(punsignedSystemValue4 + 2) = 0;
    *(uint32_t *)(punsignedSystemValue4 + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
    punsignedSystemValue4[1] = *(void* *)(ConfigurationDataPointer + 8);
    *(uint32_t *)((long long)punsignedSystemValue4 + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
    *(uint32_t *)(punsignedSystemValue4 + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
    *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
    *(void* *)(ConfigurationDataPointer + 8) = 0;
    *(void* *)(ConfigurationDataPointer + 0x18) = 0;
    return;
  }
  localResourceOffset = *ResourceManagerPointer;
  localSystemFlags = (long long)punsignedSystemValue4 - localResourceOffset >> 5;
  if (localSystemFlags == 0) {
    localSystemFlags = 1;
  }
  else {
    localSystemFlags = localSystemFlags * 2;
    if (localSystemFlags == 0) goto LAB_180066ec4;
  }
  nextDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemFlags << 5,(char)ResourceManagerPointer[3],ConfigurationFlag,0xfffffffffffffffe);
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
  localResourceOffset = *ResourceManagerPointer;
LAB_180066ec4:
  HashEntryStatus = (void* *)CopySystemResourceDataExtended(localResourceOffset,punsignedSystemValue4,nextDataIndex);
  *HashEntryStatus = &SystemMemoryAllocatorReference;
  HashEntryStatus[1] = 0;
  *(uint32_t *)(HashEntryStatus + 2) = 0;
  *HashEntryStatus = &SystemGlobalDataReference;
  HashEntryStatus[3] = 0;
  HashEntryStatus[1] = 0;
  *(uint32_t *)(HashEntryStatus + 2) = 0;
  *(uint32_t *)(HashEntryStatus + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  HashEntryStatus[1] = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)((long long)HashEntryStatus + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(HashEntryStatus + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  punsignedSystemValue4 = (void* *)ResourceManagerPointer[1];
  pcurrentThreadId = (void* *)*ResourceManagerPointer;
  if (pcurrentThreadId != punsignedSystemValue4) {
    do {
      (**(code **)*pcurrentThreadId)(pcurrentThreadId,0);
      pcurrentThreadId = pcurrentThreadId + 4;
    } while (pcurrentThreadId != punsignedSystemValue4);
    pcurrentThreadId = (void* *)*ResourceManagerPointer;
  }
  if (pcurrentThreadId == (void* *)0x0) {
    *ResourceManagerPointer = nextDataIndex;
    ResourceManagerPointer[1] = (long long)(HashEntryStatus + 4);
    ResourceManagerPointer[2] = localSystemFlags * 0x20 + nextDataIndex;
    return;
  }
    SystemCleanupFunction(pcurrentThreadId);
}



/**
 * @brief 在内存中搜索数据模式
 * 
 * 该函数负责在指定的内存区域中搜索特定的数据模式。
 * 它会使用memchr和memcmp函数来查找匹配的数据模式。
 * 
 * @param ResourceManagerPointer 系统资源指针（搜索起始地址）
 * @param ConfigurationDataPointer 配置数据指针（搜索区域大小）
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志（搜索模式）
 * @param DataSize 数据大小
 * @return 返回找到的数据偏移量，如果没有找到则返回-1
 */
long long SearchDataPatternInMemory(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,char *ConfigurationFlag,
                      ulong long DataSize)

{
  char SystemNodeFlag;
  int systemResult;
  long long localResourceOffset;
  long long bufferBaseAddress;
  
  if (DataSize <= ConfigurationDataPointer) {
    if (DataSize == 0) {
      return 0;
    }
    charStatus = *ConfigurationFlag;
    bufferBaseAddress = (ResourceManagerPointer - DataSize) + ConfigurationDataPointer;
    for (localResourceOffset = memchr(ResourceManagerPointer,(int)charStatus,(bufferBaseAddress + 1) - ResourceManagerPointer); localResourceOffset != 0;
        localResourceOffset = memchr(localResourceOffset + 1,(int)charStatus,(bufferBaseAddress + 1) - (localResourceOffset + 1))) {
      systemResult = memcmp(localResourceOffset,ConfigurationFlag,DataSize);
      if (systemResult == 0) {
        return localResourceOffset - ResourceManagerPointer;
      }
    }
  }
  return -1;
}




/**
 * @brief 处理系统越界异常
 * 
 * 该函数负责处理系统越界异常，包括异常报告和异常处理。
 * 主要用于系统异常的处理和恢复。
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_180067050，现已重命名为HandleSystemOutOfRangeException
 */
void HandleSystemOutOfRangeException(void)

{
  code *systemFunctionPointer;
  
  __Xout_of_range_std__YAXPEBD_Z(&SystemErrorMessageOutOfRange);
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}




// 函数: void FreeSystemResourceMemory(long long *ResourceManagerPointer)
/**
 * @brief 释放系统资源内存
 * 
 * 该函数负责释放系统资源内存，处理内存分配和释放操作
 * 用于系统资源管理和内存清理
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_180067070，现已重命名为FreeSystemResourceMemory
 */
void FreeSystemResourceMemory(long long *ResourceManagerPointer)

{
  ulong long systemStatus;
  long long localSystemHandle;
  long long localResourceOffset;
  
  systemStatus = ResourceManagerPointer[3];
  if (0xf < systemStatus) {
    localSystemHandle = *ResourceManagerPointer;
    localResourceOffset = localSystemHandle;
    if (0xfff < systemStatus + 1) {
      localResourceOffset = *(long long *)(localSystemHandle + -8);
      if (0x1f < (localSystemHandle - localResourceOffset) - 8U) {
          _invalid_parameter_noinfo_noreturn(localSystemHandle - localResourceOffset,systemStatus + 0x28);
      }
    }
    free(localResourceOffset);
  }
  ResourceManagerPointer[2] = 0;
  ResourceManagerPointer[3] = 0xf;
  *(uint8_t *)ResourceManagerPointer = 0;
  return;
}




// 函数: void ExecuteSystemResourceMemoryFree(void)
/**
 * @brief 执行系统资源内存释放
 * 
 * 该函数负责执行系统资源内存释放操作，调用内存释放函数
 * 用于系统资源清理和内存管理
 * 
 * 原始函数名为FUN_1800670d0，现已重命名为ExecuteSystemResourceMemoryFree
 */
void ExecuteSystemResourceMemoryFree(void)

{
  FreeSystemResourceMemory();
  return;
}




/**
 * @brief 处理长度错误异常
 * 
 * 该函数负责处理系统中的长度错误异常，调用标准库的长度错误处理函数，
 * 然后通过软件中断执行错误处理程序。
 * 
 * 原始函数名为FUN_1800670f0，现已重命名为HandleLengthError
 */
void HandleLengthError(void)

{
  code *systemFunctionPointer;
  
  __Xlength_error_std__YAXPEBD_Z(&SystemErrorMessageLengthError);
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}




/**
 * @brief 系统内存分配器
 * 
 * 该函数负责分配系统内存，根据请求的大小进行内存分配。
 * 对于小内存请求使用标准malloc，对于大内存请求使用系统级别的内存分配。
 * 
 * @param MemoryAllocationSize 内存分配大小
 * @return 返回分配的内存地址
 * 
 * 原始函数名为FUN_180067110，现已重命名为AllocateSystemMemory
 */
void* AllocateSystemMemory(ulong long MemoryAllocationSize)

{
  code *systemExceptionHandler;
  int memoryAllocationResult;
  long long allocatedMemoryAddress;
  ulong long adjustedMemorySize;
  
  if (0xfff < MemoryAllocationSize) {
    adjustedMemorySize = MemoryAllocationSize + 0x27;
    if (adjustedMemorySize <= MemoryAllocationSize) {
      adjustedMemorySize = 0xffffffffffffffff;
    }
    allocatedMemoryAddress = SystemLevelMemoryAllocation(adjustedMemorySize);
    if (allocatedMemoryAddress == 0) {
        _invalid_parameter_noinfo_noreturn();
    }
    *(long long *)((allocatedMemoryAddress + 0x27U & 0xffffffffffffffe0) - 8) = allocatedMemoryAddress;
    return;
  }
  if (MemoryAllocationSize == 0) {
    return;
  }
  do {
    allocatedMemoryAddress = malloc(MemoryAllocationSize);
    if (allocatedMemoryAddress != 0) {
      return;
    }
    memoryAllocationResult = _callnewh(MemoryAllocationSize);
  } while (memoryAllocationResult != 0);
  if (MemoryAllocationSize == 0xffffffffffffffff) {
    SystemExceptionHandler();
    systemExceptionHandler = (code *)swi(3);
    (*systemExceptionHandler)();
    return;
  }
  SystemCleanupHandler();
  systemExceptionHandler = (code *)swi(3);
  (*systemExceptionHandler)();
  return;
}




/**
 * @brief 系统内存释放器
 * 
 * 该函数负责释放系统内存，根据内存地址和大小进行内存释放。
 * 对于大内存块使用特殊的释放机制，对于小内存块使用标准free。
 * 
 * @param MemoryAddress 内存地址
 * @param MemorySize 内存大小
 * 
 * 原始函数名为FUN_180067170，现已重命名为FreeSystemMemory
 */
void FreeSystemMemory(long long MemoryAddress,ulong long MemorySize)

{
  long long memoryBlockPointer;
  
  memoryBlockPointer = MemoryAddress;
  if (0xfff < MemorySize) {
    memoryBlockPointer = *(long long *)(MemoryAddress + -8);
    if (0x1f < (MemoryAddress - memoryBlockPointer) - 8U) {
        _invalid_parameter_noinfo_noreturn(MemoryAddress - memoryBlockPointer,MemorySize + 0x27);
    }
  }
  free(memoryBlockPointer);
  return;
}




/**
 * @brief 系统数据缓冲区重新分配器
 * 
 * 该函数负责重新分配系统数据缓冲区，根据新的参数调整缓冲区大小。
 * 主要用于系统数据缓冲区的动态调整和优化。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数，指定新的缓冲区大小
 * 
 * 原始函数名为FUN_1800671b0，现已重命名为ReallocateSystemDataBuffer
 */
void ReallocateSystemDataBuffer(void* *ResourceManagerPointer,void* ConfigurationDataPointer,ulong long AdditionalParameter)

{
  ulong long currentBufferSize;
  code *systemExceptionHandler;
  void* allocatedMemoryBuffer;
  ulong long adjustedBufferSize;
  void* *bufferDataPointer;
  ulong long maximumBufferSize;
  
  currentBufferSize = ResourceManagerPointer[3];
  if (AdditionalParameter <= currentBufferSize) {
    bufferDataPointer = ResourceManagerPointer;
    if (0xf < currentBufferSize) {
      bufferDataPointer = (void* *)*ResourceManagerPointer;
    }
    ResourceManagerPointer[2] = AdditionalParameter;
      memmove(bufferDataPointer);
  }
  if (AdditionalParameter < 0x8000000000000000) {
    adjustedBufferSize = AdditionalParameter | 0xf;
    maximumBufferSize = 0x7fffffffffffffff;
    if (((adjustedBufferSize < 0x8000000000000000) && (currentBufferSize <= 0x7fffffffffffffff - (currentBufferSize >> 1))) &&
       (currentBufferSize = (currentBufferSize >> 1) + currentBufferSize, maximumBufferSize = adjustedBufferSize, adjustedBufferSize < currentBufferSize)) {
      maximumBufferSize = currentBufferSize;
    }
    allocatedMemoryBuffer = AllocateSystemMemory(maximumBufferSize + 1);
    ResourceManagerPointer[2] = AdditionalParameter;
    ResourceManagerPointer[3] = maximumBufferSize;
      memcpy(allocatedMemoryBuffer,ConfigurationDataPointer,AdditionalParameter);
  }
  FUN_1800670f0();
  systemExceptionHandler = (code *)swi(3);
  (*systemExceptionHandler)();
  return;
}




/**
 * @brief 系统字符串缓冲区分配器
 * 
 * 该函数负责分配系统字符串缓冲区，根据请求的大小进行内存分配和设置。
 * 主要用于系统字符串处理的内存分配和初始化。
 * 
 * @param StringBufferSize 字符串缓冲区大小
 * 
 * 原始函数名为FUN_18006720b，现已重命名为AllocateStringBuffer
 */
void AllocateStringBuffer(ulong long StringBufferSize)

{
  ulong long calculatedBufferSize;
  void* allocatedStringBuffer;
  long long stringMemoryBlockPtr;
  ulong long stringStackFrameSize;
  void* stringIteratorPtr;
  ulong long stringDataIndex;
  
  StringBufferSize = StringBufferSize | 0xf;
  if (((StringBufferSize <= stringDataIndex) && (stringStackFrameSize <= stringDataIndex - (stringStackFrameSize >> 1))) &&
     (calculatedBufferSize = (stringStackFrameSize >> 1) + stringStackFrameSize, stringDataIndex = StringBufferSize, StringBufferSize < calculatedBufferSize)) {
    stringDataIndex = calculatedBufferSize;
  }
  allocatedStringBuffer = AllocateSystemMemory(stringDataIndex + 1);
  *(void* *)(stringMemoryBlockPtr + 0x10) = stringIteratorPtr;
  *(ulong long *)(stringMemoryBlockPtr + 0x18) = stringDataIndex;
    memcpy(allocatedStringBuffer);
}




/**
 * @brief 系统空操作函数B
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 * 原始函数名为FUN_18006729a，现已重命名为SystemNoOperationB
 */
void SystemNoOperationB(void)

{
  return;
}




/**
 * @brief 系统参数错误处理器
 * 
 * 该函数负责处理系统参数错误，当参数无效时调用错误处理函数。
 * 主要用于系统参数验证和错误处理。
 * 
 * 原始函数名为FUN_1800672b0，现已重命名为HandleSystemParameterError
 */
void HandleSystemParameterError(void)

{
    _invalid_parameter_noinfo_noreturn();
}




/**
 * @brief 处理系统长度错误和软件中断
 * 
 * 该函数负责处理系统长度错误，并通过软件中断执行错误处理程序
 * 用于系统错误处理和异常管理
 * 
 * 原始函数名为FUN_1800672b7，现已重命名为HandleSystemLengthErrorAndSWI
 */
void HandleSystemLengthErrorAndSWI(void)

{
  code *systemFunctionPointer;
  
  HandleLengthError();
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}





/**
 * @brief 处理系统资源队列和完成状态
 * 
 * 该函数负责处理系统资源队列，获取完成状态并处理线程优先级
 * 用于系统资源管理和队列处理
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_1800672c0，现已重命名为ProcessSystemResourceQueueAndCompletion
 */
void ProcessSystemResourceQueueAndCompletion(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  int MemoryComparisonResult;
  void* unsignedSystemValue4;
  void* currentThreadId;
  long long *plocalSystemFlags;
  uint auStackX_8 [2];
  long long lStackX_10;
  long long lStackX_18;
  long long *plStackX_20;
  uint32_t processFlags70;
  uint32_t uStack_6c;
  uint32_t EncryptionValue68;
  uint32_t uStack_64;
  uint32_t unsignedValue60;
  uint32_t uStack_5c;
  uint32_t processFlags58;
  uint32_t uStack_54;
  void* *memoryAllocationEnd;
  void* *pEncryptionValue48;
  
  unsignedSystemValue4 = GetCurrentThread();
  SetThreadPriority(unsignedSystemValue4,0);
  auStackX_8[0] = 0;
  lStackX_18 = 0;
  lStackX_10 = 0;
  while( true ) {
    while( true ) {
      systemCounter = GetQueuedCompletionStatus
                        (*(void* *)(ResourceManagerPointer + 0x28),auStackX_8,&lStackX_18,&lStackX_10,
                         0xffffffff);
      localSystemHandle = lStackX_10;
      if (systemCounter == 0) break;
      if (lStackX_18 == -1) {
        return;
      }
      *(long long *)(lStackX_10 + 0x1c8) =
           *(long long *)(lStackX_10 + 0x1c8) - (ulong long)auStackX_8[0];
      unsignedSystemValue4 = SystemManagerPointerStorage;
      if (*(long long *)(lStackX_10 + 0x1c8) < 1) {
        nextDataIndex = *(long long *)(ResourceManagerPointer + 0x20);
        currentThreadId = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x40,8,10);
        plStackX_20 = (long long *)&unsignedValue60;
        memoryAllocationEnd = &SystemMemoryAllocationEndMarker;
        pEncryptionValue48 = &SystemMemoryAllocationStartMarker;
        processFlags70 = (uint32_t)unsignedSystemValue4;
        uStack_6c = (uint32_t)((ulong long)unsignedSystemValue4 >> 0x20);
        EncryptionValue68 = (uint32_t)localSystemHandle;
        uStack_64 = (uint32_t)((ulong long)localSystemHandle >> 0x20);
        unsignedValue60 = processFlags70;
        uStack_5c = uStack_6c;
        processFlags58 = EncryptionValue68;
        uStack_54 = uStack_64;
        plocalSystemFlags = (long long *)InitializeSystemResource(currentThreadId,&unsignedValue60);
        if (plocalSystemFlags != (long long *)0x0) {
          (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
        }
        unsignedSystemValue4 = SystemAllocationFlagsTemplate;
        plStackX_20 = plocalSystemFlags;
        if (*(char *)(nextDataIndex + 0x368) == '\0') {
          plocalSystemFlags[3] = -4;
          (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
          ProcessSystemResourceSemaphore(unsignedSystemValue4,&plStackX_20);
        }
        else {
          if (plocalSystemFlags != (long long *)0x0) {
            (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
          }
          ReleaseSystemResourceSemaphore(unsignedSystemValue4,&plStackX_20);
        }
        if (plocalSystemFlags != (long long *)0x0) {
          (**(code **)(*plocalSystemFlags + 0x38))(plocalSystemFlags);
        }
      }
    }
    systemCounter = GetLastError();
    if (systemCounter == 0x2df) {
      return;
    }
    if (lStackX_10 == 0) break;
    UpdateSystemResourceContextManager(*(void* )(ResourceManagerPointer + 0x20));
  }
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemContextUpdateData,systemCounter);
}





/**
 * @brief 更新系统资源上下文管理器
 * 
 * 该函数负责更新系统资源上下文管理器，处理字符串模板和配置数据
 * 用于系统资源管理和上下文更新
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180067480，现已重命名为UpdateSystemResourceContextManager
 */
void UpdateSystemResourceContextManager(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  void* *HashEntryStatus;
  
  pointerToUnsigned1 = *(void* **)(*(long long *)(ConfigurationDataPointer + 0x1f8) + 0x10);
  HashEntryStatus = &SystemStringTemplate;
  if (pointerToUnsigned1 != (void* *)0x0) {
    HashEntryStatus = pointerToUnsigned1;
  }
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemErrorMessageContextManager,HashEntryStatus);
}




/**
 * @brief 执行系统资源操作
 * 
 * 该函数负责执行系统资源操作，调用系统资源指针中的代码函数
 * 用于系统资源管理和操作执行
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_180067810，现已重命名为ExecuteSystemResourceOperation
 */
void ExecuteSystemResourceOperation(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(ResourceManagerPointer + 0x10) != (code *)0x0) {
    (**(code **)(ResourceManagerPointer + 0x10))(ResourceManagerPointer,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  return;
}





// 函数: void FreeSystemResourceMemoryEx(long long *ResourceManagerPointer)
/**
 * @brief 处理系统资源内存分配和缓冲区管理
 * 
 * 该函数负责处理系统资源的内存分配操作，包括缓冲区管理、
 * 内存模板配置和系统资源的状态更新
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_180067840，现已重命名为ProcessSystemResourceMemoryAllocation
 */
void ProcessSystemResourceMemoryAllocation(long long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  long long bufferBaseAddress;
  void* currentThreadId;
  void* hashValue;
  void** SystemCurrentNode;
  long long *plocalMemoryAddress;
  int systemId;
  long long lStackX_8;
  void** HashBucketNode;
  long long lStack_c8;
  long long lStack_c0;
  void* UnsignedStackFlagB8;
  void*2 UnsignedStackFlagB0;
  uint8_t uStack_ae;
  uint8_t StackBuffer [64];
  void* EncryptionValue48;
  void* unsignedValue40;
  
  EncryptionValue48 = 0xfffffffffffffffe;
  localResourceOffset = ResourceManagerPointer[1];
  systemId = *(int *)(localResourceOffset + 0x138) - *(int *)(localResourceOffset + 0x1d8);
  bufferBaseAddress = *(long long *)(localResourceOffset + 0x150);
  plocalMemoryAddress = (long long *)0x0;
  if (bufferBaseAddress != 0) {
    currentThreadId = *(void* *)(localResourceOffset + 0x158);
    hashValue = *(void* *)(localResourceOffset + 0x1e0);
    lStackX_8 = *(long long *)(localResourceOffset + 0x140);
    localResourceOffset = *(long long *)(localResourceOffset + 0x1f0);
    if (bufferBaseAddress - 2U < 2) {
      plocalMemoryAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x10,8,3);
      *plocalMemoryAddress = (long long)&SystemMemoryPoolTemplate;
      *(bool *)(plocalMemoryAddress + 1) = bufferBaseAddress == 3;
    }
    (**(code **)(*plocalMemoryAddress + 0x18))(plocalMemoryAddress,StackBuffer,systemId + localResourceOffset,lStackX_8,hashValue,currentThreadId);
      SystemCleanupFunction(plocalMemoryAddress);
  }
  uStack_ae = 3;
  localResourceOffset = ResourceManagerPointer[1];
  UnsignedStackFlagB8 = *(void* *)(localResourceOffset + 0x140);
  lStack_c8 = (long long)systemId + *(long long *)(localResourceOffset + 0x1f0);
  UnsignedStackFlagB0 = 1;
  lStack_c0 = lStack_c8;
  (**(code **)(localResourceOffset + 0x180))(&lStack_c8,*(long long *)(localResourceOffset + 0x1f8) + 8);
  if (((char)UnsignedStackFlagB0 == '\0') && (lStack_c8 != 0)) {
      SystemCleanupFunction();
  }
  LOCK();
  pointerToInteger1 = (int *)(*(long long *)(ResourceManagerPointer[1] + 0x1f8) + 0x120);
  *pointerToInteger1 = *pointerToInteger1 + -1;
  UNLOCK();
  lStackX_8 = *(long long *)(ResourceManagerPointer[1] + 0x1a8);
  localResourceOffset = *ResourceManagerPointer;
  AllocateSystemResource(localResourceOffset + 0x10,&lStackX_8);
  systemId = _Cnd_signal(localResourceOffset + 0x278);
  if (systemId != 0) {
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  puStackX_10 = *(void* **)(ResourceManagerPointer[1] + 0x1b0);
  localResourceOffset = *ResourceManagerPointer;
  AllocateSystemResource(localResourceOffset + 0x10,&puStackX_10);
  systemId = _Cnd_signal(localResourceOffset + 0x278);
  if (systemId != 0) {
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  localResourceOffset = *(long long *)(ResourceManagerPointer[1] + 0x1c0);
  if (*(long long *)(ResourceManagerPointer[1] + 0x1b8) != 0) {
      SystemCleanupFunction();
  }
  if (localResourceOffset != 0) {
      SystemCleanupFunction(localResourceOffset);
  }
  localResourceOffset = ResourceManagerPointer[1];
  if (*(long long *)(localResourceOffset + 0x150) == 0) {
    if (*(long long *)(localResourceOffset + 0x148) == 0) {
      plocalMemoryAddress = *(long long **)(localResourceOffset + 0x140);
    }
  }
  else {
    plocalMemoryAddress = *(long long **)(localResourceOffset + 0x140);
    if (*(long long *)(localResourceOffset + 0x148) == 0) {
      plocalMemoryAddress = (long long *)((long long)plocalMemoryAddress + *(long long *)(localResourceOffset + 0x158));
    }
  }
  LOCK();
  resourcePoolPointer = (long long *)(*(long long *)(*ResourceManagerPointer + 8) + 0x3f0);
  *resourcePoolPointer = *resourcePoolPointer - (long long)plocalMemoryAddress;
  UNLOCK();
  LOCK();
  pointerToInteger1 = (int *)(*(long long *)(*ResourceManagerPointer + 8) + 0x3f8);
  *pointerToInteger1 = *pointerToInteger1 + -1;
  UNLOCK();
  bufferBaseAddress = *ResourceManagerPointer;
  HashBucketNode = (void* *)ResourceManagerPointer[1];
  localResourceOffset = bufferBaseAddress + 0x200380;
  unsignedValue40 = 0x180068808;
  lStackX_8 = localResourceOffset;
  puStackX_10 = HashBucketNode;
  systemId = _Mtx_lock(localResourceOffset);
  if (systemId != 0) {
    unsignedValue40 = 0x180068815;
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  unsignedValue40 = 0x18006881f;
  ReleaseSystemResource(HashBucketNode + 4);
  *HashBucketNode = *(void* *)(bufferBaseAddress + 0x200378);
  *(void* **)(bufferBaseAddress + 0x200378) = HashBucketNode;
  unsignedValue40 = 0x18006883a;
  systemId = _Mtx_unlock(localResourceOffset);
  if (systemId != 0) {
    unsignedValue40 = 0x180068847;
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  return;
}





// 函数: void CleanupAndInitializeSystemResource(void* *ResourceManagerPointer)
/**
 * @brief 系统资源清理和初始化函数
 * 
 * 该函数负责系统资源的清理操作，包括内存释放、
 * 资源重置和状态初始化
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_180067bc0，现已重命名为CleanupAndInitializeSystemResource
 */
void CleanupAndInitializeSystemResource(void* *ResourceManagerPointer)

{
  uint8_t aUnsignedStackFlagB8 [48];
  void* *pUnsignedStackFlag88;
  void* processFlags70;
  void* *pEncryptionValue68;
  ulong long unsignedValue30;
  
  processFlags70 = 0xfffffffffffffffe;
  unsignedValue30 = SystemEncryptionKeyTemplate ^ (ulong long)aUnsignedStackFlagB8;
  pEncryptionValue68 = ResourceManagerPointer;
  DestroyResourceManagerPointer();
  *ResourceManagerPointer = &SystemResourceEncryptionKeyTemplate;
  pUnsignedStackFlag88 = ResourceManagerPointer + 0x6e;
    memset(pUnsignedStackFlag88,0,0x200000);
}




// 函数: void DestroySystemMutex(void)
/**
 * @brief 系统互斥锁销毁函数
 * 
 * 该函数负责销毁系统互斥锁，清理线程同步资源
 * 
 * 原始函数名为FUN_180067f00，现已重命名为DestroySystemMutex
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: void DestroySystemMutexB(void)
/**
 * @brief 系统互斥锁销毁函数B
 * 
 * 该函数负责销毁系统互斥锁，清理线程同步资源
 * 这是DestroySystemMutex的另一个版本
 * 
 * 原始函数名为FUN_180067f30，现已重命名为DestroySystemMutexB
 */
void DestroySystemMutexB(void)

{
  _Mtx_destroy_in_situ();
  return;
}





// 函数: void CreateSystemIoCompletionPort(long long ResourceManagerPointer,long long ConfigurationDataPointer)
void CreateSystemIoCompletionPort(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  int systemStatus;
  long long localSystemHandle;
  long long localResourceOffset;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  ulong long hashValue;
  uint unsignedSystemValue7;
  uint8_t auStack_2e8 [32];
  ulong long uStack_2c8;
  uint32_t uStack_2c0;
  void* unsignedValue2b8;
  long long lStack_2a8;
  void* uStack_2a0;
  long long alStack_288 [4];
  void* *pointerUnsigned268;
  void* *puStack_260;
  ulong long EncryptionValue48;
  ulong long unsignedSystemValue8;
  
  uStack_2a0 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_2e8;
  FUN_180624440(&pointerUnsigned268);
  punsignedSystemValue4 = &SystemStringTemplate;
  if (puStack_260 != (void* *)0x0) {
    punsignedSystemValue4 = puStack_260;
  }
  hashValue = 0;
  unsignedValue2b8 = 0;
  uStack_2c0 = 0x60000001;
  uStack_2c8 = CONCAT44(uStack_2c8._4_4_,3);
  localSystemHandle = CreateFileA(punsignedSystemValue4,0x80000000,1,0);
  if (localSystemHandle == -1) {
    punsignedSystemValue4 = &SystemStringTemplate;
    if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
      punsignedSystemValue4 = *(void* **)(ConfigurationDataPointer + 8);
    }
      UpdateContextManagerSystem(SystemContextManagerPointer,&SystemErrorMessageFileCreation,punsignedSystemValue4);
  }
  localResourceOffset = CreateIoCompletionPort(localSystemHandle,*(void* *)(ResourceManagerPointer + 0x213430),0,0);
  if (localResourceOffset != *(long long *)(ResourceManagerPointer + 0x213430)) {
    punsignedSystemValue4 = &SystemStringTemplate;
    if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
      punsignedSystemValue4 = *(void* **)(ConfigurationDataPointer + 8);
    }
      UpdateContextManagerSystem(SystemContextManagerPointer,&SystemConfigurationUpdateData,punsignedSystemValue4);
  }
  localResourceOffset = ResourceManagerPointer + 0x2133e0;
  lStack_2a8 = localResourceOffset;
  systemStatus = _Mtx_lock(localResourceOffset);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  pcurrentThreadId = *(void* **)(ResourceManagerPointer + 0x2133d8);
  if (pcurrentThreadId == (void* *)0x0) {
    unsignedSystemValue8 = *(ulong long *)(ResourceManagerPointer + 0x2133d0);
    if (0xff < unsignedSystemValue8) {
      systemStatus = _Mtx_unlock(localResourceOffset);
      if (systemStatus != 0) {
        __Throw_C_error_std__YAXH_Z(systemStatus);
      }
      _SystemConfigSizePtr = *(uint32_t *)(ConfigurationDataPointer + 0x10);
      punsignedSystemValue4 = &SystemStringTemplate;
      if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
        punsignedSystemValue4 = *(void* **)(ConfigurationDataPointer + 8);
      }
      strcpy_s(_SystemStringBufferPtr,0x100,punsignedSystemValue4);
      unsignedSystemValue8 = hashValue;
      if (0 < *(int *)(ConfigurationDataPointer + 0x10)) {
        do {
          hashValue = hashValue * 0x1f + (long long)*(char *)(unsignedSystemValue8 + *(long long *)(ComparisonDataPointer + 8));
          unsignedSystemValue7 = (int)unsignedSystemValue8 + 1;
          unsignedSystemValue8 = (ulong long)unsignedSystemValue7;
        } while ((int)unsignedSystemValue7 < *(int *)(ConfigurationDataPointer + 0x10));
      }
      lRam0000000000000128 = localSystemHandle;
      uStack_2c8 = hashValue;
      ConfigureSystemResourceAllocation(ResourceManagerPointer + 0x330,alStack_288,unsignedSystemValue8,ConfigurationDataPointer);
      *(void* *)(alStack_288[0] + 0x118) = 0;
      pointerUnsigned268 = &SystemMemoryAllocatorReference;
        ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)auStack_2e8);
    }
    pcurrentThreadId = (void* *)(unsignedSystemValue8 * 0x130 + ResourceManagerPointer + 0x2003d0);
    *(ulong long *)(ResourceManagerPointer + 0x2133d0) = unsignedSystemValue8 + 1;
  }
  else {
    *(void* *)(ResourceManagerPointer + 0x2133d8) = *pcurrentThreadId;
  }
    memset(pcurrentThreadId + 1,0,0x128);
}




/**
 * @brief 系统内存分配和互斥锁管理函数
 * 
 * 该函数负责管理系统内存分配，包括内存对齐、互斥锁操作和内存页面管理。
 * 用于系统内存资源的动态分配和同步控制。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数（包含内存分配信息）
 * @return 分配结果或错误代码
 * 
 * 原始函数名为FUN_180068250，现已重命名为AllocateSystemMemoryWithMutex
 */
void* AllocateSystemMemoryWithMutex(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  ulong long systemStatus;
  char validationStatusFlag;
  int MemoryComparisonResult;
  void* unsignedSystemValue4;
  ulong long currentThreadId;
  void** SystemRootNode;
  ulong long unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  
  unsignedSystemValue8 = *(ulong long *)(AdditionalParameter + 0x118) & 0xfffffffffffff000;
  currentThreadId = (*(long long *)(AdditionalParameter + 0x120) - unsignedSystemValue8) + *(ulong long *)(AdditionalParameter + 0x118);
  unsignedSystemValue7 = (ulong long)(-(uint)((currentThreadId & 0xfff) != 0) & 0x1000) + (currentThreadId & 0xfffffffffffff000);
  systemCounter = _Mtx_lock(ResourceManagerPointer + 0x200380);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  resourceEntryPointer = *(void* **)(ResourceManagerPointer + 0x200378);
  if (resourceEntryPointer == (void* *)0x0) {
    systemStatus = *(ulong long *)(ResourceManagerPointer + 0x200370);
    if (0xfff < systemStatus) {
      systemCounter = _Mtx_unlock(ResourceManagerPointer + 0x200380);
      if (systemCounter != 0) {
        __Throw_C_error_std__YAXH_Z(systemCounter);
      }
      ConfigureSystemResourceAllocation(0x20,AdditionalParameter);
      uRam00000000000001f0 = 0;
      uRam00000000000001e8 = 0;
      uRam00000000000001e0 = 0;
      charResult = ConfigureResourceManager(ResourceManagerPointer,0x20,0x1e0,0x1e8,0x1f0);
      if (validationStatusFlag == '\0') {
        ProcessSystemResourceData(ResourceManagerPointer + 0x370,0);
        unsignedSystemValue4 = 0;
      }
      else {
        _SystemDataNullPtr = 0;
        _SystemDataBufferPtr = 0;
        _SystemConfigSizePtr = 0;
        LOCK();
        _SystemStringBufferPtr = unsignedSystemValue8;
        uRam00000000000001c8 = currentThreadId;
        uRam00000000000001d0 = unsignedSystemValue7;
        uRam00000000000001d8 = unsignedSystemValue8;
        lRam00000000000001f8 = ConfigurationDataPointer;
        *(int *)(ConfigurationDataPointer + 0x120) = *(int *)(ConfigurationDataPointer + 0x120) + 1;
        UNLOCK();
        systemCounter = ReadFile(*(void* *)(ConfigurationDataPointer + 0x128),uRam00000000000001f0,unsignedSystemValue7 & 0xffffffff,0,
                         0);
        if (systemCounter != 0) {
            UpdateContextManagerSystem(SystemContextManagerPointer,&SystemStateUpdateData);
        }
        systemCounter = GetLastError();
        if (systemCounter != 0x3e5) {
            UpdateContextManagerSystem(SystemContextManagerPointer,&SystemStatusUpdateData,systemCounter);
        }
        unsignedSystemValue4 = 1;
      }
      return unsignedSystemValue4;
    }
    resourceEntryPointer = (void* *)(systemStatus * 0x200 + ResourceManagerPointer + 0x370);
    *(ulong long *)(ResourceManagerPointer + 0x200370) = systemStatus + 1;
  }
  else {
    *(void* *)(ResourceManagerPointer + 0x200378) = *resourceEntryPointer;
    *resourceEntryPointer = 0;
  }
    memset(resourceEntryPointer,0,0x200);
}



/**
 * @brief 复制系统配置数据
 * 
 * 该函数负责复制系统配置数据，将配置数据从一个资源复制到另一个资源。
 * 它会复制字符串模板、指针和各个配置字段，并调用相应的回调函数。
 * 
 * @param ResourceManagerPointer 目标系统资源指针
 * @param ConfigurationDataPointer 源配置数据指针
 * @return 返回目标系统资源指针
 */
long long CopySystemConfigurationData(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  code *stringProcessingPointer;
  void* *HashNodePointer;
  
  *(uint32_t *)(ResourceManagerPointer + 0x10) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  HashNodePointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    HashNodePointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x100,HashNodePointer);
  *(void* *)(ResourceManagerPointer + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
  nextDataIndex = ResourceManagerPointer + 0x148;
  *(void* *)(ResourceManagerPointer + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
  *(void* *)(ResourceManagerPointer + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
  *(void* *)(ResourceManagerPointer + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
  *(void* *)(ResourceManagerPointer + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
  *(uint8_t *)(ResourceManagerPointer + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
  if (nextDataIndex != ConfigurationDataPointer + 0x148) {
    if (*(code **)(ResourceManagerPointer + 0x158) != (code *)0x0) {
      (**(code **)(ResourceManagerPointer + 0x158))(nextDataIndex,0,0);
    }
    pcharResult = *(code **)(ConfigurationDataPointer + 0x158);
    if (stringProcessingPointer != (code *)0x0) {
      (*pcharResult)(nextDataIndex,ConfigurationDataPointer + 0x148,1);
      pcharResult = *(code **)(ConfigurationDataPointer + 0x158);
    }
    *(code **)(ResourceManagerPointer + 0x158) = pcharResult;
    *(void* *)(ResourceManagerPointer + 0x160) = *(void* *)(ConfigurationDataPointer + 0x160);
  }
  nextDataIndex = ResourceManagerPointer + 0x168;
  if (nextDataIndex != ConfigurationDataPointer + 0x168) {
    if (*(code **)(ResourceManagerPointer + 0x178) != (code *)0x0) {
      (**(code **)(ResourceManagerPointer + 0x178))(nextDataIndex,0,0);
    }
    pcharResult = *(code **)(ConfigurationDataPointer + 0x178);
    if (stringProcessingPointer != (code *)0x0) {
      (*pcharResult)(nextDataIndex,ConfigurationDataPointer + 0x168,1);
      pcharResult = *(code **)(ConfigurationDataPointer + 0x178);
    }
    *(code **)(ResourceManagerPointer + 0x178) = pcharResult;
    *(void* *)(ResourceManagerPointer + 0x180) = *(void* *)(ConfigurationDataPointer + 0x180);
  }
  *(void* *)(ResourceManagerPointer + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
  *(void* *)(ResourceManagerPointer + 400) = *(void* *)(ConfigurationDataPointer + 400);
  *(void* *)(ResourceManagerPointer + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
  *(void* *)(ResourceManagerPointer + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
  return ResourceManagerPointer;
}




// 函数: void ConfigureSystemResourceWithMutex(long long ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ConfigureSystemResourceWithMutex(long long ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  void* creationFlags;
  
  creationFlags = 0xfffffffffffffffe;
  CloseHandle(ConfigurationDataPointer[0x25]);
  systemStatus = _Mtx_lock(ResourceManagerPointer + 0x2133e0);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  (**(code **)*ConfigurationDataPointer)(ConfigurationDataPointer,0,AdditionalParameter,ConfigurationFlag,creationFlags);
  *ConfigurationDataPointer = *(void* *)(ResourceManagerPointer + 0x2133d8);
  *(void* **)(ResourceManagerPointer + 0x2133d8) = ConfigurationDataPointer;
  systemStatus = _Mtx_unlock(ResourceManagerPointer + 0x2133e0);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  return;
}




// 函数: void CleanupSystemResourceData(long long ResourceManagerPointer)
void CleanupSystemResourceData(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  char systemStatusFlag;
  long long *plocalSystemPointer;
  long long *plocalSystemFlags;
  long long *plocalDataIndex;
  long long *plStackX_8;
  
  systemStatusFlag = FindResourceManagerPointerMapping(ResourceManagerPointer + 0x10,&plStackX_8);
  do {
    if (systemStatusFlag == '\0') {
      return;
    }
    resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x318);
    if (plStackX_8 != (long long *)0x0) {
      *(uint8_t *)(plStackX_8 + 4) = 0;
      *resourcePoolPointer = *resourcePoolPointer - plStackX_8[1];
      resourcePoolPointer[2] = resourcePoolPointer[2] + plStackX_8[1];
      plocalDataIndex = (long long *)plStackX_8[3];
      plocalSystemFlags = (long long *)resourcePoolPointer[3];
      plocalSystemPointer = plStackX_8;
      if (plocalDataIndex != plocalSystemFlags) {
        do {
          if ((plocalDataIndex == (long long *)0x0) || ((char)plocalDataIndex[4] != '\0')) break;
          localResourceOffset = plocalSystemPointer[2];
          plocalDataIndex[2] = localResourceOffset;
          if (localResourceOffset != 0) {
            *(long long **)(localResourceOffset + 0x18) = plocalDataIndex;
          }
          plocalDataIndex[1] = plocalDataIndex[1] + plocalSystemPointer[1];
          *plocalSystemPointer = resourcePoolPointer[0x28005];
          resourcePoolPointer[0x28005] = (long long)plocalSystemPointer;
          plocalSystemFlags = (long long *)resourcePoolPointer[3];
          PrimaryResourcePointer = plocalDataIndex + 3;
          plocalSystemPointer = plocalDataIndex;
          plocalDataIndex = (long long *)*PrimaryResourcePointer;
        } while ((long long *)*PrimaryResourcePointer != plocalSystemFlags);
      }
      plocalDataIndex = (long long *)plocalSystemPointer[2];
      while (((plocalSystemPointer != plocalSystemFlags && (plocalDataIndex != (long long *)0x0)) && ((char)plocalDataIndex[4] == '\0'))) {
        localResourceOffset = plocalDataIndex[2];
        plocalSystemPointer[2] = localResourceOffset;
        if (localResourceOffset != 0) {
          *(long long **)(localResourceOffset + 0x18) = plocalSystemPointer;
        }
        plocalSystemPointer[1] = plocalSystemPointer[1] + plocalDataIndex[1];
        *plocalDataIndex = resourcePoolPointer[0x28005];
        resourcePoolPointer[0x28005] = (long long)plocalDataIndex;
        plocalSystemFlags = (long long *)resourcePoolPointer[3];
        plocalDataIndex = (long long *)plocalSystemPointer[2];
      }
    }
    systemStatusFlag = FindResourceManagerPointerMapping(ResourceManagerPointer + 0x10,&plStackX_8);
  } while( true );
}




// 函数: void ConfigureSystemResourceWithLock(long long ResourceManagerPointer,void* *ConfigurationDataPointer)
void ConfigureSystemResourceWithLock(long long ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  int systemStatus;
  
  systemStatus = _Mtx_lock(ResourceManagerPointer + 0x200010);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  ReleaseSystemResource(ConfigurationDataPointer + 4);
  *ConfigurationDataPointer = *(void* *)(ResourceManagerPointer + 0x200008);
  *(void* **)(ResourceManagerPointer + 0x200008) = ConfigurationDataPointer;
  systemStatus = _Mtx_unlock(ResourceManagerPointer + 0x200010);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  return;
}




/**
 * @brief 系统资源配置和初始化函数
 * 
 * 该函数负责系统资源的配置、内存分配和初始化工作
 * 根据资源管理器指针和数组大小来分配内存块，并设置相关配置
 * 
 * @param ResourceManagerPointer 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @param ArraySize 数组大小
 * @return 配置数据指针
 * 
 * 原始函数名为FUN_180068860，现已重命名为ConfigureSystemResourceAllocation
 */
long long *
ConfigureSystemResourceAllocation(long long ResourceManagerPointer,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag,
             ulong long ArraySize)

{
  long long nextDataIndex;
  ulong long creationFlags;
  long long localResourceOffset;
  void* unsignedSystemValue4;
  
  creationFlags = ArraySize % (ulong long)*(uint *)(ResourceManagerPointer + 0x10);
  localResourceOffset = AllocateSystemMemoryBlock(ResourceManagerPointer,*(void* *)(*(long long *)(ResourceManagerPointer + 8) + creationFlags * 8),
                              ConfigurationFlag);
  if (localResourceOffset == 0) {
    FUN_18066c220(ResourceManagerPointer + 0x20,&ArraySize,*(uint32_t *)(ResourceManagerPointer + 0x10),
                  *(uint32_t *)(ResourceManagerPointer + 0x18),1);
    localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x128,*(uint8_t *)(ResourceManagerPointer + 0x2c));
    InitializeSystemResourceStringTemplate(localResourceOffset,ConfigurationFlag);
    *(void* *)(localResourceOffset + 0x118) = 0;
    *(void* *)(localResourceOffset + 0x120) = 0;
    if ((char)ArraySize != '\0') {
      unsignedSystemValue4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(ulong long)ArraySize._4_4_ * 8 + 8,8,
                            *(uint8_t *)(ResourceManagerPointer + 0x2c));
        memset(unsignedSystemValue4,0,(ulong long)ArraySize._4_4_ * 8);
    }
    *(void* *)(localResourceOffset + 0x120) = *(void* *)(*(long long *)(ResourceManagerPointer + 8) + creationFlags * 8);
    *(long long *)(*(long long *)(ResourceManagerPointer + 8) + creationFlags * 8) = localResourceOffset;
    *(long long *)(ResourceManagerPointer + 0x18) = *(long long *)(ResourceManagerPointer + 0x18) + 1;
    nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
    *ConfigurationDataPointer = localResourceOffset;
    ConfigurationDataPointer[1] = nextDataIndex + creationFlags * 8;
    *(uint8_t *)(ConfigurationDataPointer + 2) = 1;
  }
  else {
    nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
    *ConfigurationDataPointer = localResourceOffset;
    ConfigurationDataPointer[1] = nextDataIndex + creationFlags * 8;
    *(uint8_t *)(ConfigurationDataPointer + 2) = 0;
  }
  return ConfigurationDataPointer;
}



/**
 * @brief 系统资源指针映射和查找函数
 * 
 * 该函数负责在系统资源指针和配置数据指针之间进行映射和查找操作，
 * 包括资源地址计算、偏移量处理和数据验证。用于系统资源的管理和访问。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针数组
 * @return 找到的资源指针或空指针
 * 
 * 原始函数名为FUN_180068a90，现已重命名为FindResourceManagerPointerMapping
 */
void* FindResourceManagerPointerMapping(ulong long *ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *HashEntryStatus;
  long long localResourceOffset;
  long long bufferBaseAddress;
  char operationStatusFlag;
  bool isThreadActive;
  ulong long unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  ulong long systemOperationFlags;
  ulong long systemStatus1;
  ulong long systemStatus2;
  ulong long systemStatus3;
  ulong long systemStatus4;
  
  systemStatus1 = *ResourceManagerPointer;
  systemOperationFlags = 0;
  unsignedSystemValue8 = systemOperationFlags;
  systemStatus2 = systemOperationFlags;
  systemStatus4 = systemOperationFlags;
  do {
    unsignedSystemValue9 = unsignedSystemValue8;
    if (systemStatus1 == 0) break;
    unsignedSystemValue7 = *(long long *)(systemStatus1 + 0x20) - *(long long *)(systemStatus1 + 0x28);
    if ((ulong long)(*(long long *)(systemStatus1 + 0x28) - *(long long *)(systemStatus1 + 0x20)) <
        0x8000000000000001) {
      unsignedSystemValue7 = systemOperationFlags;
    }
    systemStatus3 = systemStatus2;
    if ((unsignedSystemValue7 != 0) && (systemStatus4 = systemStatus4 + 1, unsignedSystemValue9 = systemStatus1, systemStatus3 = unsignedSystemValue7, unsignedSystemValue7 <= systemStatus2)) {
      unsignedSystemValue9 = unsignedSystemValue8;
      systemStatus3 = systemStatus2;
    }
    PrimaryResourcePointer = (long long *)(systemStatus1 + 8);
    systemStatus1 = *PrimaryResourcePointer - 8;
    if (*PrimaryResourcePointer == 0) {
      systemStatus1 = systemOperationFlags;
    }
    unsignedSystemValue8 = unsignedSystemValue9;
    systemStatus2 = systemStatus3;
  } while (systemStatus4 < 3);
  if (systemStatus4 != 0) {
    charValue = FUN_180068ce0(unsignedSystemValue9,ConfigurationDataPointer);
    if (charValue != '\0') {
      return 1;
    }
    systemStatus1 = *ResourceManagerPointer;
    while (systemStatus1 != 0) {
      if (systemStatus1 != unsignedSystemValue9) {
        bufferBaseAddress = *(long long *)(systemStatus1 + 0x38);
        if (*(char *)(systemStatus1 + 0x48) == '\0') {
          if ((ulong long)((*(long long *)(systemStatus1 + 0x30) - bufferBaseAddress) - *(long long *)(systemStatus1 + 0x20)) <
              0x8000000000000001) goto LAB_180068c92;
          LOCK();
          PrimaryResourcePointer = (long long *)(systemStatus1 + 0x30);
          localResourceOffset = *PrimaryResourcePointer;
          *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
          UNLOCK();
          if ((ulong long)((localResourceOffset - *(long long *)(systemStatus1 + 0x20)) - bufferBaseAddress) < 0x8000000000000001)
          goto LAB_180068c87;
          LOCK();
          HashEntryStatus = (ulong long *)(systemStatus1 + 0x28);
          unsignedSystemValue8 = *HashEntryStatus;
          *HashEntryStatus = *HashEntryStatus + 1;
          UNLOCK();
          PrimaryResourcePointer = *(long long **)(systemStatus1 + 0x60);
          localResourceOffset = *(long long *)
                   (PrimaryResourcePointer[3] +
                   (((unsignedSystemValue8 & 0xffffffffffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5)
                    + PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 8);
          bufferBaseAddress = *(long long *)(localResourceOffset + 8);
          *ConfigurationDataPointer = *(void* *)(bufferBaseAddress + (ulong long)((uint)unsignedSystemValue8 & 0x1f) * 8);
          LOCK();
          PrimaryResourcePointer = (long long *)(bufferBaseAddress + 0x108);
          bufferBaseAddress = *PrimaryResourcePointer;
          *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
          UNLOCK();
          if (bufferBaseAddress == 0x1f) {
            *(void* *)(localResourceOffset + 8) = 0;
            ReleaseSystemResourceHandle(*(void* *)(systemStatus1 + 0x50));
          }
          isThreadActive = true;
        }
        else {
          if (0x8000000000000000 <
              (ulong long)((*(long long *)(systemStatus1 + 0x30) - bufferBaseAddress) - *(long long *)(systemStatus1 + 0x20))) {
            LOCK();
            PrimaryResourcePointer = (long long *)(systemStatus1 + 0x30);
            localResourceOffset = *PrimaryResourcePointer;
            *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
            UNLOCK();
            if (0x8000000000000000 < (ulong long)((localResourceOffset - *(long long *)(systemStatus1 + 0x20)) - bufferBaseAddress)) {
              LOCK();
              HashEntryStatus = (ulong long *)(systemStatus1 + 0x28);
              unsignedSystemValue8 = *HashEntryStatus;
              *HashEntryStatus = *HashEntryStatus + 1;
              UNLOCK();
              PrimaryResourcePointer = *(long long **)(systemStatus1 + 0x58);
              systemStatus2 = (ulong long)((uint)unsignedSystemValue8 & 0x1f);
              bufferBaseAddress = *(long long *)
                       (PrimaryResourcePointer[2] + 8 +
                       (((unsignedSystemValue8 & 0xffffffffffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10)
                        >> 5) + PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
              *ConfigurationDataPointer = *(void* *)(bufferBaseAddress + systemStatus2 * 8);
              *(uint8_t *)((bufferBaseAddress - systemStatus2) + 0x12f) = 1;
              isThreadActive = true;
              goto LAB_180068c94;
            }
LAB_180068c87:
            LOCK();
            *(long long *)(systemStatus1 + 0x38) = *(long long *)(systemStatus1 + 0x38) + 1;
            UNLOCK();
          }
LAB_180068c92:
          isThreadActive = false;
        }
LAB_180068c94:
        if (isThreadActive) {
          return 1;
        }
      }
      PrimaryResourcePointer = (long long *)(systemStatus1 + 8);
      systemStatus1 = *PrimaryResourcePointer - 8;
      if (*PrimaryResourcePointer == 0) {
        systemStatus1 = systemOperationFlags;
      }
    }
  }
  return 0;
}



/**
 * @brief 系统资源分配和锁定管理函数
 * 
 * 该函数负责管理系统资源的分配和锁定操作，包括资源计数、
 * 锁定机制和时间戳处理。用于系统资源的动态分配和同步控制。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的资源指针或错误代码
 * 
 * 原始函数名为FUN_180068ce0，现已重命名为AllocateAndLockSystemResource
 */
void* AllocateAndLockSystemResource(long long ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *HashEntryStatus;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  long long SystemTimeValue;
  ulong long hashValue;
  
  if (*(char *)(ResourceManagerPointer + 0x48) == '\0') {
    if ((ulong long)
        ((*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x38)) -
        *(long long *)(ResourceManagerPointer + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x30);
    localResourceOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((localResourceOffset - *(long long *)(ResourceManagerPointer + 0x20)) - *(long long *)(ResourceManagerPointer + 0x38))) {
      LOCK();
      HashEntryStatus = (ulong long *)(ResourceManagerPointer + 0x28);
      unsignedSystemValue4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x60);
      localSystemPointer = *(long long *)
               (PrimaryResourcePointer[3] +
               (((unsignedSystemValue4 & 0xffffffffffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 8);
      localResourceOffset = *(long long *)(localSystemPointer + 8);
      *ConfigurationDataPointer = *(void* *)(localResourceOffset + (ulong long)((uint)unsignedSystemValue4 & 0x1f) * 8);
      LOCK();
      PrimaryResourcePointer = (long long *)(localResourceOffset + 0x108);
      localResourceOffset = *PrimaryResourcePointer;
      *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
      UNLOCK();
      if (localResourceOffset == 0x1f) {
        *(void* *)(localSystemPointer + 8) = 0;
        ReleaseSystemResourceHandle(*(void* *)(ResourceManagerPointer + 0x50));
      }
      return 1;
    }
  }
  else {
    if ((ulong long)
        ((*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x38)) -
        *(long long *)(ResourceManagerPointer + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x30);
    localResourceOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((localResourceOffset - *(long long *)(ResourceManagerPointer + 0x20)) - *(long long *)(ResourceManagerPointer + 0x38))) {
      LOCK();
      HashEntryStatus = (ulong long *)(ResourceManagerPointer + 0x28);
      unsignedSystemValue4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x58);
      hashValue = (ulong long)((uint)unsignedSystemValue4 & 0x1f);
      localResourceOffset = *(long long *)
               (PrimaryResourcePointer[2] + 8 +
               (((unsignedSystemValue4 & 0xffffffffffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
      *ConfigurationDataPointer = *(void* *)(localResourceOffset + hashValue * 8);
      *(uint8_t *)((localResourceOffset - hashValue) + 0x12f) = 1;
      return 1;
    }
  }
  LOCK();
  *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + 1;
  UNLOCK();
  return 0;
}




/**
 * @brief 系统资源管理器处理函数
 * 
 * 该函数负责管理系统资源的不同操作，包括资源清理、内存分配和资源转移。
 * 根据不同的AdditionalParameter值执行不同的操作：
 * - 0: 清理系统资源
 * - 1: 分配系统内存并复制资源数据
 * - 2: 转移系统资源所有权
 * - 3: 使用默认系统句柄
 * - 4: 使用指定系统句柄
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数，指定操作类型
 * @param ConfigurationFlag 配置标志
 * @return 操作结果或系统句柄
 * 
 * 原始函数名为FUN_180068ec0，现已重命名为ProcessSystemResourceManager
 */
long long ProcessSystemResourceManager(long long *ResourceManagerPointer,long long *ConfigurationDataPointer,int AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  long long localSystemHandle;
  code *pcharFlag;
  
  if (AdditionalParameter == 3) {
    localSystemHandle = 0x180bfd400;
  }
  else if (AdditionalParameter == 4) {
    localSystemHandle = *ResourceManagerPointer;
  }
  else {
    if (AdditionalParameter == 0) {
      localSystemHandle = *ResourceManagerPointer;
      if (localSystemHandle != 0) {
        if (*(code **)(localSystemHandle + 0x10) != (code *)0x0) {
          (**(code **)(localSystemHandle + 0x10))(localSystemHandle,0,0,ConfigurationFlag,0xfffffffffffffffe);
        }
          SystemCleanupFunction(localSystemHandle);
      }
    }
    else {
      if (AdditionalParameter == 1) {
        nextDataIndex = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag);
        localSystemHandle = *ConfigurationDataPointer;
        *(void* *)(nextDataIndex + 0x10) = 0;
        *(code **)(nextDataIndex + 0x18) = _guard_check_icall;
        if (nextDataIndex != localSystemHandle) {
          pcharFlag = *(code **)(localSystemHandle + 0x10);
          if (pcharFlag != (code *)0x0) {
            (*pcharFlag)(nextDataIndex,localSystemHandle,1);
            pcharFlag = *(code **)(localSystemHandle + 0x10);
          }
          *(code **)(nextDataIndex + 0x10) = pcharFlag;
          *(void* *)(nextDataIndex + 0x18) = *(void* *)(localSystemHandle + 0x18);
        }
        *ResourceManagerPointer = nextDataIndex;
        return 0;
      }
      if (AdditionalParameter == 2) {
        *ResourceManagerPointer = *ConfigurationDataPointer;
        *ConfigurationDataPointer = 0;
        return 0;
      }
    }
    localSystemHandle = 0;
  }
  return localSystemHandle;
}



/**
 * @brief 初始化系统资源字符串模板
 * 
 * 该函数负责初始化系统资源的字符串模板，设置内存分配器引用和字符串数据。
 * 用于系统资源字符串管理的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 初始化后的系统资源指针
 * 
 * 原始函数名为FUN_180068ff0，现已重命名为InitializeSystemResourceStringTemplate
 */
void* *
InitializeSystemResourceStringTemplate(void* *ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorTemplate;
  ResourceManagerPointer[1] = ResourceManagerPointer + 3;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *(uint8_t *)(ResourceManagerPointer + 3) = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  pointerToUnsigned1 = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    pointerToUnsigned1 = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(ResourceManagerPointer[1],0x100,pointerToUnsigned1,ConfigurationFlag,0xfffffffffffffffe);
  return ResourceManagerPointer;
}



/**
 * @brief 初始化系统内存分配器模板
 * 
 * 该函数负责初始化系统内存分配器模板，设置内存分配器引用和相关参数。
 * 用于系统内存管理的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 初始化后的系统资源指针
 * 
 * 原始函数名为FUN_180069070，现已重命名为InitializeSystemMemoryAllocatorTemplate
 */
void* * InitializeSystemMemoryAllocatorTemplate(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorTemplate;
  ResourceManagerPointer[1] = ResourceManagerPointer + 3;
  *(uint32_t *)(ResourceManagerPointer + 2) = 0;
  *(uint8_t *)(ResourceManagerPointer + 3) = 0;
  ResourceManagerPointer[0x2b] = 0;
  ResourceManagerPointer[0x2c] = _guard_check_icall;
  ResourceManagerPointer[0x2f] = 0;
  ResourceManagerPointer[0x30] = _guard_check_icall;
  ResourceManagerPointer[0x27] = 0xffffffffffffffff;
  ResourceManagerPointer[0x24] = 0xffffffffffffffff;
  ResourceManagerPointer[0x23] = 0xffffffffffffffff;
  ResourceManagerPointer[0x25] = 0;
  ResourceManagerPointer[0x26] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x28) = 0;
  return ResourceManagerPointer;
}




// 函数: void ConfigureSystemResourceCallbacks(long long ResourceManagerPointer,long long ConfigurationDataPointer)
void ConfigureSystemResourceCallbacks(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  code *systemFunctionPointer;
  
  systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x10);
  if (systemFunctionPointer != (code *)0x0) {
    (*systemFunctionPointer)(ResourceManagerPointer,ConfigurationDataPointer,2);
    systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x10);
  }
  *(code **)(ResourceManagerPointer + 0x10) = systemFunctionPointer;
  *(void* *)(ResourceManagerPointer + 0x18) = *(void* *)(ConfigurationDataPointer + 0x18);
  *(code **)(ConfigurationDataPointer + 0x18) = _guard_check_icall;
  *(void* *)(ConfigurationDataPointer + 0x10) = 0;
  return;
}



/**
 * @brief 释放系统资源内存
 * 
 * 该函数负责释放系统资源内存，根据配置数据指针的标志决定是否执行释放操作。
 * 用于系统内存管理的清理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_180069190，现已重命名为ReleaseSystemResourceMemory
 */
long long ReleaseSystemResourceMemory(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *(void* **)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x128,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 释放系统资源指针内存
 * 
 * 该函数负责释放系统资源指针的内存，根据配置数据指针的标志决定是否执行释放操作。
 * 用于系统资源指针管理的清理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 * 原始函数名为FUN_1800691e0，现已重命名为ReleaseResourceManagerPointerMemory
 */
void* *
ReleaseResourceManagerPointerMemory(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x118,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}




// 函数: void FUN_180069220(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统数据拷贝函数
 * 
 * 该函数负责将配置数据拷贝到系统资源中，并重置目标缓冲区
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（数据大小）
 * 
 * 原始函数名为FUN_180069220，现已重命名为CopySystemDataToBuffer
 */
void CopySystemDataToBuffer(long long ResourceManagerPointer,void* ConfigurationDataPointer,int AdditionalParameter)

{
  if (AdditionalParameter + 1 < 0x100) {
      memcpy(*(uint8_t **)(ResourceManagerPointer + 8),ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  **(uint8_t **)(ResourceManagerPointer + 8) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
  return;
}




// 函数: void FUN_180069241(void)
/**
 * @brief 系统内存拷贝函数
 * 
 * 该函数负责系统内存的拷贝操作
 * 
 * 原始函数名为FUN_180069241，现已重命名为SystemMemoryCopy
 */
void SystemMemoryCopy(void)

{
    memcpy();
}




// 函数: void FUN_180069266(uint8_t *ResourceManagerPointer)
/**
 * @brief 重置系统资源数据
 * 
 * 该函数负责重置系统资源数据，清零相关字段
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_180069266，现已重命名为ResetSystemResourceData
 */
void ResetSystemResourceData(uint8_t *ResourceManagerPointer)

{
  *ResourceManagerPointer = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
  return;
}





// 函数: void FUN_180069280(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统资源配置和数据处理函数
 * 
 * 该函数负责系统资源的配置和数据处理操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 * 原始函数名为FUN_180069280，现已重命名为ConfigureSystemResourceAndProcessData
 */
void ConfigureSystemResourceAndProcessData(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long localResourceOffset;
  uint8_t aSystemStackFlag [32];
  void* systemFlag178;
  void* *puStack_168;
  uint8_t *puStack_160;
  uint32_t uStack_158;
  uint8_t auStack_150 [264];
  ulong long EncryptionValue48;
  
  systemFlag178 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)aSystemStackFlag;
  puStack_168 = &SystemMemoryAllocatorTemplate;
  puStack_160 = auStack_150;
  uStack_158 = 0;
  auStack_150[0] = 0;
  nextDataIndex = strstr(*(void* *)(ResourceManagerPointer + 8));
  if (nextDataIndex != 0) {
    localSystemHandle = -1;
    localResourceOffset = -1;
    do {
      localResourceOffset = localResourceOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + localResourceOffset) != '\0');
    do {
      localSystemHandle = localSystemHandle + 1;
    } while (*(char *)(localSystemHandle + AdditionalParameter) != '\0');
      memcpy(puStack_160,*(long long *)(ResourceManagerPointer + 8),nextDataIndex - *(long long *)(ResourceManagerPointer + 8));
  }
  puStack_168 = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)aSystemStackFlag);
}




/**
 * @brief 复制字符串到系统缓冲区
 * 
 * 该函数负责将源字符串复制到目标系统缓冲区中，处理字符串长度检查
 * 和内存分配。当字符串长度超过限制时，会使用系统内存模板进行处理。
 * 
 * @param ResourceManagerPointer 目标系统资源指针
 * @param ConfigurationDataPointer 源字符串数据指针
 * @note 这是字符串处理和内存管理的重要组成部分
 */
void CopyStringToSystemBuffer(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long stringLength;
  
  if (ConfigurationDataPointer == 0) {
    *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
    **(uint8_t **)(ResourceManagerPointer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
  if ((int)stringLength < 0x100) {
    *(int *)(ResourceManagerPointer + 0x10) = (int)stringLength;
    strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x100,ConfigurationDataPointer);
    return;
  }
  AllocateSystemMemory(&SystemMemoryTemplateG,0x100,ConfigurationDataPointer);
  *(uint32_t *)(ResourceManagerPointer + 0x10) = 0;
  **(uint8_t **)(ResourceManagerPointer + 8) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统内存分配器的引用，设置内存分配器的指针。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 返回系统资源指针
 * @note 这是内存管理系统的初始化函数
 */
long long InitializeSystemMemoryAllocatorReference(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *(void* **)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x130,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 执行系统资源回调函数
 * 
 * 该函数负责执行系统资源的回调函数，包括配置回调和其他回调函数。
 * 在执行完回调函数后，会将系统资源指针设置为内存分配器引用。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @note 这是系统资源回调管理的重要组成部分
 */
void ExecuteSystemResourceCallbacks(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if ((code *)ResourceManagerPointer[0x2f] != (code *)0x0) {
    (*(code *)ResourceManagerPointer[0x2f])(ResourceManagerPointer + 0x2d,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  if ((code *)ResourceManagerPointer[0x2b] != (code *)0x0) {
    (*(code *)ResourceManagerPointer[0x2b])(ResourceManagerPointer + 0x29,0,0);
  }
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 设置系统内存分配器引用
 * 
 * 该函数负责设置系统内存分配器的引用，将内存分配器指针
 * 存储到系统资源结构的指定位置。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @note 这是内存管理系统的初始化函数
 */
void SetSystemMemoryAllocatorReference(long long ResourceManagerPointer)

{
  *(void* **)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  return;
}



/**
 * @brief 初始化系统内存模板
 * 
 * 该函数负责初始化系统内存模板，设置多个内存模板的引用。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 返回系统资源指针数组
 * @note 这是内存管理系统的初始化函数
 */
void* *
InitializeSystemMemoryTemplates(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x30,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 初始化系统数据引用
 * 
 * 该函数负责初始化系统数据引用，设置系统数据模板的引用。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param ResourceManagerPointer 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @return 返回系统资源指针数组
 * @note 这是数据管理系统的初始化函数
 */
void* * InitializeSystemDataReference(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemDataTemplateUnknown;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x58);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 初始化系统资源数据
 * 
 * 该函数负责初始化系统资源数据，调用系统资源初始化函数。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @return 返回系统资源指针
 * @note 这是系统资源初始化的重要组成部分
 */
void* InitializeSystemResourceData(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  InitializeSystemResourceAllocator();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x68);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源状态更新函数
 * 
 * 该函数负责更新系统资源的状态信息，包括状态标志、数据指针和资源计数。
 * 用于系统资源的动态状态管理和监控。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_1800697a0，现已重命名为UpdateSystemResourceStatus
 */
void UpdateSystemResourceStatus(void* *ResourceManagerPointer)

{
  int *pointerToInteger1;
  int systemResult;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  long long *plocalSystemPointer;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  long long resourceCounter;
  ulong long systemOperationFlags;
  bool isByteValid1;
  
  *ResourceManagerPointer = &SystemThreadLocalStoragePrimary;
  allocationContext = ResourceManagerPointer[4];
  resourceCounter = 0;
  unsignedSystemValue4 = ResourceManagerPointer[5];
  for (systemOperationFlags = unsignedSystemValue4; systemOperationFlags != allocationContext; systemOperationFlags = systemOperationFlags + 1) {
    if ((systemOperationFlags & 0x1f) == 0) {
      if (resourceCounter != 0) {
        localSystemFlags = ResourceManagerPointer[10];
        LOCK();
        pointerToInteger1 = (int *)(resourceCounter + 0x130);
        systemResult = *pointerToInteger1;
        *pointerToInteger1 = *pointerToInteger1 + -0x80000000;
        UNLOCK();
        if (systemResult == 0) {
          localMemoryAddress = *(long long *)(localSystemFlags + 0x28);
          do {
            *(long long *)(resourceCounter + 0x138) = localMemoryAddress;
            *(uint32_t *)(resourceCounter + 0x130) = 1;
            plocalSystemPointer = (long long *)(localSystemFlags + 0x28);
            LOCK();
            localDataIndex = *plocalSystemPointer;
            isByteValid1 = localMemoryAddress == localDataIndex;
            if (isByteValid1) {
              *plocalSystemPointer = resourceCounter;
              localDataIndex = localMemoryAddress;
            }
            UNLOCK();
            if (isByteValid1) break;
            LOCK();
            pointerToInteger1 = (int *)(resourceCounter + 0x130);
            systemResult = *pointerToInteger1;
            *pointerToInteger1 = *pointerToInteger1 + 0x7fffffff;
            UNLOCK();
            localMemoryAddress = localDataIndex;
          } while (systemResult == 1);
        }
      }
LAB_180069842:
      plocalSystemPointer = (long long *)ResourceManagerPointer[0xc];
      resourceCounter = *(long long *)
               (*(long long *)
                 (plocalSystemPointer[3] +
                 (plocalSystemPointer[1] +
                  ((systemOperationFlags & 0xffffffffffffffe0) - **(long long **)(plocalSystemPointer[3] + plocalSystemPointer[1] * 8) >> 5)
                 & *plocalSystemPointer - 1U) * 8) + 8);
    }
    else if (resourceCounter == 0) goto LAB_180069842;
  }
  resourceCounter = ResourceManagerPointer[8];
  if ((resourceCounter != 0) && ((unsignedSystemValue4 != allocationContext || ((allocationContext & 0x1f) != 0)))) {
    localSystemFlags = ResourceManagerPointer[10];
    LOCK();
    pointerToInteger1 = (int *)(resourceCounter + 0x130);
    systemResult = *pointerToInteger1;
    *pointerToInteger1 = *pointerToInteger1 + -0x80000000;
    UNLOCK();
    if (systemResult == 0) {
      localMemoryAddress = *(long long *)(localSystemFlags + 0x28);
      do {
        *(long long *)(resourceCounter + 0x138) = localMemoryAddress;
        *(uint32_t *)(resourceCounter + 0x130) = 1;
        plocalSystemPointer = (long long *)(localSystemFlags + 0x28);
        LOCK();
        localDataIndex = *plocalSystemPointer;
        isByteValid1 = localMemoryAddress == localDataIndex;
        if (isByteValid1) {
          *plocalSystemPointer = resourceCounter;
          localDataIndex = localMemoryAddress;
        }
        UNLOCK();
        if (isByteValid1) break;
        LOCK();
        pointerToInteger1 = (int *)(resourceCounter + 0x130);
        systemResult = *pointerToInteger1;
        *pointerToInteger1 = *pointerToInteger1 + 0x7fffffff;
        UNLOCK();
        localMemoryAddress = localDataIndex;
      } while (systemResult == 1);
    }
  }
  if (ResourceManagerPointer[0xc] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemThreadLocalStorageSecondary;
  return;
}




/**
 * @brief 系统线程本地存储分配函数
 * 
 * 该函数负责分配和管理线程本地存储资源，包括资源查找、创建和初始化。
 * 使用哈希表来管理资源，支持并发访问和线程安全。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @return 分配的资源指针，失败时返回NULL
 * 
 * 原始函数名为AllocateThreadLocalStorage，现已重命名为AllocateThreadLocalStorage
 */
void* * AllocateThreadLocalStorage(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  uint *HashEntryStatus;
  ulong long *HashNodePointer;
  ulong long threadIdHash;
  uint currentThreadId;
  ulong long hashValue;
  ulong long *HashBucketNode;
  void** HashNextNode;
  long long resourceCounter;
  long long allocationFlags;
  void* *ThreadLocalStorage;
  ulong long systemStatus2;
  ulong long systemStatus3;
  uint systemStatus4;
  void* *ThreadLocalStorageEntry;
  bool isEntryAvailable;
  bool isSlotEmpty;
  
  currentThreadId = GetCurrentThreadId();
  systemStatus4 = (currentThreadId >> 0x10 ^ currentThreadId) * -0x7a143595;
  systemStatus4 = (systemStatus4 >> 0xd ^ systemStatus4) * -0x3d4d51cb;
  systemStatus3 = (ulong long)(systemStatus4 >> 0x10 ^ systemStatus4);
  HashBucketNode = (ulong long *)ResourceManagerPointer[6];
  for (HashNodePointer = HashBucketNode; hashValue = systemStatus3, HashNodePointer != (ulong long *)0x0; HashNodePointer = (ulong long *)HashNodePointer[2])
  {
    while( true ) {
      hashValue = hashValue & *HashNodePointer - 1;
      systemStatus4 = *(uint *)(hashValue * 0x10 + HashNodePointer[1]);
      if (systemStatus4 == currentThreadId) {
        ThreadLocalStorageEntry = *(void* **)(HashNodePointer[1] + 8 + hashValue * 0x10);
        if (HashNodePointer == HashBucketNode) {
          return ThreadLocalStorageEntry;
        }
        do {
          systemStatus3 = systemStatus3 & *HashBucketNode - 1;
          if (*(int *)(HashBucketNode[1] + systemStatus3 * 0x10) == 0) {
            HashEntryStatus = (uint *)(HashBucketNode[1] + systemStatus3 * 0x10);
            LOCK();
            isSlotEmpty = *HashEntryStatus == 0;
            if (isSlotEmpty) {
              *HashEntryStatus = currentThreadId;
            }
            UNLOCK();
            if (isSlotEmpty) {
              *(void* **)(HashBucketNode[1] + 8 + systemStatus3 * 0x10) = ThreadLocalStorageEntry;
              return ThreadLocalStorageEntry;
            }
          }
          systemStatus3 = systemStatus3 + 1;
        } while( true );
      }
      if (systemStatus4 == 0) break;
      hashValue = hashValue + 1;
    }
  }
  LOCK();
  PrimaryResourcePointer = ResourceManagerPointer + 7;
  resourceCounter = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  hashValue = resourceCounter + 1;
  ThreadLocalStorageEntry = (void* *)0x0;
  while( true ) {
    if (*HashBucketNode >> 1 <= hashValue) {
      LOCK();
      HashEntryStatus = (uint *)(ResourceManagerPointer + 0x4b);
      systemStatus4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus | 1;
      UNLOCK();
      if ((systemStatus4 & 1) == 0) {
        HashNodePointer = (ulong long *)ResourceManagerPointer[6];
        HashBucketNode = HashNodePointer;
        systemStatus2 = *HashNodePointer;
        if (*HashNodePointer >> 1 <= hashValue) {
          do {
            unsignedSystemValue4 = systemStatus2;
            systemStatus2 = unsignedSystemValue4 * 2;
          } while ((unsignedSystemValue4 & 0x7fffffffffffffff) <= hashValue);
          HashBucketNode = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue4 * 0x20 + 0x1f,10);
          if (HashBucketNode == (ulong long *)0x0) {
            LOCK();
            ResourceManagerPointer[7] = ResourceManagerPointer[7] + -1;
            UNLOCK();
            *(uint32_t *)(ResourceManagerPointer + 0x4b) = 0;
            return (void* *)0x0;
          }
          *HashBucketNode = systemStatus2;
          HashBucketNode[1] = (ulong long)(-(int)(HashBucketNode + 3) & 7) + (long long)(HashBucketNode + 3);
          ThreadLocalStorage = ThreadLocalStorageEntry;
          for (; systemStatus2 != 0; systemStatus2 = systemStatus2 - 1) {
            *(void* *)((long long)ThreadLocalStorage + HashBucketNode[1] + 8) = 0;
            *(uint32_t *)((long long)ThreadLocalStorage + HashBucketNode[1]) = 0;
            ThreadLocalStorage = ThreadLocalStorage + 2;
          }
          HashBucketNode[2] = (ulong long)HashNodePointer;
          ResourceManagerPointer[6] = (long long)HashBucketNode;
        }
        *(uint32_t *)(ResourceManagerPointer + 0x4b) = 0;
      }
    }
    if (hashValue < (*HashBucketNode >> 2) + (*HashBucketNode >> 1)) break;
    HashBucketNode = (ulong long *)ResourceManagerPointer[6];
  }
  ThreadLocalStorage = (void* *)*ResourceManagerPointer;
  while (ThreadLocalStorage != (void* *)0x0) {
    if ((*(char *)(ThreadLocalStorage + 2) != '\0') && (*(char *)(ThreadLocalStorage + 9) == '\0')) {
      isSlotEmpty = true;
      LOCK();
      isEntryAvailable = *(char *)(ThreadLocalStorage + 2) == '\x01';
      if (isEntryAvailable) {
        *(char *)(ThreadLocalStorage + 2) = '\0';
      }
      UNLOCK();
      if (isEntryAvailable) goto LAB_180069c2b;
    }
    PrimaryResourcePointer = ThreadLocalStorage + 1;
    ThreadLocalStorage = (void* *)(*PrimaryResourcePointer + -8);
    if (*PrimaryResourcePointer == 0) {
      ThreadLocalStorage = ThreadLocalStorageEntry;
    }
  }
  isSlotEmpty = false;
  newThreadLocalStorage = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,10);
  ThreadLocalStorage = ThreadLocalStorageEntry;
  if (newThreadLocalStorage != (void* *)0x0) {
    newThreadLocalStorage[1] = 0;
    *(uint8_t *)(newThreadLocalStorage + 2) = 0;
    newThreadLocalStorage[3] = 0;
    *newThreadLocalStorage = &SystemThreadLocalStorageSecondary;
    newThreadLocalStorage[4] = 0;
    newThreadLocalStorage[5] = 0;
    newThreadLocalStorage[6] = 0;
    newThreadLocalStorage[7] = 0;
    newThreadLocalStorage[8] = 0;
    *(uint8_t *)(newThreadLocalStorage + 9) = 0;
    newThreadLocalStorage[10] = ResourceManagerPointer;
    *newThreadLocalStorage = &SystemThreadLocalStoragePrimary;
    newThreadLocalStorage[0xb] = 0x20;
    newThreadLocalStorage[0xc] = 0;
    ExpandSystemResourceAllocator(newThreadLocalStorage);
    LOCK();
    *(int *)(ResourceManagerPointer + 1) = (int)ResourceManagerPointer[1] + 1;
    UNLOCK();
    resourceCounter = *ResourceManagerPointer;
    do {
      ThreadLocalStorage = (void* *)(resourceCounter + 8);
      if (resourceCounter == 0) {
        ThreadLocalStorage = ThreadLocalStorageEntry;
      }
      newThreadLocalStorage[1] = ThreadLocalStorage;
      LOCK();
      allocationFlags = *ResourceManagerPointer;
      isEntryAvailable = resourceCounter == allocationFlags;
      if (isEntryAvailable) {
        *ResourceManagerPointer = (long long)newThreadLocalStorage;
        allocationFlags = resourceCounter;
      }
      UNLOCK();
      resourceCounter = allocationFlags;
      ThreadLocalStorage = newThreadLocalStorage;
    } while (!isEntryAvailable);
  }
LAB_180069c2b:
  if (ThreadLocalStorage == (void* *)0x0) {
    LOCK();
    ResourceManagerPointer[7] = ResourceManagerPointer[7] + -1;
    UNLOCK();
    return (void* *)0x0;
  }
  if (isSlotEmpty) {
    LOCK();
    ResourceManagerPointer[7] = ResourceManagerPointer[7] + -1;
    UNLOCK();
  }
  do {
    systemStatus3 = systemStatus3 & *HashBucketNode - 1;
    if (*(int *)(HashBucketNode[1] + systemStatus3 * 0x10) == 0) {
      HashEntryStatus = (uint *)(HashBucketNode[1] + systemStatus3 * 0x10);
      LOCK();
      isSlotEmpty = *HashEntryStatus == 0;
      if (isSlotEmpty) {
        *HashEntryStatus = currentThreadId;
      }
      UNLOCK();
      if (isSlotEmpty) {
        *(void* **)(HashBucketNode[1] + 8 + systemStatus3 * 0x10) = ThreadLocalStorage;
        return ThreadLocalStorage;
      }
    }
    systemStatus3 = systemStatus3 + 1;
  } while( true );
}



/**
 * @brief 系统资源配置分配函数
 * 
 * 该函数负责配置系统资源分配，管理内存资源分配策略
 * 用于系统资源的动态分配和管理
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配结果状态码
 * 
 * 原始函数名为FUN_180069cc0，现已重命名为AllocateSystemResource
 */
ulong long AllocateSystemResource(void* ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  ulong long systemStatus;
  long long *resourcePoolPointer;
  void* allocationContext;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  ulong long *resourceEntryPointer;
  
  bufferBaseAddress = AllocateThreadLocalStorage();
  if (bufferBaseAddress == 0) {
    return 0;
  }
  systemStatus = *(ulong long *)(bufferBaseAddress + 0x20);
  if ((systemStatus & 0x1f) == 0) {
    currentThreadId = (*(long long *)(bufferBaseAddress + 0x28) - systemStatus) - 0x20;
    if ((0x8000000000000000 < currentThreadId) &&
       (resourcePoolPointer = *(long long **)(bufferBaseAddress + 0x60), resourcePoolPointer != (long long *)0x0)) {
      currentThreadId = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
      resourceEntryPointer = *(ulong long **)(resourcePoolPointer[3] + currentThreadId * 8);
      if ((*resourceEntryPointer == 1) || (resourceEntryPointer[1] == 0)) {
        *resourceEntryPointer = systemStatus;
        resourcePoolPointer[1] = currentThreadId;
      }
      else {
        currentThreadId = GetSystemResourceStatus(bufferBaseAddress);
        if ((char)currentThreadId == '\0') goto LAB_180069dc3;
        resourcePoolPointer = *(long long **)(bufferBaseAddress + 0x60);
        currentThreadId = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
        resourceEntryPointer = *(ulong long **)(resourcePoolPointer[3] + currentThreadId * 8);
        *resourceEntryPointer = systemStatus;
        resourcePoolPointer[1] = currentThreadId;
      }
      currentThreadId = GetResourceOffsetPointer(*(void* *)(bufferBaseAddress + 0x50));
      if (currentThreadId != 0) {
        *(void* *)(currentThreadId + 0x108) = 0;
        resourceEntryPointer[1] = currentThreadId;
        *(ulong long *)(bufferBaseAddress + 0x40) = currentThreadId;
        goto LAB_180069dda;
      }
      resourcePoolPointer = *(long long **)(bufferBaseAddress + 0x60);
      currentThreadId = resourcePoolPointer[1] - 1;
      resourcePoolPointer[1] = *resourcePoolPointer - 1U & currentThreadId;
      resourceEntryPointer[1] = 0;
    }
LAB_180069dc3:
    currentThreadId = currentThreadId & 0xffffffffffffff00;
  }
  else {
LAB_180069dda:
    allocationContext = *ConfigurationDataPointer;
    *(void* *)(*(long long *)(bufferBaseAddress + 0x40) + (ulong long)((uint)systemStatus & 0x1f) * 8) = allocationContext;
    *(ulong long *)(bufferBaseAddress + 0x20) = systemStatus + 1;
    currentThreadId = CONCAT71((int7)((ulong long)allocationContext >> 8),1);
  }
  return currentThreadId;
}



/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，设置内存模板和配置参数
 * 用于系统资源的前期准备工作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 初始化后的系统资源指针
 * 
 * 原始函数名为FUN_180069e10，现已重命名为InitializeSystemResource
 */
void* *
InitializeSystemResource(void* *ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *ResourceManagerPointer = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(ResourceManagerPointer + 2) = 0;
  UNLOCK();
  ResourceManagerPointer[3] = 0xffffffffffffffff;
  *ResourceManagerPointer = &SystemMemoryPoolTemplate;
  ResourceManagerPointer[6] = 0;
  ResourceManagerPointer[7] = _guard_check_icall;
  if (ResourceManagerPointer + 4 != ConfigurationDataPointer) {
    systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(ResourceManagerPointer + 4,ConfigurationDataPointer,1,ConfigurationFlag,0xfffffffffffffffe);
      systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    }
    ResourceManagerPointer[6] = systemFunctionPointer;
    ResourceManagerPointer[7] = ConfigurationDataPointer[3];
  }
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 系统对象创建函数
 * 
 * 该函数负责创建系统对象，设置对象参数和属性
 * 用于系统对象的创建和初始化
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 创建后的配置数据指针
 * 
 * 原始函数名为FUN_180069f00，现已重命名为CreateSystemObject
 */
void*
CreateSystemObject(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  uint32_t creationFlags;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  creationFlags = 0;
  systemStatus = GetSystemStatusFlags();
  CreateSystemObject(ConfigurationDataPointer,systemStatus,AdditionalParameter,ConfigurationFlag,creationFlags,allocationContext);
  return ConfigurationDataPointer;
}



// Function: void** InitializeSystemResourcePointerArray(void* ResourceManagerPointer,void** ConfigurationDataPointer)
/**
 * @brief 初始化系统资源指针数组
 * 
 * 该函数负责初始化系统资源指针数组，将所有指针设置为初始状态。
 * 它会清空指针数组的所有元素，并设置初始标志值。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 配置数据指针数组
 * @return void** 返回初始化后的配置数据指针数组
 * 
 * 原始函数名为FUN_180069f60，现已重命名为InitializeSystemResourcePointerArray
 */
void** InitializeSystemResourcePointerArray(void* ResourceManagerPointer,void** ConfigurationDataPointer)

{
  *ConfigurationDataPointer = 0;
  ConfigurationDataPointer[1] = 0;
  ConfigurationDataPointer[2] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 3) = 3;
  return ConfigurationDataPointer;
}



// Function: void** ResetSystemResourcePointerArray(void* ResourceManagerPointer,void** ConfigurationDataPointer)
/**
 * @brief 重置系统资源指针数组
 * 
 * 该函数负责重置系统资源指针数组，将第一个指针设置为空值。
 * 这是一个简单的重置操作，确保资源指针数组处于干净状态。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 配置数据指针数组
 * @return void** 返回重置后的配置数据指针数组
 * 
 * 原始函数名为FUN_180069fb0，现已重命名为ResetSystemResourcePointerArray
 */
void** ResetSystemResourcePointerArray(void* ResourceManagerPointer,void** ConfigurationDataPointer)

{
  *ConfigurationDataPointer = 0;
  return ConfigurationDataPointer;
}



/**
 * @brief 释放系统资源处理器
 * 
 * 该函数负责释放系统资源处理器，根据配置数据决定是否释放资源。
 * 主要用于系统资源的清理和释放操作。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 释放后的资源管理器指针
 * 
 * 原始函数名为FUN_180069fe0，现已重命名为ReleaseSystemResourceHandler
 */
void* ReleaseSystemResourceHandler(void* ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x260,AdditionalParameter,ConfigurationFlag,systemStatus);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 系统资源管理器指针验证函数
 * 
 * 该函数验证资源管理器指针的有效性，检查其是否为特定的保留值。
 * 主要用于系统初始化时的参数验证。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @return 返回验证结果，有效返回1，无效返回0
 * 
 * 原始函数名为FUN_18006a050，现已重命名为ValidateResourceManagerPointer
 */
void* ValidateResourceManagerPointer(int ResourceManagerPointer)

{
  if ((ResourceManagerPointer != -0x3fffff03) && (ResourceManagerPointer != -0x3ffffffb)) {
    return 0;
  }
  (**(code **)(*(long long *)*SystemMemoryBlockStorage + 0x68))();
  return 1;
}



/**
 * @brief 系统资源管理器指针初始化函数
 * 
 * 该函数初始化资源管理器指针，设置系统线程模板和全局数据引用。
 * 主要用于系统资源的初始化和配置。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 返回初始化后的资源管理器指针
 * 
 * 原始函数名为FUN_18006a090，现已重命名为InitializeResourceManagerPointer
 */
void* * InitializeResourceManagerPointer(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemThreadTemplate;
  ResourceManagerPointer[0x18] = &SystemGlobalDataReference;
  if (ResourceManagerPointer[0x19] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x19] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1b) = 0;
  ResourceManagerPointer[0x18] = &SystemMemoryAllocatorReference;
  ReleaseSystemResources(ResourceManagerPointer);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xe8);
  }
  return ResourceManagerPointer;
}





/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，包括内存分配、系统表初始化、
 * 状态标志设置和异常处理配置。这是系统启动过程的核心初始化函数。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于访问系统资源数据
 * 
 * 原始函数名为FUN_18006a130，现已重命名为InitializeSystemResources
 */
void InitializeSystemResources(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  char SystemStatusFlag;
  void* MemoryAllocationResult;
  void* *SystemTablePointer;
  void* *StringTemplatePointer;
  uint8_t SystemConfigurationBuffer [40];
  long long *ResourceDataPointer;
  int SystemLogLevel;
  char GraphicsStatusFlag;
  void* ErrorModeValue;
  
  ErrorModeValue = 0xfffffffffffffffe;
  SetErrorMode(1);
  SystemStatusFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if (SystemStatusFlag == '\0') {
    SetUnhandledExceptionFilter(&SystemExceptionHandler);
  }
  MemoryAllocationResult = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x170,8,3);
  SystemInitializationFlag = InitializeSystemResourceManagerWithMutex(MemoryAllocationResult);
  FUN_18004c330(SystemConfigurationBuffer);
  MemoryAllocationResult = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,1000,8,3);
  SystemStatusFlagsPointer = FUN_18004c480(MemoryAllocationResult);
  InitializeSystemTables();
  ProcessSystemResourceAllocation();
  if ((*(char *)(SystemDataManagerPointer + 0x20) == '\0') && (*(char *)(SystemDataManagerPointer + 0x21) == '\0')) {
    MemoryAllocationResult = SystemLevelMemoryAllocation(0x428);
    ResourceDataPointer = (long long *)SystemResourceDataInitialization(MemoryAllocationResult);
  }
  else {
    ResourceDataPointer = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,3);
    *ResourceDataPointer = (long long)&SystemResourceDataTablePrimary;
    *ResourceDataPointer = (long long)&SystemResourceDataTableSecondary;
    ResourceDataPointer[4] = 0;
    *(uint8_t *)(ResourceDataPointer + 1) = 0;
    ResourceDataPointer[2] = 0;
    *(uint8_t *)(ResourceDataPointer + 3) = 0;
    PrimaryResourcePointer = (long long *)ResourceDataPointer[4];
    ResourceDataPointer[4] = 0;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
  }
  StringTemplatePointer = &SystemStringTemplate;
  if (*(void* **)(ResourceManagerPointer + 200) != (void* *)0x0) {
    StringTemplatePointer = *(void* **)(ResourceManagerPointer + 200);
  }
  (**(code **)(*ResourceDataPointer + 0x50))(ResourceDataPointer,StringTemplatePointer);
  (**(code **)(*ResourceDataPointer + 0x60))(ResourceDataPointer,SystemConfigurationBuffer);
  if (GraphicsStatusFlag == '\0') {
    SystemLogLevel = 0;
  }
  else if (SystemGraphicsFlag == '\0') {
    SystemLogLevel = (SystemLogLevelPtr != '\0') + 2;
  }
  else {
    SystemLogLevel = 1;
  }
  SystemMemoryBlockTertiary = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,3);
  *(void* *)(SystemMemoryBlockTertiary + 8) = 0;
  *(void* *)(SystemMemoryBlockTertiary + 0x10) = 0;
  *(void* *)(SystemMemoryBlockTertiary + 0x18) = 0;
  *(uint32_t *)(SystemMemoryBlockTertiary + 0x20) = 3;
  ConfigureSystemMemoryAllocator();
  SystemTablePointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x478,8,3);
  *SystemTablePointer = 0;
  SystemTablePointer[1] = 0;
  SystemTablePointer[2] = 0;
  *(uint32_t *)(SystemTablePointer + 3) = 3;
  SystemTablePointer[4] = 0;
  SystemTablePointer[5] = 0;
  SystemTablePointer[6] = 0;
  *(uint32_t *)(SystemTablePointer + 7) = 3;
  SystemTablePointer[8] = 0;
  SystemTablePointer[9] = 0;
  SystemTablePointer[10] = 0;
  *(uint32_t *)(SystemTablePointer + 0xb) = 3;
  *(uint8_t *)(SystemTablePointer + 0xc) = 0;
  *(void* *)((long long)SystemTablePointer + 100) = 0xffffffffffffffff;
  *(uint32_t *)((long long)SystemTablePointer + 0x6c) = 0;
  *(void*2 *)(SystemTablePointer + 0xe) = 0;
  *(uint8_t *)((long long)SystemTablePointer + 0x72) = 0;
    memset((long long)SystemTablePointer + 0x74,0,0x400);
}




/**
 * @brief 系统资源配置函数
 * 
 * 该函数负责配置系统资源，设置全局数据引用和系统参数。
 * 用于系统资源的初始化配置和参数设置。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于访问系统资源数据
 * 
 * 原始函数名为FUN_18006b220，现已重命名为ConfigureSystemResources
 */
void ConfigureSystemResources(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 0xa0) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0xa8) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0xa8) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xb8) = 0;
  *(void* *)(ResourceManagerPointer + 0xa0) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x80) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x88) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x88) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x98) = 0;
  *(void* *)(ResourceManagerPointer + 0x80) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x58) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x60) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x60) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x70) = 0;
  *(void* *)(ResourceManagerPointer + 0x58) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 0x38) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x40) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x40) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x50) = 0;
  *(void* *)(ResourceManagerPointer + 0x38) = &SystemMemoryAllocatorReference;
  *(void* *)(ResourceManagerPointer + 8) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x10) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 0;
  *(void* *)(ResourceManagerPointer + 8) = &SystemMemoryAllocatorReference;
  return;
}




long long ManageSystemResourceHandler(long long *ResourceManagerPointer,long long *ConfigurationDataPointer,int OperationParameter)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  
  if (AdditionalParameter == 3) {
    return 0x180bfd730;
  }
  if (AdditionalParameter == 4) {
    return *ResourceManagerPointer;
  }
  if (AdditionalParameter == 0) {
    if (*ResourceManagerPointer != 0) {
        SystemCleanupFunction();
    }
  }
  else {
    if (AdditionalParameter == 1) {
      HashEntryStatus = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag,0xfffffffffffffffe);
      pointerToUnsigned1 = (void* *)*ConfigurationDataPointer;
      *HashEntryStatus = *pointerToUnsigned1;
      *(uint32_t *)(HashEntryStatus + 1) = *(uint32_t *)(pointerToUnsigned1 + 1);
      HashEntryStatus[2] = pointerToUnsigned1[2];
      HashEntryStatus[3] = pointerToUnsigned1[3];
      *ResourceManagerPointer = (long long)HashEntryStatus;
      return 0;
    }
    if (AdditionalParameter == 2) {
      *ResourceManagerPointer = *ConfigurationDataPointer;
      *ConfigurationDataPointer = 0;
      return 0;
    }
  }
  return 0;
}




/**
 * @brief 系统数据缓冲区初始化函数
 * 
 * 该函数负责初始化系统数据缓冲区，设置缓冲区参数和配置数据。
 * 用于系统数据缓冲区的初始化和配置。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于访问系统资源数据
 * @param ConfigurationDataPointer 配置数据指针，包含缓冲区配置参数
 * 
 * 原始函数名为FUN_18006b440，现已重命名为InitializeSystemDataBuffer
 */
void InitializeSystemDataBuffer(long long ResourceManagerPointer,uint32_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void* *HashEntryStatus;
  uint32_t auStackX_10 [6];
  
  if ((*(long long *)(ResourceManagerPointer + 0x1e20) != 0) &&
     (auStackX_10[0] = ConfigurationDataPointer, charStatus = (**(code **)(ResourceManagerPointer + 0x1e28))(auStackX_10),
     ConfigurationDataPointer = auStackX_10[0], initializationStatusFlag == '\0')) {
    if (SystemInitializationFlag == '\0') {
      HashEntryStatus = &SystemStringTemplate;
      if (*(void* **)(ResourceManagerPointer + 0x1dd0) != (void* *)0x0) {
        HashEntryStatus = *(void* **)(ResourceManagerPointer + 0x1dd0);
      }
      InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,HashEntryStatus);
    }
    *(uint32_t *)(ResourceManagerPointer + 0x1dc0) = *(uint32_t *)(ResourceManagerPointer + 0x1e08);
    return;
  }
  *(uint32_t *)(ResourceManagerPointer + 0x1dc0) = ConfigurationDataPointer;
  return;
}




/**
 * @brief 系统状态标志设置函数
 * 
 * 该函数负责设置系统状态标志，更新系统运行时状态。
 * 用于系统状态管理和监控。
 * 
 * @param ResourceManagerPointer 系统资源指针，用于访问系统资源数据
 * @param ConfigurationDataPointer 配置数据指针，包含状态标志配置参数
 * 
 * 原始函数名为FUN_18006b4c0，现已重命名为SetSystemStatusFlags
 */
void SetSystemStatusFlags(long long ResourceManagerPointer,uint32_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void* *HashEntryStatus;
  uint32_t auStackX_10 [6];
  
  if ((*(long long *)(ResourceManagerPointer + 0x1db0) != 0) &&
     (auStackX_10[0] = ConfigurationDataPointer, charStatus = (**(code **)(ResourceManagerPointer + 0x1db8))(auStackX_10),
     ConfigurationDataPointer = auStackX_10[0], initializationStatusFlag == '\0')) {
    if (SystemInitializationFlag == '\0') {
      HashEntryStatus = &SystemStringTemplate;
      if (*(void* **)(ResourceManagerPointer + 0x1d60) != (void* *)0x0) {
        HashEntryStatus = *(void* **)(ResourceManagerPointer + 0x1d60);
      }
      InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,HashEntryStatus);
    }
    *(uint32_t *)(ResourceManagerPointer + 0x1d50) = *(uint32_t *)(ResourceManagerPointer + 0x1d98);
    return;
  }
  *(uint32_t *)(ResourceManagerPointer + 0x1d50) = ConfigurationDataPointer;
  return;
}





// 函数: void ProcessSystemResourceConfiguration(void* ResourceManagerPointer,uint32_t ConfigurationDataPointer)
/**
 * @brief 处理系统资源配置
 * 
 * 该函数负责处理系统资源的配置操作，包括初始化检查、配置数据设置
 * 和系统状态更新。它会根据系统初始化状态执行不同的配置操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_18006b540，现已重命名为ProcessSystemResourceConfiguration
 */
void ProcessSystemResourceConfiguration(void* ResourceManagerPointer,uint32_t ConfigurationDataPointer)

{
  long long nextDataIndex;
  char validationStatusFlag;
  void* *HashNodePointer;
  uint32_t auStackX_10 [6];
  
  nextDataIndex = SystemNodeManagerPointer;
  if ((*(long long *)(SystemNodeManagerPointer + 0x1870) != 0) &&
     (auStackX_10[0] = ConfigurationDataPointer, charResult = (**(code **)(SystemNodeManagerPointer + 0x1878))(auStackX_10),
     ConfigurationDataPointer = auStackX_10[0], charResult == '\0')) {
    if (SystemInitializationFlag == '\0') {
      HashNodePointer = &SystemStringTemplate;
      if (*(void* **)(nextDataIndex + 0x1820) != (void* *)0x0) {
        HashNodePointer = *(void* **)(nextDataIndex + 0x1820);
      }
      FUN_180626f80(&SystemGlobalDataTable,HashNodePointer);
    }
    *(uint32_t *)(nextDataIndex + 0x1810) = *(uint32_t *)(nextDataIndex + 0x1858);
    return;
  }
  *(uint32_t *)(nextDataIndex + 0x1810) = ConfigurationDataPointer;
  return;
}



/**
 * @brief 清理系统资源句柄
 * 
 * 该函数负责清理系统资源句柄，释放相关的内存和资源。
 * 主要用于系统资源的清理和释放工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源数据结构
 * @param ConfigurationDataPointer 清理选项参数，控制清理行为
 * @param AdditionalParameter 清理回调函数指针
 * @param ConfigurationFlag 清理标志参数，指定清理操作的标志位
 * @return 返回清理后的系统资源指针
 * 
 * 原始函数名为FUN_18006b5c0，现已重命名为CleanupSystemResourceHandle
 */
long long CleanupSystemResourceHandle(long long ResourceManagerPointer,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(ResourceManagerPointer + 0xd0) != (code *)0x0) {
    (**(code **)(ResourceManagerPointer + 0xd0))(ResourceManagerPointer + 0xc0,0,0,ConfigurationFlag,0xfffffffffffffffe);
  }
  ReleaseSystemResources(ResourceManagerPointer);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xe0);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理所需的数据结构和回调函数。
 * 主要用于系统资源的创建和管理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 初始化参数，包含初始化所需的配置信息
 * @param AdditionalParameter 初始化回调函数指针
 * @param ConfigurationFlag 初始化标志参数，指定初始化操作的标志位
 * @return 返回初始化后的系统资源指针
 * 
 * 原始函数名为FUN_18006b640，现已重命名为InitializeSystemResourceManager
 */
void* *
InitializeSystemResourceManager(void* *ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  void* creationFlags;
  
  creationFlags = 0xfffffffffffffffe;
  InitializeSystemDataTableManager();
  *ResourceManagerPointer = &SystemEventTemplate;
  ResourceManagerPointer[0x1a] = 0;
  ResourceManagerPointer[0x1b] = _guard_check_icall;
  if (ResourceManagerPointer + 0x18 != ConfigurationDataPointer) {
    systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(ResourceManagerPointer + 0x18,ConfigurationDataPointer,1,ConfigurationFlag,creationFlags);
      systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    }
    ResourceManagerPointer[0x1a] = systemFunctionPointer;
    ResourceManagerPointer[0x1b] = ConfigurationDataPointer[3];
  }
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  return ResourceManagerPointer;
}




// 函数: void InitializeSystemResourceConfiguration(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统资源配置
 * 
 * 该函数负责初始化系统资源配置，遍历资源表并执行初始化操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18006b6f0，现已重命名为InitializeSystemResourceConfiguration
 */
void InitializeSystemResourceConfiguration(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 0x13) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,AdditionalParameter,ConfigurationFlag,allocationContext);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ProcessSystemResourceConfigurationData(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 处理系统资源配置数据
 * 
 * 该函数负责处理系统资源配置数据，遍历资源表并执行数据处理操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18006b760，现已重命名为ProcessSystemResourceConfigurationData
 */
void ProcessSystemResourceConfigurationData(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 0x13) {
    (**(code **)*HashEntryStatus)(HashEntryStatus,0,AdditionalParameter,ConfigurationFlag,allocationContext);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}





// 函数: void CleanupSystemResourceConfiguration(void)
/**
 * @brief 清理系统资源配置
 * 
 * 该函数负责清理系统资源配置，执行系统清理操作
 * 
 * 原始函数名为FUN_18006b780，现已重命名为CleanupSystemResourceConfiguration
 */
void CleanupSystemResourceConfiguration(void)

{
  long long *PrimaryResourcePointer;
  long long localSystemHandle;
  char characterProcessingFlag;
  
  if (SystemCleanupHandler != 0) {
    (**(code **)(SystemCleanupHandler + 0x88))(1);
  }

// 函数: void ReleaseSystemResourceHandle(long long ResourceManagerPointer)
/**
 * @brief 释放系统资源句柄
 * 
 * 该函数负责释放系统资源句柄，清理相关内存和资源
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006b8f0，现已重命名为ReleaseSystemResourceHandle
 */
void ReleaseSystemResourceHandle(long long ResourceManagerPointer)

{
  *(void* *)(ResourceManagerPointer + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(ResourceManagerPointer + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ResourceManagerPointer + 0x28) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x38) = 0;
  *(void* *)(ResourceManagerPointer + 0x20) = &SystemMemoryAllocatorReference;
  return;
}





// 函数: void DestroyResourceManagerPointer(void* *ResourceManagerPointer)
/**
 * @brief 销毁系统资源指针
 * 
 * 该函数负责销毁系统资源指针，释放相关资源
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006b940，现已重命名为DestroyResourceManagerPointer
 */
void DestroyResourceManagerPointer(void* *ResourceManagerPointer)

{
  ulong long systemStatus;
  ulong long creationFlags;
  ulong long allocationContext;
  void* *punsignedSystemValue4;
  void* *pcurrentThreadId;
  long long localSystemFlags;
  long long localDataIndex;
  uint8_t aUnsignedStackFlagB8 [48];
  void* *pUnsignedStackFlag88;
  void* *pUnsignedStackFlag80;
  void* EncryptionValue68;
  void* *punsignedValue60;
  ulong long unsignedValue30;
  
  EncryptionValue68 = 0xfffffffffffffffe;
  unsignedValue30 = SystemEncryptionKeyTemplate ^ (ulong long)aUnsignedStackFlagB8;
  *ResourceManagerPointer = &SystemCriticalSectionTemplate;
  creationFlags = 0;
  ResourceManagerPointer[1] = 0;
  pUnsignedStackFlag80 = ResourceManagerPointer + 2;
  *pUnsignedStackFlag80 = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  ResourceManagerPointer[4] = 0;
  ResourceManagerPointer[7] = 0;
  pcurrentThreadId = ResourceManagerPointer + 0xd;
  localDataIndex = 0x20;
  localSystemFlags = 0x20;
  punsignedSystemValue4 = pcurrentThreadId;
  punsignedValue60 = ResourceManagerPointer;
  do {
    SystemResourceCleanup(punsignedSystemValue4);
    punsignedSystemValue4 = punsignedSystemValue4 + 2;
    localSystemFlags = localSystemFlags + -1;
  } while (localSystemFlags != 0);
  *(void* *)((long long)ResourceManagerPointer + 0x26c) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x4d) = 0;
  ResourceManagerPointer[9] = 0;
  ResourceManagerPointer[10] = 0x20;
  ResourceManagerPointer[0xb] = pcurrentThreadId;
  do {
    *(uint32_t *)pcurrentThreadId = 0;
    pcurrentThreadId = pcurrentThreadId + 2;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  ResourceManagerPointer[0xc] = 0;
  ResourceManagerPointer[8] = ResourceManagerPointer + 10;
  ResourceManagerPointer[6] = 0x15;
  localSystemFlags = InitializeSystemThreadStructure();
  ResourceManagerPointer[5] = localSystemFlags;
  if (localSystemFlags == 0) {
    ResourceManagerPointer[6] = 0;
    systemStatus = creationFlags;
  }
  else {
    systemStatus = ResourceManagerPointer[6];
  }
  allocationContext = creationFlags;
  if (systemStatus != 0) {
    do {
      *(uint8_t *)(creationFlags + 0x141 + ResourceManagerPointer[5]) = 0;
      allocationContext = allocationContext + 1;
      creationFlags = creationFlags + 0x148;
    } while (allocationContext < (ulong long)ResourceManagerPointer[6]);
  }
  pUnsignedStackFlag88 = ResourceManagerPointer + 0x4f;
  _Cnd_init_in_situ();
  pUnsignedStackFlag88 = ResourceManagerPointer + 0x58;
  _Mtx_init_in_situ(pUnsignedStackFlag88,2);
  *(uint32_t *)(ResourceManagerPointer + 0x65) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x32c) = 0x80;
  pUnsignedStackFlag80 = ResourceManagerPointer + 0x66;
  *(uint32_t *)(ResourceManagerPointer + 0x6a) = 0x3f800000;
  *(void* *)((long long)ResourceManagerPointer + 0x354) = 0x40000000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x35c) = 3;
  ResourceManagerPointer[0x68] = 1;
  ResourceManagerPointer[0x67] = &SystemNullPointer;
  ResourceManagerPointer[0x69] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x6b) = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x6d) = 1;
  localSystemFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x140038,8,3);
    memset(localSystemFlags + 0x20,0,0x140000);
}



/**
 * @brief 系统资源管理器配置函数
 * 
 * 该函数配置系统资源管理器，包括配置系统缓冲区和根据配置标志
 * 决定是否释放资源管理器内存。用于系统资源管理的配置和清理。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针（包含清理标志）
 * @return 配置后的资源管理器指针
 * 
 * 原始函数名为FUN_18006bd20，现已重命名为ConfigureResourceManager
 */
void* ConfigureResourceManager(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  ConfigureSystemBuffer();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x370);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 清理系统资源指针数组
 * 
 * 该函数负责清理系统资源指针数组，将所有指针重置为系统内存分配器引用，
 * 并执行必要的清理操作。主要用于系统资源的释放和重置。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源数据结构
 * 
 * 原始函数名为FUN_18006bd60，现已重命名为CleanupResourceManagerPointerArray
 */
void CleanupResourceManagerPointerArray(long long ResourceManagerPointer)

{
  long long arrayIndex;
  void** systemDataTable;
  ulong long arraySize;
  ulong long currentIndex;
  
  arraySize = *(ulong long *)(ResourceManagerPointer + 0x10);
  arrayIndex = *(long long *)(ResourceManagerPointer + 8);
  currentIndex = 0;
  if (arraySize != 0) {
    do {
      resourcePointer = *(void* **)(arrayIndex + currentIndex * 8);
      if (resourcePointer != (void* *)0x0) {
        *resourcePointer = &SystemMemoryAllocatorReference;
          SystemCleanupFunction();
      }
      *(void* *)(arrayIndex + currentIndex * 8) = 0;
      currentIndex = currentIndex + 1;
    } while (currentIndex < arraySize);
    arraySize = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < arraySize) && (*(long long *)(ResourceManagerPointer + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * @brief 重置系统资源指针数组
 * 
 * 该函数负责重置系统资源指针数组，将所有指针重置为系统内存分配器引用，
 * 并执行必要的清理操作。主要用于系统资源的重置和初始化。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要重置的资源数据结构
 * 
 * 原始函数名为FUN_18006bd80，现已重命名为ResetResourceManagerPointerArray
 */
void ResetResourceManagerPointerArray(long long ResourceManagerPointer)

{
  long long arrayIndex;
  void** systemDataTable;
  ulong long arraySize;
  ulong long currentIndex;
  
  arraySize = *(ulong long *)(ResourceManagerPointer + 0x10);
  arrayIndex = *(long long *)(ResourceManagerPointer + 8);
  currentIndex = 0;
  if (arraySize != 0) {
    do {
      resourcePointer = *(void* **)(arrayIndex + currentIndex * 8);
      if (resourcePointer != (void* *)0x0) {
        *resourcePointer = &SystemMemoryAllocatorReference;
          SystemCleanupFunction();
      }
      *(void* *)(arrayIndex + currentIndex * 8) = 0;
      currentIndex = currentIndex + 1;
    } while (currentIndex < arraySize);
    arraySize = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* )(ResourceManagerPointer + 0x18) = 0;
  if ((1 < arraySize) && (*(long long *)(ResourceManagerPointer + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * @brief 系统资源分配和配置函数
 * 
 * 该函数负责系统资源的分配、配置和初始化
 * 包括内存池管理、哈希表操作和资源索引分配
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志指针
 * @param OutputResult 输出结果指针
 * 
 * 原始函数名为FUN_18006bda0，现已重命名为AllocateAndConfigureSystemResource
 */
void AllocateAndConfigureSystemResource(long long ResourceManagerPointer,long long ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag,
             long long *OutputResult)

{
  long long nextDataIndex;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  ulong long currentThreadId;
  ulong long hashValue;
  void*7 unsignedSystemValue7;
  
  localResourceOffset = *(long long *)(ConfigurationDataPointer + 0x128);
  if (localResourceOffset != 0) {
    *AdditionalParameter = localResourceOffset;
    localResourceOffset = *(long long *)(ConfigurationDataPointer + 0x128);
  }
  nextDataIndex = *(long long *)(ConfigurationDataPointer + 0x130);
  unsignedSystemValue4 = 0;
  if (nextDataIndex == 0) {
    if (localResourceOffset == 0) {
      unsignedSystemValue4 = *(ulong long *)(ConfigurationDataPointer + 0x120);
    }
  }
  else {
    unsignedSystemValue4 = *(ulong long *)(ConfigurationDataPointer + 0x120);
    if (localResourceOffset == 0) {
      unsignedSystemValue4 = unsignedSystemValue4 + *(long long *)(ConfigurationDataPointer + 0x138);
    }
  }
  *(void* *)(ConfigurationDataPointer + 0x1a0) = 0;
  *(void* *)(ConfigurationDataPointer + 0x198) = 0;
  *(void* *)(ConfigurationDataPointer + 400) = 0;
  *(void* *)(ConfigurationDataPointer + 0x188) = 0;
  currentThreadId = (*(long long *)(ConfigurationDataPointer + 0x120) - (*(ulong long *)(ConfigurationDataPointer + 0x118) & 0xfffffffffffff000))
          + *(ulong long *)(ConfigurationDataPointer + 0x118);
  hashValue = currentThreadId & 0xfffffffffffff000;
  localResourceOffset = (-(uint)((currentThreadId & 0xfff) != 0) & 0x1000) + hashValue;
  if (*(ulong long *)(ResourceManagerPointer + 0x360) < unsignedSystemValue4) {
    unsignedSystemValue7 = (void*7)(hashValue >> 8);
    if (nextDataIndex == 0) {
      if (*AdditionalParameter == 0) {
        localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,localResourceOffset,CONCAT71(unsignedSystemValue7,3));
        *AdditionalParameter = localResourceOffset;
        *(long long *)(ConfigurationDataPointer + 0x198) = localResourceOffset;
        *OutputResult = *AdditionalParameter;
      }
    }
    else {
      localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,localResourceOffset,CONCAT71(unsignedSystemValue7,3));
      *ConfigurationFlag = localResourceOffset;
      *(long long *)(ConfigurationDataPointer + 0x198) = localResourceOffset;
      *OutputResult = *ConfigurationFlag;
      if (*AdditionalParameter == 0) {
        localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,*(void* *)(ConfigurationDataPointer + 0x138),3);
        *AdditionalParameter = localResourceOffset;
        *(long long *)(ConfigurationDataPointer + 0x1a0) = localResourceOffset;
      }
    }
  }
  else if (nextDataIndex == 0) {
    if (*AdditionalParameter == 0) {
      resourcePoolPointer = (long long *)FUN_18006e000(ResourceManagerPointer,localResourceOffset);
      *(long long **)(ConfigurationDataPointer + 400) = resourcePoolPointer;
      if (resourcePoolPointer == (long long *)0x0) goto LAB_18006bf7f;
      localResourceOffset = *(long long *)(ResourceManagerPointer + 800) + *resourcePoolPointer;
      *AdditionalParameter = localResourceOffset;
      *OutputResult = localResourceOffset;
    }
  }
  else {
    resourcePoolPointer = (long long *)FUN_18006e000(ResourceManagerPointer,localResourceOffset);
    *(long long **)(ConfigurationDataPointer + 0x188) = resourcePoolPointer;
    if (resourcePoolPointer == (long long *)0x0) {
LAB_18006bf7f:
      ConfigureSystemMemoryBlock(ResourceManagerPointer,*(void* *)(ConfigurationDataPointer + 0x188));
      ConfigureSystemMemoryBlock(ResourceManagerPointer,*(void* *)(ConfigurationDataPointer + 400));
      return 0;
    }
    localResourceOffset = *resourcePoolPointer + *(long long *)(ResourceManagerPointer + 800);
    *ConfigurationFlag = localResourceOffset;
    *OutputResult = localResourceOffset;
    if (*AdditionalParameter == 0) {
      resourcePoolPointer = (long long *)FUN_18006e000(ResourceManagerPointer,*(void* *)(ConfigurationDataPointer + 0x138));
      *(long long **)(ConfigurationDataPointer + 400) = resourcePoolPointer;
      if (resourcePoolPointer == (long long *)0x0) goto LAB_18006bf7f;
      *AdditionalParameter = *resourcePoolPointer + *(long long *)(ResourceManagerPointer + 800);
    }
  }
  return 1;
}




// 函数: void ConfigureSystemBuffer(void* *ResourceManagerPointer)
void ConfigureSystemBuffer(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemCriticalSectionTemplate;
  FUN_18006cb90();
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  SuspendSystemThreads(ResourceManagerPointer + 2);
  if ((long long *)ResourceManagerPointer[1] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[1] + 0x38))();
  }
  return;
}





// 函数: void FUN_18006c070(long long ResourceManagerPointer)
/**
 * @brief 处理系统资源节点队列
 * 
 * 该函数负责处理系统资源节点队列，包括节点的创建、销毁和状态管理。
 * 主要用于系统资源的动态管理和内存分配。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006c070，现已重命名为ProcessSystemResourceNodeQueue
 */
void ProcessSystemResourceNodeQueue(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  byte *pisOperationComplete;
  void* unsignedSystemValue4;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  bool isDataValid;
  long long localMemoryAddress;
  char systemAvailabilityFlag;
  long long allocationFlags;
  long long *PrimaryResourcePointer1;
  byte *pisByteValid2;
  long long nextDataIndex3;
  long long nextDataIndex4;
  long long *PrimaryResourcePointer5;
  uint systemStatus6;
  int systemStatus7;
  long long *PrimaryResourcePointer8;
  void* *HashEntryStatus0;
  long long localSystemHandle1;
  code *pcharResult2;
  long long *resourcePoolPointer3;
  void* *HashEntryStatus4;
  ulong long creationFlags5;
  uint8_t aunsignedValue278 [32];
  ulong long uStack_258;
  void* **ppunsignedValue248;
  long long *plStack_240;
  long long lStack_238;
  long long longValue230;
  uint8_t unsignedValue228;
  void* uStack_218;
  int iStack_210;
  uint32_t unsignedValue20c;
  void* unsignedValue208;
  void* *SystemGlobalDataReferencePtr2;
  byte *pbStack_1f0;
  int iStack_1e8;
  byte abStack_1e0 [256];
  void* uStack_e0;
  ulong long unsignedValueD8;
  long long lStack_d0;
  long long lStack_c8;
  long long lStack_c0;
  uint8_t UnsignedStackFlagB8;
  uint8_t aUnsignedStackFlagB0 [16];
  code *charPointerA0;
  code *pcStack_98;
  uint8_t aStackParameterC [16];
  code *charPointer80;
  code *pcStack_78;
  void* processFlags70;
  void* EncryptionValue68;
  void* unsignedValue60;
  void* processFlags58;
  int iStack_48;
  uint32_t uStack_44;
  int iStack_40;
  uint32_t uStack_3c;
  ulong long uStack_38;
  ulong long systemStatus9;
  
  unsignedValue208 = 0xfffffffffffffffe;
  uStack_38 = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue278;
  charOutput = *(char *)(*(long long *)(ResourceManagerPointer + 1000) + 0x58);
  do {
    if ((charOutput == '\0') || (systemStatus9 = 0, *(char *)(ResourceManagerPointer + 0x400) != '\0')) {
        ValidateSystemChecksum(uStack_38 ^ (ulong long)aunsignedValue278);
    }
    SystemGlobalDataReferencePtr2 = &SystemMemoryAllocatorTemplate;
    pbStack_1f0 = abStack_1e0;
    iStack_1e8 = 0;
    abStack_1e0[0] = 0;
    charPointerA0 = (code *)0x0;
    pcStack_98 = _guard_check_icall;
    ppunsignedValue248 = (void* **)aStackParameterC;
    charPointer80 = (code *)0x0;
    pcStack_78 = _guard_check_icall;
    lStack_c0 = -1;
    unsignedValueD8 = 0xffffffffffffffff;
    uStack_e0 = 0xffffffffffffffff;
    lStack_d0 = 0;
    lStack_c8 = 0;
    UnsignedStackFlagB8 = 0;
    nextDataIndex3 = *(long long *)(ResourceManagerPointer + 0x3c8);
    nextDataIndex4 = *(long long *)(ResourceManagerPointer + 0x3d0) - nextDataIndex3;
    allocationFlags = nextDataIndex4 >> 0x3f;
    if (nextDataIndex4 / 0x1a8 + allocationFlags == allocationFlags) {
      charOutput = FUN_18006d4e0(ResourceManagerPointer + 200,&SystemGlobalDataReferencePtr2);
      if (systemAvailabilityFlag == '\0') {
        nextDataIndex3 = ResourceManagerPointer + 0x378;
        unsignedValue228 = 0;
        longValue230 = nextDataIndex3;
        systemStatus7 = _Mtx_lock(nextDataIndex3);
        if (systemStatus7 != 0) {
          __Throw_C_error_std__YAXH_Z(systemStatus7);
        }
        unsignedValue228 = 1;
        allocationFlags = _Xtime_get_ticks();
        nextDataIndex4 = (allocationFlags + 50000) * 100;
        allocationFlags = nextDataIndex4 / 1000000000;
        iStack_48 = (int)allocationFlags;
        iStack_210 = (int)nextDataIndex4 + iStack_48 * -1000000000;
        uStack_218._4_4_ = (uint32_t)((ulong long)allocationFlags >> 0x20);
        uStack_44 = uStack_218._4_4_;
        uStack_3c = unsignedValue20c;
        uStack_218 = allocationFlags;
        iStack_40 = iStack_210;
        systemStatus7 = _Mtx_current_owns(nextDataIndex3);
        if (systemStatus7 == 0) {
          __Throw_Cpp_error_std__YAXH_Z(4);
        }
        systemStatus6 = _Cnd_timedwait(ResourceManagerPointer + 0x330,nextDataIndex3,&iStack_48);
        if ((systemStatus6 & 0xfffffffd) != 0) {
          __Throw_C_error_std__YAXH_Z(systemStatus6);
        }
        charOutput = FUN_18006d4e0(ResourceManagerPointer + 200,&SystemGlobalDataReferencePtr2);
        if (systemAvailabilityFlag == '\0') {
          systemStatus7 = _Mtx_unlock(nextDataIndex3);
          if (systemStatus7 != 0) {
            __Throw_C_error_std__YAXH_Z(systemStatus7);
          }
          isDataValid = false;
        }
        else {
          systemStatus7 = _Mtx_unlock();
          if (systemStatus7 != 0) {
            __Throw_C_error_std__YAXH_Z(systemStatus7);
          }
          isDataValid = true;
        }
      }
      else {
        isDataValid = true;
      }
    }
    else {
      iStack_1e8 = *(int *)(nextDataIndex3 + 0x10);
      HashEntryStatus4 = &SystemStringTemplate;
      if (*(void* **)(nextDataIndex3 + 8) != (void* *)0x0) {
        HashEntryStatus4 = *(void* **)(nextDataIndex3 + 8);
      }
      strcpy_s(pbStack_1f0,0x100,HashEntryStatus4);
      uStack_e0 = *(void* *)(nextDataIndex3 + 0x118);
      unsignedValueD8 = *(ulong long *)(nextDataIndex3 + 0x120);
      lStack_d0 = *(long long *)(nextDataIndex3 + 0x128);
      lStack_c8 = *(long long *)(nextDataIndex3 + 0x130);
      lStack_c0 = *(long long *)(nextDataIndex3 + 0x138);
      UnsignedStackFlagB8 = *(uint8_t *)(nextDataIndex3 + 0x140);
      if (aUnsignedStackFlagB0 != (uint8_t *)(nextDataIndex3 + 0x148)) {
        if (charPointerA0 != (code *)0x0) {
          (*charPointerA0)(aUnsignedStackFlagB0,0,0);
        }
        pcharResult2 = *(code **)(nextDataIndex3 + 0x158);
        if (pcharResult2 != (code *)0x0) {
          (*pcharResult2)(aUnsignedStackFlagB0,(uint8_t *)(nextDataIndex3 + 0x148),1);
          pcharResult2 = *(code **)(nextDataIndex3 + 0x158);
        }
        pcStack_98 = *(code **)(nextDataIndex3 + 0x160);
        charPointerA0 = pcharResult2;
      }
      if (aStackParameterC != (uint8_t *)(nextDataIndex3 + 0x168)) {
        if (charPointer80 != (code *)0x0) {
          (*charPointer80)(aStackParameterC,0,0);
        }
        pcharResult2 = *(code **)(nextDataIndex3 + 0x178);
        if (pcharResult2 != (code *)0x0) {
          (*pcharResult2)(aStackParameterC,(uint8_t *)(nextDataIndex3 + 0x168),1);
          pcharResult2 = *(code **)(nextDataIndex3 + 0x178);
        }
        pcStack_78 = *(code **)(nextDataIndex3 + 0x180);
        charPointer80 = pcharResult2;
      }
      processFlags70 = *(void* *)(nextDataIndex3 + 0x188);
      EncryptionValue68 = *(void* *)(nextDataIndex3 + 400);
      unsignedValue60 = *(void* *)(nextDataIndex3 + 0x198);
      processFlags58 = *(void* *)(nextDataIndex3 + 0x1a0);
      *(long long *)(ResourceManagerPointer + 0x3d0) = *(long long *)(ResourceManagerPointer + 0x3d0) + -0x1a8;
      ReleaseSystemResource();
      isDataValid = true;
    }
    HashEntryStatus0 = *(void* **)(ResourceManagerPointer + 0xc0);
    if ((void* *)*HashEntryStatus0 == &SystemMemoryManagerTemplate) {
      charOutput = FindResourceManagerPointerMapping(HashEntryStatus0 + 2,&plStack_240);
      while (charOutput != '\0') {
        resourcePoolPointer3 = (long long *)HashEntryStatus0[99];
        if (plStack_240 != (long long *)0x0) {
          *(uint8_t *)(plStack_240 + 4) = 0;
          *resourcePoolPointer3 = *resourcePoolPointer3 - plStack_240[1];
          resourcePoolPointer3[2] = resourcePoolPointer3[2] + plStack_240[1];
          PrimaryResourcePointer8 = (long long *)plStack_240[3];
          PrimaryResourcePointer5 = (long long *)resourcePoolPointer3[3];
          PrimaryResourcePointer1 = plStack_240;
          if (PrimaryResourcePointer8 != PrimaryResourcePointer5) {
            do {
              if ((PrimaryResourcePointer8 == (long long *)0x0) || ((char)PrimaryResourcePointer8[4] != '\0')) break;
              nextDataIndex3 = PrimaryResourcePointer1[2];
              PrimaryResourcePointer8[2] = nextDataIndex3;
              if (nextDataIndex3 != 0) {
                *(long long **)(nextDataIndex3 + 0x18) = PrimaryResourcePointer8;
              }
              PrimaryResourcePointer8[1] = PrimaryResourcePointer8[1] + PrimaryResourcePointer1[1];
              *PrimaryResourcePointer1 = resourcePoolPointer3[0x28005];
              resourcePoolPointer3[0x28005] = (long long)PrimaryResourcePointer1;
              PrimaryResourcePointer = PrimaryResourcePointer8 + 3;
              PrimaryResourcePointer5 = (long long *)resourcePoolPointer3[3];
              PrimaryResourcePointer1 = PrimaryResourcePointer8;
              PrimaryResourcePointer8 = (long long *)*PrimaryResourcePointer;
            } while ((long long *)*PrimaryResourcePointer != PrimaryResourcePointer5);
          }
          PrimaryResourcePointer8 = (long long *)PrimaryResourcePointer1[2];
          while (((PrimaryResourcePointer1 != PrimaryResourcePointer5 && (PrimaryResourcePointer8 != (long long *)0x0)) && ((char)PrimaryResourcePointer8[4] == '\0')
                 )) {
            nextDataIndex3 = PrimaryResourcePointer8[2];
            PrimaryResourcePointer1[2] = nextDataIndex3;
            if (nextDataIndex3 != 0) {
              *(long long **)(nextDataIndex3 + 0x18) = PrimaryResourcePointer1;
            }
            PrimaryResourcePointer1[1] = PrimaryResourcePointer1[1] + PrimaryResourcePointer8[1];
            *PrimaryResourcePointer8 = resourcePoolPointer3[0x28005];
            resourcePoolPointer3[0x28005] = (long long)PrimaryResourcePointer8;
            PrimaryResourcePointer5 = (long long *)resourcePoolPointer3[3];
            PrimaryResourcePointer8 = (long long *)PrimaryResourcePointer1[2];
          }
        }
        charOutput = FindResourceManagerPointerMapping(HashEntryStatus0 + 2,&plStack_240);
      }
    }
    else {
      (**(code **)((void* *)*HashEntryStatus0 + 0x18))(HashEntryStatus0);
    }
    if (isDataValid) {
      resourcePoolPointer3 = *(long long **)(ResourceManagerPointer + 0xc0);
      creationFlags5 = systemStatus9;
      if (0 < iStack_1e8) {
        do {
          creationFlags5 = creationFlags5 * 0x1f + (long long)(char)pbStack_1f0[systemStatus9];
          systemStatus6 = (int)systemStatus9 + 1;
          systemStatus9 = (ulong long)systemStatus6;
        } while ((int)systemStatus6 < iStack_1e8);
      }
      PrimaryResourcePointer8 = (long long *)resourcePoolPointer3[0x67];
      for (nextDataIndex3 = PrimaryResourcePointer8[creationFlags5 % (ulong long)*(uint *)(resourcePoolPointer3 + 0x68)]; nextDataIndex3 != 0;
          nextDataIndex3 = *(long long *)(nextDataIndex3 + 0x120)) {
        systemStatus7 = *(int *)(nextDataIndex3 + 0x10);
        if (iStack_1e8 == systemStatus7) {
          if (iStack_1e8 != 0) {
            pisByteValid2 = pbStack_1f0;
            do {
              pisOperationComplete = pisByteValid2 + (*(long long *)(nextDataIndex3 + 8) - (long long)pbStack_1f0);
              systemStatus7 = (uint)*pisByteValid2 - (uint)*pisOperationComplete;
              if (systemStatus7 != 0) break;
              pisByteValid2 = pisByteValid2 + 1;
            } while (*pisOperationComplete != 0);
          }
LAB_18006c61e:
          if (systemStatus7 == 0) {
            if (nextDataIndex3 != 0) {
              allocationFlags = resourcePoolPointer3[0x68];
              goto LAB_18006c642;
            }
            break;
          }
        }
        else if (iStack_1e8 == 0) goto LAB_18006c61e;
      }
      allocationFlags = resourcePoolPointer3[0x68];
      nextDataIndex3 = PrimaryResourcePointer8[allocationFlags];
LAB_18006c642:
      if ((nextDataIndex3 != PrimaryResourcePointer8[allocationFlags]) && (nextDataIndex3 = *(long long *)(nextDataIndex3 + 0x118), nextDataIndex3 != 0)) {
LAB_18006c852:
        if (lStack_c8 == 0) {
          systemStatus9 = 0;
          if (lStack_d0 == 0) {
            systemStatus9 = unsignedValueD8;
          }
        }
        else {
          systemStatus9 = unsignedValueD8;
          if (lStack_d0 == 0) {
            systemStatus9 = unsignedValueD8 + lStack_c0;
          }
        }
        LOCK();
        resourcePoolPointer3 = (long long *)(ResourceManagerPointer + 0x3f0);
        allocationFlags = *resourcePoolPointer3;
        *resourcePoolPointer3 = *resourcePoolPointer3 + systemStatus9;
        UNLOCK();
        LOCK();
        pointerToInteger2 = (int *)(ResourceManagerPointer + 0x3f8);
        systemStatus7 = *pointerToInteger2;
        *pointerToInteger2 = *pointerToInteger2 + 1;
        UNLOCK();
        HashEntryStatus0 = *(void* **)(ResourceManagerPointer + 0xc0);
        uStack_258 = HashEntryStatus0[0x6c];
        if (uStack_258 < systemStatus9) {
          pisByteValid2 = &SystemStringTemplate;
          if (pbStack_1f0 != (byte *)0x0) {
            pisByteValid2 = pbStack_1f0;
          }
            UpdateContextManagerSystem(SystemContextManagerPointer,&SystemSecurityUpdateData,systemStatus9,pisByteValid2);
        }
        if (((uStack_258 < allocationFlags + systemStatus9) ||
            ((ulong long)(long long)*(int *)(ResourceManagerPointer + 0x3fc) < (long long)systemStatus7 + 1U)) ||
           (charOutput = (**(code **)*HashEntryStatus0)(HashEntryStatus0,nextDataIndex3,&SystemGlobalDataReferencePtr2), charOutput == '\0')) {
          LOCK();
          *(long long *)(ResourceManagerPointer + 0x3f0) = *(long long *)(ResourceManagerPointer + 0x3f0) - systemStatus9;
          UNLOCK();
          LOCK();
          *(int *)(ResourceManagerPointer + 0x3f8) = *(int *)(ResourceManagerPointer + 0x3f8) + -1;
          UNLOCK();
          FUN_18006cc50(ResourceManagerPointer + 0x3c8,&SystemGlobalDataReferencePtr2);
LAB_18006ca44:
          pcharResult2 = *(code **)(**(long long **)(ResourceManagerPointer + 0xc0) + 0x28);
          if (pcharResult2 != _guard_check_icall) {
            (*pcharResult2)();
          }
          Sleep(1);
        }
        pcharResult2 = *(code **)(**(long long **)(ResourceManagerPointer + 0xc0) + 0x20);
        if (pcharResult2 != _guard_check_icall) {
          (*pcharResult2)();
        }
        goto LAB_18006ca95;
      }
      if (*(int *)((long long)resourcePoolPointer3 + 0x32c) < (int)resourcePoolPointer3[0x65]) {
        HashEntryStatus0 = (void* *)*PrimaryResourcePointer8;
        PrimaryResourcePointer5 = PrimaryResourcePointer8;
        if (HashEntryStatus0 == (void* *)0x0) {
          PrimaryResourcePointer5 = PrimaryResourcePointer8 + 1;
          HashEntryStatus0 = (void* *)*PrimaryResourcePointer5;
          if (HashEntryStatus0 == (void* *)0x0) {
            do {
              PrimaryResourcePointer5 = PrimaryResourcePointer5 + 1;
              HashEntryStatus0 = (void* *)*PrimaryResourcePointer5;
            } while (HashEntryStatus0 == (void* *)0x0);
            allocationFlags = resourcePoolPointer3[0x68];
          }
        }
        if (HashEntryStatus0 != (void* *)PrimaryResourcePointer8[allocationFlags]) {
          do {
            if (*(int *)(HashEntryStatus0[0x23] + 0x120) == 0) {
              unsignedSystemValue4 = HashEntryStatus0[0x23];
              *(int *)(resourcePoolPointer3 + 0x65) = (int)resourcePoolPointer3[0x65] + -1;
              (**(code **)(*resourcePoolPointer3 + 0x10))(resourcePoolPointer3,unsignedSystemValue4);
              nextDataIndex3 = HashEntryStatus0[0x24];
              resourcePoolPointer3 = PrimaryResourcePointer5;
              while (nextDataIndex3 == 0) {
                resourcePoolPointer3 = resourcePoolPointer3 + 1;
                nextDataIndex3 = *resourcePoolPointer3;
              }
              pcurrentThreadId = (void* *)*PrimaryResourcePointer5;
              resourceEntryPointer = (void* *)pcurrentThreadId[0x24];
              if (pcurrentThreadId == HashEntryStatus0) {
                *PrimaryResourcePointer5 = (long long)resourceEntryPointer;
              }
              else {
                for (; resourceEntryPointer != HashEntryStatus0; resourceEntryPointer = (void* *)resourceEntryPointer[0x24]) {
                  pcurrentThreadId = resourceEntryPointer;
                }
                pcurrentThreadId[0x24] = resourceEntryPointer[0x24];
              }
              *HashEntryStatus0 = &SystemMemoryAllocatorReference;
              ppunsignedValue248 = (void* **)HashEntryStatus0;
                SystemCleanupFunction(HashEntryStatus0);
            }
            HashEntryStatus0 = (void* *)HashEntryStatus0[0x24];
            while (HashEntryStatus0 == (void* *)0x0) {
              PrimaryResourcePointer5 = PrimaryResourcePointer5 + 1;
              HashEntryStatus0 = (void* *)*PrimaryResourcePointer5;
            }
          } while (HashEntryStatus0 != *(void* **)(resourcePoolPointer3[0x67] + resourcePoolPointer3[0x68] * 8));
        }
      }
      PrimaryResourcePointer8 = (long long *)(ResourceManagerPointer + 0x3c8);
      nextDataIndex3 = 0;
      resourcePoolPointer3 = *(long long **)(ResourceManagerPointer + 0xc0);
      if (*(int *)((long long)resourcePoolPointer3 + 0x32c) < (int)resourcePoolPointer3[0x65]) {
        systemStatus9 = *(ulong long *)(ResourceManagerPointer + 0x3d0);
        if (systemStatus9 < *(ulong long *)(ResourceManagerPointer + 0x3d8)) {
          *(ulong long *)(ResourceManagerPointer + 0x3d0) = systemStatus9 + 0x1a8;
          FUN_18006cd80(systemStatus9,&SystemGlobalDataReferencePtr2);
          goto LAB_18006ca44;
        }
        allocationFlags = *PrimaryResourcePointer8;
        nextDataIndex4 = (long long)(systemStatus9 - allocationFlags) / 0x1a8;
        if (nextDataIndex4 == 0) {
          nextDataIndex4 = 1;
LAB_18006c9ac:
          nextDataIndex3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex4 * 0x1a8,*(uint8_t *)(ResourceManagerPointer + 0x3e0));
          systemStatus9 = *(ulong long *)(ResourceManagerPointer + 0x3d0);
          allocationFlags = *PrimaryResourcePointer8;
        }
        else {
          nextDataIndex4 = nextDataIndex4 * 2;
          if (nextDataIndex4 != 0) goto LAB_18006c9ac;
        }
        InitializeSystemMemoryAllocatorWithHashNodes(&lStack_238,allocationFlags,systemStatus9,nextDataIndex3);
        localMemoryAddress = lStack_238;
        FUN_18006cd80(lStack_238,&SystemGlobalDataReferencePtr2);
        allocationFlags = *(long long *)(ResourceManagerPointer + 0x3d0);
        localSystemHandle1 = *PrimaryResourcePointer8;
        if (localSystemHandle1 != allocationFlags) {
          do {
            ReleaseSystemResource(localSystemHandle1);
            localSystemHandle1 = localSystemHandle1 + 0x1a8;
          } while (localSystemHandle1 != allocationFlags);
          localSystemHandle1 = *PrimaryResourcePointer8;
        }
        if (localSystemHandle1 != 0) {
            SystemCleanupFunction(localSystemHandle1);
        }
        *PrimaryResourcePointer8 = nextDataIndex3;
        *(long long *)(ResourceManagerPointer + 0x3d0) = localMemoryAddress + 0x1a8;
        *(long long *)(ResourceManagerPointer + 0x3d8) = nextDataIndex4 * 0x1a8 + nextDataIndex3;
        goto LAB_18006ca44;
      }
      *(int *)(resourcePoolPointer3 + 0x65) = (int)resourcePoolPointer3[0x65] + 1;
      nextDataIndex3 = (**(code **)(*resourcePoolPointer3 + 8))(resourcePoolPointer3,&SystemGlobalDataReferencePtr2);
      if (nextDataIndex3 != 0) goto LAB_18006c852;
      (*pcStack_78)(aStackParameterC);
      ppunsignedValue248 = (void* **)aStackParameterC;
      if (charPointer80 != (code *)0x0) {
        (*charPointer80)(aStackParameterC,0,0);
      }
      ppunsignedValue248 = (void* **)aUnsignedStackFlagB0;
      if (charPointerA0 != (code *)0x0) {
        (*charPointerA0)(aUnsignedStackFlagB0,0,0);
      }
    }
    else {
      pcharResult2 = *(code **)(**(long long **)(ResourceManagerPointer + 0xc0) + 0x28);
      if (pcharResult2 != _guard_check_icall) {
        (*pcharResult2)();
      }
LAB_18006ca95:
      ppunsignedValue248 = (void* **)aStackParameterC;
      if (charPointer80 != (code *)0x0) {
        (*charPointer80)(aStackParameterC,0,0);
      }
      ppunsignedValue248 = (void* **)aUnsignedStackFlagB0;
      if (charPointerA0 != (code *)0x0) {
        (*charPointerA0)(aUnsignedStackFlagB0,0,0);
      }
    }
    ppunsignedValue248 = &SystemGlobalDataReferencePtr2;
    SystemGlobalDataReferencePtr2 = &SystemMemoryAllocatorReference;
    charOutput = *(char *)(*(long long *)(ResourceManagerPointer + 1000) + 0x58);
  } while( true );
}




// 函数: void FUN_18006cb90(long long ResourceManagerPointer)
/**
 * @brief 清理系统资源数据表
 * 
 * 该函数负责清理系统资源数据表，释放资源并重置数据表状态。
 * 主要用于系统资源的清理和内存回收。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006cb90，现已重命名为CleanupSystemResourceDataTable
 */
void CleanupSystemResourceDataTable(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  void** SystemDataTable;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  
  allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
  unsignedSystemValue4 = 0;
  if (allocationContext != 0) {
    do {
      HashEntryStatus = *(void* **)(nextDataIndex + unsignedSystemValue4 * 8);
      if (HashEntryStatus != (void* *)0x0) {
        *HashEntryStatus = &SystemMemoryAllocatorReference;
          SystemCleanupFunction();
      }
      *(void* *)(nextDataIndex + unsignedSystemValue4 * 8) = 0;
      unsignedSystemValue4 = unsignedSystemValue4 + 1;
    } while (unsignedSystemValue4 < allocationContext);
    allocationContext = *(ulong long *)(ResourceManagerPointer + 0x10);
  }
  *(void* *)(ResourceManagerPointer + 0x18) = 0;
  if ((1 < allocationContext) && (*(long long *)(ResourceManagerPointer + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: ulong long FUN_18006cc50(long long *ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 分配系统资源节点
 * 
 * 该函数负责分配系统资源节点，包括内存分配和节点初始化。
 * 主要用于系统资源的动态分配和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的资源节点地址
 * 
 * 原始函数名为FUN_18006cc50，现已重命名为AllocateSystemResourceNode
 */
ulong long AllocateSystemResourceNode(long long *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  ulong long creationFlags;
  long long localResourceOffset;
  long long bufferBaseAddress;
  code *pcharValue;
  long long localSystemFlags;
  ulong long uStackX_8;
  
  creationFlags = ResourceManagerPointer[1];
  if (creationFlags < (ulong long)ResourceManagerPointer[2]) {
    ResourceManagerPointer[1] = creationFlags + 0x1a8;
    uStackX_8 = creationFlags;
    InitializeSystemResourceStringTemplate();
    *(void* *)(creationFlags + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
    *(void* *)(creationFlags + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
    *(void* *)(creationFlags + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
    *(void* *)(creationFlags + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
    *(void* *)(creationFlags + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
    *(uint8_t *)(creationFlags + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
    *(void* *)(creationFlags + 0x158) = 0;
    *(code **)(creationFlags + 0x160) = _guard_check_icall;
    if (creationFlags + 0x148 != ConfigurationDataPointer + 0x148) {
      pcharValue = *(code **)(ConfigurationDataPointer + 0x158);
      if (pcharValue != (code *)0x0) {
        (*pcharValue)(creationFlags + 0x148,ConfigurationDataPointer + 0x148,1);
        pcharValue = *(code **)(ConfigurationDataPointer + 0x158);
      }
      *(code **)(creationFlags + 0x158) = pcharValue;
      *(void* *)(creationFlags + 0x160) = *(void* *)(ConfigurationDataPointer + 0x160);
    }
    *(void* *)(creationFlags + 0x178) = 0;
    *(code **)(creationFlags + 0x180) = _guard_check_icall;
    if (creationFlags + 0x168 != ConfigurationDataPointer + 0x168) {
      pcharValue = *(code **)(ConfigurationDataPointer + 0x178);
      if (pcharValue != (code *)0x0) {
        (*pcharValue)(creationFlags + 0x168,ConfigurationDataPointer + 0x168,1);
        pcharValue = *(code **)(ConfigurationDataPointer + 0x178);
      }
      *(code **)(creationFlags + 0x178) = pcharValue;
      *(void* *)(creationFlags + 0x180) = *(void* *)(ConfigurationDataPointer + 0x180);
    }
    *(void* *)(creationFlags + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
    *(void* *)(creationFlags + 400) = *(void* *)(ConfigurationDataPointer + 400);
    *(void* *)(creationFlags + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
    *(void* *)(creationFlags + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
    return creationFlags;
  }
  localSystemFlags = *ResourceManagerPointer;
  bufferBaseAddress = (long long)(creationFlags - localSystemFlags) / 0x1a8;
  if (bufferBaseAddress == 0) {
    bufferBaseAddress = 1;
  }
  else {
    bufferBaseAddress = bufferBaseAddress * 2;
    if (bufferBaseAddress == 0) {
      nextDataIndex = 0;
      goto LAB_18006ccef;
    }
  }
  nextDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,bufferBaseAddress * 0x1a8,(char)ResourceManagerPointer[3]);
  creationFlags = ResourceManagerPointer[1];
  localSystemFlags = *ResourceManagerPointer;
LAB_18006ccef:
  InitializeSystemMemoryAllocatorWithHashNodes(&uStackX_8,localSystemFlags,creationFlags,nextDataIndex);
  FUN_18006cd80(uStackX_8,ConfigurationDataPointer);
  localSystemFlags = ResourceManagerPointer[1];
  localResourceOffset = *ResourceManagerPointer;
  if (localResourceOffset != localSystemFlags) {
    do {
      ReleaseSystemResource(localResourceOffset);
      localResourceOffset = localResourceOffset + 0x1a8;
    } while (localResourceOffset != localSystemFlags);
    localResourceOffset = *ResourceManagerPointer;
  }
  if (localResourceOffset != 0) {
      SystemCleanupFunction(localResourceOffset);
  }
  creationFlags = bufferBaseAddress * 0x1a8 + nextDataIndex;
  *ResourceManagerPointer = nextDataIndex;
  ResourceManagerPointer[1] = uStackX_8 + 0x1a8;
  ResourceManagerPointer[2] = creationFlags;
  return creationFlags;
}





// 函数: void FUN_18006cc8d(void* ResourceManagerPointer,void* ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 配置系统资源节点
 * 
 * 该函数负责配置系统资源节点，包括内存分配和节点初始化。
 * 主要用于系统资源的动态配置和管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 * 原始函数名为FUN_18006cc8d，现已重命名为ConfigureSystemResourceNode
 */
void ConfigureSystemResourceNode(void* ResourceManagerPointer,void* ConfigurationDataPointer,long long AdditionalParameter)

{
  long long nextDataIndex;
  long long localSystemHandle;
  long long in_RAX;
  long long localResourceOffset;
  long long bufferBaseAddress;
  long long SystemTimeValue;
  long long *systemDataIndexPtr;
  long long in_R10;
  long long InputStackParameter50;
  
  bufferBaseAddress = SUB168(SEXT816(in_RAX) * SEXT816(AdditionalParameter - in_R10),8);
  bufferBaseAddress = (bufferBaseAddress >> 7) - (bufferBaseAddress >> 0x3f);
  if (bufferBaseAddress == 0) {
    bufferBaseAddress = 1;
  }
  else {
    bufferBaseAddress = bufferBaseAddress * 2;
    if (bufferBaseAddress == 0) {
      localResourceOffset = 0;
      goto LAB_18006ccef;
    }
  }
  localResourceOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,bufferBaseAddress * 0x1a8,(char)systemDataIndexPtr[3]);
  AdditionalParameter = systemDataIndexPtr[1];
  in_R10 = *systemDataIndexPtr;
LAB_18006ccef:
  InitializeSystemMemoryAllocatorWithHashNodes(&stack0x00000050,in_R10,AdditionalParameter,localResourceOffset);
  localSystemHandle = InputStackParameter50;
  FUN_18006cd80(InputStackParameter50);
  nextDataIndex = systemDataIndexPtr[1];
  localSystemPointer = *systemDataIndexPtr;
  if (localSystemPointer != nextDataIndex) {
    do {
      ReleaseSystemResource(localSystemPointer);
      localSystemPointer = localSystemPointer + 0x1a8;
    } while (localSystemPointer != nextDataIndex);
    localSystemPointer = *systemDataIndexPtr;
  }
  if (localSystemPointer != 0) {
      SystemCleanupFunction(localSystemPointer);
  }
  *systemDataIndexPtr = localResourceOffset;
  systemDataIndexPtr[1] = localSystemHandle + 0x1a8;
  systemDataIndexPtr[2] = bufferBaseAddress * 0x1a8 + localResourceOffset;
  return;
}




// 函数: void FUN_18006cd43(void)
/**
 * @brief 系统清理函数
 * 
 * 该函数负责执行系统清理操作，释放资源和重置系统状态。
 * 主要用于系统资源的统一清理。
 * 
 * 原始函数名为FUN_18006cd43，现已重命名为SystemCleanupFunctionB
 */
void SystemCleanupFunctionB(void)

{
    SystemCleanupFunction();
}



// 函数: long long FUN_18006cd80(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 处理系统资源数据
 * 
 * 该函数负责处理系统资源数据，包括数据的配置和管理。
 * 主要用于系统资源的动态处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 处理结果
 * 
 * 原始函数名为FUN_18006cd80，现已重命名为ProcessSystemResourceDataB
 */
long long ProcessSystemResourceDataB(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  void* creationFlags;
  
  creationFlags = 0xfffffffffffffffe;
  InitializeSystemResourceStringTemplate();
  *(void* *)(ResourceManagerPointer + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
  *(void* *)(ResourceManagerPointer + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
  *(void* *)(ResourceManagerPointer + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
  *(void* *)(ResourceManagerPointer + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
  *(void* *)(ResourceManagerPointer + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
  *(uint8_t *)(ResourceManagerPointer + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
  *(void* *)(ResourceManagerPointer + 0x158) = 0;
  *(code **)(ResourceManagerPointer + 0x160) = _guard_check_icall;
  if (ResourceManagerPointer + 0x148 != ConfigurationDataPointer + 0x148) {
    systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x158);
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(ResourceManagerPointer + 0x148,ConfigurationDataPointer + 0x148,1,ConfigurationFlag,creationFlags);
      systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x158);
    }
    *(code **)(ResourceManagerPointer + 0x158) = systemFunctionPointer;
    *(void* *)(ResourceManagerPointer + 0x160) = *(void* *)(ConfigurationDataPointer + 0x160);
  }
  *(void* *)(ResourceManagerPointer + 0x178) = 0;
  *(code **)(ResourceManagerPointer + 0x180) = _guard_check_icall;
  if (ResourceManagerPointer + 0x168 != ConfigurationDataPointer + 0x168) {
    systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x178);
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(ResourceManagerPointer + 0x168,ConfigurationDataPointer + 0x168,1);
      systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x178);
    }
    *(code **)(ResourceManagerPointer + 0x178) = systemFunctionPointer;
    *(void* *)(ResourceManagerPointer + 0x180) = *(void* *)(ConfigurationDataPointer + 0x180);
  }
  *(void* *)(ResourceManagerPointer + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
  *(void* *)(ResourceManagerPointer + 400) = *(void* *)(ConfigurationDataPointer + 400);
  *(void* *)(ResourceManagerPointer + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
  *(void* *)(ResourceManagerPointer + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
  return ResourceManagerPointer;
}




// 函数: void FUN_18006cf00(void* *ResourceManagerPointer)
/**
 * @brief 初始化系统资源指针
 * 
 * 该函数负责初始化系统资源指针，设置资源管理的基本参数。
 * 主要用于系统资源的初始化配置。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006cf00，现已重命名为InitializeResourceManagerPointerB
 */
void InitializeResourceManagerPointerB(void* *ResourceManagerPointer)

{
  int *pointerToInteger1;
  int systemResult;
  ulong long allocationContext;
  ulong long unsignedSystemValue4;
  long long *plocalSystemPointer;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  long long resourceCounter;
  ulong long systemOperationFlags;
  bool isByteValid1;
  
  *ResourceManagerPointer = &SystemResourceTemplateA;
  allocationContext = ResourceManagerPointer[4];
  resourceCounter = 0;
  unsignedSystemValue4 = ResourceManagerPointer[5];
  for (systemOperationFlags = unsignedSystemValue4; systemOperationFlags != allocationContext; systemOperationFlags = systemOperationFlags + 1) {
    if ((systemOperationFlags & 0x1f) == 0) {
      if (resourceCounter != 0) {
        localSystemFlags = ResourceManagerPointer[10];
        LOCK();
        pointerToInteger1 = (int *)(resourceCounter + 0x3530);
        systemResult = *pointerToInteger1;
        *pointerToInteger1 = *pointerToInteger1 + -0x80000000;
        UNLOCK();
        if (systemResult == 0) {
          localMemoryAddress = *(long long *)(localSystemFlags + 0x28);
          do {
            *(long long *)(resourceCounter + 0x3538) = localMemoryAddress;
            *(uint32_t *)(resourceCounter + 0x3530) = 1;
            plocalSystemPointer = (long long *)(localSystemFlags + 0x28);
            LOCK();
            localDataIndex = *plocalSystemPointer;
            isByteValid1 = localMemoryAddress == localDataIndex;
            if (isByteValid1) {
              *plocalSystemPointer = resourceCounter;
              localDataIndex = localMemoryAddress;
            }
            UNLOCK();
            if (isByteValid1) break;
            LOCK();
            pointerToInteger1 = (int *)(resourceCounter + 0x3530);
            systemResult = *pointerToInteger1;
            *pointerToInteger1 = *pointerToInteger1 + 0x7fffffff;
            UNLOCK();
            localMemoryAddress = localDataIndex;
          } while (systemResult == 1);
        }
      }
LAB_18006cfb1:
      plocalSystemPointer = (long long *)ResourceManagerPointer[0xc];
      resourceCounter = *(long long *)
               (*(long long *)
                 (plocalSystemPointer[3] +
                 (((systemOperationFlags & 0xffffffffffffffe0) - **(long long **)(plocalSystemPointer[3] + plocalSystemPointer[1] * 8) >> 5)
                  + plocalSystemPointer[1] & *plocalSystemPointer - 1U) * 8) + 8);
    }
    else if (resourceCounter == 0) goto LAB_18006cfb1;
    ReleaseSystemResource((ulong long)((uint)systemOperationFlags & 0x1f) * 0x1a8 + resourceCounter);
  }
  resourceCounter = ResourceManagerPointer[8];
  if ((resourceCounter != 0) && ((unsignedSystemValue4 != allocationContext || ((allocationContext & 0x1f) != 0)))) {
    localSystemFlags = ResourceManagerPointer[10];
    LOCK();
    pointerToInteger1 = (int *)(resourceCounter + 0x3530);
    systemResult = *pointerToInteger1;
    *pointerToInteger1 = *pointerToInteger1 + -0x80000000;
    UNLOCK();
    if (systemResult == 0) {
      localMemoryAddress = *(long long *)(localSystemFlags + 0x28);
      do {
        *(long long *)(resourceCounter + 0x3538) = localMemoryAddress;
        *(uint32_t *)(resourceCounter + 0x3530) = 1;
        plocalSystemPointer = (long long *)(localSystemFlags + 0x28);
        LOCK();
        localDataIndex = *plocalSystemPointer;
        isByteValid1 = localMemoryAddress == localDataIndex;
        if (isByteValid1) {
          *plocalSystemPointer = resourceCounter;
          localDataIndex = localMemoryAddress;
        }
        UNLOCK();
        if (isByteValid1) break;
        LOCK();
        pointerToInteger1 = (int *)(resourceCounter + 0x3530);
        systemResult = *pointerToInteger1;
        *pointerToInteger1 = *pointerToInteger1 + 0x7fffffff;
        UNLOCK();
        localMemoryAddress = localDataIndex;
      } while (systemResult == 1);
    }
  }
  if (ResourceManagerPointer[0xc] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemResourceTemplateB;
  return;
}




/**
 * @brief 获取线程本地存储条目
 * 
 * 该函数负责获取或创建线程本地存储（TLS）条目，支持多线程环境下的
 * 线程私有数据管理。使用哈希表来存储和检索线程特定的数据。
 * 
 * @param ResourceManagerPointer 资源管理器指针，包含线程本地存储的哈希表
 * @return void** 返回线程本地存储条目指针，失败时返回NULL
 * 
 * 原始函数名为FUN_18006d0b0，现已重命名为GetThreadLocalStorageEntry
 */
void** GetThreadLocalStorageEntry(long long* ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  uint *HashEntryStatus;
  ulong long *HashNodePointer;
  ulong long unsignedSystemValue4;
  uint currentThreadId;
  ulong long hashValue;
  ulong long *HashBucketNode;
  void** SystemNextNode;
  long long resourceCounter;
  long long allocationFlags;
  void* *ThreadLocalStorage;
  ulong long systemStatus2;
  ulong long systemStatus3;
  uint systemStatus4;
  void* *ThreadLocalStorageEntry;
  bool isEntryAvailable;
  bool isSlotEmpty;
  
  currentThreadId = GetCurrentThreadId();
  systemStatus4 = (currentThreadId >> 0x10 ^ currentThreadId) * -0x7a143595;
  systemStatus4 = (systemStatus4 >> 0xd ^ systemStatus4) * -0x3d4d51cb;
  systemStatus3 = (ulong long)(systemStatus4 >> 0x10 ^ systemStatus4);
  HashBucketNode = (ulong long *)ResourceManagerPointer[6];
  for (HashNodePointer = HashBucketNode; hashValue = systemStatus3, HashNodePointer != (ulong long *)0x0; HashNodePointer = (ulong long *)HashNodePointer[2])
  {
    while( true ) {
      hashValue = hashValue & *HashNodePointer - 1;
      systemStatus4 = *(uint *)(hashValue * 0x10 + HashNodePointer[1]);
      if (systemStatus4 == currentThreadId) {
        ThreadLocalStorageEntry = *(void* **)(HashNodePointer[1] + 8 + hashValue * 0x10);
        if (HashNodePointer == HashBucketNode) {
          return ThreadLocalStorageEntry;
        }
        do {
          systemStatus3 = systemStatus3 & *HashBucketNode - 1;
          if (*(int *)(HashBucketNode[1] + systemStatus3 * 0x10) == 0) {
            HashEntryStatus = (uint *)(HashBucketNode[1] + systemStatus3 * 0x10);
            LOCK();
            isSlotEmpty = *HashEntryStatus == 0;
            if (isSlotEmpty) {
              *HashEntryStatus = currentThreadId;
            }
            UNLOCK();
            if (isSlotEmpty) {
              *(void* **)(HashBucketNode[1] + 8 + systemStatus3 * 0x10) = ThreadLocalStorageEntry;
              return ThreadLocalStorageEntry;
            }
          }
          systemStatus3 = systemStatus3 + 1;
        } while( true );
      }
      if (systemStatus4 == 0) break;
      hashValue = hashValue + 1;
    }
  }
  LOCK();
  PrimaryResourcePointer = ResourceManagerPointer + 7;
  resourceCounter = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  hashValue = resourceCounter + 1;
  ThreadLocalStorageEntry = (void* *)0x0;
  while( true ) {
    if (*HashBucketNode >> 1 <= hashValue) {
      LOCK();
      HashEntryStatus = (uint *)(ResourceManagerPointer + 0x4b);
      systemStatus4 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus | 1;
      UNLOCK();
      if ((systemStatus4 & 1) == 0) {
        HashNodePointer = (ulong long *)ResourceManagerPointer[6];
        HashBucketNode = HashNodePointer;
        systemStatus2 = *HashNodePointer;
        if (*HashNodePointer >> 1 <= hashValue) {
          do {
            unsignedSystemValue4 = systemStatus2;
            systemStatus2 = unsignedSystemValue4 * 2;
          } while ((unsignedSystemValue4 & 0x7fffffffffffffff) <= hashValue);
          HashBucketNode = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue4 * 0x20 + 0x1f,10);
          if (HashBucketNode == (ulong long *)0x0) {
            LOCK();
            ResourceManagerPointer[7] = ResourceManagerPointer[7] + -1;
            UNLOCK();
            *(uint32_t *)(ResourceManagerPointer + 0x4b) = 0;
            return (void* *)0x0;
          }
          *HashBucketNode = systemStatus2;
          HashBucketNode[1] = (ulong long)(-(int)(HashBucketNode + 3) & 7) + (long long)(HashBucketNode + 3);
          ThreadLocalStorage = ThreadLocalStorageEntry;
          for (; systemStatus2 != 0; systemStatus2 = systemStatus2 - 1) {
            *(void* *)((long long)ThreadLocalStorage + HashBucketNode[1] + 8) = 0;
            *(uint32_t *)((long long)ThreadLocalStorage + HashBucketNode[1]) = 0;
            ThreadLocalStorage = ThreadLocalStorage + 2;
          }
          HashBucketNode[2] = (ulong long)HashNodePointer;
          ResourceManagerPointer[6] = (long long)HashBucketNode;
        }
        *(uint32_t *)(ResourceManagerPointer + 0x4b) = 0;
      }
    }
    if (hashValue < (*HashBucketNode >> 2) + (*HashBucketNode >> 1)) break;
    HashBucketNode = (ulong long *)ResourceManagerPointer[6];
  }
  ThreadLocalStorage = (void* *)*ResourceManagerPointer;
  while (ThreadLocalStorage != (void* *)0x0) {
    if ((*(char *)(ThreadLocalStorage + 2) != '\0') && (*(char *)(ThreadLocalStorage + 9) == '\0')) {
      isSlotEmpty = true;
      LOCK();
      isEntryAvailable = *(char *)(ThreadLocalStorage + 2) == '\x01';
      if (isEntryAvailable) {
        *(char *)(ThreadLocalStorage + 2) = '\0';
      }
      UNLOCK();
      if (isEntryAvailable) goto LAB_18006d3bb;
    }
    PrimaryResourcePointer = ThreadLocalStorage + 1;
    ThreadLocalStorage = (void* *)(*PrimaryResourcePointer + -8);
    if (*PrimaryResourcePointer == 0) {
      ThreadLocalStorage = ThreadLocalStorageEntry;
    }
  }
  isSlotEmpty = false;
  newThreadLocalStorage = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,10);
  ThreadLocalStorage = ThreadLocalStorageEntry;
  if (newThreadLocalStorage != (void* *)0x0) {
    newThreadLocalStorage[1] = 0;
    *(uint8_t *)(newThreadLocalStorage + 2) = 0;
    newThreadLocalStorage[3] = 0;
    *newThreadLocalStorage = &SystemResourceTemplateB;
    newThreadLocalStorage[4] = 0;
    newThreadLocalStorage[5] = 0;
    newThreadLocalStorage[6] = 0;
    newThreadLocalStorage[7] = 0;
    newThreadLocalStorage[8] = 0;
    *(uint8_t *)(newThreadLocalStorage + 9) = 0;
    newThreadLocalStorage[10] = ResourceManagerPointer;
    *newThreadLocalStorage = &SystemResourceTemplateA;
    newThreadLocalStorage[0xb] = 0x20;
    newThreadLocalStorage[0xc] = 0;
    ExpandSystemResourceAllocator(newThreadLocalStorage);
    LOCK();
    *(int *)(ResourceManagerPointer + 1) = (int)ResourceManagerPointer[1] + 1;
    UNLOCK();
    resourceCounter = *ResourceManagerPointer;
    do {
      ThreadLocalStorage = (void* *)(resourceCounter + 8);
      if (resourceCounter == 0) {
        ThreadLocalStorage = ThreadLocalStorageEntry;
      }
      newThreadLocalStorage[1] = ThreadLocalStorage;
      LOCK();
      allocationFlags = *ResourceManagerPointer;
      isEntryAvailable = resourceCounter == allocationFlags;
      if (isEntryAvailable) {
        *ResourceManagerPointer = (long long)newThreadLocalStorage;
        allocationFlags = resourceCounter;
      }
      UNLOCK();
      resourceCounter = allocationFlags;
      ThreadLocalStorage = newThreadLocalStorage;
    } while (!isEntryAvailable);
  }
LAB_18006d3bb:
  if (ThreadLocalStorage == (void* *)0x0) {
    LOCK();
    ResourceManagerPointer[7] = ResourceManagerPointer[7] + -1;
    UNLOCK();
    return (void* *)0x0;
  }
  if (isSlotEmpty) {
    LOCK();
    ResourceManagerPointer[7] = ResourceManagerPointer[7] + -1;
    UNLOCK();
  }
  do {
    systemStatus3 = systemStatus3 & *HashBucketNode - 1;
    if (*(int *)(HashBucketNode[1] + systemStatus3 * 0x10) == 0) {
      HashEntryStatus = (uint *)(HashBucketNode[1] + systemStatus3 * 0x10);
      LOCK();
      isSlotEmpty = *HashEntryStatus == 0;
      if (isSlotEmpty) {
        *HashEntryStatus = currentThreadId;
      }
      UNLOCK();
      if (isSlotEmpty) {
        *(void* **)(HashBucketNode[1] + 8 + systemStatus3 * 0x10) = ThreadLocalStorage;
        return ThreadLocalStorage;
      }
    }
    systemStatus3 = systemStatus3 + 1;
  } while( true );
}



/**
 * @brief 系统资源管理器清理函数
 * 
 * 该函数清理系统资源管理器，初始化资源管理器指针，并根据配置标志
 * 决定是否释放资源管理器内存。用于系统资源管理的清理和回收。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针（包含清理标志）
 * @return 清理后的资源管理器指针
 * 
 * 原始函数名为FUN_18006d450，现已重命名为CleanupResourceManagerPointer
 */
void* CleanupResourceManagerPointer(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  FUN_18006cf00();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x68);
  }
  return ResourceManagerPointer;
}



void* GetSystemDataResourcePointer(ulong long* ResourceManagerPointer, void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *HashEntryStatus;
  long long localResourceOffset;
  long long bufferBaseAddress;
  char operationStatusFlag;
  ulong long hashValue;
  ulong long unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  ulong long systemOperationFlags;
  ulong long systemStatus1;
  ulong long systemStatus2;
  ulong long systemStatus3;
  
  systemStatus3 = 0;
  unsignedSystemValue7 = *ResourceManagerPointer;
  unsignedSystemValue8 = systemStatus3;
  systemOperationFlags = systemStatus3;
  systemStatus2 = systemStatus3;
  do {
    unsignedSystemValue9 = unsignedSystemValue8;
    systemStatus1 = systemOperationFlags;
    if (unsignedSystemValue7 == 0) break;
    hashValue = *(long long *)(unsignedSystemValue7 + 0x20) - *(long long *)(unsignedSystemValue7 + 0x28);
    if ((ulong long)(*(long long *)(unsignedSystemValue7 + 0x28) - *(long long *)(unsignedSystemValue7 + 0x20)) < 0x8000000000000001)
    {
      hashValue = systemStatus3;
    }
    if ((hashValue != 0) && (systemStatus2 = systemStatus2 + 1, unsignedSystemValue9 = unsignedSystemValue7, systemStatus1 = hashValue, hashValue <= systemOperationFlags)) {
      unsignedSystemValue9 = unsignedSystemValue8;
      systemStatus1 = systemOperationFlags;
    }
    PrimaryResourcePointer = (long long *)(unsignedSystemValue7 + 8);
    unsignedSystemValue7 = *PrimaryResourcePointer - 8;
    if (*PrimaryResourcePointer == 0) {
      unsignedSystemValue7 = systemStatus3;
    }
    unsignedSystemValue8 = unsignedSystemValue9;
    systemOperationFlags = systemStatus1;
  } while (systemStatus2 < 3);
  if (systemStatus2 != 0) {
    charValue = FUN_18006d810(unsignedSystemValue9,ConfigurationDataPointer,unsignedSystemValue7,systemStatus1,0xfffffffffffffffe);
    if (charValue != '\0') {
      return 1;
    }
    unsignedSystemValue7 = *ResourceManagerPointer;
    while (unsignedSystemValue7 != 0) {
      if (unsignedSystemValue7 != unsignedSystemValue9) {
        if (*(char *)(unsignedSystemValue7 + 0x48) == '\0') {
          charValue = FUN_18006da90(unsignedSystemValue7,ConfigurationDataPointer);
        }
        else {
          if (0x8000000000000000 <
              (ulong long)
              ((*(long long *)(unsignedSystemValue7 + 0x30) - *(long long *)(unsignedSystemValue7 + 0x38)) -
              *(long long *)(unsignedSystemValue7 + 0x20))) {
            LOCK();
            PrimaryResourcePointer = (long long *)(unsignedSystemValue7 + 0x30);
            localResourceOffset = *PrimaryResourcePointer;
            *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
            UNLOCK();
            if (0x8000000000000000 <
                (ulong long)((localResourceOffset - *(long long *)(unsignedSystemValue7 + 0x20)) - *(long long *)(unsignedSystemValue7 + 0x38))) {
              LOCK();
              HashEntryStatus = (ulong long *)(unsignedSystemValue7 + 0x28);
              unsignedSystemValue8 = *HashEntryStatus;
              *HashEntryStatus = *HashEntryStatus + 1;
              UNLOCK();
              PrimaryResourcePointer = *(long long **)(unsignedSystemValue7 + 0x58);
              bufferBaseAddress = *(long long *)
                       (PrimaryResourcePointer[2] + 8 +
                       (((unsignedSystemValue8 & 0xffffffffffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10)
                        >> 5) + PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
              unsignedSystemValue8 = (ulong long)((uint)unsignedSystemValue8 & 0x1f);
              localResourceOffset = unsignedSystemValue8 * 0x1a8 + bufferBaseAddress;
              ConfigureResourceManagerData(ConfigurationDataPointer,localResourceOffset);
              ReleaseSystemResource(localResourceOffset);
              *(uint8_t *)((bufferBaseAddress - unsignedSystemValue8) + 0x352f) = 1;
              charValue = '\x01';
              goto LAB_18006d67d;
            }
            LOCK();
            *(long long *)(unsignedSystemValue7 + 0x38) = *(long long *)(unsignedSystemValue7 + 0x38) + 1;
            UNLOCK();
          }
          charValue = '\0';
        }
LAB_18006d67d:
        if (charValue != '\0') {
          return 1;
        }
      }
      PrimaryResourcePointer = (long long *)(unsignedSystemValue7 + 8);
      unsignedSystemValue7 = *PrimaryResourcePointer - 8;
      if (*PrimaryResourcePointer == 0) {
        unsignedSystemValue7 = systemStatus3;
      }
    }
  }
  return 0;
}



void* FUN_18006d6c0(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ulong long systemStatus;
  long long *resourcePoolPointer;
  char characterProcessingFlag;
  ulong long unsignedSystemValue4;
  ulong long *pcurrentThreadId;
  void* hashValue;
  
  hashValue = 0xfffffffffffffffe;
  systemStatus = *(ulong long *)(ResourceManagerPointer + 0x20);
  if ((systemStatus & 0x1f) != 0) {
    FUN_18006cd80((ulong long)((uint)systemStatus & 0x1f) * 0x1a8 + *(long long *)(ResourceManagerPointer + 0x40));
LAB_18006d7fb:
    *(ulong long *)(ResourceManagerPointer + 0x20) = systemStatus + 1;
    return 1;
  }
  if ((0x8000000000000000 < (*(long long *)(ResourceManagerPointer + 0x28) - systemStatus) - 0x20) &&
     (resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x60), resourcePoolPointer != (long long *)0x0)) {
    unsignedSystemValue4 = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
    pcurrentThreadId = *(ulong long **)(resourcePoolPointer[3] + unsignedSystemValue4 * 8);
    if ((*pcurrentThreadId == 1) || (pcurrentThreadId[1] == 0)) {
      *pcurrentThreadId = systemStatus;
      resourcePoolPointer[1] = unsignedSystemValue4;
    }
    else {
      charFlag = GetSystemResourceStatus(ResourceManagerPointer);
      if (characterProcessingFlag == '\0') {
        return 0;
      }
      resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x60);
      unsignedSystemValue4 = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
      pcurrentThreadId = *(ulong long **)(resourcePoolPointer[3] + unsignedSystemValue4 * 8);
      *pcurrentThreadId = systemStatus;
      resourcePoolPointer[1] = unsignedSystemValue4;
    }
    unsignedSystemValue4 = FUN_18006d920(*(void* *)(ResourceManagerPointer + 0x50));
    if (unsignedSystemValue4 != 0) {
      *(void* *)(unsignedSystemValue4 + 0x3508) = 0;
      FUN_18006cd80(unsignedSystemValue4,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,hashValue);
      pcurrentThreadId[1] = unsignedSystemValue4;
      *(ulong long *)(ResourceManagerPointer + 0x40) = unsignedSystemValue4;
      goto LAB_18006d7fb;
    }
    resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x60);
    resourcePoolPointer[1] = *resourcePoolPointer - 1U & resourcePoolPointer[1] - 1U;
    pcurrentThreadId[1] = 0;
  }
  return 0;
}



void* FUN_18006d810(long long ResourceManagerPointer,void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *HashEntryStatus;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  void* unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  
  if (*(char *)(ResourceManagerPointer + 0x48) == '\0') {
    unsignedSystemValue7 = FUN_18006da90();
  }
  else {
    if (0x8000000000000000 <
        (ulong long)
        ((*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x38)) -
        *(long long *)(ResourceManagerPointer + 0x20))) {
      LOCK();
      PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x30);
      localResourceOffset = *PrimaryResourcePointer;
      *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
      UNLOCK();
      if (0x8000000000000000 <
          (ulong long)((localResourceOffset - *(long long *)(ResourceManagerPointer + 0x20)) - *(long long *)(ResourceManagerPointer + 0x38))) {
        LOCK();
        HashEntryStatus = (ulong long *)(ResourceManagerPointer + 0x28);
        unsignedSystemValue4 = *HashEntryStatus;
        *HashEntryStatus = *HashEntryStatus + 1;
        UNLOCK();
        PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x58);
        localSystemPointer = PrimaryResourcePointer[2];
        localSystemFlags = *(long long *)
                 (localSystemPointer + 8 +
                 (((unsignedSystemValue4 & 0xffffffffffffffe0) - *(long long *)(localSystemPointer + PrimaryResourcePointer[1] * 0x10) >> 5) +
                  PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
        unsignedSystemValue8 = (ulong long)((uint)unsignedSystemValue4 & 0x1f);
        localResourceOffset = unsignedSystemValue8 * 0x1a8 + localSystemFlags;
        FUN_18006dcb0(ConfigurationDataPointer,localResourceOffset,PrimaryResourcePointer,localSystemPointer,0xfffffffffffffffe,localSystemFlags,unsignedSystemValue4);
        ReleaseSystemResource(localResourceOffset);
        *(uint8_t *)((localSystemFlags - unsignedSystemValue8) + 0x352f) = 1;
        return 1;
      }
      LOCK();
      *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + 1;
      UNLOCK();
    }
    unsignedSystemValue7 = 0;
  }
  return unsignedSystemValue7;
}




/**
 * @brief 系统资源指针计算和查找函数
 * 
 * 该函数负责计算和查找系统资源指针，包括资源地址计算、
 * 锁定操作和偏移量处理。用于系统资源的动态管理和访问。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @return 计算结果或资源地址
 * 
 * 原始函数名为FUN_18006d920，现已重命名为CalculateAndFindResourceManagerPointer
 */
long long CalculateAndFindResourceManagerPointer(long long ResourceManagerPointer)

{
  ulong long *pointerToUnsigned1;
  uint *HashEntryStatus;
  uint allocationContext;
  ulong long unsignedSystemValue4;
  uint currentThreadId;
  long long localSystemFlags;
  long long localDataIndex;
  long long localMemoryAddress;
  long long resourceCounter;
  bool isByteValid0;
  
  if (*(ulong long *)(ResourceManagerPointer + 0x10) < *(ulong long *)(ResourceManagerPointer + 0x20)) {
    LOCK();
    pointerToUnsigned1 = (ulong long *)(ResourceManagerPointer + 0x10);
    unsignedSystemValue4 = *pointerToUnsigned1;
    *pointerToUnsigned1 = *pointerToUnsigned1 + 1;
    UNLOCK();
    if ((unsignedSystemValue4 < *(ulong long *)(ResourceManagerPointer + 0x20)) &&
       (localSystemFlags = unsignedSystemValue4 * 0x3548 + *(long long *)(ResourceManagerPointer + 0x18), localSystemFlags != 0)) {
      return localSystemFlags;
    }
  }
  localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28);
LAB_18006d957:
  do {
    resourceCounter = localSystemFlags;
    if (resourceCounter == 0) {
LAB_18006d9f6:
      localSystemFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x3548,10);
      if (localSystemFlags == 0) {
        return 0;
      }
      *(void* *)(localSystemFlags + 0x3500) = 0;
      *(void* *)(localSystemFlags + 0x3508) = 0;
      *(uint32_t *)(localSystemFlags + 0x3530) = 0;
      *(void* *)(localSystemFlags + 0x3538) = 0;
      *(void*2 *)(localSystemFlags + 0x3540) = 0x100;
      return localSystemFlags;
    }
    HashEntryStatus = (uint *)(resourceCounter + 0x3530);
    currentThreadId = *HashEntryStatus;
    if ((currentThreadId & 0x7fffffff) == 0) {
LAB_18006d9d7:
      localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28);
      goto LAB_18006d957;
    }
    LOCK();
    allocationContext = *HashEntryStatus;
    if (currentThreadId == allocationContext) {
      *HashEntryStatus = currentThreadId + 1;
    }
    UNLOCK();
    if (currentThreadId != allocationContext) goto LAB_18006d9d7;
    LOCK();
    localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28);
    isByteValid0 = resourceCounter == localSystemFlags;
    if (isByteValid0) {
      *(long long *)(ResourceManagerPointer + 0x28) = *(long long *)(resourceCounter + 0x3538);
      localSystemFlags = resourceCounter;
    }
    UNLOCK();
    if (isByteValid0) {
      LOCK();
      *HashEntryStatus = *HashEntryStatus - 2;
      UNLOCK();
      if (resourceCounter != 0) {
        return resourceCounter;
      }
      goto LAB_18006d9f6;
    }
    LOCK();
    currentThreadId = *HashEntryStatus;
    *HashEntryStatus = *HashEntryStatus - 1;
    UNLOCK();
    if (currentThreadId == 0x80000001) {
      localMemoryAddress = *(long long *)(ResourceManagerPointer + 0x28);
      do {
        *(long long *)(resourceCounter + 0x3538) = localMemoryAddress;
        *HashEntryStatus = 1;
        LOCK();
        localDataIndex = *(long long *)(ResourceManagerPointer + 0x28);
        isByteValid0 = localMemoryAddress == localDataIndex;
        if (isByteValid0) {
          *(long long *)(ResourceManagerPointer + 0x28) = resourceCounter;
          localDataIndex = localMemoryAddress;
        }
        UNLOCK();
        if (isByteValid0) break;
        LOCK();
        currentThreadId = *HashEntryStatus;
        *HashEntryStatus = *HashEntryStatus + 0x7fffffff;
        UNLOCK();
        localMemoryAddress = localDataIndex;
      } while (currentThreadId == 1);
    }
  } while( true );
}




// 函数: void FUN_18006da50(long long *ResourceManagerPointer)
/**
 * @brief 处理系统资源数据
 * 
 * 该函数负责处理系统资源数据，包括数据的配置和管理。
 * 主要用于系统资源的动态处理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006da50，现已重命名为ProcessSystemResourceDataC
 */
void ProcessSystemResourceDataC(long long *ResourceManagerPointer)

{
  ReleaseSystemResource((ulong long)(*(uint *)(ResourceManagerPointer + 1) & 0x1f) * 0x1a8 + *ResourceManagerPointer);
  *(uint8_t *)((*ResourceManagerPointer - (ulong long)(*(uint *)(ResourceManagerPointer + 1) & 0x1f)) + 0x352f) = 1;
  return;
}



/**
 * @brief 获取系统资源哈希值
 * 
 * 该函数负责从资源管理器中获取资源的哈希值
 * 用于资源查找和索引操作
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return ulong long 返回资源的哈希值
 * 
 * 原始函数名为FUN_18006da90，现已重命名为GetSystemResourceHash
 */
ulong long GetSystemResourceHash(long long ResourceManagerPointer,void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *HashEntryStatus;
  uint *HashNodePointer;
  uint unsignedSystemValue4;
  long long SystemTimeValue;
  ulong long hashValue;
  long long localDataIndex;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  long long allocationFlags;
  ulong long systemStatus1;
  bool isByteValid2;
  
  unsignedSystemValue8 = (*(long long *)(ResourceManagerPointer + 0x30) - *(long long *)(ResourceManagerPointer + 0x38)) -
          *(long long *)(ResourceManagerPointer + 0x20);
  if (0x8000000000000000 < unsignedSystemValue8) {
    LOCK();
    PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x30);
    localSystemPointer = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    unsignedSystemValue8 = *(ulong long *)(ResourceManagerPointer + 0x20);
    if (0x8000000000000000 < (localSystemPointer - unsignedSystemValue8) - *(long long *)(ResourceManagerPointer + 0x38)) {
      LOCK();
      HashEntryStatus = (ulong long *)(ResourceManagerPointer + 0x28);
      unsignedSystemValue8 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x60);
      systemStatus1 = (unsignedSystemValue8 & 0xffffffffffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5;
      localSystemPointer = *(long long *)(PrimaryResourcePointer[3] + (PrimaryResourcePointer[1] + systemStatus1 & *PrimaryResourcePointer - 1U) * 8);
      hashValue = *(ulong long *)(localSystemPointer + 8);
      allocationFlags = (ulong long)((uint)unsignedSystemValue8 & 0x1f) * 0x1a8 + hashValue;
      localDataIndex = *(long long *)(ResourceManagerPointer + 0x50);
      ConfigureResourceManagerData(ConfigurationDataPointer,allocationFlags,systemStatus1,PrimaryResourcePointer,0xfffffffffffffffe,hashValue,unsignedSystemValue8,localSystemPointer);
      ReleaseSystemResource(allocationFlags);
      LOCK();
      HashEntryStatus = (ulong long *)(hashValue + 0x3508);
      unsignedSystemValue8 = *HashEntryStatus;
      *HashEntryStatus = *HashEntryStatus + 1;
      UNLOCK();
      if (unsignedSystemValue8 == 0x1f) {
        *(void* *)(localSystemPointer + 8) = 0;
        LOCK();
        HashNodePointer = (uint *)(hashValue + 0x3530);
        unsignedSystemValue4 = *HashNodePointer;
        *HashNodePointer = *HashNodePointer + 0x80000000;
        UNLOCK();
        unsignedSystemValue8 = (ulong long)unsignedSystemValue4;
        if (unsignedSystemValue4 == 0) {
          systemStatus1 = *(ulong long *)(localDataIndex + 0x28);
          do {
            *(ulong long *)(hashValue + 0x3538) = systemStatus1;
            *(uint32_t *)(hashValue + 0x3530) = 1;
            HashEntryStatus = (ulong long *)(localDataIndex + 0x28);
            LOCK();
            unsignedSystemValue9 = *HashEntryStatus;
            isByteValid2 = systemStatus1 == unsignedSystemValue9;
            if (isByteValid2) {
              *HashEntryStatus = hashValue;
              unsignedSystemValue9 = systemStatus1;
            }
            UNLOCK();
            unsignedSystemValue8 = unsignedSystemValue9;
            if (isByteValid2) break;
            LOCK();
            HashNodePointer = (uint *)(hashValue + 0x3530);
            unsignedSystemValue4 = *HashNodePointer;
            unsignedSystemValue8 = (ulong long)unsignedSystemValue4;
            *HashNodePointer = *HashNodePointer + 0x7fffffff;
            UNLOCK();
            systemStatus1 = unsignedSystemValue9;
          } while (unsignedSystemValue4 == 1);
        }
      }
      return CONCAT71((int7)(unsignedSystemValue8 >> 8),1);
    }
    LOCK();
    *(long long *)(ResourceManagerPointer + 0x38) = *(long long *)(ResourceManagerPointer + 0x38) + 1;
    UNLOCK();
  }
  return unsignedSystemValue8 & 0xffffffffffffff00;
}




// 函数: void FUN_18006dc10(long long *ResourceManagerPointer)
/**
 * @brief 清理系统资源数据
 * 
 * 该函数负责清理系统资源数据，释放资源并重置状态。
 * 主要用于系统资源的清理和内存回收。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18006dc10，现已重命名为CleanupSystemResourceDataB
 */
void CleanupSystemResourceDataB(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  int MemoryComparisonResult;
  long long bufferBaseAddress;
  long long SystemTimeValue;
  long long localSystemFlags;
  long long localDataIndex;
  bool isConfigValid;
  
  ReleaseSystemResource((ulong long)(*(uint *)(ResourceManagerPointer + 1) & 0x1f) * 0x1a8 + *ResourceManagerPointer);
  LOCK();
  PrimaryResourcePointer = (long long *)(*ResourceManagerPointer + 0x3508);
  bufferBaseAddress = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  if (bufferBaseAddress == 0x1f) {
    *(void* *)(ResourceManagerPointer[2] + 8) = 0;
    bufferBaseAddress = *ResourceManagerPointer;
    localSystemPointer = ResourceManagerPointer[3];
    LOCK();
    pointerToInteger2 = (int *)(bufferBaseAddress + 0x3530);
    systemCounter = *pointerToInteger2;
    *pointerToInteger2 = *pointerToInteger2 + -0x80000000;
    UNLOCK();
    if (systemCounter == 0) {
      localDataIndex = *(long long *)(localSystemPointer + 0x28);
      do {
        *(long long *)(bufferBaseAddress + 0x3538) = localDataIndex;
        *(uint32_t *)(bufferBaseAddress + 0x3530) = 1;
        PrimaryResourcePointer = (long long *)(localSystemPointer + 0x28);
        LOCK();
        localSystemFlags = *PrimaryResourcePointer;
        isConfigValid = localDataIndex == localSystemFlags;
        if (isConfigValid) {
          *PrimaryResourcePointer = bufferBaseAddress;
          localSystemFlags = localDataIndex;
        }
        UNLOCK();
        if (isConfigValid) {
          return;
        }
        LOCK();
        pointerToInteger2 = (int *)(bufferBaseAddress + 0x3530);
        systemCounter = *pointerToInteger2;
        *pointerToInteger2 = *pointerToInteger2 + 0x7fffffff;
        UNLOCK();
        localDataIndex = localSystemFlags;
      } while (systemCounter == 1);
    }
  }
  return;
}



/**
 * @brief 配置资源管理器数据函数
 * 
 * 该函数负责配置资源管理器的数据结构和参数，包括字符串模板、
 * 哈希条目状态、数据索引和各种配置参数的设置。用于系统资源管理的数据初始化。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置结果状态码
 * 
 * 原始函数名为FUN_18006dcb0，现已重命名为ConfigureResourceManagerData
 */
long long ConfigureResourceManagerData(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  void* *HashEntryStatus;
  
  *(uint32_t *)(ResourceManagerPointer + 0x10) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  HashEntryStatus = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    HashEntryStatus = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(*(void* *)(ResourceManagerPointer + 8),0x100,HashEntryStatus);
  *(void* *)(ResourceManagerPointer + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
  nextDataIndex = ResourceManagerPointer + 0x148;
  *(void* *)(ResourceManagerPointer + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
  *(void* *)(ResourceManagerPointer + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
  *(void* *)(ResourceManagerPointer + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
  *(void* *)(ResourceManagerPointer + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
  *(uint8_t *)(ResourceManagerPointer + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
  if (nextDataIndex != ConfigurationDataPointer + 0x148) {
    if (*(code **)(ResourceManagerPointer + 0x158) != (code *)0x0) {
      (**(code **)(ResourceManagerPointer + 0x158))(nextDataIndex,0,0);
    }
    FUN_180069130(nextDataIndex,ConfigurationDataPointer + 0x148);
  }
  nextDataIndex = ResourceManagerPointer + 0x168;
  if (nextDataIndex != ConfigurationDataPointer + 0x168) {
    if (*(code **)(ResourceManagerPointer + 0x178) != (code *)0x0) {
      (**(code **)(ResourceManagerPointer + 0x178))(nextDataIndex,0,0);
    }
    FUN_180069130(nextDataIndex,ConfigurationDataPointer + 0x168);
  }
  *(void* *)(ResourceManagerPointer + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
  *(void* *)(ResourceManagerPointer + 400) = *(void* *)(ConfigurationDataPointer + 400);
  *(void* *)(ResourceManagerPointer + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
  *(void* *)(ResourceManagerPointer + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
  return ResourceManagerPointer;
}



/**
 * @brief 使用哈希节点初始化系统内存分配器
 * 
 * 该函数负责使用哈希节点初始化系统内存分配器，包括内存分配、
 * 哈希节点设置和字符串处理。主要用于系统内存管理的基础操作。
 * 
 * @param ResourceManagerPointer 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @param ConfigurationFlag 配置标志，用于控制初始化行为
 * @return 返回初始化后的资源管理器指针
 * 
 * 原始函数名为FUN_18006de00，现已重命名为InitializeSystemMemoryAllocatorWithHashNodes
 */
long long *
InitializeSystemMemoryAllocatorWithHashNodes(long long *ResourceManagerPointer,void* *ConfigurationDataPointer,void* *AdditionalParameter,void* *ConfigurationFlag)

{
  void* *pointerToUnsigned1;
  code *stringProcessingPointer;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  
  *ResourceManagerPointer = (long long)ConfigurationFlag;
  if (ConfigurationDataPointer != AdditionalParameter) {
    HashNodePointer = ConfigurationDataPointer + 0x2b;
    do {
      *ConfigurationFlag = &SystemMemoryAllocatorReference;
      ConfigurationFlag[1] = 0;
      *(uint32_t *)(ConfigurationFlag + 2) = 0;
      *ConfigurationFlag = &SystemMemoryAllocatorTemplate;
      ConfigurationFlag[1] = ConfigurationFlag + 3;
      *(uint32_t *)(ConfigurationFlag + 2) = 0;
      *(uint8_t *)(ConfigurationFlag + 3) = 0;
      *(uint32_t *)(ConfigurationFlag + 2) = *(uint32_t *)(HashNodePointer + -0x29);
      punsignedSystemValue4 = &SystemStringTemplate;
      if ((void* *)HashNodePointer[-0x2a] != (void* *)0x0) {
        punsignedSystemValue4 = (void* *)HashNodePointer[-0x2a];
      }
      strcpy_s(ConfigurationFlag[1],0x100,punsignedSystemValue4);
      ConfigurationFlag[0x23] = HashNodePointer[-8];
      ConfigurationFlag[0x24] = HashNodePointer[-7];
      ConfigurationFlag[0x25] = HashNodePointer[-6];
      ConfigurationFlag[0x26] = HashNodePointer[-5];
      ConfigurationFlag[0x27] = HashNodePointer[-4];
      *(uint8_t *)(ConfigurationFlag + 0x28) = *(uint8_t *)(HashNodePointer + -3);
      ConfigurationFlag[0x2b] = 0;
      ConfigurationFlag[0x2c] = _guard_check_icall;
      if (ConfigurationFlag + 0x29 != HashNodePointer + -2) {
        pcharResult = (code *)*HashNodePointer;
        if (stringProcessingPointer != (code *)0x0) {
          (*pcharResult)(ConfigurationFlag + 0x29,HashNodePointer + -2,2);
          pcharResult = (code *)*HashNodePointer;
        }
        ConfigurationFlag[0x2b] = pcharResult;
        ConfigurationFlag[0x2c] = HashNodePointer[1];
        *HashNodePointer = 0;
        HashNodePointer[1] = _guard_check_icall;
      }
      ConfigurationFlag[0x2f] = 0;
      ConfigurationFlag[0x30] = _guard_check_icall;
      if (ConfigurationFlag + 0x2d != HashNodePointer + 2) {
        pcharResult = (code *)HashNodePointer[4];
        if (stringProcessingPointer != (code *)0x0) {
          (*pcharResult)(ConfigurationFlag + 0x2d,HashNodePointer + 2,2);
          pcharResult = (code *)HashNodePointer[4];
        }
        ConfigurationFlag[0x2f] = pcharResult;
        ConfigurationFlag[0x30] = HashNodePointer[5];
        HashNodePointer[4] = 0;
        HashNodePointer[5] = _guard_check_icall;
      }
      ConfigurationFlag[0x31] = HashNodePointer[6];
      ConfigurationFlag[0x32] = HashNodePointer[7];
      ConfigurationFlag[0x33] = HashNodePointer[8];
      ConfigurationFlag[0x34] = HashNodePointer[9];
      *ResourceManagerPointer = *ResourceManagerPointer + 0x1a8;
      ConfigurationFlag = (void* *)*ResourceManagerPointer;
      pointerToUnsigned1 = HashNodePointer + 10;
      HashNodePointer = HashNodePointer + 0x35;
    } while (pointerToUnsigned1 != AdditionalParameter);
  }
  return ResourceManagerPointer;
}



/**
 * @brief 创建系统资源池
 * 
 * 该函数负责创建系统资源池，分配内存并初始化资源池结构
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return long long* 返回创建的资源池指针
 * 
 * 原始函数名为FUN_18006e000，现已重命名为CreateSystemResourcePool
 */
long long * CreateSystemResourcePool(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  long long *resourcePoolPointer;
  long long *plocalResourceOffset;
  ulong long unsignedSystemValue4;
  long long *plocalSystemPointer;
  
  plocalSystemPointer = *(long long **)(ResourceManagerPointer + 0x318);
  unsignedSystemValue4 = ConfigurationDataPointer + 0xfU & 0xfffffffffffffff0;
  plocalResourceOffset = (long long *)0x0;
  resourcePoolPointer = (long long *)plocalSystemPointer[3];
  if (resourcePoolPointer != (long long *)0x0) {
    do {
      if ((((char)resourcePoolPointer[4] == '\0') && (unsignedSystemValue4 <= (ulong long)resourcePoolPointer[1])) &&
         ((plocalResourceOffset == (long long *)0x0 || ((ulong long)resourcePoolPointer[1] < (ulong long)plocalResourceOffset[1])))) {
        plocalResourceOffset = resourcePoolPointer;
      }
      resourcePoolPointer = (long long *)resourcePoolPointer[2];
    } while (resourcePoolPointer != (long long *)0x0);
    if (plocalResourceOffset != (long long *)0x0) {
      if (unsignedSystemValue4 < (ulong long)plocalResourceOffset[1]) {
        resourcePoolPointer = (long long *)CreateResourcePoolPointer(plocalSystemPointer + 4);
        *(uint8_t *)(resourcePoolPointer + 4) = 0;
        *resourcePoolPointer = *plocalResourceOffset + unsignedSystemValue4;
        resourcePoolPointer[1] = plocalResourceOffset[1] - unsignedSystemValue4;
        nextDataIndex = plocalResourceOffset[2];
        resourcePoolPointer[2] = nextDataIndex;
        if (nextDataIndex != 0) {
          *(long long **)(nextDataIndex + 0x18) = resourcePoolPointer;
        }
        plocalResourceOffset[2] = (long long)resourcePoolPointer;
        resourcePoolPointer[3] = (long long)plocalResourceOffset;
        plocalResourceOffset[1] = unsignedSystemValue4;
      }
      *(uint8_t *)(plocalResourceOffset + 4) = 1;
      *plocalSystemPointer = *plocalSystemPointer + unsignedSystemValue4;
      plocalSystemPointer[2] = plocalSystemPointer[2] - unsignedSystemValue4;
      return plocalResourceOffset;
    }
  }
  return (long long *)0x0;
}



/**
 * @brief 清理资源管理器函数
 * 
 * 该函数负责清理资源管理器的所有资源，包括销毁互斥锁、条件变量、
 * 释放系统资源和根据配置标志决定是否释放内存。用于系统资源的清理和回收。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针（包含清理标志）
 * @return 清理后的资源管理器指针
 * 
 * 原始函数名为FUN_18006e0b0，现已重命名为CleanupResourceManager
 */
long long CleanupResourceManager(long long ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  CleanupSystemResourceArray();
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  CleanupResourceManagerPointers(ResourceManagerPointer + 200);
  ReleaseSystemResources(ResourceManagerPointer);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x408);
  }
  return ResourceManagerPointer;
}





/**
 * @brief 初始化系统线程对象函数
 * 
 * 该函数负责创建和初始化系统线程对象，设置线程对象的各个字段和参数，
 * 包括内存指针、计数器、缓冲区大小等。用于系统线程管理的前期准备工作。
 * 
 * @return 初始化结果指针，失败时返回0
 * 
 * 原始函数名为FUN_18006e140，现已重命名为InitializeSystemThreadObject
 */
void* InitializeSystemThreadObject(void)

{
  long long nextDataIndex;
  
  nextDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x45ee8,10);
  if (nextDataIndex == 0) {
    return;
  }
  *(void* *)(nextDataIndex + 0x3500) = 0;
  *(void* *)(nextDataIndex + 0x3508) = 0;
  *(uint32_t *)(nextDataIndex + 0x3530) = 0;
  *(void* *)(nextDataIndex + 0x3538) = 0;
  *(void*2 *)(nextDataIndex + 0x3540) = 0x100;
  *(void* *)(nextDataIndex + 0x6a48) = 0;
  *(void* *)(nextDataIndex + 0x6a50) = 0;
  *(uint32_t *)(nextDataIndex + 0x6a78) = 0;
  *(void* *)(nextDataIndex + 0x6a80) = 0;
  *(void*2 *)(nextDataIndex + 0x6a88) = 0x100;
  *(void* *)(nextDataIndex + 0x9f90) = 0;
  *(void* *)(nextDataIndex + 0x9f98) = 0;
  *(uint32_t *)(nextDataIndex + 0x9fc0) = 0;
  *(void* *)(nextDataIndex + 0x9fc8) = 0;
  *(void*2 *)(nextDataIndex + 0x9fd0) = 0x100;
  *(void* *)(nextDataIndex + 0xd4d8) = 0;
  *(void* *)(nextDataIndex + 0xd4e0) = 0;
  *(uint32_t *)(nextDataIndex + 0xd508) = 0;
  *(void* *)(nextDataIndex + 0xd510) = 0;
  *(void*2 *)(nextDataIndex + 0xd518) = 0x100;
  *(void* *)(nextDataIndex + 0x10a20) = 0;
  *(void* *)(nextDataIndex + 0x10a28) = 0;
  *(uint32_t *)(nextDataIndex + 0x10a50) = 0;
  *(void* *)(nextDataIndex + 0x10a58) = 0;
  *(void*2 *)(nextDataIndex + 0x10a60) = 0x100;
  *(void* *)(nextDataIndex + 0x13f68) = 0;
  *(void* *)(nextDataIndex + 0x13f70) = 0;
  *(uint32_t *)(nextDataIndex + 0x13f98) = 0;
  *(void* *)(nextDataIndex + 0x13fa0) = 0;
  *(void*2 *)(nextDataIndex + 0x13fa8) = 0x100;
  *(void* *)(nextDataIndex + 0x174b0) = 0;
  *(void* *)(nextDataIndex + 0x174b8) = 0;
  *(uint32_t *)(nextDataIndex + 0x174e0) = 0;
  *(void* *)(nextDataIndex + 0x174e8) = 0;
  *(void*2 *)(nextDataIndex + 0x174f0) = 0x100;
  *(void* *)(nextDataIndex + 0x1a9f8) = 0;
  *(void* *)(nextDataIndex + 0x1aa00) = 0;
  *(uint32_t *)(nextDataIndex + 0x1aa28) = 0;
  *(void* *)(nextDataIndex + 0x1aa30) = 0;
  *(void*2 *)(nextDataIndex + 0x1aa38) = 0x100;
  *(void* *)(nextDataIndex + 0x1df40) = 0;
  *(void* *)(nextDataIndex + 0x1df48) = 0;
  *(uint32_t *)(nextDataIndex + 0x1df70) = 0;
  *(void* *)(nextDataIndex + 0x1df78) = 0;
  *(void*2 *)(nextDataIndex + 0x1df80) = 0x100;
  *(void* *)(nextDataIndex + 0x21488) = 0;
  *(void* *)(nextDataIndex + 0x21490) = 0;
  *(uint32_t *)(nextDataIndex + 0x214b8) = 0;
  *(void* *)(nextDataIndex + 0x214c0) = 0;
  *(void*2 *)(nextDataIndex + 0x214c8) = 0x100;
  *(void* *)(nextDataIndex + 0x249d0) = 0;
  *(void* *)(nextDataIndex + 0x249d8) = 0;
  *(uint32_t *)(nextDataIndex + 0x24a00) = 0;
  *(void* *)(nextDataIndex + 0x24a08) = 0;
  *(void*2 *)(nextDataIndex + 0x24a10) = 0x100;
  *(void* *)(nextDataIndex + 0x27f18) = 0;
  *(void* *)(nextDataIndex + 0x27f20) = 0;
  *(uint32_t *)(nextDataIndex + 0x27f48) = 0;
  *(void* *)(nextDataIndex + 0x27f50) = 0;
  *(void*2 *)(nextDataIndex + 0x27f58) = 0x100;
  *(void* *)(nextDataIndex + 0x2b460) = 0;
  *(void* *)(nextDataIndex + 0x2b468) = 0;
  *(uint32_t *)(nextDataIndex + 0x2b490) = 0;
  *(void* *)(nextDataIndex + 0x2b498) = 0;
  *(void*2 *)(nextDataIndex + 0x2b4a0) = 0x100;
  *(void* *)(nextDataIndex + 0x2e9a8) = 0;
  *(void* *)(nextDataIndex + 0x2e9b0) = 0;
  *(uint32_t *)(nextDataIndex + 0x2e9d8) = 0;
  *(void* *)(nextDataIndex + 0x2e9e0) = 0;
  *(void*2 *)(nextDataIndex + 0x2e9e8) = 0x100;
  *(void* *)(nextDataIndex + 0x31ef0) = 0;
  *(void* *)(nextDataIndex + 0x31ef8) = 0;
  *(uint32_t *)(nextDataIndex + 0x31f20) = 0;
  *(void* *)(nextDataIndex + 0x31f28) = 0;
  *(void*2 *)(nextDataIndex + 0x31f30) = 0x100;
  *(void* *)(nextDataIndex + 0x35438) = 0;
  *(void* *)(nextDataIndex + 0x35440) = 0;
  *(uint32_t *)(nextDataIndex + 0x35468) = 0;
  *(void* *)(nextDataIndex + 0x35470) = 0;
  *(void*2 *)(nextDataIndex + 0x35478) = 0x100;
  *(void* *)(nextDataIndex + 0x38980) = 0;
  *(void* *)(nextDataIndex + 0x38988) = 0;
  *(uint32_t *)(nextDataIndex + 0x389b0) = 0;
  *(void* *)(nextDataIndex + 0x389b8) = 0;
  *(void*2 *)(nextDataIndex + 0x389c0) = 0x100;
  *(void* *)(nextDataIndex + 0x3bec8) = 0;
  *(void* *)(nextDataIndex + 0x3bed0) = 0;
  *(uint32_t *)(nextDataIndex + 0x3bef8) = 0;
  *(void* *)(nextDataIndex + 0x3bf00) = 0;
  *(void*2 *)(nextDataIndex + 0x3bf08) = 0x100;
  *(void* *)(nextDataIndex + 0x3f410) = 0;
  *(void* *)(nextDataIndex + 0x3f418) = 0;
  *(uint32_t *)(nextDataIndex + 0x3f440) = 0;
  *(void* *)(nextDataIndex + 0x3f448) = 0;
  *(void*2 *)(nextDataIndex + 0x3f450) = 0x100;
  *(void* *)(nextDataIndex + 0x42958) = 0;
  *(void* *)(nextDataIndex + 0x42960) = 0;
  *(uint32_t *)(nextDataIndex + 0x42988) = 0;
  *(void* *)(nextDataIndex + 0x42990) = 0;
  *(void*2 *)(nextDataIndex + 0x42998) = 0x100;
  *(void* *)(nextDataIndex + 0x45ea0) = 0;
  *(void* *)(nextDataIndex + 0x45ea8) = 0;
  *(uint32_t *)(nextDataIndex + 0x45ed0) = 0;
  *(void* *)(nextDataIndex + 0x45ed8) = 0;
  *(void*2 *)(nextDataIndex + 0x45ee0) = 0x100;
  return;
}



void* * FUN_18006e460(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &SystemResourceTemplateB;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x58);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 清理资源管理器指针函数
 * 
 * 该函数负责清理资源管理器的指针和数据结构，包括哈希节点、
 * 字符串处理指针、缓冲区地址等。用于系统资源管理器的内存清理。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * 
 * 原始函数名为FUN_18006e4a0，现已重命名为CleanupResourceManagerPointers
 */
void CleanupResourceManagerPointers(long long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  char *stringProcessingPointer;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  
  HashNodePointer = (void* *)*ResourceManagerPointer;
  if (HashNodePointer != (void* *)0x0) {
    if ((void* *)HashNodePointer[3] != (void* *)0x0) {
      *(void* *)HashNodePointer[3] = 0;
    }
    (**(code **)*HashNodePointer)(HashNodePointer,0);
      SystemCleanupFunction(HashNodePointer);
  }
  if ((ResourceManagerPointer[6] != 0) && (*(long long *)(ResourceManagerPointer[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = ResourceManagerPointer[5];
  while (bufferBaseAddress != 0) {
    pcharResult = (char *)(bufferBaseAddress + 0x3541);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x3538);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = (void* *)ResourceManagerPointer[3];
  if (HashNodePointer == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
  if (currentThreadId != 0) {
    bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
    bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
      *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
      *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
      pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          HashNodePointer,currentThreadId,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 清理资源管理器扩展指针函数
 * 
 * 该函数负责清理资源管理器的扩展指针和数据结构，包括哈希节点、
 * 字符串处理指针、缓冲区地址等。用于系统资源管理器的扩展内存清理。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * 
 * 原始函数名为FUN_18006e4a4，现已重命名为CleanupResourceManagerExtendedPointers
 */
void CleanupResourceManagerExtendedPointers(long long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  char *stringProcessingPointer;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  
  HashNodePointer = (void* *)*ResourceManagerPointer;
  if (HashNodePointer != (void* *)0x0) {
    if ((void* *)HashNodePointer[3] != (void* *)0x0) {
      *(void* *)HashNodePointer[3] = 0;
    }
    (**(code **)*HashNodePointer)(HashNodePointer,0);
      SystemCleanupFunction(HashNodePointer);
  }
  if ((ResourceManagerPointer[6] != 0) && (*(long long *)(ResourceManagerPointer[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = ResourceManagerPointer[5];
  while (bufferBaseAddress != 0) {
    pcharResult = (char *)(bufferBaseAddress + 0x3541);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x3538);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = (void* *)ResourceManagerPointer[3];
  if (HashNodePointer == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
  if (currentThreadId != 0) {
    bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
    bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
      *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
      *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
      pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          HashNodePointer,currentThreadId,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 重置系统内存块状态
 * 
 * 该函数负责重置系统内存块的状态，清理相关资源
 * 用于系统内存管理中的状态重置操作
 */
void ResetSystemMemoryBlockState(void)

{
  void* *systemMemoryBlockPtr;
  
  if ((void* *)systemMemoryBlockPtr[3] != (void* *)0x0) {
    *(void* *)systemMemoryBlockPtr[3] = 0;
  }
  (**(code **)*systemMemoryBlockPtr)();
  SystemCleanupFunction();
}




/**
 * @brief 清理系统字符串迭代器资源
 * 
 * 该函数负责清理系统字符串迭代器的相关资源，包括哈希节点和缓冲区
 * 用于系统字符串管理中的资源清理操作
 */
void CleanupSystemStringIteratorResources(void)

{
  int *resourceReferenceCount;
  char *stringProcessingPointer;
  void* *hashNodePointer;
  long long bufferBaseAddress;
  long long systemStringIteratorPtr;
  ulong long currentThreadId;
  
  if ((*(long long *)(systemStringIteratorPtr + 0x30) != 0) &&
     (*(long long *)(*(long long *)(systemStringIteratorPtr + 0x30) + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = *(long long *)(systemStringIteratorPtr + 0x28);
  while (bufferBaseAddress != 0) {
    stringProcessingPointer = (char *)(bufferBaseAddress + 0x3541);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x3538);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  hashNodePointer = *(void* **)(systemStringIteratorPtr + 0x18);
  if (hashNodePointer != (void* *)0x0) {
    currentThreadId = (ulong long)hashNodePointer & 0xffffffffffc00000;
    if (currentThreadId != 0) {
      bufferBaseAddress = currentThreadId + 0x80 + ((long long)hashNodePointer - currentThreadId >> 0x10) * 0x50;
      bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
      if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
        *hashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
        *(void* **)(bufferBaseAddress + 0x20) = hashNodePointer;
        resourceReferenceCount = (int *)(bufferBaseAddress + 0x18);
        *resourceReferenceCount = *resourceReferenceCount + -1;
        if (*resourceReferenceCount == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                            hashNodePointer,currentThreadId,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源释放管理器
 * 
 * 该函数负责管理系统资源的释放，包括资源引用计数的管理和资源释放操作
 * 当资源引用计数降为0时，会调用系统资源释放函数来清理资源
 * 
 * @param ResourceManagerPointer 系统资源管理器指针
 * 
 * 原始函数名为FUN_18006e570，现已重命名为ReleaseSystemResourceManager
 */
void ReleaseSystemResourceManager(void* *ResourceManagerPointer)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  ulong long allocationContext;
  
  allocationContext = (ulong long)ResourceManagerPointer & 0xffffffffffc00000;
  if (allocationContext != 0) {
    localSystemHandle = allocationContext + 0x80 + ((long long)ResourceManagerPointer - allocationContext >> 0x10) * 0x50;
    localSystemHandle = localSystemHandle - (ulong long)*(uint *)(localSystemHandle + 4);
    if ((*(void ***)(allocationContext + 0x70) == &ExceptionList) && (*(char *)(localSystemHandle + 0xe) == '\0')) {
      *ResourceManagerPointer = *(void* *)(localSystemHandle + 0x20);
      *(void* **)(localSystemHandle + 0x20) = ResourceManagerPointer;
      pointerToInteger1 = (int *)(localSystemHandle + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(allocationContext,CONCAT71(0xff000000,*(void ***)(allocationContext + 0x70) == &ExceptionList),
                          ResourceManagerPointer,allocationContext,0xfffffffffffffffe);
    }
  }
  return;
}




/**
 * @brief 系统资源清理和销毁函数
 * 
 * 该函数负责系统资源的清理和销毁操作，包括互斥锁、条件变量的销毁
 * 以及哈希节点的清理和系统内存的释放
 * 
 * @param ResourceManagerPointer 系统资源管理器指针
 * 
 * 原始函数名为FUN_18006e580，现已重命名为DestroySystemResources
 */
void DestroySystemResources(long long *ResourceManagerPointer)

{
  int *pointerToInteger1;
  char *stringProcessingPointer;
  void* *HashNodePointer;
  long long bufferBaseAddress;
  ulong long currentThreadId;
  
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  HashNodePointer = (void* *)*ResourceManagerPointer;
  if (HashNodePointer != (void* *)0x0) {
    if ((void* *)HashNodePointer[3] != (void* *)0x0) {
      *(void* *)HashNodePointer[3] = 0;
    }
    (**(code **)*HashNodePointer)(HashNodePointer,0);
      SystemCleanupFunction(HashNodePointer);
  }
  if ((ResourceManagerPointer[6] != 0) && (*(long long *)(ResourceManagerPointer[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  bufferBaseAddress = ResourceManagerPointer[5];
  while (bufferBaseAddress != 0) {
    pcharResult = (char *)(bufferBaseAddress + 0x3541);
    bufferBaseAddress = *(long long *)(bufferBaseAddress + 0x3538);
    if (*stringProcessingPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  HashNodePointer = (void* *)ResourceManagerPointer[3];
  if (HashNodePointer == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)HashNodePointer & 0xffffffffffc00000;
  if (currentThreadId != 0) {
    bufferBaseAddress = currentThreadId + 0x80 + ((long long)HashNodePointer - currentThreadId >> 0x10) * 0x50;
    bufferBaseAddress = bufferBaseAddress - (ulong long)*(uint *)(bufferBaseAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(bufferBaseAddress + 0xe) == '\0')) {
      *HashNodePointer = *(void* *)(bufferBaseAddress + 0x20);
      *(void* **)(bufferBaseAddress + 0x20) = HashNodePointer;
      pointerToInteger1 = (int *)(bufferBaseAddress + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          HashNodePointer,currentThreadId,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18006e5d0(long long *ResourceManagerPointer)
/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，遍历资源链表并逐个清理每个资源项。
 * 使用固定步长0x1a8遍历资源，最后调用系统清理函数完成清理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源数组
 * 
 * 原始函数名为FUN_18006e5d0，现已重命名为CleanupSystemResourceArray
 */
void CleanupSystemResourceArray(long long *ResourceManagerPointer)

{
  long long resourceEndIndex;
  long long currentResourceHandle;
  
  resourceEndIndex = ResourceManagerPointer[1];
  for (currentResourceHandle = *ResourceManagerPointer; currentResourceHandle != resourceEndIndex; currentResourceHandle = currentResourceHandle + 0x1a8) {
    CleanupSystemResourceItem(currentResourceHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void FUN_18006e640(long long *ResourceManagerPointer)
/**
 * @brief 系统资源批量清理函数
 * 
 * 该函数负责批量清理系统资源，遍历资源链表并逐个清理每个资源项。
 * 使用固定步长0x1a8遍历资源，最后调用系统清理函数完成清理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源数组
 * 
 * 原始函数名为FUN_18006e640，现已重命名为CleanupSystemResourceBatch
 */
void CleanupSystemResourceBatch(long long *ResourceManagerPointer)

{
  long long resourceEndIndex;
  long long currentResourceHandle;
  
  resourceEndIndex = ResourceManagerPointer[1];
  for (currentResourceHandle = *ResourceManagerPointer; currentResourceHandle != resourceEndIndex; currentResourceHandle = currentResourceHandle + 0x1a8) {
    CleanupSystemResourceItem(currentResourceHandle);
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}



/**
 * @brief 初始化系统资源管理器和数据表
 * 
 * 该函数负责初始化系统资源管理器和数据表，包括：
 * - 设置数据表管理器
 * - 初始化资源管理器指针数组
 * - 配置资源条目和缓冲区
 * - 初始化互斥锁和条件变量
 * - 设置系统资源参数和标志
 * 
 * @param ResourceManagerPointer 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @return 返回初始化后的资源管理器指针
 * 
 * 原始函数名为FUN_18006e660，现已重命名为InitializeSystemResourceManagerAndDataTable
 */
void* * InitializeSystemResourceManagerAndDataTable(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter)

{
  ulong long systemStatus;
  ulong long creationFlags;
  ulong long allocationContext;
  long long bufferBaseAddress;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  long long localDataIndex;
  
  InitializeSystemDataTableManager();
  *ResourceManagerPointer = &SystemDataTableTemplate;
  ResourceManagerPointer[0x19] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1a) = 0;
  ResourceManagerPointer[0x1b] = 0;
  ResourceManagerPointer[0x1e] = 0;
  resourceEntryPointer = ResourceManagerPointer + 0x24;
  localDataIndex = 0x20;
  bufferBaseAddress = 0x20;
  pcurrentThreadId = resourceEntryPointer;
  do {
    SystemResourceCleanup(pcurrentThreadId);
    pcurrentThreadId = pcurrentThreadId + 2;
    bufferBaseAddress = bufferBaseAddress + -1;
  } while (bufferBaseAddress != 0);
  creationFlags = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x324) = 0;
  *(uint32_t *)(ResourceManagerPointer + 100) = 0;
  ResourceManagerPointer[0x20] = 0;
  ResourceManagerPointer[0x21] = 0x20;
  ResourceManagerPointer[0x22] = resourceEntryPointer;
  do {
    *(uint32_t *)resourceEntryPointer = 0;
    resourceEntryPointer = resourceEntryPointer + 2;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  ResourceManagerPointer[0x23] = 0;
  ResourceManagerPointer[0x1f] = ResourceManagerPointer + 0x21;
  ResourceManagerPointer[0x1d] = 0x15;
  bufferBaseAddress = FUN_18006e140();
  ResourceManagerPointer[0x1c] = bufferBaseAddress;
  if (bufferBaseAddress == 0) {
    ResourceManagerPointer[0x1d] = 0;
    systemStatus = creationFlags;
  }
  else {
    systemStatus = ResourceManagerPointer[0x1d];
  }
  allocationContext = creationFlags;
  if (systemStatus != 0) {
    do {
      *(uint8_t *)(creationFlags + 0x3541 + ResourceManagerPointer[0x1c]) = 0;
      allocationContext = allocationContext + 1;
      creationFlags = creationFlags + 0x3548;
    } while (allocationContext < (ulong long)ResourceManagerPointer[0x1d]);
  }
  _Cnd_init_in_situ();
  _Mtx_init_in_situ(ResourceManagerPointer + 0x6f,2);
  ResourceManagerPointer[0x79] = 0;
  ResourceManagerPointer[0x7a] = 0;
  ResourceManagerPointer[0x7b] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x7c) = 3;
  ResourceManagerPointer[0x7e] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x7f) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x3fc) = 4000;
  ResourceManagerPointer[0x18] = ConfigurationDataPointer;
  ResourceManagerPointer[0x7d] = AdditionalParameter;
  *(uint8_t *)(ResourceManagerPointer + 0x80) = 0;
  return ResourceManagerPointer;
}



/**
 * @brief 使用互斥锁初始化系统资源管理器
 * 
 * 该函数负责使用互斥锁初始化系统资源管理器，包括互斥锁的初始化、
 * 资源管理器的配置和内存分配。主要用于系统资源的同步管理。
 * 
 * @param ResourceManagerPointer 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @param ConfigurationFlag 配置标志，用于控制初始化行为
 * @return 返回初始化后的资源管理器指针
 * 
 * 原始函数名为FUN_18006e870，现已重命名为InitializeSystemResourceManagerWithMutex
 */
uint32_t *
InitializeSystemResourceManagerWithMutex(uint32_t *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t *pointerToUnsigned1;
  
  *ResourceManagerPointer = 0;
  ResourceManagerPointer[1] = 0;
  ResourceManagerPointer[2] = 0;
  ResourceManagerPointer[3] = 0;
  ResourceManagerPointer[4] = 3;
  *(void* *)(ResourceManagerPointer + 6) = 0;
  *(uint32_t **)ResourceManagerPointer = ResourceManagerPointer;
  *(uint32_t **)(ResourceManagerPointer + 2) = ResourceManagerPointer;
  _Mtx_init_in_situ(ResourceManagerPointer + 8,0x102,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  *(void* *)(ResourceManagerPointer + 0x1c) = 1;
  pointerToUnsigned1 = ResourceManagerPointer + 0x1e;
  *pointerToUnsigned1 = 0;
  ResourceManagerPointer[0x1f] = 0;
  ResourceManagerPointer[0x20] = 0;
  ResourceManagerPointer[0x21] = 0;
  ResourceManagerPointer[0x22] = 3;
  *(void* *)(ResourceManagerPointer + 0x24) = 0;
  *(uint32_t **)pointerToUnsigned1 = pointerToUnsigned1;
  *(uint32_t **)(ResourceManagerPointer + 0x20) = pointerToUnsigned1;
  _Mtx_init_in_situ(ResourceManagerPointer + 0x26,0x102);
  *(void* *)(ResourceManagerPointer + 0x3a) = 1;
  pointerToUnsigned1 = ResourceManagerPointer + 0x3c;
  *pointerToUnsigned1 = 0;
  ResourceManagerPointer[0x3d] = 0;
  ResourceManagerPointer[0x3e] = 0;
  ResourceManagerPointer[0x3f] = 0;
  ResourceManagerPointer[0x40] = 3;
  *(void* *)(ResourceManagerPointer + 0x42) = 0;
  *(uint32_t **)pointerToUnsigned1 = pointerToUnsigned1;
  *(uint32_t **)(ResourceManagerPointer + 0x3e) = pointerToUnsigned1;
  _Mtx_init_in_situ(ResourceManagerPointer + 0x44,0x102);
  *(void* *)(ResourceManagerPointer + 0x58) = 1;
  ResourceManagerPointer[0x5a] = 0;
  return ResourceManagerPointer;
}





/**
 * @brief 系统初始化状态管理器
 * 
 * 该函数负责管理系统初始化状态，包括初始化标志的设置、
 * 系统计数器的更新和系统内存的管理
 * 
 * 原始函数名为FUN_18006e990，现已重命名为ManageSystemInitializationState
 */
void ManageSystemInitializationState(void)

{
  long long nextDataIndex;
  char validationStatusFlag;
  int MemoryComparisonResult;
  long long* SystemMemoryPointer;
  
  nextDataIndex = SystemInitializationFlag;
  FUN_18006f160(SystemInitializationFlag);
  *(int *)(nextDataIndex + 0xec) = *(int *)(nextDataIndex + 0xec) + 1;
  systemCounter = _Mtx_lock(nextDataIndex + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  pbufferBaseAddress = *(long long **)(nextDataIndex + 0x78);
  if ((pbufferBaseAddress != (long long *)(nextDataIndex + 0x78)) && (*(uint *)(pbufferBaseAddress + 2) < *(uint *)(nextDataIndex + 0xec))) {
    pbufferBaseAddress = *(long long **)(*pbufferBaseAddress + 8);
    *(long long *)(*pbufferBaseAddress + 8) = pbufferBaseAddress[1];
    *(long long *)pbufferBaseAddress[1] = *pbufferBaseAddress;
      SystemCleanupFunction();
  }
  systemCounter = _Mtx_unlock(nextDataIndex + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  *(int *)(nextDataIndex + 0x164) = *(int *)(nextDataIndex + 0x164) + 1;
  systemCounter = _Mtx_lock(nextDataIndex + 0x110);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  pbufferBaseAddress = *(long long **)(nextDataIndex + 0xf0);
  do {
    if (pbufferBaseAddress == (long long *)(nextDataIndex + 0xf0)) {
LAB_18006f48d:
      systemCounter = _Mtx_unlock(nextDataIndex + 0x110);
      if (systemCounter != 0) {
        __Throw_C_error_std__YAXH_Z(systemCounter);
      }
      return;
    }
    charResult = (**(code **)(*(long long *)pbufferBaseAddress[3] + 0x40))();
    if (validationStatusFlag != '\0') {
      if (*(uint *)(pbufferBaseAddress + 2) < *(uint *)(nextDataIndex + 0x164)) {
        pbufferBaseAddress = *(long long **)(*pbufferBaseAddress + 8);
        *(long long *)(*pbufferBaseAddress + 8) = pbufferBaseAddress[1];
        *(long long *)pbufferBaseAddress[1] = *pbufferBaseAddress;
          SystemCleanupFunction();
      }
      goto LAB_18006f48d;
    }
    pbufferBaseAddress = (long long *)*pbufferBaseAddress;
  } while( true );
}





// 函数: void FinalizeSystemMemorySetup(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FinalizeSystemMemorySetup(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long localSystemHandle;
  int MemoryComparisonResult;
  
  localSystemHandle = SystemInitializationFlag;
  FUN_18005e630(SystemAllocationFlagsTemplate,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  FUN_18006efc0(localSystemHandle);
  systemCounter = _Mtx_lock(localSystemHandle + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  if (*(long long *)(localSystemHandle + 0x90) != 0) {
    PrimaryResourcePointer = *(long long **)(**(long long **)(localSystemHandle + 0x78) + 8);
    *(long long *)(*PrimaryResourcePointer + 8) = PrimaryResourcePointer[1];
    *(long long *)PrimaryResourcePointer[1] = *PrimaryResourcePointer;
      SystemCleanupFunction();
  }
  systemCounter = _Mtx_unlock(localSystemHandle + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  systemCounter = _Mtx_lock(localSystemHandle + 0x110);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  if (*(long long *)(localSystemHandle + 0x108) != 0) {
    PrimaryResourcePointer = *(long long **)(**(long long **)(localSystemHandle + 0xf0) + 8);
    *(long long *)(*PrimaryResourcePointer + 8) = PrimaryResourcePointer[1];
    *(long long *)PrimaryResourcePointer[1] = *PrimaryResourcePointer;
      SystemCleanupFunction();
  }
  systemCounter = _Mtx_unlock(localSystemHandle + 0x110);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  return;
}





// 函数: void FUN_18006edf0(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括创建线程对象、
 * 设置资源参数和配置系统状态
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006edf0，现已重命名为InitializeSystemResourceManagerEx
 */
void InitializeSystemResourceManagerEx(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long DataIndex;
  int SystemOperationResult;
  long long ResourceOffset;
  int SystemIndex;
  long long *SystemPointer;
  long long SystemFlags;
  void* SystemValue;
  uint32_t StackParameter1;
  uint32_t StackParameter2;
  uint32_t StackParameter3;
  uint7 StackParameter4;
  
  ResourceOffset = SystemInitializationFlag;
  SystemValue = 0xfffffffffffffffe;
  if (SystemInitializationFlag != 0) {
    SystemFlags = SystemInitializationFlag + 0xf0;
    DataIndex = SystemInitializationFlag + 0x110;
    SystemIndex = _Mtx_lock(DataIndex);
    if (SystemIndex != 0) {
      __Throw_C_error_std__YAXH_Z(SystemIndex);
    }
    SystemIndex = *(int *)(ResourceOffset + 0x164);
    SystemOperationResult = *(int *)(ResourceOffset + 0x160);
    SystemPointer = (long long *)
             CreateSystemThreadObject(SystemMemoryPoolTemplate,0x28,*(uint8_t *)(ResourceOffset + 0x100),ConfigurationFlag,SystemValue);
    StackParameter2 = (uint32_t)ResourceManagerPointer;
    StackParameter3 = (uint32_t)((ulong long)ResourceManagerPointer >> 0x20);
    *(int *)(SystemPointer + 2) = SystemIndex + SystemOperationResult;
    *(uint32_t *)((long long)SystemPointer + 0x14) = StackParameter1;
    *(uint32_t *)(SystemPointer + 3) = StackParameter2;
    *(uint32_t *)((long long)SystemPointer + 0x1c) = StackParameter3;
    SystemPointer[4] = (ulong long)StackParameter4 << 8;
    *SystemPointer = SystemFlags;
    SystemPointer[1] = *(long long *)(ResourceOffset + 0xf8);
    **(long long **)(ResourceOffset + 0xf8) = (long long)SystemPointer;
    *(long long **)(ResourceOffset + 0xf8) = SystemPointer;
    *(long long *)(ResourceOffset + 0x108) = *(long long *)(ResourceOffset + 0x108) + 1;
    SystemIndex = _Mtx_unlock(DataIndex);
    if (SystemIndex != 0) {
      __Throw_C_error_std__YAXH_Z(SystemIndex);
    }
  }
  return;
}



/**
 * @brief 获取系统资源状态
 * 
 * 该函数负责获取系统资源的状态信息，通过线程安全的方式
 * 访问资源管理器中的状态数据
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @return 系统状态指针，包含当前系统状态信息
 * 
 * 原始函数名为FUN_18006eec0，现已重命名为GetSystemResourceStatus
 */
void* GetSystemResourceStatus(long long ResourceManagerPointer)

{
  void* SystemStatus;
  int OperationResult;
  
  OperationResult = _Mtx_lock(ResourceManagerPointer + 0x20);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  SystemStatus = *(void* *)(ResourceManagerPointer + 0x18);
  OperationResult = _Mtx_unlock(ResourceManagerPointer + 0x20);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  return SystemStatus;
}




// 函数: void ReleaseSystemResource(long long *ResourceManagerPointer)
/**
 * @brief 释放系统资源
 * 
 * 该函数负责释放系统资源，包括销毁互斥锁和清理相关资源
 * 确保系统资源的正确释放和内存管理
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @return 无返回值
 */
void ReleaseSystemResource(long long *ResourceManagerPointer)

{
  _Mtx_destroy_in_situ();
  if ((long long *)*ResourceManagerPointer != ResourceManagerPointer) {
      SystemCleanupFunction((long long *)*ResourceManagerPointer);
  }
  return;
}




// 函数: void FUN_18006ef80(long long *ResourceManagerPointer)
/**
 * @brief 清理系统资源管理器
 * 
 * 该函数负责清理系统资源管理器，确保资源的正确释放
 * 主要用于系统关闭时的资源清理工作
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006ef80，现已重命名为CleanupSystemResourceManager
 */
void CleanupSystemResourceManager(long long *ResourceManagerPointer)

{
  if ((long long *)*ResourceManagerPointer != ResourceManagerPointer) {
      SystemCleanupFunction((long long *)*ResourceManagerPointer);
  }
  return;
}




// 函数: void FUN_18006efc0(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 执行系统资源清理操作
 * 
 * 该函数负责执行系统资源的清理操作，包括锁定资源管理器、
 * 清理主要资源指针和释放相关资源
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006efc0，现已重命名为ExecuteSystemResourceCleanup
 */
void ExecuteSystemResourceCleanup(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *MainResourcePointer;
  int OperationResult;
  
  OperationResult = _Mtx_lock(ResourceManagerPointer + 4,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  if (ResourceManagerPointer[3] != 0) {
    MainResourcePointer = *(long long **)(*(long long *)*ResourceManagerPointer + 8);
    *(long long *)(*MainResourcePointer + 8) = MainResourcePointer[1];
    *(long long *)MainResourcePointer[1] = *MainResourcePointer;
      SystemCleanupFunction();
  }
  OperationResult = _Mtx_unlock(ResourceManagerPointer + 4);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  return;
}




// 函数: void UpdateSystemResourceCounter(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 更新系统资源计数器
 * 
 * 该函数负责更新系统资源的计数器，管理资源的使用统计。
 * 它会锁定资源管理器，更新计数器值，并在必要时清理资源。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18006f160，现已重命名为UpdateSystemResourceCounter
 */
void UpdateSystemResourceCounter(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  int systemResult;
  
  *(int *)((long long)ResourceManagerPointer + 0x74) = *(int *)((long long)ResourceManagerPointer + 0x74) + 1;
  systemResult = _Mtx_lock(ResourceManagerPointer + 4,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  PrimaryResourcePointer = (long long *)*ResourceManagerPointer;
  if ((PrimaryResourcePointer != ResourceManagerPointer) && (*(uint *)(PrimaryResourcePointer + 2) < *(uint *)((long long)ResourceManagerPointer + 0x74))) {
    PrimaryResourcePointer = *(long long **)(*PrimaryResourcePointer + 8);
    *(long long *)(*PrimaryResourcePointer + 8) = PrimaryResourcePointer[1];
    *(long long *)PrimaryResourcePointer[1] = *PrimaryResourcePointer;
      SystemCleanupFunction();
  }
  systemResult = _Mtx_unlock(ResourceManagerPointer + 4);
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  return;
}




// 函数: void CleanupSystemResourceHandle(long long *ResourceManagerPointer)
/**
 * @brief 清理系统资源句柄
 * 
 * 该函数负责清理系统资源句柄，释放相关资源并清理内存。
 * 这是一个简单的资源清理函数，确保资源句柄被正确释放。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源句柄
 * 
 * 原始函数名为FUN_18006f310，现已重命名为CleanupSystemResourceHandle
 */
void CleanupSystemResourceHandle(long long *ResourceManagerPointer)

{
  if ((long long *)*ResourceManagerPointer != ResourceManagerPointer) {
      SystemCleanupFunction((long long *)*ResourceManagerPointer);
  }
  return;
}




/**
 * @brief 处理系统资源队列
 * 
 * 该函数负责处理系统资源队列，管理资源的分配和释放。
 * 主要用于系统资源的队列管理和线程同步。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向资源队列数据结构
 * 
 * 原始函数名为FUN_18006f340，现已重命名为ProcessSystemResourceQueue
 */
void ProcessSystemResourceQueue(long long *ResourceManagerPointer)

{
  char SystemNodeFlag;
  int systemResult;
  long long *plocalResourceOffset;
  
  *(int *)((long long)ResourceManagerPointer + 0x74) = *(int *)((long long)ResourceManagerPointer + 0x74) + 1;
  systemResult = _Mtx_lock(ResourceManagerPointer + 4);
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  plocalResourceOffset = (long long *)*ResourceManagerPointer;
  do {
    if (plocalResourceOffset == ResourceManagerPointer) {
LAB_18006f48d:
      systemResult = _Mtx_unlock(ResourceManagerPointer + 4);
      if (systemResult != 0) {
        __Throw_C_error_std__YAXH_Z(systemResult);
      }
      return;
    }
    charStatus = (**(code **)(*(long long *)plocalResourceOffset[3] + 0x40))();
    if (initializationStatusFlag != '\0') {
      if (*(uint *)(plocalResourceOffset + 2) < *(uint *)((long long)ResourceManagerPointer + 0x74)) {
        plocalResourceOffset = *(long long **)(*plocalResourceOffset + 8);
        *(long long *)(*plocalResourceOffset + 8) = plocalResourceOffset[1];
        *(long long *)plocalResourceOffset[1] = *plocalResourceOffset;
          SystemCleanupFunction();
      }
      goto LAB_18006f48d;
    }
    plocalResourceOffset = (long long *)*plocalResourceOffset;
  } while( true );
}




// 函数: void ExecuteSystemEntryPoint(void* *entryPointPtr)
/**
 * @brief 执行系统入口点
 * 
 * 该函数负责执行系统的入口点函数。它会检查入口点指针是否有效，
 * 如果有效则调用相应的函数指针，并处理运行时类型转换。
 * 
 * @param entryPointPtr 入口点指针，指向要执行的函数
 */
void ExecuteSystemEntryPoint(void* *entryPointPtr)

{
  long long runtimeCastResult;
  
  if (entryPointPtr != (void* *)0x0) {
    runtimeCastResult = __RTCastToVoid();
    (**(code **)*entryPointPtr)(entryPointPtr,0);
    if (runtimeCastResult != 0) {
        SystemCleanupFunction(runtimeCastResult);
    }
  }
  return;
}




/**
 * @brief 系统内存数据索引处理器
 * 
 * 该函数负责处理系统内存数据索引，包括索引的获取和清理操作
 * 用于系统内存数据的管理和维护
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006f4cd，现已重命名为ProcessSystemMemoryDataIndex
 */
void ProcessSystemMemoryDataIndex(void)

{
  long long NextDataIndex;
  void* *SystemMemoryBlockPointer;
  
  NextDataIndex = __RTCastToVoid();
  (**(code **)*SystemMemoryBlockPointer)();
  if (NextDataIndex != 0) {
      SystemCleanupFunction(NextDataIndex);
  }
  return;
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，用于系统初始化过程中的占位操作
 * 在某些系统流程中需要调用但不执行任何操作
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006f4fc，现已重命名为SystemNullOperation
 */
void SystemNullOperation(void)

{
  return;
}




/**
 * @brief 执行资源管理器操作
 * 
 * 该函数负责执行资源管理器的特定操作，通过调用资源管理器中的
 * 预定义函数指针来执行相应的操作
 * 
 * @param ResourceManagerPointer 资源管理器指针，包含要操作的资源管理器
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006f500，现已重命名为ExecuteResourceManagerOperation
 */
void ExecuteResourceManagerOperation(long long ResourceManagerPointer)

{
  if (*(long long **)(ResourceManagerPointer + 0x70) != (long long *)0x0) {
    (**(code **)(**(long long **)(ResourceManagerPointer + 0x70) + 0x38))();
  }
  return;
}




/**
 * @brief 清理资源管理器状态
 * 
 * 该函数负责清理资源管理器的状态，包括系统清理函数的调用
 * 和资源管理器中特定函数指针的执行
 * 
 * @param ResourceManagerPointer 资源管理器指针，包含要清理的资源管理器
 * @return 无返回值
 * 
 * 原始函数名为FUN_18006f530，现已重命名为CleanupResourceManagerState
 */
void CleanupResourceManagerState(long long ResourceManagerPointer)

{
  if (*(long long *)(ResourceManagerPointer + 0x1d8) != 0) {
      SystemCleanupFunction();
  }
  if (*(long long **)(ResourceManagerPointer + 0x1b8) != (long long *)0x0) {
    (**(code **)(**(long long **)(ResourceManagerPointer + 0x1b8) + 0x38))();
  }
  return;
}



/**
 * @brief 配置系统资源管理器
 * 
 * 该函数负责配置系统资源管理器，包括内存分配器的设置、
 * 全局数据的初始化和系统命令的执行
 * 
 * @param ResourceManagerPointer 资源管理器指针，包含要配置的资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，包含额外的配置参数
 * @param ConfigurationFlag 配置标志，指定配置的方式和选项
 * @return 资源管理器指针，返回配置后的资源管理器指针
 * 
 * 原始函数名为FUN_18006f590，现已重命名为ConfigureSystemResourceManager
 */
void* *
ConfigureSystemResourceManager(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (SystemInitFlagPtr == '\0') {
    *ResourceManagerPointer = &SystemMemoryAllocatorReference;
    ResourceManagerPointer[1] = 0;
    *(uint32_t *)(ResourceManagerPointer + 2) = 0;
    *ResourceManagerPointer = &SystemGlobalDataReference;
    ResourceManagerPointer[3] = 0;
    ResourceManagerPointer[1] = 0;
    *(uint32_t *)(ResourceManagerPointer + 2) = 0;
    ExecuteSystemCommand(ResourceManagerPointer,0,AdditionalParameter,ConfigurationFlag,0,0xfffffffffffffffe);
    *(uint32_t *)(ResourceManagerPointer + 2) = 0;
    if ((uint8_t *)ResourceManagerPointer[1] != (uint8_t *)0x0) {
      *(uint8_t *)ResourceManagerPointer[1] = 0;
    }
  }
  else {
    FUN_1802265d0(ResourceManagerPointer,ResourceManagerPointer);
  }
  return ResourceManagerPointer;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括配置系统数据、设置标志、
 * 处理调试器检测、显示消息框等系统初始化操作
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统状态码
 * 
 * 原始函数名为FUN_18006f620，现已重命名为InitializeSystemResourceManagerA
 */
ulong long InitializeSystemResourceManagerA(void* ResourceManagerPointer,void* ConfigurationDataPointer)

{
  code *systemFunctionPointer;
  bool isSystemActive;
  long long localResourceOffset;
  char systemStatusFlag;
  int systemValue;
  int systemFlag;
  ulong long unsignedSystemValue7;
  void* *newThreadLocalStorage;
  bool isSystemBusy;
  void* *memoryAllocationEnd;
  void* *pEncryptionValue48;
  uint32_t unsignedValue40;
  void* uStack_38;
  uint8_t aunsignedValue30 [8];
  void* *pEncryptionKeyValue;
  
  localResourceOffset = SystemAllocationFlagsTemplate;
  unsignedSystemValue7 = FUN_1800f9600(ConfigurationDataPointer);
  if (((char)unsignedSystemValue7 != '\0') || (unsignedSystemValue7 = WaitForSingleObject(SystemSemaphoreHandle,0), (int)unsignedSystemValue7 != 0)) {
    return unsignedSystemValue7 & 0xffffffffffffff00;
  }
  if (localResourceOffset != 0) {
    FUN_18005dab0(localResourceOffset);
  }
  isSystemBusy = true;
  systemStatusFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((systemStatusFlag == '\0') && (systemValue = IsDebuggerPresent(), systemValue != 0)) {
    isSystemActive = true;
  }
  else {
    isSystemActive = false;
  }
  if (localResourceOffset != 0) {
    systemValue = *(int *)(**(long long **)(localResourceOffset + 8) + 0x48);
    systemFlag = _Thrd_id();
    isSystemBusy = systemFlag == systemValue;
  }
  FUN_1800f9ce0(aunsignedValue30,0);
  memoryAllocationEnd = &SystemGlobalDataReference;
  uStack_38 = 0;
  pEncryptionValue48 = (void* *)0x0;
  unsignedValue40 = 0;
  ConfigureSystemDataBuffer(&memoryAllocationEnd,&SystemDataBufferTemplate,ConfigurationDataPointer);
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationTemplate);
  newThreadLocalStorage = &SystemStringTemplate;
  if (pEncryptionValue48 != (void* *)0x0) {
    newThreadLocalStorage = pEncryptionValue48;
  }
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemStringTemplateBuffer,newThreadLocalStorage);
  newThreadLocalStorage = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    newThreadLocalStorage = pEncryptionKeyValue;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffff00000000,3,newThreadLocalStorage);
  InitializeSystemManager();
  newThreadLocalStorage = &SystemStringTemplate;
  if (pEncryptionValue48 != (void* *)0x0) {
    newThreadLocalStorage = pEncryptionValue48;
  }
  OutputDebugStringA(newThreadLocalStorage);
  FUN_18004c2b0(ConfigurationDataPointer);
  localResourceOffset = SystemRenderManagerPointer;
  if (((isSystemBusy) && (SystemRenderManagerPointer != 0)) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
    ProcessSystemResourceAllocation(*(void* *)(SystemStatusFlagsPointer + 8),*(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                  *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
    *(uint8_t *)(localResourceOffset + 0x1609) = 1;
  }
  if (SystemSilentMode == '\0') {
    if ((SystemInitializationFlag == '\0') ||
       ((systemValue = IsDebuggerPresent(), systemValue != 0 && (SystemSilentMode == '\0')))) {
      MessageBoxA(0,ConfigurationDataPointer,&SystemMessageTemplate,0x41010);
    }
    else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
      SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,&SystemMessageTemplate,ConfigurationDataPointer);
    }
  }
  else if (SystemInitializationFlag == '\0') {
    newThreadLocalStorage = &SystemStringTemplate;
    if (pEncryptionValue48 != (void* *)0x0) {
      newThreadLocalStorage = pEncryptionValue48;
    }
    FUN_1806272a0(newThreadLocalStorage);
  }
  systemValue = FUN_1800f98e0(ConfigurationDataPointer);
  if ((!isSystemActive) && (systemValue == 0)) {
    FUN_180066320();
  }
  FUN_1800f96b0(ConfigurationDataPointer,0);
  if (SystemStatusFlagsPointer == 0) {
    _Exit(5);
    systemFunctionPointer = (code *)swi(3);
    unsignedSystemValue7 = (*systemFunctionPointer)();
    return unsignedSystemValue7;
  }
  FUN_180055f70();
  systemFunctionPointer = (code *)swi(3);
  unsignedSystemValue7 = (*systemFunctionPointer)();
  return unsignedSystemValue7;
}



00018006fc4b)
00018006fc66)
00018006fc6b)
00018006fe26)

/**
 * @brief 系统资源初始化和处理函数
 * 
 * 该函数负责系统资源的初始化和处理，包括调试器检测、信号量等待、
 * 系统配置和资源管理等功能
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @return 系统状态码
 * 
 * 原始函数名为FUN_18006f940，现已重命名为InitializeAndProcessSystemResources
 */
ulong long InitializeAndProcessSystemResources(void* ResourceManagerPointer,void* ConfigurationDataPointer,char AdditionalParameter)

{
  uint8_t systemStatus;
  code *stringProcessingPointer;
  bool isOperationComplete;
  long long bufferBaseAddress;
  void* *pcurrentThreadId;
  char debuggerCheckResult;
  int systemOffset;
  int systemCode;
  uint32_t unsignedSystemValue9;
  ulong long in_RAX;
  long long allocationFlags;
  void* *ThreadLocalStorage;
  ulong long systemStatus2;
  void* systemStatus3;
  void* *pointerToUnsigned14;
  bool isByteValid5;
  byte bStackX_20;
  void* *DataBufferPtrE0;
  void* *punsignedValueD8;
  uint32_t uStack_d0;
  ulong long uStack_c8;
  void* *pUnsignedStackFlagC0;
  void* *systemGlobalDataPtrB8;
  uint32_t UnsignedStackFlagB0;
  void* UnsignedStackFlagA8;
  void* *SystemDataPointer;
  void* *stackParameterB;
  uint32_t SystemConfigurationValue;
  ulong long UnsignedStackFlag88;
  void* *pUnsignedStackFlag80;
  long long lStack_78;
  uint32_t EncryptionValue68;
  void* unsignedValue40;
  
  bufferBaseAddress = SystemAllocationFlagsTemplate;
  unsignedValue40 = 0xfffffffffffffffe;
  bStackX_20 = 0;
  if (((SystemInitializationFlag == '\0') || (in_RAX = FUN_1800f9600(ConfigurationDataPointer), (char)in_RAX != '\0')) ||
     (in_RAX = WaitForSingleObject(SystemSemaphoreHandle,0), (int)in_RAX != 0)) {
    systemStatus2 = in_RAX & 0xffffffffffffff00;
  }
  else {
    if (bufferBaseAddress != 0) {
      FUN_18005dab0(bufferBaseAddress);
    }
    isByteValid5 = true;
    debuggerCheckResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
    if ((debuggerCheckResult == '\0') && (systemOffset = IsDebuggerPresent(), systemOffset != 0)) {
      isOperationComplete = true;
    }
    else {
      isOperationComplete = false;
    }
    if (bufferBaseAddress != 0) {
      systemOffset = *(int *)(**(long long **)(bufferBaseAddress + 8) + 0x48);
      systemCode = _Thrd_id();
      isByteValid5 = systemCode == systemOffset;
    }
    pUnsignedStackFlagC0 = &SystemGlobalDataReference;
    UnsignedStackFlagA8 = 0;
    systemGlobalDataPtrB8 = (void* *)0x0;
    UnsignedStackFlagB0 = 0;
    if (!isOperationComplete) {
      allocationFlags = FUN_1800f9ce0(&DataBufferPtrE0,0);
      UnsignedStackFlagB0 = *(uint32_t *)(allocationFlags + 0x10);
      systemGlobalDataPtrB8 = *(void* **)(allocationFlags + 8);
      UnsignedStackFlagA8 = *(void* *)(allocationFlags + 0x18);
      *(uint32_t *)(allocationFlags + 0x10) = 0;
      *(void* *)(allocationFlags + 8) = 0;
      *(void* *)(allocationFlags + 0x18) = 0;
      DataBufferPtrE0 = &SystemGlobalDataReference;
      if (punsignedValueD8 != (void* *)0x0) {
          SystemCleanupFunction();
      }
      punsignedValueD8 = (void* *)0x0;
      uStack_c8 = uStack_c8 & 0xffffffff00000000;
      DataBufferPtrE0 = &SystemMemoryAllocatorReference;
    }
    pcurrentThreadId = systemGlobalDataPtrB8;
    stackParameterA = &SystemGlobalDataReference;
    UnsignedStackFlag88 = 0;
    stackParameterB = (void* *)0x0;
    SystemConfigurationValue = 0;
    ConfigureSystemDataBuffer(&stackParameterA,&SystemDataTemplateC,ConfigurationDataPointer);
    FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationTemplate);
    ThreadLocalStorage = &SystemStringTemplate;
    if (stackParameterB != (void* *)0x0) {
      ThreadLocalStorage = stackParameterB;
    }
    FUN_180062380(SystemContextManagerPointer,2,0xffffffff00000000,&SystemStringTemplateBuffer,ThreadLocalStorage);
    ThreadLocalStorage = &SystemStringTemplate;
    if (pcurrentThreadId != (void* *)0x0) {
      ThreadLocalStorage = pcurrentThreadId;
    }
    SystemManagerSetFlags(SystemContextManagerPointer,2,0xffffffff00000000,3,ThreadLocalStorage);
    InitializeSystemManager();
    ThreadLocalStorage = &SystemStringTemplate;
    if (stackParameterB != (void* *)0x0) {
      ThreadLocalStorage = stackParameterB;
    }
    OutputDebugStringA(ThreadLocalStorage);
    FUN_18004c2b0(ConfigurationDataPointer);
    if (((SystemInitializationFlag != '\0') && (isOperationComplete)) &&
       ((*(char *)(SystemStatusFlagsPointer + 0x25) != '\0' ||
        ((AdditionalParameter == '\0' || (*(int *)(SystemStatusFlagsPointer + 0x340) == 2)))))) {
      if (SystemDebugFlag == '\0') {
        pcharResult = (code *)swi(3);
        systemStatus2 = (*pcharResult)();
        return systemStatus2;
      }
      bStackX_20 = 1;
    }
    if (SystemSilentMode == '\0') {
      if (isByteValid5) {
        if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
          ValidateSystemResourceStatus(*(long long *)(SystemStatusFlagsPointer + 8));
        }
        bufferBaseAddress = SystemRenderManagerPointer;
        if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
          ProcessSystemResourceAllocation(*(void* *)(SystemStatusFlagsPointer + 8),
                        *(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                        *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
          *(uint8_t *)(bufferBaseAddress + 0x1609) = 1;
        }
      }
      DataBufferPtrE0 = &SystemGlobalDataReference;
      uStack_c8 = 0;
      punsignedValueD8 = (void* *)0x0;
      uStack_d0 = 0;
      pointerToUnsigned14 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
      *(uint8_t *)pointerToUnsigned14 = 0;
      punsignedValueD8 = pointerToUnsigned14;
      unsignedSystemValue9 = StartSystemThread(pointerToUnsigned14);
      uStack_c8 = CONCAT44(uStack_c8._4_4_,unsignedSystemValue9);
      *pointerToUnsigned14 = 0x4e524157204c4752;
      *(uint32_t *)(pointerToUnsigned14 + 1) = 0x474e49;
      uStack_d0 = 0xb;
      if (((SystemInitializationFlag == '\0') || (systemOffset = IsDebuggerPresent(), systemOffset != 0)) &&
         (SystemSilentMode == '\0')) {
        MessageBoxA(0,ConfigurationDataPointer,pointerToUnsigned14,0x41030);
      }
      else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
        SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,pointerToUnsigned14,ConfigurationDataPointer);
      }
      DataBufferPtrE0 = &SystemGlobalDataReference;
        SystemCleanupFunction(pointerToUnsigned14);
    }
    if (SystemInitializationFlag == '\0') {
      FUN_1806272a0(&SystemDebugTemplate,ConfigurationDataPointer);
    }
    systemOffset = FUN_1800f98e0(ConfigurationDataPointer);
    if (((!isOperationComplete) && (systemOffset == 0)) && (*(char *)(SystemStatusFlagsPointer + 0x2a) != '\0')) {
      systemStatus = *(uint8_t *)(SystemStatusFlagsPointer + 0x141);
      systemStatus3 = CreateSystemObject(&pUnsignedStackFlag80,SystemStatusFlagsPointer + 0x148);
      systemStatus3 = CreateSystemObject(&DataBufferPtrE0,systemStatus3);
      pUnsignedStackFlag80 = &SystemGlobalDataReference;
      if (lStack_78 != 0) {
          SystemCleanupFunction();
      }
      lStack_78 = 0;
      EncryptionValue68 = 0;
      pUnsignedStackFlag80 = &SystemMemoryAllocatorReference;
      ThreadLocalStorage = &SystemStringTemplate;
      if (pcurrentThreadId != (void* *)0x0) {
        ThreadLocalStorage = pcurrentThreadId;
      }
      FUN_180066320(systemStatus3,&DataBufferPtrE0,systemStatus,0,ThreadLocalStorage);
      DataBufferPtrE0 = &SystemGlobalDataReference;
      if (punsignedValueD8 != (void* *)0x0) {
          SystemCleanupFunction();
      }
      punsignedValueD8 = (void* *)0x0;
      uStack_c8 = uStack_c8 & 0xffffffff00000000;
      DataBufferPtrE0 = &SystemMemoryAllocatorReference;
    }
    FUN_1800f96b0(ConfigurationDataPointer,0);
    if (SystemStatusFlagsPointer == 0) {
      charSignal = '\x01';
    }
    else {
      charSignal = *(char *)(SystemStatusFlagsPointer + 0x29);
    }
    if (*(char *)(SystemStatusFlagsPointer + 0x25) != '\0') {
      FUN_180055f70(SystemStatusFlagsPointer,5);
      pcharResult = (code *)swi(3);
      systemStatus2 = (*pcharResult)();
      return systemStatus2;
    }
    if (charSignal != '\0') {
      SystemGlobalStateStorage = 5;
    }
    if ((SystemSilentMode == '\0') && (isByteValid5)) {
      if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
        CleanupSystemResources();
      }
      if (SystemRenderManagerPointer != 0) {
        FUN_180092940(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
      }
    }
    if (bufferBaseAddress != 0) {
      FUN_18005db30(bufferBaseAddress);
    }
    do {
      systemOffset = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemOffset == 0);
    stackParameterA = &SystemGlobalDataReference;
    if (stackParameterB != (void* *)0x0) {
        SystemCleanupFunction();
    }
    stackParameterB = (void* *)0x0;
    UnsignedStackFlag88 = UnsignedStackFlag88 & 0xffffffff00000000;
    stackParameterA = &SystemMemoryAllocatorReference;
    pUnsignedStackFlagC0 = &SystemGlobalDataReference;
    if (pcurrentThreadId != (void* *)0x0) {
        SystemCleanupFunction(pcurrentThreadId);
    }
    systemStatus2 = (ulong long)bStackX_20;
  }
  return systemStatus2;
}




/**
 * @brief 系统资源配置和管理函数
 * 
 * 该函数负责系统资源的配置和管理，包括内存分配、字符处理、
 * 系统索引管理等操作
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @return 系统状态码
 * 
 * 原始函数名为FUN_18006ff80，现已重命名为ConfigureAndManageSystemResources
 */
ulong long ConfigureAndManageSystemResources(void* ResourceManagerPointer,void* ConfigurationDataPointer,char AdditionalParameter)

{
  code *systemFunctionPointer;
  long long localSystemHandle;
  char characterProcessingFlag;
  int systemIndex;
  int systemValue;
  uint8_t *resourceEntryPointer;
  long long localDataIndex;
  void* **pnewThreadLocalStorage;
  void* *punsignedSystemValue9;
  void* *pointerToUnsigned10;
  ulong long systemStatus1;
  void* *psystemStatus2;
  uint8_t systemStatus3;
  bool isByteValid4;
  bool isByteValid5;
  uint32_t systemStatus6;
  byte bStack_d8;
  void* *alternateBufferPtrB0;
  void* *pUnsignedStackFlagA8;
  uint32_t UnsignedStackFlagA0;
  ulong long unsignedValue98;
  void* *pStackParameterC;
  void* *pUnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  ulong long UnsignedStackFlag78;
  void* *pprocessFlags70;
  long long lStack_68;
  uint32_t processFlags58;
  void* *memoryAllocationEnd;
  long long lStack_48;
  uint32_t uStack_38;
  void* unsignedValue30;
  
  localSystemHandle = SystemAllocationFlagsTemplate;
  unsignedValue30 = 0xfffffffffffffffe;
  bStack_d8 = 0;
  resourceEntryPointer = (uint8_t *)register0x00000020;
  if (((SystemInitializationFlag == '\0') ||
      (resourceEntryPointer = (uint8_t *)FUN_1800f9600(ConfigurationDataPointer), (char)resourceEntryPointer != '\0')) ||
     (resourceEntryPointer = (uint8_t *)WaitForSingleObject(SystemSemaphoreHandle,0), (int)resourceEntryPointer != 0)) {
    return (ulong long)resourceEntryPointer & 0xffffffffffffff00;
  }
  if (localSystemHandle != 0) {
    FUN_18005dab0(localSystemHandle);
  }
  isByteValid4 = true;
  charFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((charFlag == '\0') && (systemIndex = IsDebuggerPresent(), systemIndex != 0)) {
    isByteValid5 = true;
  }
  else {
    isByteValid5 = false;
  }
  if (localSystemHandle != 0) {
    systemIndex = *(int *)(**(long long **)(localSystemHandle + 8) + 0x48);
    systemValue = _Thrd_id();
    isByteValid4 = systemValue == systemIndex;
  }
  psystemStatus2 = (void* *)0x0;
  if (!isByteValid5) {
    localDataIndex = FUN_1800f9ce0(&pprocessFlags70,0);
    psystemStatus2 = *(void* **)(localDataIndex + 8);
    *(uint32_t *)(localDataIndex + 0x10) = 0;
    *(void* *)(localDataIndex + 8) = 0;
    *(void* *)(localDataIndex + 0x18) = 0;
    pprocessFlags70 = &SystemGlobalDataReference;
    if (lStack_68 != 0) {
        SystemCleanupFunction();
    }
    lStack_68 = 0;
    processFlags58 = 0;
    pprocessFlags70 = &SystemMemoryAllocatorReference;
  }
  alternateBufferPtrB0 = &SystemGlobalDataReference;
  systemConfigurationValue = 0;
  pUnsignedStackFlagA8 = (void* *)0x0;
  UnsignedStackFlagA0 = 0;
  ConfigureSystemDataBuffer(&alternateBufferPtrB0,&SystemAlternateBufferTemplate,ConfigurationDataPointer);
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationTemplate);
  pointerToUnsigned10 = &SystemStringTemplate;
  if (pUnsignedStackFlagA8 != (void* *)0x0) {
    pointerToUnsigned10 = pUnsignedStackFlagA8;
  }
  FUN_180062380(SystemContextManagerPointer,2,0xffffffff00000000,&SystemStringTemplateBuffer,pointerToUnsigned10);
  if (SystemResourceFlagPtr != '\0') {
    pointerToUnsigned10 = &SystemStringTemplate;
    if (psystemStatus2 != (void* *)0x0) {
      pointerToUnsigned10 = psystemStatus2;
    }
    SystemManagerSetFlags(SystemContextManagerPointer,2,0xffffffff00000000,3,pointerToUnsigned10);
  }
  InitializeSystemManager();
  pointerToUnsigned10 = &SystemStringTemplate;
  if (pUnsignedStackFlagA8 != (void* *)0x0) {
    pointerToUnsigned10 = pUnsignedStackFlagA8;
  }
  OutputDebugStringA(pointerToUnsigned10);
  FUN_18004c2b0(ConfigurationDataPointer);
  if ((SystemInitializationFlag != '\0') && (isByteValid5)) {
    if ((*(char *)(SystemStatusFlagsPointer + 0x25) == '\0') &&
       ((AdditionalParameter != '\0' && (*(int *)(SystemStatusFlagsPointer + 0x340) != 2)))) {
      systemStatus1 = 1;
      bStack_d8 = 1;
      goto LAB_180070230;
    }
    if (SystemDebugFlag == '\0') {
      systemFunctionPointer = (code *)swi(3);
      systemStatus1 = (*systemFunctionPointer)();
      return systemStatus1;
    }
  }
  systemStatus1 = 0;
LAB_180070230:
  if (*(int *)(SystemMemoryBlockSecondary + 0x460) == 0) {
    if (SystemSilentMode == '\0') {
      if (isByteValid4) {
        if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
          ValidateSystemResourceStatus(*(long long *)(SystemStatusFlagsPointer + 8));
        }
        localDataIndex = SystemRenderManagerPointer;
        if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
          ProcessSystemResourceAllocation(*(void* *)(SystemStatusFlagsPointer + 8),
                        *(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                        *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
          *(uint8_t *)(localDataIndex + 0x1609) = 1;
        }
      }
      if (((SystemInitializationFlag == '\0') || (systemIndex = IsDebuggerPresent(), systemIndex != 0)) &&
         (SystemSilentMode == '\0')) {
        MessageBoxA(0,ConfigurationDataPointer,&SystemErrorMessageTemplate,0x41030);
      }
      else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
        SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,&SystemErrorMessageTemplate,ConfigurationDataPointer)
        ;
      }
    }
    else if (SystemInitializationFlag == '\0') {
      FUN_1806272a0(&SystemWarningTemplate,ConfigurationDataPointer);
    }
    systemIndex = FUN_1800f98e0(ConfigurationDataPointer);
    if ((!isByteValid5) && (systemIndex == 0)) {
      isByteValid5 = SystemStatusFlagsPointer == 0;
      if (isByteValid5) {
        systemStatus3 = 0;
        pSystemConfigurationValue = &SystemGlobalDataReference;
        UnsignedStackFlag78 = 0;
        pUnsignedStackFlag88 = (void* *)0x0;
        UnsignedStackFlag80 = 0;
        punsignedSystemValue9 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x34,0x13);
        *(uint8_t *)punsignedSystemValue9 = 0;
        pUnsignedStackFlag88 = punsignedSystemValue9;
        systemStatus6 = StartSystemThread(punsignedSystemValue9);
        UnsignedStackFlag78 = CONCAT44(UnsignedStackFlag78._4_4_,systemStatus6);
        *punsignedSystemValue9 = 0x7270706d75645c5c;
        punsignedSystemValue9[1] = 0x2e726f737365636f;
        punsignedSystemValue9[2] = 0x6c726f77656c6174;
        punsignedSystemValue9[3] = 0x445c6d6f632e7364;
        *(uint32_t *)(punsignedSystemValue9 + 4) = 0x50706d75;
        *(uint32_t *)((long long)punsignedSystemValue9 + 0x24) = 0x65636f72;
        *(uint32_t *)(punsignedSystemValue9 + 5) = 0x6e697373;
        *(uint32_t *)((long long)punsignedSystemValue9 + 0x2c) = 0x6c6f4667;
        *(uint32_t *)(punsignedSystemValue9 + 6) = 0x726564;
        UnsignedStackFlag80 = 0x33;
        pnewThreadLocalStorage = &pStackParameterC;
      }
      else {
        systemStatus3 = *(uint8_t *)(SystemStatusFlagsPointer + 0x141);
        pnewThreadLocalStorage = (void* **)CreateSystemObject(&memoryAllocationEnd,SystemStatusFlagsPointer + 0x148);
        punsignedSystemValue9 = pUnsignedStackFlag88;
      }
      systemStatus6 = CreateSystemObject(&pprocessFlags70,pnewThreadLocalStorage);
      if (isByteValid5) {
        pSystemConfigurationValue = &SystemGlobalDataReference;
        if (punsignedSystemValue9 != (void* *)0x0) {
            SystemCleanupFunction(punsignedSystemValue9);
        }
        pUnsignedStackFlag88 = (void* *)0x0;
        UnsignedStackFlag78 = UnsignedStackFlag78 & 0xffffffff00000000;
        pSystemConfigurationValue = &SystemMemoryAllocatorReference;
      }
      if (!isByteValid5) {
        memoryAllocationEnd = &SystemGlobalDataReference;
        if (lStack_48 != 0) {
            SystemCleanupFunction();
        }
        lStack_48 = 0;
        uStack_38 = 0;
        memoryAllocationEnd = &SystemMemoryAllocatorReference;
      }
      pointerToUnsigned10 = &SystemStringTemplate;
      if (psystemStatus2 != (void* *)0x0) {
        pointerToUnsigned10 = psystemStatus2;
      }
      FUN_180066320(systemStatus6,&pprocessFlags70,systemStatus3,0,pointerToUnsigned10);
      pprocessFlags70 = &SystemGlobalDataReference;
      if (lStack_68 != 0) {
          SystemCleanupFunction();
      }
      lStack_68 = 0;
      processFlags58 = 0;
      pprocessFlags70 = &SystemMemoryAllocatorReference;
    }
    FUN_1800f96b0(ConfigurationDataPointer,0);
    if (SystemStatusFlagsPointer == 0) {
      charFlag = '\x01';
    }
    else {
      charFlag = *(char *)(SystemStatusFlagsPointer + 0x29);
    }
    if (*(char *)(SystemStatusFlagsPointer + 0x25) != '\0') {
      FUN_180055f70(SystemStatusFlagsPointer,5);
      systemFunctionPointer = (code *)swi(3);
      systemStatus1 = (*systemFunctionPointer)();
      return systemStatus1;
    }
    if (charFlag != '\0') {
      SystemGlobalStateStorage = 5;
    }
    if ((SystemSilentMode == '\0') && (isByteValid4)) {
      if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
        CleanupSystemResources();
      }
      if (SystemRenderManagerPointer != 0) {
        FUN_180092940(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
      }
    }
    if (localSystemHandle != 0) {
      FUN_18005db30(localSystemHandle);
    }
    do {
      systemIndex = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemIndex == 0);
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    if (pUnsignedStackFlagA8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pUnsignedStackFlagA8 = (void* *)0x0;
    unsignedValue98 = unsignedValue98 & 0xffffffff00000000;
    alternateBufferPtrB0 = &SystemMemoryAllocatorReference;
    if (psystemStatus2 != (void* *)0x0) {
        SystemCleanupFunction(psystemStatus2);
    }
    systemStatus1 = (ulong long)bStack_d8;
  }
  else {
    if (*(int *)(SystemMemoryBlockSecondary + 0x460) == 1) {
      FUN_1806272a0(&SystemRuntimeConfigurationData,ConfigurationDataPointer);
    }
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    if (pUnsignedStackFlagA8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pUnsignedStackFlagA8 = (void* *)0x0;
    unsignedValue98 = unsignedValue98 & 0xffffffff00000000;
    alternateBufferPtrB0 = &SystemMemoryAllocatorReference;
    if (psystemStatus2 != (void* *)0x0) {
        SystemCleanupFunction(psystemStatus2);
    }
  }
  return systemStatus1;
}





/**
 * @brief 初始化资源管理器配置
 * 
 * 该函数负责初始化资源管理器的配置参数，设置系统资源管理的相关属性
 * 用于系统资源管理的前期准备工作
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180070680，现已重命名为InitializeResourceManagerConfiguration
 */
void InitializeResourceManagerConfiguration(void* ResourceManagerPointer,void* ConfigurationDataPointer)

{
  bool isDebuggerPresent;
  char validationStatusFlag;
  int memoryComparisonResult;
  int systemIndex;
  long long systemTimeValue;
  void* *resourceEntryPointer;
  void* unsignedSystemValue7;
  void* *newThreadLocalStorage;
  bool isSystemBusy;
  void* *systemStackPointer70;
  void* *encryptionValuePointer68;
  uint32_t systemStackValue60;
  void* systemStackValue58;
  void* *memoryAllocationEnd;
  long long systemStackValue48;
  uint32_t systemStackValue38;
  
  systemCounter = WaitForSingleObject(SystemSemaphoreHandle,0);
  if (systemCounter != 0) {
    return;
  }
  isSystemBusy = true;
  charResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((charResult == '\0') && (systemCounter = IsDebuggerPresent(), systemCounter != 0)) {
    isByteValid = true;
  }
  else {
    isByteValid = false;
  }
  if (SystemAllocationFlagsTemplate != 0) {
    systemCounter = *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
    systemIndex = _Thrd_id();
    isSystemBusy = systemIndex == systemCounter;
  }
  newThreadLocalStorage = (void* *)0x0;
  if (!isByteValid) {
    localSystemPointer = FUN_1800f9ce0(&memoryAllocationEnd,0);
    newThreadLocalStorage = *(void* **)(localSystemPointer + 8);
    *(uint32_t *)(localSystemPointer + 0x10) = 0;
    *(void* *)(localSystemPointer + 8) = 0;
    *(void* *)(localSystemPointer + 0x18) = 0;
    memoryAllocationEnd = &SystemGlobalDataReference;
    if (lStack_48 != 0) {
        SystemCleanupFunction();
    }
    lStack_48 = 0;
    uStack_38 = 0;
    memoryAllocationEnd = &SystemMemoryAllocatorReference;
  }
  pprocessFlags70 = &SystemGlobalDataReference;
  processFlags58 = 0;
  pEncryptionValue68 = (void* *)0x0;
  unsignedValue60 = 0;
  ConfigureSystemDataBuffer(&pprocessFlags70,&SystemConfigurationTemplateA,ConfigurationDataPointer);
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferA);
  resourceEntryPointer = &SystemStringTemplate;
  if (pEncryptionValue68 != (void* *)0x0) {
    resourceEntryPointer = pEncryptionValue68;
  }
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferB,resourceEntryPointer);
  resourceEntryPointer = &SystemStringTemplate;
  if (newThreadLocalStorage != (void* *)0x0) {
    SystemCurrentNode = SystemNextNode;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffff00000000,3,resourceEntryPointer);
  InitializeSystemManager();
  newThreadLocalStorage = &SystemStringTemplate;
  if (pEncryptionValue68 != (void* *)0x0) {
    newThreadLocalStorage = pEncryptionValue68;
  }
  OutputDebugStringA(newThreadLocalStorage);
  localSystemPointer = SystemRenderManagerPointer;
  if (((isSystemBusy) && (SystemRenderManagerPointer != 0)) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
    ProcessSystemResourceAllocation(*(void* *)(SystemStatusFlagsPointer + 8),*(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                  *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
    *(uint8_t *)(localSystemPointer + 0x1609) = 1;
  }
  if (SystemSilentMode == '\0') {
    FUN_1800f93e0();
  }
  else {
    unsignedSystemValue7 = GetSystemStatusFlagsInternal(&pprocessFlags70);
    FUN_1806272a0(unsignedSystemValue7);
  }
  InitializeSystemData(&SystemInitializationDataPtr,1);
  _Exit(5);
  return;
}



000180070cdc)
000180070ce2)


/**
 * @brief 初始化系统数据结构
 * 
 * 该函数负责初始化系统的核心数据结构
 * 包括内存管理、资源分配和系统配置
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @param ControlFlag 控制标志
 * @param SystemStatus 系统状态
 * 
 * 原始函数名为FUN_180070930，现已重命名为InitializeSystemDataStructure
 */
void InitializeSystemDataStructure(void* ResourceManagerPointer,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag,
                  char ControlFlag,char SystemStatus)

{
  code *systemFunctionPointer;
  bool isSystemActive;
  char characterProcessingFlag;
  int systemIndex;
  uint currentThreadId;
  uint hashValue;
  uint32_t unsignedSystemValue7;
  int systemCode;
  long long resourceCounter;
  uint8_t *pointerToUnsigned10;
  void* *ThreadLocalStorage;
  uint8_t *psystemStatus2;
  byte isByteValid3;
  uint systemStatus4;
  long long nextDataIndex5;
  long long nextDataIndex6;
  void* *pointerToUnsigned18;
  ulong long systemStatus9;
  uint8_t aunsignedValue188 [32];
  uint8_t *puStack_168;
  void* *puStack_160;
  uint8_t *puStack_158;
  uint8_t uStack_148;
  char cStack_147;
  void* *puStack_140;
  uint8_t *systemMemoryContext;
  uint uStack_130;
  ulong long uStack_128;
  char controlFlag;
  char validationFlag;
  uint32_t uStack_11c;
  void* *pUnsignedStackFlag118;
  uint8_t *pUnsignedStackFlag110;
  uint unsignedValue108;
  void* unsignedValue100;
  void* *punsignedValueF8;
  void* *puStack_f0;
  uint32_t uStack_e0;
  void* *punsignedValueD8;
  long long lStack_d0;
  uint32_t UnsignedStackFlagC0;
  uint32_t unsignedValue98;
  uint32_t uStack_94;
  long long lStack_90;
  long long lStack_88;
  void* unsignedValue60;
  void* processFlags58;
  void* unsignedValue50;
  ulong long EncryptionValue48;
  long long nextDataIndex7;
  
  unsignedValue60 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValue188;
  controlFlag = ControlFlag;
  pointerToUnsigned10 = (uint8_t *)0x0;
  systemStatus4 = 0;
  uStack_11c = 0;
  uStack_148 = 0;
  processFlags58 = 0;
  unsignedValue50 = 0;
  unsignedValue98 = AdditionalParameter;
  lStack_88 = ConfigurationFlag;
  FUN_1800634b0(&processFlags58,0x10,&SystemDataBufferTemplateI,AdditionalParameter);
  resourceCounter = ProcessSystemQueue(&punsignedValueD8,ConfigurationFlag);
  pUnsignedStackFlag118 = &SystemGlobalDataReference;
  unsignedValue100 = 0;
  pUnsignedStackFlag110 = (uint8_t *)0x0;
  unsignedValue108 = 0;
  uStack_11c = 4;
  hashValue = *(uint *)(resourceCounter + 0x10);
  systemStatus9 = (ulong long)hashValue;
  currentThreadId = 0;
  if (*(long long *)(resourceCounter + 8) == 0) {
LAB_180070a3f:
    systemStatus4 = currentThreadId;
    if (hashValue != 0) {
        memcpy(pointerToUnsigned10,*(void* *)(resourceCounter + 8),systemStatus9);
    }
  }
  else if (hashValue != 0) {
    systemIndex = hashValue + 1;
    if (systemIndex < 0x10) {
      systemIndex = 0x10;
    }
    pointerToUnsigned10 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemIndex,0x13);
    *pointerToUnsigned10 = 0;
    pUnsignedStackFlag110 = pointerToUnsigned10;
    currentThreadId = StartSystemThread(pointerToUnsigned10);
    unsignedValue100 = CONCAT44(unsignedValue100._4_4_,currentThreadId);
    goto LAB_180070a3f;
  }
  if (pointerToUnsigned10 != (uint8_t *)0x0) {
    pointerToUnsigned10[systemStatus9] = 0;
  }
  currentThreadId = *(uint *)(resourceCounter + 0x1c);
  unsignedValue108 = hashValue;
  unsignedValue100._4_4_ = currentThreadId;
  if (ConfigurationDataPointer != 0) {
    resourceCounter = -1;
    do {
      nextDataIndex5 = resourceCounter;
      resourceCounter = nextDataIndex5 + 1;
    } while (*(char *)(ConfigurationDataPointer + resourceCounter) != '\0');
    if (0 < (int)resourceCounter) {
      systemIndex = hashValue + (int)resourceCounter;
      if (systemIndex != 0) {
        hashValue = systemIndex + 1;
        if (pointerToUnsigned10 == (uint8_t *)0x0) {
          if ((int)hashValue < 0x10) {
            hashValue = 0x10;
          }
          pointerToUnsigned10 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)hashValue,0x13);
          *pointerToUnsigned10 = 0;
        }
        else {
          if (hashValue <= systemStatus4) goto LAB_180070b00;
          puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
          pointerToUnsigned10 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,pointerToUnsigned10,hashValue,0x10);
        }
        pUnsignedStackFlag110 = pointerToUnsigned10;
        unsignedValue100._0_4_ = StartSystemThread(pointerToUnsigned10);
      }
LAB_180070b00:
        memcpy(pointerToUnsigned10 + systemStatus9,ConfigurationDataPointer,(long long)((int)nextDataIndex5 + 2));
    }
  }
  FUN_180627e10(&pUnsignedStackFlag118,&punsignedValueF8,&processFlags58);
  uStack_94 = 0;
  uStack_11c = 0;
  pUnsignedStackFlag118 = &SystemGlobalDataReference;
  if (pointerToUnsigned10 != (uint8_t *)0x0) {
      SystemCleanupFunction(pointerToUnsigned10);
  }
  pUnsignedStackFlag110 = (uint8_t *)0x0;
  unsignedValue100 = (ulong long)unsignedValue100._4_4_ << 0x20;
  pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
  punsignedValueD8 = &SystemGlobalDataReference;
  if (lStack_d0 != 0) {
      SystemCleanupFunction();
  }
  lStack_d0 = 0;
  UnsignedStackFlagC0 = 0;
  punsignedValueD8 = &SystemMemoryAllocatorReference;
  pointerToUnsigned18 = &SystemStringTemplate;
  if (puStack_f0 != (void* *)0x0) {
    pointerToUnsigned18 = puStack_f0;
  }
  charFlag = FUN_1800f9600(pointerToUnsigned18);
  if (charFlag != '\0') {
    punsignedValueF8 = &SystemGlobalDataReference;
    if (puStack_f0 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    goto LAB_1800718e9;
  }
  systemIndex = WaitForSingleObject(SystemSemaphoreHandle,1);
  resourceCounter = SystemAllocationFlagsTemplate;
  if (systemIndex != 0) {
    punsignedValueF8 = &SystemGlobalDataReference;
    if (puStack_f0 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    goto LAB_1800718e9;
  }
  lStack_90 = SystemAllocationFlagsTemplate;
  puStack_140 = &SystemGlobalDataReference;
  uStack_128 = 0;
  systemMemoryContext = (uint8_t *)0x0;
  uStack_130 = 0;
  pointerToUnsigned18 = &SystemRootDataPtr;
  if (controlFlag != '\0') {
    pointerToUnsigned18 = &SystemStatusDataPointer;
  }
  nextDataIndex5 = -1;
  do {
    nextDataIndex6 = nextDataIndex5;
    nextDataIndex5 = nextDataIndex6 + 1;
  } while (pointerToUnsigned18[nextDataIndex5] != '\0');
  systemIndex = (int)nextDataIndex5;
  if (0 < systemIndex) {
    if (systemIndex != 0) {
      systemIndex = systemIndex + 1;
      if (systemIndex < 0x10) {
        systemIndex = 0x10;
      }
      systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemIndex,0x13);
      *systemMemoryContext = 0;
      unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
      uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
    }
      memcpy(systemMemoryContext + uStack_130,pointerToUnsigned18,(long long)((int)nextDataIndex6 + 2));
  }
  systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
  *systemMemoryContext = 0;
  currentThreadId = StartSystemThread(systemMemoryContext);
  uStack_128 = CONCAT44(uStack_128._4_4_,currentThreadId);
  *(void*2 *)(systemMemoryContext + uStack_130) = 10;
  uStack_130 = 1;
  hashValue = 2;
  if (systemMemoryContext == (uint8_t *)0x0) {
    uStack_130 = 1;
    systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
    *systemMemoryContext = 0;
LAB_180070db8:
    unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
    uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
  }
  else if (currentThreadId < 3) {
    puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
    uStack_130 = 1;
    systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,3,0x10);
    goto LAB_180070db8;
  }
  *(void*2 *)(systemMemoryContext + uStack_130) = 10;
  uStack_130 = 2;
  if (ConfigurationDataPointer != 0) {
    nextDataIndex5 = -1;
    do {
      nextDataIndex6 = nextDataIndex5;
      nextDataIndex5 = nextDataIndex6 + 1;
    } while (*(char *)(ConfigurationDataPointer + nextDataIndex5) != '\0');
    systemIndex = (int)nextDataIndex5;
    if (0 < systemIndex) {
      currentThreadId = hashValue;
      if (systemIndex != -2) {
        systemStatus4 = systemIndex + 3;
        if (systemMemoryContext == (uint8_t *)0x0) {
          if ((int)systemStatus4 < 0x10) {
            systemStatus4 = 0x10;
          }
          uStack_130 = hashValue;
          systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemStatus4,0x13);
          *systemMemoryContext = 0;
        }
        else {
          currentThreadId = uStack_130;
          if (systemStatus4 <= (uint)uStack_128) goto LAB_180070e64;
          puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
          uStack_130 = hashValue;
          systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,systemStatus4,0x10);
        }
        unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
        uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
        currentThreadId = uStack_130;
      }
LAB_180070e64:
      uStack_130 = currentThreadId;
        memcpy(systemMemoryContext + uStack_130,ConfigurationDataPointer,(long long)((int)nextDataIndex6 + 2));
    }
  }
  if (systemMemoryContext == (uint8_t *)0x0) {
    uStack_130 = hashValue;
    systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
    *systemMemoryContext = 0;
LAB_180070ee8:
    unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
    uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
  }
  else if ((uint)uStack_128 < 4) {
    puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
    uStack_130 = hashValue;
    systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,4,0x10);
    goto LAB_180070ee8;
  }
  *(void*2 *)(systemMemoryContext + uStack_130) = 0x3a;
  uStack_130 = 3;
  ProcessSystemData(&puStack_140,unsignedValue98);
  hashValue = uStack_130;
  currentThreadId = uStack_130 + 1;
  if (currentThreadId != 0) {
    systemStatus4 = uStack_130 + 2;
    if (systemMemoryContext == (uint8_t *)0x0) {
      if ((int)systemStatus4 < 0x10) {
        systemStatus4 = 0x10;
      }
      systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemStatus4,0x13);
      *systemMemoryContext = 0;
    }
    else {
      if (systemStatus4 <= (uint)uStack_128) goto LAB_180070f81;
      puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
      systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,systemStatus4,0x10);
    }
    unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
    uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
  }
LAB_180070f81:
  *(void*2 *)(systemMemoryContext + uStack_130) = 10;
  systemStatus4 = hashValue + 0xd;
  uStack_130 = currentThreadId;
  if (systemStatus4 != 0) {
    currentThreadId = hashValue + 0xe;
    if (systemMemoryContext == (uint8_t *)0x0) {
      if ((int)currentThreadId < 0x10) {
        currentThreadId = 0x10;
      }
      systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)currentThreadId,0x13);
      *systemMemoryContext = 0;
    }
    else {
      if (currentThreadId <= (uint)uStack_128) goto LAB_180071000;
      puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
      systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,currentThreadId,0x10);
    }
    unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
    uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
  }
LAB_180071000:
  nextDataIndex5 = lStack_88;
  ThreadLocalStorage = (void* *)(systemMemoryContext + uStack_130);
  *ThreadLocalStorage = 0x6973736572707845;
  *(uint32_t *)(ThreadLocalStorage + 1) = 0x203a6e6f;
  *(uint8_t *)((long long)ThreadLocalStorage + 0xc) = 0;
  nextDataIndex6 = -1;
  uStack_130 = systemStatus4;
  if (lStack_88 != 0) {
    do {
      nextDataIndex7 = nextDataIndex6;
      nextDataIndex6 = nextDataIndex7 + 1;
    } while (*(char *)(lStack_88 + nextDataIndex6) != '\0');
    if (0 < (int)nextDataIndex6) {
      systemIndex = systemStatus4 + (int)nextDataIndex6;
      if (systemIndex != 0) {
        hashValue = systemIndex + 1;
        if (systemMemoryContext == (uint8_t *)0x0) {
          if ((int)hashValue < 0x10) {
            hashValue = 0x10;
          }
          systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)hashValue,0x13);
          *systemMemoryContext = 0;
        }
        else {
          if (hashValue <= (uint)uStack_128) goto LAB_1800710b8;
          puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
          systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,hashValue,0x10);
        }
        unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
        uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
      }
LAB_1800710b8:
        memcpy(systemMemoryContext + uStack_130,nextDataIndex5,(long long)((int)nextDataIndex7 + 2));
    }
  }
  systemIndex = hashValue + 0xe;
  if (systemIndex != 0) {
    hashValue = hashValue + 0xf;
    if (systemMemoryContext == (uint8_t *)0x0) {
      if ((int)hashValue < 0x10) {
        hashValue = 0x10;
      }
      systemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)hashValue,0x13);
      *systemMemoryContext = 0;
    }
    else {
      if (hashValue <= (uint)uStack_128) goto LAB_18007113f;
      puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
      systemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,systemMemoryContext,hashValue,0x10);
    }
    unsignedSystemValue7 = StartSystemThread(systemMemoryContext);
    uStack_128 = CONCAT44(uStack_128._4_4_,unsignedSystemValue7);
  }
LAB_18007113f:
  *(void*2 *)(systemMemoryContext + uStack_130) = 10;
  uStack_130 = systemIndex;
  if (resourceCounter != 0) {
    FUN_18005dab0(resourceCounter);
  }
  isByteValid3 = 1;
  validationFlag = '\x01';
  charFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((charFlag != '\0') || (systemIndex = IsDebuggerPresent(), systemIndex == 0)) {
    isByteValid3 = 0;
  }
  if (SystemStatusFlagsPointer == 0) {
    cStack_147 = '\0';
  }
  else {
    cStack_147 = *(char *)(SystemStatusFlagsPointer + 0x24);
  }
  isSystemActive = true;
  if (resourceCounter != 0) {
    systemIndex = *(int *)(**(long long **)(resourceCounter + 8) + 0x48);
    systemCode = _Thrd_id();
    validationFlag = systemCode == systemIndex;
    isSystemActive = (bool)validationFlag;
  }
  resourceCounter = SystemRenderManagerPointer;
  if ((SystemSilentMode == '\0') && (isSystemActive)) {
    if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
      ProcessSystemResourceAllocation(*(void* *)(SystemStatusFlagsPointer + 8),*(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                    *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
      *(uint8_t *)(resourceCounter + 0x1609) = 1;
    }
    if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
      ValidateSystemResourceStatus();
    }
  }
  pUnsignedStackFlag118 = &SystemGlobalDataReference;
  unsignedValue100 = 0;
  pUnsignedStackFlag110 = (uint8_t *)0x0;
  unsignedValue108 = 0;
  if (isByteValid3 == 0) {
    resourceCounter = FUN_1800f9ce0(&punsignedValueD8,0);
    unsignedValue108 = *(uint *)(resourceCounter + 0x10);
    pUnsignedStackFlag110 = *(uint8_t **)(resourceCounter + 8);
    unsignedValue100 = *(ulong long *)(resourceCounter + 0x18);
    *(uint32_t *)(resourceCounter + 0x10) = 0;
    *(void* *)(resourceCounter + 8) = 0;
    *(void* *)(resourceCounter + 0x18) = 0;
    punsignedValueD8 = &SystemGlobalDataReference;
    if (lStack_d0 != 0) {
        SystemCleanupFunction();
    }
    lStack_d0 = 0;
    UnsignedStackFlagC0 = 0;
    punsignedValueD8 = &SystemMemoryAllocatorReference;
  }
  pointerToUnsigned10 = pUnsignedStackFlag110;
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferA);
  puStack_168 = &SystemStringTemplate;
  if (systemMemoryContext != (uint8_t *)0x0) {
    puStack_168 = systemMemoryContext;
  }
  FUN_180062380(SystemContextManagerPointer,4,0xffffffff00000000,&SystemConfigurationDataBufferB);
  puStack_168 = &SystemStringTemplate;
  if (pointerToUnsigned10 != (uint8_t *)0x0) {
    puStack_168 = pointerToUnsigned10;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,4,0xffffffff00000000,3);
  InitializeSystemManager();
  psystemStatus2 = &SystemStringTemplate;
  if (systemMemoryContext != (uint8_t *)0x0) {
    psystemStatus2 = systemMemoryContext;
  }
  OutputDebugStringA(psystemStatus2);
  FUN_18004c2b0(nextDataIndex5);
  if (SystemInitializationFlag != '\0') {
    if (isByteValid3 != 0) {
      if (((cStack_147 == '\0') && (SystemStatus != '\0')) && (*(int *)(SystemStatusFlagsPointer + 0x340) != 2)) {
        uStack_148 = 1;
      }
      else if (SystemDebugFlag == '\0') {
        systemFunctionPointer = (code *)swi(3);
        (*systemFunctionPointer)();
        return;
      }
    }
    if ((SystemInitializationFlag == 0) || (*(int *)(SystemInitializationFlag + 0x168) == 2)) {
      FUN_180062380(SystemContextManagerPointer,4,0xffffffff00000000,&SystemSecurityDataBuffer);
      InitializeSystemManager();
      systemIndex = IsDebuggerPresent();
      if ((systemIndex != 0) && (SystemDebugFlag == '\0')) {
        systemFunctionPointer = (code *)swi(3);
        (*systemFunctionPointer)();
        return;
      }
    }
  }
  if (SystemSilentMode == '\0') {
    pointerToUnsigned18 = &SystemThreadDataPointer;
    if (controlFlag != '\0') {
      pointerToUnsigned18 = &SystemProcessDataPointer;
    }
    do {
      while( true ) {
        psystemStatus2 = &SystemStringTemplate;
        if (systemMemoryContext != (uint8_t *)0x0) {
          psystemStatus2 = systemMemoryContext;
        }
        if (((SystemInitializationFlag == '\0') || (systemIndex = IsDebuggerPresent(), systemIndex != 0)) &&
           (SystemSilentMode == '\0')) break;
        if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
          puStack_168 = &SystemStackDataTemplate1;
          puStack_160 = pointerToUnsigned18;
          puStack_158 = psystemStatus2;
          SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd);
        }
      }
      unsignedSystemValue7 = MessageBoxA(0,psystemStatus2,pointerToUnsigned18,0x52012);
      switch(unsignedSystemValue7) {
      case 1:
        systemIndex = 0;
        break;
      default:
        systemIndex = 1;
        break;
      case 4:
        systemIndex = 2;
        break;
      case 5:
        systemIndex = 3;
        break;
      case 6:
        systemIndex = 4;
        break;
      case 7:
        systemIndex = 5;
      }
    } while (systemIndex == 1);
    if (systemIndex == 2) {
      if (isByteValid3 == 0) {
        psystemStatus2 = &SystemStringTemplate;
        if (pointerToUnsigned10 != (uint8_t *)0x0) {
          psystemStatus2 = pointerToUnsigned10;
        }
        if (((SystemInitializationFlag == '\0') || (systemIndex = IsDebuggerPresent(), systemIndex != 0)) &&
           (SystemSilentMode == '\0')) {
          MessageBoxA(0,psystemStatus2,&SystemErrorMessageBuffer,0x41010);
        }
        else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
          puStack_160 = &SystemErrorMessageBuffer;
          puStack_168 = &SystemStackDataTemplate1;
          puStack_158 = psystemStatus2;
          SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd);
        }
      }
      else if (((SystemStatus == '\0') || (*(int *)(SystemStatusFlagsPointer + 0x340) == 2)) &&
              (SystemDebugFlag == '\0')) {
        systemFunctionPointer = (code *)swi(3);
        (*systemFunctionPointer)();
        return;
      }
    }
    else if (systemIndex == 3) goto LAB_1800715eb;
    if (SystemStatusFlagsPointer == 0) {
      charFlag = '\x01';
    }
    else {
      charFlag = *(char *)(SystemStatusFlagsPointer + 0x29);
    }
    if (cStack_147 != '\0') {
      FUN_180055f70(charFlag,5);
      systemFunctionPointer = (code *)swi(3);
      (*systemFunctionPointer)();
      return;
    }
    if (charFlag != '\0') {
      SystemGlobalStateStorage = 5;
    }
    if ((SystemSilentMode == '\0') && (validationFlag != '\0')) {
      if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
        CleanupSystemResources();
      }
      if (SystemRenderManagerPointer != 0) {
        FUN_180092940(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
      }
    }
    if (lStack_90 != 0) {
      FUN_18005db30();
    }
    do {
      systemIndex = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemIndex == 0);
    pUnsignedStackFlag118 = &SystemGlobalDataReference;
    if (pointerToUnsigned10 != (uint8_t *)0x0) {
        SystemCleanupFunction(pointerToUnsigned10);
    }
    pUnsignedStackFlag110 = (uint8_t *)0x0;
    unsignedValue100 = unsignedValue100 & 0xffffffff00000000;
    pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
    puStack_140 = &SystemGlobalDataReference;
    if (systemMemoryContext != (uint8_t *)0x0) {
        SystemCleanupFunction();
    }
    systemMemoryContext = (uint8_t *)0x0;
    uStack_128 = uStack_128 & 0xffffffff00000000;
    puStack_140 = &SystemMemoryAllocatorReference;
    punsignedValueF8 = &SystemGlobalDataReference;
    if (puStack_f0 != (void* *)0x0) {
        SystemCleanupFunction();
    }
LAB_1800718e9:
    uStack_e0 = 0;
    puStack_f0 = (void* *)0x0;
    punsignedValueF8 = &SystemMemoryAllocatorReference;
      ValidateSystemChecksum(EncryptionValue48 ^ (ulong long)aunsignedValue188);
  }
LAB_1800715eb:
  pointerToUnsigned18 = &SystemStringTemplate;
  if (puStack_f0 != (void* *)0x0) {
    pointerToUnsigned18 = puStack_f0;
  }
  unsignedSystemValue7 = FUN_1800f98e0(pointerToUnsigned18);
    UpdateContextManagerSystem(SystemContextManagerPointer,&UNK_1809ff6e0,isByteValid3 ^ 1,unsignedSystemValue7);
}



000180071b49)
000180071ad3)
000180071a52)
000180071c73)


/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括线程创建、内存分配和资源配置
 * 用于系统资源的统一管理和调度
 * 
 * @param ResourceManagerPointer 资源管理器指针，指向要初始化的资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含资源配置的相关信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @param ConfigurationFlag 配置标志，指定初始化的方式和选项
 * @return 无返回值
 * 
 * 原始函数名为FUN_180071940，现已重命名为InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(void* ResourceManagerPointer,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag)

{
  int systemStatus;
  uint threadCreationFlags;
  uint32_t memoryAllocationContext;
  long long systemBufferAddress;
  void* *threadIdPointer;
  uint32_t *resourceEntryPointer;
  void** systemCurrentNode;
  uint8_t *threadLocalStorage;
  void* *systemValuePointer;
  long long memoryAllocationFlags;
  uint systemOperationStatus1;
  uint systemOperationStatus2;
  void* *stackParameterPointer;
  uint8_t *threadObjectPointer;
  uint stackParameterOffset;
  ulong long threadHandleValue;
  void* *globalDataPointer;
  void* *encryptionKeyPointer;
  uint32_t bufferFlags;
  void* bufferDataPointer;
  void* *memoryAllocationEndPointer;
  long long debugFlag;
  uint32_t allocationSize;
  
  systemStatus = WaitForSingleObject(SystemSemaphoreHandle,0);
  if (systemStatus != 0) {
    return;
  }
  systemValuePointer = (void* *)0x0;
  globalDataPointer = &SystemGlobalDataReference;
  bufferDataPointer = 0;
  encryptionKeyPointer = (void* *)0x0;
  bufferFlags = 0;
  systemStatus = IsDebuggerPresent();
  if (systemStatus == 0) {
    systemBufferAddress = GetSystemMemoryBuffer(&memoryAllocationEndPointer,0);
    bufferFlags = *(uint32_t *)(systemBufferAddress + 0x10);
    systemValuePointer = *(void* **)(systemBufferAddress + 8);
    bufferDataPointer = *(void* *)(systemBufferAddress + 0x18);
    *(uint32_t *)(systemBufferAddress + 0x10) = 0;
    *(void* *)(systemBufferAddress + 8) = 0;
    *(void* *)(systemBufferAddress + 0x18) = 0;
    memoryAllocationEndPointer = &SystemGlobalDataReference;
    encryptionKeyPointer = systemValuePointer;
    if (debugFlag != 0) {
        SystemCleanupFunction();
    }
    debugFlag = 0;
    allocationSize = 0;
    memoryAllocationEndPointer = &SystemMemoryAllocatorReference;
  }
  pSystemConfigurationValue = &SystemGlobalDataReference;
  threadHandleValue = 0;
  threadObjectPointer = (uint8_t *)0x0;
  stackParameterOffset = 0;
  threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x12,0x13);
  *threadObjectPointer = 0;
  threadCreationFlags = StartSystemThread(threadObjectPointer);
  threadHandleValue = CONCAT44(threadHandleValue._4_4_,threadCreationFlags);
  resourceEntryPointer = (uint32_t *)(threadObjectPointer + stackParameterOffset);
  *resourceEntryPointer = 0x65737341;
  resourceEntryPointer[1] = 0x6f697472;
  resourceEntryPointer[2] = 0x6146206e;
  resourceEntryPointer[3] = 0x64656c69;
  *(void*2 *)(systemCurrentNode + 4) = 0x21;
  stackParameterOffset = 0x11;
  if (threadObjectPointer == (uint8_t *)0x0) {
    stackParameterOffset = 0x11;
    threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x13,0x13);
    *threadObjectPointer = 0;
LAB_180071af3:
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = CONCAT44(threadHandleValue._4_4_,memoryAllocationContext);
  }
  else if (threadCreationFlags < 0x13) {
    stackParameterOffset = 0x11;
    threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,0x13,0x10,0x13);
    goto LAB_180071af3;
  }
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 10;
  stackParameterOffset = 0x12;
  threadCreationFlags = 0x13;
  if (threadObjectPointer == (uint8_t *)0x0) {
    stackParameterOffset = 0x12;
    threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x14,0x13);
    *threadObjectPointer = 0;
LAB_180071b69:
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = CONCAT44(threadHandleValue._4_4_,memoryAllocationContext);
  }
  else if ((uint)threadHandleValue < 0x14) {
    stackParameterOffset = 0x12;
    threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,0x14,0x10,0x13);
    goto LAB_180071b69;
  }
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 10;
  stackParameterOffset = 0x13;
  if (ConfigurationDataPointer != 0) {
    systemBufferAddress = -1;
    do {
      memoryAllocationFlags = systemBufferAddress;
      systemBufferAddress = memoryAllocationFlags + 1;
    } while (*(char *)(ConfigurationDataPointer + systemBufferAddress) != '\0');
    systemStatus = (int)systemBufferAddress;
    if (0 < systemStatus) {
      systemOperationStatus1 = threadCreationFlags;
      if (systemStatus != -0x13) {
        systemOperationStatus2 = systemStatus + 0x14;
        if (threadObjectPointer == (uint8_t *)0x0) {
          if ((int)systemOperationStatus2 < 0x10) {
            systemOperationStatus2 = 0x10;
          }
          stackParameterOffset = threadCreationFlags;
          threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemOperationStatus2,0x13);
          *threadObjectPointer = 0;
        }
        else {
          systemOperationStatus1 = stackParameterOffset;
          if (systemOperationStatus2 <= (uint)threadHandleValue) goto LAB_180071c1a;
          stackParameterOffset = threadCreationFlags;
          threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,systemOperationStatus2,0x10,0x13);
        }
        memoryAllocationContext = StartSystemThread(threadObjectPointer);
        threadHandleValue = CONCAT44(threadHandleValue._4_4_,memoryAllocationContext);
        systemOperationStatus1 = stackParameterOffset;
      }
LAB_180071c1a:
      stackParameterOffset = systemOperationStatus1;
        memcpy(threadObjectPointer + stackParameterOffset,ConfigurationDataPointer,(long long)((int)memoryAllocationFlags + 2));
    }
  }
  if (threadObjectPointer == (uint8_t *)0x0) {
    stackParameterOffset = threadCreationFlags;
    threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x15,0x13);
    *threadObjectPointer = 0;
LAB_180071c93:
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = CONCAT44(threadHandleValue._4_4_,memoryAllocationContext);
  }
  else if ((uint)threadHandleValue < 0x15) {
    stackParameterOffset = threadCreationFlags;
    threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,0x15,0x10,0x13);
    goto LAB_180071c93;
  }
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 0x3a;
  stackParameterOffset = 0x14;
  ProcessSystemData(&stackParameterPointer,AdditionalParameter);
  threadCreationFlags = stackParameterOffset;
  systemOperationStatus1 = stackParameterOffset + 1;
  if (systemOperationStatus1 != 0) {
    systemOperationStatus2 = stackParameterOffset + 2;
    if (threadObjectPointer == (uint8_t *)0x0) {
      if ((int)systemOperationStatus2 < 0x10) {
        systemOperationStatus2 = 0x10;
      }
      threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemOperationStatus2,0x13);
      *threadObjectPointer = 0;
    }
    else {
      if (systemOperationStatus2 <= (uint)threadHandleValue) goto LAB_180071d1f;
      threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,systemOperationStatus2,0x10,0x13);
    }
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = CONCAT44(threadHandleValue._4_4_,memoryAllocationContext);
  }
LAB_180071d1f:
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 10;
  systemOperationStatus2 = threadCreationFlags + 0xd;
  stackParameterOffset = systemOperationStatus1;
  if (systemOperationStatus2 != 0) {
    systemOperationStatus1 = threadCreationFlags + 0xe;
    if (threadObjectPointer == (uint8_t *)0x0) {
      if ((int)systemOperationStatus1 < 0x10) {
        systemOperationStatus1 = 0x10;
      }
      threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemOperationStatus1,0x13);
      *threadObjectPointer = 0;
    }
    else {
      if (systemOperationStatus1 <= (uint)threadHandleValue) goto LAB_180071d94;
      threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,systemOperationStatus1,0x10,0x13);
    }
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = CONCAT44(threadHandleValue._4_4_,memoryAllocationContext);
  }
LAB_180071d94:
  HashBucketNode = (void* *)(threadObjectPointer + stackParameterOffset);
  *HashBucketNode = 0x6973736572707845;
  *(uint32_t *)(HashBucketNode + 1) = 0x203a6e6f;
  *(uint8_t *)((long long)HashBucketNode + 0xc) = 0;
  bufferBaseAddress = -1;
  UnsignedStackFlag80 = systemStatus2;
  if (ConfigurationFlag != 0) {
    do {
      allocationFlags = bufferBaseAddress;
      bufferBaseAddress = allocationFlags + 1;
    } while (*(char *)(ConfigurationFlag + bufferBaseAddress) != '\0');
    if (0 < (int)bufferBaseAddress) {
      systemStatus = systemStatus2 + (int)bufferBaseAddress;
      if (systemStatus != 0) {
        creationFlags = systemStatus + 1;
        if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
          if ((int)creationFlags < 0x10) {
            creationFlags = 0x10;
          }
          pUnsignedStackFlag88 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)creationFlags,0x13);
          *pUnsignedStackFlag88 = 0;
        }
        else {
          if (creationFlags <= (uint)UnsignedStackFlag78) goto LAB_180071e34;
          pUnsignedStackFlag88 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,pUnsignedStackFlag88,creationFlags,0x10,0x13);
        }
        allocationContext = StartSystemThread(pUnsignedStackFlag88);
        UnsignedStackFlag78 = CONCAT44(UnsignedStackFlag78._4_4_,allocationContext);
      }
LAB_180071e34:
        memcpy(pUnsignedStackFlag88 + UnsignedStackFlag80,ConfigurationFlag,(long long)((int)allocationFlags + 2));
    }
  }
  if (creationFlags + 0xe != 0) {
    systemStatus1 = creationFlags + 0xf;
    if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
      if ((int)systemStatus1 < 0x10) {
        systemStatus1 = 0x10;
      }
      pUnsignedStackFlag88 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemStatus1,0x13);
      *pUnsignedStackFlag88 = 0;
    }
    else {
      if (systemStatus1 <= (uint)UnsignedStackFlag78) goto LAB_180071eb0;
      pUnsignedStackFlag88 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,pUnsignedStackFlag88,systemStatus1,0x10,0x13);
    }
    allocationContext = StartSystemThread(pUnsignedStackFlag88);
    UnsignedStackFlag78 = CONCAT44(UnsignedStackFlag78._4_4_,allocationContext);
  }
LAB_180071eb0:
  *(void*2 *)(pUnsignedStackFlag88 + UnsignedStackFlag80) = 10;
  UnsignedStackFlag80 = creationFlags + 0xe;
  FUN_180062380(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferA);
  newThreadLocalStorage = &SystemStringTemplate;
  if (pUnsignedStackFlag88 != (uint8_t *)0x0) {
    newThreadLocalStorage = pUnsignedStackFlag88;
  }
  FUN_180062380(SystemContextManagerPointer,4,0xffffffff00000000,&UNK_1809ff5b0,newThreadLocalStorage);
  pcurrentThreadId = &SystemStringTemplate;
  if (punsignedSystemValue9 != (void* *)0x0) {
    pcurrentThreadId = punsignedSystemValue9;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,4,0xffffffff00000000,3,pcurrentThreadId);
  InitializeSystemManager();
  newThreadLocalStorage = &SystemStringTemplate;
  if (pUnsignedStackFlag88 != (uint8_t *)0x0) {
    newThreadLocalStorage = pUnsignedStackFlag88;
  }
  OutputDebugStringA(newThreadLocalStorage);
  do {
    systemStatus = ReleaseSemaphore(SystemSemaphoreHandle,1);
  } while (systemStatus == 0);
  pSystemConfigurationValue = &SystemGlobalDataReference;
  if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
    pUnsignedStackFlag88 = (uint8_t *)0x0;
    UnsignedStackFlag78 = UnsignedStackFlag78 & 0xffffffff00000000;
    pSystemConfigurationValue = &SystemMemoryAllocatorReference;
    pprocessFlags70 = &SystemGlobalDataReference;
    if (punsignedSystemValue9 == (void* *)0x0) {
      return;
    }
      SystemCleanupFunction(punsignedSystemValue9);
  }
    SystemCleanupFunction();
}



00018007258a)
0001800724fe)
00018007246a)
0001800726c4)


// 函数: void FUN_180072000(void* ResourceManagerPointer,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag,
/**
 * @brief 系统资源操作处理函数
 * 
 * 该函数负责处理系统资源的各种操作，包括资源分配、数据处理和系统模式配置。
 * 函数会根据操作类型和系统模式执行相应的资源管理操作。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @param OperationType 操作类型
 * @param SystemMode 系统模式
 * 
 * 原始函数名为FUN_180072000，现已重命名为ProcessSystemResourceOperation
 */
void ProcessSystemResourceOperation(void* ResourceManagerPointer,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag,
                  uint8_t OperationType,char SystemMode)

{
  code *systemFunctionPointer;
  char validationStatusFlag;
  int MemoryComparisonResult;
  uint unsignedSystemValue4;
  int systemValue;
  uint hashValue;
  uint32_t unsignedSystemValue7;
  uint unsignedSystemValue8;
  long long resourceCounter;
  uint8_t *pointerToUnsigned10;
  void* **pThreadLocalStorage;
  uint32_t *psystemStatus2;
  void* *pointerToUnsigned13;
  uint8_t *pointerToUnsigned14;
  void* *ThreadLocalStorageEntry;
  uint systemStatus6;
  long long nextDataIndex7;
  uint8_t systemStatus8;
  ulong long systemStatus9;
  uint8_t auStack_168 [32];
  uint8_t *puStack_148;
  void* *systemMemoryContext;
  uint8_t *puStack_130;
  uint uStack_128;
  ulong long uStack_120;
  char cStack_118;
  char cStack_117;
  uint8_t uStack_116;
  uint uStack_114;
  void* *pUnsignedStackFlag110;
  uint8_t *punsignedValue108;
  uint unsignedValue100;
  void* unsignedValueF8;
  void* *puStack_f0;
  long long lStack_e8;
  uint32_t unsignedValueD8;
  void* *dataBufferContext;
  void* *pointerUnsignedC8;
  uint32_t UnsignedStackFlagC0;
  ulong long UnsignedStackFlagB8;
  uint32_t UnsignedStackFlagB0;
  void* *pUnsignedStackFlagA8;
  void* *SystemDataPointer;
  uint32_t SystemConfigurationValue;
  long long lStack_88;
  void* *pUnsignedStackFlag80;
  long long lStack_78;
  uint32_t EncryptionValue68;
  void* unsignedValue60;
  void* processFlags58;
  void* unsignedValue50;
  ulong long EncryptionValue48;
  
  unsignedValue60 = 0xfffffffffffffffe;
  EncryptionValue48 = SystemEncryptionKeyTemplate ^ (ulong long)auStack_168;
  pointerToUnsigned10 = (uint8_t *)0x0;
  uStack_114 = 0;
  uStack_116 = 0;
  UnsignedStackFlagB0 = AdditionalParameter;
  lStack_88 = ConfigurationFlag;
  if ((SystemInitializationFlag != '\0') || (SystemVerboseFlag != '\0')) goto LAB_180072d7b;
  processFlags58 = 0;
  unsignedValue50 = 0;
  FUN_1800634b0(&processFlags58,0x10,&SystemDataBufferTemplateI,AdditionalParameter);
  resourceCounter = ProcessSystemQueue(&puStack_f0,ConfigurationFlag);
  pUnsignedStackFlag110 = &SystemGlobalDataReference;
  systemStatus6 = 0;
  unsignedValueF8 = 0;
  punsignedValue108 = (uint8_t *)0x0;
  unsignedValue100 = 0;
  uStack_114 = 4;
  hashValue = *(uint *)(resourceCounter + 0x10);
  systemStatus9 = (ulong long)hashValue;
  unsignedSystemValue4 = 0;
  if (*(long long *)(resourceCounter + 8) == 0) {
LAB_180072120:
    systemStatus6 = unsignedSystemValue4;
    if (hashValue != 0) {
        memcpy(pointerToUnsigned10,*(void* *)(resourceCounter + 8),systemStatus9);
    }
  }
  else if (hashValue != 0) {
    systemCounter = hashValue + 1;
    if (MemoryCompareResult < 0x10) {
      systemCounter = 0x10;
    }
    pointerToUnsigned10 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCounter,0x13);
    *pointerToUnsigned10 = 0;
    punsignedValue108 = pointerToUnsigned10;
    unsignedSystemValue4 = StartSystemThread(pointerToUnsigned10);
    unsignedValueF8 = CONCAT44(unsignedValueF8._4_4_,unsignedSystemValue4);
    goto LAB_180072120;
  }
  if (pointerToUnsigned10 != (uint8_t *)0x0) {
    pointerToUnsigned10[systemStatus9] = 0;
  }
  unsignedSystemValue4 = *(uint *)(resourceCounter + 0x1c);
  unsignedValue100 = hashValue;
  unsignedValueF8._4_4_ = unsignedSystemValue4;
  if (ConfigurationDataPointer != 0) {
    resourceCounter = -1;
    do {
      nextDataIndex7 = resourceCounter;
      resourceCounter = nextDataIndex7 + 1;
    } while (*(char *)(ConfigurationDataPointer + resourceCounter) != '\0');
    if (0 < (int)resourceCounter) {
      systemCounter = hashValue + (int)resourceCounter;
      if (systemCounter != 0) {
        hashValue = systemCounter + 1;
        if (pointerToUnsigned10 == (uint8_t *)0x0) {
          if ((int)hashValue < 0x10) {
            hashValue = 0x10;
          }
          pointerToUnsigned10 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)hashValue,0x13);
          *pointerToUnsigned10 = 0;
        }
        else {
          if (hashValue <= systemStatus6) goto LAB_1800721e1;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          pointerToUnsigned10 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,pointerToUnsigned10,hashValue,0x10);
        }
        punsignedValue108 = pointerToUnsigned10;
        unsignedValueF8._0_4_ = StartSystemThread(pointerToUnsigned10);
      }
LAB_1800721e1:
        memcpy(pointerToUnsigned10 + systemStatus9,ConfigurationDataPointer,(long long)((int)nextDataIndex7 + 2));
    }
  }
  FUN_180627e10(&pUnsignedStackFlag110,&pUnsignedStackFlagA8,&processFlags58);
  uStack_114 = 0;
  pUnsignedStackFlag110 = &SystemGlobalDataReference;
  if (pointerToUnsigned10 != (uint8_t *)0x0) {
      SystemCleanupFunction(pointerToUnsigned10);
  }
  punsignedValue108 = (uint8_t *)0x0;
  unsignedValueF8 = (ulong long)unsignedValueF8._4_4_ << 0x20;
  pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
  puStack_f0 = &SystemGlobalDataReference;
  if (lStack_e8 != 0) {
      SystemCleanupFunction();
  }
  lStack_e8 = 0;
  unsignedValueD8 = 0;
  puStack_f0 = &SystemMemoryAllocatorReference;
  ThreadLocalStorageEntry = &SystemStringTemplate;
  if (stackParameterA != (void* *)0x0) {
    ThreadLocalStorageEntry = stackParameterA;
  }
  charResult = FUN_1800f9600(ThreadLocalStorageEntry);
  if (validationStatusFlag == '\0') {
    systemCounter = WaitForSingleObject(SystemSemaphoreHandle,0);
    if (systemCounter == 0) {
      cStack_117 = '\x01';
      charResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
      if ((charResult == '\0') && (systemCounter = IsDebuggerPresent(), systemCounter != 0)) {
        validationStatusFlag = '\x01';
      }
      else {
        validationStatusFlag = '\0';
      }
      cStack_118 = charResult;
      if (SystemAllocationFlagsTemplate == 0) {
LAB_1800722f5:
        resourceCounter = SystemRenderManagerPointer;
        if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
          ProcessSystemResourceAllocation(*(void* *)(SystemStatusFlagsPointer + 8),
                        *(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                        *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
          *(uint8_t *)(resourceCounter + 0x1609) = 1;
        }
        if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
          ValidateSystemResourceStatus();
        }
      }
      else {
        systemCounter = *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
        systemValue = _Thrd_id();
        cStack_117 = systemValue == systemCounter;
        if ((bool)cStack_117) goto LAB_1800722f5;
      }
      if (validationStatusFlag != '\0') {
        if ((SystemMode == '\0') || (*(int *)(SystemStatusFlagsPointer + 0x340) == 2)) {
          systemFunctionPointer = (code *)swi(3);
          (*systemFunctionPointer)();
          return;
        }
        uStack_116 = 1;
      }
      pUnsignedStackFlag110 = &SystemGlobalDataReference;
      unsignedValueF8 = 0;
      punsignedValue108 = (void* *)0x0;
      unsignedValue100 = 0;
      if (validationStatusFlag == '\0') {
        resourceCounter = FUN_1800f9ce0(&puStack_f0,0);
        unsignedValue100 = *(uint *)(resourceCounter + 0x10);
        punsignedValue108 = *(uint8_t **)(resourceCounter + 8);
        unsignedValueF8 = *(ulong long *)(resourceCounter + 0x18);
        *(uint32_t *)(resourceCounter + 0x10) = 0;
        *(void* *)(resourceCounter + 8) = 0;
        *(void* *)(resourceCounter + 0x18) = 0;
        puStack_f0 = &SystemGlobalDataReference;
        if (lStack_e8 != 0) {
            SystemCleanupFunction();
        }
        lStack_e8 = 0;
        unsignedValueD8 = 0;
        puStack_f0 = &SystemMemoryAllocatorReference;
      }
      pointerToUnsigned10 = punsignedValue108;
      systemMemoryContext = &SystemGlobalDataReference;
      uStack_120 = 0;
      puStack_130 = (uint8_t *)0x0;
      uStack_128 = 0;
      puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x15,0x13);
      *puStack_130 = 0;
      hashValue = StartSystemThread(puStack_130);
      uStack_120 = CONCAT44(uStack_120._4_4_,hashValue);
      psystemStatus2 = (uint32_t *)(puStack_130 + uStack_128);
      *psystemStatus2 = 0x69746f4e;
      psystemStatus2[1] = 0x61636966;
      psystemStatus2[2] = 0x6e6f6974;
      psystemStatus2[3] = 0x73734120;
      psystemStatus2[4] = 0x21747265;
      *(uint8_t *)(psystemStatus2 + 5) = 0;
      uStack_128 = 0x14;
      if (puStack_130 == (uint8_t *)0x0) {
        uStack_128 = 0x14;
        puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x16,0x13);
        *puStack_130 = 0;
LAB_180072521:
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
      else if (hashValue < 0x16) {
        puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
        uStack_128 = 0x14;
        puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,0x16,0x10);
        goto LAB_180072521;
      }
      *(void*2 *)(puStack_130 + uStack_128) = 10;
      uStack_128 = 0x15;
      hashValue = 0x16;
      if (puStack_130 == (uint8_t *)0x0) {
        uStack_128 = 0x15;
        puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x17,0x13);
        *puStack_130 = 0;
LAB_1800725ac:
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
      else if ((uint)uStack_120 < 0x17) {
        puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
        uStack_128 = 0x15;
        puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,0x17,0x10);
        goto LAB_1800725ac;
      }
      *(void*2 *)(puStack_130 + uStack_128) = 10;
      uStack_128 = 0x16;
      if (ConfigurationDataPointer != 0) {
        resourceCounter = -1;
        do {
          nextDataIndex7 = resourceCounter;
          resourceCounter = nextDataIndex7 + 1;
        } while (*(char *)(ConfigurationDataPointer + resourceCounter) != '\0');
        systemCounter = (int)resourceCounter;
        if (0 < systemCounter) {
          unsignedSystemValue4 = hashValue;
          if (systemCounter != -0x16) {
            systemStatus6 = systemCounter + 0x17;
            if (puStack_130 == (uint8_t *)0x0) {
              if ((int)systemStatus6 < 0x10) {
                systemStatus6 = 0x10;
              }
              uStack_128 = hashValue;
              puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemStatus6,0x13);
              *puStack_130 = 0;
            }
            else {
              unsignedSystemValue4 = uStack_128;
              if (systemStatus6 <= (uint)uStack_120) goto LAB_180072662;
              puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
              uStack_128 = hashValue;
              puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,systemStatus6,0x10);
            }
            unsignedSystemValue7 = StartSystemThread(puStack_130);
            uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
            unsignedSystemValue4 = uStack_128;
          }
LAB_180072662:
          uStack_128 = unsignedSystemValue4;
            memcpy(puStack_130 + uStack_128,ConfigurationDataPointer,(long long)((int)nextDataIndex7 + 2));
        }
      }
      if (puStack_130 == (uint8_t *)0x0) {
        uStack_128 = hashValue;
        puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x18,0x13);
        *puStack_130 = 0;
LAB_1800726e7:
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
      else if ((uint)uStack_120 < 0x18) {
        puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
        uStack_128 = hashValue;
        puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,0x18,0x10);
        goto LAB_1800726e7;
      }
      *(void*2 *)(puStack_130 + uStack_128) = 0x3a;
      uStack_128 = 0x17;
      ProcessSystemData(&systemMemoryContext,UnsignedStackFlagB0);
      hashValue = uStack_128;
      unsignedSystemValue4 = uStack_128 + 1;
      if (unsignedSystemValue4 != 0) {
        systemStatus6 = uStack_128 + 2;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)systemStatus6 < 0x10) {
            systemStatus6 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemStatus6,0x13);
          *puStack_130 = 0;
        }
        else {
          if (systemStatus6 <= (uint)uStack_120) goto LAB_180072780;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,systemStatus6,0x10);
        }
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
LAB_180072780:
      *(void*2 *)(puStack_130 + uStack_128) = 10;
      systemStatus6 = hashValue + 0xd;
      uStack_128 = unsignedSystemValue4;
      if (systemStatus6 != 0) {
        unsignedSystemValue4 = hashValue + 0xe;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)unsignedSystemValue4 < 0x10) {
            unsignedSystemValue4 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)unsignedSystemValue4,0x13);
          *puStack_130 = 0;
        }
        else {
          if (unsignedSystemValue4 <= (uint)uStack_120) goto LAB_1800727ff;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,unsignedSystemValue4,0x10);
        }
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
LAB_1800727ff:
      pointerToUnsigned13 = (void* *)(puStack_130 + uStack_128);
      *pointerToUnsigned13 = 0x6973736572707845;
      *(uint32_t *)(pointerToUnsigned13 + 1) = 0x203a6e6f;
      *(uint8_t *)((long long)pointerToUnsigned13 + 0xc) = 0;
      resourceCounter = -1;
      uStack_128 = systemStatus6;
      if (ConfigurationFlag != 0) {
        do {
          nextDataIndex7 = resourceCounter;
          resourceCounter = nextDataIndex7 + 1;
        } while (*(char *)(resourceCounter + ConfigurationFlag) != '\0');
        if (0 < (int)resourceCounter) {
          systemCounter = systemStatus6 + (int)resourceCounter;
          if (systemCounter != 0) {
            hashValue = systemCounter + 1;
            if (puStack_130 == (uint8_t *)0x0) {
              if ((int)hashValue < 0x10) {
                hashValue = 0x10;
              }
              puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)hashValue,0x13);
              *puStack_130 = 0;
            }
            else {
              if (hashValue <= (uint)uStack_120) goto LAB_1800728ad;
              puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
              puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,hashValue,0x10);
            }
            unsignedSystemValue7 = StartSystemThread(puStack_130);
            uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
          }
LAB_1800728ad:
            memcpy(puStack_130 + uStack_128,ConfigurationFlag,(long long)((int)nextDataIndex7 + 2));
        }
      }
      unsignedSystemValue4 = hashValue + 0xf;
      if (unsignedSystemValue4 != 0) {
        unsignedSystemValue8 = hashValue + 0x10;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)unsignedSystemValue8 < 0x10) {
            unsignedSystemValue8 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)unsignedSystemValue8,0x13);
          *puStack_130 = 0;
        }
        else {
          if (unsignedSystemValue8 <= (uint)uStack_120) goto LAB_180072934;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,unsignedSystemValue8,0x10);
        }
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
LAB_180072934:
      *(void*2 *)(puStack_130 + uStack_128) = 0xa0a;
      *(uint8_t *)((long long)(puStack_130 + uStack_128) + 2) = 0;
      uStack_128 = unsignedSystemValue4;
      if (hashValue + 0x6d != 0) {
        unsignedSystemValue4 = hashValue + 0x6e;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)unsignedSystemValue4 < 0x10) {
            unsignedSystemValue4 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)unsignedSystemValue4,0x13);
          *puStack_130 = 0;
        }
        else {
          if (unsignedSystemValue4 <= (uint)uStack_120) goto LAB_1800729bd;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,puStack_130,unsignedSystemValue4,0x10);
        }
        unsignedSystemValue7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,unsignedSystemValue7);
      }
LAB_1800729bd:
      pointerToUnsigned13 = (void* *)(puStack_130 + uStack_128);
      *pointerToUnsigned13 = 0x232323232323233c;
      pointerToUnsigned13[1] = 0x2323232323232323;
      pointerToUnsigned13[2] = 0x2323232323232323;
      pointerToUnsigned13[3] = 0x2323232323232323;
      pointerToUnsigned13[4] = 0x2323232323232323;
      pointerToUnsigned13[5] = 0x2323232323232323;
      pointerToUnsigned13[6] = 0x2323232323232323;
      pointerToUnsigned13[7] = 0x2323232323232323;
      *(uint32_t *)(pointerToUnsigned13 + 8) = 0x23232323;
      *(uint32_t *)((long long)pointerToUnsigned13 + 0x44) = 0x23232323;
      *(uint32_t *)(pointerToUnsigned13 + 9) = 0x23232323;
      *(uint32_t *)((long long)pointerToUnsigned13 + 0x4c) = 0x23232323;
      pointerToUnsigned13[10] = 0x2323232323232323;
      *(uint32_t *)(pointerToUnsigned13 + 0xb) = 0x3e232323;
      *(void*2 *)((long long)pointerToUnsigned13 + 0x5c) = 0xa0a;
      *(uint8_t *)((long long)pointerToUnsigned13 + 0x5e) = 0;
      puStack_148 = &SystemStringTemplate;
      if (puStack_130 != (uint8_t *)0x0) {
        puStack_148 = puStack_130;
      }
      uStack_128 = hashValue + 0x6d;
      FUN_180062380(SystemContextManagerPointer,4,0xffffffff00000000,&SystemConfigurationDataBufferB);
      puStack_148 = &SystemStringTemplate;
      if (pointerToUnsigned10 != (void* *)0x0) {
        puStack_148 = pointerToUnsigned10;
      }
      SystemManagerSetFlags(SystemContextManagerPointer,4,0xffffffff00000000,3);
      InitializeSystemManager();
      pointerToUnsigned14 = &SystemStringTemplate;
      if (puStack_130 != (uint8_t *)0x0) {
        pointerToUnsigned14 = puStack_130;
      }
      OutputDebugStringA(pointerToUnsigned14);
      FUN_18004c2b0(ConfigurationFlag);
      ThreadLocalStorageEntry = &SystemStringTemplate;
      if (stackParameterA != (void* *)0x0) {
        ThreadLocalStorageEntry = stackParameterA;
      }
      systemCounter = FUN_1800f98e0(ThreadLocalStorageEntry);
      if ((cStack_118 == '\0') && (systemCounter == 0)) {
        if ((SystemStatusFlagsPointer == 0) || (*(char *)(SystemStatusFlagsPointer + 0x141) == '\0')) {
          systemStatus8 = 0;
        }
        else {
          systemStatus8 = 1;
        }
        if (SystemStatusFlagsPointer == 0) {
          dataBufferContext = &SystemGlobalDataReference;
          UnsignedStackFlagB8 = 0;
          pointerUnsignedC8 = (void* *)0x0;
          UnsignedStackFlagC0 = 0;
          pointerToUnsigned13 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x34,0x13);
          *(uint8_t *)pointerToUnsigned13 = 0;
          pointerUnsignedC8 = pointerToUnsigned13;
          unsignedSystemValue7 = StartSystemThread(pointerToUnsigned13);
          UnsignedStackFlagB8 = CONCAT44(UnsignedStackFlagB8._4_4_,unsignedSystemValue7);
          *pointerToUnsigned13 = 0x7270706d75645c5c;
          pointerToUnsigned13[1] = 0x2e726f737365636f;
          pointerToUnsigned13[2] = 0x6c726f77656c6174;
          pointerToUnsigned13[3] = 0x445c6d6f632e7364;
          *(uint32_t *)(pointerToUnsigned13 + 4) = 0x50706d75;
          *(uint32_t *)((long long)pointerToUnsigned13 + 0x24) = 0x65636f72;
          *(uint32_t *)(pointerToUnsigned13 + 5) = 0x6e697373;
          *(uint32_t *)((long long)pointerToUnsigned13 + 0x2c) = 0x6c6f4667;
          *(uint32_t *)(pointerToUnsigned13 + 6) = 0x726564;
          UnsignedStackFlagC0 = 0x33;
          pThreadLocalStorage = &dataBufferContext;
          hashValue = 2;
          uStack_114 = 2;
        }
        else {
          pThreadLocalStorage = (void* **)CreateSystemObject(&pUnsignedStackFlag80,SystemStatusFlagsPointer + 0x148);
          hashValue = 1;
          uStack_114 = 1;
          pointerToUnsigned13 = pointerUnsignedC8;
        }
        unsignedSystemValue7 = CreateSystemObject(&puStack_f0,pThreadLocalStorage);
        if ((hashValue & 2) != 0) {
          hashValue = hashValue & 0xfffffffd;
          dataBufferContext = &SystemGlobalDataReference;
          uStack_114 = hashValue;
          if (pointerToUnsigned13 != (void* *)0x0) {
              SystemCleanupFunction(pointerToUnsigned13);
          }
          pointerUnsignedC8 = (void* *)0x0;
          UnsignedStackFlagB8 = UnsignedStackFlagB8 & 0xffffffff00000000;
          dataBufferContext = &SystemMemoryAllocatorReference;
        }
        if ((hashValue & 1) != 0) {
          uStack_114 = hashValue & 0xfffffffe;
          pUnsignedStackFlag80 = &SystemGlobalDataReference;
          if (lStack_78 != 0) {
              SystemCleanupFunction();
          }
          lStack_78 = 0;
          EncryptionValue68 = 0;
          pUnsignedStackFlag80 = &SystemMemoryAllocatorReference;
        }
        puStack_148 = &SystemStringTemplate;
        if (pointerToUnsigned10 != (void* *)0x0) {
          puStack_148 = pointerToUnsigned10;
        }
        FUN_1800669c0(unsignedSystemValue7,&puStack_f0,systemStatus8,systemConfigurationParameter);
        puStack_f0 = &SystemGlobalDataReference;
        if (lStack_e8 != 0) {
            SystemCleanupFunction();
        }
        lStack_e8 = 0;
        unsignedValueD8 = 0;
        puStack_f0 = &SystemMemoryAllocatorReference;
      }
      ThreadLocalStorageEntry = &SystemStringTemplate;
      if (stackParameterA != (void* *)0x0) {
        ThreadLocalStorageEntry = stackParameterA;
      }
      FUN_1800f96b0(ThreadLocalStorageEntry,1);
      if (cStack_117 != '\0') {
        if (*(long long *)(SystemStatusFlagsPointer + 8) != 0) {
          CleanupSystemResources();
        }
        if (SystemRenderManagerPointer != 0) {
          FUN_180092940(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
        }
      }

/**
 * @brief 处理系统资源初始化配置
 * 
 * 该函数负责处理系统资源的初始化配置，包括资源创建和参数设置
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_180072e80，现已重命名为ProcessSystemResourceInitializationConfiguration
 */
void ProcessSystemResourceInitializationConfiguration(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  void* creationFlags;
  void* *pointerUnsigned30;
  long long lStack_28;
  
  PrimaryResourcePointer = *(long long **)(SystemStatusFlagsPointer + 0x2b0);
  if (PrimaryResourcePointer != (long long *)0x0) {
    creationFlags = (**(code **)(*PrimaryResourcePointer + 0x110))(PrimaryResourcePointer,&pointerUnsigned30,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
    FUN_18005d190(ConfigurationDataPointer,creationFlags);
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}




bool FUN_180072f00(void* ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  uint32_t systemStatus;
  int systemResult;
  int MemoryComparisonResult;
  long long bufferBaseAddress;
  void* *pcurrentThreadId;
  void** SystemRootNode;
  void* **pHashBucketNode;
  uint8_t *newThreadLocalStorage;
  void* unsignedSystemValue9;
  void*2 *pointerToUnsigned10;
  uint systemStatus1;
  void* *psystemStatus2;
  void* *pointerToUnsigned13;
  void* *pointerToUnsigned14;
  char cStackX_10;
  uint systemStatus5;
  void* *pUnsignedStackFlag110;
  void* *punsignedValue108;
  int iStack_100;
  void* unsignedValueF8;
  void* *puStack_f0;
  void*2 *pointerUnsignedE8;
  uint32_t uStack_e0;
  void* unsignedValueD8;
  void* *dataBufferContext;
  void* *pointerUnsignedC8;
  uint32_t UnsignedStackFlagC0;
  ulong long UnsignedStackFlagB8;
  void* *alternateBufferPtrB0;
  void* *pUnsignedStackFlagA8;
  uint32_t UnsignedStackFlagA0;
  ulong long unsignedValue98;
  void* *pStackParameterC;
  uint8_t *pUnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  ulong long UnsignedStackFlag78;
  void* *pprocessFlags70;
  void* *pEncryptionValue68;
  void* *punsignedValue60;
  long long lStack_48;
  void* unsignedValue40;
  
  unsignedValue40 = 0xfffffffffffffffe;
  pcurrentThreadId = (void* *)0x0;
  systemCounter = 0;
  WaitForSingleObject(SystemSemaphoreHandle,300000);
  lStack_48 = SystemAllocationFlagsTemplate;
  if (SystemAllocationFlagsTemplate != 0) {
    FUN_18005dab0(SystemAllocationFlagsTemplate);
  }
  puStack_f0 = &SystemGlobalDataReference;
  unsignedValueD8 = 0;
  pointerUnsignedE8 = (void*2 *)0x0;
  uStack_e0 = 0;
  pointerUnsignedE8 = (void*2 *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
  *(uint8_t *)pointerUnsignedE8 = 0;
  systemStatus = StartSystemThread(pointerUnsignedE8);
  unsignedValueD8 = CONCAT44(unsignedValueD8._4_4_,systemStatus);
  *pointerUnsignedE8 = 0xa0a;
  *(uint8_t *)(pointerUnsignedE8 + 1) = 0;
  uStack_e0 = 2;
  dataBufferContext = &SystemGlobalDataReference;
  UnsignedStackFlagB8 = 0;
  pointerUnsignedC8 = (void* *)0x0;
  UnsignedStackFlagC0 = 0;
  FUN_1800a32b0(SystemTextureManagerPointer,&pEncryptionValue68);
  if (pEncryptionValue68 != punsignedValue60) {
    ConfigureSystemDataBuffer(&puStack_f0,&SystemDataBufferTemplateA,&SystemResourceDataBufferA);
    resourceEntryPointer = pcurrentThreadId;
    psystemStatus2 = pcurrentThreadId;
    if ((long long)punsignedValue60 - (long long)pEncryptionValue68 >> 5 != 0) {
      do {
        pointerToUnsigned13 = &SystemStringTemplate;
        if (*(void* **)((long long)(resourceEntryPointer + 1) + (long long)pEncryptionValue68) != (void* *)0x0) {
          pointerToUnsigned13 = *(void* **)((long long)(resourceEntryPointer + 1) + (long long)pEncryptionValue68);
        }
        ConfigureSystemDataBuffer(&puStack_f0,&SystemDataBufferTemplateA,pointerToUnsigned13);
        systemStatus1 = (int)psystemStatus2 + 1;
        resourceEntryPointer = SystemCurrentNode + 4;
        psystemStatus2 = (void* *)(ulong long)systemStatus1;
      } while ((ulong long)(long long)(int)systemStatus1 <
               (ulong long)((long long)punsignedValue60 - (long long)pEncryptionValue68 >> 5));
    }
    ConfigureSystemDataBuffer(&puStack_f0,&UNK_1809ff840,&UNK_1809ff800);
    FUN_18006f590(&pUnsignedStackFlag110);
    if (iStack_100 != 0) {
      ConfigureSystemDataBuffer(&puStack_f0,&SystemDataBufferTemplateA,&UNK_1809ff848);
      resourceEntryPointer = (void* *)&SystemStringTemplate;
      if (punsignedValue108 != (void* *)0x0) {
        resourceEntryPointer = punsignedValue108;
      }
      ConfigureSystemDataBuffer(&puStack_f0,&UNK_1809ff888,resourceEntryPointer);
      ConfigureSystemDataBuffer(&puStack_f0,&UNK_1809ff840,&UNK_1809ff800);
    }
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    if (punsignedValue108 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    punsignedValue108 = (void* *)0x0;
    unsignedValueF8 = (ulong long)unsignedValueF8._4_4_ << 0x20;
    pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
  }
  bufferBaseAddress = FUN_1800f9ce0(&pUnsignedStackFlag110,ConfigurationDataPointer[1]);
  UnsignedStackFlagC0 = *(uint32_t *)(bufferBaseAddress + 0x10);
  pointerToUnsigned13 = *(void* **)(bufferBaseAddress + 8);
  UnsignedStackFlagB8 = *(ulong long *)(bufferBaseAddress + 0x18);
  *(uint32_t *)(bufferBaseAddress + 0x10) = 0;
  *(void* *)(bufferBaseAddress + 8) = 0;
  *(void* *)(bufferBaseAddress + 0x18) = 0;
  pUnsignedStackFlag110 = &SystemGlobalDataReference;
  pointerUnsignedC8 = pointerToUnsigned13;
  pprocessFlags70 = pointerToUnsigned13;
  if (punsignedValue108 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  punsignedValue108 = (void* *)0x0;
  unsignedValueF8 = unsignedValueF8 & 0xffffffff00000000;
  pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
  ConfigureSystemDataBuffer(&puStack_f0,&UNK_1809ff8a8,*(uint32_t *)*ConfigurationDataPointer,
                *(void* *)((uint32_t *)*ConfigurationDataPointer + 4));
  ConfigureSystemDataBuffer(&puStack_f0,&SystemDataBufferTemplateA,&UNK_1809ff8d8);
  pointerToUnsigned14 = &SystemStringTemplate;
  if (pointerToUnsigned13 != (void* *)0x0) {
    pointerToUnsigned14 = pointerToUnsigned13;
  }
  ConfigureSystemDataBuffer(&puStack_f0,&SystemDataBufferTemplateA,pointerToUnsigned14);
  pointerToUnsigned10 = (void*2 *)&SystemStringTemplate;
  if (pointerUnsignedE8 != (void*2 *)0x0) {
    pointerToUnsigned10 = pointerUnsignedE8;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffff00000000,3,&SystemDataBufferTemplateA,pointerToUnsigned10);
  InitializeSystemManager();
  bufferBaseAddress = SystemStatusFlagsPointer;
  if (SystemStatusFlagsPointer == 0) {
    cStackX_10 = '\0';
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    unsignedValueF8 = 0;
    punsignedValue108 = (void* *)0x0;
    iStack_100 = 0;
    resourceEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x34,0x13);
    *(uint8_t *)resourceEntryPointer = 0;
    punsignedValue108 = resourceEntryPointer;
    systemStatus = StartSystemThread(resourceEntryPointer);
    unsignedValueF8 = CONCAT44(unsignedValueF8._4_4_,systemStatus);
    *resourceEntryPointer = 0x7270706d75645c5c;
    resourceEntryPointer[1] = 0x2e726f737365636f;
    resourceEntryPointer[2] = 0x6c726f77656c6174;
    resourceEntryPointer[3] = 0x445c6d6f632e7364;
    *(uint32_t *)(SystemCurrentNode + 4) = 0x50706d75;
    *(uint32_t *)((long long)resourceEntryPointer + 0x24) = 0x65636f72;
    *(uint32_t *)(resourceEntryPointer + 5) = 0x6e697373;
    *(uint32_t *)((long long)resourceEntryPointer + 0x2c) = 0x6c6f4667;
    *(uint32_t *)(resourceEntryPointer + 6) = 0x726564;
    systemCounter = 0x33;
    iStack_100 = 0x33;
    systemStatus1 = 2;
    systemStatus5 = 2;
    pHashBucketNode = &punsignedValue108;
    pcurrentThreadId = pUnsignedStackFlagA8;
  }
  else {
    cStackX_10 = *(char *)(SystemStatusFlagsPointer + 0x141);
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    systemConfigurationValue = 0;
    pUnsignedStackFlagA8 = (void* *)0x0;
    UnsignedStackFlagA0 = 0;
    if (*(int *)(SystemStatusFlagsPointer + 0x158) != 0) {
      systemResult = *(int *)(SystemStatusFlagsPointer + 0x158) + 1;
      if (systemResult < 0x10) {
        systemResult = 0x10;
      }
      pcurrentThreadId = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemResult,0x13);
      *(uint8_t *)pcurrentThreadId = 0;
      pUnsignedStackFlagA8 = pcurrentThreadId;
      systemStatus = StartSystemThread(pcurrentThreadId);
      unsignedValue98 = CONCAT44(unsignedValue98._4_4_,systemStatus);
      if (*(int *)(bufferBaseAddress + 0x158) != 0) {
          memcpy(pcurrentThreadId,*(void* *)(bufferBaseAddress + 0x150),*(int *)(bufferBaseAddress + 0x158) + 1);
      }
    }
    if (*(long long *)(bufferBaseAddress + 0x150) != 0) {
      UnsignedStackFlagA0 = 0;
      if (pcurrentThreadId != (void* *)0x0) {
        *(uint8_t *)pcurrentThreadId = 0;
      }
      unsignedValue98 = unsignedValue98 & 0xffffffff;
    }
    systemStatus1 = 1;
    systemStatus5 = 1;
    pHashBucketNode = &pUnsignedStackFlagA8;
    resourceEntryPointer = punsignedValue108;
  }
  pSystemConfigurationValue = &SystemGlobalDataReference;
  UnsignedStackFlag78 = 0;
  pUnsignedStackFlag88 = (uint8_t *)0x0;
  UnsignedStackFlag80 = 0;
  if (systemCounter != 0) {
    systemStatus5 = systemCounter + 1;
    systemStatus1 = systemStatus5;
    if (systemStatus5 < 0x10) {
      systemStatus1 = 0x10;
    }
    newThreadLocalStorage = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,systemStatus1,0x13);
    *newThreadLocalStorage = 0;
    pUnsignedStackFlag88 = newThreadLocalStorage;
    systemStatus = StartSystemThread(newThreadLocalStorage);
    UnsignedStackFlag78 = CONCAT44(UnsignedStackFlag78._4_4_,systemStatus);
      memcpy(newThreadLocalStorage,*pHashBucketNode,systemStatus5);
  }
  UnsignedStackFlag78 = 0;
  UnsignedStackFlag80 = 0;
  if ((systemStatus1 & 2) != 0) {
    systemStatus5 = systemStatus1 & 0xfffffffd;
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    if (resourceEntryPointer != (void* *)0x0) {
        SystemCleanupFunction(resourceEntryPointer);
    }
    punsignedValue108 = (void* *)0x0;
    unsignedValueF8 = unsignedValueF8 & 0xffffffff00000000;
    pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
    systemStatus1 = systemStatus5;
  }
  if ((systemStatus1 & 1) != 0) {
    systemStatus5 = systemStatus1 & 0xfffffffe;
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    if (pcurrentThreadId != (void* *)0x0) {
        SystemCleanupFunction(pcurrentThreadId);
    }
    pUnsignedStackFlagA8 = (void* *)0x0;
    unsignedValue98 = unsignedValue98 & 0xffffffff00000000;
    alternateBufferPtrB0 = &SystemMemoryAllocatorReference;
  }
  pointerToUnsigned14 = &SystemStringTemplate;
  if (pointerToUnsigned13 != (void* *)0x0) {
    pointerToUnsigned14 = pointerToUnsigned13;
  }
  FUN_180066320(0,&pStackParameterC,cStackX_10,1,pointerToUnsigned14,pointerToUnsigned10,systemStatus5);
  if (lStack_48 != 0) {
    FUN_18005db30();
  }
  do {
    systemCounter = ReleaseSemaphore(SystemSemaphoreHandle,1);
  } while (systemCounter == 0);
  unsignedSystemValue9 = __acrt_iob_func(1);
  fflush(unsignedSystemValue9);
  unsignedSystemValue9 = __acrt_iob_func(2);
  fflush(unsignedSystemValue9);
  pSystemConfigurationValue = &SystemGlobalDataReference;
  if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
    pUnsignedStackFlag88 = (uint8_t *)0x0;
    UnsignedStackFlag78 = UnsignedStackFlag78 & 0xffffffff00000000;
    pSystemConfigurationValue = &SystemMemoryAllocatorReference;
    for (pcurrentThreadId = pEncryptionValue68; pcurrentThreadId != punsignedValue60; pcurrentThreadId = pcurrentThreadId + 4) {
      (**(code **)*pcurrentThreadId)(pcurrentThreadId,0);
    }
    if (pEncryptionValue68 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    dataBufferContext = &SystemGlobalDataReference;
    if (pprocessFlags70 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pointerUnsignedC8 = (void* *)0x0;
    UnsignedStackFlagB8 = UnsignedStackFlagB8 & 0xffffffff00000000;
    dataBufferContext = &SystemMemoryAllocatorReference;
    puStack_f0 = &SystemGlobalDataReference;
    if (pointerUnsignedE8 == (void*2 *)0x0) {
      return cStackX_10 != '\0';
    }
      SystemCleanupFunction();
  }
    SystemCleanupFunction();
}





/**
 * @brief 初始化系统资源管理器配置
 * 
 * 该函数负责初始化系统资源管理器的配置，设置管理器参数和标志
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180073630，现已重命名为InitializeSystemResourceManagerConfiguration
 */
void InitializeSystemResourceManagerConfiguration(void* ResourceManagerPointer,void* ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  char validationStatusFlag;
  uint32_t auStackX_18 [4];
  void* *pointerUnsigned30;
  long long lStack_28;
  
  SystemManagerSetFlags(SystemContextManagerPointer,0,0x100000000,0,&SystemResourceManagerDataBufferA,ConfigurationDataPointer,0xfffffffffffffffe);
  if (SystemInitializationFlag == '\0') {
    auStackX_18[0] = 0xffff0000;
    ProcessSystemQueue(&pointerUnsigned30,ConfigurationDataPointer);
    pointerToUnsigned1 = *(void* **)*SystemMemoryBlockStorage;
    if (pointerToUnsigned1 == &SystemMemoryBlockTemplatePrimary) {
      charResult = *(int *)(SystemStatusFlags + 0xc40) != 0;
    }
    else {
      charResult = (**(code **)(pointerToUnsigned1 + 0x50))((void* *)*SystemMemoryBlockStorage);
    }
    if (validationStatusFlag == '\0') {
      (**(code **)(*(long long *)SystemMemoryBlockStorage[1] + 0x18))
                ((long long *)SystemMemoryBlockStorage[1],&pointerUnsigned30,auStackX_18);
    }
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}





/**
 * @brief 配置系统资源管理器数据
 * 
 * 该函数负责配置系统资源管理器的数据，设置管理器参数和数据缓冲区
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180073730，现已重命名为ConfigureSystemResourceManagerData
 */
void ConfigureSystemResourceManagerData(void* ResourceManagerPointer,void* ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  char validationStatusFlag;
  uint32_t auStackX_18 [4];
  void* *pointerUnsigned30;
  long long lStack_28;
  
  SystemManagerSetFlags(SystemContextManagerPointer,0,0x100000000,1,&SystemResourceManagerDataBufferB,ConfigurationDataPointer,0xfffffffffffffffe);
  if (SystemInitializationFlag == '\0') {
    auStackX_18[0] = 0xff00ff00;
    ProcessSystemQueue(&pointerUnsigned30,ConfigurationDataPointer);
    pointerToUnsigned1 = *(void* **)*SystemMemoryBlockStorage;
    if (pointerToUnsigned1 == &SystemMemoryBlockTemplatePrimary) {
      charResult = *(int *)(SystemStatusFlags + 0xc40) != 0;
    }
    else {
      charResult = (**(code **)(pointerToUnsigned1 + 0x50))((void* *)*SystemMemoryBlockStorage);
    }
    if (validationStatusFlag == '\0') {
      (**(code **)(*(long long *)SystemMemoryBlockStorage[1] + 0x18))
                ((long long *)SystemMemoryBlockStorage[1],&pointerUnsigned30,auStackX_18);
    }
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}





/**
 * @brief 系统管理器参数设置函数
 * 
 * 该函数负责设置系统管理器的各种参数和配置。
 * 函数会根据系统初始化状态执行相应的管理器参数设置操作。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * 
 * 原始函数名为FUN_180073830，现已重命名为SetSystemManagerParameters
 */
void SetSystemManagerParameters(void* ResourceManagerPointer,uint32_t ConfigurationDataPointer,void* AdditionalParameter)

{
  void* *pointerToUnsigned1;
  char validationStatusFlag;
  uint32_t auStackX_20 [2];
  void* *pointerUnsigned30;
  long long lStack_28;
  
  SystemManagerSetFlags(SystemContextManagerPointer,0,0x100000000,0xc,&SystemResourceManagerDataBufferC,AdditionalParameter,0xfffffffffffffffe);
  if (SystemInitializationFlag == '\0') {
    auStackX_20[0] = ConfigurationDataPointer;
    ProcessSystemQueue(&pointerUnsigned30,AdditionalParameter);
    pointerToUnsigned1 = *(void* **)*SystemMemoryBlockStorage;
    if (pointerToUnsigned1 == &SystemMemoryBlockTemplatePrimary) {
      charResult = *(int *)(SystemStatusFlags + 0xc40) != 0;
    }
    else {
      charResult = (**(code **)(pointerToUnsigned1 + 0x50))((void* *)*SystemMemoryBlockStorage);
    }
    if (validationStatusFlag == '\0') {
      (**(code **)(*(long long *)SystemMemoryBlockStorage[1] + 0x18))
                ((long long *)SystemMemoryBlockStorage[1],&pointerUnsigned30,auStackX_20);
    }
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}




// 函数: void FUN_180073930(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统回调函数管理器
 * 
 * 该函数负责管理系统回调函数的初始化和设置，处理系统全局数据引用。
 * 它会调用其他相关函数来完成回调函数的配置和清理工作。
 * 
 * @param ResourceManagerPointer 回调函数参数1
 * @param ConfigurationDataPointer 回调函数参数2  
 * @param AdditionalParameter 回调函数参数3
 * @param ConfigurationFlag 回调函数参数4
 */
void SystemCallbackManager(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pUnsignedStackFlag88;
  void* UnsignedStackFlag80;
  uint32_t UnsignedStackFlag78;
  void* processFlags70;
  void* EncryptionValue68;
  void* unsignedValue60;
  void* processFlags58;
  uint32_t unsignedValue50;
  void* EncryptionValue48;
  void* unsignedValue40;
  void*2 uStack_38;
  void* uStack_36;
  void* uStack_2e;
  void*2 uStack_26;
  void* unsignedValue18;
  
  unsignedValue18 = 0xfffffffffffffffe;
  pUnsignedStackFlag88 = &SystemGlobalDataReference;
  processFlags70 = 0;
  UnsignedStackFlag80 = 0;
  UnsignedStackFlag78 = 0;
  EncryptionValue68 = 0;
  unsignedValue60 = 0;
  processFlags58 = 0;
  unsignedValue50 = 3;
  uStack_38 = 0;
  EncryptionValue48 = 0;
  unsignedValue40 = 0;
  uStack_26 = 0;
  uStack_36 = 0;
  uStack_2e = 0;
  FUN_180074090(&pUnsignedStackFlag88,ResourceManagerPointer,AdditionalParameter,ConfigurationFlag,&EncryptionValue68);
  FUN_180073ad0(&pUnsignedStackFlag88,AdditionalParameter);
  FUN_1800739f0(&pUnsignedStackFlag88);
  return;
}




/**
 * @brief 资源管理器重置函数
 * 
 * 该函数负责重置资源管理器的各种状态和指针。
 * 函数会清理资源管理器的各个字段，并重置为初始状态。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * 
 * 原始函数名为FUN_1800739f0，现已重命名为ResetResourceManager
 */
void ResetResourceManager(void* *ResourceManagerPointer)

{
  if (*(long long *)((long long)ResourceManagerPointer + 0x52) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)((long long)ResourceManagerPointer + 0x52) = 0;
  if (*(long long *)((long long)ResourceManagerPointer + 0x5a) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)((long long)ResourceManagerPointer + 0x5a) = 0;
  if (ResourceManagerPointer[8] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[8] = 0;
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[9] = 0;
  FUN_180074a80();
  *ResourceManagerPointer = &SystemGlobalDataReference;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  *(uint32_t *)(ResourceManagerPointer + 3) = 0;
  *ResourceManagerPointer = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源清理处理器
 * 
 * 该函数负责清理系统资源，包括内存释放、资源重置和状态清理。
 * 主要用于系统关闭或重启时的资源回收工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要清理的资源结构
 * 
 * @note 该函数在清理过程中会调用SystemCleanupFunction进行最终清理
 * @note 函数使用循环遍历所有相关资源并进行清理
 * @note 如果清理过程中发现错误，会触发系统清理函数
 */
void SystemResourceCleanupHandler(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)ResourceManagerPointer[1];
  resourcePoolPointer = (long long *)*ResourceManagerPointer;
  while( true ) {
    if (resourcePoolPointer == PrimaryResourcePointer) {
      if (*ResourceManagerPointer != 0) {
          SystemCleanupFunction();
      }
      return;
    }
    if (*(long long *)((long long)resourcePoolPointer + 0x12) != 0) {
        SystemCleanupFunction();
    }
    *(void* *)((long long)resourcePoolPointer + 0x12) = 0;
    if (*(long long *)((long long)resourcePoolPointer + 0x1a) != 0) break;
    *(void* *)((long long)resourcePoolPointer + 0x1a) = 0;
    if (*resourcePoolPointer != 0) {
        SystemCleanupFunction();
    }
    *resourcePoolPointer = 0;
    if (resourcePoolPointer[1] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[1] = 0;
    resourcePoolPointer = (long long *)((long long)resourcePoolPointer + 0x24);
  }
    SystemCleanupFunction();
}




/**
 * @brief 处理系统数据块
 * 
 * 该函数处理系统数据块，包括数据块的读取、解析和存储操作。
 * 主要用于系统初始化过程中的数据处理。
 * 
 * @param DataBlockHandle 数据块句柄，用于标识要处理的数据块
 * @param DataBufferPointer 数据缓冲区指针，用于存储处理后的数据
 * 
 * @note 该函数是系统初始化过程中的重要组成部分，负责数据块的格式化处理
 */
void ProcessSystemDataBlock(long long DataBlockHandle, long long *DataBufferPointer)

{
  ushort DataElementSize;
  void* DataPointer;
  int *IntegerBufferPointer;
  uint32_t *UInt32BufferPointer;
  uint *UIntBufferPointer;
  long long DataBlockSize;
  long long DataElementOffset;
  int ElementCount;
  ulong long DataSize;
  long long ElementIndex;
  
  InitializeDataBuffer(DataBufferPointer, DataBlockHandle);
  DataBlockSize = *(long long *)(DataBlockHandle + 0x28) - *(long long *)(DataBlockHandle + 0x20);
  IntegerBufferPointer = (int *)DataBufferPointer[1];
  DataBlockSize = DataBlockSize / 0x12 + (DataBlockSize >> 0x3f);
  ElementCount = (int)(DataBlockSize >> 1) - (int)(DataBlockSize >> 0x3f);
  if ((ulong long)((*DataBufferPointer - (long long)IntegerBufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)IntegerBufferPointer + (4 - *DataBufferPointer));
    IntegerBufferPointer = (int *)DataBufferPointer[1];
  }
  *IntegerBufferPointer = ElementCount;
  UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
  DataBufferPointer[1] = (long long)UInt32BufferPointer;
  DataBlockSize = (long long)ElementCount;
  if (0 < ElementCount) {
    ElementIndex = 0;
    do {
      DataElementOffset = *(long long *)(DataBlockHandle + 0x20) + ElementIndex;
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0x10;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UIntBufferPointer = (uint *)DataBufferPointer[1];
      DataElementSize = *(ushort *)(DataElementOffset + 0x10);
      if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
        UIntBufferPointer = (uint *)DataBufferPointer[1];
      }
      *UIntBufferPointer = (uint)DataElementSize;
      UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
      DataBufferPointer[1] = (long long)UInt32BufferPointer;
      if (*(ushort *)(DataElementOffset + 0x10) != 0) {
        DataPointer = *(void* *)(DataElementOffset + 8);
        DataSize = (ulong long)*(ushort *)(DataElementOffset + 0x10) * 4;
        if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) <= DataSize) {
          ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (DataSize - *DataBufferPointer));
          UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
        }
              memcpy(UInt32BufferPointer, DataPointer, DataSize);
      }
      DataElementOffset = *(long long *)(DataBlockHandle + 0x20) + ElementIndex;
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0x10;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UIntBufferPointer = (uint *)DataBufferPointer[1];
      DataElementSize = *(ushort *)(DataElementOffset + 0x22);
      if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
        UIntBufferPointer = (uint *)DataBufferPointer[1];
      }
      *UIntBufferPointer = (uint)DataElementSize;
      UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
      DataBufferPointer[1] = (long long)UInt32BufferPointer;
      if (*(ushort *)(DataElementOffset + 0x22) != 0) {
        DataPointer = *(void* *)(DataElementOffset + 0x1a);
        DataSize = (ulong long)*(ushort *)(DataElementOffset + 0x22) * 4;
        if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) <= DataSize) {
          ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (DataSize - *DataBufferPointer));
          UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
        }
              memcpy(UInt32BufferPointer, DataPointer, DataSize);
      }
      ElementIndex = ElementIndex + 0x24;
      DataBlockSize = DataBlockSize + -1;
    } while (DataBlockSize != 0);
  }
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0x10;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UIntBufferPointer = (uint *)DataBufferPointer[1];
  DataElementSize = *(ushort *)(DataBlockHandle + 0x50);
  if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
    UIntBufferPointer = (uint *)DataBufferPointer[1];
  }
  *UIntBufferPointer = (uint)DataElementSize;
  UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
  DataBufferPointer[1] = (long long)UInt32BufferPointer;
  if (*(ushort *)(DataBlockHandle + 0x50) != 0) {
    DataPointer = *(void* *)(DataBlockHandle + 0x48);
    DataSize = (ulong long)*(ushort *)(DataBlockHandle + 0x50) * 4;
    if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) <= DataSize) {
      ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (DataSize - *DataBufferPointer));
      UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
    }
      memcpy(UInt32BufferPointer, DataPointer, DataSize);
  }
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0x10;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UIntBufferPointer = (uint *)DataBufferPointer[1];
  DataElementSize = *(ushort *)(DataBlockHandle + 0x62);
  if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
    UIntBufferPointer = (uint *)DataBufferPointer[1];
  }
  *UIntBufferPointer = (uint)DataElementSize;
  DataBlockSize = DataBufferPointer[1] + 4;
  DataBufferPointer[1] = DataBlockSize;
  if (*(ushort *)(DataBlockHandle + 0x62) == 0) {
    return;
  }
  DataPointer = *(void* *)(DataBlockHandle + 0x5a);
  DataSize = (ulong long)*(ushort *)(DataBlockHandle + 0x62) * 4;
  if ((ulong long)((*DataBufferPointer - DataBlockSize) + DataBufferPointer[2]) <= DataSize) {
    ExpandDataBuffer(DataBufferPointer,DataSize + (DataBlockSize - *DataBufferPointer));
    DataBlockSize = DataBufferPointer[1];
  }
  memcpy(DataBlockSize, DataPointer, DataSize);
}




/**
 * @brief 处理系统资源分配
 * 
 * 该函数负责处理系统资源的分配，包括内存分配和资源管理
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * 
 * 原始函数名为FUN_180073adc，现已重命名为ProcessSystemResourceAllocation
 */
void ProcessSystemResourceAllocation(long long ResourceManagerPointer)

{
  ushort systemStatus;
  void* creationFlags;
  int *pointerToInteger3;
  uint32_t *punsignedSystemValue4;
  uint *pcurrentThreadId;
  long long localSystemFlags;
  long long *systemMemoryBlockPtr;
  long long localDataIndex;
  int systemCode;
  ulong long unsignedSystemValue9;
  long long allocationFlags;
  
  FUN_180639ec0();
  localSystemFlags = *(long long *)(ResourceManagerPointer + 0x28) - *(long long *)(ResourceManagerPointer + 0x20);
  pointerToInteger3 = (int *)systemMemoryBlockPtr[1];
  localSystemFlags = localSystemFlags / 0x12 + (localSystemFlags >> 0x3f);
  systemCode = (int)(localSystemFlags >> 1) - (int)(localSystemFlags >> 0x3f);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)pointerToInteger3) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    pointerToInteger3 = (int *)systemMemoryBlockPtr[1];
  }
  *pointerToInteger3 = systemCode;
  punsignedSystemValue4 = (uint32_t *)(systemMemoryBlockPtr[1] + 4);
  systemMemoryBlockPtr[1] = (long long)punsignedSystemValue4;
  localSystemFlags = (long long)systemCode;
  if (0 < systemCode) {
    allocationFlags = 0;
    do {
      localDataIndex = *(long long *)(ResourceManagerPointer + 0x20) + allocationFlags;
      if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
        FUN_180639bf0();
        punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
      }
      *punsignedSystemValue4 = 0;
      systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
      punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
      if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
        FUN_180639bf0();
        punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
      }
      *punsignedSystemValue4 = 0x10;
      systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
      pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
      systemStatus = *(ushort *)(localDataIndex + 0x10);
      if ((ulong long)((*systemMemoryBlockPtr - (long long)pcurrentThreadId) + systemMemoryBlockPtr[2]) < 5) {
        FUN_180639bf0();
        pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
      }
      *pcurrentThreadId = (uint)systemStatus;
      punsignedSystemValue4 = (uint32_t *)(systemMemoryBlockPtr[1] + 4);
      systemMemoryBlockPtr[1] = (long long)punsignedSystemValue4;
      if (*(ushort *)(localDataIndex + 0x10) != 0) {
        creationFlags = *(void* *)(localDataIndex + 8);
        unsignedSystemValue9 = (ulong long)*(ushort *)(localDataIndex + 0x10) * 4;
        if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) <= unsignedSystemValue9) {
          FUN_180639bf0();
          punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
        }
          memcpy(punsignedSystemValue4,creationFlags,unsignedSystemValue9);
      }
      localDataIndex = *(long long *)(ResourceManagerPointer + 0x20) + allocationFlags;
      if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
        FUN_180639bf0();
        punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
      }
      *punsignedSystemValue4 = 0;
      systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
      punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
      if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
        FUN_180639bf0();
        punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
      }
      *punsignedSystemValue4 = 0x10;
      systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
      pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
      systemStatus = *(ushort *)(localDataIndex + 0x22);
      if ((ulong long)((*systemMemoryBlockPtr - (long long)pcurrentThreadId) + systemMemoryBlockPtr[2]) < 5) {
        FUN_180639bf0();
        pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
      }
      *pcurrentThreadId = (uint)systemStatus;
      punsignedSystemValue4 = (uint32_t *)(systemMemoryBlockPtr[1] + 4);
      systemMemoryBlockPtr[1] = (long long)punsignedSystemValue4;
      if (*(ushort *)(localDataIndex + 0x22) != 0) {
        creationFlags = *(void* *)(localDataIndex + 0x1a);
        unsignedSystemValue9 = (ulong long)*(ushort *)(localDataIndex + 0x22) * 4;
        if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) <= unsignedSystemValue9) {
          FUN_180639bf0();
          punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
        }
          memcpy(punsignedSystemValue4,creationFlags,unsignedSystemValue9);
      }
      allocationFlags = allocationFlags + 0x24;
      localSystemFlags = localSystemFlags + -1;
    } while (localSystemFlags != 0);
  }
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = 0;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(ResourceManagerPointer + 0x50);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)pcurrentThreadId) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
  }
  *pcurrentThreadId = (uint)systemStatus;
  punsignedSystemValue4 = (uint32_t *)(systemMemoryBlockPtr[1] + 4);
  systemMemoryBlockPtr[1] = (long long)punsignedSystemValue4;
  if (*(ushort *)(ResourceManagerPointer + 0x50) != 0) {
    creationFlags = *(void* *)(ResourceManagerPointer + 0x48);
    unsignedSystemValue9 = (ulong long)*(ushort *)(ResourceManagerPointer + 0x50) * 4;
    if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) <= unsignedSystemValue9) {
      FUN_180639bf0();
      punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
    }
      memcpy(punsignedSystemValue4,creationFlags,unsignedSystemValue9);
  }
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = 0;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(ResourceManagerPointer + 0x62);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)pcurrentThreadId) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    pcurrentThreadId = (uint *)systemMemoryBlockPtr[1];
  }
  *pcurrentThreadId = (uint)systemStatus;
  localSystemFlags = systemMemoryBlockPtr[1] + 4;
  systemMemoryBlockPtr[1] = localSystemFlags;
  if (*(ushort *)(ResourceManagerPointer + 0x62) == 0) {
    return;
  }
  creationFlags = *(void* *)(ResourceManagerPointer + 0x5a);
  unsignedSystemValue9 = (ulong long)*(ushort *)(ResourceManagerPointer + 0x62) * 4;
  if ((ulong long)((*systemMemoryBlockPtr - localSystemFlags) + systemMemoryBlockPtr[2]) <= unsignedSystemValue9) {
    FUN_180639bf0();
    localSystemFlags = systemMemoryBlockPtr[1];
  }
    memcpy(localSystemFlags,creationFlags,unsignedSystemValue9);
}




/**
 * @brief 验证系统资源状态
 * 
 * 该函数负责验证系统资源的状态，确保资源处于有效状态
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * 
 * 原始函数名为FUN_180073b64，现已重命名为ValidateSystemResourceState
 */
void ValidateSystemResourceState(uint *ResourceManagerPointer)

{
  ushort systemStatus;
  void* creationFlags;
  uint32_t *HashNodePointer;
  uint *punsignedSystemValue4;
  long long *systemMemoryBlockPtr;
  long long SystemTimeValue;
  ulong long hashValue;
  long long systemAllocationOffset;
  uint unaff_R13D;
  long long systemResourceHandle;
  
  hashValue = (ulong long)unaff_R13D;
  do {
    localSystemPointer = *(long long *)(systemResourceHandle + 0x20) + hashValue;
    if ((ulong long)((*systemMemoryBlockPtr - (long long)ResourceManagerPointer) + systemMemoryBlockPtr[2]) < 5) {
      FUN_180639bf0();
      ResourceManagerPointer = (uint *)systemMemoryBlockPtr[1];
    }
    *ResourceManagerPointer = unaff_R13D;
    systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
    if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
      FUN_180639bf0();
      HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
    }
    *HashNodePointer = 0x10;
    systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
    systemStatus = *(ushort *)(localSystemPointer + 0x10);
    if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
      FUN_180639bf0();
      punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
    }
    *punsignedSystemValue4 = (uint)systemStatus;
    punsignedSystemValue4 = (uint *)(systemMemoryBlockPtr[1] + 4);
    systemMemoryBlockPtr[1] = (long long)punsignedSystemValue4;
    if (*(ushort *)(localSystemPointer + 0x10) != 0) {
      creationFlags = *(void* *)(localSystemPointer + 8);
      hashValue = (ulong long)*(ushort *)(localSystemPointer + 0x10) * 4;
      if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) <= hashValue) {
        FUN_180639bf0();
        punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
      }
        memcpy(punsignedSystemValue4,creationFlags,hashValue);
    }
    localSystemPointer = *(long long *)(systemResourceHandle + 0x20) + hashValue;
    if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
      FUN_180639bf0();
      punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
    }
    *punsignedSystemValue4 = unaff_R13D;
    systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
    if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
      FUN_180639bf0();
      HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
    }
    *HashNodePointer = 0x10;
    systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
    systemStatus = *(ushort *)(localSystemPointer + 0x22);
    if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
      FUN_180639bf0();
      punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
    }
    *punsignedSystemValue4 = (uint)systemStatus;
    ResourceManagerPointer = (uint *)(systemMemoryBlockPtr[1] + 4);
    systemMemoryBlockPtr[1] = (long long)ResourceManagerPointer;
    if (*(ushort *)(localSystemPointer + 0x22) != 0) {
      creationFlags = *(void* *)(localSystemPointer + 0x1a);
      hashValue = (ulong long)*(ushort *)(localSystemPointer + 0x22) * 4;
      if ((ulong long)((*systemMemoryBlockPtr - (long long)ResourceManagerPointer) + systemMemoryBlockPtr[2]) <= hashValue) {
        FUN_180639bf0();
        ResourceManagerPointer = (uint *)systemMemoryBlockPtr[1];
      }
        memcpy(ResourceManagerPointer,creationFlags,hashValue);
    }
    hashValue = hashValue + 0x24;
    systemAllocationOffset = systemAllocationOffset + -1;
  } while (systemAllocationOffset != 0);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)ResourceManagerPointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    ResourceManagerPointer = (uint *)systemMemoryBlockPtr[1];
  }
  *ResourceManagerPointer = unaff_R13D;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *HashNodePointer = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(systemResourceHandle + 0x50);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = (uint)systemStatus;
  punsignedSystemValue4 = (uint *)(systemMemoryBlockPtr[1] + 4);
  systemMemoryBlockPtr[1] = (long long)punsignedSystemValue4;
  if (*(ushort *)(systemResourceHandle + 0x50) != 0) {
    creationFlags = *(void* *)(systemResourceHandle + 0x48);
    hashValue = (ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4;
    if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) <= hashValue) {
      FUN_180639bf0();
      punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
    }
      memcpy(punsignedSystemValue4,creationFlags,hashValue);
  }
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = unaff_R13D;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *HashNodePointer = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(systemResourceHandle + 0x62);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = (uint)systemStatus;
  localSystemPointer = systemMemoryBlockPtr[1] + 4;
  systemMemoryBlockPtr[1] = localSystemPointer;
  if (*(ushort *)(systemResourceHandle + 0x62) != 0) {
    creationFlags = *(void* *)(systemResourceHandle + 0x5a);
    hashValue = (ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4;
    if ((ulong long)((*systemMemoryBlockPtr - localSystemPointer) + systemMemoryBlockPtr[2]) <= hashValue) {
      FUN_180639bf0();
      localSystemPointer = systemMemoryBlockPtr[1];
    }
      memcpy(localSystemPointer,creationFlags,hashValue);
  }
  return;
}




// 函数: void FUN_180073e0b(uint32_t *ResourceManagerPointer)
/**
 * @brief 初始化资源管理器哈希节点
 * 
 * 该函数负责初始化资源管理器的哈希节点，设置哈希值和相关属性
 * 用于资源管理器的数据结构初始化
 * 
 * @param ResourceManagerPointer 资源管理器指针，指向要初始化的资源管理器
 * @return 无返回值
 * 
 * 原始函数名为FUN_180073e0b，现已重命名为InitializeResourceManagerHashNode
 */
void InitializeResourceManagerHashNode(uint32_t *ResourceManagerPointer)
{
  ushort SystemResourceStatus;
  void* ResourceCreationFlags;
  uint32_t *HashNodePointer;
  uint *SystemStatusValue;
  long long SystemTimestamp;
  long long *SystemMemoryBlockPtr;
  ulong long ResourceHashValue;
  uint32_t ResourceNodeId;
  long long SystemResourceHandle;
  
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)ResourceManagerPointer) + SystemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    ResourceManagerPointer = (uint32_t *)SystemMemoryBlockPtr[1];
  }
  *ResourceManagerPointer = ResourceNodeId;
  SystemMemoryBlockPtr[1] = SystemMemoryBlockPtr[1] + 4;
  HashNodePointer = (uint32_t *)SystemMemoryBlockPtr[1];
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)HashNodePointer) + SystemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)SystemMemoryBlockPtr[1];
  }
  *HashNodePointer = 0x10;
  SystemMemoryBlockPtr[1] = SystemMemoryBlockPtr[1] + 4;
  SystemStatusValue = (uint *)SystemMemoryBlockPtr[1];
  SystemResourceStatus = *(ushort *)(SystemResourceHandle + 0x50);
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)SystemStatusValue) + SystemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    SystemStatusValue = (uint *)SystemMemoryBlockPtr[1];
  }
  *SystemStatusValue = (uint)SystemResourceStatus;
  HashNodePointer = (uint32_t *)(SystemMemoryBlockPtr[1] + 4);
  SystemMemoryBlockPtr[1] = (long long)HashNodePointer;
  if (*(ushort *)(SystemResourceHandle + 0x50) != 0) {
    ResourceCreationFlags = *(void* *)(SystemResourceHandle + 0x48);
    ResourceHashValue = (ulong long)*(ushort *)(SystemResourceHandle + 0x50) * 4;
    if ((ulong long)((*SystemMemoryBlockPtr - (long long)HashNodePointer) + SystemMemoryBlockPtr[2]) <= ResourceHashValue) {
      FUN_180639bf0();
      HashNodePointer = (uint32_t *)SystemMemoryBlockPtr[1];
    }
      memcpy(HashNodePointer,ResourceCreationFlags,ResourceHashValue);
  }
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)HashNodePointer) + SystemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)SystemMemoryBlockPtr[1];
  }
  *HashNodePointer = ResourceNodeId;
  SystemMemoryBlockPtr[1] = SystemMemoryBlockPtr[1] + 4;
  return;
}




// 函数: void ProcessSystemResourceOperationA(void)
/**
 * @brief 处理系统资源操作A
 * 
 * 该函数处理系统资源的操作，包括资源分配、数据复制和内存管理。
 * 主要用于系统资源的管理和维护。
 */
void ProcessSystemResourceOperationA(void)

{
  ushort systemStatus;
  void* creationFlags;
  uint32_t *HashNodePointer;
  uint *punsignedSystemValue4;
  long long SystemTimeValue;
  long long *systemMemoryBlockPtr;
  ulong long hashValue;
  uint32_t unaff_R13D;
  long long systemResourceHandle;
  
  FUN_180639bf0();
  *(uint32_t *)systemMemoryBlockPtr[1] = unaff_R13D;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *HashNodePointer = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(systemResourceHandle + 0x50);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = (uint)systemStatus;
  HashNodePointer = (uint32_t *)(systemMemoryBlockPtr[1] + 4);
  systemMemoryBlockPtr[1] = (long long)HashNodePointer;
  if (*(ushort *)(systemResourceHandle + 0x50) != 0) {
    creationFlags = *(void* *)(systemResourceHandle + 0x48);
    hashValue = (ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4;
    if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) <= hashValue) {
      FUN_180639bf0();
      HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
    }
      memcpy(HashNodePointer,creationFlags,hashValue);
  }
  if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *HashNodePointer = unaff_R13D;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint32_t *)systemMemoryBlockPtr[1];
  }
  *HashNodePointer = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(systemResourceHandle + 0x62);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)punsignedSystemValue4) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    punsignedSystemValue4 = (uint *)systemMemoryBlockPtr[1];
  }
  *punsignedSystemValue4 = (uint)systemStatus;
  localSystemPointer = systemMemoryBlockPtr[1] + 4;
  systemMemoryBlockPtr[1] = localSystemPointer;
  if (*(ushort *)(systemResourceHandle + 0x62) != 0) {
    creationFlags = *(void* *)(systemResourceHandle + 0x5a);
    hashValue = (ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4;
    if ((ulong long)((*systemMemoryBlockPtr - localSystemPointer) + systemMemoryBlockPtr[2]) <= hashValue) {
      FUN_180639bf0();
      localSystemPointer = systemMemoryBlockPtr[1];
    }
      memcpy(localSystemPointer,creationFlags,hashValue);
  }
  return;
}




// 函数: void ProcessSystemResourceOperationB(void)
/**
 * @brief 处理系统资源操作B
 * 
 * 该函数处理系统资源的操作，包括数据复制和内存管理。
 * 主要用于系统资源的维护和清理。
 */
void ProcessSystemResourceOperationB(void)

{
  ushort systemStatus;
  void* creationFlags;
  uint *HashNodePointer;
  long long bufferBaseAddress;
  long long *systemMemoryBlockPtr;
  ulong long currentThreadId;
  long long systemResourceHandle;
  
  FUN_180639bf0();
  *(uint32_t *)systemMemoryBlockPtr[1] = 0x10;
  systemMemoryBlockPtr[1] = systemMemoryBlockPtr[1] + 4;
  HashNodePointer = (uint *)systemMemoryBlockPtr[1];
  systemStatus = *(ushort *)(systemResourceHandle + 0x62);
  if ((ulong long)((*systemMemoryBlockPtr - (long long)HashNodePointer) + systemMemoryBlockPtr[2]) < 5) {
    FUN_180639bf0();
    HashNodePointer = (uint *)systemMemoryBlockPtr[1];
  }
  *HashNodePointer = (uint)systemStatus;
  bufferBaseAddress = systemMemoryBlockPtr[1] + 4;
  systemMemoryBlockPtr[1] = bufferBaseAddress;
  if (*(ushort *)(systemResourceHandle + 0x62) != 0) {
    creationFlags = *(void* *)(systemResourceHandle + 0x5a);
    currentThreadId = (ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4;
    if ((ulong long)((*systemMemoryBlockPtr - bufferBaseAddress) + systemMemoryBlockPtr[2]) <= currentThreadId) {
      FUN_180639bf0();
      bufferBaseAddress = systemMemoryBlockPtr[1];
    }
      memcpy(bufferBaseAddress,creationFlags,currentThreadId);
  }
  return;
}





// 函数: void ProcessSystemResourceOperationC(long long *ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 处理系统资源操作C
 * 
 * 该函数处理系统资源的操作，包括资源分配、线程创建和内存管理。
 * 主要用于系统资源的初始化和维护。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递额外的系统参数
 */
void ProcessSystemResourceOperationC(long long *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  uint allocationContext;
  int systemIndex;
  long long SystemTimeValue;
  ulong long hashValue;
  long long localDataIndex;
  long long localMemoryAddress;
  uint *punsignedSystemValue9;
  long long allocationFlags;
  long long nextDataIndex1;
  long long *PrimaryResourcePointer2;
  
  allocationContext = **(uint **)(ConfigurationDataPointer + 8);
  punsignedSystemValue9 = *(uint **)(ConfigurationDataPointer + 8) + 1;
  *(uint **)(ConfigurationDataPointer + 8) = punsignedSystemValue9;
  if (allocationContext != 0) {
    (**(code **)(*ResourceManagerPointer + 0x18))(ResourceManagerPointer,punsignedSystemValue9,allocationContext);
    *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + (ulong long)allocationContext;
    punsignedSystemValue9 = *(uint **)(ConfigurationDataPointer + 8);
  }
  localMemoryAddress = (long long)(int)*punsignedSystemValue9;
  *(uint **)(ConfigurationDataPointer + 8) = punsignedSystemValue9 + 1;
  PrimaryResourcePointer = ResourceManagerPointer + 4;
  FUN_180074b30(PrimaryResourcePointer,localMemoryAddress);
  localSystemPointer = *(long long *)(ComparisonDataPointer + 8);
  localDataIndex = 0;
  nextDataIndex1 = localDataIndex;
  if (0 < localMemoryAddress) {
    do {
      allocationFlags = *PrimaryResourcePointer;
      *(int **)(ConfigurationDataPointer + 8) = (int *)(localSystemPointer + 8);
      systemIndex = *(int *)(localSystemPointer + 8);
      PrimaryResourcePointer2 = (long long *)(allocationFlags + nextDataIndex1);
      *(long long *)(ComparisonDataPointer + 8) = localSystemPointer + 0xc;
      if (0 < systemIndex) {
        *(short *)(PrimaryResourcePointer2 + 2) = (short)systemIndex;
        if (PrimaryResourcePointer2[1] != 0) {
            SystemCleanupFunction();
        }
        PrimaryResourcePointer2[1] = 0;
        if (*PrimaryResourcePointer2 == 0) {
          *PrimaryResourcePointer2 = 0;
          if ((ulong long)*(ushort *)(PrimaryResourcePointer2 + 2) == 0) {
            hashValue = 0;
            localSystemPointer = localDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(PrimaryResourcePointer2 + 2) * 4,4);
            hashValue = (ulong long)*(ushort *)(PrimaryResourcePointer2 + 2);
          }
          PrimaryResourcePointer2[1] = localSystemPointer;
          if (hashValue != 0) {
            localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,hashValue << 4,4);
          }
          *PrimaryResourcePointer2 = localDataIndex;
            memcpy(PrimaryResourcePointer2[1],*(void* *)(ConfigurationDataPointer + 8),(long long)(systemIndex * 4));
        }
          SystemCleanupFunction();
      }
      allocationFlags = *PrimaryResourcePointer;
      pointerToInteger2 = (int *)(localSystemPointer + 0x14);
      *(int **)(ConfigurationDataPointer + 8) = pointerToInteger2;
      localSystemPointer = localSystemPointer + 0x18;
      systemIndex = *pointerToInteger2;
      allocationFlags = allocationFlags + nextDataIndex1;
      *(long long *)(ComparisonDataPointer + 8) = localSystemPointer;
      if (0 < systemIndex) {
        *(short *)(allocationFlags + 0x22) = (short)systemIndex;
        if (*(long long *)(allocationFlags + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)(allocationFlags + 0x1a) = 0;
        if (*(long long *)(allocationFlags + 0x12) == 0) {
          *(void* *)(allocationFlags + 0x12) = 0;
          if ((ulong long)*(ushort *)(allocationFlags + 0x22) == 0) {
            hashValue = 0;
            localSystemPointer = localDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(allocationFlags + 0x22) * 4,4);
            hashValue = (ulong long)*(ushort *)(allocationFlags + 0x22);
          }
          *(long long *)(allocationFlags + 0x1a) = localSystemPointer;
          if (hashValue != 0) {
            localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,hashValue << 4,4);
          }
          *(long long *)(allocationFlags + 0x12) = localDataIndex;
            memcpy(*(void* *)(allocationFlags + 0x1a),*(void* *)(ConfigurationDataPointer + 8),(long long)(systemIndex * 4));
        }
          SystemCleanupFunction();
      }
      localMemoryAddress = localMemoryAddress + -1;
      nextDataIndex1 = nextDataIndex1 + 0x24;
    } while (localMemoryAddress != 0);
  }
  *(int **)(ConfigurationDataPointer + 8) = (int *)(localSystemPointer + 8);
  systemIndex = *(int *)(localSystemPointer + 8);
  *(long long *)(ComparisonDataPointer + 8) = localSystemPointer + 0xc;
  if (systemIndex < 1) {
    *(int **)(ConfigurationDataPointer + 8) = (int *)(localSystemPointer + 0x14);
    systemIndex = *(int *)(localSystemPointer + 0x14);
    *(long long *)(ComparisonDataPointer + 8) = localSystemPointer + 0x18;
    if (systemIndex < 1) {
      return;
    }
    *(short *)((long long)ResourceManagerPointer + 0x62) = (short)systemIndex;
    if (*(long long *)((long long)ResourceManagerPointer + 0x5a) == 0) {
      *(void* *)((long long)ResourceManagerPointer + 0x5a) = 0;
      if (*(long long *)((long long)ResourceManagerPointer + 0x52) == 0) {
        *(void* *)((long long)ResourceManagerPointer + 0x52) = 0;
        if ((ulong long)*(ushort *)((long long)ResourceManagerPointer + 0x62) == 0) {
          hashValue = 0;
          localSystemPointer = localDataIndex;
        }
        else {
          localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)((long long)ResourceManagerPointer + 0x62) * 4,
                                4);
          hashValue = (ulong long)*(ushort *)((long long)ResourceManagerPointer + 0x62);
        }
        *(long long *)((long long)ResourceManagerPointer + 0x5a) = localSystemPointer;
        if (hashValue != 0) {
          localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,hashValue << 4,4);
        }
        *(long long *)((long long)ResourceManagerPointer + 0x52) = localDataIndex;
          memcpy(*(void* *)((long long)ResourceManagerPointer + 0x5a),*(void* *)(ConfigurationDataPointer + 8),
               (long long)(systemIndex * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(ResourceManagerPointer + 10) = (short)systemIndex;
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[9] = 0;
  if (ResourceManagerPointer[8] == 0) {
    ResourceManagerPointer[8] = 0;
    if ((ulong long)*(ushort *)(ResourceManagerPointer + 10) == 0) {
      hashValue = 0;
      localSystemPointer = localDataIndex;
    }
    else {
      localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(ResourceManagerPointer + 10) * 4,4);
      hashValue = (ulong long)*(ushort *)(ResourceManagerPointer + 10);
    }
    ResourceManagerPointer[9] = localSystemPointer;
    if (hashValue != 0) {
      localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,hashValue << 4,4);
    }
    ResourceManagerPointer[8] = localDataIndex;
      memcpy(ResourceManagerPointer[9],*(void* *)(ConfigurationDataPointer + 8),(long long)(systemIndex * 4));
  }
    SystemCleanupFunction();
}





// 函数: void FUN_1800740a2(long long *ResourceManagerPointer)
/**
 * @brief 处理系统资源分配和数据初始化
 * 
 * 该函数负责处理系统资源的分配和数据的初始化操作
 * 用于系统资源管理和数据结构的建立
 * 
 * @param ResourceManagerPointer 资源管理器指针，指向要处理的资源管理器
 * @return 无返回值
 * 
 * 原始函数名为FUN_1800740a2，现已重命名为ProcessSystemResourceAllocation
 */
void ProcessSystemResourceAllocation(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  int *SecondaryResourcePointer;
  uint AllocationContextSize;
  int SystemResourceIndex;
  uint *SystemResourceArray;
  long long SystemTimestamp;
  ulong long ResourceHashValue;
  long long CurrentDataIndex;
  long long MemoryAllocationSize;
  uint *ResourceDataPointer;
  long long ResourceAllocationFlags;
  long long SystemDataIndexPointer;
  long long ResourceDataOffset;
  long long *SecondaryResourceDataPointer;
  
  AllocationContextSize = *SystemResourceArray;
  ResourceDataPointer = SystemResourceArray + 1;
  *(uint **)(SystemDataIndexPointer + 8) = ResourceDataPointer;
  if (AllocationContextSize != 0) {
    (**(code **)(*ResourceManagerPointer + 0x18))(ResourceManagerPointer,ResourceDataPointer,AllocationContextSize);
    *(long long *)(SystemDataIndexPointer + 8) = *(long long *)(SystemDataIndexPointer + 8) + (ulong long)AllocationContextSize;
    ResourceDataPointer = *(uint **)(SystemDataIndexPointer + 8);
  }
  MemoryAllocationSize = (long long)(int)*ResourceDataPointer;
  *(uint **)(SystemDataIndexPointer + 8) = ResourceDataPointer + 1;
  PrimaryResourcePointer = ResourceManagerPointer + 4;
  FUN_180074b30(PrimaryResourcePointer,MemoryAllocationSize);
  localSystemPointer = *(long long *)(SystemDataIndexPointer + 8);
  CurrentDataIndex = 0;
  ResourceDataOffset = CurrentDataIndex;
  if (0 < MemoryAllocationSize) {
    do {
      ResourceAllocationFlags = *PrimaryResourcePointer;
      *(int **)(SystemDataIndexPointer + 8) = (int *)(localSystemPointer + 8);
      SystemResourceIndex = *(int *)(localSystemPointer + 8);
      SecondaryResourceDataPointer = (long long *)(ResourceAllocationFlags + ResourceDataOffset);
      *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer + 0xc;
      if (0 < SystemResourceIndex) {
        *(short *)(SecondaryResourceDataPointer + 2) = (short)SystemResourceIndex;
        if (SecondaryResourceDataPointer[1] != 0) {
            SystemCleanupFunction();
        }
        SecondaryResourceDataPointer[1] = 0;
        if (*SecondaryResourceDataPointer == 0) {
          *SecondaryResourceDataPointer = 0;
          if ((ulong long)*(ushort *)(SecondaryResourceDataPointer + 2) == 0) {
            ResourceHashValue = 0;
            localSystemPointer = CurrentDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(SecondaryResourceDataPointer + 2) * 4,4);
            ResourceHashValue = (ulong long)*(ushort *)(SecondaryResourceDataPointer + 2);
          }
          SecondaryResourceDataPointer[1] = localSystemPointer;
          if (ResourceHashValue != 0) {
            CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
          }
          *SecondaryResourceDataPointer = CurrentDataIndex;
            memcpy(SecondaryResourceDataPointer[1],*(void* *)(SystemDataIndexPointer + 8),(long long)(SystemResourceIndex * 4));
        }
          SystemCleanupFunction();
      }
      ResourceAllocationFlags = *PrimaryResourcePointer;
      SecondaryResourcePointer = (int *)(localSystemPointer + 0x14);
      *(int **)(SystemDataIndexPointer + 8) = SecondaryResourcePointer;
      localSystemPointer = localSystemPointer + 0x18;
      SystemResourceIndex = *SecondaryResourcePointer;
      ResourceAllocationFlags = ResourceAllocationFlags + ResourceDataOffset;
      *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer;
      if (0 < SystemResourceIndex) {
        *(short *)(ResourceAllocationFlags + 0x22) = (short)SystemResourceIndex;
        if (*(long long *)(ResourceAllocationFlags + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)(ResourceAllocationFlags + 0x1a) = 0;
        if (*(long long *)(ResourceAllocationFlags + 0x12) == 0) {
          *(void* *)(ResourceAllocationFlags + 0x12) = 0;
          if ((ulong long)*(ushort *)(ResourceAllocationFlags + 0x22) == 0) {
            ResourceHashValue = 0;
            localSystemPointer = CurrentDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(ResourceAllocationFlags + 0x22) * 4,4);
            ResourceHashValue = (ulong long)*(ushort *)(ResourceAllocationFlags + 0x22);
          }
          *(long long *)(ResourceAllocationFlags + 0x1a) = localSystemPointer;
          if (ResourceHashValue != 0) {
            CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
          }
          *(long long *)(ResourceAllocationFlags + 0x12) = CurrentDataIndex;
            memcpy(*(void* *)(ResourceAllocationFlags + 0x1a),*(void* *)(SystemDataIndexPointer + 8),(long long)(SystemResourceIndex * 4)
                );
        }
          SystemCleanupFunction();
      }
      MemoryAllocationSize = MemoryAllocationSize + -1;
      ResourceDataOffset = ResourceDataOffset + 0x24;
    } while (MemoryAllocationSize != 0);
  }
  *(int **)(SystemDataIndexPointer + 8) = (int *)(localSystemPointer + 8);
  SystemResourceIndex = *(int *)(localSystemPointer + 8);
  *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer + 0xc;
  if (SystemResourceIndex < 1) {
    *(int **)(SystemDataIndexPointer + 8) = (int *)(localSystemPointer + 0x14);
    SystemResourceIndex = *(int *)(localSystemPointer + 0x14);
    *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer + 0x18;
    if (SystemResourceIndex < 1) {
      return;
    }
    *(short *)((long long)ResourceManagerPointer + 0x62) = (short)SystemResourceIndex;
    if (*(long long *)((long long)ResourceManagerPointer + 0x5a) == 0) {
      *(void* *)((long long)ResourceManagerPointer + 0x5a) = 0;
      if (*(long long *)((long long)ResourceManagerPointer + 0x52) == 0) {
        *(void* *)((long long)ResourceManagerPointer + 0x52) = 0;
        if ((ulong long)*(ushort *)((long long)ResourceManagerPointer + 0x62) == 0) {
          ResourceHashValue = 0;
          localSystemPointer = CurrentDataIndex;
        }
        else {
          localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)((long long)ResourceManagerPointer + 0x62) * 4,
                                4);
          ResourceHashValue = (ulong long)*(ushort *)((long long)ResourceManagerPointer + 0x62);
        }
        *(long long *)((long long)ResourceManagerPointer + 0x5a) = localSystemPointer;
        if (ResourceHashValue != 0) {
          CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
        }
        *(long long *)((long long)ResourceManagerPointer + 0x52) = CurrentDataIndex;
          memcpy(*(void* *)((long long)ResourceManagerPointer + 0x5a),*(void* *)(SystemDataIndexPointer + 8),
               (long long)(SystemResourceIndex * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(ResourceManagerPointer + 10) = (short)SystemResourceIndex;
  if (ResourceManagerPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[9] = 0;
  if (ResourceManagerPointer[8] == 0) {
    ResourceManagerPointer[8] = 0;
    if ((ulong long)*(ushort *)(ResourceManagerPointer + 10) == 0) {
      ResourceHashValue = 0;
      localSystemPointer = CurrentDataIndex;
    }
    else {
      localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(ResourceManagerPointer + 10) * 4,4);
      ResourceHashValue = (ulong long)*(ushort *)(ResourceManagerPointer + 10);
    }
    ResourceManagerPointer[9] = localSystemPointer;
    if (ResourceHashValue != 0) {
      CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
    }
    ResourceManagerPointer[8] = CurrentDataIndex;
      memcpy(ResourceManagerPointer[9],*(void* *)(SystemDataIndexPointer + 8),(long long)(SystemResourceIndex * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 初始化系统缓冲区管理器
 * 
 * 该函数负责初始化系统缓冲区管理器，设置缓冲区的大小和参数。
 * 主要用于系统缓冲区的创建和管理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向缓冲区管理器数据结构
 * 
 * 原始函数名为FUN_1800740f5，现已重命名为InitializeSystemBufferManager
 */
void InitializeSystemBufferManager(long long ResourceManagerPointer)

{
  int systemStatus;
  ulong long creationFlags;
  long long localResourceOffset;
  long long *systemMemoryBlockPtr;
  long long bufferBaseAddress;
  ulong long systemStringIteratorPtr;
  long long systemDataIndexPtr;
  ulong long currentThreadId;
  long long unaff_R13;
  ulong long *resourceEntryPointer;
  long long systemResourceHandle;
  
  currentThreadId = systemStringIteratorPtr & 0xffffffff;
  do {
    localResourceOffset = ResourceManagerPointer;
    bufferBaseAddress = *systemMemoryBlockPtr;
    *(int **)(systemDataIndexPtr + 8) = (int *)(localResourceOffset + 8);
    systemStatus = *(int *)(localResourceOffset + 8);
    resourceEntryPointer = (ulong long *)(bufferBaseAddress + currentThreadId);
    *(long long *)(systemDataIndexPtr + 8) = localResourceOffset + 0xc;
    if (0 < systemStatus) {
      *(short *)(resourceEntryPointer + 2) = (short)systemStatus;
      if (resourceEntryPointer[1] != 0) {
          SystemCleanupFunction();
      }
      resourceEntryPointer[1] = systemStringIteratorPtr;
      if (*resourceEntryPointer == 0) {
        *resourceEntryPointer = systemStringIteratorPtr;
        if ((ulong long)(ushort)resourceEntryPointer[2] == 0) {
          currentThreadId = 0;
          creationFlags = systemStringIteratorPtr;
        }
        else {
          creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)(ushort)resourceEntryPointer[2] * 4,4);
          currentThreadId = (ulong long)(ushort)resourceEntryPointer[2];
        }
        resourceEntryPointer[1] = creationFlags;
        if (currentThreadId != 0) {
          systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
        }
        *resourceEntryPointer = systemStringIteratorPtr;
          memcpy(resourceEntryPointer[1],*(void* *)(systemDataIndexPtr + 8),(long long)(systemStatus * 4));
      }
        SystemCleanupFunction();
    }
    bufferBaseAddress = *systemMemoryBlockPtr;
    *(int **)(systemDataIndexPtr + 8) = (int *)(localResourceOffset + 0x14);
    systemStatus = *(int *)(localResourceOffset + 0x14);
    bufferBaseAddress = bufferBaseAddress + currentThreadId;
    *(long long *)(systemDataIndexPtr + 8) = localResourceOffset + 0x18;
    if (0 < systemStatus) {
      *(short *)(bufferBaseAddress + 0x22) = (short)systemStatus;
      if (*(long long *)(bufferBaseAddress + 0x1a) != 0) {
          SystemCleanupFunction();
      }
      *(ulong long *)(bufferBaseAddress + 0x1a) = systemStringIteratorPtr;
      if (*(long long *)(bufferBaseAddress + 0x12) == 0) {
        *(ulong long *)(bufferBaseAddress + 0x12) = systemStringIteratorPtr;
        if ((ulong long)*(ushort *)(bufferBaseAddress + 0x22) == 0) {
          currentThreadId = 0;
          creationFlags = systemStringIteratorPtr;
        }
        else {
          creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(bufferBaseAddress + 0x22) * 4,4);
          currentThreadId = (ulong long)*(ushort *)(bufferBaseAddress + 0x22);
        }
        *(ulong long *)(bufferBaseAddress + 0x1a) = creationFlags;
        if (currentThreadId != 0) {
          systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
        }
        *(ulong long *)(bufferBaseAddress + 0x12) = systemStringIteratorPtr;
          memcpy(*(void* *)(bufferBaseAddress + 0x1a),*(void* *)(systemDataIndexPtr + 8),(long long)(systemStatus * 4));
      }
        SystemCleanupFunction();
    }
    currentThreadId = currentThreadId + 0x24;
    unaff_R13 = unaff_R13 + -1;
    ResourceManagerPointer = localResourceOffset + 0x18;
  } while (unaff_R13 != 0);
  *(int **)(systemDataIndexPtr + 8) = (int *)(localResourceOffset + 0x20);
  systemStatus = *(int *)(localResourceOffset + 0x20);
  *(long long *)(systemDataIndexPtr + 8) = localResourceOffset + 0x24;
  if (systemStatus < 1) {
    *(int **)(systemDataIndexPtr + 8) = (int *)(localResourceOffset + 0x2c);
    systemStatus = *(int *)(localResourceOffset + 0x2c);
    *(long long *)(systemDataIndexPtr + 8) = localResourceOffset + 0x30;
    if (systemStatus < 1) {
      return;
    }
    *(short *)(systemResourceHandle + 0x62) = (short)systemStatus;
    if (*(long long *)(systemResourceHandle + 0x5a) == 0) {
      *(ulong long *)(systemResourceHandle + 0x5a) = systemStringIteratorPtr;
      if (*(long long *)(systemResourceHandle + 0x52) == 0) {
        *(ulong long *)(systemResourceHandle + 0x52) = systemStringIteratorPtr;
        if ((ulong long)*(ushort *)(systemResourceHandle + 0x62) == 0) {
          currentThreadId = 0;
          creationFlags = systemStringIteratorPtr;
        }
        else {
          creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4,4);
          currentThreadId = (ulong long)*(ushort *)(systemResourceHandle + 0x62);
        }
        *(ulong long *)(systemResourceHandle + 0x5a) = creationFlags;
        if (currentThreadId != 0) {
          systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
        }
        *(ulong long *)(systemResourceHandle + 0x52) = systemStringIteratorPtr;
          memcpy(*(void* *)(systemResourceHandle + 0x5a),*(void* *)(systemDataIndexPtr + 8),
               (long long)(systemStatus * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(systemResourceHandle + 0x50) = (short)systemStatus;
  if (*(long long *)(systemResourceHandle + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(ulong long *)(systemResourceHandle + 0x48) = systemStringIteratorPtr;
  if (*(long long *)(systemResourceHandle + 0x40) == 0) {
    *(ulong long *)(systemResourceHandle + 0x40) = systemStringIteratorPtr;
    if ((ulong long)*(ushort *)(systemResourceHandle + 0x50) == 0) {
      currentThreadId = 0;
      creationFlags = systemStringIteratorPtr;
    }
    else {
      creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4,4);
      currentThreadId = (ulong long)*(ushort *)(systemResourceHandle + 0x50);
    }
    *(ulong long *)(systemResourceHandle + 0x48) = creationFlags;
    if (currentThreadId != 0) {
      systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
    }
    *(ulong long *)(systemResourceHandle + 0x40) = systemStringIteratorPtr;
      memcpy(*(void* *)(systemResourceHandle + 0x48),*(void* *)(systemDataIndexPtr + 8),(long long)(systemStatus * 4));
  }
    SystemCleanupFunction();
}





// 函数: void FUN_1800742ea(long long ResourceManagerPointer)
void FUN_1800742ea(long long ResourceManagerPointer)

{
  int systemStatus;
  void* creationFlags;
  ulong long allocationContext;
  void* systemStringIteratorPtr;
  long long systemDataIndexPtr;
  long long systemResourceHandle;
  
  *(int **)(systemDataIndexPtr + 8) = (int *)(ResourceManagerPointer + 8);
  systemStatus = *(int *)(ResourceManagerPointer + 8);
  *(long long *)(systemDataIndexPtr + 8) = ResourceManagerPointer + 0xc;
  if (systemStatus < 1) {
    *(int **)(systemDataIndexPtr + 8) = (int *)(ResourceManagerPointer + 0x14);
    systemStatus = *(int *)(ResourceManagerPointer + 0x14);
    *(long long *)(systemDataIndexPtr + 8) = ResourceManagerPointer + 0x18;
    if (systemStatus < 1) {
      return;
    }
    *(short *)(systemResourceHandle + 0x62) = (short)systemStatus;
    if (*(long long *)(systemResourceHandle + 0x5a) == 0) {
      *(void* *)(systemResourceHandle + 0x5a) = systemStringIteratorPtr;
      if (*(long long *)(systemResourceHandle + 0x52) == 0) {
        *(void* *)(systemResourceHandle + 0x52) = systemStringIteratorPtr;
        if ((ulong long)*(ushort *)(systemResourceHandle + 0x62) == 0) {
          allocationContext = 0;
          creationFlags = systemStringIteratorPtr;
        }
        else {
          creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4,4);
          allocationContext = (ulong long)*(ushort *)(systemResourceHandle + 0x62);
        }
        *(void* *)(systemResourceHandle + 0x5a) = creationFlags;
        if (allocationContext != 0) {
          systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,allocationContext << 4,4);
        }
        *(void* *)(systemResourceHandle + 0x52) = systemStringIteratorPtr;
          memcpy(*(void* *)(systemResourceHandle + 0x5a),*(void* *)(systemDataIndexPtr + 8),
               (long long)(systemStatus * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(systemResourceHandle + 0x50) = (short)systemStatus;
  if (*(long long *)(systemResourceHandle + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(systemResourceHandle + 0x48) = systemStringIteratorPtr;
  if (*(long long *)(systemResourceHandle + 0x40) == 0) {
    *(void* *)(systemResourceHandle + 0x40) = systemStringIteratorPtr;
    if ((ulong long)*(ushort *)(systemResourceHandle + 0x50) == 0) {
      allocationContext = 0;
      creationFlags = systemStringIteratorPtr;
    }
    else {
      creationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4,4);
      allocationContext = (ulong long)*(ushort *)(systemResourceHandle + 0x50);
    }
    *(void* *)(systemResourceHandle + 0x48) = creationFlags;
    if (allocationContext != 0) {
      systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,allocationContext << 4,4);
    }
    *(void* *)(systemResourceHandle + 0x40) = systemStringIteratorPtr;
      memcpy(*(void* *)(systemResourceHandle + 0x48),*(void* *)(systemDataIndexPtr + 8),(long long)(systemStatus * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 系统全局状态初始化函数
 * 
 * 该函数负责初始化系统的全局状态，包括：
 * - 设置系统全局数据结构
 * - 初始化系统状态标志
 * - 配置系统内存管理
 * - 建立系统基础架构
 * 
 * @return 无返回值
 * @note 此函数在系统启动时调用，用于建立系统基础架构
 * @warning 调用此函数前必须确保系统资源已准备就绪
 */
void InitializeSystemGlobalState(void)

{
  void* systemStatus;
  ulong long creationFlags;
  void*2 unaff_BP;
  void*6 unaff_0000002a;
  void* systemStringIteratorPtr;
  long long systemDataIndexPtr;
  long long systemResourceHandle;
  
  *(void*2 *)(systemResourceHandle + 0x50) = unaff_BP;
  if (*(long long *)(systemResourceHandle + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(systemResourceHandle + 0x48) = systemStringIteratorPtr;
  if (*(long long *)(systemResourceHandle + 0x40) == 0) {
    *(void* *)(systemResourceHandle + 0x40) = systemStringIteratorPtr;
    if ((ulong long)*(ushort *)(systemResourceHandle + 0x50) == 0) {
      creationFlags = 0;
      systemStatus = systemStringIteratorPtr;
    }
    else {
      systemStatus = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4,4);
      creationFlags = (ulong long)*(ushort *)(systemResourceHandle + 0x50);
    }
    *(void* *)(systemResourceHandle + 0x48) = systemStatus;
    if (creationFlags != 0) {
      systemStringIteratorPtr = CreateSystemThreadObject(SystemMemoryPoolTemplate,creationFlags << 4,4);
    }
    *(void* *)(systemResourceHandle + 0x40) = systemStringIteratorPtr;
      memcpy(*(void* *)(systemResourceHandle + 0x48),*(void* *)(systemDataIndexPtr + 8),
           (long long)((int)CONCAT62(unaff_0000002a,unaff_BP) * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 系统资源时间戳管理函数
 * 
 * 该函数负责管理系统资源的时间戳，包括：
 * - 更新资源访问时间
 * - 记录资源修改时间
 * - 管理资源生命周期
 * - 处理时间相关的资源操作
 * 
 * @param ResourceManagerPointer 系统资源指针，指向需要管理的资源
 * @param ConfigurationDataPointer 时间参数，用于时间戳操作
 * @return 无返回值
 * @note 此函数用于资源的时间管理和生命周期控制
 * @warning 调用此函数前确保资源指针有效
 */
void ManageSystemResourceTimestamp(long long ResourceManagerPointer, long long TimestampParameter)

{
  uint *pointerToUnsigned1;
  int systemResult;
  uint allocationContext;
  int *pointerToInteger4;
  long long SystemTimeValue;
  int systemFlag;
  int systemOffset;
  int systemCode;
  uint32_t unsignedSystemValue9;
  uint32_t systemOperationFlags;
  uint32_t systemStatus1;
  uint8_t *psystemStatus2;
  uint32_t *pointerToUnsigned13;
  uint8_t aunsignedValueF8 [32];
  void* unsignedValueD8;
  void* *pointerUnsignedC8;
  uint8_t *pUnsignedStackFlagC0;
  uint32_t UnsignedStackFlagB8;
  uint8_t aUnsignedStackFlagB0 [136];
  ulong long EncryptionKeyValue;
  
  unsignedValueD8 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aunsignedValueF8;
  pointerToInteger4 = *(int **)(ConfigurationDataPointer + 8);
  systemResult = *pointerToInteger4;
  *(int **)(ConfigurationDataPointer + 8) = pointerToInteger4 + 1;
  systemFlag = pointerToInteger4[2];
  systemOffset = pointerToInteger4[3];
  systemCode = pointerToInteger4[4];
  *(int *)(ResourceManagerPointer + 0x18) = pointerToInteger4[1];
  *(int *)(ResourceManagerPointer + 0x1c) = systemFlag;
  *(int *)(ResourceManagerPointer + 0x20) = systemOffset;
  *(int *)(ResourceManagerPointer + 0x24) = systemCode;
  psystemStatus2 = (uint8_t *)(*(long long *)(ComparisonDataPointer + 8) + 0x10);
  *(uint8_t **)(ConfigurationDataPointer + 8) = psystemStatus2;
  *(uint8_t *)(ResourceManagerPointer + 0x28) = *psystemStatus2;
  localSystemPointer = *(long long *)(ComparisonDataPointer + 8);
  *(uint32_t **)(ConfigurationDataPointer + 8) = (uint32_t *)(localSystemPointer + 1);
  if (systemResult == 0) {
    pointerUnsignedC8 = &SystemResourceTemplatePrimary;
    pUnsignedStackFlagC0 = aUnsignedStackFlagB0;
    UnsignedStackFlagB8 = 0;
    aUnsignedStackFlagB0[0] = 0;
    allocationContext = **(uint **)(ConfigurationDataPointer + 8);
    pointerToUnsigned1 = *(uint **)(ConfigurationDataPointer + 8) + 1;
    *(uint **)(ConfigurationDataPointer + 8) = pointerToUnsigned1;
    if (allocationContext != 0) {
      FUN_180049910(&pointerUnsignedC8,pointerToUnsigned1,allocationContext);
      *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + (ulong long)allocationContext;
    }
    pointerUnsignedC8 = &SystemMemoryAllocatorReference;
    pointerToUnsigned13 = *(uint32_t **)(ConfigurationDataPointer + 8);
  }
  else {
    unsignedSystemValue9 = *(uint32_t *)(localSystemPointer + 5);
    systemOperationFlags = *(uint32_t *)(localSystemPointer + 9);
    systemStatus1 = *(uint32_t *)(localSystemPointer + 0xd);
    *(uint32_t *)(ResourceManagerPointer + 8) = *(uint32_t *)(localSystemPointer + 1);
    *(uint32_t *)(ResourceManagerPointer + 0xc) = unsignedSystemValue9;
    *(uint32_t *)(ResourceManagerPointer + 0x10) = systemOperationFlags;
    *(uint32_t *)(ResourceManagerPointer + 0x14) = systemStatus1;
    *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + 0x10;
    pointerToUnsigned13 = *(uint32_t **)(ConfigurationDataPointer + 8);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x2c) = *pointerToUnsigned13;
  pointerToUnsigned13 = (uint32_t *)(*(long long *)(ComparisonDataPointer + 8) + 4);
  *(uint32_t **)(ConfigurationDataPointer + 8) = pointerToUnsigned13;
  *(uint32_t *)(ResourceManagerPointer + 0x30) = *pointerToUnsigned13;
  pointerToUnsigned13 = (uint32_t *)(*(long long *)(ComparisonDataPointer + 8) + 4);
  *(uint32_t **)(ConfigurationDataPointer + 8) = pointerToUnsigned13;
  *(uint32_t *)(ResourceManagerPointer + 0x34) = *pointerToUnsigned13;
  *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + 4;
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)aunsignedValueF8);
}




/**
 * @brief 系统数据表创建和配置函数
 * 
 * 该函数负责创建和配置系统数据表，包括：
 * - 分配数据表内存
 * - 初始化数据表结构
 * - 设置数据表参数
 * - 配置数据表属性
 * 
 * @param ResourceManagerPointer 系统资源指针，用于数据表创建
 * @param ConfigurationDataPointer 配置参数，包含数据表的配置信息
 * @return 返回创建的数据表指针
 * @note 此函数用于系统数据表的动态创建和配置
 * @warning 调用此函数后需要正确释放返回的数据表
 */
void* * CreateAndConfigureSystemDataTable(void* ResourceManagerPointer, long long ConfigurationParameter)

{
  void* systemStatus;
  void** SystemDataTable;
  
  HashEntryStatus = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x38,8,3,0xfffffffffffffffe);
  *HashEntryStatus = &SystemResourceManagerDataTableA;
  *HashEntryStatus = &SystemResourceManagerDataTableB;
  *(void* *)((long long)HashEntryStatus + 0x2c) = 0;
  *(uint32_t *)((long long)HashEntryStatus + 0x34) = 0;
  *(uint8_t *)(HashEntryStatus + 5) = 0;
  HashEntryStatus[3] = 0;
  HashEntryStatus[4] = 0;
  HashEntryStatus[1] = 0;
  HashEntryStatus[2] = 0;
  if (ConfigurationDataPointer != 0) {
    systemStatus = *(void* *)(ConfigurationDataPointer + 0x10);
    HashEntryStatus[1] = *(void* *)(ConfigurationDataPointer + 8);
    HashEntryStatus[2] = systemStatus;
    systemStatus = *(void* *)(ConfigurationDataPointer + 0x20);
    HashEntryStatus[3] = *(void* *)(ConfigurationDataPointer + 0x18);
    HashEntryStatus[4] = systemStatus;
    *(uint8_t *)(HashEntryStatus + 5) = *(uint8_t *)(ConfigurationDataPointer + 0x28);
    *(uint32_t *)((long long)HashEntryStatus + 0x2c) = *(uint32_t *)(ConfigurationDataPointer + 0x2c);
    *(uint32_t *)(HashEntryStatus + 6) = *(uint32_t *)(ConfigurationDataPointer + 0x30);
    *(uint32_t *)((long long)HashEntryStatus + 0x34) = *(uint32_t *)(ConfigurationDataPointer + 0x34);
  }
  return HashEntryStatus;
}





// 函数: void FUN_1800746c0(long long ResourceManagerPointer)
void FUN_1800746c0(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  int systemResult;
  long long *plocalResourceOffset;
  long long* SystemMemoryPointer;
  void* *pcurrentThreadId;
  
  if (*(char *)(*(long long *)(ResourceManagerPointer + 0x20) + 0x28) == '\0') {
    plocalResourceOffset = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,0x10,4,0xfffffffffffffffe);
    *plocalResourceOffset = (long long)&SystemMemoryTemplateA;
    *plocalResourceOffset = (long long)&SystemMemoryTemplateB;
    *(uint32_t *)(plocalResourceOffset + 1) = 0;
    *plocalResourceOffset = (long long)&UNK_180a02e68;
    plocalResourceOffset[2] = (long long)&SystemMemoryAllocatorReference;
    plocalResourceOffset[3] = 0;
    *(uint32_t *)(plocalResourceOffset + 4) = 0;
    plocalResourceOffset[2] = (long long)&SystemResourceTemplatePrimary;
    plocalResourceOffset[3] = (long long)(plocalResourceOffset + 5);
    *(uint32_t *)(plocalResourceOffset + 4) = 0;
    *(uint8_t *)(plocalResourceOffset + 5) = 0;
    *(uint8_t *)((long long)plocalResourceOffset + 0xb2) = 0;
    *(uint32_t *)(plocalResourceOffset + 1) = 0;
    *(void*2 *)(plocalResourceOffset + 0x16) = 0;
    plocalResourceOffset[0x15] = 0;
    *plocalResourceOffset = (long long)&UNK_180a13a28;
    plocalResourceOffset[0x15] = 0;
    *(uint8_t *)(plocalResourceOffset + 0x17) = 0;
    (**(code **)(*plocalResourceOffset + 0x28))(plocalResourceOffset);
    pbufferBaseAddress = *(long long **)(ResourceManagerPointer + 0xb0);
    *(long long **)(ResourceManagerPointer + 0xb0) = plocalResourceOffset;
    if (pbufferBaseAddress != (long long *)0x0) {
      (**(code **)(*pbufferBaseAddress + 0x38))();
    }
    *(long long *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0xa8) = ResourceManagerPointer;
    pbufferBaseAddress = (long long *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0x10);
    pcurrentThreadId = &SystemStringTemplate;
    if (*(void* **)(ResourceManagerPointer + 0x70) != (void* *)0x0) {
      pcurrentThreadId = *(void* **)(ResourceManagerPointer + 0x70);
    }
    (**(code **)(*pbufferBaseAddress + 0x10))(pbufferBaseAddress,pcurrentThreadId);
    *(uint8_t *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0xb1) = 1;
    nextDataIndex = SystemInputManagerPointer;
    pbufferBaseAddress = *(long long **)(ResourceManagerPointer + 0xb0);
    systemResult = (**(code **)(*pbufferBaseAddress + 0x60))(pbufferBaseAddress);
    *(uint8_t *)((long long)pbufferBaseAddress + 0xb2) = 1;
    FUN_1802abe00((long long)systemResult * 0x98 + nextDataIndex + 8,pbufferBaseAddress);
  }
  return;
}




// 函数: void FUN_180074840(long long ResourceManagerPointer)
void FUN_180074840(long long ResourceManagerPointer)

{
  long long *plStackX_8;
  long long **pplStackX_10;
  
  if (*(long long *)(ResourceManagerPointer + 0xb0) != 0) {
    *(void* *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0xa8) = 0;
    pplStackX_10 = &plStackX_8;
    plStackX_8 = *(long long **)(ResourceManagerPointer + 0xb0);
    if (plStackX_8 != (long long *)0x0) {
      (**(code **)(*plStackX_8 + 0x28))();
    }
    FUN_1800b55b0();
    pplStackX_10 = *(long long ***)(ResourceManagerPointer + 0xb0);
    *(void* *)(ResourceManagerPointer + 0xb0) = 0;
    if (pplStackX_10 != (long long **)0x0) {
                    0001800748c2. Too many branches
                          (**(code **)((long long)*pplStackX_10 + 0x38))();
      return;
    }
  }
  return;
}




// 函数: void FUN_1800748d0(long long ResourceManagerPointer,long long *ConfigurationDataPointer)
void FUN_1800748d0(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  uint8_t systemStatus;
  uint32_t creationFlags;
  uint32_t allocationContext;
  uint32_t unsignedSystemValue4;
  uint32_t *pcurrentThreadId;
  uint8_t *resourceEntryPointer;
  
  pcurrentThreadId = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)pcurrentThreadId) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pcurrentThreadId + (4 - *ConfigurationDataPointer));
    pcurrentThreadId = (uint32_t *)ConfigurationDataPointer[1];
  }
  *pcurrentThreadId = 1;
  pcurrentThreadId = (uint32_t *)(ConfigurationDataPointer[1] + 4);
  ConfigurationDataPointer[1] = (long long)pcurrentThreadId;
  if ((ulong long)((*ConfigurationDataPointer - (long long)pcurrentThreadId) + ConfigurationDataPointer[2]) < 0x11) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pcurrentThreadId + (0x10 - *ConfigurationDataPointer));
    pcurrentThreadId = (uint32_t *)ConfigurationDataPointer[1];
  }
  creationFlags = *(uint32_t *)(ResourceManagerPointer + 0x1c);
  allocationContext = *(uint32_t *)(ResourceManagerPointer + 0x20);
  unsignedSystemValue4 = *(uint32_t *)(ResourceManagerPointer + 0x24);
  *pcurrentThreadId = *(uint32_t *)(ResourceManagerPointer + 0x18);
  pcurrentThreadId[1] = creationFlags;
  pcurrentThreadId[2] = allocationContext;
  pcurrentThreadId[3] = unsignedSystemValue4;
  resourceEntryPointer = (uint8_t *)(ConfigurationDataPointer[1] + 0x10);
  ConfigurationDataPointer[1] = (long long)resourceEntryPointer;
  systemStatus = *(uint8_t *)(ResourceManagerPointer + 0x28);
  if ((ulong long)((*ConfigurationDataPointer - (long long)resourceEntryPointer) + ConfigurationDataPointer[2]) < 2) {
    FUN_180639bf0(ConfigurationDataPointer,resourceEntryPointer + (1 - *ConfigurationDataPointer));
    resourceEntryPointer = (uint8_t *)ConfigurationDataPointer[1];
  }
  *resourceEntryPointer = systemStatus;
  pcurrentThreadId = (uint32_t *)(ConfigurationDataPointer[1] + 1);
  ConfigurationDataPointer[1] = (long long)pcurrentThreadId;
  if ((ulong long)((*ConfigurationDataPointer - (long long)pcurrentThreadId) + ConfigurationDataPointer[2]) < 0x11) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pcurrentThreadId + (0x10 - *ConfigurationDataPointer));
    pcurrentThreadId = (uint32_t *)ConfigurationDataPointer[1];
  }
  creationFlags = *(uint32_t *)(ResourceManagerPointer + 0xc);
  allocationContext = *(uint32_t *)(ResourceManagerPointer + 0x10);
  unsignedSystemValue4 = *(uint32_t *)(ResourceManagerPointer + 0x14);
  *pcurrentThreadId = *(uint32_t *)(ResourceManagerPointer + 8);
  pcurrentThreadId[1] = creationFlags;
  pcurrentThreadId[2] = allocationContext;
  pcurrentThreadId[3] = unsignedSystemValue4;
  pcurrentThreadId = (uint32_t *)(ConfigurationDataPointer[1] + 0x10);
  ConfigurationDataPointer[1] = (long long)pcurrentThreadId;
  creationFlags = *(uint32_t *)(ResourceManagerPointer + 0x2c);
  if ((ulong long)((*ConfigurationDataPointer - (long long)pcurrentThreadId) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pcurrentThreadId + (4 - *ConfigurationDataPointer));
    pcurrentThreadId = (uint32_t *)ConfigurationDataPointer[1];
  }
  *pcurrentThreadId = creationFlags;
  pcurrentThreadId = (uint32_t *)(ConfigurationDataPointer[1] + 4);
  ConfigurationDataPointer[1] = (long long)pcurrentThreadId;
  creationFlags = *(uint32_t *)(ResourceManagerPointer + 0x30);
  if ((ulong long)((*ConfigurationDataPointer - (long long)pcurrentThreadId) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pcurrentThreadId + (4 - *ConfigurationDataPointer));
    pcurrentThreadId = (uint32_t *)ConfigurationDataPointer[1];
  }
  *pcurrentThreadId = creationFlags;
  pcurrentThreadId = (uint32_t *)(ConfigurationDataPointer[1] + 4);
  ConfigurationDataPointer[1] = (long long)pcurrentThreadId;
  creationFlags = *(uint32_t *)(ResourceManagerPointer + 0x34);
  if ((ulong long)((*ConfigurationDataPointer - (long long)pcurrentThreadId) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pcurrentThreadId + (4 - *ConfigurationDataPointer));
    *(uint32_t *)ConfigurationDataPointer[1] = creationFlags;
  }
  else {
    *pcurrentThreadId = creationFlags;
  }
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  return;
}




// 函数: void FUN_180074a80(long long *ResourceManagerPointer)
void FUN_180074a80(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)ResourceManagerPointer[1];
  resourcePoolPointer = (long long *)*ResourceManagerPointer;
  while( true ) {
    if (resourcePoolPointer == PrimaryResourcePointer) {
      if (*ResourceManagerPointer != 0) {
          SystemCleanupFunction();
      }
      return;
    }
    if (*(long long *)((long long)resourcePoolPointer + 0x12) != 0) {
        SystemCleanupFunction();
    }
    *(void* *)((long long)resourcePoolPointer + 0x12) = 0;
    if (*(long long *)((long long)resourcePoolPointer + 0x1a) != 0) break;
    *(void* *)((long long)resourcePoolPointer + 0x1a) = 0;
    if (*resourcePoolPointer != 0) {
        SystemCleanupFunction();
    }
    *resourcePoolPointer = 0;
    if (resourcePoolPointer[1] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[1] = 0;
    resourcePoolPointer = (long long *)((long long)resourcePoolPointer + 0x24);
  }
    SystemCleanupFunction();
}




// 函数: void FUN_180074b30(long long *ResourceManagerPointer,ulong long ConfigurationDataPointer)
void FUN_180074b30(long long *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long creationFlags;
  long long *plocalResourceOffset;
  long long bufferBaseAddress;
  long long SystemTimeValue;
  
  PrimaryResourcePointer = (long long *)ResourceManagerPointer[1];
  localSystemPointer = *ResourceManagerPointer;
  creationFlags = ((long long)PrimaryResourcePointer - localSystemPointer) / 0x24;
  if (creationFlags < ConfigurationDataPointer) {
    bufferBaseAddress = ConfigurationDataPointer - creationFlags;
    FUN_180074c20(ResourceManagerPointer,bufferBaseAddress,(long long)PrimaryResourcePointer - localSystemPointer,bufferBaseAddress,0xfffffffffffffffe);
  }
  else {
    plocalResourceOffset = (long long *)(ConfigurationDataPointer * 0x24 + localSystemPointer);
    if (plocalResourceOffset != PrimaryResourcePointer) {
      do {
        if (*(long long *)((long long)plocalResourceOffset + 0x12) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)((long long)plocalResourceOffset + 0x12) = 0;
        if (*(long long *)((long long)plocalResourceOffset + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)((long long)plocalResourceOffset + 0x1a) = 0;
        if (*plocalResourceOffset != 0) {
            SystemCleanupFunction();
        }
        *plocalResourceOffset = 0;
        if (plocalResourceOffset[1] != 0) {
            SystemCleanupFunction();
        }
        plocalResourceOffset[1] = 0;
        plocalResourceOffset = (long long *)((long long)plocalResourceOffset + 0x24);
      } while (plocalResourceOffset != PrimaryResourcePointer);
      localSystemPointer = *ResourceManagerPointer;
    }
    ResourceManagerPointer[1] = ConfigurationDataPointer * 0x24 + localSystemPointer;
  }
  return;
}





// 函数: void FUN_180074c20(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)
void FUN_180074c20(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  void* *HashNodePointer;
  long long* SystemMemoryPointer;
  long long *plocalSystemPointer;
  ulong long hashValue;
  void** SystemCurrentNode;
  long long localMemoryAddress;
  ulong long unsignedSystemValue9;
  
  HashBucketNode = (void* *)ResourceManagerPointer[1];
  if ((ulong long)((ResourceManagerPointer[2] - (long long)HashBucketNode) / 0x24) < ConfigurationDataPointer) {
    HashNodePointer = (void* *)*ResourceManagerPointer;
    localMemoryAddress = ((long long)HashBucketNode - (long long)HashNodePointer) / 0x24;
    unsignedSystemValue9 = localMemoryAddress * 2;
    if (localMemoryAddress == 0) {
      unsignedSystemValue9 = 1;
    }
    if (unsignedSystemValue9 < localMemoryAddress + ConfigurationDataPointer) {
      unsignedSystemValue9 = localMemoryAddress + ConfigurationDataPointer;
    }
    PrimaryResourcePointer = (long long *)0x0;
    if (unsignedSystemValue9 != 0) {
      PrimaryResourcePointer = (long long *)
               CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue9 * 0x24,*(uint8_t *)(ResourceManagerPointer + 3),HashBucketNode,
                             0xfffffffffffffffe);
      HashBucketNode = (void* *)ResourceManagerPointer[1];
      HashNodePointer = (void* *)*ResourceManagerPointer;
    }
    resourcePoolPointer = PrimaryResourcePointer;
    if (HashNodePointer != HashBucketNode) {
      localMemoryAddress = (long long)PrimaryResourcePointer - (long long)HashNodePointer;
      pbufferBaseAddress = (long long *)((long long)HashNodePointer + 0x1a);
      do {
        *(void*2 *)(localMemoryAddress + -10 + (long long)pbufferBaseAddress) = *(void*2 *)((long long)pbufferBaseAddress + -10);
        if (*(long long *)((long long)pbufferBaseAddress + -0x12) == 0) {
          *(void* *)(localMemoryAddress + -0x12 + (long long)pbufferBaseAddress) = 0;
        }
        else {
          *(long long *)(localMemoryAddress + -0x12 + (long long)pbufferBaseAddress) = *(long long *)((long long)pbufferBaseAddress + -0x12);
          *(void* *)((long long)pbufferBaseAddress + -0x12) = 0;
        }
        if (*(long long *)((long long)pbufferBaseAddress + -0x1a) == 0) {
          *resourcePoolPointer = 0;
        }
        else {
          *resourcePoolPointer = *(long long *)((long long)pbufferBaseAddress + -0x1a);
          *(void* *)((long long)pbufferBaseAddress + -0x1a) = 0;
        }
        *(void*2 *)((long long)pbufferBaseAddress + -10) = 0;
        *(short *)(localMemoryAddress + 8 + (long long)pbufferBaseAddress) = (short)pbufferBaseAddress[1];
        if (*pbufferBaseAddress == 0) {
          *(void* *)((long long)pbufferBaseAddress + localMemoryAddress) = 0;
        }
        else {
          *(long long *)((long long)pbufferBaseAddress + localMemoryAddress) = *pbufferBaseAddress;
          *pbufferBaseAddress = 0;
        }
        if (pbufferBaseAddress[-1] == 0) {
          *(void* *)(localMemoryAddress + -8 + (long long)pbufferBaseAddress) = 0;
        }
        else {
          *(long long *)(localMemoryAddress + -8 + (long long)pbufferBaseAddress) = pbufferBaseAddress[-1];
          pbufferBaseAddress[-1] = 0;
        }
        *(void*2 *)(pbufferBaseAddress + 1) = 0;
        resourcePoolPointer = (long long *)((long long)resourcePoolPointer + 0x24);
        HashNodePointer = (void* *)((long long)pbufferBaseAddress + 10);
        pbufferBaseAddress = (long long *)((long long)pbufferBaseAddress + 0x24);
      } while (HashNodePointer != HashBucketNode);
    }
    if (ConfigurationDataPointer != 0) {
      HashBucketNode = (void* *)((long long)resourcePoolPointer + 0x1a);
      hashValue = ConfigurationDataPointer;
      do {
        HashBucketNode[-1] = 0;
        *HashBucketNode = 0;
        *(void*2 *)(HashBucketNode + 1) = 0;
        *(void*2 *)((long long)HashBucketNode + -10) = 0;
        *(void* *)((long long)HashBucketNode + -0x1a) = 0;
        *(void* *)((long long)HashBucketNode + -0x12) = 0;
        *(void*2 *)(HashBucketNode + 1) = 0;
        HashBucketNode[-1] = 0;
        *HashBucketNode = 0;
        HashBucketNode = (void* *)((long long)HashBucketNode + 0x24);
        hashValue = hashValue - 1;
      } while (hashValue != 0);
    }
    pbufferBaseAddress = (long long *)ResourceManagerPointer[1];
    plocalSystemPointer = (long long *)*ResourceManagerPointer;
    if (plocalSystemPointer != pbufferBaseAddress) {
      do {
        if (*(long long *)((long long)plocalSystemPointer + 0x12) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)((long long)plocalSystemPointer + 0x12) = 0;
        if (*(long long *)((long long)plocalSystemPointer + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)((long long)plocalSystemPointer + 0x1a) = 0;
        if (*plocalSystemPointer != 0) {
            SystemCleanupFunction();
        }
        *plocalSystemPointer = 0;
        if (plocalSystemPointer[1] != 0) {
            SystemCleanupFunction();
        }
        plocalSystemPointer[1] = 0;
        plocalSystemPointer = (long long *)((long long)plocalSystemPointer + 0x24);
      } while (plocalSystemPointer != pbufferBaseAddress);
      plocalSystemPointer = (long long *)*ResourceManagerPointer;
    }
    if (plocalSystemPointer != (long long *)0x0) {
        SystemCleanupFunction(plocalSystemPointer);
    }
    *ResourceManagerPointer = PrimaryResourcePointer;
    ResourceManagerPointer[1] = (long long)resourcePoolPointer + ConfigurationDataPointer * 0x24;
    ResourceManagerPointer[2] = (long long)PrimaryResourcePointer + unsignedSystemValue9 * 0x24;
  }
  else {
    if (ConfigurationDataPointer != 0) {
      HashNodePointer = (void* *)((long long)HashBucketNode + 0x1a);
      unsignedSystemValue9 = ConfigurationDataPointer;
      do {
        HashBucketNode[1] = 0;
        HashBucketNode[2] = 0;
        HashBucketNode[3] = 0;
        *(uint32_t *)(HashBucketNode + 4) = 0;
        *(void*2 *)((long long)HashNodePointer + -10) = 0;
        *HashBucketNode = 0;
        *(void* *)((long long)HashNodePointer + -0x12) = 0;
        *(void*2 *)(HashNodePointer + 1) = 0;
        HashNodePointer[-1] = 0;
        *HashNodePointer = 0;
        HashBucketNode = (void* *)((long long)HashBucketNode + 0x24);
        HashNodePointer = (void* *)((long long)HashNodePointer + 0x24);
        unsignedSystemValue9 = unsignedSystemValue9 - 1;
      } while (unsignedSystemValue9 != 0);
      HashBucketNode = (void* *)ResourceManagerPointer[1];
    }
    ResourceManagerPointer[1] = (long long)HashBucketNode + ConfigurationDataPointer * 0x24;
  }
  return;
}




// 函数: void FUN_180074ed0(long long *ResourceManagerPointer)
void FUN_180074ed0(long long *ResourceManagerPointer)

{
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = 0;
  if (ResourceManagerPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[1] = 0;
  return;
}



void* *
FUN_180074f20(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ResourceManagerPointer = &UNK_1809ffa18;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x38,AdditionalParameter,ConfigurationFlag,0xfffffffffffffffe);
  }
  return ResourceManagerPointer;
}



void* * FUN_180074f70(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &UNK_1809ffa18;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,8);
  }
  return ResourceManagerPointer;
}



void* *
FUN_180074fb0(void* ResourceManagerPointer,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *ConfigurationDataPointer = &SystemMemoryAllocatorReference;
  ConfigurationDataPointer[1] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 2) = 0;
  *ConfigurationDataPointer = &SystemResourceTemplatePrimary;
  ConfigurationDataPointer[1] = ConfigurationDataPointer + 3;
  *(uint8_t *)(ConfigurationDataPointer + 3) = 0;
  *(uint32_t *)(ConfigurationDataPointer + 2) = 7;
  strcpy_s(ConfigurationDataPointer[1],0x80,&UNK_1809ffa30,ConfigurationFlag,0,0xfffffffffffffffe);
  return ConfigurationDataPointer;
}




void* * FUN_180075030(void* *ResourceManagerPointer,char ConfigurationDataPointer,char AdditionalParameter)

{
  long long *PrimaryResourcePointer;
  byte isSystemActive;
  long long *plocalResourceOffset;
  long long* SystemMemoryPointer;
  
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *ResourceManagerPointer = &UNK_180a02e68;
  ResourceManagerPointer[2] = &SystemMemoryAllocatorReference;
  ResourceManagerPointer[3] = 0;
  *(uint32_t *)(ResourceManagerPointer + 4) = 0;
  ResourceManagerPointer[2] = &SystemResourceTemplatePrimary;
  ResourceManagerPointer[3] = ResourceManagerPointer + 5;
  *(uint32_t *)(ResourceManagerPointer + 4) = 0;
  *(uint8_t *)(ResourceManagerPointer + 5) = 0;
  *(uint8_t *)((long long)ResourceManagerPointer + 0xb2) = 0;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *(void*2 *)(ResourceManagerPointer + 0x16) = 0;
  ResourceManagerPointer[0x15] = 0;
  *ResourceManagerPointer = &UNK_180a00270;
  InitializeResourceManager(ResourceManagerPointer + 0x19);
  *(uint32_t *)(ResourceManagerPointer + 0x1e) = 0;
  LOCK();
  *(uint32_t *)(ResourceManagerPointer + 0x1d) = 0;
  UNLOCK();
  LOCK();
  *(uint8_t *)((long long)ResourceManagerPointer + 0xec) = 0;
  UNLOCK();
  *(uint32_t *)(ResourceManagerPointer + 0x1e) = 0;
  ResourceManagerPointer[0x23] = 0;
  ResourceManagerPointer[0x36] = 0;
  ResourceManagerPointer[0x37] = 0;
  ResourceManagerPointer[0x38] = 0;
  ResourceManagerPointer[0x3e] = ResourceManagerPointer;
  ResourceManagerPointer[0x3d] = 0;
  ResourceManagerPointer[0x42] = 0;
  ResourceManagerPointer[0x43] = 0;
  ResourceManagerPointer[0x44] = 0;
  ResourceManagerPointer[0x45] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x46) = 3;
  ResourceManagerPointer[0x4d] = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x2a4) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x274) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x27c) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x284) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x28c) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x294) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x29c) = 0;
  *(void*2 *)(ResourceManagerPointer + 0x5d) = 0;
  ResourceManagerPointer[0x5c] = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x2ec) = 0xffffffff;
  *(void*2 *)(ResourceManagerPointer + 0x5f) = 0;
  ResourceManagerPointer[0x5e] = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x2fc) = 0xffffffff;
  *(byte *)((long long)ResourceManagerPointer + 0xfd) = *(byte *)((long long)ResourceManagerPointer + 0xfd) & 0xfb;
  *(byte *)((long long)ResourceManagerPointer + 0xfd) = *(byte *)((long long)ResourceManagerPointer + 0xfd) | ConfigurationDataPointer << 2;
  ResourceManagerPointer[0x15] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x17) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0xbc) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x18) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0xc4) = 0;
  *(byte *)((long long)ResourceManagerPointer + 0xfe) = *(byte *)((long long)ResourceManagerPointer + 0xfe) & 0xfe;
  *(uint8_t *)((long long)ResourceManagerPointer + 0xfc) = 0;
  pbufferBaseAddress = (long long *)ResourceManagerPointer[0x36];
  ResourceManagerPointer[0x36] = 0;
  if (pbufferBaseAddress != (long long *)0x0) {
    (**(code **)(*pbufferBaseAddress + 0x38))();
  }
  ResourceManagerPointer[0x39] = 0;
  ResourceManagerPointer[0x3c] = 0;
  if (AdditionalParameter == '\0') {
    *(byte *)((long long)ResourceManagerPointer + 0xfd) = *(byte *)((long long)ResourceManagerPointer + 0xfd) & 0xdf;
  }
  else {
    *(byte *)((long long)ResourceManagerPointer + 0xfd) = *(byte *)((long long)ResourceManagerPointer + 0xfd) | 0x20;
  }
  *(byte *)((long long)ResourceManagerPointer + 0xfd) = *(byte *)((long long)ResourceManagerPointer + 0xfd) & 0xbf;
  *(uint8_t *)((long long)ResourceManagerPointer + 0xff) = 1;
  pbufferBaseAddress = (long long *)ResourceManagerPointer[0x37];
  ResourceManagerPointer[0x37] = 0;
  if (pbufferBaseAddress != (long long *)0x0) {
    (**(code **)(*pbufferBaseAddress + 0x38))();
  }
  *(uint8_t *)((long long)ResourceManagerPointer + 0xf4) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x20) = 0;
  *(uint8_t *)((long long)ResourceManagerPointer + 0xf7) = 0;
  *(byte *)((long long)ResourceManagerPointer + 0xfd) = *(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x6d;
  plocalResourceOffset = (long long *)ResourceManagerPointer[0x38];
  ResourceManagerPointer[0x38] = 0;
  if (plocalResourceOffset != (long long *)0x0) {
    (**(code **)(*plocalResourceOffset + 0x38))();
  }
  isSystemActive = *(byte *)((long long)ResourceManagerPointer + 0xfd) & 0xf7;
  *(byte *)((long long)ResourceManagerPointer + 0xfd) = isSystemActive;
  ResourceManagerPointer[0x47] = 0x3f8000003f800000;
  ResourceManagerPointer[0x48] = 0x3f8000003f800000;
  ResourceManagerPointer[0x49] = 0x3f8000003f800000;
  ResourceManagerPointer[0x4a] = 0x3f8000003f800000;
  *(uint32_t *)(ResourceManagerPointer + 0x4c) = 0x3f800000;
  ResourceManagerPointer[0x24] = 0x3f800000;
  ResourceManagerPointer[0x25] = 0;
  ResourceManagerPointer[0x26] = 0x3f80000000000000;
  ResourceManagerPointer[0x27] = 0;
  ResourceManagerPointer[0x28] = 0;
  ResourceManagerPointer[0x29] = 0x3f800000;
  ResourceManagerPointer[0x2a] = 0;
  ResourceManagerPointer[0x2b] = 0x3f80000000000000;
  ResourceManagerPointer[0x2c] = 0x3f800000;
  ResourceManagerPointer[0x2d] = 0;
  ResourceManagerPointer[0x2e] = 0x3f80000000000000;
  ResourceManagerPointer[0x2f] = 0;
  ResourceManagerPointer[0x30] = 0;
  ResourceManagerPointer[0x31] = 0x3f800000;
  ResourceManagerPointer[0x32] = 0;
  ResourceManagerPointer[0x33] = 0x3f80000000000000;
  *(byte *)((long long)ResourceManagerPointer + 0xfd) = isSystemActive | 1;
  *(byte *)((long long)ResourceManagerPointer + 0xfe) = *(byte *)((long long)ResourceManagerPointer + 0xfe) | 2;
  *(uint32_t *)(ResourceManagerPointer + 0x4e) = 0x21;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x104) = 0x80;
  *(uint8_t *)((long long)ResourceManagerPointer + 0xf6) = 0;
  *(void*2 *)((long long)ResourceManagerPointer + 0xfa) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x204) = 0;
  ResourceManagerPointer[0x3f] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x40) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x5b) = 0xbf800000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x2dc) = 0xbf800000;
  ResourceManagerPointer[0x55] = 0;
  ResourceManagerPointer[0x56] = 0;
  ResourceManagerPointer[0x57] = 0;
  ResourceManagerPointer[0x58] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x19) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0xcc) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1a) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0xd4) = 0x7f7fffff;
  *(uint32_t *)(ResourceManagerPointer + 0x1b) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0xdc) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x1c) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0xe4) = 0x7f7fffff;
  *(uint32_t *)(ResourceManagerPointer + 0x21) = 0xffffffff;
  ResourceManagerPointer[0x5a] = 0;
  if (ConfigurationDataPointer == '\0') {
    PrimaryResourcePointer = (long long *)ResourceManagerPointer[0x42];
    ResourceManagerPointer[0x42] = 0;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer,0);
    }
  }
  *(uint8_t *)(ResourceManagerPointer + 0x1f) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x34) = 0x3f800000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x1a4) = 0x3f800000;
  *(uint32_t *)(ResourceManagerPointer + 0x35) = 0x3f800000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x1ac) = 0x7f7fffff;
  *(uint32_t *)(ResourceManagerPointer + 0x3a) = 0xffffffff;
  plocalResourceOffset = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,9,pbufferBaseAddress,plocalResourceOffset);
  *plocalResourceOffset = (long long)&SystemMemoryTemplateA;
  *plocalResourceOffset = (long long)&SystemMemoryTemplateB;
  *(uint32_t *)(plocalResourceOffset + 1) = 0;
  *plocalResourceOffset = (long long)&UNK_180a00208;
  plocalResourceOffset[4] = (long long)&SystemMemoryAllocatorReference;
  plocalResourceOffset[5] = 0;
  *(uint32_t *)(plocalResourceOffset + 6) = 0;
  plocalResourceOffset[4] = (long long)&SystemGlobalDataReference;
  plocalResourceOffset[7] = 0;
  plocalResourceOffset[5] = 0;
  *(uint32_t *)(plocalResourceOffset + 6) = 0;
  *(uint32_t *)(plocalResourceOffset + 8) = 0xffffffff;
  *(uint32_t *)((long long)plocalResourceOffset + 0x44) = 0x3f000000;
  *(uint32_t *)(plocalResourceOffset + 9) = 0x3f000000;
  *(uint32_t *)((long long)plocalResourceOffset + 0x4c) = 0x3f4ccccd;
  *(uint32_t *)(plocalResourceOffset + 10) = 0x3f000000;
  *(uint32_t *)((long long)plocalResourceOffset + 0x54) = 0x3e99999a;
  *(uint32_t *)(plocalResourceOffset + 0xb) = 0x411cf5c3;
  *(uint32_t *)((long long)plocalResourceOffset + 0x5c) = 0x3f800000;
  *(uint32_t *)(plocalResourceOffset + 0xc) = 0xbf800000;
  *(uint32_t *)((long long)plocalResourceOffset + 100) = 0x3f800000;
  *(uint32_t *)(plocalResourceOffset + 0xd) = 0x3f000000;
  *(uint32_t *)((long long)plocalResourceOffset + 0x6c) = 0x3f800000;
  *(uint32_t *)(plocalResourceOffset + 2) = 0x3f800000;
  *(uint32_t *)((long long)plocalResourceOffset + 0x14) = 0x78;
  *(void*2 *)(plocalResourceOffset + 3) = 0;
  *(uint8_t *)((long long)plocalResourceOffset + 0x1a) = 0;
  (**(code **)(*plocalResourceOffset + 0x28))(plocalResourceOffset);
  pbufferBaseAddress = (long long *)ResourceManagerPointer[0x4d];
  ResourceManagerPointer[0x4d] = plocalResourceOffset;
  if (pbufferBaseAddress != (long long *)0x0) {
    (**(code **)(*pbufferBaseAddress + 0x38))();
  }
  *(byte *)((long long)ResourceManagerPointer + 0xfe) = *(byte *)((long long)ResourceManagerPointer + 0xfe) & 0xf3;
  ResourceManagerPointer[0x3b] = 0;
  LOCK();
  *(uint8_t *)((long long)ResourceManagerPointer + 0xf9) = 0;
  UNLOCK();
  ResourceManagerPointer[0x59] = 0;
  *(uint8_t *)((long long)ResourceManagerPointer + 0xf5) = 0;
  ResourceManagerPointer[0x4b] = 0;
  return ResourceManagerPointer;
}



void* FUN_180075580(void* ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  FUN_1800756e0();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x300);
  }
  return ResourceManagerPointer;
}



uint8_t FUN_1800755c0(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint8_t systemStatus;
  void* creationFlags;
  void* *pointerUnsigned30;
  long long lStack_28;
  
  creationFlags = 0xfffffffffffffffe;
  SetupSystemMemory(&pointerUnsigned30);
  systemStatus = FUN_180063510(ResourceManagerPointer + 0x218,&pointerUnsigned30,AdditionalParameter,ConfigurationFlag,creationFlags);
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (lStack_28 != 0) {
      SystemCleanupFunction();
  }
  return systemStatus;
}



000180276fbd)


// 函数: void FUN_180075630(long long ResourceManagerPointer,void* *ConfigurationDataPointer)
void FUN_180075630(long long ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  void* *pointerToUnsigned1;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  uint32_t unsignedSystemValue4;
  uint32_t currentThreadId;
  uint32_t hashValue;
  void* unsignedSystemValue7;
  char CharacterVariable8;
  long long resourceCounter;
  long long *PrimaryResourcePointer0;
  uint systemStatus1;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  uint8_t auStack_e8 [184];
  void* unsignedValue30;
  
  systemStatus1 = *(uint *)(ResourceManagerPointer + 0x100) & 0xfbffffff;
  *(uint *)(ResourceManagerPointer + 0x100) = systemStatus1;
  unsignedValue30 = 0x180075655;
  charInput = FUN_1800861a0(ConfigurationDataPointer);
  if (charInput == '\0') {
    *(uint *)(ResourceManagerPointer + 0x100) = systemStatus1 | 0x4000000;
  }
  unsignedSystemValue7 = ConfigurationDataPointer[1];
  resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x1c8);
  *(void* *)(ResourceManagerPointer + 0x120) = *ConfigurationDataPointer;
  *(void* *)(ResourceManagerPointer + 0x128) = unsignedSystemValue7;
  unsignedSystemValue7 = ConfigurationDataPointer[3];
  *(void* *)(ResourceManagerPointer + 0x130) = ConfigurationDataPointer[2];
  *(void* *)(ResourceManagerPointer + 0x138) = unsignedSystemValue7;
  unsignedSystemValue4 = *(uint32_t *)((long long)ConfigurationDataPointer + 0x24);
  currentThreadId = *(uint32_t *)(ConfigurationDataPointer + 5);
  hashValue = *(uint32_t *)((long long)ConfigurationDataPointer + 0x2c);
  *(uint32_t *)(ResourceManagerPointer + 0x140) = *(uint32_t *)(ConfigurationDataPointer + 4);
  *(uint32_t *)(ResourceManagerPointer + 0x144) = unsignedSystemValue4;
  *(uint32_t *)(ResourceManagerPointer + 0x148) = currentThreadId;
  *(uint32_t *)(ResourceManagerPointer + 0x14c) = hashValue;
  unsignedSystemValue4 = *(uint32_t *)((long long)ConfigurationDataPointer + 0x34);
  currentThreadId = *(uint32_t *)(ConfigurationDataPointer + 7);
  hashValue = *(uint32_t *)((long long)ConfigurationDataPointer + 0x3c);
  *(uint32_t *)(ResourceManagerPointer + 0x150) = *(uint32_t *)(ConfigurationDataPointer + 6);
  *(uint32_t *)(ResourceManagerPointer + 0x154) = unsignedSystemValue4;
  *(uint32_t *)(ResourceManagerPointer + 0x158) = currentThreadId;
  *(uint32_t *)(ResourceManagerPointer + 0x15c) = hashValue;
  if (resourcePoolPointer != (long long *)0x0) {
    if (*(code **)(*resourcePoolPointer + 0x160) == (code *)&UNK_180277350) {
      pointerToUnsigned1 = (void* *)((long long)resourcePoolPointer + 0x214);
      *(uint32_t *)((long long)resourcePoolPointer + 0x244) = 0;
      if (resourcePoolPointer[8] - resourcePoolPointer[7] >> 4 == 0) {
        *pointerToUnsigned1 = 0;
        *(void* *)((long long)resourcePoolPointer + 0x21c) = 0;
        *(void* *)((long long)resourcePoolPointer + 0x224) = 0;
        *(void* *)((long long)resourcePoolPointer + 0x22c) = 0;
        *(void* *)((long long)resourcePoolPointer + 0x234) = 0;
        *(void* *)((long long)resourcePoolPointer + 0x23c) = 0;
      }
      else {
        *pointerToUnsigned1 = 0x4cbebc204cbebc20;
        *(void* *)((long long)resourcePoolPointer + 0x21c) = 0x7f7fffff4cbebc20;
        *(uint32_t *)((long long)resourcePoolPointer + 0x234) = 0;
        *(uint32_t *)(resourcePoolPointer + 0x47) = 0;
        *(uint32_t *)((long long)resourcePoolPointer + 0x23c) = 0;
        *(uint32_t *)(resourcePoolPointer + 0x48) = 0x7f7fffff;
        *(void* *)((long long)resourcePoolPointer + 0x224) = 0xccbebc20ccbebc20;
        *(void* *)((long long)resourcePoolPointer + 0x22c) = 0x7f7fffffccbebc20;
        PrimaryResourcePointer0 = (long long *)resourcePoolPointer[7];
        if (PrimaryResourcePointer0 < (long long *)resourcePoolPointer[8]) {
          do {
            localResourceOffset = *PrimaryResourcePointer0;
            if (((*(byte *)(localResourceOffset + 0x100) & 0x20) == 0) || (resourcePoolPointer[5] == 0)) {
              resourceCounter = localResourceOffset + 0x120;
            }
            else {
              resourceCounter = CalculateResourceCount(localResourceOffset + 0x120,auStack_e8,resourcePoolPointer[5] + 0x70);
            }
            FUN_18063a240(pointerToUnsigned1,localResourceOffset + 0x274,resourceCounter);
            PrimaryResourcePointer0 = PrimaryResourcePointer0 + 2;
          } while (PrimaryResourcePointer0 < (long long *)resourcePoolPointer[8]);
        }
        if (((resourcePoolPointer[8] - resourcePoolPointer[7] & 0xfffffffffffffff0U) == 0x10) &&
           (localResourceOffset = *(long long *)resourcePoolPointer[7], (*(uint *)(localResourceOffset + 0x100) & 0x4000000) == 0)) {
          unsignedSystemValue7 = *(void* *)(localResourceOffset + 0x29c);
          *(void* *)((long long)resourcePoolPointer + 0x234) = *(void* *)(localResourceOffset + 0x294);
          *(void* *)((long long)resourcePoolPointer + 0x23c) = unsignedSystemValue7;
          *(uint32_t *)((long long)resourcePoolPointer + 0x244) =
               *(uint32_t *)(*(long long *)resourcePoolPointer[7] + 0x2a4);
        }
        else {
          FUN_1800b9f60(pointerToUnsigned1);
          PrimaryResourcePointer0 = (long long *)resourcePoolPointer[7];
          interpolationFactor2 = 0.0;
          if (PrimaryResourcePointer0 < (long long *)resourcePoolPointer[8]) {
            do {
              localResourceOffset = *PrimaryResourcePointer0;
              if ((*(uint *)(localResourceOffset + 0x100) & 0x4000000) == 0) {
                scaleResult1 = *(float *)(localResourceOffset + 0x294);
                interpolationFactor4 = *(float *)(localResourceOffset + 0x298);
                interpolationFactor5 = *(float *)(localResourceOffset + 0x29c);
                FloatRatioValue = *(float *)(localResourceOffset + 0x2a4);
              }
              else {
                FloatRatioValue = *(float *)(localResourceOffset + 0x298);
                interpolationFactor5 = *(float *)(localResourceOffset + 0x294);
                interpolationFactor1 = *(float *)(localResourceOffset + 0x29c);
                scaleResult1 = *(float *)(localResourceOffset + 0x130) * FloatRatioValue + *(float *)(localResourceOffset + 0x120) * interpolationFactor5 +
                         *(float *)(localResourceOffset + 0x140) * interpolationFactor1 + *(float *)(localResourceOffset + 0x150);
                interpolationFactor4 = *(float *)(localResourceOffset + 0x134) * FloatRatioValue + *(float *)(localResourceOffset + 0x124) * interpolationFactor5 +
                         *(float *)(localResourceOffset + 0x144) * interpolationFactor1 + *(float *)(localResourceOffset + 0x154);
                interpolationFactor5 = *(float *)(localResourceOffset + 0x138) * FloatRatioValue + *(float *)(localResourceOffset + 0x128) * interpolationFactor5 +
                         *(float *)(localResourceOffset + 0x148) * interpolationFactor1 + *(float *)(localResourceOffset + 0x158);
                FloatRatioValue = *(float *)(localResourceOffset + 0x140) * *(float *)(localResourceOffset + 0x140) +
                         *(float *)(localResourceOffset + 0x144) * *(float *)(localResourceOffset + 0x144) +
                         *(float *)(localResourceOffset + 0x148) * *(float *)(localResourceOffset + 0x148);
                interpolationFactor1 = *(float *)(localResourceOffset + 0x130) * *(float *)(localResourceOffset + 0x130) +
                         *(float *)(localResourceOffset + 0x134) * *(float *)(localResourceOffset + 0x134) +
                         *(float *)(localResourceOffset + 0x138) * *(float *)(localResourceOffset + 0x138);
                magnitudeSquared1 = *(float *)(localResourceOffset + 0x120) * *(float *)(localResourceOffset + 0x120) +
                         *(float *)(localResourceOffset + 0x124) * *(float *)(localResourceOffset + 0x124) +
                         *(float *)(localResourceOffset + 0x128) * *(float *)(localResourceOffset + 0x128);
                if (magnitudeSquared1 <= interpolationFactor1) {
                  if (FloatRatioValue <= interpolationFactor1) {
                    FloatRatioValue = interpolationFactor1;
                  }
                }
                else if (FloatRatioValue <= magnitudeSquared1) {
                  FloatRatioValue = magnitudeSquared1;
                }
                if ((FloatRatioValue - 1.0 <= -1e-06) || (1e-06 <= FloatRatioValue - 1.0)) {
                  FloatRatioValue = SQRT(FloatRatioValue) * *(float *)(localResourceOffset + 0x2a4);
                }
                else {
                  FloatRatioValue = *(float *)(localResourceOffset + 0x2a4) * 1.0;
                }
              }
              interpolationFactor5 = *(float *)((long long)resourcePoolPointer + 0x23c) - interpolationFactor5;
              scaleResult1 = *(float *)((long long)resourcePoolPointer + 0x234) - interpolationFactor3;
              interpolationFactor4 = (*(float *)(resourcePoolPointer + 0x47) - interpolationFactor4) * (*(float *)(resourcePoolPointer + 0x47) - interpolationFactor4) +
                       interpolationFactor3 * interpolationFactor3 + interpolationFactor5 * interpolationFactor5;
              scaleResult1 = interpolationFactor2 - FloatRatioValue;
              if (interpolationFactor3 <= 0.0) {
                scaleResult1 = 0.0;
              }
              if (interpolationFactor3 * interpolationFactor3 < interpolationFactor4) {
                interpolationFactor2 = SQRT(interpolationFactor4) + FloatRatioValue;
              }
              PrimaryResourcePointer0 = PrimaryResourcePointer0 + 2;
            } while (PrimaryResourcePointer0 < (long long *)resourcePoolPointer[8]);
            if ((0.0 < interpolationFactor2) &&
               (interpolationFactor2 < *(float *)((long long)resourcePoolPointer + 0x244) ||
                interpolationFactor2 == *(float *)((long long)resourcePoolPointer + 0x244))) {
              *(float *)((long long)resourcePoolPointer + 0x244) = interpolationFactor2;
            }
          }
        }
      }
      return;
    }
    unsignedValue30 = 0x1800756d4;
    (**(code **)(*resourcePoolPointer + 0x160))();
  }
  return;
}




// 函数: void FUN_1800756e0(void* *ResourceManagerPointer)
void FUN_1800756e0(void* *ResourceManagerPointer)

{
  byte *pisByteValid;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  void* unsignedSystemValue4;
  
  unsignedSystemValue4 = 0xfffffffffffffffe;
  *ResourceManagerPointer = &UNK_180a00270;
  ResourceManagerPointer[0x39] = 0;
  if (ResourceManagerPointer[0x59] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x59] = 0;
  resourcePoolPointer = (long long *)ResourceManagerPointer[0x37];
  ResourceManagerPointer[0x37] = 0;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  resourcePoolPointer = (long long *)ResourceManagerPointer[0x38];
  ResourceManagerPointer[0x38] = 0;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  if (ResourceManagerPointer[0x5a] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x5a] = 0;
  resourcePoolPointer = (long long *)ResourceManagerPointer[0x4b];
  if (resourcePoolPointer != (long long *)0x0) {
    if (*resourcePoolPointer != 0) {
        SystemCleanupFunction();
    }
    *resourcePoolPointer = 0;
    if (resourcePoolPointer[2] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[2] = 0;
    if (resourcePoolPointer[7] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[2] = 0;
    resourcePoolPointer[7] = 0;
      SystemCleanupFunction(resourcePoolPointer);
  }
  ResourceManagerPointer[0x4b] = 0;
  if (*(char*)((long long)ResourceManagerPointer + 0xf9) != '\0') {
    if (ResourceManagerPointer[0x3b] != 0) {
        SystemCleanupFunction();
    }
    ResourceManagerPointer[0x3b] = 0;
    LOCK();
    *(uint8_t *)((long long)ResourceManagerPointer + 0xf9) = 0;
    UNLOCK();
  }
  if (ResourceManagerPointer[0x3d] != 0) {
    FUN_180080060();
    ResourceManagerPointer[0x3d] = 0;
    if (ResourceManagerPointer[0x3e] != 0) {
      pisByteValid = (byte *)(ResourceManagerPointer[0x3e] + 0xfe);
      *pisByteValid = *pisByteValid & 0xfb;
    }
  }
  resourcePoolPointer = (long long *)ResourceManagerPointer[0x42];
  ResourceManagerPointer[0x42] = 0;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  localResourceOffset = ResourceManagerPointer[0x3c];
  if (localResourceOffset != 0) {
    ConfigureSystemMemoryRegion(localResourceOffset,0x18,0x10,FUN_18007bb70,unsignedSystemValue4,localResourceOffset);
      SystemCleanupFunction(localResourceOffset);
  }
  ResourceManagerPointer[0x3c] = 0;
  FUN_180080870(ResourceManagerPointer + 0x5e);
  FUN_1800809a0(ResourceManagerPointer + 0x5c);
  if ((long long *)ResourceManagerPointer[0x4d] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x4d] + 0x38))();
  }
  CleanupSystemMemoryAllocation();
  if ((long long *)ResourceManagerPointer[0x42] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x42] + 0x38))();
  }
  if (ResourceManagerPointer[0x3d] != 0) {
    FUN_180080060();
  }
  if ((long long *)ResourceManagerPointer[0x38] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x38] + 0x38))();
  }
  if ((long long *)ResourceManagerPointer[0x37] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x37] + 0x38))();
  }
  if ((long long *)ResourceManagerPointer[0x36] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x36] + 0x38))();
  }
  if ((long long *)ResourceManagerPointer[0x23] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[0x23] + 0x38))();
  }
  *ResourceManagerPointer = &UNK_180a02e68;
  ResourceManagerPointer[2] = &SystemMemoryAllocatorReference;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  return;
}




// 函数: void FUN_180075990(long long ResourceManagerPointer,long long *ConfigurationDataPointer)
void FUN_180075990(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  void* unsignedValue40;
  uint32_t uStack_38;
  long long lStack_30;
  uint8_t aEncryptionKeyValue [8];
  long long lStack_20;
  uint32_t unsignedValue18;
  long long *plStack_10;
  
  if (*(long long *)(ResourceManagerPointer + 0x1b0) != *ConfigurationDataPointer) {
    if (*ConfigurationDataPointer == 0) {
      plStack_10 = (long long *)0x0;
      aEncryptionKeyValue[0] = 0;
      unsignedValue18 = 0;
      lStack_20 = ResourceManagerPointer;
      FUN_18007f4c0(aEncryptionKeyValue);
      if ((*(int *)(ResourceManagerPointer + 0x208) != 0) || (*(int *)(ResourceManagerPointer + 0x204) != 0)) {
        unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x1b0);
        uStack_38 = 0;
        FUN_18007f770(&unsignedValue40);
        PrimaryResourcePointer = plStack_10;
        FUN_1800860f0(plStack_10 + 2,lStack_30 + 0x10);
        FUN_1800860f0(PrimaryResourcePointer + 7,lStack_30 + 0x38);
        FUN_180086090(PrimaryResourcePointer + 0xc,lStack_30 + 0x60);
        FUN_180085fb0(PrimaryResourcePointer + 0x11,lStack_30 + 0x88);
        FUN_180085ec0(PrimaryResourcePointer + 0x19,lStack_30 + 200);
        FUN_18007f840(&unsignedValue40);
      }
      FUN_18007f6a0(aEncryptionKeyValue);
      if (plStack_10 != (long long *)0x0) {
        (**(code **)(*plStack_10 + 0x38))();
      }
    }
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer);
    }
    PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 0x1b0);
    *(long long **)(ResourceManagerPointer + 0x1b0) = ConfigurationDataPointer;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
  }
  return;
}



long long FUN_180075af0(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  long long localSystemHandle;
  byte isOperationComplete;
  
  isOperationComplete = *(byte *)(ResourceManagerPointer + 0xfd) & 0x20;
  nextDataIndex = ResourceManagerPointer;
  if (isOperationComplete == 0) {
    nextDataIndex = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  localSystemHandle = 2;
  if (0xffff < *(int *)(nextDataIndex + 0x200)) {
    localSystemHandle = 4;
  }
  if (isOperationComplete == 0) {
    ResourceManagerPointer = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  return (*(int *)(ResourceManagerPointer + 0x1fc) * 3) * localSystemHandle;
}



float * FUN_180075b70(float *ResourceManagerPointer)

{
  float *pfloatValue1;
  byte isSystemActive;
  long long *plocalResourceOffset;
  float *pfloatValue4;
  char operationStatusFlag;
  float *pfloatValue6;
  uint unsignedSystemValue7;
  ulong long unsignedSystemValue8;
  bool isSystemBusy;
  float FloatScaleFactor;
  float floatValue11;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  uint32_t uStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  uint32_t uStack_9c;
  float *pfStack_98;
  uint32_t SystemConfigurationValue;
  long long lStack_88;
  void* UnsignedStackFlag78;
  void* processFlags70;
  void* EncryptionValue68;
  void* unsignedValue60;
  float fStack_58;
  float fStack_54;
  float fStack_50;
  float fStack_4c;
  void* EncryptionValue48;
  void* unsignedValue40;
  void* uStack_38;
  
  uStack_38 = 0xfffffffffffffffe;
  pfloatValue6 = ResourceManagerPointer;
  if ((*(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    pfloatValue6 = (float *)func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x6c));
  }
  if ((*(long long *)(pfloatValue6 + 0x84) != 0) && (((uint)ResourceManagerPointer[0x40] & 0x80) == 0)) {
    pfloatValue1 = ResourceManagerPointer + 0x9d;
    pfloatValue1[0] = 1e+08;
    pfloatValue1[1] = 1e+08;
    ResourceManagerPointer[0x9f] = 1e+08;
    ResourceManagerPointer[0xa0] = 3.4028235e+38;
    ResourceManagerPointer[0xa1] = -1e+08;
    ResourceManagerPointer[0xa2] = -1e+08;
    ResourceManagerPointer[0xa3] = -1e+08;
    ResourceManagerPointer[0xa4] = 3.4028235e+38;
    unsignedSystemValue7 = 0;
    ResourceManagerPointer[0xa9] = 0.0;
    ResourceManagerPointer[0xa5] = 0.0;
    ResourceManagerPointer[0xa6] = 0.0;
    ResourceManagerPointer[0xa7] = 0.0;
    ResourceManagerPointer[0xa8] = 3.4028235e+38;
    SystemConfigurationValue = 0;
    pfStack_98 = pfloatValue6;
    FUN_18007f770(&pfStack_98);
    if (*(int *)(lStack_88 + 0x10) != 0) {
      do {
        pfloatValue6 = (float *)((long long)(int)unsignedSystemValue7 * 0x10 + *(long long *)(lStack_88 + 0x18));
        fStack_a8 = *pfloatValue6;
        if (*pfloatValue1 < fStack_a8) {
          fStack_a8 = *pfloatValue1;
        }
        fStack_a4 = pfloatValue6[1];
        if (ResourceManagerPointer[0x9e] < fStack_a4) {
          fStack_a4 = ResourceManagerPointer[0x9e];
        }
        fStack_a0 = pfloatValue6[2];
        if (ResourceManagerPointer[0x9f] < fStack_a0) {
          fStack_a0 = ResourceManagerPointer[0x9f];
        }
        *(ulong long *)pfloatValue1 = CONCAT44(fStack_a4,fStack_a8);
        *(ulong long *)(ResourceManagerPointer + 0x9f) = CONCAT44(uStack_9c,fStack_a0);
        fStack_b8 = *pfloatValue6;
        if (fStack_b8 < ResourceManagerPointer[0xa1]) {
          fStack_b8 = ResourceManagerPointer[0xa1];
        }
        fStack_b4 = pfloatValue6[1];
        if (fStack_b4 < ResourceManagerPointer[0xa2]) {
          fStack_b4 = ResourceManagerPointer[0xa2];
        }
        fStack_b0 = pfloatValue6[2];
        if (fStack_b0 < ResourceManagerPointer[0xa3]) {
          fStack_b0 = ResourceManagerPointer[0xa3];
        }
        *(ulong long *)(ResourceManagerPointer + 0xa1) = CONCAT44(fStack_b4,fStack_b8);
        *(ulong long *)(ResourceManagerPointer + 0xa3) = CONCAT44(uStack_ac,fStack_b0);
        unsignedSystemValue7 = unsignedSystemValue7 + 1;
      } while (unsignedSystemValue7 < *(uint *)(lStack_88 + 0x10));
    }
    pfloatValue6 = *(float **)(ResourceManagerPointer + 0x6e);
    if ((pfloatValue6 != (float *)0x0) && (((uint)pfloatValue6[0x4e] & 0x3000) != 0)) {
      UnsignedStackFlag78 = *(void* *)(ResourceManagerPointer + 0x48);
      processFlags70 = *(void* *)(ResourceManagerPointer + 0x4a);
      EncryptionValue68 = *(void* *)(ResourceManagerPointer + 0x4c);
      unsignedValue60 = *(void* *)(ResourceManagerPointer + 0x4e);
      fStack_58 = ResourceManagerPointer[0x50];
      fStack_54 = ResourceManagerPointer[0x51];
      fStack_50 = ResourceManagerPointer[0x52];
      fStack_4c = ResourceManagerPointer[0x53];
      EncryptionValue48 = *(void* *)(ResourceManagerPointer + 0x54);
      unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x56);
      FUN_180085c10(&UnsignedStackFlag78);
      FUN_18063a240(pfloatValue1,pfloatValue1,&UnsignedStackFlag78);
      pfloatValue6 = *(float **)(ResourceManagerPointer + 0x6e);
      if (((uint)pfloatValue6[0x4e] & 0x3000) == 0x2000) {
        UnsignedStackFlag78 = *(void* *)(ResourceManagerPointer + 0x48);
        processFlags70 = *(void* *)(ResourceManagerPointer + 0x4a);
        EncryptionValue68 = *(void* *)(ResourceManagerPointer + 0x4c);
        unsignedValue60 = *(void* *)(ResourceManagerPointer + 0x4e);
        fStack_58 = ResourceManagerPointer[0x50];
        fStack_54 = ResourceManagerPointer[0x51];
        fStack_50 = ResourceManagerPointer[0x52];
        fStack_4c = ResourceManagerPointer[0x53];
        EncryptionValue48 = *(void* *)(ResourceManagerPointer + 0x54);
        unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x56);
        FUN_180085ac0(&UnsignedStackFlag78,0x3fc90fdb);
        FUN_18063a240(pfloatValue1,pfloatValue1,&UnsignedStackFlag78);
        UnsignedStackFlag78 = *(void* *)(ResourceManagerPointer + 0x48);
        processFlags70 = *(void* *)(ResourceManagerPointer + 0x4a);
        EncryptionValue68 = *(void* *)(ResourceManagerPointer + 0x4c);
        unsignedValue60 = *(void* *)(ResourceManagerPointer + 0x4e);
        fStack_58 = ResourceManagerPointer[0x50];
        fStack_54 = ResourceManagerPointer[0x51];
        fStack_50 = ResourceManagerPointer[0x52];
        fStack_4c = ResourceManagerPointer[0x53];
        EncryptionValue48 = *(void* *)(ResourceManagerPointer + 0x54);
        unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x56);
        FUN_180085970(&UnsignedStackFlag78);
        pfloatValue6 = (float *)FUN_18063a240(pfloatValue1,pfloatValue1,&UnsignedStackFlag78);
      }
    }
    pfloatValue4 = pfStack_98;
    if (ResourceManagerPointer[0xa1] < *pfloatValue1) {
      ResourceManagerPointer[0xa9] = 0.0;
      pfloatValue1[0] = 0.0;
      pfloatValue1[1] = 0.0;
      ResourceManagerPointer[0x9f] = 0.0;
      ResourceManagerPointer[0xa0] = 0.0;
      ResourceManagerPointer[0xa1] = 0.0;
      ResourceManagerPointer[0xa2] = 0.0;
      ResourceManagerPointer[0xa3] = 0.0;
      ResourceManagerPointer[0xa4] = 0.0;
      ResourceManagerPointer[0xa5] = 0.0;
      ResourceManagerPointer[0xa6] = 0.0;
      ResourceManagerPointer[0xa7] = 0.0;
      ResourceManagerPointer[0xa8] = 0.0;
    }
    else {
      ResourceManagerPointer[0xa5] = (ResourceManagerPointer[0xa1] + *pfloatValue1) * 0.5;
      ResourceManagerPointer[0xa6] = (ResourceManagerPointer[0xa2] + ResourceManagerPointer[0x9e]) * 0.5;
      ResourceManagerPointer[0xa7] = (ResourceManagerPointer[0xa3] + ResourceManagerPointer[0x9f]) * 0.5;
      ResourceManagerPointer[0xa8] = 3.4028235e+38;
      FloatScaleFactor = 0.0;
      unsignedSystemValue8 = (ulong long)*(uint *)(lStack_88 + 0x10);
      if (0 < (int)*(uint *)(lStack_88 + 0x10)) {
        pfloatValue6 = *(float **)(lStack_88 + 0x18);
        floatValue11 = FloatScaleFactor;
        do {
          FloatScaleFactor = (*pfloatValue6 - ResourceManagerPointer[0xa5]) * (*pfloatValue6 - ResourceManagerPointer[0xa5]) +
                   (pfloatValue6[1] - ResourceManagerPointer[0xa6]) * (pfloatValue6[1] - ResourceManagerPointer[0xa6]) +
                   (pfloatValue6[2] - ResourceManagerPointer[0xa7]) * (pfloatValue6[2] - ResourceManagerPointer[0xa7]);
          if (FloatScaleFactor <= floatValue11) {
            FloatScaleFactor = floatValue11;
          }
          pfloatValue6 = pfloatValue6 + 4;
          unsignedSystemValue8 = unsignedSystemValue8 - 1;
          floatValue11 = FloatScaleFactor;
        } while (unsignedSystemValue8 != 0);
      }
      ResourceManagerPointer[0xa9] = SQRT(FloatScaleFactor);
    }
    if (pfStack_98 != (float *)0x0) {
      while( true ) {
        LOCK();
        charValue = *(char *)(pfloatValue4 + 0x3b);
        isSystemBusy = charValue == '\0';
        if (isSystemBusy) {
          *(char *)(pfloatValue4 + 0x3b) = '\x01';
          charValue = '\0';
        }
        UNLOCK();
        if (isSystemBusy) break;
        FloatScaleFactor = (float)_Thrd_id();
        if ((pfloatValue4[0x3c] == FloatScaleFactor) || (pfloatValue4[0x3c] != 0.0)) goto LAB_180075f4f;
        Sleep();
      }
      charValue = '\0';
LAB_180075f4f:
      LOCK();
      pfloatValue1 = pfloatValue4 + 0x3a;
      FloatScaleFactor = *pfloatValue1;
      pfloatValue6 = (float *)(ulong long)(uint)FloatScaleFactor;
      *pfloatValue1 = (float)((int)*pfloatValue1 + -1);
      UNLOCK();
      if (charValue == '\0') {
        if ((((FloatScaleFactor == 1.4013e-45) && (*(long long *)(pfStack_98 + 0x84) != 0)) &&
            (pfloatValue6 = pfStack_98, FUN_1800791a0(pfStack_98), *(char *)(pfloatValue6 + 0x3f) == '\0')) &&
           ((*(char *)(pfloatValue6 + 0x3d) == '\0' &&
            (((*(byte *)((long long)pfloatValue6 + 0xfd) & 0x20) == 0 ||
             ((*(byte *)((long long)pfloatValue6 + 0xfe) & 1) == 0)))))) {
          plocalResourceOffset = *(long long **)(pfloatValue6 + 0x84);
          pfloatValue6[0x84] = 0.0;
          pfloatValue6[0x85] = 0.0;
          if (plocalResourceOffset != (long long *)0x0) {
            (**(code **)(*plocalResourceOffset + 0x38))();
          }
        }
        LOCK();
        isSystemActive = *(byte *)(pfloatValue4 + 0x3b);
        *(byte *)(pfloatValue4 + 0x3b) = 0;
        pfloatValue6 = (float *)(ulong long)isSystemActive;
        UNLOCK();
      }
    }
  }
  return pfloatValue6;
}




// 函数: void FUN_180075ff0(long long *ResourceManagerPointer)
void FUN_180075ff0(long long *ResourceManagerPointer)

{
  ushort systemStatus;
  long long *resourcePoolPointer;
  uint allocationContext;
  int systemIndex;
  int systemValue;
  int systemFlag;
  long long localDataIndex;
  float floatValue8;
  float floatValue9;
  uint8_t StackBuffer138 [8];
  long long *pLocalStackInitializationFlag;
  uint32_t uStack_128;
  long long *plStack_120;
  long long *plStack_118;
  uint32_t UnsignedStackFlag110;
  long long lStack_108;
  void* unsignedValue100;
  void* unsignedValueF8;
  uint8_t uStack_f0;
  void* uStack_e8;
  void* unsignedValueD8;
  void* uStack_c8;
  void* UnsignedStackFlagC0;
  uint8_t UnsignedStackFlagB8;
  void* UnsignedStackFlagB0;
  void* UnsignedStackFlagA0;
  void* StackParameterC;
  
  SystemConfigurationValue = 0xfffffffffffffffe;
  while( true ) {
    if (((int)ResourceManagerPointer[0x41] != 0) &&
       ((floatValue8 = *(float *)(ResourceManagerPointer + 0x5b) - *(float *)((long long)ResourceManagerPointer + 0x2dc), floatValue8 <= -0.01
        || (0.01 <= floatValue8)))) {
      resourcePoolPointer = ResourceManagerPointer;
      if ((((*(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x40) == 0) || (ResourceManagerPointer[0x42] == 0)) &&
         (ResourceManagerPointer[0x36] != 0)) {
        resourcePoolPointer = (long long *)FUN_180085900();
      }
      systemFlag = 0;
      if (resourcePoolPointer == ResourceManagerPointer) {
        plStack_120 = (long long *)0x0;
        StackBuffer138[0] = 0;
        uStack_128 = 0;
        pLocalStackInitializationFlag = resourcePoolPointer;
        FUN_18007f4c0(StackBuffer138);
        resourcePoolPointer = plStack_120 + 0x16;
        systemStatus = *(ushort *)(plStack_120 + 0x18);
        floatValue8 = *(float *)(plStack_120[0x17] + -4 + (ulong long)systemStatus * 4);
        floatValue9 = *(float *)((long long)ResourceManagerPointer + 0x2dc);
        if (floatValue8 < *(float *)((long long)ResourceManagerPointer + 0x2dc)) {
          *(float *)((long long)ResourceManagerPointer + 0x2dc) = floatValue8;
          systemStatus = *(ushort *)(plStack_120 + 0x18);
          floatValue9 = floatValue8;
        }
        allocationContext = (uint)systemStatus;
        if (systemStatus < 2) {
          systemFlag = allocationContext - 1;
          floatValue8 = 0.0;
          systemValue = systemFlag;
        }
        else {
          systemValue = allocationContext - 1;
          if (0 < (int)(allocationContext - 2)) {
            do {
              systemIndex = systemValue + systemFlag >> 1;
              if (*(float *)(plStack_120[0x17] + (long long)systemIndex * 4) <= floatValue9) {
                systemFlag = systemIndex;
                systemIndex = systemValue;
              }
              systemValue = systemIndex;
            } while (systemFlag < systemValue + -1);
          }
          floatValue8 = *(float *)(plStack_120[0x17] + (long long)systemFlag * 4);
          floatValue8 = (floatValue9 - floatValue8) / (*(float *)(plStack_120[0x17] + (long long)systemValue * 4) - floatValue8);
          if (0.0 <= floatValue8) {
            if (1.0 <= floatValue8) {
              floatValue8 = 1.0;
            }
          }
          else {
            floatValue8 = 0.0;
          }
        }
        if (-1 < systemFlag) {
          (**(code **)(*ResourceManagerPointer + 0x28))(ResourceManagerPointer);
          unsignedValue100 = 0;
          unsignedValueF8 = 0;
          unsignedValueD8 = 0;
          uStack_e8 = 0;
          uStack_f0 = 0;
          FUN_18022f2e0(&unsignedValue100,ResourceManagerPointer,0);
          (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
          FUN_18022f9b0(&unsignedValue100,resourcePoolPointer,systemValue,systemFlag,floatValue8);
          FUN_18022f410(&unsignedValue100);
        }
        FUN_18007f6a0(StackBuffer138);
        if (plStack_120 != (long long *)0x0) {
          (**(code **)(*plStack_120 + 0x38))();
        }
      }
      else {
        UnsignedStackFlag110 = 0;
        plStack_118 = resourcePoolPointer;
        FUN_18007f770(&plStack_118);
        localDataIndex = lStack_108 + 0xb0;
        systemStatus = *(ushort *)(lStack_108 + 0xc0);
        floatValue8 = *(float *)(*(long long *)(lStack_108 + 0xb8) + -4 + (ulong long)systemStatus * 4);
        floatValue9 = *(float *)((long long)ResourceManagerPointer + 0x2dc);
        if (floatValue8 < *(float *)((long long)ResourceManagerPointer + 0x2dc)) {
          *(float *)((long long)ResourceManagerPointer + 0x2dc) = floatValue8;
          systemStatus = *(ushort *)(lStack_108 + 0xc0);
          floatValue9 = floatValue8;
        }
        allocationContext = (uint)systemStatus;
        if (systemStatus < 2) {
          systemFlag = allocationContext - 1;
          floatValue8 = 0.0;
          systemValue = systemFlag;
        }
        else {
          systemValue = allocationContext - 1;
          if (0 < (int)(allocationContext - 2)) {
            do {
              systemIndex = systemValue + systemFlag >> 1;
              if (*(float *)(*(long long *)(lStack_108 + 0xb8) + (long long)systemIndex * 4) <= floatValue9) {
                systemFlag = systemIndex;
                systemIndex = systemValue;
              }
              systemValue = systemIndex;
            } while (systemFlag < systemValue + -1);
          }
          floatValue8 = *(float *)(*(long long *)(lStack_108 + 0xb8) + (long long)systemFlag * 4);
          floatValue8 = (floatValue9 - floatValue8) /
                  (*(float *)(*(long long *)(lStack_108 + 0xb8) + (long long)systemValue * 4) - floatValue8);
          if (0.0 <= floatValue8) {
            if (1.0 <= floatValue8) {
              floatValue8 = 1.0;
            }
          }
          else {
            floatValue8 = 0.0;
          }
        }
        if (-1 < systemFlag) {
          (**(code **)(*ResourceManagerPointer + 0x28))(ResourceManagerPointer);
          uStack_c8 = 0;
          UnsignedStackFlagC0 = 0;
          UnsignedStackFlagA0 = 0;
          UnsignedStackFlagB0 = 0;
          UnsignedStackFlagB8 = 0;
          FUN_18022f2e0(&uStack_c8,ResourceManagerPointer,0);
          (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
          FUN_18022f9b0(&uStack_c8,localDataIndex,systemValue,systemFlag,floatValue8);
          FUN_18022f410(&uStack_c8);
        }
        FUN_18007f840(&plStack_118);
      }
      *(uint32_t *)(ResourceManagerPointer + 0x5b) = *(uint32_t *)((long long)ResourceManagerPointer + 0x2dc);
    }
    if ((*(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x20) != 0) break;
    ResourceManagerPointer = (long long *)ResourceManagerPointer[0x36];
  }
  return;
}




long long * FUN_1800763c0(long long *ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  byte *pisByteValid;
  uint32_t creationFlags;
  long long localResourceOffset;
  uint32_t unsignedSystemValue4;
  uint32_t currentThreadId;
  uint32_t hashValue;
  void* unsignedSystemValue7;
  void* unsignedSystemValue8;
  void* unsignedSystemValue9;
  void* systemOperationFlags;
  long long nextDataIndex1;
  long long nextDataIndex2;
  long long nextDataIndex3;
  long long nextDataIndex4;
  long long nextDataIndex5;
  long long nextDataIndex6;
  long long nextDataIndex7;
  void* systemStatus8;
  long long *PrimaryResourcePointer9;
  void* *HashEntryStatus0;
  long long *plStackX_8;
  long long *plStackX_10;
  uint32_t creationFlags1;
  
  plStackX_10 = ConfigurationDataPointer;
  systemStatus8 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x300,0x10,9,0,0xfffffffffffffffe);
  PrimaryResourcePointer9 = (long long *)FUN_180075030(systemStatus8,0,0);
  *ConfigurationDataPointer = (long long)PrimaryResourcePointer9;
  if (PrimaryResourcePointer9 != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer9 + 0x28))(PrimaryResourcePointer9);
  }
  creationFlags1 = 1;
  *(byte *)(*ConfigurationDataPointer + 0xfd) = *(byte *)(*ConfigurationDataPointer + 0xfd) & 0xdf;
  nextDataIndex1 = ResourceManagerPointer[0x18];
  localResourceOffset = *ConfigurationDataPointer;
  *(long long *)(localResourceOffset + 0xb8) = ResourceManagerPointer[0x17];
  *(long long *)(localResourceOffset + 0xc0) = nextDataIndex1;
  *(byte *)(*ConfigurationDataPointer + 0xfd) = *(byte *)(*ConfigurationDataPointer + 0xfd) & 0xbf;
  creationFlags = *(uint32_t *)((long long)ResourceManagerPointer + 0xcc);
  nextDataIndex1 = ResourceManagerPointer[0x1a];
  unsignedSystemValue4 = *(uint32_t *)((long long)ResourceManagerPointer + 0xd4);
  nextDataIndex2 = ResourceManagerPointer[0x1b];
  currentThreadId = *(uint32_t *)((long long)ResourceManagerPointer + 0xdc);
  nextDataIndex3 = ResourceManagerPointer[0x1c];
  hashValue = *(uint32_t *)((long long)ResourceManagerPointer + 0xe4);
  localResourceOffset = *ConfigurationDataPointer;
  *(int *)(localResourceOffset + 200) = (int)ResourceManagerPointer[0x19];
  *(uint32_t *)(localResourceOffset + 0xcc) = creationFlags;
  *(int *)(localResourceOffset + 0xd0) = (int)nextDataIndex1;
  *(uint32_t *)(localResourceOffset + 0xd4) = unsignedSystemValue4;
  *(int *)(localResourceOffset + 0xd8) = (int)nextDataIndex2;
  *(uint32_t *)(localResourceOffset + 0xdc) = currentThreadId;
  *(int *)(localResourceOffset + 0xe0) = (int)nextDataIndex3;
  *(uint32_t *)(localResourceOffset + 0xe4) = hashValue;
  if ((*(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    FUN_180075990(*ConfigurationDataPointer,ResourceManagerPointer + 0x36);
  }
  else {
    localResourceOffset = *ConfigurationDataPointer;
    plStackX_8 = ResourceManagerPointer;
    (**(code **)(*ResourceManagerPointer + 0x28))(ResourceManagerPointer);
    FUN_180075990(localResourceOffset,&plStackX_8);
    (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
  }
  *(long long *)(*ConfigurationDataPointer + 0xa8) = ResourceManagerPointer[0x15];
  pisByteValid = (byte *)(*ConfigurationDataPointer + 0xfd);
  *pisByteValid = *pisByteValid ^ (*(byte *)(*ConfigurationDataPointer + 0xfd) ^ *(byte *)((long long)ResourceManagerPointer + 0xfd)) & 2;
  *(int *)(*ConfigurationDataPointer + 0x100) = (int)ResourceManagerPointer[0x20];
  nextDataIndex1 = ResourceManagerPointer[0x48];
  localResourceOffset = *ConfigurationDataPointer;
  *(long long *)(localResourceOffset + 0x238) = ResourceManagerPointer[0x47];
  *(long long *)(localResourceOffset + 0x240) = nextDataIndex1;
  nextDataIndex1 = ResourceManagerPointer[0x4a];
  localResourceOffset = *ConfigurationDataPointer;
  *(long long *)(localResourceOffset + 0x248) = ResourceManagerPointer[0x49];
  *(long long *)(localResourceOffset + 0x250) = nextDataIndex1;
  creationFlags = *(uint32_t *)((long long)ResourceManagerPointer + 0x2ac);
  nextDataIndex1 = ResourceManagerPointer[0x56];
  unsignedSystemValue4 = *(uint32_t *)((long long)ResourceManagerPointer + 0x2b4);
  localResourceOffset = *ConfigurationDataPointer;
  *(int *)(localResourceOffset + 0x2a8) = (int)ResourceManagerPointer[0x55];
  *(uint32_t *)(localResourceOffset + 0x2ac) = creationFlags;
  *(int *)(localResourceOffset + 0x2b0) = (int)nextDataIndex1;
  *(uint32_t *)(localResourceOffset + 0x2b4) = unsignedSystemValue4;
  creationFlags = *(uint32_t *)((long long)ResourceManagerPointer + 700);
  nextDataIndex1 = ResourceManagerPointer[0x58];
  unsignedSystemValue4 = *(uint32_t *)((long long)ResourceManagerPointer + 0x2c4);
  localResourceOffset = *ConfigurationDataPointer;
  *(int *)(localResourceOffset + 0x2b8) = (int)ResourceManagerPointer[0x57];
  *(uint32_t *)(localResourceOffset + 700) = creationFlags;
  *(int *)(localResourceOffset + 0x2c0) = (int)nextDataIndex1;
  *(uint32_t *)(localResourceOffset + 0x2c4) = unsignedSystemValue4;
  *(int *)(*ConfigurationDataPointer + 0x108) = (int)ResourceManagerPointer[0x21];
  if ((long long *)(*ConfigurationDataPointer + 0x218) != ResourceManagerPointer + 0x43) {
    FUN_1800588c0((long long *)(*ConfigurationDataPointer + 0x218),ResourceManagerPointer[0x43],ResourceManagerPointer[0x44]);
  }
  HashEntryStatus0 = &SystemStringTemplate;
  if ((void* *)ResourceManagerPointer[3] != (void* *)0x0) {
    HashEntryStatus0 = (void* *)ResourceManagerPointer[3];
  }
  (**(code **)(*(long long *)(*ConfigurationDataPointer + 0x10) + 0x10))((long long *)(*ConfigurationDataPointer + 0x10),HashEntryStatus0);
  *(uint8_t *)(*ConfigurationDataPointer + 0xf6) = *(uint8_t *)((long long)ResourceManagerPointer + 0xf6);
  systemStatus8 = *(void* *)((long long)ResourceManagerPointer + 0x27c);
  unsignedSystemValue7 = *(void* *)((long long)ResourceManagerPointer + 0x284);
  unsignedSystemValue8 = *(void* *)((long long)ResourceManagerPointer + 0x28c);
  unsignedSystemValue9 = *(void* *)((long long)ResourceManagerPointer + 0x294);
  systemOperationFlags = *(void* *)((long long)ResourceManagerPointer + 0x29c);
  creationFlags = *(uint32_t *)((long long)ResourceManagerPointer + 0x2a4);
  localResourceOffset = *ConfigurationDataPointer;
  *(void* *)(localResourceOffset + 0x274) = *(void* *)((long long)ResourceManagerPointer + 0x274);
  *(void* *)(localResourceOffset + 0x27c) = systemStatus8;
  *(void* *)(localResourceOffset + 0x284) = unsignedSystemValue7;
  *(void* *)(localResourceOffset + 0x28c) = unsignedSystemValue8;
  *(void* *)(localResourceOffset + 0x294) = unsignedSystemValue9;
  *(void* *)(localResourceOffset + 0x29c) = systemOperationFlags;
  *(uint32_t *)(localResourceOffset + 0x2a4) = creationFlags;
  *(uint8_t *)(*ConfigurationDataPointer + 0xff) = *(uint8_t *)((long long)ResourceManagerPointer + 0xff);
  *(int *)(*ConfigurationDataPointer + 0x270) = (int)ResourceManagerPointer[0x4e];
  nextDataIndex1 = ResourceManagerPointer[0x25];
  nextDataIndex2 = ResourceManagerPointer[0x26];
  nextDataIndex3 = ResourceManagerPointer[0x27];
  nextDataIndex4 = ResourceManagerPointer[0x28];
  nextDataIndex5 = ResourceManagerPointer[0x29];
  nextDataIndex6 = ResourceManagerPointer[0x2a];
  nextDataIndex7 = ResourceManagerPointer[0x2b];
  localResourceOffset = *ConfigurationDataPointer;
  *(long long *)(localResourceOffset + 0x120) = ResourceManagerPointer[0x24];
  *(long long *)(localResourceOffset + 0x128) = nextDataIndex1;
  *(long long *)(localResourceOffset + 0x130) = nextDataIndex2;
  *(long long *)(localResourceOffset + 0x138) = nextDataIndex3;
  *(long long *)(localResourceOffset + 0x140) = nextDataIndex4;
  *(long long *)(localResourceOffset + 0x148) = nextDataIndex5;
  *(long long *)(localResourceOffset + 0x150) = nextDataIndex6;
  *(long long *)(localResourceOffset + 0x158) = nextDataIndex7;
  nextDataIndex1 = ResourceManagerPointer[0x2d];
  nextDataIndex2 = ResourceManagerPointer[0x2e];
  nextDataIndex3 = ResourceManagerPointer[0x2f];
  nextDataIndex4 = ResourceManagerPointer[0x30];
  creationFlags = *(uint32_t *)((long long)ResourceManagerPointer + 0x184);
  nextDataIndex5 = ResourceManagerPointer[0x31];
  unsignedSystemValue4 = *(uint32_t *)((long long)ResourceManagerPointer + 0x18c);
  nextDataIndex6 = ResourceManagerPointer[0x32];
  currentThreadId = *(uint32_t *)((long long)ResourceManagerPointer + 0x194);
  nextDataIndex7 = ResourceManagerPointer[0x33];
  hashValue = *(uint32_t *)((long long)ResourceManagerPointer + 0x19c);
  localResourceOffset = *ConfigurationDataPointer;
  *(long long *)(localResourceOffset + 0x160) = ResourceManagerPointer[0x2c];
  *(long long *)(localResourceOffset + 0x168) = nextDataIndex1;
  *(long long *)(localResourceOffset + 0x170) = nextDataIndex2;
  *(long long *)(localResourceOffset + 0x178) = nextDataIndex3;
  *(int *)(localResourceOffset + 0x180) = (int)nextDataIndex4;
  *(uint32_t *)(localResourceOffset + 0x184) = creationFlags;
  *(int *)(localResourceOffset + 0x188) = (int)nextDataIndex5;
  *(uint32_t *)(localResourceOffset + 0x18c) = unsignedSystemValue4;
  *(int *)(localResourceOffset + 400) = (int)nextDataIndex6;
  *(uint32_t *)(localResourceOffset + 0x194) = currentThreadId;
  *(int *)(localResourceOffset + 0x198) = (int)nextDataIndex7;
  *(uint32_t *)(localResourceOffset + 0x19c) = hashValue;
  pisByteValid = (byte *)(*ConfigurationDataPointer + 0xfd);
  *pisByteValid = *pisByteValid ^ (*(byte *)(*ConfigurationDataPointer + 0xfd) ^ *(byte *)((long long)ResourceManagerPointer + 0xfd)) & 1;
  *(uint8_t *)(*ConfigurationDataPointer + 0xf7) = *(uint8_t *)((long long)ResourceManagerPointer + 0xf7);
  *(int *)(*ConfigurationDataPointer + 0x208) = (int)ResourceManagerPointer[0x41];
  *(int *)(*ConfigurationDataPointer + 0x1f8) = (int)ResourceManagerPointer[0x3f];
  *(uint32_t *)(*ConfigurationDataPointer + 0x1fc) = *(uint32_t *)((long long)ResourceManagerPointer + 0x1fc);
  *(int *)(*ConfigurationDataPointer + 0x200) = (int)ResourceManagerPointer[0x40];
  *(uint32_t *)(*ConfigurationDataPointer + 0x204) = *(uint32_t *)((long long)ResourceManagerPointer + 0x204);
  *(int *)(*ConfigurationDataPointer + 0x2d8) = (int)ResourceManagerPointer[0x5b];
  creationFlags = *(uint32_t *)((long long)ResourceManagerPointer + 0x2dc);
  *(uint32_t *)(*ConfigurationDataPointer + 0x2dc) = creationFlags;
  localResourceOffset = *ConfigurationDataPointer;
  PrimaryResourcePointer9 = (long long *)ResourceManagerPointer[0x4d];
  if (PrimaryResourcePointer9 != (long long *)0x0) {
    plStackX_8 = PrimaryResourcePointer9;
    (**(code **)(*PrimaryResourcePointer9 + 0x28))(PrimaryResourcePointer9,creationFlags,(int)nextDataIndex4,(int)nextDataIndex6,creationFlags1);
  }
  plStackX_8 = *(long long **)(localResourceOffset + 0x268);
  *(long long **)(localResourceOffset + 0x268) = PrimaryResourcePointer9;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x38))();
  }
  FUN_180076910(*ConfigurationDataPointer,ResourceManagerPointer + 0x37);
  return ConfigurationDataPointer;
}




// 函数: void FUN_180076760(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FUN_180076760(long long *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  void* creationFlags;
  long long *plongValue40;
  long long *plongValue38;
  uint8_t aunsignedValue30 [8];
  void* EncryptionKeyValue;
  long long *plStack_18;
  void*2 unsignedValue10;
  char cStack_e;
  
  creationFlags = 0xfffffffffffffffe;
  if (ResourceManagerPointer[0x42] == 0) {
    ResourceManagerPointer[0x3f] = 0;
    ResourceManagerPointer[0x40] = 0;
    *(uint32_t *)(ResourceManagerPointer + 0x41) = 0;
    FUN_180079520();
  }
  else {
    (**(code **)(*ResourceManagerPointer + 0x28))();
    plongValue40 = (long long *)0x0;
    plongValue38 = (long long *)0x0;
    plStack_18 = (long long *)0x0;
    EncryptionKeyValue = 0;
    aunsignedValue30[0] = 0;
    FUN_18022f2e0(&plongValue40,ResourceManagerPointer,0,ConfigurationFlag,creationFlags);
    (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
    PrimaryResourcePointer = plongValue38;
    *(uint32_t *)(plongValue38 + 2) = 0;
    *(uint32_t *)(plongValue38 + 7) = 0;
    *(uint32_t *)(plongValue38 + 0x11) = 0;
    *(uint32_t *)(plongValue38 + 0xc) = 0;
    *(void*2 *)(plongValue38 + 0x18) = 0;
    if (plongValue38[0x17] != 0) {
        SystemCleanupFunction();
    }
    plongValue38[0x17] = 0;
    FUN_180085530(plongValue38[0x16]);
    PrimaryResourcePointer[0x16] = 0;
    *(uint32_t *)(PrimaryResourcePointer + 0x19) = 0;
    unsignedValue10 = 0x101;
    if ((plongValue40 != (long long *)0x0) && (plongValue38 != (long long *)0x0)) {
      if (cStack_e != '\0') {
        FUN_180075b70();
      }
      FUN_18007f6a0(aunsignedValue30);
      if ((char)unsignedValue10 != '\0') {
        FUN_180079520(plongValue40);
      }
      if (unsignedValue10._1_1_ != '\0') {
        FUN_180079520(plongValue40);
      }
      PrimaryResourcePointer = plongValue38;
      plongValue38 = (long long *)0x0;
      if (PrimaryResourcePointer != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer + 0x38))();
      }
    }
    FUN_18007f6a0(aunsignedValue30);
    if (plStack_18 != (long long *)0x0) {
      (**(code **)(*plStack_18 + 0x38))();
    }
    if (plongValue38 != (long long *)0x0) {
      (**(code **)(*plongValue38 + 0x38))();
    }
    if (plongValue40 != (long long *)0x0) {
      (**(code **)(*plongValue40 + 0x38))();
      return;
    }
  }
  return;
}




// 函数: void FUN_180076910(long long ResourceManagerPointer,long long *ConfigurationDataPointer)
void FUN_180076910(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  byte isByteValid;
  long long localSystemHandle;
  uint8_t allocationContext;
  byte isResourceAvailable;
  uint currentThreadId;
  long long localSystemFlags;
  long long *plocalDataIndex;
  
  if (*ConfigurationDataPointer != *(long long *)(ResourceManagerPointer + 0x1b8)) {
    if (*(char *)(ResourceManagerPointer + 0xb1) != '\0') {
        SystemDataOperation();
    }
    FUN_180080810(ResourceManagerPointer + 0x1b8);
    localSystemHandle = *(long long *)(ResourceManagerPointer + 0x1b8);
    if (localSystemHandle != 0) {
      localSystemFlags = 0;
      isByteValid = *(byte *)(ResourceManagerPointer + 0xfd);
      isResourceAvailable = (byte)((uint)*(uint32_t *)(*(long long *)(localSystemHandle + 0x1e0) + 0x1588) >> 0x1b) << 7;
      *(byte *)(ResourceManagerPointer + 0xfd) = isResourceAvailable | isByteValid & 0x7f;
      currentThreadId = *(uint *)(localSystemHandle + 0x138) & 0x3000;
      if (currentThreadId == 0x1000) {
        *(uint8_t *)(ResourceManagerPointer + 0xf7) = 1;
      }
      else {
        allocationContext = 0;
        if (currentThreadId == 0x2000) {
          allocationContext = 2;
        }
        *(uint8_t *)(ResourceManagerPointer + 0xf7) = allocationContext;
      }
      isResourceAvailable = isResourceAvailable | isByteValid & 0x77;
      *(byte *)(ResourceManagerPointer + 0xfd) = isResourceAvailable;
      plocalDataIndex = (long long *)(localSystemHandle + 0xb8);
      do {
        if (0xf < localSystemFlags) break;
        if ((*plocalDataIndex != 0) && (*(int *)(*plocalDataIndex + 0x36c) != 0)) {
          isResourceAvailable = isResourceAvailable | 8;
          *(byte *)(ResourceManagerPointer + 0xfd) = isResourceAvailable;
        }
        localSystemFlags = localSystemFlags + 1;
        plocalDataIndex = plocalDataIndex + 1;
      } while ((isResourceAvailable & 8) == 0);
      FUN_1800781e0(ResourceManagerPointer);
    }
  }
  return;
}




// 函数: void FUN_180076a20(long long ResourceManagerPointer)
void FUN_180076a20(long long ResourceManagerPointer)

{
  int systemStatus;
  
  systemStatus = _Mtx_lock(0x180c91910);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  *(char *)(ResourceManagerPointer + 0xfc) = *(char *)(ResourceManagerPointer + 0xfc) + '\x01';
  systemStatus = _Mtx_unlock(0x180c91910);
  if (systemStatus != 0) {
    __Throw_C_error_std__YAXH_Z(systemStatus);
  }
  return;
}




// 函数: void FUN_180076a80(long long ResourceManagerPointer)
/**
 * @brief 系统资源引用计数管理器
 * 
 * 该函数负责管理系统资源的引用计数，当引用计数降为0时，
 * 会执行资源清理和释放操作。它使用互斥锁确保线程安全。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含引用计数和资源信息
 * @note 这是系统资源生命周期管理的核心函数
 */
void ManageSystemResourceReferenceCount(long long ResourceManagerPointer)

{
  char *ReferenceCountPointer;
  long long *resourcePoolPointer;
  int LockStatus;
  bool IsResourceLocked;
  
  LockStatus = _Mtx_lock(0x180c91910);
  if (LockStatus != 0) {
    __Throw_C_error_std__YAXH_Z(LockStatus);
  }
  ReferenceCountPointer = (char *)(ResourceManagerPointer + 0xfc);
  *ReferenceCountPointer = *ReferenceCountPointer + -1;
  if (*ReferenceCountPointer == '\0') {
    while( true ) {
      LOCK();
      IsResourceLocked = *(char *)(ResourceManagerPointer + 0xec) == '\0';
      if (IsResourceLocked) {
        *(char *)(ResourceManagerPointer + 0xec) = '\x01';
      }
      UNLOCK();
      if (IsResourceLocked) break;
      Sleep();
    }
    while (*(int *)(ResourceManagerPointer + 0xe8) != 0) {
      Sleep(0);
    }
    if ((((*(long long *)(ResourceManagerPointer + 0x210) != 0) &&
         (FUN_1800791a0(ResourceManagerPointer), *ReferenceCountPointer == '\0')) &&
        (*(char *)(ResourceManagerPointer + 0xf4) == '\0')) &&
       (((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0 || ((*(byte *)(ResourceManagerPointer + 0xfe) & 1) == 0)))) {
      resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x210);
      *(void* *)(ResourceManagerPointer + 0x210) = 0;
      if (resourcePoolPointer != (long long *)0x0) {
        (**(code **)(*resourcePoolPointer + 0x38))();
      }
    }
    LOCK();
    if (*(char *)(ResourceManagerPointer + 0xec) == '\x01') {
      *(char *)(ResourceManagerPointer + 0xec) = '\0';
    }
    UNLOCK();
  }
  LockStatus = _Mtx_unlock(0x180c91910);
  if (LockStatus != 0) {
    __Throw_C_error_std__YAXH_Z(LockStatus);
  }
  return;
}



void* FUN_180076b90(long long ResourceManagerPointer)

{
  byte isByteValid;
  long long localSystemHandle;
  byte isOperationComplete;
  
  isOperationComplete = *(byte *)(ResourceManagerPointer + 0xfd);
  localSystemHandle = ResourceManagerPointer;
  if ((isOperationComplete & 0x20) == 0) {
    localSystemHandle = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  if (0 < *(int *)(localSystemHandle + 0x200)) {
    localSystemHandle = *(long long *)(ResourceManagerPointer + 0x1b8);
    isByteValid = *(byte *)(localSystemHandle + 0x38c);
    if (isByteValid == 9) {
      isByteValid = func_0x00018022d300();
      *(byte *)(localSystemHandle + 0x38c) = isByteValid;
      isOperationComplete = *(byte *)(ResourceManagerPointer + 0xfd);
    }
    if ((isOperationComplete & 0x20) == 0) {
      ResourceManagerPointer = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
    }
    if ((*(long long *)(ResourceManagerPointer + 0x1e0) == 0) ||
       (*(byte *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + (ulong long)isByteValid * 0x18) < 2)) {
      return 0;
    }
  }
  return 1;
}




int FUN_180076c50(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  ulong long *HashNodePointer;
  char systemStatusFlag;
  int systemValue;
  uint hashValue;
  long long localDataIndex;
  char *pcharInput;
  long long resourceCounter;
  ulong long systemOperationFlags;
  ulong long systemStatus1;
  ulong long *psystemStatus2;
  uint systemStatus3;
  ulong long systemStatus4;
  uint32_t extraout_XMM0_Da;
  uint32_t systemStatus5;
  void* uStackX_8;
  void** HashBucketNode;
  void** SystemStackPointer;
  uint InputStackParameterNegative38;
  void* systemStatus6;
  ulong long *pUnsignedStackFlag80;
  long long *plStack_78;
  code *pcStack_70;
  code *pcStack_68;
  void* unsignedValue60;
  void* processFlags58;
  void* unsignedValue50;
  uint32_t EncryptionValue48;
  
  systemStatus6 = 0xfffffffffffffffe;
  systemValue = 0;
  if (((*(long long *)(ResourceManagerPointer + 0x1b8) != 0) && (systemValue = 0, (*(byte *)(ConfigurationDataPointer + 1) & 4) == 0)) &&
     (*(char*)((long long)ConfigurationDataPointer + 0x12) == '\0')) {
    systemValue = FUN_18022d470();
  }
  if ((*(byte *)(ConfigurationDataPointer + 1) & 0x20) == 0) {
    systemStatusFlag = FUN_180076b90(ResourceManagerPointer);
    if (systemStatusFlag == '\0') {
      if ((char)ConfigurationDataPointer[2] != '\0') {
        pUnsignedStackFlag80 = (ulong long *)0x0;
        plStack_78 = (long long *)0x0;
        pcStack_70 = (code *)0x0;
        pcStack_68 = _guard_check_icall;
        FUN_1800b6f90(extraout_XMM0_Da,ResourceManagerPointer,&pUnsignedStackFlag80);
        if (pcStack_70 != (code *)0x0) {
          (*pcStack_70)(&pUnsignedStackFlag80,0,0);
        }
      }
      systemStatusFlag = FUN_180076b90(ResourceManagerPointer);
      if (systemStatusFlag == '\0') {
        systemValue = systemValue + 1;
        if (*ConfigurationDataPointer != 0) {
          uStackX_8 = ResourceManagerPointer;
          InitializeSystemHandle(*ConfigurationDataPointer,&uStackX_8);
        }
      }
    }
    else if ((char)ConfigurationDataPointer[2] != '\0') {
      FUN_18007b1e0(ResourceManagerPointer,0);
    }
  }
  if ((*(byte *)(ConfigurationDataPointer + 1) & 0x10) == 0) {
    return systemValue;
  }
  unsignedValue60 = 0;
  processFlags58 = 0;
  unsignedValue50 = 0;
  EncryptionValue48 = 3;
  puStackX_10 = *(void* **)(ResourceManagerPointer + 0x1b8);
  systemStatus3 = *(uint *)(ResourceManagerPointer + 0x100) >> 0x16;
  pcharInput = "";
  if ((char *)puStackX_10[3] != (char *)0x0) {
    pcharInput = (char *)puStackX_10[3];
  }
  hashValue = 0x1505;
  systemStatusFlag = *pcharInput;
  while (systemStatusFlag != '\0') {
    pcharInput = pcharInput + 1;
    hashValue = hashValue * 0x21 + (int)systemStatusFlag;
    systemStatusFlag = *pcharInput;
  }
  systemStatus1 = (ulong long)hashValue;
  if ((systemStatus3 & 1) != 0) {
    systemStatus1 = (ulong long)hashValue | 0x400000000;
  }
  resourceCounter = ConfigurationDataPointer[9];
  if (resourceCounter != 0) {
    PrimaryResourcePointer = (long long *)(*(long long *)(resourceCounter + 8) + *(ulong long *)(resourceCounter + 0x10) * 8);
    psystemStatus2 = (ulong long *)*PrimaryResourcePointer;
    resourcePoolPointer = (long long *)
             (*(long long *)(resourceCounter + 8) + (systemStatus1 % (*(ulong long *)(resourceCounter + 0x10) & 0xffffffff)) * 8)
    ;
    for (HashNodePointer = (ulong long *)*resourcePoolPointer;
        (pUnsignedStackFlag80 = psystemStatus2, plStack_78 = PrimaryResourcePointer, HashNodePointer != (ulong long *)0x0 &&
        (pUnsignedStackFlag80 = HashNodePointer, plStack_78 = resourcePoolPointer, systemStatus1 != *HashNodePointer));
        HashNodePointer = (ulong long *)HashNodePointer[1]) {
    }
    if (pUnsignedStackFlag80 != psystemStatus2) goto LAB_180076feb;
  }
  PrimaryResourcePointer = ConfigurationDataPointer + 5;
  resourceCounter = ConfigurationDataPointer[7] - *PrimaryResourcePointer;
  if ((ulong long)(resourceCounter / 0x18) < 0x100) {
    localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x1800,(char)ConfigurationDataPointer[8]);
    resourceCounter = *PrimaryResourcePointer;
    if (resourceCounter != ConfigurationDataPointer[6]) {
        memmove(localDataIndex,resourceCounter,ConfigurationDataPointer[6] - resourceCounter);
    }
    if (resourceCounter != 0) {
        SystemCleanupFunction();
    }
    *PrimaryResourcePointer = localDataIndex;
    ConfigurationDataPointer[6] = localDataIndex;
    ConfigurationDataPointer[7] = localDataIndex + 0x1800;
    resourceCounter = 0;
  }
  SystemStackPointer = &uStackX_8;
  uStackX_8 = 0;
  systemStatus5 = InitializeResourceContext(resourceCounter,puStackX_10,&unsignedValue60,0,InputStackParameterNegative38 & 0xffffff00,0,
                         (byte)systemStatus3 & 1,PrimaryResourcePointer,1,0,0,&uStackX_8,systemStatus6);
  puStackX_10 = &uStackX_8;
  uStackX_8 = 0;
  systemStatusFlag = ValidateResourceInitialization(systemStatus5,PrimaryResourcePointer,&uStackX_8);
  if (systemStatusFlag == '\0') {
    systemValue = systemValue + 1;
  }
  ConfigurationDataPointer[6] = *PrimaryResourcePointer;
  resourceCounter = ConfigurationDataPointer[9];
  systemStatus4 = systemStatus1 % (ulong long)*(uint *)(resourceCounter + 0x10);
  for (psystemStatus2 = *(ulong long **)(*(long long *)(resourceCounter + 8) + systemStatus4 * 8); psystemStatus2 != (ulong long *)0x0
      ; psystemStatus2 = (ulong long *)psystemStatus2[1]) {
    if (systemStatus1 == *psystemStatus2) goto LAB_180076feb;
  }
  PrimaryResourcePointer = *(long long **)(resourceCounter + 0x30);
  systemOperationFlags = (long long)(int)PrimaryResourcePointer[2] + 0xfU & 0xfffffffffffffff0;
  *(int *)(PrimaryResourcePointer + 2) = (int)systemOperationFlags + 0x10;
  psystemStatus2 = (ulong long *)(*PrimaryResourcePointer + systemOperationFlags);
  *psystemStatus2 = systemStatus1;
  psystemStatus2[1] = 0;
  FUN_18066c220(resourceCounter + 0x20,&uStackX_8,*(uint32_t *)(resourceCounter + 0x10),*(uint32_t *)(resourceCounter + 0x18),
                1);
  if ((char)uStackX_8 != '\0') {
    systemStatus4 = systemStatus1 % (ulong long)uStackX_8._4_4_;
    FUN_180083b20(resourceCounter,uStackX_8._4_4_);
  }
  psystemStatus2[1] = *(ulong long *)(*(long long *)(resourceCounter + 8) + systemStatus4 * 8);
  *(ulong long **)(*(long long *)(resourceCounter + 8) + systemStatus4 * 8) = psystemStatus2;
  *(long long *)(resourceCounter + 0x18) = *(long long *)(resourceCounter + 0x18) + 1;
LAB_180076feb:
  FUN_180080df0(&unsignedValue60);
  return systemValue;
}




// 函数: void FUN_180077020(long long *ResourceManagerPointer)
void FUN_180077020(long long *ResourceManagerPointer)

{
  void* *pointerToUnsigned1;
  void** SystemDataTable;
  
  pointerToUnsigned1 = (void* *)ResourceManagerPointer[1];
  for (HashEntryStatus = (void* *)*ResourceManagerPointer; HashEntryStatus != pointerToUnsigned1; HashEntryStatus = HashEntryStatus + 6) {
    *HashEntryStatus = &SystemGlobalDataReference;
    if (HashEntryStatus[1] != 0) {
        SystemCleanupFunction();
    }
    HashEntryStatus[1] = 0;
    *(uint32_t *)(HashEntryStatus + 3) = 0;
    *HashEntryStatus = &SystemMemoryAllocatorReference;
  }
  if (*ResourceManagerPointer != 0) {
      SystemCleanupFunction();
  }
  return;
}




ulong long FUN_180077040(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  byte isSystemActive;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  long long SystemTimeValue;
  long long localSystemFlags;
  
  if (*(long long *)(ResourceManagerPointer + 0x1b8) != 0) {
    localSystemFlags = 0xb8;
    localSystemPointer = SystemStatusFlagsPointer;
    do {
      localResourceOffset = *(long long *)(localSystemFlags + *(long long *)(ResourceManagerPointer + 0x1b8));
      if ((((localResourceOffset != 0) && (*(long long *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x328 + localSystemFlags) == 0)) &&
          ((*(uint *)(localResourceOffset + 0x328) & 0x20000000) == 0)) && (*(long long *)(localResourceOffset + 0x370) == 0)) {
        if (*(long long *)(localResourceOffset + 0x1d8) == 0) {
          FUN_18023b050(localResourceOffset,0);
          localSystemPointer = SystemStatusFlagsPointer;
          pointerToInteger1 = (int *)(*(long long *)(localSystemFlags + *(long long *)(ResourceManagerPointer + 0x1b8)) + 0x3a8);
          *pointerToInteger1 = *pointerToInteger1 + 1;
        }
        else if (localSystemPointer != 0) {
          *(long long *)(localResourceOffset + 0x340) = (long long)*(int *)(localSystemPointer + 0x224);
        }
      }
      localSystemFlags = localSystemFlags + 8;
    } while (localSystemFlags < 0x138);
  }
  isSystemActive = *(byte *)(ResourceManagerPointer + 0xf9);
  if (isSystemActive != 0) {
    if (*(long long *)(ResourceManagerPointer + 0x1d8) != 0) {
        SystemCleanupFunction();
    }
    *(void* *)(ResourceManagerPointer + 0x1d8) = 0;
    LOCK();
    isSystemActive = *(byte *)(ResourceManagerPointer + 0xf9);
    *(byte *)(ResourceManagerPointer + 0xf9) = 0;
    UNLOCK();
  }
  unsignedSystemValue4 = (ulong long)isSystemActive;
  if (*(long long *)(ResourceManagerPointer + 0x1e8) != 0) {
    FUN_180080060();
    unsignedSystemValue4 = *(ulong long *)(ResourceManagerPointer + 0x1f0);
    *(void* *)(ResourceManagerPointer + 0x1e8) = 0;
    if (unsignedSystemValue4 != 0) {
      *(byte *)(unsignedSystemValue4 + 0xfe) = *(byte *)(unsignedSystemValue4 + 0xfe) & 0xfb;
    }
  }
  return unsignedSystemValue4;
}





// 函数: void FUN_180077150(long long *ResourceManagerPointer)
void FUN_180077150(long long *ResourceManagerPointer)

{
  void* systemStatus;
  ulong long *HashEntryStatus;
  ulong long allocationContext;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  byte isThreadActive;
  uint8_t StackBuffer [32];
  ulong long *pEncryptionValue68;
  void* unsignedValue60;
  void* *memoryAllocationBuffer;
  ulong long *memoryAllocationEnd;
  ulong long EncryptionValue48;
  ulong long StackBuffer40 [2];
  void* unsignedValue30;
  char cStack_28;
  char cStack_27;
  char cStack_26;
  ulong long unsignedValue20;
  
  unsignedValue60 = 0xfffffffffffffffe;
  unsignedValue20 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer;
  systemStatus = *(void* *)(ResourceManagerPointer[0x37] + 0x1e0);
  memoryAllocationBuffer = &SystemMemoryTemplateE;
  memoryAllocationEnd = StackBuffer40;
  StackBuffer40[0] = StackBuffer40[0] & 0xffffffffffffff00;
  EncryptionValue48._0_4_ = 0x12;
  strcpy_s(StackBuffer40,0x20,&UNK_1809ffa98);
  allocationContext = FUN_180240430(systemStatus,&memoryAllocationBuffer,0);
  memoryAllocationBuffer = &SystemMemoryAllocatorReference;
  if (allocationContext != 0) {
    localSystemPointer = ResourceManagerPointer[0x37];
    if ((*(ulong long *)(localSystemPointer + 0x140) & allocationContext) != 0) {
      isThreadActive = *(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x20;
      pbufferBaseAddress = ResourceManagerPointer;
      if (isThreadActive == 0) {
        pbufferBaseAddress = (long long *)func_0x000180085de0(ResourceManagerPointer[0x36]);
      }
      if (((*(uint *)(pbufferBaseAddress + 0x20) & 0x8000000) == 0) && (isThreadActive != 0)) {
        pEncryptionValue68 = (ulong long *)ResourceManagerPointer;
        (**(code **)(*ResourceManagerPointer + 0x28))(ResourceManagerPointer);
        memoryAllocationBuffer = (void* *)0x0;
        memoryAllocationEnd = (ulong long *)0x0;
        pEncryptionValue68 = &EncryptionValue48;
        unsignedValue30 = 0;
        StackBuffer40[0] = 0;
        EncryptionValue48._0_4_ = (uint)EncryptionValue48 & 0xffffff00;
        FUN_18022f2e0(&memoryAllocationBuffer,ResourceManagerPointer,0);
        (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
        FUN_180237d00(&memoryAllocationBuffer);
        FUN_18022f390(&memoryAllocationBuffer);
        FUN_18022f410(&memoryAllocationBuffer);
        localSystemPointer = ResourceManagerPointer[0x37];
      }
      if ((*(ulong long *)(localSystemPointer + 0x140) & allocationContext) != 0) goto LAB_18007738d;
    }
    pbufferBaseAddress = ResourceManagerPointer;
    if ((*(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x20) == 0) {
      pbufferBaseAddress = (long long *)func_0x000180085de0(ResourceManagerPointer[0x36]);
    }
    if ((*(uint *)(pbufferBaseAddress + 0x20) & 0x8000000) != 0) {
      pEncryptionValue68 = (ulong long *)ResourceManagerPointer;
      (**(code **)(*ResourceManagerPointer + 0x28))(ResourceManagerPointer);
      memoryAllocationBuffer = (void* *)0x0;
      memoryAllocationEnd = (ulong long *)0x0;
      pEncryptionValue68 = &EncryptionValue48;
      unsignedValue30 = 0;
      StackBuffer40[0] = 0;
      EncryptionValue48._0_4_ = (uint)EncryptionValue48 & 0xffffff00;
      FUN_18022f2e0(&memoryAllocationBuffer,ResourceManagerPointer,0);
      (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
      FUN_180238950(&memoryAllocationBuffer);
      if (memoryAllocationEnd != (ulong long *)0x0) {
        if (cStack_26 != '\0') {
          FUN_180075b70(memoryAllocationBuffer);
        }
        FUN_18007f6a0(&EncryptionValue48);
        if (cStack_28 != '\0') {
          FUN_180079520(memoryAllocationBuffer);
        }
        if (cStack_27 != '\0') {
          FUN_180079520(memoryAllocationBuffer);
        }
        HashEntryStatus = memoryAllocationEnd;
        pEncryptionValue68 = memoryAllocationEnd;
        memoryAllocationEnd = (ulong long *)0x0;
        if (HashEntryStatus != (ulong long *)0x0) {
          (**(code **)(*HashEntryStatus + 0x38))();
        }
      }
      FUN_18022f410(&memoryAllocationBuffer);
    }
  }
LAB_18007738d:
    ValidateSystemChecksum(unsignedValue20 ^ (ulong long)StackBuffer);
}




void* FUN_180077420(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  uint *pointerToUnsigned1;
  long long *resourcePoolPointer;
  uint allocationContext;
  code *psystemStatusFlag;
  bool isMemoryReady;
  byte isThreadActive;
  char resourceStatusFlag;
  int systemCode;
  uint unsignedSystemValue9;
  long long allocationFlags;
  long long nextDataIndex1;
  long long nextDataIndex2;
  long long nextDataIndex3;
  ulong long systemStatus4;
  code *systemFunctionPointer5;
  bool isEntryAvailable;
  void* UnsignedStackFlag78;
  uint32_t processFlags70;
  uint32_t uStack_6c;
  void*2 EncryptionValue68;
  uint8_t uStack_66;
  uint32_t uStack_64;
  uint8_t unsignedValue60;
  void* processFlags58;
  long long lStack_50;
  void* EncryptionValue48;
  void* unsignedValue40;
  uint32_t uStack_38;
  void* unsignedValue30;
  
  nextDataIndex3 = ResourceManagerPointer;
  if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    nextDataIndex3 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x1b8);
  isThreadActive = *(byte *)(nextDataIndex2 + 0x38c);
  if (isThreadActive == 9) {
    isThreadActive = func_0x00018022d300();
    *(byte *)(nextDataIndex2 + 0x38c) = isThreadActive;
  }
  if ((*(long long *)(nextDataIndex3 + 0x1e0) == 0) ||
     (((nextDataIndex2 = (ulong long)isThreadActive * 0x18,
       *(char *)(*(long long *)(nextDataIndex3 + 0x1e0) + 0x15 + nextDataIndex2) != '\x03' &&
       (*(char *)(*(long long *)(nextDataIndex3 + 0x1e0) + 0x15 + nextDataIndex2) != '\x04')) &&
      (*(char *)(*(long long *)(nextDataIndex3 + 0x1e0) + nextDataIndex2 + 0x15) != '\x02')))) {
    *(int *)(ConfigurationDataPointer + 0x124e8) = *(int *)(ConfigurationDataPointer + 0x124e8) + 1;
  }
  else if (*(char *)(*(long long *)(nextDataIndex3 + 0x1e0) + nextDataIndex2 + 0x15) != '\x04') {
    UnsignedStackFlag78 = 0;
    processFlags70 = 0;
    uStack_6c = 0xffffffff;
    EncryptionValue68 = 1;
    uStack_66 = 0;
    uStack_64 = 0xffffffff;
    unsignedValue60 = 1;
    processFlags58 = 0;
    lStack_50 = 0;
    EncryptionValue48 = 0;
    unsignedValue40 = 0;
    uStack_38 = 3;
    unsignedValue30 = 0;
    systemCode = FUN_18022d470(*(void* *)(ResourceManagerPointer + 0x1b8),&UnsignedStackFlag78);
    if (systemCode < 1) {
      if (lStack_50 != 0) {
          SystemCleanupFunction();
      }
      isMemoryReady = false;
      if ((*(byte *)(ResourceManagerPointer + 0xfd) & 8) != 0) {
        nextDataIndex3 = 0xb8;
        systemFunctionPointer5 = (code *)&UNK_1802426a0;
        do {
          nextDataIndex2 = *(long long *)(nextDataIndex3 + *(long long *)(ResourceManagerPointer + 0x1b8));
          if (((nextDataIndex2 != 0) && (nextDataIndex1 = *(long long *)(nextDataIndex2 + 0x370), nextDataIndex1 != 0)) &&
             ((charBuffer = func_0x0001802434e0(), charBuffer != '\0' &&
              ((*(char *)(nextDataIndex1 + 0xde) != '\0' &&
               (isMemoryReady = true, (*(byte *)(ConfigurationDataPointer + 0x1bd8) & 0x20) != 0)))))) {
            psystemStatusFlag = *(code **)(**(long long **)(ConfigurationDataPointer + 0x3580) + 0xb8);
            if (psystemStatusFlag == systemFunctionPointer5) {
              nextDataIndex1 = (*(long long **)(ConfigurationDataPointer + 0x3580))[0xda];
            }
            else {
              nextDataIndex1 = (*psystemStatusFlag)();
            }
            pointerToUnsigned1 = (uint *)(nextDataIndex1 + 0x3f68);
            LOCK();
            allocationContext = *pointerToUnsigned1;
            *pointerToUnsigned1 = *pointerToUnsigned1 + 1;
            UNLOCK();
            unsignedSystemValue9 = allocationContext >> 10;
            systemStatus4 = (ulong long)unsignedSystemValue9;
            if (*(long long *)(nextDataIndex1 + 0x3f70 + (ulong long)unsignedSystemValue9 * 8) == 0) {
              allocationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
              resourcePoolPointer = (long long *)(nextDataIndex1 + 0x3f70 + systemStatus4 * 8);
              LOCK();
              isEntryAvailable = *resourcePoolPointer == 0;
              if (isEntryAvailable) {
                *resourcePoolPointer = allocationFlags;
              }
              UNLOCK();
              if (isEntryAvailable) {
                LOCK();
                *(uint8_t *)(systemStatus4 + 0x48 + (long long)pointerToUnsigned1) = 0;
                UNLOCK();
              }
              else {
                if (allocationFlags != 0) {
                    SystemCleanupFunction();
                }
                do {
                } while (*(char *)(systemStatus4 + 0x48 + (long long)pointerToUnsigned1) != '\0');
              }
            }
            else {
              do {
              } while (*(char *)(systemStatus4 + 0x48 + (long long)pointerToUnsigned1) != '\0');
            }
            *(long long *)
             (*(long long *)(nextDataIndex1 + 0x3f70 + systemStatus4 * 8) + (ulong long)(allocationContext + unsignedSystemValue9 * -0x400) * 8)
                 = nextDataIndex2;
            systemFunctionPointer5 = (code *)&UNK_1802426a0;
          }
          nextDataIndex3 = nextDataIndex3 + 8;
        } while (nextDataIndex3 < 0x138);
        if (isMemoryReady) {
          return 0;
        }
      }
      *(byte *)(ResourceManagerPointer + 0xfe) = *(byte *)(ResourceManagerPointer + 0xfe) | 4;
      return 1;
    }
    if (lStack_50 != 0) {
        SystemCleanupFunction();
    }
  }
  return 0;
}




// 函数: void FUN_180077710(long long ResourceManagerPointer)
void FUN_180077710(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  long long localResourceOffset;
  ulong long unsignedSystemValue4;
  
  HashEntryStatus = *(void* **)(ResourceManagerPointer + 0x28);
  if (HashEntryStatus == (void* *)0x0) {
    return;
  }
  systemValue4 = (ulong long)HashEntryStatus & 0xffffffffffc00000;
  if (systemValue4 != 0) {
    localResourceOffset = systemValue4 + 0x80 + ((long long)HashEntryStatus - systemValue4 >> 0x10) * 0x50;
    localResourceOffset = localResourceOffset - (ulong long)*(uint *)(localResourceOffset + 4);
    if ((*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList) && (*(char *)(localResourceOffset + 0xe) == '\0')) {
      *HashEntryStatus = *(void* *)(localResourceOffset + 0x20);
      *(void* **)(localResourceOffset + 0x20) = HashEntryStatus;
      pointerToInteger1 = (int *)(localResourceOffset + 0x18);
      *pointerToInteger1 = *pointerToInteger1 + -1;
      if (*pointerToInteger1 == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(unsignedSystemValue4,CONCAT71(0xff000000,*(void ***)(unsignedSystemValue4 + 0x70) == &ExceptionList),
                          HashEntryStatus,unsignedSystemValue4,0xfffffffffffffffe);
    }
  }
  return;
}




ulong long FUN_180077750(long long ResourceManagerPointer,uint *ConfigurationDataPointer,float *AdditionalParameter,long long ConfigurationFlag,
                       long long systemConfigurationParameter)

{
  float FloatVariable1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  uint hashValue;
  uint32_t unsignedSystemValue7;
  uint32_t unsignedSystemValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  char CharacterVariable21;
  byte isSystemActive2;
  uint32_t creationFlags3;
  void* creationFlags4;
  ulong long creationFlags5;
  void* *HashEntryStatus6;
  long long localSystemHandle7;
  long long localSystemHandle8;
  uint32_t *HashEntryStatus9;
  uint *HashNodePointer0;
  byte isOperationComplete1;
  char *pcharFlag2;
  int systemCounter3;
  ulong long allocationContext4;
  uint *HashNodePointer5;
  bool isOperationComplete6;
  uint32_t auStackX_8 [2];
  uint *puStackX_10;
  float *pfStackX_18;
  long long lStackX_20;
  uint32_t StackBuffer138 [2];
  ulong long uStack_130;
  void* *apuStack_128 [2];
  long long lStack_118;
  void* unsignedValue108;
  void* unsignedValue100;
  void* unsignedValueF8;
  void* uStack_f0;
  void* uStack_e8;
  void* uStack_e0;
  void* unsignedValueD8;
  void* uStack_d0;
  float fStack_c8;
  float fStack_c4;
  float fStack_c0;
  float fStack_bc;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  float fStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  float fStack_9c;
  float fStack_98;
  float fStack_94;
  float fStack_90;
  float fStack_8c;
  
  puStackX_10 = ConfigurationDataPointer;
  pfStackX_18 = AdditionalParameter;
  lStackX_20 = ConfigurationFlag;
  if (*(char *)(ResourceManagerPointer + 0xf9) == '\0') {
    creationFlags4 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,9);
    creationFlags4 = FUN_180084ea0(creationFlags4);
    *(void* *)(ResourceManagerPointer + 0x1d8) = creationFlags4;
    LOCK();
    *(uint8_t *)(ResourceManagerPointer + 0xf9) = 1;
    UNLOCK();
  }
  if ((char)*(byte *)(ResourceManagerPointer + 0xfd) < '\0') {
    localSystemHandle7 = *(long long *)(ResourceManagerPointer + 0x1b8);
    creationFlags4 = *(void* *)(localSystemHandle7 + 0x290);
    *(void* *)(ResourceManagerPointer + 0x2a8) = *(void* *)(localSystemHandle7 + 0x288);
    *(void* *)(ResourceManagerPointer + 0x2b0) = creationFlags4;
    creationFlags3 = *(uint32_t *)(localSystemHandle7 + 0x29c);
    unsignedSystemValue7 = *(uint32_t *)(localSystemHandle7 + 0x2a0);
    unsignedSystemValue8 = *(uint32_t *)(localSystemHandle7 + 0x2a4);
    *(uint32_t *)(ResourceManagerPointer + 0x2b8) = *(uint32_t *)(localSystemHandle7 + 0x298);
    *(uint32_t *)(ResourceManagerPointer + 700) = creationFlags3;
    *(uint32_t *)(ResourceManagerPointer + 0x2c0) = unsignedSystemValue7;
    *(uint32_t *)(ResourceManagerPointer + 0x2c4) = unsignedSystemValue8;
  }
  creationFlags5 = (ulong long)*(uint *)(ResourceManagerPointer + 0x270);
  if ((*ConfigurationDataPointer & *(uint *)(ResourceManagerPointer + 0x270)) == 0) goto FUN_180077ef9;
  isOperationComplete1 = *(byte *)(ResourceManagerPointer + 0xfd) & 0x20;
  localSystemHandle7 = ResourceManagerPointer;
  if (isOperationComplete1 == 0) {
    localSystemHandle7 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  if (*(int *)(localSystemHandle7 + 0x200) == 0) {
LAB_180077847:
    if ((*(byte *)(ResourceManagerPointer + 0x100) & 4) != 0) goto LAB_180077879;
    localSystemHandle7 = *(long long *)(ResourceManagerPointer + 0x1b8);
    creationFlags5 = 0;
    if (*(char *)(localSystemHandle7 + 0x38c) == '\t') {
      creationFlags5 = func_0x00018022d300();
      *(char *)(localSystemHandle7 + 0x38c) = (char)creationFlags5;
      if ((char)creationFlags5 == '\t') goto LAB_180077879;
    }
FUN_180077ef9:
    creationFlags5 = creationFlags5 & 0xffffffffffffff00;
  }
  else {
    localSystemHandle7 = ResourceManagerPointer;
    if (isOperationComplete1 == 0) {
      localSystemHandle7 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
    }
    if (*(int *)(localSystemHandle7 + 0x1fc) * 3 == 0) goto LAB_180077847;
LAB_180077879:
    charResult1 = func_0x0001800854e0(ResourceManagerPointer);
    if ((charResult1 == '\0') || (ConfigurationFlag == 0)) {
      FUN_18007b1e0(ResourceManagerPointer,0);
      if ((*(byte *)(ResourceManagerPointer + 0xfe) & 4) == 0) {
        creationFlags4 = FUN_180077420(ResourceManagerPointer,ConfigurationDataPointer);
        isOperationComplete1 = (char)creationFlags4 << 2;
        isSystemActive2 = isOperationComplete1 | *(byte *)(ResourceManagerPointer + 0xfe) & 0xfb;
        creationFlags5 = CONCAT71((int7)((ulong long)creationFlags4 >> 8),isSystemActive2);
        *(byte *)(ResourceManagerPointer + 0xfe) = isSystemActive2;
        if ((isOperationComplete1 & 4) == 0) goto FUN_180077ef9;
      }
      hashValue = *(uint *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x388);
      if (((hashValue >> 0x19 & 1) != 0) ||
         ((*(long long *)(ResourceManagerPointer + 600) != 0 && (0 < *(int *)(*(long long *)(ResourceManagerPointer + 600) + 0x1c)))
         )) {
        systemCounter3 = *(int *)(SystemStatusFlagsPointer + 0x224);
        HashEntryStatus6 = *(void* **)(ResourceManagerPointer + 600);
        if (HashEntryStatus6 == (void* *)0x0) {
          HashEntryStatus6 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,3);
          *(void* *)((long long)HashEntryStatus6 + 0x2c) = 0xffffffffffffffff;
          *(uint32_t *)(HashEntryStatus6 + 9) = 0xffffffff;
          *HashEntryStatus6 = 0;
          HashEntryStatus6[2] = 0;
          HashEntryStatus6[7] = 0;
          *(uint32_t *)(HashEntryStatus6 + 5) = 0xffffffff;
          *(uint32_t *)(HashEntryStatus6 + 4) = 0xffffffff;
          HashEntryStatus6[3] = 0;
          *(uint32_t *)(HashEntryStatus6 + 8) = 0;
          *(uint32_t *)(HashEntryStatus6 + 1) = 0;
          *(uint8_t *)((long long)HashEntryStatus6 + 0x44) = 0;
          *(uint8_t *)((long long)HashEntryStatus6 + 0x24) = 0;
          *(void* **)(ResourceManagerPointer + 600) = HashEntryStatus6;
        }
        AdditionalParameter = pfStackX_18;
        if (*(int *)(HashEntryStatus6 + 4) != systemCounter3) {
          *(int *)(HashEntryStatus6 + 4) = systemCounter3;
          FUN_180079270(ResourceManagerPointer,systemConfigurationParameter);
          AdditionalParameter = pfStackX_18;
          if (((byte)(hashValue >> 0x19) & 1) != 0) {
            if ((*(uint *)(ResourceManagerPointer + 0x100) & 0x800) != 0) {
              FUN_18007ee70(ResourceManagerPointer);
            }
            lStack_118 = SystemMemoryContext + 0x5868;
            HashNodePointer0 = (uint *)((long long)*(int *)(SystemMemoryContext + 0x6a78) * 0x908 + lStack_118);
            LOCK();
            hashValue = *HashNodePointer0;
            *HashNodePointer0 = *HashNodePointer0 + 1;
            UNLOCK();
            creationFlags5 = (ulong long)(hashValue >> 9);
            allocationContext4 = (ulong long)(hashValue >> 9);
            pcharFlag2 = (char *)((long long)HashNodePointer0 + allocationContext4 + 0x808);
            HashNodePointer5 = HashNodePointer0 + (creationFlags5 + 1) * 2;
            uStack_130 = creationFlags5;
            do {
              systemCounter3 = (int)allocationContext4;
              if (*(long long *)HashNodePointer5 == 0) {
                localSystemHandle7 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0xc000,0x25);
                LOCK();
                isOperationComplete6 = *(long long *)(HashNodePointer0 + (long long)systemCounter3 * 2 + 2) == 0;
                if (isOperationComplete6) {
                  *(long long *)(HashNodePointer0 + (long long)systemCounter3 * 2 + 2) = localSystemHandle7;
                }
                UNLOCK();
                if (isOperationComplete6) {
                  FUN_1800e94a0(HashNodePointer0,systemCounter3 << 9);
                  LOCK();
                  *(uint8_t *)((long long)HashNodePointer0 + (long long)systemCounter3 + 0x808) = 0;
                  UNLOCK();
                  creationFlags5 = uStack_130;
                }
                else {
                  if (localSystemHandle7 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                    creationFlags5 = uStack_130;
                  } while (*pcharFlag2 != '\0');
                }
              }
              else {
                do {
                } while (*pcharFlag2 != '\0');
              }
              pcharFlag2 = pcharFlag2 + 1;
              allocationContext4 = (ulong long)(systemCounter3 + 1);
              HashNodePointer5 = HashNodePointer5 + 2;
            } while ((long long)(pcharFlag2 + (-0x808 - (long long)HashNodePointer0)) <= (long long)creationFlags5);
            HashEntryStatus6 = (void* *)
                      (*(long long *)
                        ((long long)*(int *)(lStack_118 + 0x1210) * 0x908 + lStack_118 + 8 +
                        creationFlags5 * 8) + (ulong long)(hashValue - (hashValue & 0xfffffe00)) * 0x60);
            localSystemHandle7 = ResourceManagerPointer;
            apuStack_128[0] = HashEntryStatus6;
            if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
              localSystemHandle7 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
            }
            localSystemHandle8 = *(long long *)(ResourceManagerPointer + 0x1b8);
            isOperationComplete1 = *(byte *)(localSystemHandle8 + 0x38c);
            if (isOperationComplete1 == 9) {
              isOperationComplete1 = func_0x00018022d300();
              *(byte *)(localSystemHandle8 + 0x38c) = isOperationComplete1;
            }
            ConfigurationDataPointer = puStackX_10;
            localSystemHandle7 = *(long long *)(localSystemHandle7 + 0x1e0);
            *HashEntryStatus6 = *(void* *)(localSystemHandle7 + (ulong long)isOperationComplete1 * 0x18);
            HashEntryStatus6[1] = *(void* *)(localSystemHandle7 + 8 + (ulong long)isOperationComplete1 * 0x18);
            *(uint32_t *)(apuStack_128[0] + 2) =
                 *(uint32_t *)(*(long long *)(ResourceManagerPointer + 600) + 0x2c);
            *(uint32_t *)((long long)apuStack_128[0] + 0x14) =
                 *(uint32_t *)(*(long long *)(ResourceManagerPointer + 600) + 0x4c);
            *(int *)(apuStack_128[0] + 9) = (int)*(char *)(*(long long *)(ResourceManagerPointer + 600) + 0x44);
            if ((*(long long *)(ResourceManagerPointer + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x14) == 0)) {
              creationFlags3 = 0xffffffff;
            }
            else {
              creationFlags3 = *(uint32_t *)(ResourceManagerPointer + 0x108);
            }
            *(uint32_t *)(apuStack_128[0] + 3) = creationFlags3;
            if ((*(long long *)(ResourceManagerPointer + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x14) == 0)) {
              creationFlags3 = 0xffffffff;
            }
            else {
              creationFlags3 = *(uint32_t *)(ResourceManagerPointer + 0x10c);
            }
            *(uint32_t *)((long long)apuStack_128[0] + 0x1c) = creationFlags3;
            if ((*(long long *)(ResourceManagerPointer + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x14) == 0)) {
              creationFlags3 = 0xffffffff;
            }
            else {
              creationFlags3 = *(uint32_t *)(ResourceManagerPointer + 0x110);
            }
            *(uint32_t *)(apuStack_128[0] + 4) = creationFlags3;
            *(byte *)((long long)apuStack_128[0] + 0x4e) = *(byte *)(ResourceManagerPointer + 0xfe) >> 3 & 1;
            if (*(int *)(ResourceManagerPointer + 0x108) != -1) {
              HashEntryStatus9 = *(uint32_t **)(ResourceManagerPointer + 0x2d0);
              creationFlags3 = HashEntryStatus9[1];
              unsignedSystemValue7 = HashEntryStatus9[2];
              unsignedSystemValue8 = HashEntryStatus9[3];
              *(uint32_t *)(apuStack_128[0] + 5) = *HashEntryStatus9;
              *(uint32_t *)((long long)apuStack_128[0] + 0x2c) = creationFlags3;
              *(uint32_t *)(apuStack_128[0] + 6) = unsignedSystemValue7;
              *(uint32_t *)((long long)apuStack_128[0] + 0x34) = unsignedSystemValue8;
              creationFlags4 = *(void* *)(HashEntryStatus9 + 6);
              apuStack_128[0][7] = *(void* *)(HashEntryStatus9 + 4);
              apuStack_128[0][8] = creationFlags4;
            }
            *(uint8_t *)((long long)apuStack_128[0] + 0x4f) =
                 *(uint8_t *)(*(long long *)(ResourceManagerPointer + 600) + 0x24);
            localSystemHandle7 = *(long long *)(ResourceManagerPointer + 600);
            if (*(char *)(localSystemHandle7 + 0x24) != '\0') {
              creationFlags3 = *(uint32_t *)(ResourceManagerPointer + 0x2ac);
              unsignedSystemValue7 = *(uint32_t *)(ResourceManagerPointer + 0x2b0);
              unsignedSystemValue8 = *(uint32_t *)(ResourceManagerPointer + 0x2b4);
              *(uint32_t *)(apuStack_128[0] + 10) = *(uint32_t *)(ResourceManagerPointer + 0x2a8);
              *(uint32_t *)((long long)apuStack_128[0] + 0x54) = creationFlags3;
              *(uint32_t *)(apuStack_128[0] + 0xb) = unsignedSystemValue7;
              *(uint32_t *)((long long)apuStack_128[0] + 0x5c) = unsignedSystemValue8;
              localSystemHandle7 = *(long long *)(ResourceManagerPointer + 600);
            }
            *(bool *)((long long)apuStack_128[0] + 0x4c) = *(long long *)(localSystemHandle7 + 0x10) != 0;
            *(uint8_t *)((long long)apuStack_128[0] + 0x4d) = 1;
            if ((*(char *)(systemConfigurationParameter + 0xc) != '\0') ||
               (0 < *(int *)(*(long long *)(ResourceManagerPointer + 600) + 0x1c))) {
              *(uint8_t *)((long long)apuStack_128[0] + 0x4d) = 0;
            }
            if (*(uint **)(puStackX_10 + 10) == (uint *)0x0) {
              StackBuffer138[0] = 0xffffffff;
              HashEntryStatus9 = StackBuffer138;
              HashNodePointer5 = puStackX_10;
            }
            else {
              auStackX_8[0] = 0xffffffff;
              HashEntryStatus9 = auStackX_8;
              HashNodePointer5 = *(uint **)(puStackX_10 + 10);
            }
            FUN_180080e90(HashNodePointer5 + 0xce2,HashEntryStatus9,apuStack_128);
            AdditionalParameter = pfStackX_18;
            ConfigurationFlag = lStackX_20;
          }
        }
      }
    }
    if ((*(uint *)(ResourceManagerPointer + 0x100) & 0x4000000) != 0) {
      floatValue9 = *AdditionalParameter;
      FloatScaleFactor = AdditionalParameter[1];
      floatValue11 = AdditionalParameter[2];
      FloatRatioValue = AdditionalParameter[3];
      interpolationFactor1 = AdditionalParameter[4];
      interpolationFactor2 = AdditionalParameter[5];
      scaleResult1 = AdditionalParameter[6];
      interpolationFactor4 = AdditionalParameter[7];
      interpolationFactor5 = AdditionalParameter[8];
      magnitudeSquared1 = AdditionalParameter[9];
      floatValue19 = AdditionalParameter[10];
      floatValue20 = AdditionalParameter[0xb];
      floatValue1 = *(float *)(ResourceManagerPointer + 0x124);
      floatValue2 = *(float *)(ResourceManagerPointer + 0x120);
      floatValue3 = *(float *)(ResourceManagerPointer + 0x128);
      floatValue4 = *(float *)(ResourceManagerPointer + 0x134);
      floatValue5 = *(float *)(ResourceManagerPointer + 0x130);
      fStack_c8 = floatValue1 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue3 * interpolationFactor5;
      fStack_c4 = floatValue1 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue3 * magnitudeSquared1;
      fStack_c0 = floatValue1 * interpolationFactor3 + floatValue2 * floatValue11 + floatValue3 * floatValue19;
      fStack_bc = floatValue1 * interpolationFactor4 + floatValue2 * FloatRatioValue + floatValue3 * floatValue20;
      floatValue1 = *(float *)(ResourceManagerPointer + 0x138);
      floatValue2 = *(float *)(ResourceManagerPointer + 0x140);
      floatValue3 = *(float *)(ResourceManagerPointer + 0x144);
      fStack_b8 = floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5;
      fStack_b4 = floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
      fStack_b0 = floatValue4 * interpolationFactor3 + floatValue5 * floatValue11 + floatValue1 * floatValue19;
      fStack_ac = floatValue4 * interpolationFactor4 + floatValue5 * FloatRatioValue + floatValue1 * floatValue20;
      floatValue1 = *(float *)(ResourceManagerPointer + 0x148);
      floatValue4 = *(float *)(ResourceManagerPointer + 0x154);
      floatValue5 = *(float *)(ResourceManagerPointer + 0x150);
      fStack_a8 = floatValue3 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue1 * interpolationFactor5;
      fStack_a4 = floatValue3 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
      fStack_a0 = floatValue3 * interpolationFactor3 + floatValue2 * floatValue11 + floatValue1 * floatValue19;
      fStack_9c = floatValue3 * interpolationFactor4 + floatValue2 * FloatRatioValue + floatValue1 * floatValue20;
      floatValue1 = *(float *)(ResourceManagerPointer + 0x158);
      fStack_98 = floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5 + AdditionalParameter[0xc];
      fStack_94 = floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1 + AdditionalParameter[0xd];
      fStack_90 = floatValue4 * interpolationFactor3 + floatValue5 * floatValue11 + floatValue1 * floatValue19 + AdditionalParameter[0xe];
      fStack_8c = floatValue4 * interpolationFactor4 + floatValue5 * FloatRatioValue + floatValue1 * floatValue20 + AdditionalParameter[0xf];
      AdditionalParameter = &fStack_c8;
    }
    FUN_180085190(&unsignedValue108,ConfigurationDataPointer + 0xc,*(uint8_t *)(ResourceManagerPointer + 0xf7),AdditionalParameter);
    hashValue = ConfigurationDataPointer[0x6f6];
    systemCounter3 = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (((*(byte *)(ResourceManagerPointer + 0xfd) & 1) == 0) &&
       ((*(int *)(ResourceManagerPointer + 0x1d0) == systemCounter3 || (*(int *)(ResourceManagerPointer + 0x1d0) == systemCounter3 + -1)))) {
      isOperationComplete1 = 0;
    }
    else {
      isOperationComplete1 = 1;
    }
    *(byte *)(ResourceManagerPointer + 0xfd) = *(byte *)(ResourceManagerPointer + 0xfd) & 0xfe | isOperationComplete1;
    isSystemActive2 = (byte)hashValue & 0x20;
    if ((isSystemActive2 != 0) && (isOperationComplete1 != 0)) {
      *(void* *)(ResourceManagerPointer + 0x160) = unsignedValue108;
      *(void* *)(ResourceManagerPointer + 0x168) = unsignedValue100;
      *(void* *)(ResourceManagerPointer + 0x170) = unsignedValueF8;
      *(void* *)(ResourceManagerPointer + 0x178) = uStack_f0;
      *(void* *)(ResourceManagerPointer + 0x180) = uStack_e8;
      *(void* *)(ResourceManagerPointer + 0x188) = uStack_e0;
      *(void* *)(ResourceManagerPointer + 400) = unsignedValueD8;
      *(void* *)(ResourceManagerPointer + 0x198) = uStack_d0;
    }
    creationFlags5 = FUN_18024a290(ConfigurationDataPointer,ResourceManagerPointer,&unsignedValue108,ConfigurationFlag,systemConfigurationParameter);
    *(byte *)(ResourceManagerPointer + 0xfd) = *(byte *)(ResourceManagerPointer + 0xfd) & 0xfe;
    *(int *)(ResourceManagerPointer + 0x1d0) = systemCounter3;
    if (isSystemActive2 != 0) {
      *(void* *)(ResourceManagerPointer + 0x160) = unsignedValue108;
      *(void* *)(ResourceManagerPointer + 0x168) = unsignedValue100;
      *(void* *)(ResourceManagerPointer + 0x170) = unsignedValueF8;
      *(void* *)(ResourceManagerPointer + 0x178) = uStack_f0;
      *(void* *)(ResourceManagerPointer + 0x180) = uStack_e8;
      *(void* *)(ResourceManagerPointer + 0x188) = uStack_e0;
      *(void* *)(ResourceManagerPointer + 400) = unsignedValueD8;
      *(void* *)(ResourceManagerPointer + 0x198) = uStack_d0;
    }
  }
  return creationFlags5;
}





/**
 * @brief 系统资源管理和线程初始化函数
 * 
 * 该函数负责系统资源的分配、管理和线程初始化操作。
 * 主要功能包括：
 * - 系统内存池的分配和管理
 * - 线程对象的创建和初始化
 * - 系统资源状态的检查和更新
 * - 哈希节点的管理和同步
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_18007799c，现已重命名为SystemNoOperationA
 */
void SystemNoOperationA(void)

{
  uint systemStatus;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  float floatValue6;
  uint32_t unsignedSystemValue7;
  uint32_t unsignedSystemValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  void* creationFlags1;
  void* creationFlags2;
  void* creationFlags3;
  void* creationFlags4;
  void* creationFlags5;
  void* creationFlags6;
  void* creationFlags7;
  void* creationFlags8;
  byte isSystemActive9;
  byte isOperationComplete0;
  uint32_t allocationContext1;
  ulong long allocationContext2;
  long long localResourceOffset3;
  long long localResourceOffset4;
  uint32_t *HashNodePointer5;
  long long systemMemoryBlockPtr;
  uint *HashNodePointer6;
  char *pcharFlag7;
  void* *HashNodePointer8;
  float *pfloatValue39;
  int systemAllocationOffsetD;
  int systemIndex0;
  ulong long unsignedSystemValue41;
  uint *punsignedSystemValue42;
  bool in_ZF;
  bool isResourceAvailable3;
  uint32_t InputStackParameter30;
  ulong long InputStackParameter38;
  void* *InputStackParameter40;
  long long InputStackParameter50;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float FloatStackArray[16];
  uint32_t ResourceFlags[8];
  uint32_t ThreadCreationFlags;
  long long ResourceOffset;
  float *FloatParameterArray;
  void* ThreadParameter;
  long long SystemMemoryOffset;
  
  if (!in_ZF) {
    FUN_18007ee70();
  }
  InputStackParameter50 = SystemMemoryContext + 0x5868;
  HashNodePointer6 = (uint *)((long long)*(int *)(SystemMemoryContext + 0x6a78) * 0x908 + InputStackParameter50);
  LOCK();
  systemStatus = *HashNodePointer6;
  *HashNodePointer6 = *HashNodePointer6 + systemAllocationOffsetD;
  UNLOCK();
  allocationContext2 = (ulong long)(systemStatus >> 9);
  unsignedSystemValue41 = (ulong long)(systemStatus >> 9);
  pcharFlag7 = (char *)((long long)HashNodePointer6 + unsignedSystemValue41 + 0x808);
  punsignedSystemValue42 = HashNodePointer6 + (allocationContext2 + 1) * 2;
  InputStackParameter38 = allocationContext2;
  do {
    systemIndex0 = (int)unsignedSystemValue41;
    if (*(long long *)punsignedSystemValue42 == 0) {
      localResourceOffset3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0xc000,0x25);
      LOCK();
      isResourceAvailable3 = *(long long *)(HashNodePointer6 + (long long)systemIndex0 * 2 + 2) == 0;
      if (isResourceAvailable3) {
        *(long long *)(HashNodePointer6 + (long long)systemIndex0 * 2 + 2) = localResourceOffset3;
      }
      UNLOCK();
      if (isResourceAvailable3) {
        FUN_1800e94a0(HashNodePointer6,systemIndex0 << 9);
        LOCK();
        *(uint8_t *)((long long)HashNodePointer6 + (long long)systemIndex0 + 0x808) = 0;
        UNLOCK();
        allocationContext2 = InputStackParameter38;
      }
      else {
        if (localResourceOffset3 != 0) {
            SystemCleanupFunction();
        }
        do {
          allocationContext2 = InputStackParameter38;
        } while (*pcharFlag7 != '\0');
      }
    }
    else {
      do {
      } while (*pcharFlag7 != '\0');
    }
    pcharFlag7 = pcharFlag7 + 1;
    unsignedSystemValue41 = (ulong long)(systemIndex0 + 1);
    punsignedSystemValue42 = punsignedSystemValue42 + 2;
  } while ((long long)(pcharFlag7 + (-0x808 - (long long)HashNodePointer6)) <= (long long)allocationContext2);
  HashNodePointer8 = (void* *)
            (*(long long *)
              ((long long)*(int *)(InputStackParameter50 + 0x1210) * 0x908 + InputStackParameter50 + 8 +
              allocationContext2 * 8) + (ulong long)(systemStatus - (systemStatus & 0xfffffe00)) * 0x60);
  localResourceOffset3 = systemMemoryBlockPtr;
  InputStackParameter40 = HashNodePointer8;
  if ((*(byte *)(systemMemoryBlockPtr + 0xfd) & 0x20) == 0) {
    localResourceOffset3 = func_0x000180085de0(*(void* *)(systemMemoryBlockPtr + 0x1b0));
  }
  localResourceOffset4 = *(long long *)(systemMemoryBlockPtr + 0x1b8);
  isSystemActive9 = *(byte *)(localResourceOffset4 + 0x38c);
  if (isSystemActive9 == 9) {
    isSystemActive9 = func_0x00018022d300();
    *(byte *)(localResourceOffset4 + 0x38c) = isSystemActive9;
  }
  localResourceOffset4 = ResourceOffset;
  localResourceOffset3 = *(long long *)(localResourceOffset3 + 0x1e0);
  *HashNodePointer8 = *(void* *)(localResourceOffset3 + (ulong long)isSystemActive9 * 0x18);
  HashNodePointer8[1] = *(void* *)(localResourceOffset3 + 8 + (ulong long)isSystemActive9 * 0x18);
  *(uint32_t *)(InputStackParameter40 + 2) = *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x2c);
  *(uint32_t *)((long long)InputStackParameter40 + 0x14) =
       *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x4c);
  *(int *)(InputStackParameter40 + 9) = (int)*(char *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x44);
  if ((*(long long *)(systemMemoryBlockPtr + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) == 0)) {
    allocationContext1 = 0xffffffff;
  }
  else {
    allocationContext1 = *(uint32_t *)(systemMemoryBlockPtr + 0x108);
  }
  *(uint32_t *)(InputStackParameter40 + 3) = allocationContext1;
  if ((*(long long *)(systemMemoryBlockPtr + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) == 0)) {
    allocationContext1 = 0xffffffff;
  }
  else {
    allocationContext1 = *(uint32_t *)(systemMemoryBlockPtr + 0x10c);
  }
  *(uint32_t *)((long long)InputStackParameter40 + 0x1c) = allocationContext1;
  if ((*(long long *)(systemMemoryBlockPtr + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) == 0)) {
    allocationContext1 = 0xffffffff;
  }
  else {
    allocationContext1 = *(uint32_t *)(systemMemoryBlockPtr + 0x110);
  }
  *(uint32_t *)(InputStackParameter40 + 4) = allocationContext1;
  *(byte *)((long long)InputStackParameter40 + 0x4e) = *(byte *)(systemMemoryBlockPtr + 0xfe) >> 3 & 1;
  if (*(int *)(systemMemoryBlockPtr + 0x108) != -1) {
    HashNodePointer5 = *(uint32_t **)(systemMemoryBlockPtr + 0x2d0);
    allocationContext1 = HashNodePointer5[1];
    unsignedSystemValue7 = HashNodePointer5[2];
    unsignedSystemValue8 = HashNodePointer5[3];
    *(uint32_t *)(InputStackParameter40 + 5) = *HashNodePointer5;
    *(uint32_t *)((long long)InputStackParameter40 + 0x2c) = allocationContext1;
    *(uint32_t *)(InputStackParameter40 + 6) = unsignedSystemValue7;
    *(uint32_t *)((long long)InputStackParameter40 + 0x34) = unsignedSystemValue8;
    creationFlags1 = *(void* *)(HashNodePointer5 + 6);
    InputStackParameter40[7] = *(void* *)(HashNodePointer5 + 4);
    InputStackParameter40[8] = creationFlags1;
  }
  *(uint8_t *)((long long)InputStackParameter40 + 0x4f) =
       *(uint8_t *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x24);
  localResourceOffset3 = *(long long *)(systemMemoryBlockPtr + 600);
  if (*(char *)(localResourceOffset3 + 0x24) != '\0') {
    allocationContext1 = *(uint32_t *)(systemMemoryBlockPtr + 0x2ac);
    unsignedSystemValue7 = *(uint32_t *)(systemMemoryBlockPtr + 0x2b0);
    unsignedSystemValue8 = *(uint32_t *)(systemMemoryBlockPtr + 0x2b4);
    *(uint32_t *)(InputStackParameter40 + 10) = *(uint32_t *)(systemMemoryBlockPtr + 0x2a8);
    *(uint32_t *)((long long)InputStackParameter40 + 0x54) = allocationContext1;
    *(uint32_t *)(InputStackParameter40 + 0xb) = unsignedSystemValue7;
    *(uint32_t *)((long long)InputStackParameter40 + 0x5c) = unsignedSystemValue8;
    localResourceOffset3 = *(long long *)(systemMemoryBlockPtr + 600);
  }
  *(bool *)((long long)InputStackParameter40 + 0x4c) = *(long long *)(localResourceOffset3 + 0x10) != 0;
  *(uint8_t *)((long long)InputStackParameter40 + 0x4d) = 1;
  if ((*(char *)(SystemMemoryOffset + 0xc) != '\0') ||
     (0 < *(int *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x1c))) {
    *(uint8_t *)((long long)InputStackParameter40 + 0x4d) = 0;
  }
  if (*(long long *)(ResourceOffset + 0x28) == 0) {
    InputStackParameter30 = 0xffffffff;
    HashNodePointer5 = &stack0x00000030;
    localResourceOffset3 = ResourceOffset;
  }
  else {
    ThreadCreationFlags = 0xffffffff;
    HashNodePointer5 = &stack0x00000170;
    localResourceOffset3 = *(long long *)(ResourceOffset + 0x28);
  }
  FUN_180080e90(localResourceOffset3 + 0x3388,HashNodePointer5,&stack0x00000040);
  pfloatValue39 = FloatParameterArray;
  if ((*(uint *)(systemMemoryBlockPtr + 0x100) & 0x4000000) != 0) {
    floatValue9 = *in_stack_00000180;
    FloatScaleFactor = in_stack_00000180[1];
    floatValue11 = in_stack_00000180[2];
    FloatRatioValue = in_stack_00000180[3];
    interpolationFactor1 = in_stack_00000180[4];
    interpolationFactor2 = in_stack_00000180[5];
    scaleResult1 = in_stack_00000180[6];
    interpolationFactor4 = in_stack_00000180[7];
    interpolationFactor5 = in_stack_00000180[8];
    magnitudeSquared1 = in_stack_00000180[9];
    floatValue19 = in_stack_00000180[10];
    floatValue20 = in_stack_00000180[0xb];
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x124);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x120);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x128);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x134);
    floatValue6 = *(float *)(systemMemoryBlockPtr + 0x130);
    fStack00000000000000a0 = floatValue2 * interpolationFactor1 + floatValue3 * floatValue9 + floatValue4 * interpolationFactor5;
    fStack00000000000000a4 = floatValue2 * interpolationFactor2 + floatValue3 * FloatScaleFactor + floatValue4 * magnitudeSquared1;
    fStack00000000000000a8 = floatValue2 * interpolationFactor3 + floatValue3 * floatValue11 + floatValue4 * floatValue19;
    fStack00000000000000ac = floatValue2 * interpolationFactor4 + floatValue3 * FloatRatioValue + floatValue4 * floatValue20;
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x138);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x140);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x144);
    fStack00000000000000b0 = floatValue5 * interpolationFactor1 + floatValue6 * floatValue9 + floatValue2 * interpolationFactor5;
    fStack00000000000000b4 = floatValue5 * interpolationFactor2 + floatValue6 * FloatScaleFactor + floatValue2 * magnitudeSquared1;
    fStack00000000000000b8 = floatValue5 * interpolationFactor3 + floatValue6 * floatValue11 + floatValue2 * floatValue19;
    fStack00000000000000bc = floatValue5 * interpolationFactor4 + floatValue6 * FloatRatioValue + floatValue2 * floatValue20;
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x148);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x154);
    floatValue6 = *(float *)(systemMemoryBlockPtr + 0x150);
    fStack00000000000000c0 = floatValue4 * interpolationFactor1 + floatValue3 * floatValue9 + floatValue2 * interpolationFactor5;
    fStack00000000000000c4 = floatValue4 * interpolationFactor2 + floatValue3 * FloatScaleFactor + floatValue2 * magnitudeSquared1;
    fStack00000000000000c8 = floatValue4 * interpolationFactor3 + floatValue3 * floatValue11 + floatValue2 * floatValue19;
    fStack00000000000000cc = floatValue4 * interpolationFactor4 + floatValue3 * FloatRatioValue + floatValue2 * floatValue20;
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x158);
    fStack00000000000000d0 =
         floatValue5 * interpolationFactor1 + floatValue6 * floatValue9 + floatValue2 * interpolationFactor5 + in_stack_00000180[0xc];
    fStack00000000000000d4 =
         floatValue5 * interpolationFactor2 + floatValue6 * FloatScaleFactor + floatValue2 * magnitudeSquared1 + in_stack_00000180[0xd];
    fStack00000000000000d8 =
         floatValue5 * interpolationFactor3 + floatValue6 * floatValue11 + floatValue2 * floatValue19 + in_stack_00000180[0xe];
    fStack00000000000000dc =
         floatValue5 * interpolationFactor4 + floatValue6 * FloatRatioValue + floatValue2 * floatValue20 + in_stack_00000180[0xf];
    pfloatValue39 = &stack0x000000a0;
  }
  FUN_180085190(&stack0x00000060,localResourceOffset4 + 0x30,*(uint8_t *)(systemMemoryBlockPtr + 0xf7),pfloatValue39);
  creationFlags8 = ThreadCreationParameter;
  creationFlags7 = InputStackParameter90;
  creationFlags6 = InputStackParameter88;
  creationFlags5 = InputStackParameter80;
  creationFlags4 = InputStackParameter78;
  creationFlags3 = InputStackParameter70;
  creationFlags2 = InputStackParameter68;
  creationFlags1 = InputStackParameter60;
  isSystemActive9 = *(byte *)(localResourceOffset4 + 0x1bd8);
  systemIndex0 = *(int *)(SystemStatusFlagsPointer + 0x224);
  if (((*(byte *)(systemMemoryBlockPtr + 0xfd) & 1) == 0) &&
     ((*(int *)(systemMemoryBlockPtr + 0x1d0) == systemIndex0 || (*(int *)(systemMemoryBlockPtr + 0x1d0) == systemIndex0 + -1)))) {
    isOperationComplete0 = 0;
  }
  else {
    isOperationComplete0 = 1;
  }
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe | isOperationComplete0;
  isSystemActive9 = isSystemActive9 & 0x20;
  if ((isSystemActive9 != 0) && (isOperationComplete0 != 0)) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = InputStackParameter60;
    *(void* *)(systemMemoryBlockPtr + 0x168) = InputStackParameter68;
    *(void* *)(systemMemoryBlockPtr + 0x170) = InputStackParameter70;
    *(void* *)(systemMemoryBlockPtr + 0x178) = InputStackParameter78;
    *(void* *)(systemMemoryBlockPtr + 0x180) = InputStackParameter80;
    *(void* *)(systemMemoryBlockPtr + 0x188) = InputStackParameter88;
    *(void* *)(systemMemoryBlockPtr + 400) = InputStackParameter90;
    *(void* *)(systemMemoryBlockPtr + 0x198) = ThreadCreationParameter;
  }
  FUN_18024a290(localResourceOffset4);
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe;
  *(int *)(systemMemoryBlockPtr + 0x1d0) = systemIndex0;
  if (isSystemActive9 != 0) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = creationFlags1;
    *(void* *)(systemMemoryBlockPtr + 0x168) = creationFlags2;
    *(void* *)(systemMemoryBlockPtr + 0x170) = creationFlags3;
    *(void* *)(systemMemoryBlockPtr + 0x178) = creationFlags4;
    *(void* *)(systemMemoryBlockPtr + 0x180) = creationFlags5;
    *(void* *)(systemMemoryBlockPtr + 0x188) = creationFlags6;
    *(void* *)(systemMemoryBlockPtr + 400) = creationFlags7;
    *(void* *)(systemMemoryBlockPtr + 0x198) = creationFlags8;
  }
  return;
}





// 函数: void FUN_180077ad8(void)
void FUN_180077ad8(void)

{
  float FloatVariable1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  int systemFlag;
  uint32_t unsignedSystemValue7;
  uint32_t unsignedSystemValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  void* creationFlags1;
  void* creationFlags2;
  void* creationFlags3;
  void* creationFlags4;
  void* creationFlags5;
  void* creationFlags6;
  void* creationFlags7;
  void* creationFlags8;
  long long localSystemHandle9;
  byte isOperationComplete0;
  byte isOperationComplete1;
  uint32_t allocationContext2;
  long long localResourceOffset3;
  uint32_t *HashNodePointer4;
  long long systemMemoryBlockPtr;
  void* *systemDataIndexPtr;
  long long localResourceOffset5;
  float *pfloatValue36;
  uint32_t InputStackParameter30;
  long long InputStackParameter40;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  uint32_t in_stack_000000f0;
  uint32_t in_stack_000000f8;
  uint32_t in_stack_00000100;
  uint32_t in_stack_00000108;
  uint32_t in_stack_00000110;
  uint32_t in_stack_00000118;
  uint32_t in_stack_00000170;
  long long in_stack_00000178;
  float *in_stack_00000180;
  void* in_stack_00000188;
  long long in_stack_00000190;
  
  localResourceOffset3 = *(long long *)(systemMemoryBlockPtr + 0x1b8);
  isOperationComplete0 = *(byte *)(localResourceOffset3 + 0x38c);
  localResourceOffset5 = systemMemoryBlockPtr;
  if (isOperationComplete0 == 9) {
    isOperationComplete0 = func_0x00018022d300();
    *(byte *)(localResourceOffset3 + 0x38c) = isOperationComplete0;
  }
  localSystemHandle9 = in_stack_00000178;
  localResourceOffset3 = *(long long *)(localResourceOffset5 + 0x1e0);
  *systemDataIndexPtr = *(void* *)(localResourceOffset3 + (ulong long)isOperationComplete0 * 0x18);
  systemDataIndexPtr[1] = *(void* *)(localResourceOffset3 + 8 + (ulong long)isOperationComplete0 * 0x18);
  *(uint32_t *)(InputStackParameter40 + 0x10) = *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x2c)
  ;
  *(uint32_t *)(InputStackParameter40 + 0x14) = *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x4c)
  ;
  *(int *)(InputStackParameter40 + 0x48) = (int)*(char *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x44);
  if ((*(long long *)(systemMemoryBlockPtr + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) == 0)) {
    allocationContext2 = 0xffffffff;
  }
  else {
    allocationContext2 = *(uint32_t *)(systemMemoryBlockPtr + 0x108);
  }
  *(uint32_t *)(InputStackParameter40 + 0x18) = allocationContext2;
  if ((*(long long *)(systemMemoryBlockPtr + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) == 0)) {
    allocationContext2 = 0xffffffff;
  }
  else {
    allocationContext2 = *(uint32_t *)(systemMemoryBlockPtr + 0x10c);
  }
  *(uint32_t *)(InputStackParameter40 + 0x1c) = allocationContext2;
  if ((*(long long *)(systemMemoryBlockPtr + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) == 0)) {
    allocationContext2 = 0xffffffff;
  }
  else {
    allocationContext2 = *(uint32_t *)(systemMemoryBlockPtr + 0x110);
  }
  *(uint32_t *)(InputStackParameter40 + 0x20) = allocationContext2;
  *(byte *)(InputStackParameter40 + 0x4e) = *(byte *)(systemMemoryBlockPtr + 0xfe) >> 3 & 1;
  if (*(int *)(systemMemoryBlockPtr + 0x108) != -1) {
    HashNodePointer4 = *(uint32_t **)(systemMemoryBlockPtr + 0x2d0);
    allocationContext2 = HashNodePointer4[1];
    unsignedSystemValue7 = HashNodePointer4[2];
    unsignedSystemValue8 = HashNodePointer4[3];
    *(uint32_t *)(InputStackParameter40 + 0x28) = *HashNodePointer4;
    *(uint32_t *)(InputStackParameter40 + 0x2c) = allocationContext2;
    *(uint32_t *)(InputStackParameter40 + 0x30) = unsignedSystemValue7;
    *(uint32_t *)(InputStackParameter40 + 0x34) = unsignedSystemValue8;
    creationFlags1 = *(void* *)(HashNodePointer4 + 6);
    *(void* *)(InputStackParameter40 + 0x38) = *(void* *)(HashNodePointer4 + 4);
    *(void* *)(InputStackParameter40 + 0x40) = creationFlags1;
  }
  *(uint8_t *)(InputStackParameter40 + 0x4f) = *(uint8_t *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x24)
  ;
  localResourceOffset3 = *(long long *)(systemMemoryBlockPtr + 600);
  if (*(char *)(localResourceOffset3 + 0x24) != '\0') {
    allocationContext2 = *(uint32_t *)(systemMemoryBlockPtr + 0x2ac);
    unsignedSystemValue7 = *(uint32_t *)(systemMemoryBlockPtr + 0x2b0);
    unsignedSystemValue8 = *(uint32_t *)(systemMemoryBlockPtr + 0x2b4);
    *(uint32_t *)(InputStackParameter40 + 0x50) = *(uint32_t *)(systemMemoryBlockPtr + 0x2a8);
    *(uint32_t *)(InputStackParameter40 + 0x54) = allocationContext2;
    *(uint32_t *)(InputStackParameter40 + 0x58) = unsignedSystemValue7;
    *(uint32_t *)(InputStackParameter40 + 0x5c) = unsignedSystemValue8;
    localResourceOffset3 = *(long long *)(systemMemoryBlockPtr + 600);
  }
  *(bool *)(InputStackParameter40 + 0x4c) = *(long long *)(localResourceOffset3 + 0x10) != 0;
  *(uint8_t *)(InputStackParameter40 + 0x4d) = 1;
  if ((*(char *)(SystemMemoryOffset + 0xc) != '\0') ||
     (0 < *(int *)(*(long long *)(systemMemoryBlockPtr + 600) + 0x1c))) {
    *(uint8_t *)(InputStackParameter40 + 0x4d) = 0;
  }
  if (*(long long *)(ResourceOffset + 0x28) == 0) {
    InputStackParameter30 = 0xffffffff;
    HashNodePointer4 = &stack0x00000030;
    localResourceOffset3 = ResourceOffset;
  }
  else {
    ThreadCreationFlags = 0xffffffff;
    HashNodePointer4 = &stack0x00000170;
    localResourceOffset3 = *(long long *)(ResourceOffset + 0x28);
  }
  FUN_180080e90(localResourceOffset3 + 0x3388,HashNodePointer4,&stack0x00000040);
  pfloatValue36 = in_stack_00000180;
  if ((*(uint *)(systemMemoryBlockPtr + 0x100) & 0x4000000) != 0) {
    floatValue9 = *in_stack_00000180;
    FloatScaleFactor = in_stack_00000180[1];
    floatValue11 = in_stack_00000180[2];
    FloatRatioValue = in_stack_00000180[3];
    interpolationFactor1 = in_stack_00000180[4];
    interpolationFactor2 = in_stack_00000180[5];
    scaleResult1 = in_stack_00000180[6];
    interpolationFactor4 = in_stack_00000180[7];
    interpolationFactor5 = in_stack_00000180[8];
    magnitudeSquared1 = in_stack_00000180[9];
    floatValue19 = in_stack_00000180[10];
    floatValue20 = in_stack_00000180[0xb];
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x124);
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x120);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x128);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x134);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x130);
    fStack00000000000000a0 = floatValue1 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue3 * interpolationFactor5;
    fStack00000000000000a4 = floatValue1 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue3 * magnitudeSquared1;
    fStack00000000000000a8 = floatValue1 * interpolationFactor3 + floatValue2 * floatValue11 + floatValue3 * floatValue19;
    fStack00000000000000ac = floatValue1 * interpolationFactor4 + floatValue2 * FloatRatioValue + floatValue3 * floatValue20;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x138);
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x140);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x144);
    fStack00000000000000b0 = floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5;
    fStack00000000000000b4 = floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
    fStack00000000000000b8 = floatValue4 * interpolationFactor3 + floatValue5 * floatValue11 + floatValue1 * floatValue19;
    fStack00000000000000bc = floatValue4 * interpolationFactor4 + floatValue5 * FloatRatioValue + floatValue1 * floatValue20;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x148);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x154);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x150);
    fStack00000000000000c0 = floatValue3 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue1 * interpolationFactor5;
    fStack00000000000000c4 = floatValue3 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
    fStack00000000000000c8 = floatValue3 * interpolationFactor3 + floatValue2 * floatValue11 + floatValue1 * floatValue19;
    fStack00000000000000cc = floatValue3 * interpolationFactor4 + floatValue2 * FloatRatioValue + floatValue1 * floatValue20;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x158);
    fStack00000000000000d0 =
         floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5 + in_stack_00000180[0xc];
    fStack00000000000000d4 =
         floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1 + in_stack_00000180[0xd];
    fStack00000000000000d8 =
         floatValue4 * interpolationFactor3 + floatValue5 * floatValue11 + floatValue1 * floatValue19 + in_stack_00000180[0xe];
    fStack00000000000000dc =
         floatValue4 * interpolationFactor4 + floatValue5 * FloatRatioValue + floatValue1 * floatValue20 + in_stack_00000180[0xf];
    pfloatValue36 = &stack0x000000a0;
  }
  FUN_180085190(&stack0x00000060,localSystemHandle9 + 0x30,*(uint8_t *)(systemMemoryBlockPtr + 0xf7),pfloatValue36);
  creationFlags8 = ThreadCreationParameter;
  creationFlags7 = InputStackParameter90;
  creationFlags6 = InputStackParameter88;
  creationFlags5 = InputStackParameter80;
  creationFlags4 = InputStackParameter78;
  creationFlags3 = InputStackParameter70;
  creationFlags2 = InputStackParameter68;
  creationFlags1 = InputStackParameter60;
  isOperationComplete0 = *(byte *)(localSystemHandle9 + 0x1bd8);
  systemFlag = *(int *)(SystemStatusFlagsPointer + 0x224);
  if (((*(byte *)(systemMemoryBlockPtr + 0xfd) & 1) == 0) &&
     ((*(int *)(systemMemoryBlockPtr + 0x1d0) == systemFlag || (*(int *)(systemMemoryBlockPtr + 0x1d0) == systemFlag + -1)))) {
    isOperationComplete1 = 0;
  }
  else {
    isOperationComplete1 = 1;
  }
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe | isOperationComplete1;
  isOperationComplete0 = isOperationComplete0 & 0x20;
  if ((isOperationComplete0 != 0) && (isOperationComplete1 != 0)) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = InputStackParameter60;
    *(void* *)(systemMemoryBlockPtr + 0x168) = InputStackParameter68;
    *(void* *)(systemMemoryBlockPtr + 0x170) = InputStackParameter70;
    *(void* *)(systemMemoryBlockPtr + 0x178) = InputStackParameter78;
    *(void* *)(systemMemoryBlockPtr + 0x180) = InputStackParameter80;
    *(void* *)(systemMemoryBlockPtr + 0x188) = InputStackParameter88;
    *(void* *)(systemMemoryBlockPtr + 400) = InputStackParameter90;
    *(void* *)(systemMemoryBlockPtr + 0x198) = ThreadCreationParameter;
  }
  FUN_18024a290(localSystemHandle9);
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe;
  *(int *)(systemMemoryBlockPtr + 0x1d0) = systemFlag;
  if (isOperationComplete0 != 0) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = creationFlags1;
    *(void* *)(systemMemoryBlockPtr + 0x168) = creationFlags2;
    *(void* *)(systemMemoryBlockPtr + 0x170) = creationFlags3;
    *(void* *)(systemMemoryBlockPtr + 0x178) = creationFlags4;
    *(void* *)(systemMemoryBlockPtr + 0x180) = creationFlags5;
    *(void* *)(systemMemoryBlockPtr + 0x188) = creationFlags6;
    *(void* *)(systemMemoryBlockPtr + 400) = creationFlags7;
    *(void* *)(systemMemoryBlockPtr + 0x198) = creationFlags8;
  }
  return;
}





// 函数: void FUN_180077c96(void)
void FUN_180077c96(void)

{
  float FloatVariable1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  int systemFlag;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  void* systemStatus9;
  void* creationFlags0;
  void* creationFlags1;
  void* creationFlags2;
  void* creationFlags3;
  void* creationFlags4;
  void* creationFlags5;
  void* creationFlags6;
  byte isSystemActive7;
  long long systemMemoryBlockPtr;
  byte isSystemActive8;
  float *systemStringIteratorPtr;
  long long unaff_R13;
  bool in_ZF;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  
  if (!in_ZF) {
    floatValue7 = *systemStringIteratorPtr;
    floatValue8 = systemStringIteratorPtr[1];
    floatValue9 = systemStringIteratorPtr[2];
    FloatScaleFactor = systemStringIteratorPtr[3];
    floatValue11 = systemStringIteratorPtr[4];
    FloatRatioValue = systemStringIteratorPtr[5];
    interpolationFactor1 = systemStringIteratorPtr[6];
    interpolationFactor2 = systemStringIteratorPtr[7];
    scaleResult1 = systemStringIteratorPtr[8];
    interpolationFactor4 = systemStringIteratorPtr[9];
    interpolationFactor5 = systemStringIteratorPtr[10];
    magnitudeSquared1 = systemStringIteratorPtr[0xb];
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x124);
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x120);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x128);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x134);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x130);
    fStack00000000000000a0 = floatValue1 * floatValue11 + floatValue2 * floatValue7 + floatValue3 * interpolationFactor3;
    fStack00000000000000a4 = floatValue1 * FloatRatioValue + floatValue2 * floatValue8 + floatValue3 * interpolationFactor4;
    fStack00000000000000a8 = floatValue1 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue3 * interpolationFactor5;
    fStack00000000000000ac = floatValue1 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue3 * magnitudeSquared1;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x138);
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x140);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x144);
    fStack00000000000000b0 = floatValue4 * floatValue11 + floatValue5 * floatValue7 + floatValue1 * interpolationFactor3;
    fStack00000000000000b4 = floatValue4 * FloatRatioValue + floatValue5 * floatValue8 + floatValue1 * interpolationFactor4;
    fStack00000000000000b8 = floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5;
    fStack00000000000000bc = floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x148);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x154);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x150);
    fStack00000000000000c0 = floatValue3 * floatValue11 + floatValue2 * floatValue7 + floatValue1 * interpolationFactor3;
    fStack00000000000000c4 = floatValue3 * FloatRatioValue + floatValue2 * floatValue8 + floatValue1 * interpolationFactor4;
    fStack00000000000000c8 = floatValue3 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue1 * interpolationFactor5;
    fStack00000000000000cc = floatValue3 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x158);
    fStack00000000000000d0 = floatValue4 * floatValue11 + floatValue5 * floatValue7 + floatValue1 * interpolationFactor3 + systemStringIteratorPtr[0xc];
    fStack00000000000000d4 = floatValue4 * FloatRatioValue + floatValue5 * floatValue8 + floatValue1 * interpolationFactor4 + systemStringIteratorPtr[0xd];
    fStack00000000000000d8 = floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5 + systemStringIteratorPtr[0xe];
    fStack00000000000000dc = floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1 + systemStringIteratorPtr[0xf];
  }
  FUN_180085190(&stack0x00000060,unaff_R13 + 0x30,*(uint8_t *)(systemMemoryBlockPtr + 0xf7));
  creationFlags6 = ThreadCreationParameter;
  creationFlags5 = InputStackParameter90;
  creationFlags4 = InputStackParameter88;
  creationFlags3 = InputStackParameter80;
  creationFlags2 = InputStackParameter78;
  creationFlags1 = InputStackParameter70;
  creationFlags0 = InputStackParameter68;
  systemStatus9 = InputStackParameter60;
  isSystemActive8 = *(byte *)(unaff_R13 + 0x1bd8);
  systemFlag = *(int *)(SystemStatusFlagsPointer + 0x224);
  if (((*(byte *)(systemMemoryBlockPtr + 0xfd) & 1) == 0) &&
     ((*(int *)(systemMemoryBlockPtr + 0x1d0) == systemFlag || (*(int *)(systemMemoryBlockPtr + 0x1d0) == systemFlag + -1)))) {
    isSystemActive7 = 0;
  }
  else {
    isSystemActive7 = 1;
  }
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe | isSystemActive7;
  isSystemActive8 = isSystemActive8 & 0x20;
  if ((isSystemActive8 != 0) && (isSystemActive7 != 0)) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = InputStackParameter60;
    *(void* *)(systemMemoryBlockPtr + 0x168) = InputStackParameter68;
    *(void* *)(systemMemoryBlockPtr + 0x170) = InputStackParameter70;
    *(void* *)(systemMemoryBlockPtr + 0x178) = InputStackParameter78;
    *(void* *)(systemMemoryBlockPtr + 0x180) = InputStackParameter80;
    *(void* *)(systemMemoryBlockPtr + 0x188) = InputStackParameter88;
    *(void* *)(systemMemoryBlockPtr + 400) = InputStackParameter90;
    *(void* *)(systemMemoryBlockPtr + 0x198) = ThreadCreationParameter;
  }
  FUN_18024a290();
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe;
  *(int *)(systemMemoryBlockPtr + 0x1d0) = systemFlag;
  if (isSystemActive8 != 0) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = systemStatus9;
    *(void* *)(systemMemoryBlockPtr + 0x168) = creationFlags0;
    *(void* *)(systemMemoryBlockPtr + 0x170) = creationFlags1;
    *(void* *)(systemMemoryBlockPtr + 0x178) = creationFlags2;
    *(void* *)(systemMemoryBlockPtr + 0x180) = creationFlags3;
    *(void* *)(systemMemoryBlockPtr + 0x188) = creationFlags4;
    *(void* *)(systemMemoryBlockPtr + 400) = creationFlags5;
    *(void* *)(systemMemoryBlockPtr + 0x198) = creationFlags6;
  }
  return;
}





// 函数: void FUN_180077dc6(void)
void FUN_180077dc6(void)

{
  float FloatVariable1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  int systemFlag;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  void* systemStatus9;
  void* creationFlags0;
  void* creationFlags1;
  void* creationFlags2;
  void* creationFlags3;
  void* creationFlags4;
  void* creationFlags5;
  void* creationFlags6;
  byte isSystemActive7;
  long long systemMemoryBlockPtr;
  byte isSystemActive8;
  float *pfloatValue29;
  long long unaff_R13;
  uint32_t uStack0000000000000030;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  uint32_t in_stack_000000f0;
  uint32_t in_stack_000000f8;
  uint32_t in_stack_00000100;
  uint32_t in_stack_00000108;
  uint32_t in_stack_00000110;
  uint32_t in_stack_00000118;
  float *in_stack_00000180;
  void* in_stack_00000188;
  
  uStack0000000000000030 = 0xffffffff;
  FUN_180080e90(unaff_R13 + 0x3388,&stack0x00000030);
  pfloatValue29 = in_stack_00000180;
  if ((*(uint *)(systemMemoryBlockPtr + 0x100) & 0x4000000) != 0) {
    floatValue7 = *in_stack_00000180;
    floatValue8 = in_stack_00000180[1];
    floatValue9 = in_stack_00000180[2];
    FloatScaleFactor = in_stack_00000180[3];
    floatValue11 = in_stack_00000180[4];
    FloatRatioValue = in_stack_00000180[5];
    interpolationFactor1 = in_stack_00000180[6];
    interpolationFactor2 = in_stack_00000180[7];
    scaleResult1 = in_stack_00000180[8];
    interpolationFactor4 = in_stack_00000180[9];
    interpolationFactor5 = in_stack_00000180[10];
    magnitudeSquared1 = in_stack_00000180[0xb];
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x124);
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x120);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x128);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x134);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x130);
    fStack00000000000000a0 = floatValue1 * floatValue11 + floatValue2 * floatValue7 + floatValue3 * interpolationFactor3;
    fStack00000000000000a4 = floatValue1 * FloatRatioValue + floatValue2 * floatValue8 + floatValue3 * interpolationFactor4;
    fStack00000000000000a8 = floatValue1 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue3 * interpolationFactor5;
    fStack00000000000000ac = floatValue1 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue3 * magnitudeSquared1;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x138);
    floatValue2 = *(float *)(systemMemoryBlockPtr + 0x140);
    floatValue3 = *(float *)(systemMemoryBlockPtr + 0x144);
    fStack00000000000000b0 = floatValue4 * floatValue11 + floatValue5 * floatValue7 + floatValue1 * interpolationFactor3;
    fStack00000000000000b4 = floatValue4 * FloatRatioValue + floatValue5 * floatValue8 + floatValue1 * interpolationFactor4;
    fStack00000000000000b8 = floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5;
    fStack00000000000000bc = floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x148);
    floatValue4 = *(float *)(systemMemoryBlockPtr + 0x154);
    floatValue5 = *(float *)(systemMemoryBlockPtr + 0x150);
    fStack00000000000000c0 = floatValue3 * floatValue11 + floatValue2 * floatValue7 + floatValue1 * interpolationFactor3;
    fStack00000000000000c4 = floatValue3 * FloatRatioValue + floatValue2 * floatValue8 + floatValue1 * interpolationFactor4;
    fStack00000000000000c8 = floatValue3 * interpolationFactor1 + floatValue2 * floatValue9 + floatValue1 * interpolationFactor5;
    fStack00000000000000cc = floatValue3 * interpolationFactor2 + floatValue2 * FloatScaleFactor + floatValue1 * magnitudeSquared1;
    floatValue1 = *(float *)(systemMemoryBlockPtr + 0x158);
    fStack00000000000000d0 =
         floatValue4 * floatValue11 + floatValue5 * floatValue7 + floatValue1 * interpolationFactor3 + in_stack_00000180[0xc];
    fStack00000000000000d4 =
         floatValue4 * FloatRatioValue + floatValue5 * floatValue8 + floatValue1 * interpolationFactor4 + in_stack_00000180[0xd];
    fStack00000000000000d8 =
         floatValue4 * interpolationFactor1 + floatValue5 * floatValue9 + floatValue1 * interpolationFactor5 + in_stack_00000180[0xe];
    fStack00000000000000dc =
         floatValue4 * interpolationFactor2 + floatValue5 * FloatScaleFactor + floatValue1 * magnitudeSquared1 + in_stack_00000180[0xf];
    pfloatValue29 = &stack0x000000a0;
  }
  FUN_180085190(&stack0x00000060,unaff_R13 + 0x30,*(uint8_t *)(systemMemoryBlockPtr + 0xf7),pfloatValue29);
  creationFlags6 = ThreadCreationParameter;
  creationFlags5 = InputStackParameter90;
  creationFlags4 = InputStackParameter88;
  creationFlags3 = InputStackParameter80;
  creationFlags2 = InputStackParameter78;
  creationFlags1 = InputStackParameter70;
  creationFlags0 = InputStackParameter68;
  systemStatus9 = InputStackParameter60;
  isSystemActive8 = *(byte *)(unaff_R13 + 0x1bd8);
  systemFlag = *(int *)(SystemStatusFlagsPointer + 0x224);
  if (((*(byte *)(systemMemoryBlockPtr + 0xfd) & 1) == 0) &&
     ((*(int *)(systemMemoryBlockPtr + 0x1d0) == systemFlag || (*(int *)(systemMemoryBlockPtr + 0x1d0) == systemFlag + -1)))) {
    isSystemActive7 = 0;
  }
  else {
    isSystemActive7 = 1;
  }
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe | isSystemActive7;
  isSystemActive8 = isSystemActive8 & 0x20;
  if ((isSystemActive8 != 0) && (isSystemActive7 != 0)) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = InputStackParameter60;
    *(void* *)(systemMemoryBlockPtr + 0x168) = InputStackParameter68;
    *(void* *)(systemMemoryBlockPtr + 0x170) = InputStackParameter70;
    *(void* *)(systemMemoryBlockPtr + 0x178) = InputStackParameter78;
    *(void* *)(systemMemoryBlockPtr + 0x180) = InputStackParameter80;
    *(void* *)(systemMemoryBlockPtr + 0x188) = InputStackParameter88;
    *(void* *)(systemMemoryBlockPtr + 400) = InputStackParameter90;
    *(void* *)(systemMemoryBlockPtr + 0x198) = ThreadCreationParameter;
  }
  FUN_18024a290();
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe;
  *(int *)(systemMemoryBlockPtr + 0x1d0) = systemFlag;
  if (isSystemActive8 != 0) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = systemStatus9;
    *(void* *)(systemMemoryBlockPtr + 0x168) = creationFlags0;
    *(void* *)(systemMemoryBlockPtr + 0x170) = creationFlags1;
    *(void* *)(systemMemoryBlockPtr + 0x178) = creationFlags2;
    *(void* *)(systemMemoryBlockPtr + 0x180) = creationFlags3;
    *(void* *)(systemMemoryBlockPtr + 0x188) = creationFlags4;
    *(void* *)(systemMemoryBlockPtr + 400) = creationFlags5;
    *(void* *)(systemMemoryBlockPtr + 0x198) = creationFlags6;
  }
  return;
}





// 函数: void FUN_180077dec(void)
void FUN_180077dec(void)

{
  int systemStatus;
  void* creationFlags;
  void* allocationContext;
  void* unsignedSystemValue4;
  void* currentThreadId;
  void* hashValue;
  void* unsignedSystemValue7;
  void* unsignedSystemValue8;
  void* unsignedSystemValue9;
  byte isByteValid0;
  long long systemMemoryBlockPtr;
  byte isByteValid1;
  long long unaff_R13;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  
  FUN_180085190(&stack0x00000060,unaff_R13 + 0x30,*(uint8_t *)(systemMemoryBlockPtr + 0xf7));
  unsignedSystemValue9 = ThreadCreationParameter;
  unsignedSystemValue8 = InputStackParameter90;
  unsignedSystemValue7 = InputStackParameter88;
  hashValue = InputStackParameter80;
  currentThreadId = InputStackParameter78;
  unsignedSystemValue4 = InputStackParameter70;
  allocationContext = InputStackParameter68;
  creationFlags = InputStackParameter60;
  isByteValid1 = *(byte *)(unaff_R13 + 0x1bd8);
  systemStatus = *(int *)(SystemStatusFlagsPointer + 0x224);
  if (((*(byte *)(systemMemoryBlockPtr + 0xfd) & 1) == 0) &&
     ((*(int *)(systemMemoryBlockPtr + 0x1d0) == systemStatus || (*(int *)(systemMemoryBlockPtr + 0x1d0) == systemStatus + -1)))) {
    isByteValid0 = 0;
  }
  else {
    isByteValid0 = 1;
  }
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe | isByteValid0;
  isByteValid1 = isByteValid1 & 0x20;
  if ((isByteValid1 != 0) && (isByteValid0 != 0)) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = InputStackParameter60;
    *(void* *)(systemMemoryBlockPtr + 0x168) = InputStackParameter68;
    *(void* *)(systemMemoryBlockPtr + 0x170) = InputStackParameter70;
    *(void* *)(systemMemoryBlockPtr + 0x178) = InputStackParameter78;
    *(void* *)(systemMemoryBlockPtr + 0x180) = InputStackParameter80;
    *(void* *)(systemMemoryBlockPtr + 0x188) = InputStackParameter88;
    *(void* *)(systemMemoryBlockPtr + 400) = InputStackParameter90;
    *(void* *)(systemMemoryBlockPtr + 0x198) = ThreadCreationParameter;
  }
  FUN_18024a290();
  *(byte *)(systemMemoryBlockPtr + 0xfd) = *(byte *)(systemMemoryBlockPtr + 0xfd) & 0xfe;
  *(int *)(systemMemoryBlockPtr + 0x1d0) = systemStatus;
  if (isByteValid1 != 0) {
    *(void* *)(systemMemoryBlockPtr + 0x160) = creationFlags;
    *(void* *)(systemMemoryBlockPtr + 0x168) = allocationContext;
    *(void* *)(systemMemoryBlockPtr + 0x170) = unsignedSystemValue4;
    *(void* *)(systemMemoryBlockPtr + 0x178) = currentThreadId;
    *(void* *)(systemMemoryBlockPtr + 0x180) = hashValue;
    *(void* *)(systemMemoryBlockPtr + 0x188) = unsignedSystemValue7;
    *(void* *)(systemMemoryBlockPtr + 400) = unsignedSystemValue8;
    *(void* *)(systemMemoryBlockPtr + 0x198) = unsignedSystemValue9;
  }
  return;
}



uint8_t FUN_180077ef9(void)

{
  return 0;
}



ulong long FUN_180077f20(long long ResourceManagerPointer,void* ConfigurationDataPointer,uint32_t AdditionalParameter,float *ConfigurationFlag,
                       uint32_t primaryConfigurationParameter,uint32_t secondaryConfigurationParameter)

{
  float FloatVariable1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  char CharacterVariable19;
  ulong long in_RAX;
  long long localSystemHandle0;
  ulong long creationFlags1;
  long long localSystemHandle2;
  byte isSystemActive3;
  void* UnsignedStackFlag88;
  ulong long UnsignedStackFlag80;
  void* UnsignedStackFlag78;
  ulong long processFlags70;
  void* EncryptionValue68;
  ulong long unsignedValue60;
  float fStack_58;
  float fStack_54;
  float fStack_50;
  uint32_t uStack_4c;
  
  localSystemHandle2 = *(long long *)(ResourceManagerPointer + 0x1b8);
  if (localSystemHandle2 != 0) {
    isSystemActive3 = *(byte *)(ResourceManagerPointer + 0xfd) & 0x20;
    localSystemHandle0 = ResourceManagerPointer;
    if (isSystemActive3 == 0) {
      localSystemHandle0 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
    }
    if (*(int *)(localSystemHandle0 + 0x200) != 0) {
      localSystemHandle0 = ResourceManagerPointer;
      if (isSystemActive3 == 0) {
        localSystemHandle0 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
      }
      if (*(int *)(localSystemHandle0 + 0x1fc) * 3 != 0) goto LAB_180077fcf;
    }
    if ((*(byte *)(ResourceManagerPointer + 0x100) & 4) != 0) {
LAB_180077fcf:
      localSystemHandle2 = *(long long *)(ResourceManagerPointer + 0x1b8);
      charStatus9 = *(char *)(localSystemHandle2 + 0x38c);
      if (charStatus9 == '\t') {
        charStatus9 = func_0x00018022d300();
        *(char *)(localSystemHandle2 + 0x38c) = charStatus9;
      }
      charStatus9 = FUN_18007b240(ResourceManagerPointer,ResourceManagerPointer + 0x1e8,charStatus9,1);
      if (charStatus9 == '\0') {
        *(byte *)(ResourceManagerPointer + 0xfe) = *(byte *)(ResourceManagerPointer + 0xfe) & 0xfb;
      }
      if ((*(uint *)(ResourceManagerPointer + 0x100) & 0x4000000) == 0) {
        UnsignedStackFlag88 = *(void* *)ConfigurationFlag;
        UnsignedStackFlag80._0_4_ = (float)*(void* *)(ConfigurationFlag + 2);
        UnsignedStackFlag78 = *(void* *)(ConfigurationFlag + 4);
        processFlags70._0_4_ = (float)*(void* *)(ConfigurationFlag + 6);
        EncryptionValue68 = *(void* *)(ConfigurationFlag + 8);
        unsignedValue60._0_4_ = (float)*(void* *)(ConfigurationFlag + 10);
        fStack_58 = ConfigurationFlag[0xc];
        fStack_54 = ConfigurationFlag[0xd];
        fStack_50 = ConfigurationFlag[0xe];
      }
      else {
        FloatScaleFactor = ConfigurationFlag[4];
        floatValue11 = ConfigurationFlag[5];
        FloatRatioValue = ConfigurationFlag[6];
        floatValue1 = *(float *)(ResourceManagerPointer + 0x120);
        floatValue2 = *(float *)(ResourceManagerPointer + 0x128);
        floatValue3 = *(float *)(ResourceManagerPointer + 0x134);
        floatValue4 = *(float *)(ResourceManagerPointer + 0x144);
        floatValue5 = *(float *)(ResourceManagerPointer + 0x154);
        interpolationFactor1 = *ConfigurationFlag;
        interpolationFactor2 = ConfigurationFlag[1];
        scaleResult1 = ConfigurationFlag[2];
        interpolationFactor4 = ConfigurationFlag[8];
        interpolationFactor5 = ConfigurationFlag[9];
        magnitudeSquared1 = ConfigurationFlag[10];
        floatValue6 = *(float *)(ResourceManagerPointer + 0x124);
        floatValue7 = *(float *)(ResourceManagerPointer + 0x130);
        UnsignedStackFlag80._0_4_ = floatValue6 * FloatRatioValue + floatValue1 * interpolationFactor3 + floatValue2 * magnitudeSquared1;
        floatValue8 = *(float *)(ResourceManagerPointer + 0x138);
        floatValue9 = *(float *)(ResourceManagerPointer + 0x140);
        processFlags70._0_4_ = floatValue3 * FloatRatioValue + floatValue7 * interpolationFactor3 + floatValue8 * magnitudeSquared1;
        UnsignedStackFlag88 = CONCAT44(floatValue6 * floatValue11 + floatValue1 * interpolationFactor2 + floatValue2 * interpolationFactor5,
                             floatValue6 * FloatScaleFactor + floatValue1 * interpolationFactor1 + floatValue2 * interpolationFactor4);
        floatValue1 = *(float *)(ResourceManagerPointer + 0x148);
        floatValue2 = *(float *)(ResourceManagerPointer + 0x150);
        unsignedValue60._0_4_ = floatValue4 * FloatRatioValue + floatValue9 * interpolationFactor3 + floatValue1 * magnitudeSquared1;
        floatValue6 = *(float *)(ResourceManagerPointer + 0x158);
        UnsignedStackFlag78 = CONCAT44(floatValue3 * floatValue11 + floatValue7 * interpolationFactor2 + floatValue8 * interpolationFactor5,
                             floatValue3 * FloatScaleFactor + floatValue7 * interpolationFactor1 + floatValue8 * interpolationFactor4);
        EncryptionValue68 = CONCAT44(floatValue4 * floatValue11 + floatValue9 * interpolationFactor2 + floatValue1 * interpolationFactor5,
                             floatValue4 * FloatScaleFactor + floatValue9 * interpolationFactor1 + floatValue1 * interpolationFactor4);
        fStack_58 = floatValue5 * FloatScaleFactor + floatValue2 * interpolationFactor1 + floatValue6 * interpolationFactor4 + ConfigurationFlag[0xc];
        fStack_54 = floatValue5 * floatValue11 + floatValue2 * interpolationFactor2 + floatValue6 * interpolationFactor5 + ConfigurationFlag[0xd];
        fStack_50 = floatValue5 * FloatRatioValue + floatValue2 * interpolationFactor3 + floatValue6 * magnitudeSquared1 + ConfigurationFlag[0xe];
      }
      uStack_4c = 0x3f800000;
      unsignedValue60 = (ulong long)(uint)(float)unsignedValue60;
      processFlags70 = (ulong long)(uint)(float)processFlags70;
      UnsignedStackFlag80 = (ulong long)(uint)(float)UnsignedStackFlag80;
      creationFlags1 = FUN_180252ca0(ConfigurationDataPointer,ResourceManagerPointer,AdditionalParameter,&UnsignedStackFlag88,primaryConfigurationParameter,secondaryConfigurationParameter);
      return creationFlags1;
    }
    in_RAX = 0;
    if (*(char *)(localSystemHandle2 + 0x38c) == '\t') {
      in_RAX = func_0x00018022d300(localSystemHandle2);
      *(char *)(localSystemHandle2 + 0x38c) = (char)in_RAX;
      if ((char)in_RAX == '\t') goto LAB_180077fcf;
    }
  }
  return in_RAX & 0xffffffffffffff00;
}




// 函数: void FUN_180078051(void* ResourceManagerPointer,void* ConfigurationDataPointer,float AdditionalParameter,float ConfigurationFlag)
void FUN_180078051(void* ResourceManagerPointer,void* ConfigurationDataPointer,float AdditionalParameter,float ConfigurationFlag)

{
  float FloatVariable1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  long long systemMemoryBlockPtr;
  float *systemDataIndexPtr;
  uint32_t systemResourceCounterD;
  float in_XMM0_Dc;
  float in_XMM1_Dc;
  float in_XMM4_Da;
  float in_XMM4_Db;
  float in_XMM4_Dc;
  float in_XMM5_Da;
  uint32_t uStack0000000000000028;
  float fStack0000000000000030;
  float fStack0000000000000034;
  float fStack0000000000000038;
  uint32_t uStack000000000000003c;
  float fStack0000000000000040;
  float fStack0000000000000044;
  float fStack0000000000000048;
  uint32_t uStack000000000000004c;
  float fStack0000000000000050;
  float fStack0000000000000054;
  float fStack0000000000000058;
  uint32_t uStack000000000000005c;
  float fStack0000000000000060;
  float fStack0000000000000064;
  float fStack0000000000000068;
  uint32_t uStack000000000000006c;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  
  floatValue4 = *systemDataIndexPtr;
  floatValue5 = systemDataIndexPtr[1];
  floatValue6 = systemDataIndexPtr[2];
  floatValue7 = systemDataIndexPtr[8];
  floatValue8 = systemDataIndexPtr[9];
  floatValue9 = systemDataIndexPtr[10];
  floatValue1 = *(float *)(systemMemoryBlockPtr + 0x124);
  floatValue2 = *(float *)(systemMemoryBlockPtr + 0x130);
  fStack0000000000000030 = floatValue1 * in_XMM4_Da + (float)ResourceManagerPointer * floatValue4 + (float)ConfigurationDataPointer * floatValue7;
  fStack0000000000000034 =
       floatValue1 * in_XMM4_Db + (float)((ulong long)ResourceManagerPointer >> 0x20) * floatValue5 +
       (float)((ulong long)ConfigurationDataPointer >> 0x20) * floatValue8;
  fStack0000000000000038 = floatValue1 * in_XMM4_Dc + in_XMM0_Dc * floatValue6 + in_XMM1_Dc * floatValue9;
  floatValue1 = *(float *)(systemMemoryBlockPtr + 0x138);
  floatValue3 = *(float *)(systemMemoryBlockPtr + 0x140);
  fStack0000000000000040 = in_XMM5_Da * in_XMM4_Da + floatValue2 * floatValue4 + floatValue1 * floatValue7;
  fStack0000000000000044 = in_XMM5_Da * in_XMM4_Db + floatValue2 * floatValue5 + floatValue1 * floatValue8;
  fStack0000000000000048 = in_XMM5_Da * in_XMM4_Dc + floatValue2 * floatValue6 + floatValue1 * floatValue9;
  floatValue1 = *(float *)(systemMemoryBlockPtr + 0x148);
  floatValue2 = *(float *)(systemMemoryBlockPtr + 0x150);
  fStack0000000000000050 = ConfigurationFlag * in_XMM4_Da + floatValue3 * floatValue4 + floatValue1 * floatValue7;
  fStack0000000000000054 = ConfigurationFlag * in_XMM4_Db + floatValue3 * floatValue5 + floatValue1 * floatValue8;
  fStack0000000000000058 = ConfigurationFlag * in_XMM4_Dc + floatValue3 * floatValue6 + floatValue1 * floatValue9;
  floatValue1 = *(float *)(systemMemoryBlockPtr + 0x158);
  fStack0000000000000060 = AdditionalParameter * in_XMM4_Da + floatValue2 * floatValue4 + floatValue1 * floatValue7 + systemDataIndexPtr[0xc];
  fStack0000000000000064 = AdditionalParameter * in_XMM4_Db + floatValue2 * floatValue5 + floatValue1 * floatValue8 + systemDataIndexPtr[0xd];
  fStack0000000000000068 = AdditionalParameter * in_XMM4_Dc + floatValue2 * floatValue6 + floatValue1 * floatValue9 + systemDataIndexPtr[0xe];
  uStack0000000000000028 = in_stack_000000e8;
  uStack000000000000006c = 0x3f800000;
  uStack000000000000005c = 0;
  uStack000000000000004c = 0;
  uStack000000000000003c = 0;
  FUN_180252ca0(0x3f800000,floatValue1 * floatValue7,systemResourceCounterD,&stack0x00000030,in_stack_000000e0);
  return;
}




// 函数: void FUN_180078143(void)
void FUN_180078143(void)

{
  void* *systemDataIndexPtr;
  uint32_t systemResourceCounterD;
  uint32_t uStack0000000000000028;
  void* uStack0000000000000030;
  ulong long uStack0000000000000038;
  void* uStack0000000000000040;
  ulong long uStack0000000000000048;
  void* uStack0000000000000050;
  ulong long uStack0000000000000058;
  uint32_t uStack0000000000000060;
  uint32_t uStack0000000000000064;
  uint32_t uStack0000000000000068;
  uint32_t uStack000000000000006c;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  
  uStack0000000000000030 = *systemDataIndexPtr;
  uStack0000000000000040 = systemDataIndexPtr[2];
  uStack0000000000000050 = systemDataIndexPtr[4];
  uStack0000000000000060 = *(uint32_t *)(systemDataIndexPtr + 6);
  uStack0000000000000064 = *(uint32_t *)((long long)systemDataIndexPtr + 0x34);
  uStack0000000000000068 = *(uint32_t *)(systemDataIndexPtr + 7);
  uStack0000000000000028 = in_stack_000000e8;
  uStack000000000000006c = 0x3f800000;
  uStack0000000000000058 = systemDataIndexPtr[5] & 0xffffffff;
  uStack0000000000000048 = systemDataIndexPtr[3] & 0xffffffff;
  uStack0000000000000038 = systemDataIndexPtr[1] & 0xffffffff;
  FUN_180252ca0(0x3f800000,uStack0000000000000060,systemResourceCounterD,&stack0x00000030,in_stack_000000e0);
  return;
}





// 函数: void FUN_1800781e0(long long ResourceManagerPointer)
void FUN_1800781e0(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  uint32_t creationFlags;
  uint32_t allocationContext;
  uint32_t unsignedSystemValue4;
  char operationStatusFlag;
  uint8_t hashValue;
  void** SystemCurrentNode;
  long long localMemoryAddress;
  uint unsignedSystemValue9;
  bool isByteValid0;
  float floatValue11;
  
  localMemoryAddress = ResourceManagerPointer;
  if ((*(long long *)(ResourceManagerPointer + 0x1c8) != 0) &&
     (nextDataIndex = *(long long *)(*(long long *)(ResourceManagerPointer + 0x1c8) + 0x28), nextDataIndex != 0)) {
    floatValue11 = (*(float *)(nextDataIndex + 0x74) * *(float *)(nextDataIndex + 0x88) -
             *(float *)(nextDataIndex + 0x78) * *(float *)(nextDataIndex + 0x84)) * *(float *)(nextDataIndex + 0x90);
    func_0x0001800773c0(floatValue11,(*(float *)(nextDataIndex + 0x78) * *(float *)(nextDataIndex + 0x80) -
                               *(float *)(nextDataIndex + 0x70) * *(float *)(nextDataIndex + 0x88)) *
                               *(float *)(nextDataIndex + 0x94) + floatValue11 +
                               (*(float *)(nextDataIndex + 0x70) * *(float *)(nextDataIndex + 0x84) -
                               *(float *)(nextDataIndex + 0x74) * *(float *)(nextDataIndex + 0x80)) *
                               *(float *)(nextDataIndex + 0x98) < 0.0);
  }
  if (*(long long *)(localMemoryAddress + 0x1b8) == 0) {
LAB_1800782d4:
    isByteValid0 = (*(byte *)(ResourceManagerPointer + 0xfd) & 2) != 0;
  }
  else {
    unsignedSystemValue9 = *(uint *)(*(long long *)(localMemoryAddress + 0x1b8) + 0x138);
    if ((unsignedSystemValue9 & 0x20) != 0) {
      charValue = '\0';
      goto LAB_1800782e0;
    }
    if ((unsignedSystemValue9 & 0x10) == 0) goto LAB_1800782d4;
    isByteValid0 = (*(byte *)(ResourceManagerPointer + 0xfd) & 2) == 0;
  }
  charValue = isByteValid0 + '\x01';
LAB_1800782e0:
  *(char *)(ResourceManagerPointer + 0xff) = charValue;
  localMemoryAddress = *(long long *)(ResourceManagerPointer + 0x1b8);
  unsignedSystemValue9 = *(uint *)(localMemoryAddress + 0x138) & 0x3000;
  hashValue = 0;
  if (unsignedSystemValue9 == 0x1000) {
    *(uint8_t *)(ResourceManagerPointer + 0xf7) = 1;
  }
  else {
    if (unsignedSystemValue9 == 0x2000) {
      hashValue = 2;
    }
    *(uint8_t *)(ResourceManagerPointer + 0xf7) = hashValue;
  }
  if ((((*(float *)(localMemoryAddress + 0x288) != 0.0) || (*(float *)(localMemoryAddress + 0x28c) != 0.0)) ||
      (*(float *)(localMemoryAddress + 0x290) != 0.0)) || (*(float *)(localMemoryAddress + 0x294) != 0.0)) {
    creationFlags = *(uint32_t *)(localMemoryAddress + 0x28c);
    allocationContext = *(uint32_t *)(localMemoryAddress + 0x290);
    unsignedSystemValue4 = *(uint32_t *)(localMemoryAddress + 0x294);
    *(uint32_t *)(ResourceManagerPointer + 0x2a8) = *(uint32_t *)(localMemoryAddress + 0x288);
    *(uint32_t *)(ResourceManagerPointer + 0x2ac) = creationFlags;
    *(uint32_t *)(ResourceManagerPointer + 0x2b0) = allocationContext;
    *(uint32_t *)(ResourceManagerPointer + 0x2b4) = unsignedSystemValue4;
  }
  if (((*(float *)(localMemoryAddress + 0x298) != 0.0) || (*(float *)(localMemoryAddress + 0x29c) != 0.0)) ||
     ((*(float *)(localMemoryAddress + 0x2a0) != 0.0 || (*(float *)(localMemoryAddress + 0x2a4) != 0.0)))) {
    creationFlags = *(uint32_t *)(localMemoryAddress + 0x29c);
    allocationContext = *(uint32_t *)(localMemoryAddress + 0x2a0);
    unsignedSystemValue4 = *(uint32_t *)(localMemoryAddress + 0x2a4);
    *(uint32_t *)(ResourceManagerPointer + 0x2b8) = *(uint32_t *)(localMemoryAddress + 0x298);
    *(uint32_t *)(ResourceManagerPointer + 700) = creationFlags;
    *(uint32_t *)(ResourceManagerPointer + 0x2c0) = allocationContext;
    *(uint32_t *)(ResourceManagerPointer + 0x2c4) = unsignedSystemValue4;
  }
  *(void*2 *)(localMemoryAddress + 0x3c0) = 0xffff;
  FUN_180077150(ResourceManagerPointer);
  if ((*(long long *)(ResourceManagerPointer + 600) == 0) &&
     ((*(uint *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)HashBucketNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(HashBucketNode + 9) = 0xffffffff;
    *HashBucketNode = 0;
    HashBucketNode[2] = 0;
    HashBucketNode[7] = 0;
    *(uint32_t *)(HashBucketNode + 5) = 0xffffffff;
    *(uint32_t *)(HashBucketNode + 4) = 0xffffffff;
    HashBucketNode[3] = 0;
    *(uint32_t *)(HashBucketNode + 8) = 0;
    *(uint32_t *)(HashBucketNode + 1) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x44) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x24) = 0;
    *(void* **)(ResourceManagerPointer + 600) = HashBucketNode;
  }
  return;
}





// 函数: void FUN_1800781f4(long long ResourceManagerPointer)
void FUN_1800781f4(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  uint32_t creationFlags;
  uint32_t allocationContext;
  uint32_t unsignedSystemValue4;
  char operationStatusFlag;
  uint8_t hashValue;
  long long in_RAX;
  void** SystemCurrentNode;
  uint unsignedSystemValue8;
  long long systemMemoryBlockPtr;
  bool isSystemBusy;
  float FloatScaleFactor;
  
  if ((in_RAX != 0) && (nextDataIndex = *(long long *)(in_RAX + 0x28), nextDataIndex != 0)) {
    FloatScaleFactor = (*(float *)(nextDataIndex + 0x74) * *(float *)(nextDataIndex + 0x88) -
             *(float *)(nextDataIndex + 0x78) * *(float *)(nextDataIndex + 0x84)) * *(float *)(nextDataIndex + 0x90);
    func_0x0001800773c0(FloatScaleFactor,(*(float *)(nextDataIndex + 0x78) * *(float *)(nextDataIndex + 0x80) -
                               *(float *)(nextDataIndex + 0x70) * *(float *)(nextDataIndex + 0x88)) *
                               *(float *)(nextDataIndex + 0x94) + FloatScaleFactor +
                               (*(float *)(nextDataIndex + 0x70) * *(float *)(nextDataIndex + 0x84) -
                               *(float *)(nextDataIndex + 0x74) * *(float *)(nextDataIndex + 0x80)) *
                               *(float *)(nextDataIndex + 0x98) < 0.0);
  }
  if (*(long long *)(ResourceManagerPointer + 0x1b8) == 0) {
LAB_1800782d4:
    isSystemBusy = (*(byte *)(systemMemoryBlockPtr + 0xfd) & 2) != 0;
  }
  else {
    unsignedSystemValue8 = *(uint *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x138);
    if ((unsignedSystemValue8 & 0x20) != 0) {
      charValue = '\0';
      goto LAB_1800782e0;
    }
    if ((unsignedSystemValue8 & 0x10) == 0) goto LAB_1800782d4;
    isSystemBusy = (*(byte *)(systemMemoryBlockPtr + 0xfd) & 2) == 0;
  }
  charValue = isSystemBusy + '\x01';
LAB_1800782e0:
  *(char *)(systemMemoryBlockPtr + 0xff) = charValue;
  nextDataIndex = *(long long *)(systemMemoryBlockPtr + 0x1b8);
  unsignedSystemValue8 = *(uint *)(nextDataIndex + 0x138) & 0x3000;
  hashValue = 0;
  if (unsignedSystemValue8 == 0x1000) {
    *(uint8_t *)(systemMemoryBlockPtr + 0xf7) = 1;
  }
  else {
    if (unsignedSystemValue8 == 0x2000) {
      hashValue = 2;
    }
    *(uint8_t *)(systemMemoryBlockPtr + 0xf7) = hashValue;
  }
  if ((((*(float *)(nextDataIndex + 0x288) != 0.0) || (*(float *)(nextDataIndex + 0x28c) != 0.0)) ||
      (*(float *)(nextDataIndex + 0x290) != 0.0)) || (*(float *)(nextDataIndex + 0x294) != 0.0)) {
    creationFlags = *(uint32_t *)(nextDataIndex + 0x28c);
    allocationContext = *(uint32_t *)(nextDataIndex + 0x290);
    unsignedSystemValue4 = *(uint32_t *)(nextDataIndex + 0x294);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2a8) = *(uint32_t *)(nextDataIndex + 0x288);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2ac) = creationFlags;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b0) = allocationContext;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b4) = unsignedSystemValue4;
  }
  if (((*(float *)(nextDataIndex + 0x298) != 0.0) || (*(float *)(nextDataIndex + 0x29c) != 0.0)) ||
     ((*(float *)(nextDataIndex + 0x2a0) != 0.0 || (*(float *)(nextDataIndex + 0x2a4) != 0.0)))) {
    creationFlags = *(uint32_t *)(nextDataIndex + 0x29c);
    allocationContext = *(uint32_t *)(nextDataIndex + 0x2a0);
    unsignedSystemValue4 = *(uint32_t *)(nextDataIndex + 0x2a4);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b8) = *(uint32_t *)(nextDataIndex + 0x298);
    *(uint32_t *)(systemMemoryBlockPtr + 700) = creationFlags;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2c0) = allocationContext;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2c4) = unsignedSystemValue4;
  }
  *(void*2 *)(nextDataIndex + 0x3c0) = 0xffff;
  FUN_180077150();
  if ((*(long long *)(systemMemoryBlockPtr + 600) == 0) &&
     ((*(uint *)(*(long long *)(systemMemoryBlockPtr + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)HashBucketNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(HashBucketNode + 9) = 0xffffffff;
    *HashBucketNode = 0;
    HashBucketNode[2] = 0;
    HashBucketNode[7] = 0;
    *(uint32_t *)(HashBucketNode + 5) = 0xffffffff;
    *(uint32_t *)(HashBucketNode + 4) = 0xffffffff;
    HashBucketNode[3] = 0;
    *(uint32_t *)(HashBucketNode + 8) = 0;
    *(uint32_t *)(HashBucketNode + 1) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x44) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x24) = 0;
    *(void* **)(systemMemoryBlockPtr + 600) = HashBucketNode;
  }
  return;
}





// 函数: void FUN_180078239(float ResourceManagerPointer,float ConfigurationDataPointer,float AdditionalParameter,float ConfigurationFlag)
void FUN_180078239(float ResourceManagerPointer,float ConfigurationDataPointer,float AdditionalParameter,float ConfigurationFlag)

{
  long long nextDataIndex;
  uint32_t creationFlags;
  uint32_t allocationContext;
  uint32_t unsignedSystemValue4;
  char operationStatusFlag;
  uint8_t hashValue;
  long long in_RAX;
  void** SystemCurrentNode;
  long long in_RCX;
  uint unsignedSystemValue8;
  long long systemMemoryBlockPtr;
  bool isSystemBusy;
  float FloatScaleFactor;
  float in_XMM4_Da;
  float in_XMM5_Da;
  float unaff_XMM8_Da;
  
  FloatScaleFactor = (*(float *)(in_RAX + 0x74) * ConfigurationDataPointer - AdditionalParameter * ConfigurationFlag) * *(float *)(in_RAX + 0x90);
  func_0x0001800773c0(FloatScaleFactor,(AdditionalParameter * in_XMM4_Da - ResourceManagerPointer * ConfigurationDataPointer) * *(float *)(in_RAX + 0x94)
                             + FloatScaleFactor +
                             (in_XMM5_Da * ConfigurationFlag - *(float *)(in_RAX + 0x74) * in_XMM4_Da) *
                             *(float *)(in_RAX + 0x98) < unaff_XMM8_Da);
  if (*(long long *)(in_RCX + 0x1b8) == 0) {
LAB_1800782d4:
    isSystemBusy = (*(byte *)(systemMemoryBlockPtr + 0xfd) & 2) != 0;
  }
  else {
    unsignedSystemValue8 = *(uint *)(*(long long *)(in_RCX + 0x1b8) + 0x138);
    if ((unsignedSystemValue8 & 0x20) != 0) {
      charValue = '\0';
      goto LAB_1800782e0;
    }
    if ((unsignedSystemValue8 & 0x10) == 0) goto LAB_1800782d4;
    isSystemBusy = (*(byte *)(systemMemoryBlockPtr + 0xfd) & 2) == 0;
  }
  charValue = isSystemBusy + '\x01';
LAB_1800782e0:
  *(char *)(systemMemoryBlockPtr + 0xff) = charValue;
  nextDataIndex = *(long long *)(systemMemoryBlockPtr + 0x1b8);
  unsignedSystemValue8 = *(uint *)(nextDataIndex + 0x138) & 0x3000;
  hashValue = 0;
  if (unsignedSystemValue8 == 0x1000) {
    *(uint8_t *)(systemMemoryBlockPtr + 0xf7) = 1;
  }
  else {
    if (unsignedSystemValue8 == 0x2000) {
      hashValue = 2;
    }
    *(uint8_t *)(systemMemoryBlockPtr + 0xf7) = hashValue;
  }
  if ((((unaff_XMM8_Da != *(float *)(nextDataIndex + 0x288)) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x28c))
       ) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x290))) ||
     (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x294))) {
    creationFlags = *(uint32_t *)(nextDataIndex + 0x28c);
    allocationContext = *(uint32_t *)(nextDataIndex + 0x290);
    unsignedSystemValue4 = *(uint32_t *)(nextDataIndex + 0x294);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2a8) = *(uint32_t *)(nextDataIndex + 0x288);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2ac) = creationFlags;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b0) = allocationContext;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b4) = unsignedSystemValue4;
  }
  if (((unaff_XMM8_Da != *(float *)(nextDataIndex + 0x298)) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x29c)))
     || ((unaff_XMM8_Da != *(float *)(nextDataIndex + 0x2a0) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x2a4))
         ))) {
    creationFlags = *(uint32_t *)(nextDataIndex + 0x29c);
    allocationContext = *(uint32_t *)(nextDataIndex + 0x2a0);
    unsignedSystemValue4 = *(uint32_t *)(nextDataIndex + 0x2a4);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b8) = *(uint32_t *)(nextDataIndex + 0x298);
    *(uint32_t *)(systemMemoryBlockPtr + 700) = creationFlags;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2c0) = allocationContext;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2c4) = unsignedSystemValue4;
  }
  *(void*2 *)(nextDataIndex + 0x3c0) = 0xffff;
  FUN_180077150();
  if ((*(long long *)(systemMemoryBlockPtr + 600) == 0) &&
     ((*(uint *)(*(long long *)(systemMemoryBlockPtr + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)HashBucketNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(HashBucketNode + 9) = 0xffffffff;
    *HashBucketNode = 0;
    HashBucketNode[2] = 0;
    HashBucketNode[7] = 0;
    *(uint32_t *)(HashBucketNode + 5) = 0xffffffff;
    *(uint32_t *)(HashBucketNode + 4) = 0xffffffff;
    HashBucketNode[3] = 0;
    *(uint32_t *)(HashBucketNode + 8) = 0;
    *(uint32_t *)(HashBucketNode + 1) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x44) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x24) = 0;
    *(void* **)(systemMemoryBlockPtr + 600) = HashBucketNode;
  }
  return;
}





// 函数: void FUN_1800782a8(long long ResourceManagerPointer)
void FUN_1800782a8(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  uint32_t creationFlags;
  uint32_t allocationContext;
  uint32_t unsignedSystemValue4;
  char operationStatusFlag;
  uint8_t hashValue;
  void** SystemCurrentNode;
  uint unsignedSystemValue8;
  long long systemMemoryBlockPtr;
  bool isSystemBusy;
  float unaff_XMM8_Da;
  
  if (*(long long *)(ResourceManagerPointer + 0x1b8) == 0) {
LAB_1800782d4:
    isSystemBusy = (*(byte *)(systemMemoryBlockPtr + 0xfd) & 2) != 0;
  }
  else {
    unsignedSystemValue8 = *(uint *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x138);
    if ((unsignedSystemValue8 & 0x20) != 0) {
      charValue = '\0';
      goto LAB_1800782e0;
    }
    if ((unsignedSystemValue8 & 0x10) == 0) goto LAB_1800782d4;
    isSystemBusy = (*(byte *)(systemMemoryBlockPtr + 0xfd) & 2) == 0;
  }
  charValue = isSystemBusy + '\x01';
LAB_1800782e0:
  *(char *)(systemMemoryBlockPtr + 0xff) = charValue;
  nextDataIndex = *(long long *)(systemMemoryBlockPtr + 0x1b8);
  unsignedSystemValue8 = *(uint *)(nextDataIndex + 0x138) & 0x3000;
  hashValue = 0;
  if (unsignedSystemValue8 == 0x1000) {
    *(uint8_t *)(systemMemoryBlockPtr + 0xf7) = 1;
  }
  else {
    if (unsignedSystemValue8 == 0x2000) {
      hashValue = 2;
    }
    *(uint8_t *)(systemMemoryBlockPtr + 0xf7) = hashValue;
  }
  if ((((unaff_XMM8_Da != *(float *)(nextDataIndex + 0x288)) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x28c))
       ) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x290))) ||
     (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x294))) {
    creationFlags = *(uint32_t *)(nextDataIndex + 0x28c);
    allocationContext = *(uint32_t *)(nextDataIndex + 0x290);
    unsignedSystemValue4 = *(uint32_t *)(nextDataIndex + 0x294);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2a8) = *(uint32_t *)(nextDataIndex + 0x288);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2ac) = creationFlags;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b0) = allocationContext;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b4) = unsignedSystemValue4;
  }
  if (((unaff_XMM8_Da != *(float *)(nextDataIndex + 0x298)) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x29c)))
     || ((unaff_XMM8_Da != *(float *)(nextDataIndex + 0x2a0) || (unaff_XMM8_Da != *(float *)(nextDataIndex + 0x2a4))
         ))) {
    creationFlags = *(uint32_t *)(nextDataIndex + 0x29c);
    allocationContext = *(uint32_t *)(nextDataIndex + 0x2a0);
    unsignedSystemValue4 = *(uint32_t *)(nextDataIndex + 0x2a4);
    *(uint32_t *)(systemMemoryBlockPtr + 0x2b8) = *(uint32_t *)(nextDataIndex + 0x298);
    *(uint32_t *)(systemMemoryBlockPtr + 700) = creationFlags;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2c0) = allocationContext;
    *(uint32_t *)(systemMemoryBlockPtr + 0x2c4) = unsignedSystemValue4;
  }
  *(void*2 *)(nextDataIndex + 0x3c0) = 0xffff;
  FUN_180077150();
  if ((*(long long *)(systemMemoryBlockPtr + 600) == 0) &&
     ((*(uint *)(*(long long *)(systemMemoryBlockPtr + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)HashBucketNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(HashBucketNode + 9) = 0xffffffff;
    *HashBucketNode = 0;
    HashBucketNode[2] = 0;
    HashBucketNode[7] = 0;
    *(uint32_t *)(HashBucketNode + 5) = 0xffffffff;
    *(uint32_t *)(HashBucketNode + 4) = 0xffffffff;
    HashBucketNode[3] = 0;
    *(uint32_t *)(HashBucketNode + 8) = 0;
    *(uint32_t *)(HashBucketNode + 1) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x44) = 0;
    *(uint8_t *)((long long)HashBucketNode + 0x24) = 0;
    *(void* **)(systemMemoryBlockPtr + 600) = HashBucketNode;
  }
  return;
}





// 函数: void FUN_1800783b0(void)
void FUN_1800783b0(void)

{
  void* *pointerToUnsigned1;
  long long systemMemoryBlockPtr;
  void* systemDataIndexPtr;
  
  if ((*(uint *)(*(long long *)(systemMemoryBlockPtr + 0x1b8) + 0x388) >> 0x19 & 1) != 0) {
    pointerToUnsigned1 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)pointerToUnsigned1 + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(pointerToUnsigned1 + 9) = 0xffffffff;
    *pointerToUnsigned1 = systemDataIndexPtr;
    pointerToUnsigned1[2] = systemDataIndexPtr;
    pointerToUnsigned1[7] = systemDataIndexPtr;
    *(uint32_t *)(pointerToUnsigned1 + 5) = 0xffffffff;
    *(uint32_t *)(pointerToUnsigned1 + 4) = 0xffffffff;
    pointerToUnsigned1[3] = systemDataIndexPtr;
    *(int *)(pointerToUnsigned1 + 8) = (int)systemDataIndexPtr;
    *(int *)(pointerToUnsigned1 + 1) = (int)systemDataIndexPtr;
    *(char*)((long long)pointerToUnsigned1 + 0x44) = (char)systemDataIndexPtr;
    *(char*)((long long)pointerToUnsigned1 + 0x24) = (char)systemDataIndexPtr;
    *(void* **)(systemMemoryBlockPtr + 600) = pointerToUnsigned1;
  }
  return;
}



void* * FUN_1800784e0(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  void* systemStatus;
  
  systemStatus = 0xfffffffffffffffe;
  *ResourceManagerPointer = &UNK_180a001e8;
  FUN_180078550();
  ConfigureSystemMemoryRegion(ResourceManagerPointer + 1,8,7,InitializeMemoryManager,systemStatus);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0x158);
  }
  return ResourceManagerPointer;
}





// 函数: void FUN_180078550(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FUN_180078550(void* *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long localResourceOffset;
  uint32_t unsignedSystemValue4;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  if (0 < *(int *)(SystemDataBufferPointer + 0x40)) {
    ResourceManagerPointer[0x26] = *(void* *)(SystemDataBufferPointer + 0x38);
  }
  resourcePoolPointer = ResourceManagerPointer + 1;
  localResourceOffset = 7;
  do {
    PrimaryResourcePointer = (long long *)*resourcePoolPointer;
    *resourcePoolPointer = 0;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
    resourcePoolPointer = resourcePoolPointer + 1;
    localResourceOffset = localResourceOffset + -1;
  } while (localResourceOffset != 0);
  ResourceManagerPointer[0x20] = 0x3f8000003f800000;
  ResourceManagerPointer[0x21] = 0x3f8000003f800000;
  ResourceManagerPointer[0x22] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x23) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x11c) = 0x3f800000;
  ResourceManagerPointer[0x24] = 0x3f800000;
  *(uint32_t *)(ResourceManagerPointer + 0x25) = 0;
  *(void* *)((long long)ResourceManagerPointer + 0x13c) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x144) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x29) = 0x3f800000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x14c) = 0x3f800000;
  *(void*2 *)(ResourceManagerPointer + 0x2a) = 0;
  *(uint8_t *)((long long)ResourceManagerPointer + 0x152) = 1;
  *(uint32_t *)(ResourceManagerPointer + 0x27) = 0;
  ResourceManagerPointer[8] = 0x3f800000;
  ResourceManagerPointer[9] = 0;
  ResourceManagerPointer[10] = 0x3f80000000000000;
  ResourceManagerPointer[0xb] = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xc) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 100) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xd) = 0x3f800000;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x6c) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xe) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x74) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xf) = 0;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x7c) = 0x3f800000;
  if ((void* *)*ResourceManagerPointer == &UNK_180a001e8) {
    ResourceManagerPointer[0x10] = ResourceManagerPointer[8];
    ResourceManagerPointer[0x11] = ResourceManagerPointer[9];
    ResourceManagerPointer[0x12] = ResourceManagerPointer[10];
    ResourceManagerPointer[0x13] = ResourceManagerPointer[0xb];
    *(uint32_t *)(ResourceManagerPointer + 0x14) = *(uint32_t *)(ResourceManagerPointer + 0xc);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xa4) = *(uint32_t *)((long long)ResourceManagerPointer + 100);
    *(uint32_t *)(ResourceManagerPointer + 0x15) = *(uint32_t *)(ResourceManagerPointer + 0xd);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xac) = *(uint32_t *)((long long)ResourceManagerPointer + 0x6c);
    *(uint32_t *)(ResourceManagerPointer + 0x16) = *(uint32_t *)(ResourceManagerPointer + 0xe);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xb4) = *(uint32_t *)((long long)ResourceManagerPointer + 0x74);
    *(uint32_t *)(ResourceManagerPointer + 0x17) = *(uint32_t *)(ResourceManagerPointer + 0xf);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xbc) = *(uint32_t *)((long long)ResourceManagerPointer + 0x7c);
    unsignedSystemValue4 = FUN_180084ae0();
    *(uint32_t *)((long long)ResourceManagerPointer + 0x8c) = 0;
    *(uint32_t *)((long long)ResourceManagerPointer + 0x9c) = 0;
    *(uint32_t *)((long long)ResourceManagerPointer + 0xac) = 0;
    *(uint32_t *)((long long)ResourceManagerPointer + 0xbc) = 0x3f800000;
    FUN_180084760(unsignedSystemValue4,ResourceManagerPointer + 0x18);
  }
  else {
    (**(code **)((void* *)*ResourceManagerPointer + 0x10))(ResourceManagerPointer,0,AdditionalParameter,ConfigurationFlag,currentThreadId);
  }
  return;
}





// 函数: void FUN_1800786e0(void* *ResourceManagerPointer,long long ConfigurationDataPointer)
void FUN_1800786e0(void* *ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long nextDataIndex;
  uint32_t creationFlags;
  long long *plocalResourceOffset;
  void* unsignedSystemValue4;
  float *pfloatValue5;
  void* *resourceEntryPointer;
  long long localDataIndex;
  long long *plocalMemoryAddress;
  int systemId;
  float FloatScaleFactor;
  uint32_t systemStatus1;
  uint32_t systemStatus2;
  uint32_t systemStatus3;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  float floatValue31;
  long long *plStackX_8;
  void* auStackX_10 [2];
  void* uStackX_20;
  void* processFlags58;
  void* unsignedValue50;
  uint32_t unsignedValue40;
  
  systemId = 0;
  plocalMemoryAddress = ResourceManagerPointer + 1;
  do {
    plocalResourceOffset = (long long *)GetResourceConfigurationPointer(ConfigurationDataPointer,systemId);
    if (plocalResourceOffset != (long long *)0x0) {
      plStackX_8 = plocalResourceOffset;
      (**(code **)(*plocalResourceOffset + 0x28))(plocalResourceOffset);
    }
    plStackX_8 = (long long *)*plocalMemoryAddress;
    *plocalMemoryAddress = (long long)plocalResourceOffset;
    if (plStackX_8 != (long long *)0x0) {
      (**(code **)(*plStackX_8 + 0x38))();
    }
    if ((((*(char *)(ConfigurationDataPointer + 0x380) != '\0') && (*(char *)(ConfigurationDataPointer + 0x381) == '\0')) &&
        (nextDataIndex = *plocalMemoryAddress, nextDataIndex != 0)) && ((*(uint *)(nextDataIndex + 0x328) & 0x200000) == 0)) {
      resourceEntryPointer = &SystemStringTemplate;
      if (*(void* **)(nextDataIndex + 0x18) != (void* *)0x0) {
        resourceEntryPointer = *(void* **)(nextDataIndex + 0x18);
      }
      AllocateSystemMemory(&SystemResourceDataBuffer,resourceEntryPointer);
    }
    systemId = systemId + 1;
    plocalMemoryAddress = plocalMemoryAddress + 1;
  } while (systemId < 7);
  unsignedSystemValue4 = GetSystemResourceIdentifier(ConfigurationDataPointer,&processFlags58);
  nextDataIndex = SystemDataBufferPointer;
  systemId = FindSystemDataIndex(SystemDataBufferPointer,unsignedSystemValue4);
  if ((systemId == -1) || (localDataIndex = (long long)systemId * 0x68 + *(long long *)(nextDataIndex + 0x38), localDataIndex == 0)) {
    localDataIndex = *(long long *)(nextDataIndex + 0x28);
  }
  processFlags58 = &SystemGlobalDataReference;
  if (unsignedValue50 != 0) {
      SystemCleanupFunction();
  }
  unsignedValue50 = 0;
  unsignedValue40 = 0;
  processFlags58 = &SystemMemoryAllocatorReference;
  if (localDataIndex == 0) {
    localDataIndex = *(long long *)(SystemDataBufferPointer + 0x38);
  }
  ResourceManagerPointer[0x26] = localDataIndex;
  if ((*(char *)(ConfigurationDataPointer + 0x248) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc730();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x240);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x114) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x254) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc760();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x24c);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x23) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2f0) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ProcessResourceConfigurationData(*(long long *)(ConfigurationDataPointer + 0x3c8),&processFlags58);
    creationFlags = (uint32_t)processFlags58;
    systemStatus1 = processFlags58._4_4_;
    systemStatus2 = (uint32_t)unsignedValue50;
    systemStatus3 = unsignedValue50._4_4_;
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2d0);
    systemStatus1 = *(uint32_t *)(ConfigurationDataPointer + 0x2d4);
    systemStatus2 = *(uint32_t *)(ConfigurationDataPointer + 0x2d8);
    systemStatus3 = *(uint32_t *)(ConfigurationDataPointer + 0x2dc);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x20) = creationFlags;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x104) = systemStatus1;
  *(uint32_t *)(ResourceManagerPointer + 0x21) = systemStatus2;
  *(uint32_t *)((long long)ResourceManagerPointer + 0x10c) = systemStatus3;
  if ((*(char *)(ConfigurationDataPointer + 0x2fc) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fca90();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2f4);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x22) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x260) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fcac0();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 600);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x11c) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x26c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fcb00();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x264);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x24) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x278) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fcb40();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x270);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x124) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x284) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fcb80();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x27c);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x25) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x290) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc7a0();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x288);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x27) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x29c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc7d0();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x294);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x13c) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2a8) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc800();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2a0);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x28) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2b4) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc840();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2ac);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x144) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2c0) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc880();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2b8);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x29) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2cc) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc8c0();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2c4);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x14c) = creationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x29c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    creationFlags = func_0x0001801fc7d0();
  }
  else {
    creationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x294);
  }
  *(uint32_t *)((long long)ResourceManagerPointer + 0x13c) = creationFlags;
  *(uint8_t *)((long long)ResourceManagerPointer + 0x152) = *(uint8_t *)(ConfigurationDataPointer + 0x380);
  *(uint8_t *)(ResourceManagerPointer + 0x2a) = *(uint8_t *)(ConfigurationDataPointer + 0x381);
  if ((*(char *)(ConfigurationDataPointer + 0x35c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ValidateResourceConfiguration(*(long long *)(ConfigurationDataPointer + 0x3c8),&plStackX_8);
  }
  else {
    plStackX_8 = *(long long **)(ConfigurationDataPointer + 0x34c);
  }
  if ((*(char *)(ConfigurationDataPointer + 0x348) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    InitializeResourceConfiguration(*(long long *)(ConfigurationDataPointer + 0x3c8),auStackX_10);
  }
  else {
    auStackX_10[0] = *(void* *)(ConfigurationDataPointer + 0x338);
  }
  if ((*(char *)(ConfigurationDataPointer + 0x334) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ProcessResourceConfiguration(*(long long *)(ConfigurationDataPointer + 0x3c8),&uStackX_20);
  }
  else {
    uStackX_20 = *(void* *)(ConfigurationDataPointer + 0x324);
  }
  if ((*(char *)(ConfigurationDataPointer + 800) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ConfigureResourceSettings(*(long long *)(ConfigurationDataPointer + 0x3c8),&processFlags58);
  }
  else {
    processFlags58 = *(void* **)(ConfigurationDataPointer + 0x300);
    unsignedValue50 = *(void* *)(ConfigurationDataPointer + 0x308);
  }
  FUN_180084c70(ResourceManagerPointer + 8,&processFlags58,&uStackX_20,auStackX_10,&plStackX_8);
  if ((void* *)*ResourceManagerPointer == &UNK_180a001e8) {
    pfloatValue5 = (float *)(ResourceManagerPointer + 0x10);
    *(void* *)pfloatValue5 = ResourceManagerPointer[8];
    ResourceManagerPointer[0x11] = ResourceManagerPointer[9];
    ResourceManagerPointer[0x12] = ResourceManagerPointer[10];
    ResourceManagerPointer[0x13] = ResourceManagerPointer[0xb];
    *(uint32_t *)(ResourceManagerPointer + 0x14) = *(uint32_t *)(ResourceManagerPointer + 0xc);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xa4) = *(uint32_t *)((long long)ResourceManagerPointer + 100);
    *(uint32_t *)(ResourceManagerPointer + 0x15) = *(uint32_t *)(ResourceManagerPointer + 0xd);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xac) = *(uint32_t *)((long long)ResourceManagerPointer + 0x6c);
    *(uint32_t *)(ResourceManagerPointer + 0x16) = *(uint32_t *)(ResourceManagerPointer + 0xe);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xb4) = *(uint32_t *)((long long)ResourceManagerPointer + 0x74);
    *(uint32_t *)(ResourceManagerPointer + 0x17) = *(uint32_t *)(ResourceManagerPointer + 0xf);
    *(uint32_t *)((long long)ResourceManagerPointer + 0xbc) = *(uint32_t *)((long long)ResourceManagerPointer + 0x7c);
    FUN_180084ae0();
    *(uint32_t *)((long long)ResourceManagerPointer + 0x8c) = 0;
    *(uint32_t *)((long long)ResourceManagerPointer + 0x9c) = 0;
    *(uint32_t *)((long long)ResourceManagerPointer + 0xac) = 0;
    *(uint32_t *)((long long)ResourceManagerPointer + 0xbc) = 0x3f800000;
    magnitudeSquared1 = pfloatValue5[6];
    interpolationFactor4 = pfloatValue5[0xd];
    FloatScaleFactor = pfloatValue5[9];
    interpolationFactor5 = pfloatValue5[1];
    scaleResult1 = pfloatValue5[0xe];
    floatValue23 = pfloatValue5[2];
    floatValue25 = pfloatValue5[10];
    floatValue28 = pfloatValue5[5];
    floatValue24 = interpolationFactor3 * FloatScaleFactor - interpolationFactor4 * floatValue25;
    floatValue21 = interpolationFactor3 * floatValue28 - interpolationFactor4 * magnitudeSquared1;
    floatValue22 = interpolationFactor3 * interpolationFactor5 - interpolationFactor4 * floatValue23;
    floatValue29 = floatValue28 * floatValue25 - FloatScaleFactor * magnitudeSquared1;
    floatValue20 = interpolationFactor5 * floatValue25 - FloatScaleFactor * floatValue23;
    *(float *)(ResourceManagerPointer + 0x18) = floatValue29;
    floatValue19 = interpolationFactor5 * magnitudeSquared1 - floatValue28 * floatValue23;
    floatValue30 = floatValue23 * pfloatValue5[9] - floatValue25 * pfloatValue5[1];
    *(float *)((long long)ResourceManagerPointer + 0xc4) = floatValue30;
    interpolationFactor4 = pfloatValue5[5];
    scaleResult1 = pfloatValue5[1];
    *(uint32_t *)((long long)ResourceManagerPointer + 0xcc) = 0;
    floatValue31 = magnitudeSquared1 * interpolationFactor3 - floatValue23 * interpolationFactor4;
    *(float *)(ResourceManagerPointer + 0x19) = floatValue31;
    interpolationFactor2 = magnitudeSquared1 * pfloatValue5[8] - floatValue25 * pfloatValue5[4];
    *(float *)(ResourceManagerPointer + 0x1a) = interpolationFactor2;
    floatValue27 = floatValue25 * *pfloatValue5 - floatValue23 * pfloatValue5[8];
    *(float *)((long long)ResourceManagerPointer + 0xd4) = floatValue27;
    interpolationFactor4 = pfloatValue5[4];
    scaleResult1 = *pfloatValue5;
    *(uint32_t *)((long long)ResourceManagerPointer + 0xdc) = 0;
    floatValue26 = floatValue23 * interpolationFactor4 - magnitudeSquared1 * interpolationFactor3;
    *(float *)(ResourceManagerPointer + 0x1b) = floatValue26;
    scaleResult1 = FloatScaleFactor * pfloatValue5[4] - floatValue28 * pfloatValue5[8];
    *(float *)(ResourceManagerPointer + 0x1c) = interpolationFactor3;
    FloatScaleFactor = interpolationFactor5 * pfloatValue5[8] - FloatScaleFactor * *pfloatValue5;
    *(float *)((long long)ResourceManagerPointer + 0xe4) = FloatScaleFactor;
    magnitudeSquared1 = pfloatValue5[4];
    interpolationFactor4 = *pfloatValue5;
    *(uint32_t *)((long long)ResourceManagerPointer + 0xec) = 0;
    floatValue28 = floatValue28 * interpolationFactor4 - interpolationFactor5 * magnitudeSquared1;
    *(float *)(ResourceManagerPointer + 0x1d) = floatValue28;
    interpolationFactor4 = (floatValue21 * pfloatValue5[8] - floatValue24 * pfloatValue5[4]) - floatValue29 * pfloatValue5[0xc];
    *(float *)(ResourceManagerPointer + 0x1e) = interpolationFactor4;
    floatValue25 = (floatValue24 * *pfloatValue5 - floatValue22 * pfloatValue5[8]) + floatValue20 * pfloatValue5[0xc];
    *(float *)((long long)ResourceManagerPointer + 0xf4) = floatValue25;
    floatValue23 = (floatValue22 * pfloatValue5[4] - floatValue21 * *pfloatValue5) - floatValue19 * pfloatValue5[0xc];
    *(float *)(ResourceManagerPointer + 0x1f) = floatValue23;
    interpolationFactor5 = (floatValue29 * *pfloatValue5 - floatValue20 * pfloatValue5[4]) + floatValue19 * pfloatValue5[8];
    *(float *)((long long)ResourceManagerPointer + 0xfc) = interpolationFactor5;
    magnitudeSquared1 = floatValue30 * pfloatValue5[4] + floatValue29 * *pfloatValue5 + floatValue31 * pfloatValue5[8];
    if (magnitudeSquared1 != 1.0) {
      magnitudeSquared1 = 1.0 / magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x1a) = interpolationFactor2 * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x1c) = interpolationFactor3 * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x18) = floatValue29 * magnitudeSquared1;
      *(float *)((long long)ResourceManagerPointer + 0xc4) = floatValue30 * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x19) = floatValue31 * magnitudeSquared1;
      *(float *)((long long)ResourceManagerPointer + 0xd4) = floatValue27 * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x1b) = floatValue26 * magnitudeSquared1;
      *(float *)((long long)ResourceManagerPointer + 0xe4) = FloatScaleFactor * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x1d) = floatValue28 * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x1e) = interpolationFactor4 * magnitudeSquared1;
      *(float *)((long long)ResourceManagerPointer + 0xf4) = floatValue25 * magnitudeSquared1;
      *(float *)(ResourceManagerPointer + 0x1f) = floatValue23 * magnitudeSquared1;
      *(float *)((long long)ResourceManagerPointer + 0xfc) = interpolationFactor5 * magnitudeSquared1;
    }
    return;
  }
  (**(code **)((void* *)*ResourceManagerPointer + 0x10))(ResourceManagerPointer);
  return;
}




// 函数: void FUN_180078c10(long long ResourceManagerPointer)
void FUN_180078c10(long long ResourceManagerPointer)

{
  float *pfloatValue1;
  float FloatVariable2;
  float FloatVariable3;
  float FloatVariable4;
  float floatValue5;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  float interpolationFactor3;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  
  pfloatValue1 = (float *)(ResourceManagerPointer + 0x80);
  *(void* *)pfloatValue1 = *(void* *)(ResourceManagerPointer + 0x40);
  *(void* *)(ResourceManagerPointer + 0x88) = *(void* *)(ResourceManagerPointer + 0x48);
  *(void* *)(ResourceManagerPointer + 0x90) = *(void* *)(ResourceManagerPointer + 0x50);
  *(void* *)(ResourceManagerPointer + 0x98) = *(void* *)(ResourceManagerPointer + 0x58);
  *(uint32_t *)(ResourceManagerPointer + 0xa0) = *(uint32_t *)(ResourceManagerPointer + 0x60);
  *(uint32_t *)(ResourceManagerPointer + 0xa4) = *(uint32_t *)(ResourceManagerPointer + 100);
  *(uint32_t *)(ResourceManagerPointer + 0xa8) = *(uint32_t *)(ResourceManagerPointer + 0x68);
  *(uint32_t *)(ResourceManagerPointer + 0xac) = *(uint32_t *)(ResourceManagerPointer + 0x6c);
  *(uint32_t *)(ResourceManagerPointer + 0xb0) = *(uint32_t *)(ResourceManagerPointer + 0x70);
  *(uint32_t *)(ResourceManagerPointer + 0xb4) = *(uint32_t *)(ResourceManagerPointer + 0x74);
  *(uint32_t *)(ResourceManagerPointer + 0xb8) = *(uint32_t *)(ResourceManagerPointer + 0x78);
  *(uint32_t *)(ResourceManagerPointer + 0xbc) = *(uint32_t *)(ResourceManagerPointer + 0x7c);
  FUN_180084ae0();
  *(uint32_t *)(ResourceManagerPointer + 0xbc) = 0x3f800000;
  *(uint32_t *)(ResourceManagerPointer + 0x8c) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0x9c) = 0;
  *(uint32_t *)(ResourceManagerPointer + 0xac) = 0;
  floatValue7 = pfloatValue1[6];
  floatValue5 = pfloatValue1[0xd];
  floatValue2 = pfloatValue1[9];
  floatValue6 = pfloatValue1[1];
  floatValue4 = pfloatValue1[0xe];
  FloatRatioValue = pfloatValue1[2];
  interpolationFactor2 = pfloatValue1[10];
  interpolationFactor5 = pfloatValue1[5];
  interpolationFactor1 = floatValue4 * floatValue2 - floatValue5 * interpolationFactor2;
  FloatScaleFactor = floatValue4 * interpolationFactor5 - floatValue5 * floatValue7;
  floatValue11 = floatValue4 * floatValue6 - floatValue5 * FloatRatioValue;
  magnitudeSquared1 = interpolationFactor5 * interpolationFactor2 - floatValue2 * floatValue7;
  floatValue9 = floatValue6 * interpolationFactor2 - floatValue2 * FloatRatioValue;
  *(float *)(ResourceManagerPointer + 0xc0) = magnitudeSquared1;
  floatValue8 = floatValue6 * floatValue7 - interpolationFactor5 * FloatRatioValue;
  floatValue19 = FloatRatioValue * pfloatValue1[9] - interpolationFactor2 * pfloatValue1[1];
  *(float *)(ResourceManagerPointer + 0xc4) = floatValue19;
  floatValue5 = pfloatValue1[5];
  floatValue4 = pfloatValue1[1];
  *(uint32_t *)(ResourceManagerPointer + 0xcc) = 0;
  floatValue20 = floatValue7 * floatValue4 - FloatRatioValue * floatValue5;
  *(float *)(ResourceManagerPointer + 200) = floatValue20;
  floatValue3 = floatValue7 * pfloatValue1[8] - interpolationFactor2 * pfloatValue1[4];
  *(float *)(ResourceManagerPointer + 0xd0) = floatValue3;
  interpolationFactor4 = interpolationFactor2 * *pfloatValue1 - FloatRatioValue * pfloatValue1[8];
  *(float *)(ResourceManagerPointer + 0xd4) = interpolationFactor4;
  floatValue5 = pfloatValue1[4];
  floatValue4 = *pfloatValue1;
  *(uint32_t *)(ResourceManagerPointer + 0xdc) = 0;
  scaleResult1 = FloatRatioValue * floatValue5 - floatValue7 * floatValue4;
  *(float *)(ResourceManagerPointer + 0xd8) = interpolationFactor3;
  floatValue4 = floatValue2 * pfloatValue1[4] - interpolationFactor5 * pfloatValue1[8];
  *(float *)(ResourceManagerPointer + 0xe0) = floatValue4;
  floatValue2 = floatValue6 * pfloatValue1[8] - floatValue2 * *pfloatValue1;
  *(float *)(ResourceManagerPointer + 0xe4) = floatValue2;
  floatValue7 = pfloatValue1[4];
  floatValue5 = *pfloatValue1;
  *(uint32_t *)(ResourceManagerPointer + 0xec) = 0;
  interpolationFactor5 = interpolationFactor5 * floatValue5 - floatValue6 * floatValue7;
  *(float *)(ResourceManagerPointer + 0xe8) = interpolationFactor5;
  floatValue5 = (FloatScaleFactor * pfloatValue1[8] - interpolationFactor1 * pfloatValue1[4]) - magnitudeSquared1 * pfloatValue1[0xc];
  *(float *)(ResourceManagerPointer + 0xf0) = floatValue5;
  interpolationFactor2 = (interpolationFactor1 * *pfloatValue1 - floatValue11 * pfloatValue1[8]) + floatValue9 * pfloatValue1[0xc];
  *(float *)(ResourceManagerPointer + 0xf4) = interpolationFactor2;
  FloatRatioValue = (floatValue11 * pfloatValue1[4] - FloatScaleFactor * *pfloatValue1) - floatValue8 * pfloatValue1[0xc];
  *(float *)(ResourceManagerPointer + 0xf8) = FloatRatioValue;
  floatValue6 = (magnitudeSquared1 * *pfloatValue1 - floatValue9 * pfloatValue1[4]) + floatValue8 * pfloatValue1[8];
  *(float *)(ResourceManagerPointer + 0xfc) = floatValue6;
  floatValue7 = floatValue19 * pfloatValue1[4] + magnitudeSquared1 * *pfloatValue1 + floatValue20 * pfloatValue1[8];
  if (floatValue7 != 1.0) {
    floatValue7 = 1.0 / floatValue7;
    *(float *)(ResourceManagerPointer + 0xd0) = floatValue3 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xe0) = floatValue4 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xc0) = magnitudeSquared1 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xc4) = floatValue19 * floatValue7;
    *(float *)(ResourceManagerPointer + 200) = floatValue20 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xd4) = interpolationFactor4 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xd8) = interpolationFactor3 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xe4) = floatValue2 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xe8) = interpolationFactor5 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xf0) = floatValue5 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xf4) = interpolationFactor2 * floatValue7;
    *(float *)(ResourceManagerPointer + 0xf8) = FloatRatioValue * floatValue7;
    *(float *)(ResourceManagerPointer + 0xfc) = floatValue6 * floatValue7;
  }
  return;
}




// 函数: void FUN_180078c70(uint32_t *ResourceManagerPointer,long long *ConfigurationDataPointer)
void FUN_180078c70(uint32_t *ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  uint32_t systemStatus;
  uint32_t *HashEntryStatus;
  
  systemStatus = *ResourceManagerPointer;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[2];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[3];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[5];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[6];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[7];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[9];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[10];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0xb];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0xd];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0xe];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0xf];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0x11];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0x12];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0x13];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0x14];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0x15];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashEntryStatus = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashEntryStatus = (uint32_t *)ConfigurationDataPointer[1];
  systemStatus = ResourceManagerPointer[0x16];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashEntryStatus) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashEntryStatus + (4 - *ConfigurationDataPointer));
    *(uint32_t *)ConfigurationDataPointer[1] = systemStatus;
  }
  else {
    *HashEntryStatus = systemStatus;
  }
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  return;
}




// 函数: void FUN_1800791a0(long long ResourceManagerPointer)
/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理器的各种参数和状态。
 * 包括资源句柄、系统状态标志和资源数据的初始化。
 * 
 * @param ResourceManagerPointer 资源管理器指针，指向需要初始化的资源管理器
 * 
 * 原始函数名为FUN_1800791a0，现已重命名为InitializeSystemResourceManagerEx
 */
void InitializeSystemResourceManagerEx(long long ResourceManagerPointer)

{
  long long systemDataIndex;
  long long systemResourceHandle;
  byte systemConfigurationFlag;
  
  systemResourceHandle = *(long long *)(ResourceManagerPointer + 0x210);
  *(uint32_t *)(ResourceManagerPointer + 0x1f8) = *(uint32_t *)(systemResourceHandle + 0x10);
  *(uint32_t *)(ResourceManagerPointer + 0x1fc) = *(uint32_t *)(systemResourceHandle + 0x88);
  *(uint32_t *)(ResourceManagerPointer + 0x200) = *(uint32_t *)(systemResourceHandle + 0x60);
  systemConfigurationFlag = *(byte *)(ResourceManagerPointer + 0xfd) & 0x40;
  if ((((systemConfigurationFlag != 0) && (systemResourceHandle != 0)) || (*(long long *)(ResourceManagerPointer + 0x1b0) == 0)) ||
     (systemDataIndex = GetSystemConfigurationStatus(), ResourceManagerPointer == systemDataIndex)) {
    *(uint32_t *)(ResourceManagerPointer + 0x204) = *(uint32_t *)(systemResourceHandle + 200);
  }
  if (((systemConfigurationFlag == 0) || (systemResourceHandle == 0)) &&
     ((*(long long *)(ResourceManagerPointer + 0x1b0) != 0 && (systemDataIndex = GetSystemConfigurationStatus(), ResourceManagerPointer != systemDataIndex)))) {
    return;
  }
  *(uint *)(ResourceManagerPointer + 0x208) = (uint)*(ushort *)(systemResourceHandle + 0xc0);
  return;
}





// 函数: void FUN_180079270(long long ResourceManagerPointer,long long ConfigurationDataPointer)
/**
 * @brief 系统资源配置处理函数
 * 
 * 该函数负责处理系统资源的配置和初始化，包括资源分配、
 * 状态设置和数据传输等功能。这是系统资源管理的重要组成部分。
 * 
 * @param ResourceManagerPointer 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_180079270，现已重命名为ProcessSystemResourceConfiguration
 */
void ProcessSystemResourceConfiguration(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long *primaryResourcePointer;
  int *systemCounterPointer;
  long long *resourceOffsetPointer;
  byte *systemDataPointer;
  void* *threadIdPointer;
  float scaleFactor1;
  float scaleFactor2;
  float scaleFactor3;
  float scaleFactor4;
  float scaleFactor5;
  float scaleFactor6;
  float scaleFactor7;
  float scaleFactor8;
  float scaleFactor9;
  uint8_t systemStatus5;
  char CharacterVariable16;
  long long nextDataIndex7;
  float *pmagnitudeSquared1;
  float floatValue19;
  float floatValue20;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  void* allocationContext1;
  uint32_t allocationContext2;
  long long localResourceOffset3;
  long long *plocalResourceOffset4;
  long long localResourceOffset5;
  uint allocationContext6;
  int systemCounter7;
  uint allocationContext8;
  int systemCounter9;
  ulong long unsignedSystemValue40;
  char *psystemStatusFlag1;
  uint *punsignedSystemValue42;
  int systemIndex3;
  int systemIndex4;
  int systemIndex5;
  uint32_t *punsignedSystemValue46;
  uint *punsignedSystemValue47;
  ulong long unsignedSystemValue48;
  ulong long unsignedSystemValue49;
  bool isMemoryReady0;
  
  nextDataIndex7 = SystemMemoryContext;
  localResourceOffset3 = ResourceManagerPointer;
  if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    localResourceOffset3 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  LOCK();
  pointerToInteger2 = (int *)(nextDataIndex7 + 0xed8);
  systemIndex3 = *pointerToInteger2;
  *pointerToInteger2 = *pointerToInteger2 + *(int *)(localResourceOffset3 + 0x200);
  UNLOCK();
  nextDataIndex7 = *(long long *)(ResourceManagerPointer + 600);
  systemStatus5 = *(uint8_t *)(ConfigurationDataPointer + 0x24);
  allocationContext2 = *(uint32_t *)(ConfigurationDataPointer + 0x20);
  charStatus6 = *(char *)(ConfigurationDataPointer + 0xd);
  *(uint32_t *)(nextDataIndex7 + 0x48) = *(uint32_t *)(nextDataIndex7 + 0x2c);
  *(uint32_t *)(nextDataIndex7 + 0x50) = *(uint32_t *)(nextDataIndex7 + 0x4c);
  *(int *)(nextDataIndex7 + 0x4c) = systemIndex3;
  *(uint8_t *)(nextDataIndex7 + 0x44) = systemStatus5;
  *(uint32_t *)(nextDataIndex7 + 0x2c) = allocationContext2;
  if (charStatus6 != -1) {
    allocationContext8 = (int)*(char *)(ConfigurationDataPointer + 0xd) + *(int *)(ConfigurationDataPointer + 0x18);
    pmagnitudeSquared1 = (float *)**(long long **)(ResourceManagerPointer + 600);
    allocationContext6 = allocationContext8 >> 0xd;
    nextDataIndex7 = *(long long *)
              ((long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc30 +
              (ulong long)allocationContext6 * 8);
    localResourceOffset3 = (ulong long)(allocationContext8 + allocationContext6 * -0x2000) * 0x40;
    allocationContext1 = ((void* *)(nextDataIndex7 + localResourceOffset3))[1];
    *(void* *)pmagnitudeSquared1 = *(void* *)(nextDataIndex7 + localResourceOffset3);
    *(void* *)(pmagnitudeSquared1 + 2) = allocationContext1;
    pcurrentThreadId = (void* *)(nextDataIndex7 + 0x10 + localResourceOffset3);
    allocationContext1 = pcurrentThreadId[1];
    *(void* *)(pmagnitudeSquared1 + 4) = *pcurrentThreadId;
    *(void* *)(pmagnitudeSquared1 + 6) = allocationContext1;
    pcurrentThreadId = (void* *)(nextDataIndex7 + 0x20 + localResourceOffset3);
    allocationContext1 = pcurrentThreadId[1];
    *(void* *)(pmagnitudeSquared1 + 8) = *pcurrentThreadId;
    *(void* *)(pmagnitudeSquared1 + 10) = allocationContext1;
    pcurrentThreadId = (void* *)(nextDataIndex7 + 0x30 + localResourceOffset3);
    allocationContext1 = pcurrentThreadId[1];
    *(void* *)(pmagnitudeSquared1 + 0xc) = *pcurrentThreadId;
    *(void* *)(pmagnitudeSquared1 + 0xe) = allocationContext1;
    nextDataIndex7 = *(long long *)(ConfigurationDataPointer + 0x10);
    floatValue19 = pmagnitudeSquared1[8];
    floatValue20 = pmagnitudeSquared1[9];
    floatValue21 = pmagnitudeSquared1[10];
    floatValue22 = pmagnitudeSquared1[0xb];
    floatValue23 = *pmagnitudeSquared1;
    floatValue24 = pmagnitudeSquared1[1];
    floatValue25 = pmagnitudeSquared1[2];
    floatValue26 = pmagnitudeSquared1[3];
    floatValue27 = pmagnitudeSquared1[4];
    floatValue28 = pmagnitudeSquared1[5];
    floatValue29 = pmagnitudeSquared1[6];
    floatValue30 = pmagnitudeSquared1[7];
    floatValue6 = *(float *)(nextDataIndex7 + 0x374);
    floatValue7 = *(float *)(nextDataIndex7 + 0x370);
    floatValue8 = *(float *)(nextDataIndex7 + 0x378);
    floatValue9 = *(float *)(nextDataIndex7 + 900);
    FloatScaleFactor = *(float *)(nextDataIndex7 + 0x394);
    floatValue11 = *(float *)(nextDataIndex7 + 0x380);
    FloatRatioValue = *(float *)(nextDataIndex7 + 0x388);
    interpolationFactor1 = *(float *)(nextDataIndex7 + 0x390);
    interpolationFactor2 = *(float *)(nextDataIndex7 + 0x398);
    *pmagnitudeSquared1 = floatValue6 * floatValue27 + floatValue7 * floatValue23 + floatValue8 * floatValue19;
    pmagnitudeSquared1[1] = floatValue6 * floatValue28 + floatValue7 * floatValue24 + floatValue8 * floatValue20;
    pmagnitudeSquared1[2] = floatValue6 * floatValue29 + floatValue7 * floatValue25 + floatValue8 * floatValue21;
    pmagnitudeSquared1[3] = floatValue6 * floatValue30 + floatValue7 * floatValue26 + floatValue8 * floatValue22;
    pmagnitudeSquared1[4] = floatValue9 * floatValue27 + floatValue11 * floatValue23 + FloatRatioValue * floatValue19;
    pmagnitudeSquared1[5] = floatValue9 * floatValue28 + floatValue11 * floatValue24 + FloatRatioValue * floatValue20;
    pmagnitudeSquared1[6] = floatValue9 * floatValue29 + floatValue11 * floatValue25 + FloatRatioValue * floatValue21;
    pmagnitudeSquared1[7] = floatValue9 * floatValue30 + floatValue11 * floatValue26 + FloatRatioValue * floatValue22;
    pmagnitudeSquared1[8] = FloatScaleFactor * floatValue27 + interpolationFactor1 * floatValue23 + interpolationFactor2 * floatValue19;
    pmagnitudeSquared1[9] = FloatScaleFactor * floatValue28 + interpolationFactor1 * floatValue24 + interpolationFactor2 * floatValue20;
    pmagnitudeSquared1[10] = FloatScaleFactor * floatValue29 + interpolationFactor1 * floatValue25 + interpolationFactor2 * floatValue21;
    pmagnitudeSquared1[0xb] = FloatScaleFactor * floatValue30 + interpolationFactor1 * floatValue26 + interpolationFactor2 * floatValue22;
  }
  nextDataIndex7 = *(long long *)(ResourceManagerPointer + 600);
  if (*(int *)(nextDataIndex7 + 0x28) != *(int *)(SystemStatusFlagsPointer + 0x224)) {
    systemIndex3 = *(int *)(nextDataIndex7 + 0x1c) + *(int *)(nextDataIndex7 + 0x18);
    *(int *)(nextDataIndex7 + 0x28) = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (0 < systemIndex3) {
      localResourceOffset3 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
      allocationContext2 = FUN_180080380(localResourceOffset3,systemIndex3);
      *(uint32_t *)(nextDataIndex7 + 0x30) = allocationContext2;
      FUN_1800802e0(localResourceOffset3,allocationContext2);
      if (*(long long *)(nextDataIndex7 + 0x10) == 0) {
        if (*(int *)(nextDataIndex7 + 0x18) != 0) {
          *(uint32_t *)(nextDataIndex7 + 0x2c) = *(uint32_t *)(nextDataIndex7 + 0x30);
          return;
        }
      }
      else {
        charStatus6 = *(char *)(nextDataIndex7 + 0x44);
        unsignedSystemValue40 = (ulong long)charStatus6;
        PrimaryResourcePointer = (long long *)(nextDataIndex7 + 0x38);
        systemIndex3 = (int)charStatus6;
        if (*(int *)(nextDataIndex7 + 0x40) == (int)charStatus6) {
          plocalResourceOffset4 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(nextDataIndex7 + 0x40) = systemIndex3;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus6 == '\0') {
            plocalResourceOffset4 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalResourceOffset4 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus6 * 4);
            *PrimaryResourcePointer = (long long)plocalResourceOffset4;
          }
        }
        if (plocalResourceOffset4 != (long long *)0x0) {
          systemIndex4 = 0;
          allocationContext6 = (uint)charStatus6;
          systemIndex5 = systemIndex4;
          if ((0 < systemIndex3) && (0xf < allocationContext6)) {
            systemCounter9 = *(int *)(nextDataIndex7 + 0x2c);
            plocalResourceOffset = (long long *)((long long)plocalResourceOffset4 + (long long)(charStatus6 + -1) * 4);
            if ((((long long *)(nextDataIndex7 + 0x2c) < plocalResourceOffset4) || (plocalResourceOffset < (long long *)(nextDataIndex7 + 0x2c)))
               && ((PrimaryResourcePointer < plocalResourceOffset4 || (systemIndex5 = 0, plocalResourceOffset < PrimaryResourcePointer)))) {
              allocationContext8 = allocationContext6 & 0x8000000f;
              if ((int)allocationContext8 < 0) {
                allocationContext8 = (allocationContext8 - 1 | 0xfffffff0) + 1;
              }
              plocalResourceOffset4 = plocalResourceOffset4 + 4;
              systemCounter7 = 8;
              do {
                *(int *)(plocalResourceOffset4 + -4) = systemIndex4 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -0x1c) = systemIndex4 + 1 + systemCounter9;
                *(int *)(plocalResourceOffset4 + -3) = systemIndex4 + 2 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -0x14) = systemIndex4 + 3 + systemCounter9;
                systemIndex4 = systemIndex4 + 0x10;
                *(int *)(plocalResourceOffset4 + -2) = systemCounter7 + -4 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -0xc) = systemCounter7 + -3 + systemCounter9;
                *(int *)(plocalResourceOffset4 + -1) = systemCounter7 + -2 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -4) = systemCounter7 + -1 + systemCounter9;
                *(int *)plocalResourceOffset4 = systemCounter7 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 4) = systemCounter7 + 1 + systemCounter9;
                *(int *)(plocalResourceOffset4 + 1) = systemCounter7 + 2 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 0xc) = systemCounter7 + 3 + systemCounter9;
                *(int *)(plocalResourceOffset4 + 2) = systemCounter7 + 4 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 0x14) = systemCounter7 + 5 + systemCounter9;
                *(int *)(plocalResourceOffset4 + 3) = systemCounter7 + 6 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 0x1c) = systemCounter7 + 7 + systemCounter9;
                plocalResourceOffset4 = plocalResourceOffset4 + 8;
                systemCounter7 = systemCounter7 + 0x10;
                systemIndex5 = systemIndex4;
              } while (systemIndex4 < (int)(allocationContext6 - allocationContext8));
            }
          }
          for (localResourceOffset3 = (long long)systemIndex5; localResourceOffset3 < (long long)unsignedSystemValue40; localResourceOffset3 = localResourceOffset3 + 1) {
            systemIndex4 = *(int *)(nextDataIndex7 + 0x2c) + systemIndex5;
            systemIndex5 = systemIndex5 + 1;
            *(int *)(*PrimaryResourcePointer + localResourceOffset3 * 4) = systemIndex4;
          }
          systemIndex5 = *(int *)(nextDataIndex7 + 0x18);
          systemIndex4 = 0;
          if (0 < (long long)systemIndex5) {
            localResourceOffset3 = 0;
            do {
              systemCounter9 = *(int *)(nextDataIndex7 + 0x30) + systemIndex4;
              systemIndex4 = systemIndex4 + 1;
              pisResourceAvailable = (byte *)(*(long long *)(nextDataIndex7 + 0x10) + localResourceOffset3);
              localResourceOffset3 = localResourceOffset3 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisResourceAvailable * 4) = systemCounter9;
            } while (localResourceOffset3 < systemIndex5);
          }
        }
        punsignedSystemValue42 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 +
                          SystemMemoryContext + 0x9d0);
        if (systemIndex3 == 0) {
          allocationContext6 = (int)charStatus6 - 1;
        }
        else {
          LOCK();
          allocationContext6 = *punsignedSystemValue42;
          *punsignedSystemValue42 = *punsignedSystemValue42 + (int)charStatus6;
          UNLOCK();
          unsignedSystemValue48 = (ulong long)(allocationContext6 >> 0xb);
          unsignedSystemValue49 = (ulong long)(charStatus6 + -1 + allocationContext6 >> 0xb);
          if (unsignedSystemValue48 <= unsignedSystemValue49) {
            psystemStatusFlag1 = (char *)((long long)punsignedSystemValue42 + unsignedSystemValue48 + 0x108);
            localResourceOffset3 = (unsignedSystemValue49 - unsignedSystemValue48) + 1;
            punsignedSystemValue47 = punsignedSystemValue42 + unsignedSystemValue48 * 2 + 2;
            do {
              systemIndex5 = (int)unsignedSystemValue48;
              if (*(long long *)punsignedSystemValue47 == 0) {
                localResourceOffset5 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isMemoryReady0 = *(long long *)(punsignedSystemValue42 + (long long)systemIndex5 * 2 + 2) == 0;
                if (isMemoryReady0) {
                  *(long long *)(punsignedSystemValue42 + (long long)systemIndex5 * 2 + 2) = localResourceOffset5;
                }
                UNLOCK();
                if (isMemoryReady0) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex5 + 0x108 + (long long)punsignedSystemValue42) = 0;
                  UNLOCK();
                }
                else {
                  if (localResourceOffset5 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*psystemStatusFlag1 != '\0');
                }
              }
              else {
                do {
                } while (*psystemStatusFlag1 != '\0');
              }
              unsignedSystemValue48 = (ulong long)(systemIndex5 + 1);
              punsignedSystemValue47 = punsignedSystemValue47 + 2;
              psystemStatusFlag1 = psystemStatusFlag1 + 1;
              localResourceOffset3 = localResourceOffset3 + -1;
            } while (localResourceOffset3 != 0);
          }
        }
        punsignedSystemValue46 = *(uint32_t **)(nextDataIndex7 + 0x38);
        allocationContext8 = allocationContext6 >> 0xb;
        *(uint *)(nextDataIndex7 + 0x2c) = allocationContext6;
        if (allocationContext8 == (int)charStatus6 + allocationContext6 >> 0xb) {
            memcpy(*(long long *)(punsignedSystemValue42 + (ulong long)allocationContext8 * 2 + 2) +
                 (ulong long)(allocationContext6 + allocationContext8 * -0x800) * 4,punsignedSystemValue46,(unsignedSystemValue40 & 0xffffffff) << 2);
        }
        if (systemIndex3 != 0) {
          unsignedSystemValue40 = unsignedSystemValue40 & 0xffffffff;
          do {
            allocationContext2 = *punsignedSystemValue46;
            punsignedSystemValue46 = punsignedSystemValue46 + 1;
            *(uint32_t *)
             (*(long long *)(punsignedSystemValue42 + (ulong long)(allocationContext6 >> 0xb) * 2 + 2) +
             (ulong long)(allocationContext6 + (allocationContext6 >> 0xb) * -0x800) * 4) = allocationContext2;
            unsignedSystemValue40 = unsignedSystemValue40 - 1;
            allocationContext6 = allocationContext6 + 1;
          } while (unsignedSystemValue40 != 0);
        }
      }
    }
  }
  return;
}





// 函数: void FUN_180079284(long long ResourceManagerPointer)
void FUN_180079284(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  long long *plocalResourceOffset;
  byte *pisResourceAvailable;
  void* *pcurrentThreadId;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  float interpolationFactor2;
  uint8_t systemStatus5;
  char CharacterVariable16;
  long long nextDataIndex7;
  float *pmagnitudeSquared1;
  float floatValue19;
  float floatValue20;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  void* allocationContext1;
  uint32_t allocationContext2;
  long long localResourceOffset3;
  long long *plocalResourceOffset4;
  long long localResourceOffset5;
  uint allocationContext6;
  int systemCounter7;
  uint allocationContext8;
  int systemCounter9;
  ulong long unsignedSystemValue40;
  char *psystemStatusFlag1;
  uint *punsignedSystemValue42;
  int systemIndex3;
  long long systemDataIndexPtr;
  int systemIndex4;
  int systemIndex5;
  uint32_t *punsignedSystemValue46;
  uint *punsignedSystemValue47;
  ulong long unsignedSystemValue48;
  ulong long unsignedSystemValue49;
  bool in_ZF;
  bool isMemoryReady0;
  
  nextDataIndex7 = SystemMemoryContext;
  localResourceOffset3 = ResourceManagerPointer;
  if (in_ZF) {
    localResourceOffset3 = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  LOCK();
  pointerToInteger2 = (int *)(nextDataIndex7 + 0xed8);
  systemIndex3 = *pointerToInteger2;
  *pointerToInteger2 = *pointerToInteger2 + *(int *)(localResourceOffset3 + 0x200);
  UNLOCK();
  nextDataIndex7 = *(long long *)(ResourceManagerPointer + 600);
  systemStatus5 = *(uint8_t *)(systemDataIndexPtr + 0x24);
  allocationContext2 = *(uint32_t *)(systemDataIndexPtr + 0x20);
  charStatus6 = *(char *)(systemDataIndexPtr + 0xd);
  *(uint32_t *)(nextDataIndex7 + 0x48) = *(uint32_t *)(nextDataIndex7 + 0x2c);
  *(uint32_t *)(nextDataIndex7 + 0x50) = *(uint32_t *)(nextDataIndex7 + 0x4c);
  *(int *)(nextDataIndex7 + 0x4c) = systemIndex3;
  *(uint8_t *)(nextDataIndex7 + 0x44) = systemStatus5;
  *(uint32_t *)(nextDataIndex7 + 0x2c) = allocationContext2;
  if (charStatus6 != -1) {
    allocationContext8 = (int)*(char *)(systemDataIndexPtr + 0xd) + *(int *)(systemDataIndexPtr + 0x18);
    pmagnitudeSquared1 = (float *)**(long long **)(ResourceManagerPointer + 600);
    allocationContext6 = allocationContext8 >> 0xd;
    nextDataIndex7 = *(long long *)
              ((long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc30 +
              (ulong long)allocationContext6 * 8);
    localResourceOffset3 = (ulong long)(allocationContext8 + allocationContext6 * -0x2000) * 0x40;
    allocationContext1 = ((void* *)(nextDataIndex7 + localResourceOffset3))[1];
    *(void* *)pmagnitudeSquared1 = *(void* *)(nextDataIndex7 + localResourceOffset3);
    *(void* *)(pmagnitudeSquared1 + 2) = allocationContext1;
    pcurrentThreadId = (void* *)(nextDataIndex7 + 0x10 + localResourceOffset3);
    allocationContext1 = pcurrentThreadId[1];
    *(void* *)(pmagnitudeSquared1 + 4) = *pcurrentThreadId;
    *(void* *)(pmagnitudeSquared1 + 6) = allocationContext1;
    pcurrentThreadId = (void* *)(nextDataIndex7 + 0x20 + localResourceOffset3);
    allocationContext1 = pcurrentThreadId[1];
    *(void* *)(pmagnitudeSquared1 + 8) = *pcurrentThreadId;
    *(void* *)(pmagnitudeSquared1 + 10) = allocationContext1;
    pcurrentThreadId = (void* *)(nextDataIndex7 + 0x30 + localResourceOffset3);
    allocationContext1 = pcurrentThreadId[1];
    *(void* *)(pmagnitudeSquared1 + 0xc) = *pcurrentThreadId;
    *(void* *)(pmagnitudeSquared1 + 0xe) = allocationContext1;
    nextDataIndex7 = *(long long *)(systemDataIndexPtr + 0x10);
    floatValue19 = pmagnitudeSquared1[8];
    floatValue20 = pmagnitudeSquared1[9];
    floatValue21 = pmagnitudeSquared1[10];
    floatValue22 = pmagnitudeSquared1[0xb];
    floatValue23 = *pmagnitudeSquared1;
    floatValue24 = pmagnitudeSquared1[1];
    floatValue25 = pmagnitudeSquared1[2];
    floatValue26 = pmagnitudeSquared1[3];
    floatValue27 = pmagnitudeSquared1[4];
    floatValue28 = pmagnitudeSquared1[5];
    floatValue29 = pmagnitudeSquared1[6];
    floatValue30 = pmagnitudeSquared1[7];
    floatValue6 = *(float *)(nextDataIndex7 + 0x374);
    floatValue7 = *(float *)(nextDataIndex7 + 0x370);
    floatValue8 = *(float *)(nextDataIndex7 + 0x378);
    floatValue9 = *(float *)(nextDataIndex7 + 900);
    FloatScaleFactor = *(float *)(nextDataIndex7 + 0x394);
    floatValue11 = *(float *)(nextDataIndex7 + 0x380);
    FloatRatioValue = *(float *)(nextDataIndex7 + 0x388);
    interpolationFactor1 = *(float *)(nextDataIndex7 + 0x390);
    interpolationFactor2 = *(float *)(nextDataIndex7 + 0x398);
    *pmagnitudeSquared1 = floatValue6 * floatValue27 + floatValue7 * floatValue23 + floatValue8 * floatValue19;
    pmagnitudeSquared1[1] = floatValue6 * floatValue28 + floatValue7 * floatValue24 + floatValue8 * floatValue20;
    pmagnitudeSquared1[2] = floatValue6 * floatValue29 + floatValue7 * floatValue25 + floatValue8 * floatValue21;
    pmagnitudeSquared1[3] = floatValue6 * floatValue30 + floatValue7 * floatValue26 + floatValue8 * floatValue22;
    pmagnitudeSquared1[4] = floatValue9 * floatValue27 + floatValue11 * floatValue23 + FloatRatioValue * floatValue19;
    pmagnitudeSquared1[5] = floatValue9 * floatValue28 + floatValue11 * floatValue24 + FloatRatioValue * floatValue20;
    pmagnitudeSquared1[6] = floatValue9 * floatValue29 + floatValue11 * floatValue25 + FloatRatioValue * floatValue21;
    pmagnitudeSquared1[7] = floatValue9 * floatValue30 + floatValue11 * floatValue26 + FloatRatioValue * floatValue22;
    pmagnitudeSquared1[8] = FloatScaleFactor * floatValue27 + interpolationFactor1 * floatValue23 + interpolationFactor2 * floatValue19;
    pmagnitudeSquared1[9] = FloatScaleFactor * floatValue28 + interpolationFactor1 * floatValue24 + interpolationFactor2 * floatValue20;
    pmagnitudeSquared1[10] = FloatScaleFactor * floatValue29 + interpolationFactor1 * floatValue25 + interpolationFactor2 * floatValue21;
    pmagnitudeSquared1[0xb] = FloatScaleFactor * floatValue30 + interpolationFactor1 * floatValue26 + interpolationFactor2 * floatValue22;
  }
  nextDataIndex7 = *(long long *)(ResourceManagerPointer + 600);
  if (*(int *)(nextDataIndex7 + 0x28) != *(int *)(SystemStatusFlagsPointer + 0x224)) {
    systemIndex3 = *(int *)(nextDataIndex7 + 0x1c) + *(int *)(nextDataIndex7 + 0x18);
    *(int *)(nextDataIndex7 + 0x28) = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (0 < systemIndex3) {
      localResourceOffset3 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
      allocationContext2 = FUN_180080380(localResourceOffset3,systemIndex3);
      *(uint32_t *)(nextDataIndex7 + 0x30) = allocationContext2;
      FUN_1800802e0(localResourceOffset3,allocationContext2);
      if (*(long long *)(nextDataIndex7 + 0x10) == 0) {
        if (*(int *)(nextDataIndex7 + 0x18) != 0) {
          *(uint32_t *)(nextDataIndex7 + 0x2c) = *(uint32_t *)(nextDataIndex7 + 0x30);
          return;
        }
      }
      else {
        charStatus6 = *(char *)(nextDataIndex7 + 0x44);
        unsignedSystemValue40 = (ulong long)charStatus6;
        PrimaryResourcePointer = (long long *)(nextDataIndex7 + 0x38);
        systemIndex3 = (int)charStatus6;
        if (*(int *)(nextDataIndex7 + 0x40) == (int)charStatus6) {
          plocalResourceOffset4 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(nextDataIndex7 + 0x40) = systemIndex3;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus6 == '\0') {
            plocalResourceOffset4 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalResourceOffset4 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus6 * 4);
            *PrimaryResourcePointer = (long long)plocalResourceOffset4;
          }
        }
        if (plocalResourceOffset4 != (long long *)0x0) {
          systemIndex4 = 0;
          allocationContext6 = (uint)charStatus6;
          systemIndex5 = systemIndex4;
          if ((0 < systemIndex3) && (0xf < allocationContext6)) {
            systemCounter9 = *(int *)(nextDataIndex7 + 0x2c);
            plocalResourceOffset = (long long *)((long long)plocalResourceOffset4 + (long long)(charStatus6 + -1) * 4);
            if ((((long long *)(nextDataIndex7 + 0x2c) < plocalResourceOffset4) || (plocalResourceOffset < (long long *)(nextDataIndex7 + 0x2c)))
               && ((PrimaryResourcePointer < plocalResourceOffset4 || (systemIndex5 = 0, plocalResourceOffset < PrimaryResourcePointer)))) {
              allocationContext8 = allocationContext6 & 0x8000000f;
              if ((int)allocationContext8 < 0) {
                allocationContext8 = (allocationContext8 - 1 | 0xfffffff0) + 1;
              }
              plocalResourceOffset4 = plocalResourceOffset4 + 4;
              systemCounter7 = 8;
              do {
                *(int *)(plocalResourceOffset4 + -4) = systemIndex4 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -0x1c) = systemIndex4 + 1 + systemCounter9;
                *(int *)(plocalResourceOffset4 + -3) = systemIndex4 + 2 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -0x14) = systemIndex4 + 3 + systemCounter9;
                systemIndex4 = systemIndex4 + 0x10;
                *(int *)(plocalResourceOffset4 + -2) = systemCounter7 + -4 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -0xc) = systemCounter7 + -3 + systemCounter9;
                *(int *)(plocalResourceOffset4 + -1) = systemCounter7 + -2 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + -4) = systemCounter7 + -1 + systemCounter9;
                *(int *)plocalResourceOffset4 = systemCounter7 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 4) = systemCounter7 + 1 + systemCounter9;
                *(int *)(plocalResourceOffset4 + 1) = systemCounter7 + 2 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 0xc) = systemCounter7 + 3 + systemCounter9;
                *(int *)(plocalResourceOffset4 + 2) = systemCounter7 + 4 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 0x14) = systemCounter7 + 5 + systemCounter9;
                *(int *)(plocalResourceOffset4 + 3) = systemCounter7 + 6 + systemCounter9;
                *(int *)((long long)plocalResourceOffset4 + 0x1c) = systemCounter7 + 7 + systemCounter9;
                plocalResourceOffset4 = plocalResourceOffset4 + 8;
                systemCounter7 = systemCounter7 + 0x10;
                systemIndex5 = systemIndex4;
              } while (systemIndex4 < (int)(allocationContext6 - allocationContext8));
            }
          }
          for (localResourceOffset3 = (long long)systemIndex5; localResourceOffset3 < (long long)unsignedSystemValue40; localResourceOffset3 = localResourceOffset3 + 1) {
            systemIndex4 = *(int *)(nextDataIndex7 + 0x2c) + systemIndex5;
            systemIndex5 = systemIndex5 + 1;
            *(int *)(*PrimaryResourcePointer + localResourceOffset3 * 4) = systemIndex4;
          }
          systemIndex5 = *(int *)(nextDataIndex7 + 0x18);
          systemIndex4 = 0;
          if (0 < (long long)systemIndex5) {
            localResourceOffset3 = 0;
            do {
              systemCounter9 = *(int *)(nextDataIndex7 + 0x30) + systemIndex4;
              systemIndex4 = systemIndex4 + 1;
              pisResourceAvailable = (byte *)(*(long long *)(nextDataIndex7 + 0x10) + localResourceOffset3);
              localResourceOffset3 = localResourceOffset3 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisResourceAvailable * 4) = systemCounter9;
            } while (localResourceOffset3 < systemIndex5);
          }
        }
        punsignedSystemValue42 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 +
                          SystemMemoryContext + 0x9d0);
        if (systemIndex3 == 0) {
          allocationContext6 = (int)charStatus6 - 1;
        }
        else {
          LOCK();
          allocationContext6 = *punsignedSystemValue42;
          *punsignedSystemValue42 = *punsignedSystemValue42 + (int)charStatus6;
          UNLOCK();
          unsignedSystemValue48 = (ulong long)(allocationContext6 >> 0xb);
          unsignedSystemValue49 = (ulong long)(charStatus6 + -1 + allocationContext6 >> 0xb);
          if (unsignedSystemValue48 <= unsignedSystemValue49) {
            psystemStatusFlag1 = (char *)((long long)punsignedSystemValue42 + unsignedSystemValue48 + 0x108);
            localResourceOffset3 = (unsignedSystemValue49 - unsignedSystemValue48) + 1;
            punsignedSystemValue47 = punsignedSystemValue42 + unsignedSystemValue48 * 2 + 2;
            do {
              systemIndex5 = (int)unsignedSystemValue48;
              if (*(long long *)punsignedSystemValue47 == 0) {
                localResourceOffset5 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isMemoryReady0 = *(long long *)(punsignedSystemValue42 + (long long)systemIndex5 * 2 + 2) == 0;
                if (isMemoryReady0) {
                  *(long long *)(punsignedSystemValue42 + (long long)systemIndex5 * 2 + 2) = localResourceOffset5;
                }
                UNLOCK();
                if (isMemoryReady0) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex5 + 0x108 + (long long)punsignedSystemValue42) = 0;
                  UNLOCK();
                }
                else {
                  if (localResourceOffset5 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*psystemStatusFlag1 != '\0');
                }
              }
              else {
                do {
                } while (*psystemStatusFlag1 != '\0');
              }
              unsignedSystemValue48 = (ulong long)(systemIndex5 + 1);
              punsignedSystemValue47 = punsignedSystemValue47 + 2;
              psystemStatusFlag1 = psystemStatusFlag1 + 1;
              localResourceOffset3 = localResourceOffset3 + -1;
            } while (localResourceOffset3 != 0);
          }
        }
        punsignedSystemValue46 = *(uint32_t **)(nextDataIndex7 + 0x38);
        allocationContext8 = allocationContext6 >> 0xb;
        *(uint *)(nextDataIndex7 + 0x2c) = allocationContext6;
        if (allocationContext8 == (int)charStatus6 + allocationContext6 >> 0xb) {
            memcpy(*(long long *)(punsignedSystemValue42 + (ulong long)allocationContext8 * 2 + 2) +
                 (ulong long)(allocationContext6 + allocationContext8 * -0x800) * 4,punsignedSystemValue46,(unsignedSystemValue40 & 0xffffffff) << 2);
        }
        if (systemIndex3 != 0) {
          unsignedSystemValue40 = unsignedSystemValue40 & 0xffffffff;
          do {
            allocationContext2 = *punsignedSystemValue46;
            punsignedSystemValue46 = punsignedSystemValue46 + 1;
            *(uint32_t *)
             (*(long long *)(punsignedSystemValue42 + (ulong long)(allocationContext6 >> 0xb) * 2 + 2) +
             (ulong long)(allocationContext6 + (allocationContext6 >> 0xb) * -0x800) * 4) = allocationContext2;
            unsignedSystemValue40 = unsignedSystemValue40 - 1;
            allocationContext6 = allocationContext6 + 1;
          } while (unsignedSystemValue40 != 0);
        }
      }
    }
  }
  return;
}





// 函数: void FUN_1800792ea(void)
void FUN_1800792ea(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  void* *punsignedSystemValue4;
  float floatValue5;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  char CharacterVariable14;
  float *pinterpolationFactor3;
  long long nextDataIndex6;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  void* creationFlags9;
  uint32_t allocationContext0;
  long long localResourceOffset1;
  long long *plocalResourceOffset2;
  uint allocationContext3;
  int systemCounter4;
  uint allocationContext5;
  int systemCounter6;
  long long systemMemoryBlockPtr;
  ulong long allocationContext7;
  char *pcharFlag8;
  uint *HashNodePointer9;
  int systemIndex0;
  long long systemDataIndexPtr;
  int systemIndex1;
  int systemIndex2;
  long long bufferBaseAddress3;
  uint32_t *punsignedSystemValue44;
  uint *punsignedSystemValue45;
  ulong long unsignedSystemValue46;
  ulong long unsignedSystemValue47;
  bool isResourceAvailable8;
  uint32_t unaff_XMM7_Da;
  uint32_t unaff_XMM7_Db;
  void* uStack0000000000000050;
  void* in_stack_00000058;
  
  allocationContext5 = (int)*(char *)(systemDataIndexPtr + 0xd) + *(int *)(systemDataIndexPtr + 0x18);
  pscaleResult1 = (float *)**(long long **)(systemMemoryBlockPtr + 600);
  bufferBaseAddress3 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
  allocationContext3 = allocationContext5 >> 0xd;
  nextDataIndex6 = *(long long *)(bufferBaseAddress3 + 8 + (ulong long)allocationContext3 * 8);
  localResourceOffset1 = (ulong long)(allocationContext5 + allocationContext3 * -0x2000) * 0x40;
  creationFlags9 = ((void* *)(nextDataIndex6 + localResourceOffset1))[1];
  *(void* *)pscaleResult1 = *(void* *)(nextDataIndex6 + localResourceOffset1);
  *(void* *)(pinterpolationFactor3 + 2) = creationFlags9;
  punsignedSystemValue4 = (void* *)(nextDataIndex6 + 0x10 + localResourceOffset1);
  creationFlags9 = punsignedSystemValue4[1];
  *(void* *)(pinterpolationFactor3 + 4) = *punsignedSystemValue4;
  *(void* *)(pinterpolationFactor3 + 6) = creationFlags9;
  punsignedSystemValue4 = (void* *)(nextDataIndex6 + 0x20 + localResourceOffset1);
  creationFlags9 = punsignedSystemValue4[1];
  *(void* *)(pinterpolationFactor3 + 8) = *punsignedSystemValue4;
  *(void* *)(pinterpolationFactor3 + 10) = creationFlags9;
  punsignedSystemValue4 = (void* *)(nextDataIndex6 + 0x30 + localResourceOffset1);
  creationFlags9 = punsignedSystemValue4[1];
  *(void* *)(pinterpolationFactor3 + 0xc) = *punsignedSystemValue4;
  *(void* *)(pinterpolationFactor3 + 0xe) = creationFlags9;
  nextDataIndex6 = *(long long *)(systemDataIndexPtr + 0x10);
  interpolationFactor5 = pinterpolationFactor3[8];
  magnitudeSquared1 = pinterpolationFactor3[9];
  floatValue19 = pinterpolationFactor3[10];
  floatValue20 = pinterpolationFactor3[0xb];
  floatValue21 = *pinterpolationFactor3;
  floatValue22 = pinterpolationFactor3[1];
  floatValue23 = pinterpolationFactor3[2];
  floatValue24 = pinterpolationFactor3[3];
  floatValue25 = pinterpolationFactor3[4];
  floatValue26 = pinterpolationFactor3[5];
  floatValue27 = pinterpolationFactor3[6];
  floatValue28 = pinterpolationFactor3[7];
  floatValue5 = *(float *)(nextDataIndex6 + 0x374);
  floatValue6 = *(float *)(nextDataIndex6 + 0x370);
  floatValue7 = *(float *)(nextDataIndex6 + 0x378);
  floatValue8 = *(float *)(nextDataIndex6 + 900);
  floatValue9 = *(float *)(nextDataIndex6 + 0x394);
  FloatScaleFactor = *(float *)(nextDataIndex6 + 0x380);
  floatValue11 = *(float *)(nextDataIndex6 + 0x388);
  FloatRatioValue = *(float *)(nextDataIndex6 + 0x390);
  interpolationFactor1 = *(float *)(nextDataIndex6 + 0x398);
  *pscaleResult1 = floatValue5 * floatValue25 + floatValue6 * floatValue21 + floatValue7 * interpolationFactor5;
  pinterpolationFactor3[1] = floatValue5 * floatValue26 + floatValue6 * floatValue22 + floatValue7 * magnitudeSquared1;
  pinterpolationFactor3[2] = floatValue5 * floatValue27 + floatValue6 * floatValue23 + floatValue7 * floatValue19;
  pinterpolationFactor3[3] = floatValue5 * floatValue28 + floatValue6 * floatValue24 + floatValue7 * floatValue20;
  pinterpolationFactor3[4] = floatValue8 * floatValue25 + FloatScaleFactor * floatValue21 + floatValue11 * interpolationFactor5;
  pinterpolationFactor3[5] = floatValue8 * floatValue26 + FloatScaleFactor * floatValue22 + floatValue11 * magnitudeSquared1;
  pinterpolationFactor3[6] = floatValue8 * floatValue27 + FloatScaleFactor * floatValue23 + floatValue11 * floatValue19;
  pinterpolationFactor3[7] = floatValue8 * floatValue28 + FloatScaleFactor * floatValue24 + floatValue11 * floatValue20;
  pinterpolationFactor3[8] = floatValue9 * floatValue25 + FloatRatioValue * floatValue21 + interpolationFactor1 * interpolationFactor5;
  pinterpolationFactor3[9] = floatValue9 * floatValue26 + FloatRatioValue * floatValue22 + interpolationFactor1 * magnitudeSquared1;
  pinterpolationFactor3[10] = floatValue9 * floatValue27 + FloatRatioValue * floatValue23 + interpolationFactor1 * floatValue19;
  pinterpolationFactor3[0xb] = floatValue9 * floatValue28 + FloatRatioValue * floatValue24 + interpolationFactor1 * floatValue20;
  nextDataIndex6 = *(long long *)(systemMemoryBlockPtr + 600);
  if (*(int *)(nextDataIndex6 + 0x28) != *(int *)(SystemStatusFlagsPointer + 0x224)) {
    systemIndex0 = *(int *)(nextDataIndex6 + 0x1c) + *(int *)(nextDataIndex6 + 0x18);
    *(int *)(nextDataIndex6 + 0x28) = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (0 < systemIndex0) {
      uStack0000000000000050 = in_stack_00000058;
      localResourceOffset1 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
      allocationContext0 = FUN_180080380(localResourceOffset1,systemIndex0,bufferBaseAddress3,pinterpolationFactor3,CONCAT44(unaff_XMM7_Db,unaff_XMM7_Da));
      *(uint32_t *)(nextDataIndex6 + 0x30) = allocationContext0;
      FUN_1800802e0(localResourceOffset1,allocationContext0);
      if (*(long long *)(nextDataIndex6 + 0x10) == 0) {
        if (*(int *)(nextDataIndex6 + 0x18) != 0) {
          *(uint32_t *)(nextDataIndex6 + 0x2c) = *(uint32_t *)(nextDataIndex6 + 0x30);
          return;
        }
      }
      else {
        charStatus4 = *(char *)(nextDataIndex6 + 0x44);
        allocationContext7 = (ulong long)charStatus4;
        PrimaryResourcePointer = (long long *)(nextDataIndex6 + 0x38);
        systemIndex0 = (int)charStatus4;
        if (*(int *)(nextDataIndex6 + 0x40) == (int)charStatus4) {
          plocalResourceOffset2 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(nextDataIndex6 + 0x40) = systemIndex0;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus4 == '\0') {
            plocalResourceOffset2 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalResourceOffset2 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus4 * 4);
            *PrimaryResourcePointer = (long long)plocalResourceOffset2;
          }
        }
        if (plocalResourceOffset2 != (long long *)0x0) {
          systemIndex1 = 0;
          allocationContext3 = (uint)charStatus4;
          systemIndex2 = systemIndex1;
          if ((0 < systemIndex0) && (0xf < allocationContext3)) {
            systemCounter6 = *(int *)(nextDataIndex6 + 0x2c);
            resourcePoolPointer = (long long *)((long long)plocalResourceOffset2 + (long long)(charStatus4 + -1) * 4);
            if ((((long long *)(nextDataIndex6 + 0x2c) < plocalResourceOffset2) || (resourcePoolPointer < (long long *)(nextDataIndex6 + 0x2c)))
               && ((PrimaryResourcePointer < plocalResourceOffset2 || (systemIndex2 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              allocationContext5 = allocationContext3 & 0x8000000f;
              if ((int)allocationContext5 < 0) {
                allocationContext5 = (allocationContext5 - 1 | 0xfffffff0) + 1;
              }
              plocalResourceOffset2 = plocalResourceOffset2 + 4;
              systemCounter4 = 8;
              do {
                *(int *)(plocalResourceOffset2 + -4) = systemIndex1 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + -0x1c) = systemIndex1 + 1 + systemCounter6;
                *(int *)(plocalResourceOffset2 + -3) = systemIndex1 + 2 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + -0x14) = systemIndex1 + 3 + systemCounter6;
                systemIndex1 = systemIndex1 + 0x10;
                *(int *)(plocalResourceOffset2 + -2) = systemCounter4 + -4 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + -0xc) = systemCounter4 + -3 + systemCounter6;
                *(int *)(plocalResourceOffset2 + -1) = systemCounter4 + -2 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + -4) = systemCounter4 + -1 + systemCounter6;
                *(int *)plocalResourceOffset2 = systemCounter4 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + 4) = systemCounter4 + 1 + systemCounter6;
                *(int *)(plocalResourceOffset2 + 1) = systemCounter4 + 2 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + 0xc) = systemCounter4 + 3 + systemCounter6;
                *(int *)(plocalResourceOffset2 + 2) = systemCounter4 + 4 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + 0x14) = systemCounter4 + 5 + systemCounter6;
                *(int *)(plocalResourceOffset2 + 3) = systemCounter4 + 6 + systemCounter6;
                *(int *)((long long)plocalResourceOffset2 + 0x1c) = systemCounter4 + 7 + systemCounter6;
                plocalResourceOffset2 = plocalResourceOffset2 + 8;
                systemCounter4 = systemCounter4 + 0x10;
                systemIndex2 = systemIndex1;
              } while (systemIndex1 < (int)(allocationContext3 - allocationContext5));
            }
          }
          for (localResourceOffset1 = (long long)systemIndex2; localResourceOffset1 < (long long)allocationContext7; localResourceOffset1 = localResourceOffset1 + 1) {
            systemIndex1 = *(int *)(nextDataIndex6 + 0x2c) + systemIndex2;
            systemIndex2 = systemIndex2 + 1;
            *(int *)(*PrimaryResourcePointer + localResourceOffset1 * 4) = systemIndex1;
          }
          systemIndex2 = *(int *)(nextDataIndex6 + 0x18);
          systemIndex1 = 0;
          if (0 < (long long)systemIndex2) {
            localResourceOffset1 = 0;
            do {
              systemCounter6 = *(int *)(nextDataIndex6 + 0x30) + systemIndex1;
              systemIndex1 = systemIndex1 + 1;
              pisOperationComplete = (byte *)(*(long long *)(nextDataIndex6 + 0x10) + localResourceOffset1);
              localResourceOffset1 = localResourceOffset1 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemCounter6;
            } while (localResourceOffset1 < systemIndex2);
          }
        }
        HashNodePointer9 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 +
                          SystemMemoryContext + 0x9d0);
        if (systemIndex0 == 0) {
          allocationContext3 = (int)charStatus4 - 1;
        }
        else {
          LOCK();
          allocationContext3 = *HashNodePointer9;
          *HashNodePointer9 = *HashNodePointer9 + (int)charStatus4;
          UNLOCK();
          unsignedSystemValue46 = (ulong long)(allocationContext3 >> 0xb);
          unsignedSystemValue47 = (ulong long)(charStatus4 + -1 + allocationContext3 >> 0xb);
          if (unsignedSystemValue46 <= unsignedSystemValue47) {
            pcharFlag8 = (char *)((long long)HashNodePointer9 + unsignedSystemValue46 + 0x108);
            localResourceOffset1 = (unsignedSystemValue47 - unsignedSystemValue46) + 1;
            punsignedSystemValue45 = HashNodePointer9 + unsignedSystemValue46 * 2 + 2;
            do {
              systemIndex2 = (int)unsignedSystemValue46;
              if (*(long long *)punsignedSystemValue45 == 0) {
                bufferBaseAddress3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isResourceAvailable8 = *(long long *)(HashNodePointer9 + (long long)systemIndex2 * 2 + 2) == 0;
                if (isResourceAvailable8) {
                  *(long long *)(HashNodePointer9 + (long long)systemIndex2 * 2 + 2) = bufferBaseAddress3;
                }
                UNLOCK();
                if (isResourceAvailable8) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex2 + 0x108 + (long long)HashNodePointer9) = 0;
                  UNLOCK();
                }
                else {
                  if (bufferBaseAddress3 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*pcharFlag8 != '\0');
                }
              }
              else {
                do {
                } while (*pcharFlag8 != '\0');
              }
              unsignedSystemValue46 = (ulong long)(systemIndex2 + 1);
              punsignedSystemValue45 = punsignedSystemValue45 + 2;
              pcharFlag8 = pcharFlag8 + 1;
              localResourceOffset1 = localResourceOffset1 + -1;
            } while (localResourceOffset1 != 0);
          }
        }
        punsignedSystemValue44 = *(uint32_t **)(nextDataIndex6 + 0x38);
        allocationContext5 = allocationContext3 >> 0xb;
        *(uint *)(nextDataIndex6 + 0x2c) = allocationContext3;
        if (allocationContext5 == (int)charStatus4 + allocationContext3 >> 0xb) {
            memcpy(*(long long *)(HashNodePointer9 + (ulong long)allocationContext5 * 2 + 2) +
                 (ulong long)(allocationContext3 + allocationContext5 * -0x800) * 4,punsignedSystemValue44,(allocationContext7 & 0xffffffff) << 2);
        }
        if (systemIndex0 != 0) {
          allocationContext7 = allocationContext7 & 0xffffffff;
          do {
            allocationContext0 = *punsignedSystemValue44;
            punsignedSystemValue44 = punsignedSystemValue44 + 1;
            *(uint32_t *)
             (*(long long *)(HashNodePointer9 + (ulong long)(allocationContext3 >> 0xb) * 2 + 2) +
             (ulong long)(allocationContext3 + (allocationContext3 >> 0xb) * -0x800) * 4) = allocationContext0;
            allocationContext7 = allocationContext7 - 1;
            allocationContext3 = allocationContext3 + 1;
          } while (allocationContext7 != 0);
        }
      }
    }
  }
  return;
}





// 函数: void FUN_180079309(long long ResourceManagerPointer,uint ConfigurationDataPointer,void* AdditionalParameter,float *ConfigurationFlag)
void FUN_180079309(long long ResourceManagerPointer,uint ConfigurationDataPointer,void* AdditionalParameter,float *ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  void* *punsignedSystemValue4;
  float floatValue5;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float floatValue9;
  float FloatScaleFactor;
  float floatValue11;
  float FloatRatioValue;
  float interpolationFactor1;
  char CharacterVariable14;
  long long nextDataIndex5;
  float interpolationFactor4;
  float interpolationFactor5;
  float magnitudeSquared1;
  float floatValue19;
  float floatValue20;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  void* creationFlags8;
  uint32_t creationFlags9;
  uint allocationContext0;
  long long localResourceOffset1;
  long long *plocalResourceOffset2;
  long long localResourceOffset3;
  int systemCounter4;
  int systemCounter5;
  long long systemMemoryBlockPtr;
  ulong long allocationContext6;
  char *pcharFlag7;
  uint *HashNodePointer8;
  int systemCounter9;
  uint unsignedSystemValue40;
  long long systemDataIndexPtr;
  int systemIndex1;
  int systemIndex2;
  uint32_t *punsignedSystemValue43;
  uint *punsignedSystemValue44;
  ulong long unsignedSystemValue45;
  ulong long unsignedSystemValue46;
  bool isResourceAvailable7;
  uint32_t unaff_XMM7_Da;
  uint32_t unaff_XMM7_Db;
  void* uStack0000000000000050;
  void* in_stack_00000058;
  
  ResourceManagerPointer = (long long)*(int *)(ResourceManagerPointer + 0x250) * 0x128 + ResourceManagerPointer;
  nextDataIndex5 = *(long long *)(ResourceManagerPointer + 8 + (ulong long)(ConfigurationDataPointer >> 0xd) * 8);
  localResourceOffset1 = (ulong long)(ConfigurationDataPointer + (ConfigurationDataPointer >> 0xd) * -0x2000) * 0x40;
  creationFlags8 = ((void* *)(nextDataIndex5 + localResourceOffset1))[1];
  *(void* *)ConfigurationFlag = *(void* *)(nextDataIndex5 + localResourceOffset1);
  *(void* *)(ConfigurationFlag + 2) = creationFlags8;
  punsignedSystemValue4 = (void* *)(nextDataIndex5 + 0x10 + localResourceOffset1);
  creationFlags8 = punsignedSystemValue4[1];
  *(void* *)(ConfigurationFlag + 4) = *punsignedSystemValue4;
  *(void* *)(ConfigurationFlag + 6) = creationFlags8;
  punsignedSystemValue4 = (void* *)(nextDataIndex5 + 0x20 + localResourceOffset1);
  creationFlags8 = punsignedSystemValue4[1];
  *(void* *)(ConfigurationFlag + 8) = *punsignedSystemValue4;
  *(void* *)(ConfigurationFlag + 10) = creationFlags8;
  punsignedSystemValue4 = (void* *)(nextDataIndex5 + 0x30 + localResourceOffset1);
  creationFlags8 = punsignedSystemValue4[1];
  *(void* *)(ConfigurationFlag + 0xc) = *punsignedSystemValue4;
  *(void* *)(ConfigurationFlag + 0xe) = creationFlags8;
  nextDataIndex5 = *(long long *)(systemDataIndexPtr + 0x10);
  interpolationFactor4 = ConfigurationFlag[8];
  interpolationFactor5 = ConfigurationFlag[9];
  magnitudeSquared1 = ConfigurationFlag[10];
  floatValue19 = ConfigurationFlag[0xb];
  floatValue20 = *ConfigurationFlag;
  floatValue21 = ConfigurationFlag[1];
  floatValue22 = ConfigurationFlag[2];
  floatValue23 = ConfigurationFlag[3];
  floatValue24 = ConfigurationFlag[4];
  floatValue25 = ConfigurationFlag[5];
  floatValue26 = ConfigurationFlag[6];
  floatValue27 = ConfigurationFlag[7];
  floatValue5 = *(float *)(nextDataIndex5 + 0x374);
  floatValue6 = *(float *)(nextDataIndex5 + 0x370);
  floatValue7 = *(float *)(nextDataIndex5 + 0x378);
  floatValue8 = *(float *)(nextDataIndex5 + 900);
  floatValue9 = *(float *)(nextDataIndex5 + 0x394);
  FloatScaleFactor = *(float *)(nextDataIndex5 + 0x380);
  floatValue11 = *(float *)(nextDataIndex5 + 0x388);
  FloatRatioValue = *(float *)(nextDataIndex5 + 0x390);
  interpolationFactor1 = *(float *)(nextDataIndex5 + 0x398);
  *ConfigurationFlag = floatValue5 * floatValue24 + floatValue6 * floatValue20 + floatValue7 * interpolationFactor4;
  ConfigurationFlag[1] = floatValue5 * floatValue25 + floatValue6 * floatValue21 + floatValue7 * interpolationFactor5;
  ConfigurationFlag[2] = floatValue5 * floatValue26 + floatValue6 * floatValue22 + floatValue7 * magnitudeSquared1;
  ConfigurationFlag[3] = floatValue5 * floatValue27 + floatValue6 * floatValue23 + floatValue7 * floatValue19;
  ConfigurationFlag[4] = floatValue8 * floatValue24 + FloatScaleFactor * floatValue20 + floatValue11 * interpolationFactor4;
  ConfigurationFlag[5] = floatValue8 * floatValue25 + FloatScaleFactor * floatValue21 + floatValue11 * interpolationFactor5;
  ConfigurationFlag[6] = floatValue8 * floatValue26 + FloatScaleFactor * floatValue22 + floatValue11 * magnitudeSquared1;
  ConfigurationFlag[7] = floatValue8 * floatValue27 + FloatScaleFactor * floatValue23 + floatValue11 * floatValue19;
  ConfigurationFlag[8] = floatValue9 * floatValue24 + FloatRatioValue * floatValue20 + interpolationFactor1 * interpolationFactor4;
  ConfigurationFlag[9] = floatValue9 * floatValue25 + FloatRatioValue * floatValue21 + interpolationFactor1 * interpolationFactor5;
  ConfigurationFlag[10] = floatValue9 * floatValue26 + FloatRatioValue * floatValue22 + interpolationFactor1 * magnitudeSquared1;
  ConfigurationFlag[0xb] = floatValue9 * floatValue27 + FloatRatioValue * floatValue23 + interpolationFactor1 * floatValue19;
  nextDataIndex5 = *(long long *)(systemMemoryBlockPtr + 600);
  if (*(int *)(nextDataIndex5 + 0x28) != *(int *)(SystemStatusFlagsPointer + 0x224)) {
    systemCounter9 = *(int *)(nextDataIndex5 + 0x1c) + *(int *)(nextDataIndex5 + 0x18);
    *(int *)(nextDataIndex5 + 0x28) = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (0 < systemCounter9) {
      uStack0000000000000050 = in_stack_00000058;
      localResourceOffset1 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
      creationFlags9 = FUN_180080380(localResourceOffset1,systemCounter9,ResourceManagerPointer,ConfigurationFlag,CONCAT44(unaff_XMM7_Db,unaff_XMM7_Da));
      *(uint32_t *)(nextDataIndex5 + 0x30) = creationFlags9;
      FUN_1800802e0(localResourceOffset1,creationFlags9);
      if (*(long long *)(nextDataIndex5 + 0x10) == 0) {
        if (*(int *)(nextDataIndex5 + 0x18) != 0) {
          *(uint32_t *)(nextDataIndex5 + 0x2c) = *(uint32_t *)(nextDataIndex5 + 0x30);
          return;
        }
      }
      else {
        charStatus4 = *(char *)(nextDataIndex5 + 0x44);
        allocationContext6 = (ulong long)charStatus4;
        PrimaryResourcePointer = (long long *)(nextDataIndex5 + 0x38);
        systemCounter9 = (int)charStatus4;
        if (*(int *)(nextDataIndex5 + 0x40) == (int)charStatus4) {
          plocalResourceOffset2 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(nextDataIndex5 + 0x40) = systemCounter9;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus4 == '\0') {
            plocalResourceOffset2 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalResourceOffset2 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus4 * 4);
            *PrimaryResourcePointer = (long long)plocalResourceOffset2;
          }
        }
        if (plocalResourceOffset2 != (long long *)0x0) {
          systemIndex1 = 0;
          unsignedSystemValue40 = (uint)charStatus4;
          systemIndex2 = systemIndex1;
          if ((0 < systemCounter9) && (0xf < unsignedSystemValue40)) {
            systemCounter5 = *(int *)(nextDataIndex5 + 0x2c);
            resourcePoolPointer = (long long *)((long long)plocalResourceOffset2 + (long long)(charStatus4 + -1) * 4);
            if ((((long long *)(nextDataIndex5 + 0x2c) < plocalResourceOffset2) || (resourcePoolPointer < (long long *)(nextDataIndex5 + 0x2c)))
               && ((PrimaryResourcePointer < plocalResourceOffset2 || (systemIndex2 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              allocationContext0 = unsignedSystemValue40 & 0x8000000f;
              if ((int)allocationContext0 < 0) {
                allocationContext0 = (allocationContext0 - 1 | 0xfffffff0) + 1;
              }
              plocalResourceOffset2 = plocalResourceOffset2 + 4;
              systemCounter4 = 8;
              do {
                *(int *)(plocalResourceOffset2 + -4) = systemIndex1 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + -0x1c) = systemIndex1 + 1 + systemCounter5;
                *(int *)(plocalResourceOffset2 + -3) = systemIndex1 + 2 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + -0x14) = systemIndex1 + 3 + systemCounter5;
                systemIndex1 = systemIndex1 + 0x10;
                *(int *)(plocalResourceOffset2 + -2) = systemCounter4 + -4 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + -0xc) = systemCounter4 + -3 + systemCounter5;
                *(int *)(plocalResourceOffset2 + -1) = systemCounter4 + -2 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + -4) = systemCounter4 + -1 + systemCounter5;
                *(int *)plocalResourceOffset2 = systemCounter4 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + 4) = systemCounter4 + 1 + systemCounter5;
                *(int *)(plocalResourceOffset2 + 1) = systemCounter4 + 2 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + 0xc) = systemCounter4 + 3 + systemCounter5;
                *(int *)(plocalResourceOffset2 + 2) = systemCounter4 + 4 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + 0x14) = systemCounter4 + 5 + systemCounter5;
                *(int *)(plocalResourceOffset2 + 3) = systemCounter4 + 6 + systemCounter5;
                *(int *)((long long)plocalResourceOffset2 + 0x1c) = systemCounter4 + 7 + systemCounter5;
                plocalResourceOffset2 = plocalResourceOffset2 + 8;
                systemCounter4 = systemCounter4 + 0x10;
                systemIndex2 = systemIndex1;
              } while (systemIndex1 < (int)(unsignedSystemValue40 - allocationContext0));
            }
          }
          for (localResourceOffset1 = (long long)systemIndex2; localResourceOffset1 < (long long)allocationContext6; localResourceOffset1 = localResourceOffset1 + 1) {
            systemIndex1 = *(int *)(nextDataIndex5 + 0x2c) + systemIndex2;
            systemIndex2 = systemIndex2 + 1;
            *(int *)(*PrimaryResourcePointer + localResourceOffset1 * 4) = systemIndex1;
          }
          systemIndex2 = *(int *)(nextDataIndex5 + 0x18);
          systemIndex1 = 0;
          if (0 < (long long)systemIndex2) {
            localResourceOffset1 = 0;
            do {
              systemCounter5 = *(int *)(nextDataIndex5 + 0x30) + systemIndex1;
              systemIndex1 = systemIndex1 + 1;
              pisOperationComplete = (byte *)(*(long long *)(nextDataIndex5 + 0x10) + localResourceOffset1);
              localResourceOffset1 = localResourceOffset1 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemCounter5;
            } while (localResourceOffset1 < systemIndex2);
          }
        }
        HashNodePointer8 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 +
                          SystemMemoryContext + 0x9d0);
        if (systemCounter9 == 0) {
          unsignedSystemValue40 = (int)charStatus4 - 1;
        }
        else {
          LOCK();
          unsignedSystemValue40 = *HashNodePointer8;
          *HashNodePointer8 = *HashNodePointer8 + (int)charStatus4;
          UNLOCK();
          unsignedSystemValue45 = (ulong long)(unsignedSystemValue40 >> 0xb);
          unsignedSystemValue46 = (ulong long)(charStatus4 + -1 + unsignedSystemValue40 >> 0xb);
          if (unsignedSystemValue45 <= unsignedSystemValue46) {
            pcharFlag7 = (char *)((long long)HashNodePointer8 + unsignedSystemValue45 + 0x108);
            localResourceOffset1 = (unsignedSystemValue46 - unsignedSystemValue45) + 1;
            punsignedSystemValue44 = HashNodePointer8 + unsignedSystemValue45 * 2 + 2;
            do {
              systemIndex2 = (int)unsignedSystemValue45;
              if (*(long long *)punsignedSystemValue44 == 0) {
                localResourceOffset3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isResourceAvailable7 = *(long long *)(HashNodePointer8 + (long long)systemIndex2 * 2 + 2) == 0;
                if (isResourceAvailable7) {
                  *(long long *)(HashNodePointer8 + (long long)systemIndex2 * 2 + 2) = localResourceOffset3;
                }
                UNLOCK();
                if (isResourceAvailable7) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex2 + 0x108 + (long long)HashNodePointer8) = 0;
                  UNLOCK();
                }
                else {
                  if (localResourceOffset3 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*pcharFlag7 != '\0');
                }
              }
              else {
                do {
                } while (*pcharFlag7 != '\0');
              }
              unsignedSystemValue45 = (ulong long)(systemIndex2 + 1);
              punsignedSystemValue44 = punsignedSystemValue44 + 2;
              pcharFlag7 = pcharFlag7 + 1;
              localResourceOffset1 = localResourceOffset1 + -1;
            } while (localResourceOffset1 != 0);
          }
        }
        punsignedSystemValue43 = *(uint32_t **)(nextDataIndex5 + 0x38);
        allocationContext0 = unsignedSystemValue40 >> 0xb;
        *(uint *)(nextDataIndex5 + 0x2c) = unsignedSystemValue40;
        if (allocationContext0 == (int)charStatus4 + unsignedSystemValue40 >> 0xb) {
            memcpy(*(long long *)(HashNodePointer8 + (ulong long)allocationContext0 * 2 + 2) +
                 (ulong long)(unsignedSystemValue40 + allocationContext0 * -0x800) * 4,punsignedSystemValue43,(allocationContext6 & 0xffffffff) << 2);
        }
        if (systemCounter9 != 0) {
          allocationContext6 = allocationContext6 & 0xffffffff;
          do {
            creationFlags9 = *punsignedSystemValue43;
            punsignedSystemValue43 = punsignedSystemValue43 + 1;
            *(uint32_t *)
             (*(long long *)(HashNodePointer8 + (ulong long)(unsignedSystemValue40 >> 0xb) * 2 + 2) +
             (ulong long)(unsignedSystemValue40 + (unsignedSystemValue40 >> 0xb) * -0x800) * 4) = creationFlags9;
            allocationContext6 = allocationContext6 - 1;
            unsignedSystemValue40 = unsignedSystemValue40 + 1;
          } while (allocationContext6 != 0);
        }
      }
    }
  }
  return;
}





// 函数: void FUN_18007940e(void)
void FUN_18007940e(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char systemStatusFlag;
  long long SystemTimeValue;
  uint32_t hashValue;
  uint unsignedSystemValue7;
  long long *plocalMemoryAddress;
  long long resourceCounter;
  int systemStatus0;
  int systemStatus1;
  long long systemMemoryBlockPtr;
  long long nextDataIndex2;
  ulong long systemStatus3;
  char *systemFunctionPointer4;
  uint *ThreadLocalStorageEntry;
  int systemStatus6;
  uint systemStatus7;
  int systemStatus8;
  int systemStatus9;
  uint32_t *HashEntryStatus0;
  uint *HashEntryStatus1;
  ulong long creationFlags2;
  ulong long creationFlags3;
  bool isSystemActive4;
  void* uStack0000000000000050;
  void* in_stack_00000058;
  
  localSystemPointer = *(long long *)(systemMemoryBlockPtr + 600);
  if (*(int *)(localSystemPointer + 0x28) != *(int *)(SystemStatusFlagsPointer + 0x224)) {
    systemStatus6 = *(int *)(localSystemPointer + 0x1c) + *(int *)(localSystemPointer + 0x18);
    *(int *)(localSystemPointer + 0x28) = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (0 < systemStatus6) {
      uStack0000000000000050 = in_stack_00000058;
      nextDataIndex2 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
      hashValue = FUN_180080380(nextDataIndex2,systemStatus6);
      *(uint32_t *)(localSystemPointer + 0x30) = hashValue;
      FUN_1800802e0(nextDataIndex2,hashValue);
      if (*(long long *)(localSystemPointer + 0x10) == 0) {
        if (*(int *)(localSystemPointer + 0x18) != 0) {
          *(uint32_t *)(localSystemPointer + 0x2c) = *(uint32_t *)(localSystemPointer + 0x30);
          return;
        }
      }
      else {
        systemStatusFlag = *(char *)(localSystemPointer + 0x44);
        systemStatus3 = (ulong long)systemStatusFlag;
        PrimaryResourcePointer = (long long *)(localSystemPointer + 0x38);
        systemStatus6 = (int)systemStatusFlag;
        if (*(int *)(localSystemPointer + 0x40) == (int)systemStatusFlag) {
          plocalMemoryAddress = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(localSystemPointer + 0x40) = systemStatus6;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (systemStatusFlag == '\0') {
            plocalMemoryAddress = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalMemoryAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)systemStatusFlag * 4);
            *PrimaryResourcePointer = (long long)plocalMemoryAddress;
          }
        }
        if (plocalMemoryAddress != (long long *)0x0) {
          systemStatus8 = 0;
          systemStatus7 = (uint)systemStatusFlag;
          systemStatus9 = systemStatus8;
          if ((0 < systemStatus6) && (0xf < systemStatus7)) {
            systemStatus1 = *(int *)(localSystemPointer + 0x2c);
            resourcePoolPointer = (long long *)((long long)plocalMemoryAddress + (long long)(systemStatusFlag + -1) * 4);
            if ((((long long *)(localSystemPointer + 0x2c) < plocalMemoryAddress) || (resourcePoolPointer < (long long *)(localSystemPointer + 0x2c))) &&
               ((PrimaryResourcePointer < plocalMemoryAddress || (systemStatus9 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              unsignedSystemValue7 = systemStatus7 & 0x8000000f;
              if ((int)unsignedSystemValue7 < 0) {
                unsignedSystemValue7 = (unsignedSystemValue7 - 1 | 0xfffffff0) + 1;
              }
              plocalMemoryAddress = plocalMemoryAddress + 4;
              systemStatus0 = 8;
              do {
                *(int *)(plocalMemoryAddress + -4) = systemStatus8 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + -0x1c) = systemStatus8 + 1 + systemStatus1;
                *(int *)(plocalMemoryAddress + -3) = systemStatus8 + 2 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + -0x14) = systemStatus8 + 3 + systemStatus1;
                systemStatus8 = systemStatus8 + 0x10;
                *(int *)(plocalMemoryAddress + -2) = systemStatus0 + -4 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + -0xc) = systemStatus0 + -3 + systemStatus1;
                *(int *)(plocalMemoryAddress + -1) = systemStatus0 + -2 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + -4) = systemStatus0 + -1 + systemStatus1;
                *(int *)plocalMemoryAddress = systemStatus0 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + 4) = systemStatus0 + 1 + systemStatus1;
                *(int *)(plocalMemoryAddress + 1) = systemStatus0 + 2 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + 0xc) = systemStatus0 + 3 + systemStatus1;
                *(int *)(plocalMemoryAddress + 2) = systemStatus0 + 4 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + 0x14) = systemStatus0 + 5 + systemStatus1;
                *(int *)(plocalMemoryAddress + 3) = systemStatus0 + 6 + systemStatus1;
                *(int *)((long long)plocalMemoryAddress + 0x1c) = systemStatus0 + 7 + systemStatus1;
                plocalMemoryAddress = plocalMemoryAddress + 8;
                systemStatus0 = systemStatus0 + 0x10;
                systemStatus9 = systemStatus8;
              } while (systemStatus8 < (int)(systemStatus7 - unsignedSystemValue7));
            }
          }
          for (nextDataIndex2 = (long long)systemStatus9; nextDataIndex2 < (long long)systemStatus3; nextDataIndex2 = nextDataIndex2 + 1) {
            systemStatus8 = *(int *)(localSystemPointer + 0x2c) + systemStatus9;
            systemStatus9 = systemStatus9 + 1;
            *(int *)(*PrimaryResourcePointer + nextDataIndex2 * 4) = systemStatus8;
          }
          systemStatus9 = *(int *)(localSystemPointer + 0x18);
          systemStatus8 = 0;
          if (0 < (long long)systemStatus9) {
            nextDataIndex2 = 0;
            do {
              systemStatus1 = *(int *)(localSystemPointer + 0x30) + systemStatus8;
              systemStatus8 = systemStatus8 + 1;
              pisOperationComplete = (byte *)(*(long long *)(localSystemPointer + 0x10) + nextDataIndex2);
              nextDataIndex2 = nextDataIndex2 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemStatus1;
            } while (nextDataIndex2 < systemStatus9);
          }
        }
        ThreadLocalStorageEntry = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 +
                          SystemMemoryContext + 0x9d0);
        if (systemStatus6 == 0) {
          systemStatus7 = (int)systemStatusFlag - 1;
        }
        else {
          LOCK();
          systemStatus7 = *ThreadLocalStorageEntry;
          *ThreadLocalStorageEntry = *ThreadLocalStorageEntry + (int)systemStatusFlag;
          UNLOCK();
          creationFlags2 = (ulong long)(systemStatus7 >> 0xb);
          creationFlags3 = (ulong long)(systemStatusFlag + -1 + systemStatus7 >> 0xb);
          if (creationFlags2 <= creationFlags3) {
            systemFunctionPointer4 = (char *)((long long)ThreadLocalStorageEntry + creationFlags2 + 0x108);
            nextDataIndex2 = (creationFlags3 - creationFlags2) + 1;
            HashEntryStatus1 = ThreadLocalStorageEntry + creationFlags2 * 2 + 2;
            do {
              systemStatus9 = (int)creationFlags2;
              if (*(long long *)HashEntryStatus1 == 0) {
                resourceCounter = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isSystemActive4 = *(long long *)(ThreadLocalStorageEntry + (long long)systemStatus9 * 2 + 2) == 0;
                if (isSystemActive4) {
                  *(long long *)(ThreadLocalStorageEntry + (long long)systemStatus9 * 2 + 2) = resourceCounter;
                }
                UNLOCK();
                if (isSystemActive4) {
                  LOCK();
                  *(uint8_t *)((long long)systemStatus9 + 0x108 + (long long)ThreadLocalStorageEntry) = 0;
                  UNLOCK();
                }
                else {
                  if (resourceCounter != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*systemFunctionPointer4 != '\0');
                }
              }
              else {
                do {
                } while (*systemFunctionPointer4 != '\0');
              }
              creationFlags2 = (ulong long)(systemStatus9 + 1);
              HashEntryStatus1 = HashEntryStatus1 + 2;
              systemFunctionPointer4 = systemFunctionPointer4 + 1;
              nextDataIndex2 = nextDataIndex2 + -1;
            } while (nextDataIndex2 != 0);
          }
        }
        HashEntryStatus0 = *(uint32_t **)(localSystemPointer + 0x38);
        unsignedSystemValue7 = systemStatus7 >> 0xb;
        *(uint *)(localSystemPointer + 0x2c) = systemStatus7;
        if (unsignedSystemValue7 == (int)systemStatusFlag + systemStatus7 >> 0xb) {
            memcpy(*(long long *)(ThreadLocalStorageEntry + (ulong long)unsignedSystemValue7 * 2 + 2) +
                 (ulong long)(systemStatus7 + unsignedSystemValue7 * -0x800) * 4,HashEntryStatus0,(systemStatus3 & 0xffffffff) << 2);
        }
        if (systemStatus6 != 0) {
          systemStatus3 = systemStatus3 & 0xffffffff;
          do {
            hashValue = *HashEntryStatus0;
            HashEntryStatus0 = HashEntryStatus0 + 1;
            *(uint32_t *)
             (*(long long *)(ThreadLocalStorageEntry + (ulong long)(systemStatus7 >> 0xb) * 2 + 2) +
             (ulong long)(systemStatus7 + (systemStatus7 >> 0xb) * -0x800) * 4) = hashValue;
            systemStatus3 = systemStatus3 - 1;
            systemStatus7 = systemStatus7 + 1;
          } while (systemStatus3 != 0);
        }
      }
    }
  }
  return;
}




void* * GetSystemResourceConfigurationPointer(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* configurationResultPointer;
  
  configurationResultPointer = (void*)0xfffffffffffffffe;
  if (*(long long *)(ResourceManagerPointer + 0x1b8) != 0) {
    return (void* *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x10);
  }
  if (*(int *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8) +
              0x48) < SystemDataValue5) {
    CheckSystemDataAvailability(&SystemDataValue5);
    if (SystemDataValue5 == -1) {
      SystemDataValue6 = &SystemResourceTemplatePrimary;
      SystemDataValue7 = &SystemDataValue8;

// 函数: void FUN_180079520(long long ResourceManagerPointer)
/**
 * @brief 系统资源锁定状态管理器函数
 * 
 * 该函数负责管理系统资源的锁定状态，确保资源访问的同步性。
 * 它会检查资源的状态标志，并在必要时等待资源解锁。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要管理的资源信息
 * @note 这是系统资源同步管理的重要组成部分，用于确保资源访问的安全性
 */
void ManageSystemResourceLockState(long long ResourceManagerPointer)

{
  long long nextDataIndex;
  int systemResult;
  long long localResourceOffset;
  
  if (((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) != 0) && (*(long long *)(ResourceManagerPointer + 0x1e0) != 0)) {
    systemResult = 0;
    localResourceOffset = 0;
    do {
      while ((*(char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + localResourceOffset) == '\x02' ||
             (*(char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + localResourceOffset) == '\x01'))) {
        Sleep(0);
      }
      nextDataIndex = (long long)systemResult;
      localResourceOffset = localResourceOffset + 0x18;
      systemResult = systemResult + 1;
      LOCK();
      *(uint8_t *)(*(long long *)(ResourceManagerPointer + 0x1e0) + nextDataIndex * 0x18 + 0x15) = 0;
      UNLOCK();
    } while (systemResult < 0x10);
  }
  return;
}



/**
 * @brief 系统资源状态获取器函数
 * 
 * 该函数负责获取系统资源的当前状态，包括锁定状态和可用性。
 * 它会轮询资源状态，并在资源可用时返回状态信息。
 * 
 * @return 系统资源状态字节，包含资源的当前状态信息
 * @note 这是系统资源状态监控的重要组成部分，用于实时获取资源状态
 */
uint8_t GetSystemResourceState(void)

{
  uint8_t *pointerToUnsigned1;
  uint8_t creationFlags;
  long long localResourceOffset;
  long long systemMemoryBlockPtr;
  int systemIndex;
  long long SystemTimeValue;
  
  systemIndex = 0;
  localSystemPointer = 0;
  do {
    while ((*(char *)(*(long long *)(systemMemoryBlockPtr + 0x1e0) + 0x15 + localSystemPointer) == '\x02' ||
           (*(char *)(*(long long *)(systemMemoryBlockPtr + 0x1e0) + 0x15 + localSystemPointer) == '\x01'))) {
      Sleep(0);
    }
    localResourceOffset = (long long)systemIndex;
    localSystemPointer = localSystemPointer + 0x18;
    systemIndex = systemIndex + 1;
    LOCK();
    pointerToUnsigned1 = (uint8_t *)(*(long long *)(systemMemoryBlockPtr + 0x1e0) + localResourceOffset * 0x18 + 0x15);
    creationFlags = *pointerToUnsigned1;
    *pointerToUnsigned1 = 0;
    UNLOCK();
  } while (systemIndex < 0x10);
  return creationFlags;
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，用于占位或作为默认的空实现。
 * 在某些情况下，它可能被用作回调函数或默认处理函数。
 * 
 * @note 这是一个占位函数，不执行任何实际操作
 */
void SystemNoOperation(void)

{
  return;
}



/**
 * @brief 系统状态标志获取器函数
 * 
 * 该函数负责获取系统的状态标志，包括系统运行状态和错误状态。
 * 它会读取系统状态寄存器，并返回当前的状态信息。
 * 
 * @return 系统状态标志字节，包含系统的当前状态信息
 * @note 这是系统状态监控的重要组成部分，用于实时获取系统状态
 */
uint8_t GetSystemStatusFlag(void)

{
  uint8_t *pointerToUnsigned1;
  uint8_t creationFlags;
  long long localResourceOffset;
  long long systemMemoryBlockPtr;
  int unaff_ESI;
  long long systemDataIndexPtr;
  
  do {
    Sleep(0);
    while ((*(char *)(*(long long *)(systemMemoryBlockPtr + 0x1e0) + 0x15 + systemDataIndexPtr) != '\x02' &&
           (*(char *)(*(long long *)(systemMemoryBlockPtr + 0x1e0) + 0x15 + systemDataIndexPtr) != '\x01'))) {
      localResourceOffset = (long long)unaff_ESI;
      systemDataIndexPtr = systemDataIndexPtr + 0x18;
      unaff_ESI = unaff_ESI + 1;
      LOCK();
      pointerToUnsigned1 = (uint8_t *)(*(long long *)(systemMemoryBlockPtr + 0x1e0) + localResourceOffset * 0x18 + 0x15);
      creationFlags = *pointerToUnsigned1;
      *pointerToUnsigned1 = 0;
      UNLOCK();
      if (0xf < unaff_ESI) {
        return creationFlags;
      }
    }
  } while( true );
}



000180079699)

float * FUN_1800795b0(float *ResourceManagerPointer)

{
  float *pfloatValue1;
  byte isSystemActive;
  long long *plocalResourceOffset;
  float *pfloatValue4;
  char operationStatusFlag;
  float floatValue6;
  float *pfloatValue7;
  uint unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  bool isByteValid0;
  float floatValue11;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  uint32_t uStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  uint32_t uStack_9c;
  float *pfStack_98;
  uint32_t SystemConfigurationValue;
  long long lStack_88;
  void* UnsignedStackFlag80;
  void* UnsignedStackFlag78;
  void* processFlags70;
  void* EncryptionValue68;
  void* unsignedValue60;
  void* *memoryAllocationBuffer;
  float fStack_50;
  float fStack_4c;
  void* *pEncryptionValue48;
  void* unsignedValue40;
  void* uStack_38;
  uint8_t aunsignedValue30 [8];
  float *pfStack_28;
  uint32_t unsignedValue20;
  
  uStack_38 = 0xfffffffffffffffe;
  if (((uint)ResourceManagerPointer[0x40] & 0x10000) == 0) {
    aunsignedValue30[0] = 0;
    unsignedValue20 = 0;
    UnsignedStackFlag80 = 0x1800795fa;
    pfStack_28 = ResourceManagerPointer;
    FUN_18007f4c0(aunsignedValue30);
    UnsignedStackFlag80 = 0x180079605;
    floatValue6 = (float)FUN_1802349a0(0);
    if ((10 < (int)floatValue6) ||
       ((int)(*(int *)(*(long long *)(ResourceManagerPointer + 0x84) + 0x88) +
             (*(int *)(*(long long *)(ResourceManagerPointer + 0x84) + 0x88) >> 0x1f & 3U)) >> 2 < (int)floatValue6)) {
      pEncryptionValue48 = &SystemStringTemplate;
      if (*(void* **)(ResourceManagerPointer + 6) != (void* *)0x0) {
        pEncryptionValue48 = *(void* **)(ResourceManagerPointer + 6);
      }
      unsignedValue40 = CONCAT44(unsignedValue40._4_4_,*(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x84) + 0x60));
      memoryAllocationBuffer = &UNK_1809ffb30;
      UnsignedStackFlag80 = 0x18007967a;
      fStack_50 = floatValue6;
      SystemManagerSetFlags(SystemContextManagerPointer,0,0x80000000000,3);
    }
    ResourceManagerPointer[0x40] = (float)((uint)ResourceManagerPointer[0x40] | 0x10000);
    UnsignedStackFlag80 = 0x18007968e;
    FUN_18007f6a0(aunsignedValue30);
  }
  uStack_38 = 0xfffffffffffffffe;
  pfloatValue7 = ResourceManagerPointer;
  if ((*(byte *)((long long)ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    pfloatValue7 = (float *)func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x6c));
  }
  if ((*(long long *)(pfloatValue7 + 0x84) != 0) && (((uint)ResourceManagerPointer[0x40] & 0x80) == 0)) {
    pfloatValue1 = ResourceManagerPointer + 0x9d;
    pfloatValue1[0] = 1e+08;
    pfloatValue1[1] = 1e+08;
    ResourceManagerPointer[0x9f] = 1e+08;
    ResourceManagerPointer[0xa0] = 3.4028235e+38;
    ResourceManagerPointer[0xa1] = -1e+08;
    ResourceManagerPointer[0xa2] = -1e+08;
    ResourceManagerPointer[0xa3] = -1e+08;
    ResourceManagerPointer[0xa4] = 3.4028235e+38;
    unsignedSystemValue8 = 0;
    ResourceManagerPointer[0xa9] = 0.0;
    ResourceManagerPointer[0xa5] = 0.0;
    ResourceManagerPointer[0xa6] = 0.0;
    ResourceManagerPointer[0xa7] = 0.0;
    ResourceManagerPointer[0xa8] = 3.4028235e+38;
    SystemConfigurationValue = 0;
    pfStack_98 = pfloatValue7;
    FUN_18007f770(&pfStack_98);
    if (*(int *)(lStack_88 + 0x10) != 0) {
      do {
        pfloatValue7 = (float *)((long long)(int)unsignedSystemValue8 * 0x10 + *(long long *)(lStack_88 + 0x18));
        fStack_a8 = *pfloatValue7;
        if (*pfloatValue1 < fStack_a8) {
          fStack_a8 = *pfloatValue1;
        }
        fStack_a4 = pfloatValue7[1];
        if (ResourceManagerPointer[0x9e] < fStack_a4) {
          fStack_a4 = ResourceManagerPointer[0x9e];
        }
        fStack_a0 = pfloatValue7[2];
        if (ResourceManagerPointer[0x9f] < fStack_a0) {
          fStack_a0 = ResourceManagerPointer[0x9f];
        }
        *(ulong long *)pfloatValue1 = CONCAT44(fStack_a4,fStack_a8);
        *(ulong long *)(ResourceManagerPointer + 0x9f) = CONCAT44(uStack_9c,fStack_a0);
        fStack_b8 = *pfloatValue7;
        if (fStack_b8 < ResourceManagerPointer[0xa1]) {
          fStack_b8 = ResourceManagerPointer[0xa1];
        }
        fStack_b4 = pfloatValue7[1];
        if (fStack_b4 < ResourceManagerPointer[0xa2]) {
          fStack_b4 = ResourceManagerPointer[0xa2];
        }
        fStack_b0 = pfloatValue7[2];
        if (fStack_b0 < ResourceManagerPointer[0xa3]) {
          fStack_b0 = ResourceManagerPointer[0xa3];
        }
        *(ulong long *)(ResourceManagerPointer + 0xa1) = CONCAT44(fStack_b4,fStack_b8);
        *(ulong long *)(ResourceManagerPointer + 0xa3) = CONCAT44(uStack_ac,fStack_b0);
        unsignedSystemValue8 = unsignedSystemValue8 + 1;
      } while (unsignedSystemValue8 < *(uint *)(lStack_88 + 0x10));
    }
    pfloatValue7 = *(float **)(ResourceManagerPointer + 0x6e);
    if ((pfloatValue7 != (float *)0x0) && (((uint)pfloatValue7[0x4e] & 0x3000) != 0)) {
      UnsignedStackFlag78 = *(void* *)(ResourceManagerPointer + 0x48);
      processFlags70 = *(void* *)(ResourceManagerPointer + 0x4a);
      EncryptionValue68 = *(void* *)(ResourceManagerPointer + 0x4c);
      unsignedValue60 = *(void* *)(ResourceManagerPointer + 0x4e);
      memoryAllocationBuffer = *(void* **)(ResourceManagerPointer + 0x50);
      fStack_50 = ResourceManagerPointer[0x52];
      fStack_4c = ResourceManagerPointer[0x53];
      pEncryptionValue48 = *(void* **)(ResourceManagerPointer + 0x54);
      unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x56);
      FUN_180085c10(&UnsignedStackFlag78);
      FUN_18063a240(pfloatValue1,pfloatValue1,&UnsignedStackFlag78);
      pfloatValue7 = *(float **)(ResourceManagerPointer + 0x6e);
      if (((uint)pfloatValue7[0x4e] & 0x3000) == 0x2000) {
        UnsignedStackFlag78 = *(void* *)(ResourceManagerPointer + 0x48);
        processFlags70 = *(void* *)(ResourceManagerPointer + 0x4a);
        EncryptionValue68 = *(void* *)(ResourceManagerPointer + 0x4c);
        unsignedValue60 = *(void* *)(ResourceManagerPointer + 0x4e);
        memoryAllocationBuffer = *(void* **)(ResourceManagerPointer + 0x50);
        fStack_50 = ResourceManagerPointer[0x52];
        fStack_4c = ResourceManagerPointer[0x53];
        pEncryptionValue48 = *(void* **)(ResourceManagerPointer + 0x54);
        unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x56);
        FUN_180085ac0(&UnsignedStackFlag78,0x3fc90fdb);
        FUN_18063a240(pfloatValue1,pfloatValue1,&UnsignedStackFlag78);
        UnsignedStackFlag78 = *(void* *)(ResourceManagerPointer + 0x48);
        processFlags70 = *(void* *)(ResourceManagerPointer + 0x4a);
        EncryptionValue68 = *(void* *)(ResourceManagerPointer + 0x4c);
        unsignedValue60 = *(void* *)(ResourceManagerPointer + 0x4e);
        memoryAllocationBuffer = *(void* **)(ResourceManagerPointer + 0x50);
        fStack_50 = ResourceManagerPointer[0x52];
        fStack_4c = ResourceManagerPointer[0x53];
        pEncryptionValue48 = *(void* **)(ResourceManagerPointer + 0x54);
        unsignedValue40 = *(void* *)(ResourceManagerPointer + 0x56);
        FUN_180085970(&UnsignedStackFlag78);
        pfloatValue7 = (float *)FUN_18063a240(pfloatValue1,pfloatValue1,&UnsignedStackFlag78);
      }
    }
    pfloatValue4 = pfStack_98;
    if (ResourceManagerPointer[0xa1] < *pfloatValue1) {
      ResourceManagerPointer[0xa9] = 0.0;
      pfloatValue1[0] = 0.0;
      pfloatValue1[1] = 0.0;
      ResourceManagerPointer[0x9f] = 0.0;
      ResourceManagerPointer[0xa0] = 0.0;
      ResourceManagerPointer[0xa1] = 0.0;
      ResourceManagerPointer[0xa2] = 0.0;
      ResourceManagerPointer[0xa3] = 0.0;
      ResourceManagerPointer[0xa4] = 0.0;
      ResourceManagerPointer[0xa5] = 0.0;
      ResourceManagerPointer[0xa6] = 0.0;
      ResourceManagerPointer[0xa7] = 0.0;
      ResourceManagerPointer[0xa8] = 0.0;
    }
    else {
      ResourceManagerPointer[0xa5] = (ResourceManagerPointer[0xa1] + *pfloatValue1) * 0.5;
      ResourceManagerPointer[0xa6] = (ResourceManagerPointer[0xa2] + ResourceManagerPointer[0x9e]) * 0.5;
      ResourceManagerPointer[0xa7] = (ResourceManagerPointer[0xa3] + ResourceManagerPointer[0x9f]) * 0.5;
      ResourceManagerPointer[0xa8] = 3.4028235e+38;
      floatValue6 = 0.0;
      unsignedSystemValue9 = (ulong long)*(uint *)(lStack_88 + 0x10);
      if (0 < (int)*(uint *)(lStack_88 + 0x10)) {
        pfloatValue7 = *(float **)(lStack_88 + 0x18);
        floatValue11 = floatValue6;
        do {
          floatValue6 = (*pfloatValue7 - ResourceManagerPointer[0xa5]) * (*pfloatValue7 - ResourceManagerPointer[0xa5]) +
                  (pfloatValue7[1] - ResourceManagerPointer[0xa6]) * (pfloatValue7[1] - ResourceManagerPointer[0xa6]) +
                  (pfloatValue7[2] - ResourceManagerPointer[0xa7]) * (pfloatValue7[2] - ResourceManagerPointer[0xa7]);
          if (floatValue6 <= floatValue11) {
            floatValue6 = floatValue11;
          }
          pfloatValue7 = pfloatValue7 + 4;
          unsignedSystemValue9 = unsignedSystemValue9 - 1;
          floatValue11 = floatValue6;
        } while (unsignedSystemValue9 != 0);
      }
      ResourceManagerPointer[0xa9] = SQRT(floatValue6);
    }
    if (pfStack_98 != (float *)0x0) {
      while( true ) {
        LOCK();
        charValue = *(char *)(pfloatValue4 + 0x3b);
        isByteValid0 = charValue == '\0';
        if (isByteValid0) {
          *(char *)(pfloatValue4 + 0x3b) = '\x01';
          charValue = '\0';
        }
        UNLOCK();
        if (isByteValid0) break;
        floatValue6 = (float)_Thrd_id();
        if ((pfloatValue4[0x3c] == floatValue6) || (pfloatValue4[0x3c] != 0.0)) goto LAB_180075f4f;
        Sleep();
      }
      charValue = '\0';
LAB_180075f4f:
      LOCK();
      pfloatValue1 = pfloatValue4 + 0x3a;
      floatValue6 = *pfloatValue1;
      pfloatValue7 = (float *)(ulong long)(uint)floatValue6;
      *pfloatValue1 = (float)((int)*pfloatValue1 + -1);
      UNLOCK();
      if (charValue == '\0') {
        if ((((floatValue6 == 1.4013e-45) && (*(long long *)(pfStack_98 + 0x84) != 0)) &&
            (pfloatValue7 = pfStack_98, FUN_1800791a0(pfStack_98), *(char *)(pfloatValue7 + 0x3f) == '\0')) &&
           ((*(char *)(pfloatValue7 + 0x3d) == '\0' &&
            (((*(byte *)((long long)pfloatValue7 + 0xfd) & 0x20) == 0 ||
             ((*(byte *)((long long)pfloatValue7 + 0xfe) & 1) == 0)))))) {
          plocalResourceOffset = *(long long **)(pfloatValue7 + 0x84);
          pfloatValue7[0x84] = 0.0;
          pfloatValue7[0x85] = 0.0;
          if (plocalResourceOffset != (long long *)0x0) {
            (**(code **)(*plocalResourceOffset + 0x38))();
          }
        }
        LOCK();
        isSystemActive = *(byte *)(pfloatValue4 + 0x3b);
        *(byte *)(pfloatValue4 + 0x3b) = 0;
        pfloatValue7 = (float *)(ulong long)isSystemActive;
        UNLOCK();
      }
    }
  }
  return pfloatValue7;
}



0001800797c0)
0001800797c8)
0001800797cd)
0001800797dd)


// 函数: void FUN_1800796b0(long long ResourceManagerPointer)
void FUN_1800796b0(long long ResourceManagerPointer)

{
  int *pointerToInteger1;
  uint *HashEntryStatus;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  float floatValue5;
  void* hashValue;
  void* unsignedSystemValue7;
  uint8_t aunsignedSystemValue8 [16];
  bool isSystemBusy;
  int *pointerToInteger10;
  int systemStatus1;
  long long nextDataIndex2;
  int *pointerToInteger13;
  int *pointerToInteger14;
  int *pointerToInteger15;
  int *pointerToInteger16;
  long long nextDataIndex7;
  float *pmagnitudeSquared1;
  uint systemStatus9;
  int *pointerToInteger20;
  long long localSystemHandle1;
  long long localSystemHandle2;
  long long localSystemHandle3;
  long long localSystemHandle4;
  int *pointerToInteger25;
  int *pointerToInteger26;
  int systemResult7;
  ulong long creationFlags8;
  uint32_t *HashEntryStatus9;
  ulong long allocationContext0;
  long long localResourceOffset1;
  uint *HashNodePointer2;
  uint allocationContext3;
  int *pointerToInteger34;
  uint8_t (*paallocationContext5) [16];
  ulong long allocationContext6;
  uint8_t (*paallocationContext7) [16];
  ulong long allocationContext8;
  long long *plocalResourceOffset9;
  long long bufferBaseAddress0;
  ulong long unsignedSystemValue41;
  uint8_t (*paunsignedSystemValue42) [16];
  long long bufferBaseAddress3;
  bool isResourceAvailable4;
  float floatValue45;
  float floatValue46;
  uint8_t aunsignedSystemValue47 [16];
  float floatValue48;
  float floatValue49;
  float floatValue50;
  float floatValue51;
  float floatValue52;
  float floatValue53;
  int iStackX_10;
  ulong long uStackX_18;
  ulong long uStackX_20;
  int *piStack_218;
  int *piStack_210;
  int *piStack_208;
  uint32_t StackValue200;
  int *piStack_1f8;
  int *piStack_1f0;
  int iStack_1e8;
  uint8_t (*paGlobalDataFlags2) [16];
  ulong long uStack_1d8;
  long long longValue1d0;
  uint StackValue1c8;
  uint GlobalDataFlags;
  uint32_t uStack_1bc;
  void* uStack_1b8;
  int *piStack_1b0;
  uint32_t uStack_1a8;
  void* systemFlag1A0;
  void* SystemStackFlag;
  int *piStack_190;
  uint32_t unsignedValue188;
  void* unsignedValue180;
  float fStack_178;
  float fStack_174;
  long long longValue170;
  long long *plStack_168;
  long long *plStack_160;
  uint32_t uStack_158;
  uint8_t auStack_150 [16];
  void* uStack_140;
  uint32_t uStack_138;
  uint32_t *puStack_130;
  void* uStack_128;
  void* uStack_120;
  uint32_t UnsignedStackFlag118;
  void* UnsignedStackFlag110;
  void* unsignedValue108;
  void* unsignedValue100;
  void* unsignedValueF8;
  void* uStack_f0;
  void* uStack_e8;
  void* uStack_e0;
  void* unsignedValueD8;
  void* uStack_d0;
  void* uStack_c8;
  void* UnsignedStackFlagC0;
  void* UnsignedStackFlagB8;
  uint32_t UnsignedStackFlagB0;
  
  UnsignedStackFlag110 = 0xfffffffffffffffe;
  pointerToInteger1 = (int *)(ResourceManagerPointer + 0x60);
  systemResult7 = *pointerToInteger1;
  systemStatus1 = *(int *)(ResourceManagerPointer + 0x88);
  creationFlags8 = (ulong long)systemStatus1;
  iStack_1e8 = *(int *)(ResourceManagerPointer + 0x10);
  puStack_130 = (uint32_t *)0x0;
  uStack_128 = 0;
  uStack_120 = 0;
  UnsignedStackFlag118 = 3;
  FUN_180080ca0(&puStack_130,creationFlags8);
  unsignedSystemValue41 = creationFlags8;
  HashEntryStatus9 = puStack_130;
  if (0 < systemStatus1) {
    for (; unsignedSystemValue41 != 0; unsignedSystemValue41 = unsignedSystemValue41 - 1) {
      *HashEntryStatus9 = 1;
      HashEntryStatus9 = HashEntryStatus9 + 1;
    }
  }
  auStack_150 = ZEXT816(0);
  uStack_140 = 0;
  uStack_138 = 3;
  localSystemHandle1 = (ulong long)*(ushort *)(ResourceManagerPointer + 0xc0) + 1;
  if (localSystemHandle1 == 0) {
    localSystemHandle1 = 0;
    auStack_150 = ZEXT816(0) << 0x40;
  }
  else {
    FUN_180082290(auStack_150,localSystemHandle1);
    localSystemHandle1 = auStack_150._0_8_;
  }
  paGlobalDataFlags2 = (uint8_t (*) [16])(ulong long)*(ushort *)(ResourceManagerPointer + 0xc0);
  localSystemHandle3 = -1;
  do {
    localResourceOffset1 = localSystemHandle3 + 1;
    localSystemHandle2 = localResourceOffset1 * 0x20;
    nextDataIndex7 = *(long long *)(localSystemHandle1 + 8 + localSystemHandle2);
    localSystemHandle4 = *(long long *)(localSystemHandle1 + localSystemHandle2);
    unsignedSystemValue41 = nextDataIndex7 - localSystemHandle4 >> 4;
    if (unsignedSystemValue41 < creationFlags8) {
      allocationContext0 = creationFlags8 - unsignedSystemValue41;
      if ((ulong long)(*(long long *)(localSystemHandle1 + 0x10 + localSystemHandle2) - nextDataIndex7 >> 4) < allocationContext0) {
        if (unsignedSystemValue41 == 0) {
          unsignedSystemValue41 = 1;
        }
        else {
          unsignedSystemValue41 = unsignedSystemValue41 * 2;
        }
        if (unsignedSystemValue41 < creationFlags8) {
          unsignedSystemValue41 = creationFlags8;
        }
        if (unsignedSystemValue41 == 0) {
          nextDataIndex2 = 0;
        }
        else {
          nextDataIndex2 = CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue41 << 4,*(uint8_t *)(localSystemHandle1 + 0x18 + localSystemHandle2))
          ;
          nextDataIndex7 = *(long long *)(localSystemHandle1 + 8 + localSystemHandle2);
          localSystemHandle4 = *(long long *)(localSystemHandle1 + localSystemHandle2);
        }
        if (localSystemHandle4 != nextDataIndex7) {
            memmove(nextDataIndex2,localSystemHandle4,nextDataIndex7 - localSystemHandle4);
        }
        if (allocationContext0 != 0) {
            memset(nextDataIndex2,0,allocationContext0 * 0x10);
        }
        if (*(long long *)(localSystemHandle1 + localSystemHandle2) != 0) {
            SystemCleanupFunction();
        }
        *(long long *)(localSystemHandle1 + localSystemHandle2) = nextDataIndex2;
        *(long long *)(localSystemHandle1 + 8 + localSystemHandle2) = nextDataIndex2;
        *(ulong long *)(localSystemHandle1 + 0x10 + localSystemHandle2) = unsignedSystemValue41 * 0x10 + nextDataIndex2;
      }
      else {
        if (allocationContext0 != 0) {
            memset(nextDataIndex7,0,allocationContext0 * 0x10);
        }
        *(long long *)(localSystemHandle1 + 8 + localSystemHandle2) = nextDataIndex7;
      }
    }
    else {
      *(ulong long *)(localSystemHandle1 + 8 + localSystemHandle2) = creationFlags8 * 0x10 + localSystemHandle4;
    }
    allocationContext6 = 0;
    unsignedSystemValue41 = allocationContext6;
    allocationContext0 = allocationContext6;
    allocationContext8 = creationFlags8;
    if (0 < (long long)creationFlags8) {
      do {
        localSystemHandle1 = *(long long *)(ResourceManagerPointer + 0x90);
        localSystemHandle4 = (long long)*(int *)(localSystemHandle1 + 8 + unsignedSystemValue41);
        nextDataIndex7 = (long long)*(int *)(localSystemHandle1 + 4 + unsignedSystemValue41) * 0x5c;
        if (localSystemHandle3 == -1) {
          nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x68);
          bufferBaseAddress0 = *(long long *)(ResourceManagerPointer + 0x18);
          nextDataIndex7 = (long long)*(int *)(nextDataIndex7 + nextDataIndex2);
          localSystemHandle1 = (long long)*(int *)((long long)*(int *)(localSystemHandle1 + unsignedSystemValue41) * 0x5c + nextDataIndex2);
          floatValue48 = *(float *)(bufferBaseAddress0 + 8 + localSystemHandle1 * 0x10);
          floatValue49 = *(float *)(bufferBaseAddress0 + 8 + nextDataIndex7 * 0x10) - floatValue48;
          floatValue5 = *(float *)(bufferBaseAddress0 + 4 + localSystemHandle1 * 0x10);
          floatValue52 = *(float *)(bufferBaseAddress0 + 4 + nextDataIndex7 * 0x10);
          floatValue51 = *(float *)(bufferBaseAddress0 + localSystemHandle1 * 0x10);
          localSystemHandle1 = (long long)*(int *)(localSystemHandle4 * 0x5c + nextDataIndex2);
          floatValue48 = *(float *)(bufferBaseAddress0 + 8 + localSystemHandle1 * 0x10) - floatValue48;
          floatValue45 = *(float *)(bufferBaseAddress0 + 4 + localSystemHandle1 * 0x10);
          floatValue46 = *(float *)(bufferBaseAddress0 + nextDataIndex7 * 0x10);
          floatValue53 = *(float *)(bufferBaseAddress0 + localSystemHandle1 * 0x10);
        }
        else {
          nextDataIndex2 = *(long long *)(ResourceManagerPointer + 0x68);
          bufferBaseAddress0 = *(long long *)(localSystemHandle3 * 0x50 + *(long long *)(ResourceManagerPointer + 0xb0) + 8);
          nextDataIndex7 = (long long)*(int *)(nextDataIndex7 + nextDataIndex2);
          localSystemHandle1 = (long long)*(int *)((long long)*(int *)(localSystemHandle1 + unsignedSystemValue41) * 0x5c + nextDataIndex2);
          floatValue48 = *(float *)(bufferBaseAddress0 + 8 + localSystemHandle1 * 0x10);
          floatValue49 = *(float *)(bufferBaseAddress0 + 8 + nextDataIndex7 * 0x10) - floatValue48;
          floatValue5 = *(float *)(bufferBaseAddress0 + 4 + localSystemHandle1 * 0x10);
          floatValue52 = *(float *)(bufferBaseAddress0 + 4 + nextDataIndex7 * 0x10);
          floatValue51 = *(float *)(bufferBaseAddress0 + localSystemHandle1 * 0x10);
          localSystemHandle1 = (long long)*(int *)(localSystemHandle4 * 0x5c + nextDataIndex2);
          floatValue48 = *(float *)(bufferBaseAddress0 + 8 + localSystemHandle1 * 0x10) - floatValue48;
          floatValue45 = *(float *)(bufferBaseAddress0 + 4 + localSystemHandle1 * 0x10);
          floatValue46 = *(float *)(bufferBaseAddress0 + nextDataIndex7 * 0x10);
          floatValue53 = *(float *)(bufferBaseAddress0 + localSystemHandle1 * 0x10);
        }
        floatValue50 = (floatValue46 - floatValue51) * (floatValue45 - floatValue5) - (floatValue52 - floatValue5) * (floatValue53 - floatValue51);
        floatValue51 = floatValue49 * (floatValue53 - floatValue51) - floatValue48 * (floatValue46 - floatValue51);
        floatValue48 = floatValue48 * (floatValue52 - floatValue5) - floatValue49 * (floatValue45 - floatValue5);
        fStack_174 = SQRT(floatValue51 * floatValue51 + floatValue48 * floatValue48 + floatValue50 * floatValue50);
        if (fStack_174 <= 0.0) {
          floatValue48 = 0.0;
          floatValue51 = 0.0;
          fStack_178 = 1.0;
          fStack_174 = 1.0;
        }
        else {
          fStack_178 = 1.0 / fStack_174;
          floatValue48 = floatValue48 * fStack_178;
          floatValue51 = fStack_178 * floatValue51;
          fStack_178 = fStack_178 * floatValue50;
        }
        unsignedValue180 = CONCAT44(floatValue51,floatValue48);
        pmagnitudeSquared1 = (float *)(*(long long *)(auStack_150._0_8_ + localSystemHandle2) + allocationContext0);
        *pmagnitudeSquared1 = floatValue48;
        pmagnitudeSquared1[1] = floatValue51;
        pmagnitudeSquared1[2] = fStack_178;
        pmagnitudeSquared1[3] = fStack_174;
        allocationContext8 = allocationContext8 - 1;
        unsignedSystemValue41 = unsignedSystemValue41 + 0xc;
        allocationContext0 = allocationContext0 + 0x10;
      } while (allocationContext8 != 0);
    }
    localSystemHandle1 = auStack_150._0_8_;
    localSystemHandle3 = localResourceOffset1;
  } while (localResourceOffset1 < (long long)paGlobalDataFlags2);
  longValue170 = 0;
  plStack_168 = (long long *)0x0;
  plStack_160 = (long long *)0x0;
  uStack_158 = 3;
  FUN_180081010(&longValue170,(long long)systemResult7);
  unsignedSystemValue41 = allocationContext6;
  uStackX_20 = creationFlags8;
  if (0 < (long long)creationFlags8) {
    do {
      localSystemHandle3 = longValue170;
      pointerToInteger13 = (int *)0x0;
      localSystemHandle1 = *(long long *)(ResourceManagerPointer + 0x90);
      localResourceOffset1 = (ulong long)*(uint *)(localSystemHandle1 + allocationContext6) * 0x20;
      pointerToInteger20 = *(int **)(localResourceOffset1 + 8 + longValue170);
      systemResult7 = (int)unsignedSystemValue41;
      if (pointerToInteger20 < *(int **)(localResourceOffset1 + 0x10 + longValue170)) {
        *(int **)(localResourceOffset1 + 8 + longValue170) = pointerToInteger20 + 1;
        *pointerToInteger20 = systemResult7;
      }
      else {
        pointerToInteger15 = *(int **)(localResourceOffset1 + longValue170);
        nextDataIndex7 = (long long)pointerToInteger20 - (long long)pointerToInteger15 >> 2;
        if (nextDataIndex7 == 0) {
          nextDataIndex7 = 1;
LAB_180079c12:
          pointerToInteger13 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex7 * 4,
                                         *(uint8_t *)(localResourceOffset1 + 0x18 + longValue170));
          pointerToInteger20 = *(int **)(localResourceOffset1 + 8 + localSystemHandle3);
          pointerToInteger15 = *(int **)(localResourceOffset1 + localSystemHandle3);
        }
        else {
          nextDataIndex7 = nextDataIndex7 * 2;
          if (nextDataIndex7 != 0) goto LAB_180079c12;
        }
        if (pointerToInteger15 != pointerToInteger20) {
            memmove(pointerToInteger13,pointerToInteger15,(long long)pointerToInteger20 - (long long)pointerToInteger15);
        }
        *pointerToInteger13 = systemResult7;
        if (*(long long *)(localResourceOffset1 + localSystemHandle3) != 0) {
            SystemCleanupFunction();
        }
        *(int **)(localResourceOffset1 + localSystemHandle3) = pointerToInteger13;
        *(int **)(localResourceOffset1 + 8 + localSystemHandle3) = pointerToInteger13 + 1;
        *(int **)(localResourceOffset1 + 0x10 + localSystemHandle3) = pointerToInteger13 + nextDataIndex7;
      }
      localSystemHandle3 = longValue170;
      pointerToInteger13 = (int *)0x0;
      localResourceOffset1 = (ulong long)*(uint *)(localSystemHandle1 + 4 + allocationContext6) * 0x20;
      pointerToInteger20 = *(int **)(localResourceOffset1 + 8 + longValue170);
      if (pointerToInteger20 < *(int **)(localResourceOffset1 + 0x10 + longValue170)) {
        *(int **)(localResourceOffset1 + 8 + longValue170) = pointerToInteger20 + 1;
        *pointerToInteger20 = systemResult7;
      }
      else {
        pointerToInteger15 = *(int **)(localResourceOffset1 + longValue170);
        nextDataIndex7 = (long long)pointerToInteger20 - (long long)pointerToInteger15 >> 2;
        if (nextDataIndex7 == 0) {
          nextDataIndex7 = 1;
LAB_180079cd7:
          pointerToInteger13 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,nextDataIndex7 * 4,
                                         *(uint8_t *)(localResourceOffset1 + 0x18 + longValue170));
          pointerToInteger20 = *(int **)(localResourceOffset1 + 8 + localSystemHandle3);
          pointerToInteger15 = *(int **)(localResourceOffset1 + localSystemHandle3);
        }
        else {
          nextDataIndex7 = nextDataIndex7 * 2;
          if (nextDataIndex7 != 0) goto LAB_180079cd7;
        }
        if (pointerToInteger15 != pointerToInteger20) {
            memmove(pointerToInteger13,pointerToInteger15,(long long)pointerToInteger20 - (long long)pointerToInteger15);
        }
        *pointerToInteger13 = systemResult7;
        if (*(long long *)(localResourceOffset1 + localSystemHandle3) != 0) {
            SystemCleanupFunction();
        }
        *(int **)(localResourceOffset1 + localSystemHandle3) = pointerToInteger13;
        *(int **)(localResourceOffset1 + 8 + localSystemHandle3) = pointerToInteger13 + 1;
        *(int **)(localResourceOffset1 + 0x10 + localSystemHandle3) = pointerToInteger13 + nextDataIndex7;
      }
      localSystemHandle3 = longValue170;
      localSystemHandle1 = (ulong long)*(uint *)(localSystemHandle1 + 8 + allocationContext6) * 0x20;
      pointerToInteger20 = *(int **)(localSystemHandle1 + 8 + longValue170);
      if (pointerToInteger20 < *(int **)(localSystemHandle1 + 0x10 + longValue170)) {
        *(int **)(localSystemHandle1 + 8 + longValue170) = pointerToInteger20 + 1;
        *pointerToInteger20 = systemResult7;
      }
      else {
        pointerToInteger13 = *(int **)(localSystemHandle1 + longValue170);
        localResourceOffset1 = (long long)pointerToInteger20 - (long long)pointerToInteger13 >> 2;
        if (localResourceOffset1 == 0) {
          localResourceOffset1 = 1;
LAB_180079d9b:
          pointerToInteger15 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,localResourceOffset1 * 4,
                                         *(uint8_t *)(localSystemHandle1 + 0x18 + longValue170));
          pointerToInteger20 = *(int **)(localSystemHandle1 + 8 + localSystemHandle3);
          pointerToInteger13 = *(int **)(localSystemHandle1 + localSystemHandle3);
        }
        else {
          localResourceOffset1 = localResourceOffset1 * 2;
          if (localResourceOffset1 != 0) goto LAB_180079d9b;
          pointerToInteger15 = (int *)0x0;
        }
        if (pointerToInteger13 != pointerToInteger20) {
            memmove(pointerToInteger15,pointerToInteger13,(long long)pointerToInteger20 - (long long)pointerToInteger13);
        }
        *pointerToInteger15 = systemResult7;
        if (*(long long *)(localSystemHandle1 + localSystemHandle3) != 0) {
            SystemCleanupFunction();
        }
        *(int **)(localSystemHandle1 + localSystemHandle3) = pointerToInteger15;
        *(int **)(localSystemHandle1 + 8 + localSystemHandle3) = pointerToInteger15 + 1;
        *(int **)(localSystemHandle1 + 0x10 + localSystemHandle3) = pointerToInteger15 + localResourceOffset1;
      }
      allocationContext6 = allocationContext6 + 0xc;
      uStackX_20 = uStackX_20 - 1;
      unsignedSystemValue41 = (ulong long)(systemResult7 + 1);
    } while (uStackX_20 != 0);
  }
  systemStatus9 = 0;
  SystemInitializationFlag = 0;
  if (*pointerToInteger1 < 1) {
LAB_18007a5ac:
    FUN_180080fa0(&longValue170);
    localSystemHandle1 = (long long)iStack_1e8;
    uStack_1d8 = (ulong long)*(ushort *)(ResourceManagerPointer + 0xc0);
    uStackX_18 = -1;
    do {
      piStack_218 = (int *)0x0;
      piStack_210 = (int *)0x0;
      piStack_208 = (int *)0x0;
      StackValue200 = 3;
      if (localSystemHandle1 == 0) {
        FUN_180082880(0);
        piStack_210 = piStack_218;
      }
      else {
        FUN_1800824a0(&piStack_218,localSystemHandle1);
      }
      plocalResourceOffset9 = (long long *)((uStackX_18 + 1) * 0x20 + auStack_150._0_8_);
      localSystemHandle3 = 0;
      piStack_1f0 = (int *)0x0;
      if (0 < (long long)creationFlags8) {
        piStack_1f8 = (int *)0x0;
        do {
          localSystemHandle1 = 0;
          unsignedValue180 = *(long long *)(ResourceManagerPointer + 0x90) + (long long)piStack_1f8;
          systemStatus9 = puStack_130[(long long)piStack_1f0];
          if (systemStatus9 == 0) {
            do {
              if (uStackX_18 == -1) {
                localResourceOffset1 = (long long)*(int *)(unsignedValue180 + localSystemHandle1 * 4) * 0x5c +
                         *(long long *)(ResourceManagerPointer + 0x68);
                hashValue = ((void* *)(localSystemHandle3 + *plocalResourceOffset9))[1];
                *(void* *)(localResourceOffset1 + 4) = *(void* *)(localSystemHandle3 + *plocalResourceOffset9);
                *(void* *)(localResourceOffset1 + 0xc) = hashValue;
                hashValue = ((void* *)(localSystemHandle3 + *plocalResourceOffset9))[1];
                *(void* *)(localResourceOffset1 + 0x34) = *(void* *)(localSystemHandle3 + *plocalResourceOffset9);
                *(void* *)(localResourceOffset1 + 0x3c) = hashValue;
                floatValue48 = *(float *)(localResourceOffset1 + 8);
                floatValue52 = *(float *)(localResourceOffset1 + 4);
                floatValue51 = *(float *)(localResourceOffset1 + 0xc);
                floatValue45 = floatValue51 * floatValue51 + floatValue52 * floatValue52 + floatValue48 * floatValue48;
                aunsignedSystemValue47 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aunsignedSystemValue47._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *(float *)(localResourceOffset1 + 4) = floatValue45 * floatValue52;
                *(float *)(localResourceOffset1 + 8) = floatValue45 * floatValue48;
                *(float *)(localResourceOffset1 + 0xc) = floatValue45 * floatValue51;
                floatValue48 = *(float *)(localResourceOffset1 + 0x38);
                floatValue52 = *(float *)(localResourceOffset1 + 0x34);
                floatValue51 = *(float *)(localResourceOffset1 + 0x3c);
                floatValue45 = floatValue51 * floatValue51 + floatValue52 * floatValue52 + floatValue48 * floatValue48;
                aunsignedSystemValue47 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aunsignedSystemValue47._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *(float *)(localResourceOffset1 + 0x34) = floatValue52 * floatValue45;
                *(float *)(localResourceOffset1 + 0x38) = floatValue48 * floatValue45;
                *(float *)(localResourceOffset1 + 0x3c) = floatValue51 * floatValue45;
              }
              else {
                hashValue = ((void* *)(localSystemHandle3 + *plocalResourceOffset9))[1];
                HashNodePointer = (void* *)
                         (*(long long *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0x30 + uStackX_18 * 0x50) +
                         (long long)*(int *)(unsignedValue180 + localSystemHandle1 * 4) * 0x10);
                *HashNodePointer = *(void* *)(localSystemHandle3 + *plocalResourceOffset9);
                HashNodePointer[1] = hashValue;
                pmagnitudeSquared1 = (float *)((long long)*(int *)(unsignedValue180 + localSystemHandle1 * 4) * 0x10 +
                                   *(long long *)
                                    (*(long long *)(ResourceManagerPointer + 0xb0) + 0x30 + uStackX_18 * 0x50));
                floatValue48 = pmagnitudeSquared1[1];
                floatValue52 = *pmagnitudeSquared1;
                floatValue51 = pmagnitudeSquared1[2];
                floatValue45 = floatValue51 * floatValue51 + floatValue52 * floatValue52 + floatValue48 * floatValue48;
                aunsignedSystemValue47 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aunsignedSystemValue47._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *pmagnitudeSquared1 = floatValue52 * floatValue45;
                pmagnitudeSquared1[1] = floatValue48 * floatValue45;
                pmagnitudeSquared1[2] = floatValue51 * floatValue45;
              }
              localSystemHandle1 = localSystemHandle1 + 1;
            } while (localSystemHandle1 < 3);
          }
          else {
            longValue1d0 = 0;
            do {
              pointerToInteger1 = piStack_218;
              localResourceOffset1 = 0;
              HashNodePointer2 = (uint *)((long long)*(int *)(unsignedValue180 + longValue1d0 * 4) * 0x5c +
                                *(long long *)(ResourceManagerPointer + 0x68));
              isResourceAvailable4 = false;
              nextDataIndex7 = (long long)
                       (int)((*(long long *)((long long)(piStack_218 + (ulong long)*HashNodePointer2 * 8) + 8) -
                             *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8)) / 0x14);
              localSystemHandle1 = localResourceOffset1;
              if (3 < nextDataIndex7) {
                localSystemHandle4 = (nextDataIndex7 - 4U >> 2) + 1;
                localSystemHandle1 = localSystemHandle4 * 4;
                do {
                  allocationContext3 = *HashNodePointer2;
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)allocationContext3 * 8) + localResourceOffset1) &
                      systemStatus9) != 0) {
                    HashEntryStatus = (uint *)(localResourceOffset1 + *(long long *)(piStack_218 + (ulong long)allocationContext3 * 8));
                    *HashEntryStatus = *HashEntryStatus | systemStatus9;
                    localSystemHandle2 = *plocalResourceOffset9;
                    floatValue48 = *(float *)(localSystemHandle3 + 8 + localSystemHandle2);
                    floatValue52 = *(float *)(localSystemHandle3 + 4 + localSystemHandle2);
                    nextDataIndex2 = *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8);
                    *(float *)(nextDataIndex2 + 4 + localResourceOffset1) =
                         *(float *)(nextDataIndex2 + 4 + localResourceOffset1) + *(float *)(localSystemHandle3 + localSystemHandle2);
                    *(float *)(nextDataIndex2 + 8 + localResourceOffset1) = floatValue52 + *(float *)(nextDataIndex2 + 8 + localResourceOffset1);
                    *(float *)(nextDataIndex2 + 0xc + localResourceOffset1) = floatValue48 + *(float *)(nextDataIndex2 + 0xc + localResourceOffset1);
                    isResourceAvailable4 = true;
                    allocationContext3 = *HashNodePointer2;
                  }
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)allocationContext3 * 8) + 0x14 + localResourceOffset1)
                      & systemStatus9) != 0) {
                    HashEntryStatus = (uint *)(*(long long *)(piStack_218 + (ulong long)allocationContext3 * 8) + 0x14 +
                                     localResourceOffset1);
                    *HashEntryStatus = *HashEntryStatus | systemStatus9;
                    localSystemHandle2 = *plocalResourceOffset9;
                    floatValue48 = *(float *)(localSystemHandle3 + 8 + localSystemHandle2);
                    floatValue52 = *(float *)(localSystemHandle3 + 4 + localSystemHandle2);
                    nextDataIndex2 = *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8);
                    *(float *)(nextDataIndex2 + 0x18 + localResourceOffset1) =
                         *(float *)(nextDataIndex2 + 0x18 + localResourceOffset1) + *(float *)(localSystemHandle3 + localSystemHandle2);
                    *(float *)(nextDataIndex2 + 0x1c + localResourceOffset1) = floatValue52 + *(float *)(nextDataIndex2 + 0x1c + localResourceOffset1)
                    ;
                    *(float *)(nextDataIndex2 + 0x20 + localResourceOffset1) = floatValue48 + *(float *)(nextDataIndex2 + 0x20 + localResourceOffset1)
                    ;
                    isResourceAvailable4 = true;
                    allocationContext3 = *HashNodePointer2;
                  }
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)allocationContext3 * 8) + 0x28 + localResourceOffset1)
                      & systemStatus9) != 0) {
                    HashEntryStatus = (uint *)(*(long long *)(piStack_218 + (ulong long)allocationContext3 * 8) + 0x28 +
                                     localResourceOffset1);
                    *HashEntryStatus = *HashEntryStatus | systemStatus9;
                    localSystemHandle2 = *plocalResourceOffset9;
                    floatValue48 = *(float *)(localSystemHandle3 + 8 + localSystemHandle2);
                    floatValue52 = *(float *)(localSystemHandle3 + 4 + localSystemHandle2);
                    nextDataIndex2 = *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8);
                    *(float *)(nextDataIndex2 + 0x2c + localResourceOffset1) =
                         *(float *)(nextDataIndex2 + 0x2c + localResourceOffset1) + *(float *)(localSystemHandle3 + localSystemHandle2);
                    *(float *)(nextDataIndex2 + 0x30 + localResourceOffset1) = floatValue52 + *(float *)(nextDataIndex2 + 0x30 + localResourceOffset1)
                    ;
                    *(float *)(nextDataIndex2 + 0x34 + localResourceOffset1) = floatValue48 + *(float *)(nextDataIndex2 + 0x34 + localResourceOffset1)
                    ;
                    isResourceAvailable4 = true;
                  }
                  allocationContext3 = *(uint *)(localResourceOffset1 + 0x3c +
                                    *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8));
                  if ((systemStatus9 & allocationContext3) != 0) {
                    *(uint *)(*(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8) + 0x3c + localResourceOffset1)
                         = allocationContext3 | systemStatus9;
                    localSystemHandle2 = *plocalResourceOffset9;
                    floatValue48 = *(float *)(localSystemHandle3 + 8 + localSystemHandle2);
                    floatValue52 = *(float *)(localSystemHandle3 + 4 + localSystemHandle2);
                    nextDataIndex2 = *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8);
                    *(float *)(nextDataIndex2 + 0x40 + localResourceOffset1) =
                         *(float *)(nextDataIndex2 + 0x40 + localResourceOffset1) + *(float *)(localSystemHandle3 + localSystemHandle2);
                    *(float *)(nextDataIndex2 + 0x44 + localResourceOffset1) = floatValue52 + *(float *)(nextDataIndex2 + 0x44 + localResourceOffset1)
                    ;
                    *(float *)(nextDataIndex2 + 0x48 + localResourceOffset1) = floatValue48 + *(float *)(nextDataIndex2 + 0x48 + localResourceOffset1)
                    ;
                    isResourceAvailable4 = true;
                  }
                  localResourceOffset1 = localResourceOffset1 + 0x50;
                  localSystemHandle4 = localSystemHandle4 + -1;
                } while (localSystemHandle4 != 0);
              }
              paunsignedSystemValue42 = (uint8_t (*) [16])0x0;
              if (localSystemHandle1 < nextDataIndex7) {
                localResourceOffset1 = localSystemHandle1 * 0x14;
                nextDataIndex7 = nextDataIndex7 - localSystemHandle1;
                do {
                  allocationContext3 = *(uint *)(localResourceOffset1 + *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8));
                  if ((systemStatus9 & allocationContext3) != 0) {
                    *(uint *)(localResourceOffset1 + *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8)) =
                         allocationContext3 | systemStatus9;
                    localSystemHandle1 = *plocalResourceOffset9;
                    floatValue48 = *(float *)(localSystemHandle3 + 8 + localSystemHandle1);
                    floatValue52 = *(float *)(localSystemHandle3 + 4 + localSystemHandle1);
                    localSystemHandle4 = *(long long *)(piStack_218 + (ulong long)*HashNodePointer2 * 8);
                    *(float *)(localResourceOffset1 + 4 + localSystemHandle4) =
                         *(float *)(localResourceOffset1 + 4 + localSystemHandle4) + *(float *)(localSystemHandle3 + localSystemHandle1);
                    *(float *)(localResourceOffset1 + 8 + localSystemHandle4) = floatValue52 + *(float *)(localResourceOffset1 + 8 + localSystemHandle4);
                    *(float *)(localResourceOffset1 + 0xc + localSystemHandle4) = floatValue48 + *(float *)(localResourceOffset1 + 0xc + localSystemHandle4);
                    isResourceAvailable4 = true;
                  }
                  localResourceOffset1 = localResourceOffset1 + 0x14;
                  nextDataIndex7 = nextDataIndex7 + -1;
                } while (nextDataIndex7 != 0);
              }
              if (!isResourceAvailable4) {
                localSystemHandle1 = *plocalResourceOffset9;
                uStack_1b8._4_4_ = *(uint32_t *)(localSystemHandle3 + 8 + localSystemHandle1);
                uStack_1b8._0_4_ = *(uint32_t *)(localSystemHandle3 + 4 + localSystemHandle1);
                uStack_1bc = *(uint32_t *)(localSystemHandle3 + localSystemHandle1);
                systemFlag1A0 = (int *)CONCAT44((uint32_t)uStack_1b8,uStack_1bc);
                SystemStackFlag = (int *)CONCAT44(0x7f7fffff,uStack_1b8._4_4_);
                piStack_1b0 = (int *)CONCAT44(piStack_1b0._4_4_,0x7f7fffff);
                unsignedSystemValue41 = (ulong long)*HashNodePointer2;
                paallocationContext7 = *(uint8_t (**) [16])(piStack_218 + unsignedSystemValue41 * 8 + 2);
                GlobalDataFlags = systemStatus9;
                if (paallocationContext7 < *(uint8_t (**) [16])(piStack_218 + unsignedSystemValue41 * 8 + 4)) {
                  *(uint8_t **)(piStack_218 + unsignedSystemValue41 * 8 + 2) = paallocationContext7[1] + 4;
                  aunsignedSystemValue8._4_4_ = uStack_1bc;
                  aunsignedSystemValue8._0_4_ = systemStatus9;
                  aunsignedSystemValue8._8_4_ = (uint32_t)uStack_1b8;
                  aunsignedSystemValue8._12_4_ = uStack_1b8._4_4_;
                  *paallocationContext7 = aunsignedSystemValue8;
                  *(uint32_t *)paallocationContext7[1] = 0x7f7fffff;
                }
                else {
                  paallocationContext5 = *(uint8_t (**) [16])(piStack_218 + unsignedSystemValue41 * 8);
                  localSystemHandle1 = ((long long)paallocationContext7 - (long long)paallocationContext5) / 0x14;
                  if (localSystemHandle1 == 0) {
                    uStackX_20 = 1;
LAB_18007ac04:
                    paunsignedSystemValue42 = (uint8_t (*) [16])
                               CreateSystemThreadObject(SystemMemoryPoolTemplate,uStackX_20 * 0x14,
                                             (char)piStack_218[unsignedSystemValue41 * 8 + 6]);
                    paallocationContext7 = *(uint8_t (**) [16])(pointerToInteger1 + unsignedSystemValue41 * 8 + 2);
                    paallocationContext5 = *(uint8_t (**) [16])(pointerToInteger1 + unsignedSystemValue41 * 8);
                  }
                  else {
                    uStackX_20 = localSystemHandle1 * 2;
                    if (uStackX_20 != 0) goto LAB_18007ac04;
                  }
                  paGlobalDataFlags2 = paunsignedSystemValue42;
                  if (paallocationContext5 != paallocationContext7) {
                      memmove(paunsignedSystemValue42,paallocationContext5,(long long)paallocationContext7 - (long long)paallocationContext5);
                  }
                  aunsignedSystemValue47._4_4_ = uStack_1bc;
                  aunsignedSystemValue47._0_4_ = GlobalDataFlags;
                  aunsignedSystemValue47._8_4_ = (uint32_t)uStack_1b8;
                  aunsignedSystemValue47._12_4_ = uStack_1b8._4_4_;
                  *paunsignedSystemValue42 = aunsignedSystemValue47;
                  *(uint32_t *)paunsignedSystemValue42[1] = piStack_1b0._0_4_;
                  if (*(long long *)(pointerToInteger1 + unsignedSystemValue41 * 8) != 0) {
                      SystemCleanupFunction();
                  }
                  *(uint8_t (**) [16])(pointerToInteger1 + unsignedSystemValue41 * 8) = paunsignedSystemValue42;
                  *(uint8_t **)(pointerToInteger1 + unsignedSystemValue41 * 8 + 2) = paunsignedSystemValue42[1] + 4;
                  *(ulong long *)(pointerToInteger1 + unsignedSystemValue41 * 8 + 4) = (long long)paunsignedSystemValue42 + uStackX_20 * 0x14;
                }
              }
              longValue1d0 = longValue1d0 + 1;
            } while (longValue1d0 < 3);
          }
          piStack_1f0 = (int *)((long long)piStack_1f0 + 1);
          piStack_1f8 = piStack_1f8 + 3;
          localSystemHandle3 = localSystemHandle3 + 0x10;
        } while ((long long)piStack_1f0 < (long long)creationFlags8);
        localSystemHandle1 = (long long)iStack_1e8;
      }
      nextDataIndex7 = 0;
      localSystemHandle3 = nextDataIndex7;
      localResourceOffset1 = localSystemHandle1;
      if (0 < localSystemHandle1) {
        do {
          systemResult7 = (int)((*(long long *)(localSystemHandle3 + 8 + (long long)piStack_218) -
                         *(long long *)(localSystemHandle3 + (long long)piStack_218)) / 0x14);
          localSystemHandle2 = (long long)systemResult7;
          localSystemHandle4 = nextDataIndex7;
          if (0 < systemResult7) {
            do {
              nextDataIndex2 = *(long long *)(localSystemHandle3 + (long long)piStack_218);
              floatValue48 = *(float *)(nextDataIndex2 + 8 + localSystemHandle4);
              floatValue52 = *(float *)(nextDataIndex2 + 4 + localSystemHandle4);
              floatValue51 = *(float *)(nextDataIndex2 + 0xc + localSystemHandle4);
              floatValue45 = floatValue52 * floatValue52 + floatValue48 * floatValue48 + floatValue51 * floatValue51;
              if (SQRT(floatValue45) == 0.0) {
                *(uint8_t (*) [16])(nextDataIndex2 + 4 + localSystemHandle4) = SystemZeroVectorData;
              }
              else {
                aunsignedSystemValue47 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aunsignedSystemValue47._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *(float *)(nextDataIndex2 + 4 + localSystemHandle4) = floatValue52 * floatValue45;
                *(float *)(nextDataIndex2 + 8 + localSystemHandle4) = floatValue45 * floatValue48;
                *(float *)(nextDataIndex2 + 0xc + localSystemHandle4) = floatValue51 * floatValue45;
              }
              localSystemHandle2 = localSystemHandle2 + -1;
              localSystemHandle4 = localSystemHandle4 + 0x14;
            } while (localSystemHandle2 != 0);
          }
          localResourceOffset1 = localResourceOffset1 + -1;
          localSystemHandle3 = localSystemHandle3 + 0x20;
        } while (localResourceOffset1 != 0);
      }
      localSystemHandle3 = nextDataIndex7;
      if (0 < (long long)creationFlags8) {
        do {
          systemStatus9 = puStack_130[localSystemHandle3];
          if (systemStatus9 != 0) {
            localSystemHandle1 = *(long long *)(ResourceManagerPointer + 0x90);
            nextDataIndex2 = (long long)*(int *)(nextDataIndex7 + localSystemHandle1) * 0x5c;
            localSystemHandle2 = (long long)*(int *)(*(long long *)(ResourceManagerPointer + 0x68) + nextDataIndex2);
            localSystemHandle4 = 0;
            systemResult7 = (int)((*(long long *)(piStack_218 + localSystemHandle2 * 8 + 2) -
                           *(long long *)(piStack_218 + localSystemHandle2 * 8)) / 0x14);
            localResourceOffset1 = -1;
            if (0 < systemResult7) {
              HashNodePointer2 = *(uint **)(piStack_218 + localSystemHandle2 * 8);
              do {
                localResourceOffset1 = localSystemHandle4;
                if ((*HashNodePointer2 & systemStatus9) != 0) break;
                localSystemHandle4 = localSystemHandle4 + 1;
                HashNodePointer2 = HashNodePointer2 + 5;
                localResourceOffset1 = -1;
              } while (localSystemHandle4 < systemResult7);
            }
            localSystemHandle4 = *(long long *)(piStack_218 + localSystemHandle2 * 8);
            HashNodePointer = (void* *)(localSystemHandle4 + 4 + localResourceOffset1 * 0x14);
            hashValue = *HashNodePointer;
            unsignedSystemValue7 = HashNodePointer[1];
            if (uStackX_18 == -1) {
              HashNodePointer = (void* *)(*(long long *)(ResourceManagerPointer + 0x68) + 4 + nextDataIndex2);
              *HashNodePointer = hashValue;
              HashNodePointer[1] = unsignedSystemValue7;
              HashNodePointer = (void* *)(localSystemHandle4 + 4 + localResourceOffset1 * 0x14);
              hashValue = HashNodePointer[1];
              punsignedSystemValue4 = (void* *)
                       ((long long)*(int *)(nextDataIndex7 + localSystemHandle1) * 0x5c + 0x34 +
                       *(long long *)(ResourceManagerPointer + 0x68));
              *punsignedSystemValue4 = *HashNodePointer;
              punsignedSystemValue4[1] = hashValue;
            }
            else {
              HashNodePointer = (void* *)
                       (*(long long *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0x30 + uStackX_18 * 0x50) +
                       (long long)*(int *)(nextDataIndex7 + localSystemHandle1) * 0x10);
              *HashNodePointer = hashValue;
              HashNodePointer[1] = unsignedSystemValue7;
            }
            bufferBaseAddress0 = (long long)*(int *)(nextDataIndex7 + 4 + localSystemHandle1);
            nextDataIndex2 = bufferBaseAddress0 * 0x5c;
            localSystemHandle2 = (long long)*(int *)(*(long long *)(ResourceManagerPointer + 0x68) + nextDataIndex2);
            localSystemHandle4 = 0;
            systemResult7 = (int)((*(long long *)(piStack_218 + localSystemHandle2 * 8 + 2) -
                           *(long long *)(piStack_218 + localSystemHandle2 * 8)) / 0x14);
            localResourceOffset1 = -1;
            if (0 < systemResult7) {
              HashNodePointer2 = *(uint **)(piStack_218 + localSystemHandle2 * 8);
              do {
                localResourceOffset1 = localSystemHandle4;
                if ((*HashNodePointer2 & systemStatus9) != 0) break;
                localSystemHandle4 = localSystemHandle4 + 1;
                HashNodePointer2 = HashNodePointer2 + 5;
                localResourceOffset1 = -1;
              } while (localSystemHandle4 < systemResult7);
            }
            localSystemHandle4 = *(long long *)(piStack_218 + localSystemHandle2 * 8);
            HashNodePointer = (void* *)(localSystemHandle4 + 4 + localResourceOffset1 * 0x14);
            hashValue = *HashNodePointer;
            unsignedSystemValue7 = HashNodePointer[1];
            if (uStackX_18 == -1) {
              HashNodePointer = (void* *)(*(long long *)(ResourceManagerPointer + 0x68) + 4 + nextDataIndex2);
              *HashNodePointer = hashValue;
              HashNodePointer[1] = unsignedSystemValue7;
              HashNodePointer = (void* *)(localSystemHandle4 + 4 + localResourceOffset1 * 0x14);
              hashValue = HashNodePointer[1];
              punsignedSystemValue4 = (void* *)
                       ((long long)*(int *)(nextDataIndex7 + 4 + localSystemHandle1) * 0x5c + 0x34 +
                       *(long long *)(ResourceManagerPointer + 0x68));
              *punsignedSystemValue4 = *HashNodePointer;
              punsignedSystemValue4[1] = hashValue;
            }
            else {
              HashNodePointer = (void* *)
                       (*(long long *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0x30 + uStackX_18 * 0x50) +
                       bufferBaseAddress0 * 0x10);
              *HashNodePointer = hashValue;
              HashNodePointer[1] = unsignedSystemValue7;
            }
            bufferBaseAddress0 = (long long)*(int *)(nextDataIndex7 + 8 + localSystemHandle1);
            bufferBaseAddress3 = bufferBaseAddress0 * 0x5c;
            nextDataIndex2 = (long long)*(int *)(bufferBaseAddress3 + *(long long *)(ResourceManagerPointer + 0x68));
            localSystemHandle4 = 0;
            localSystemHandle2 = (long long)
                     (int)((*(long long *)(piStack_218 + nextDataIndex2 * 8 + 2) -
                           *(long long *)(piStack_218 + nextDataIndex2 * 8)) / 0x14);
            localResourceOffset1 = -1;
            if (0 < localSystemHandle2) {
              HashNodePointer2 = *(uint **)(piStack_218 + nextDataIndex2 * 8);
              do {
                localResourceOffset1 = localSystemHandle4;
                if ((*HashNodePointer2 & systemStatus9) != 0) break;
                localSystemHandle4 = localSystemHandle4 + 1;
                HashNodePointer2 = HashNodePointer2 + 5;
                localResourceOffset1 = -1;
              } while (localSystemHandle4 < localSystemHandle2);
            }
            localSystemHandle4 = *(long long *)(piStack_218 + nextDataIndex2 * 8);
            aunsignedSystemValue47 = *(uint8_t (*) [16])(localSystemHandle4 + 4 + localResourceOffset1 * 0x14);
            if (uStackX_18 == -1) {
              *(uint8_t (*) [16])(bufferBaseAddress3 + 4 + *(long long *)(ResourceManagerPointer + 0x68)) = aunsignedSystemValue47;
              HashNodePointer = (void* *)(localSystemHandle4 + 4 + localResourceOffset1 * 0x14);
              hashValue = HashNodePointer[1];
              punsignedSystemValue4 = (void* *)
                       ((long long)*(int *)(nextDataIndex7 + 8 + localSystemHandle1) * 0x5c + 0x34 +
                       *(long long *)(ResourceManagerPointer + 0x68));
              *punsignedSystemValue4 = *HashNodePointer;
              punsignedSystemValue4[1] = hashValue;
            }
            else {
              *(uint8_t (*) [16])
               (*(long long *)(*(long long *)(ResourceManagerPointer + 0xb0) + 0x30 + uStackX_18 * 0x50) +
               bufferBaseAddress0 * 0x10) = aunsignedSystemValue47;
            }
          }
          localSystemHandle3 = localSystemHandle3 + 1;
          nextDataIndex7 = nextDataIndex7 + 0xc;
        } while (localSystemHandle3 < (long long)creationFlags8);
        localSystemHandle1 = (long long)iStack_1e8;
      }
      FUN_1800810b0(&piStack_218);
      uStackX_18 = uStackX_18 + 1;
      if ((long long)uStack_1d8 <= (long long)uStackX_18) {
        FUN_180080fa0(auStack_150);
        if (puStack_130 != (uint32_t *)0x0) {
            SystemCleanupFunction(puStack_130);
        }
        return;
      }
    } while( true );
  }
  longValue1d0 = 0;
LAB_180079e40:
  paunsignedSystemValue42 = (uint8_t (*) [16])(longValue1d0 * 0x20);
  pointerToInteger20 = *(int **)(*paunsignedSystemValue42 + longValue170);
  unsignedSystemValue41 = *(long long *)(*paunsignedSystemValue42 + longValue170 + 8) - (long long)pointerToInteger20 >> 2;
  paGlobalDataFlags2 = paunsignedSystemValue42;
  if (1 < unsignedSystemValue41) {
    isResourceAvailable4 = true;
    StackValue1c8 = puStack_130[*pointerToInteger20];
    systemResult7 = 1;
    systemStatus9 = StackValue1c8;
    pointerToInteger13 = pointerToInteger20;
    do {
      pointerToInteger13 = pointerToInteger13 + 1;
      if ((systemStatus9 & puStack_130[*pointerToInteger13]) == 0) {
        isResourceAvailable4 = false;
        break;
      }
      systemStatus9 = systemStatus9 | puStack_130[*pointerToInteger13];
      systemResult7 = systemResult7 + 1;
    } while ((ulong long)(long long)systemResult7 < unsignedSystemValue41);
    systemStatus9 = (uint)uStackX_18;
    if (!isResourceAvailable4) {
      systemFlag1A0 = (int *)0x0;
      SystemStackFlag = (int *)0x0;
      piStack_190 = (int *)0x0;
      unsignedValue188 = 3;
      pointerToInteger14 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,4,CONCAT71((uint7)(uint3)(uStackX_18 >> 8),3));
      *pointerToInteger14 = *pointerToInteger20;
      pointerToInteger20 = pointerToInteger14 + 1;
      piStack_218 = (int *)0x0;
      piStack_210 = (int *)0x0;
      pointerToInteger13 = (int *)0x0;
      piStack_208 = (int *)0x0;
      StackValue200 = 3;
      iStackX_10 = 1;
      piStack_1f8 = *(int **)(*paunsignedSystemValue42 + longValue170);
      pointerToInteger15 = pointerToInteger20;
      systemFlag1A0 = pointerToInteger14;
      SystemStackFlag = pointerToInteger20;
      piStack_190 = pointerToInteger20;
      if (1 < (ulong long)(*(long long *)(*paunsignedSystemValue42 + longValue170 + 8) - (long long)piStack_1f8 >> 2)) {
        uStackX_20 = 4;
        pointerToInteger25 = (int *)0x0;
        do {
          pointerToInteger26 = piStack_210;
          pointerToInteger16 = (int *)0x0;
          if (piStack_210 < pointerToInteger13) {
            *piStack_210 = *(int *)(uStackX_20 + (long long)piStack_1f8);
            pointerToInteger16 = pointerToInteger25;
          }
          else {
            uStack_1d8 = (long long)piStack_210 - (long long)pointerToInteger25;
            if ((long long)uStack_1d8 >> 2 == 0) {
              piStack_1f0 = (int *)0x1;
LAB_180079fb3:
              pointerToInteger16 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)piStack_1f0 * 4,
                                             CONCAT71((int7)(uStackX_20 >> 8),3));
            }
            else {
              piStack_1f0 = (int *)(((long long)uStack_1d8 >> 2) * 2);
              if (piStack_1f0 != (int *)0x0) goto LAB_180079fb3;
            }
            if (pointerToInteger25 != pointerToInteger26) {
                memmove(pointerToInteger16,pointerToInteger25,uStack_1d8);
            }
            *pointerToInteger16 = *(int *)(uStackX_20 + (long long)piStack_1f8);
            if (pointerToInteger25 != (int *)0x0) {
                SystemCleanupFunction(pointerToInteger25);
            }
            pointerToInteger13 = pointerToInteger16 + (long long)piStack_1f0;
            paunsignedSystemValue42 = paGlobalDataFlags2;
            piStack_218 = pointerToInteger16;
            piStack_208 = pointerToInteger13;
            piStack_210 = pointerToInteger16;
          }
          piStack_210 = piStack_210 + 1;
          iStackX_10 = iStackX_10 + 1;
          uStackX_20 = uStackX_20 + 4;
          piStack_1f8 = *(int **)(*paunsignedSystemValue42 + longValue170);
          pointerToInteger25 = pointerToInteger16;
        } while ((ulong long)(long long)iStackX_10 <
                 (ulong long)(*(long long *)(*paunsignedSystemValue42 + longValue170 + 8) - (long long)piStack_1f8 >> 2)
                );
      }
      do {
        pointerToInteger13 = (int *)0x0;
        GlobalDataFlags = 0;
        uStack_1bc = 0;
        uStack_1b8 = (int *)0x0;
        piStack_1b0 = (int *)0x0;
        uStack_1a8 = 3;
        isResourceAvailable4 = false;
        isSystemBusy = false;
        allocationContext3 = 0;
        unsignedValue180 = (long long)piStack_210 - (long long)piStack_218 >> 2;
        pointerToInteger26 = (int *)0x0;
        pointerToInteger25 = (int *)0x0;
        pointerToInteger16 = pointerToInteger25;
        pointerToInteger34 = pointerToInteger13;
        pointerToInteger10 = piStack_218;
        piStack_1f8 = piStack_210;
        if (unsignedValue180 != 0) {
          do {
            piStack_1f0 = pointerToInteger10;
            pointerToInteger16 = (int *)0x0;
            systemResult7 = *piStack_1f0;
            if ((StackValue1c8 & puStack_130[systemResult7]) == 0) {
              if (pointerToInteger26 < pointerToInteger13) {
                *pointerToInteger26 = systemResult7;
                pointerToInteger16 = pointerToInteger25;
                allocationContext3 = (uint)pointerToInteger34;
              }
              else {
                uStack_1d8 = (long long)pointerToInteger26 - (long long)pointerToInteger25;
                if ((long long)uStack_1d8 >> 2 == 0) {
                  localSystemHandle1 = 1;
LAB_18007a203:
                  pointerToInteger16 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemHandle1 * 4,3);
                }
                else {
                  localSystemHandle1 = ((long long)uStack_1d8 >> 2) * 2;
                  if (localSystemHandle1 != 0) goto LAB_18007a203;
                }
                if (pointerToInteger25 != pointerToInteger26) {
                    memmove(pointerToInteger16,pointerToInteger25,uStack_1d8);
                }
                *pointerToInteger16 = *piStack_1f0;
                if (pointerToInteger25 != (int *)0x0) {
                    SystemCleanupFunction(pointerToInteger25);
                }
                GlobalDataFlags = (uint)pointerToInteger16;
                uStack_1bc = (uint32_t)((ulong long)pointerToInteger16 >> 0x20);
                pointerToInteger13 = pointerToInteger16 + localSystemHandle1;
                piStack_1b0 = pointerToInteger13;
                pointerToInteger26 = pointerToInteger16;
              }
              pointerToInteger26 = pointerToInteger26 + 1;
              uStack_1b8 = pointerToInteger26;
              isResourceAvailable4 = isSystemBusy;
            }
            else {
              StackValue1c8 = StackValue1c8 | puStack_130[systemResult7];
              if (pointerToInteger20 < pointerToInteger15) {
                SystemStackFlag = pointerToInteger20 + 1;
                *pointerToInteger20 = systemResult7;
                pointerToInteger20 = SystemStackFlag;
                pointerToInteger16 = pointerToInteger25;
                allocationContext3 = (uint)pointerToInteger34;
                isResourceAvailable4 = true;
              }
              else {
                uStack_1d8 = (long long)pointerToInteger20 - (long long)pointerToInteger14;
                if ((long long)uStack_1d8 >> 2 == 0) {
                  localSystemHandle1 = 1;
LAB_18007a142:
                  pointerToInteger15 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemHandle1 * 4,3);
                }
                else {
                  localSystemHandle1 = ((long long)uStack_1d8 >> 2) * 2;
                  pointerToInteger15 = pointerToInteger16;
                  if (localSystemHandle1 != 0) goto LAB_18007a142;
                }
                if (pointerToInteger14 != pointerToInteger20) {
                    memmove(pointerToInteger15,pointerToInteger14,uStack_1d8);
                }
                *pointerToInteger15 = *piStack_1f0;
                pointerToInteger20 = pointerToInteger15 + 1;
                if (pointerToInteger14 != (int *)0x0) {
                    SystemCleanupFunction(pointerToInteger14);
                }
                piStack_190 = pointerToInteger15 + localSystemHandle1;
                pointerToInteger16 = pointerToInteger25;
                pointerToInteger13 = piStack_1b0;
                pointerToInteger14 = pointerToInteger15;
                systemFlag1A0 = pointerToInteger15;
                SystemStackFlag = pointerToInteger20;
                isResourceAvailable4 = true;
              }
            }
            allocationContext3 = allocationContext3 + 1;
            piStack_1f0 = piStack_1f0 + 1;
            pointerToInteger25 = pointerToInteger16;
            pointerToInteger34 = (int *)(ulong long)allocationContext3;
            pointerToInteger10 = piStack_1f0;
            pointerToInteger15 = piStack_190;
            isSystemBusy = isResourceAvailable4;
          } while ((ulong long)(long long)(int)allocationContext3 < unsignedValue180);
        }
        plocalResourceOffset9 = plStack_168;
        GlobalDataFlags = (uint)piStack_218;
        uStack_1bc = (uint32_t)((ulong long)piStack_218 >> 0x20);
        uStack_1b8._0_4_ = SUB84(piStack_1f8,0);
        uStack_1b8._4_4_ = (uint32_t)((ulong long)piStack_1f8 >> 0x20);
        piStack_1b0 = piStack_208;
        StackValue200 = 3;
        uStack_1a8 = 3;
        piStack_210 = pointerToInteger26;
        piStack_208 = pointerToInteger13;
        piStack_1f8 = pointerToInteger26;
        if ((((long long)pointerToInteger26 - (long long)pointerToInteger16 & 0xfffffffffffffffcU) == 0) || (!isResourceAvailable4))
        goto LAB_18007a312;
        isResourceAvailable4 = piStack_218 != (int *)0x0;
        piStack_218 = pointerToInteger16;
        if (isResourceAvailable4) {
            SystemCleanupFunction();
        }
      } while( true );
    }
  }
  goto LAB_18007a58b;
LAB_18007a312:
  if (piStack_218 != (int *)0x0) {
    piStack_218 = pointerToInteger16;
      SystemCleanupFunction();
  }
  pointerToInteger13 = *(int **)(*paGlobalDataFlags2 + longValue170);
  piStack_218 = pointerToInteger16;
  if (((*(long long *)(*paGlobalDataFlags2 + longValue170 + 8) - (long long)pointerToInteger13 ^
       (long long)pointerToInteger20 - (long long)pointerToInteger14) & 0xfffffffffffffffcU) != 0) {
    *(int **)(*paGlobalDataFlags2 + longValue170) = pointerToInteger14;
    SystemStackFlag = *(int **)(*paGlobalDataFlags2 + longValue170 + 8);
    *(int **)(*paGlobalDataFlags2 + longValue170 + 8) = pointerToInteger20;
    piStack_190 = *(int **)(paGlobalDataFlags2[1] + longValue170);
    *(int **)(paGlobalDataFlags2[1] + longValue170) = pointerToInteger15;
    unsignedValue188 = *(uint32_t *)(paGlobalDataFlags2[1] + longValue170 + 8);
    *(uint32_t *)(paGlobalDataFlags2[1] + longValue170 + 8) = 3;
    systemFlag1A0 = pointerToInteger13;
    if (plStack_168 < plStack_160) {
      unsignedSystemValue41 = (long long)pointerToInteger26 - (long long)pointerToInteger16;
      *(uint32_t *)(plStack_168 + 3) = 3;
      if (unsignedSystemValue41 < 4) {
        localSystemHandle1 = 0;
        plStack_168 = plStack_168 + 4;
      }
      else {
        plStack_168 = plStack_168 + 4;
        localSystemHandle1 = CreateSystemThreadObject(SystemMemoryPoolTemplate,((long long)unsignedSystemValue41 >> 2) * 4,3);
      }
      *plocalResourceOffset9 = localSystemHandle1;
      plocalResourceOffset9[1] = localSystemHandle1;
      plocalResourceOffset9[2] = localSystemHandle1 + ((long long)unsignedSystemValue41 >> 2) * 4;
      if (pointerToInteger16 != pointerToInteger26) {
          memmove(*plocalResourceOffset9,pointerToInteger16,unsignedSystemValue41);
      }
      plocalResourceOffset9[1] = *plocalResourceOffset9;
    }
    else {
      FUN_1800826b0(&longValue170,&piStack_218);
      pointerToInteger26 = piStack_210;
      pointerToInteger16 = piStack_218;
    }
    localSystemHandle3 = longValue1d0;
    systemResult7 = *pointerToInteger1;
    localResourceOffset1 = longValue1d0 * 0x5c;
    localSystemHandle1 = *(long long *)(ResourceManagerPointer + 0x68);
    unsignedValue108 = *(void* *)(localResourceOffset1 + localSystemHandle1);
    unsignedValue100 = ((void* *)(localResourceOffset1 + localSystemHandle1))[1];
    HashNodePointer = (void* *)(localResourceOffset1 + 0x10 + localSystemHandle1);
    unsignedValueF8 = *HashNodePointer;
    uStack_f0 = HashNodePointer[1];
    HashNodePointer = (void* *)(localResourceOffset1 + 0x20 + localSystemHandle1);
    uStack_e8 = *HashNodePointer;
    uStack_e0 = HashNodePointer[1];
    HashNodePointer = (void* *)(localResourceOffset1 + 0x30 + localSystemHandle1);
    unsignedValueD8 = *HashNodePointer;
    uStack_d0 = HashNodePointer[1];
    HashNodePointer = (void* *)(localResourceOffset1 + 0x40 + localSystemHandle1);
    uStack_c8 = *HashNodePointer;
    UnsignedStackFlagC0 = HashNodePointer[1];
    UnsignedStackFlagB8 = *(void* *)(localResourceOffset1 + 0x50 + localSystemHandle1);
    UnsignedStackFlagB0 = *(uint32_t *)(localResourceOffset1 + 0x58 + localSystemHandle1);
    FUN_180080c10(pointerToInteger1,&unsignedValue108);
    allocationContext8 = (long long)pointerToInteger26 - (long long)pointerToInteger16 >> 2;
    allocationContext0 = 0;
    pointerToInteger20 = pointerToInteger16;
    unsignedSystemValue41 = allocationContext0;
    if (allocationContext8 != 0) {
      do {
        localResourceOffset1 = (long long)*pointerToInteger20;
        localSystemHandle1 = *(long long *)(ResourceManagerPointer + 0x90);
        if (*(uint *)(localSystemHandle1 + localResourceOffset1 * 0xc) == (uint)uStackX_18) {
          *(int *)(localSystemHandle1 + localResourceOffset1 * 0xc) = systemResult7;
        }
        if (*(uint *)(localSystemHandle1 + 4 + localResourceOffset1 * 0xc) == (uint)uStackX_18) {
          *(int *)(localSystemHandle1 + 4 + localResourceOffset1 * 0xc) = systemResult7;
        }
        if (*(uint *)(localSystemHandle1 + 8 + localResourceOffset1 * 0xc) == (uint)uStackX_18) {
          *(int *)(localSystemHandle1 + 8 + localResourceOffset1 * 0xc) = systemResult7;
        }
        allocationContext3 = (int)unsignedSystemValue41 + 1;
        pointerToInteger20 = pointerToInteger20 + 1;
        unsignedSystemValue41 = (ulong long)allocationContext3;
      } while ((ulong long)(long long)(int)allocationContext3 < allocationContext8);
    }
    unsignedSystemValue41 = allocationContext0;
    pointerToInteger14 = pointerToInteger13;
    if (*(short *)(ResourceManagerPointer + 0xc0) != 0) {
      do {
        localSystemHandle1 = allocationContext0 + *(long long *)(ResourceManagerPointer + 0xb0);
        localResourceOffset1 = *(long long *)(allocationContext0 + 0x30 + *(long long *)(ResourceManagerPointer + 0xb0));
        HashNodePointer = (void* *)(localResourceOffset1 + localSystemHandle3 * 0x10);
        hashValue = *HashNodePointer;
        unsignedSystemValue7 = HashNodePointer[1];
        systemResult7 = *(int *)(localSystemHandle1 + 0x2c);
        systemStatus1 = *(int *)(localSystemHandle1 + 0x28);
        if (systemResult7 <= systemStatus1) {
          if (systemResult7 < 2) {
            *(uint32_t *)(localSystemHandle1 + 0x2c) = 8;
          }
          else {
            *(int *)(localSystemHandle1 + 0x2c) = (systemResult7 >> 1) + systemResult7;
          }
          FUN_1800846d0(localSystemHandle1 + 0x28);
          systemStatus1 = *(int *)(localSystemHandle1 + 0x28);
          localResourceOffset1 = *(long long *)(localSystemHandle1 + 0x30);
        }
        HashNodePointer = (void* *)(localResourceOffset1 + (long long)systemStatus1 * 0x10);
        *HashNodePointer = hashValue;
        HashNodePointer[1] = unsignedSystemValue7;
        *(int *)(localSystemHandle1 + 0x28) = *(int *)(localSystemHandle1 + 0x28) + 1;
        allocationContext3 = (int)unsignedSystemValue41 + 1;
        allocationContext0 = allocationContext0 + 0x50;
        unsignedSystemValue41 = (ulong long)allocationContext3;
      } while ((int)allocationContext3 < (int)(uint)*(ushort *)(ResourceManagerPointer + 0xc0));
    }
  }
  if (pointerToInteger16 != (int *)0x0) {
      SystemCleanupFunction(pointerToInteger16);
  }
  if (pointerToInteger14 != (int *)0x0) {
      SystemCleanupFunction(pointerToInteger14);
  }
LAB_18007a58b:
  systemStatus9 = systemStatus9 + 1;
  uStackX_18 = (ulong long)systemStatus9;
  longValue1d0 = longValue1d0 + 1;
  if (*pointerToInteger1 <= (int)systemStatus9) goto LAB_18007a5ac;
  goto LAB_180079e40;
}




// 函数: void FUN_18007b1a0(long long *ResourceManagerPointer)
void FUN_18007b1a0(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  
  for (PrimaryResourcePointer = (long long *)*ResourceManagerPointer; PrimaryResourcePointer != (long long *)ResourceManagerPointer[1]; PrimaryResourcePointer = PrimaryResourcePointer + 4) {
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void FUN_18007b1c0(long long *ResourceManagerPointer)
void FUN_18007b1c0(long long *ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  
  for (PrimaryResourcePointer = (long long *)*ResourceManagerPointer; PrimaryResourcePointer != (long long *)ResourceManagerPointer[1]; PrimaryResourcePointer = PrimaryResourcePointer + 4) {
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
  }
  if (*ResourceManagerPointer == 0) {
    return;
  }
    SystemCleanupFunction();
}



uint8_t FUN_18007b1e0(long long ResourceManagerPointer)

{
  char SystemNodeFlag;
  long long localSystemHandle;
  
  localSystemHandle = *(long long *)(ResourceManagerPointer + 0x1b8);
  charStatus = *(char *)(localSystemHandle + 0x38c);
  if (charStatus == '\t') {
    charStatus = func_0x00018022d300();
    *(char *)(localSystemHandle + 0x38c) = charStatus;
  }
  charStatus = FUN_18007b240(ResourceManagerPointer,ResourceManagerPointer + 0x1e8,charStatus);
  if (initializationStatusFlag == '\0') {
    *(byte *)(ResourceManagerPointer + 0xfe) = *(byte *)(ResourceManagerPointer + 0xfe) & 0xfb;
    return 0;
  }
  return 1;
}



00018007b857)
00018007b868)
00018007b879)

ulong long FUN_18007b240(long long ResourceManagerPointer,long long *ConfigurationDataPointer,byte AdditionalParameter,char ConfigurationFlag)

{
  byte *pisByteValid;
  char validationStatusFlag;
  int MemoryComparisonResult;
  int systemIndex;
  byte isMemoryReady;
  long long localSystemFlags;
  void** SystemCurrentNode;
  ulong long unsignedSystemValue8;
  void* unsignedSystemValue9;
  long long *PrimaryResourcePointer0;
  long long *PrimaryResourcePointer1;
  long long *PrimaryResourcePointer2;
  uint32_t systemStatus3;
  long long *PrimaryResourcePointer4;
  bool isByteValid5;
  long long *plStack_f0;
  long long *plStack_e8;
  long long *plStack_e0;
  long long *plStack_d8;
  long long *plStack_d0;
  long long *plStack_c8;
  long long *plStack_c0;
  long long *plStack_b8;
  uint8_t aUnsignedStackFlagB0 [8];
  long long lStack_a8;
  uint32_t UnsignedStackFlagA0;
  long long *plStack_98;
  long long lStack_90;
  uint32_t UnsignedStackFlag88;
  long long *aplStack_78 [2];
  code *pcStack_68;
  void* *punsignedValue60;
  void* processFlags58;
  long long *plStack_50;
  long long *plStack_48;
  long long *plongValue40;
  
  processFlags58 = 0xfffffffffffffffe;
  while ((localSystemFlags = ResourceManagerPointer, (*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0 &&
         (localSystemFlags = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0)), localSystemFlags != ResourceManagerPointer))) {
    if ((ConfigurationFlag != '\0') ||
       (pisByteValid = (byte *)(ResourceManagerPointer + 0x100), ResourceManagerPointer = localSystemFlags, (*pisByteValid & 8) != 0)) {
      ConfigurationFlag = '\x01';
      ResourceManagerPointer = localSystemFlags;
    }
  }
  if ((*(byte *)(ResourceManagerPointer + 0x100) & 8) != 0) {
    ConfigurationFlag = '\x01';
  }
  FUN_18007baa0(ResourceManagerPointer);
  PrimaryResourcePointer4 = (long long *)(*(long long *)(localSystemFlags + 0x1e0) + (ulong long)AdditionalParameter * 0x18);
  if ((long long *)*ConfigurationDataPointer != PrimaryResourcePointer4) {
    if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
      FUN_180080060();
    }
    *ConfigurationDataPointer = (long long)PrimaryResourcePointer4;
    if (PrimaryResourcePointer4 != (long long *)0x0) {
      LOCK();
      *(int *)(PrimaryResourcePointer4 + 2) = (int)PrimaryResourcePointer4[2] + 1;
      UNLOCK();
    }
    if (ConfigurationDataPointer[1] != 0) {
      pisByteValid = (byte *)(ConfigurationDataPointer[1] + 0xfe);
      *pisByteValid = *pisByteValid & 0xfb;
    }
  }
  LOCK();
  isByteValid5 = *(char*)((long long)PrimaryResourcePointer4 + 0x15) == '\0';
  if (isByteValid5) {
    *(char*)((long long)PrimaryResourcePointer4 + 0x15) = '\x01';
  }
  UNLOCK();
  if (!isByteValid5) goto LAB_18007b8fd;
  localSystemFlags = ResourceManagerPointer;
  if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    localSystemFlags = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  if (*(int *)(localSystemFlags + 0x200) < 1) {
    LOCK();
    if (*(char*)((long long)PrimaryResourcePointer4 + 0x15) == '\x01') {
      *(char*)((long long)PrimaryResourcePointer4 + 0x15) = '\x03';
    }
    UNLOCK();
    goto LAB_18007b8fd;
  }
  if (*PrimaryResourcePointer4 == 0) {
    HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,0x20);
    *HashBucketNode = &SystemMemoryTemplateA;
    *HashBucketNode = &SystemMemoryTemplateB;
    *(uint32_t *)(HashBucketNode + 1) = 0;
    *HashBucketNode = &UNK_180a00168;
    LOCK();
    *(uint8_t *)(HashBucketNode + 2) = 0;
    UNLOCK();
    LOCK();
    *(uint32_t *)((long long)HashBucketNode + 0x14) = 0;
    UNLOCK();
    HashBucketNode[3] = 0;
    HashBucketNode[4] = ResourceManagerPointer;
    SystemResourceManagerLink(PrimaryResourcePointer4);
  }
  if (PrimaryResourcePointer4[1] == 0) {
    HashBucketNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,0x20);
    *HashBucketNode = &SystemMemoryTemplateA;
    *HashBucketNode = &SystemMemoryTemplateB;
    *(uint32_t *)(HashBucketNode + 1) = 0;
    *HashBucketNode = &UNK_180a00100;
    LOCK();
    *(uint32_t *)(HashBucketNode + 2) = 0;
    UNLOCK();
    HashBucketNode[3] = 0;
    SystemResourceManagerLink(PrimaryResourcePointer4 + 1);
  }
  UnsignedStackFlag88 = 1;
  lStack_90 = ResourceManagerPointer;
  FUN_18007f770(&lStack_90);
  localSystemFlags = *(long long *)(ResourceManagerPointer + 0x210);
  if (localSystemFlags == 0) {
LAB_18007b44a:
    if (*(long long *)(ResourceManagerPointer + 0xa8) == 0) {
LAB_18007b454:
      LOCK();
      *(uint8_t *)((long long)PrimaryResourcePointer4 + 0x15) = 4;
      UNLOCK();
      unsignedSystemValue8 = FUN_18007f840(&lStack_90);
      return unsignedSystemValue8 & 0xffffffffffffff00;
    }
  }
  else {
    if (*(int *)(localSystemFlags + 0x60) == 0) goto LAB_18007b454;
    if (localSystemFlags == 0) goto LAB_18007b44a;
  }
  unsignedSystemValue9 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xa0,8,0x20);
  PrimaryResourcePointer0 = (long long *)FUN_1800842a0(unsignedSystemValue9);
  plStack_50 = PrimaryResourcePointer0;
  if (PrimaryResourcePointer0 != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
  }
  localSystemFlags = ResourceManagerPointer;
  if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    localSystemFlags = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  *(uint32_t *)(PrimaryResourcePointer0 + 2) = *(uint32_t *)(localSystemFlags + 0x200);
  *(byte *)(PrimaryResourcePointer0 + 0x13) =
       *(byte *)(PrimaryResourcePointer0 + 0x13) ^ (*(byte *)(ResourceManagerPointer + 0xfe) >> 1 ^ *(byte *)(PrimaryResourcePointer0 + 0x13)) & 1;
  *(byte *)((long long)PrimaryResourcePointer0 + 0x14) = AdditionalParameter;
  charResult = *(char *)(ResourceManagerPointer + 0xfa);
  *(char*)((long long)PrimaryResourcePointer0 + 0x15) = charResult;
  if (charResult == '\x01') {
    ConfigurationFlag = '\x01';
  }
  PrimaryResourcePointer1 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,0x20);
  *PrimaryResourcePointer1 = (long long)&SystemMemoryTemplateA;
  *PrimaryResourcePointer1 = (long long)&SystemMemoryTemplateB;
  *(uint32_t *)(PrimaryResourcePointer1 + 1) = 0;
  *PrimaryResourcePointer1 = (long long)&UNK_180a00030;
  PrimaryResourcePointer1[4] = 0;
  PrimaryResourcePointer1[2] = 0;
  *(byte *)(PrimaryResourcePointer1 + 5) = *(byte *)(PrimaryResourcePointer1 + 5) | 1;
  plStack_48 = PrimaryResourcePointer1;
  (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
  isMemoryReady = *(byte *)(ResourceManagerPointer + 0xfd) & 0x20;
  localSystemFlags = ResourceManagerPointer;
  if (isMemoryReady == 0) {
    localSystemFlags = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  systemCounter = *(int *)(localSystemFlags + 0x200);
  localSystemFlags = ResourceManagerPointer;
  if (isMemoryReady == 0) {
    localSystemFlags = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  systemIndex = *(int *)(localSystemFlags + 0x1fc);
  systemStatus3 = 2;
  if (0xffff < systemCounter) {
    systemStatus3 = 4;
  }
  *(byte *)(PrimaryResourcePointer1 + 5) =
       *(byte *)(PrimaryResourcePointer1 + 5) ^ (*(byte *)(ResourceManagerPointer + 0xfe) >> 1 ^ *(byte *)(PrimaryResourcePointer1 + 5)) & 1;
  *(uint32_t *)((long long)PrimaryResourcePointer1 + 0x14) = systemStatus3;
  *(int *)(PrimaryResourcePointer1 + 2) = systemIndex * 3;
  *(uint8_t *)(PrimaryResourcePointer1 + 3) = *(uint8_t *)(ResourceManagerPointer + 0xfa);
  if ((*(long long *)(ResourceManagerPointer + 0xa8) == 0) || (*(long long *)(ResourceManagerPointer + 0x210) != 0)) {
    if (ConfigurationFlag == '\0') {
      unsignedSystemValue9 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xe0,8,3);
      (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
      (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
      pcStack_68 = FUN_180083390;
      punsignedValue60 = &UNK_180083380;
      plStack_b8 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag);
      *plStack_b8 = ResourceManagerPointer;
      *(byte *)(plStack_b8 + 1) = AdditionalParameter;
      plStack_b8[2] = (long long)PrimaryResourcePointer0;
      plStack_b8[3] = (long long)PrimaryResourcePointer1;
      aplStack_78[0] = plStack_b8;
      PrimaryResourcePointer2 = (long long *)FUN_18006b640(unsignedSystemValue9,aplStack_78);
      plStack_c0 = PrimaryResourcePointer2;
      plongValue40 = PrimaryResourcePointer2;
      unsignedSystemValue9 = SystemAllocationFlagsTemplate;
      if (PrimaryResourcePointer2 != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer2 + 0x28))(PrimaryResourcePointer2);
        unsignedSystemValue9 = SystemAllocationFlagsTemplate;
        (**(code **)(*PrimaryResourcePointer2 + 0x28))(PrimaryResourcePointer2);
      }
      FUN_18005e450(unsignedSystemValue9,&plStack_c0);
      if (PrimaryResourcePointer2 != (long long *)0x0) {
        localSystemFlags = *PrimaryResourcePointer2;
LAB_18007b8dc:
        (**(code **)(localSystemFlags + 0x38))(PrimaryResourcePointer2);
      }
    }
    else {
      plStack_e0 = PrimaryResourcePointer1;
      (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
      plStack_d8 = PrimaryResourcePointer0;
      (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
      FUN_18007e080(ResourceManagerPointer,AdditionalParameter,&plStack_d8,&plStack_e0);
      plStack_d0 = PrimaryResourcePointer1;
      (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
      plStack_c8 = PrimaryResourcePointer0;
      (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
      FUN_18007c8e0(ResourceManagerPointer,AdditionalParameter,&plStack_c8,&plStack_d0);
      FUN_18007f840(&lStack_90);
      if (*(char *)(ResourceManagerPointer + 0xf4) == '\x01') {
        plStack_b8 = (long long *)0x0;
        plStack_98 = (long long *)0x0;
        aUnsignedStackFlagB0[0] = 0;
        UnsignedStackFlagA0 = 3;
        lStack_a8 = ResourceManagerPointer;
        FUN_18007f4c0(aUnsignedStackFlagB0);
        PrimaryResourcePointer2 = plStack_98;
        plStack_98 = (long long *)0x0;
        if (PrimaryResourcePointer2 != (long long *)0x0) {
          (**(code **)(*PrimaryResourcePointer2 + 0x38))();
        }
        FUN_18007f6a0(aUnsignedStackFlagB0);
        if (plStack_98 != (long long *)0x0) {
          localSystemFlags = *plStack_98;
          PrimaryResourcePointer2 = plStack_98;
          goto LAB_18007b8dc;
        }
      }
    }
  }
  else {
    plStack_f0 = PrimaryResourcePointer0;
    (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
    plStack_e8 = PrimaryResourcePointer1;
    (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
    FUN_18007c490(ResourceManagerPointer,AdditionalParameter,&plStack_e8,&plStack_f0,ConfigurationFlag);
  }
  (**(code **)(*PrimaryResourcePointer1 + 0x38))(PrimaryResourcePointer1);
  (**(code **)(*PrimaryResourcePointer0 + 0x38))(PrimaryResourcePointer0);
  FUN_18007f840(&lStack_90);
LAB_18007b8fd:
  return (ulong long)((byte)(*(char*)((long long)PrimaryResourcePointer4 + 0x15) - 2U) < 2);
}




// 函数: void FUN_18007b930(long long *ResourceManagerPointer)
void FUN_18007b930(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  long long *resourcePoolPointer;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  long long **pplStackX_20;
  void* allocationContext;
  uint8_t StackBuffer40 [8];
  long long longValue38;
  uint32_t unsignedValue30;
  long long *plStack_28;
  
  allocationContext = 0xfffffffffffffffe;
  nextDataIndex = *ResourceManagerPointer;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)ResourceManagerPointer[3];
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  pplStackX_20 = &plStackX_10;
  plStackX_10 = (long long *)ResourceManagerPointer[2];
  if (plStackX_10 != (long long *)0x0) {
    (**(code **)(*plStackX_10 + 0x28))();
  }
  FUN_18007e080(nextDataIndex,(char)ResourceManagerPointer[1],&plStackX_10,&plStackX_8,allocationContext);
  nextDataIndex = *ResourceManagerPointer;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)ResourceManagerPointer[3];
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  pplStackX_20 = &plStackX_10;
  plStackX_10 = (long long *)ResourceManagerPointer[2];
  if (plStackX_10 != (long long *)0x0) {
    (**(code **)(*plStackX_10 + 0x28))();
  }
  FUN_18007c8e0(nextDataIndex,(char)ResourceManagerPointer[1],&plStackX_10,&plStackX_8);
  longValue38 = *ResourceManagerPointer;
  if (*(char *)(longValue38 + 0xf4) == '\x01') {
    plStackX_8 = (long long *)0x0;
    plStack_28 = (long long *)0x0;
    StackBuffer40[0] = 0;
    unsignedValue30 = 3;
    FUN_18007f4c0(StackBuffer40);
    resourcePoolPointer = plStack_28;
    plStackX_10 = plStack_28;
    plStack_28 = (long long *)0x0;
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x38))();
    }
    FUN_18007f6a0(StackBuffer40);
    if (plStack_28 != (long long *)0x0) {
      (**(code **)(*plStack_28 + 0x38))();
    }
  }
  return;
}




// 函数: void FUN_18007ba60(long long ResourceManagerPointer)
void FUN_18007ba60(long long ResourceManagerPointer)

{
  if (*(long long **)(ResourceManagerPointer + 0x18) != (long long *)0x0) {
    (**(code **)(**(long long **)(ResourceManagerPointer + 0x18) + 0x38))();
  }
  if (*(long long **)(ResourceManagerPointer + 0x10) != (long long *)0x0) {
    (**(code **)(**(long long **)(ResourceManagerPointer + 0x10) + 0x38))();
  }
  return;
}





// 函数: void FUN_18007baa0(long long ResourceManagerPointer)
void FUN_18007baa0(long long ResourceManagerPointer)

{
  void* systemStatus;
  
  if (*(long long *)(ResourceManagerPointer + 0x1e0) == 0) {
    systemStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x180,8,0x1c);
      memset(systemStatus,0,0x180);
  }
  return;
}




// 函数: void FUN_18007bb70(long long *ResourceManagerPointer)
void FUN_18007bb70(long long *ResourceManagerPointer)

{
  if ((long long *)ResourceManagerPointer[1] != (long long *)0x0) {
    (**(code **)(*(long long *)ResourceManagerPointer[1] + 0x38))();
  }
  if ((long long *)*callbackParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*callbackParameter + 0x38))();
  }
  return;
}



00018007c17d)
00018007c188)


/**
 * @brief 游戏对象变换数据复制函数
 * 
 * 该函数负责在游戏对象之间复制变换相关的数据，包括位置、旋转、缩放等
 * 变换矩阵数据。它会比较源对象和目标对象的变换数据，并在需要时进行
 * 数据同步和更新。
 * 
 * @param targetObjectPointer 目标对象指针
 * @param sourceObjectPointer 源对象指针（可为空）
 * @param transformDataSource 变换数据源对象
 */
void CopyGameObjectTransformData(long long targetObjectPointer,long long sourceObjectPointer,long long transformDataSource)

{
  int TransformCompareResult;
  uint32_t SourceFlags;
  uint32_t TargetFlags;
  uint32_t TransformFlags;
  void* TransformDataPointer;
  long long *ObjectMatrixPointer;
  long long TransformOffset;
  long long *SourceMatrixPointer;
  void* *TargetObjectPointer;
  uint *ObjectFlagsPointer;
  uint BitPosition;
  void* *SourceObjectPointer;
  uint SourceObjectFlags;
  uint TargetObjectFlags;
  ulong long StackGuardValue;
  uint BitMask;
  uint CurrentBit;
  uint8_t StackBuffer [32];
  void* StackParameter;
  long long *MatrixStackPointer;
  void* ObjectPointer;
  long long *OffsetPointer;
  long long AlignmentValue;
  ulong long ChecksumValue;
  
  StackParameter = 0xfffffffffffffffe;
  ChecksumValue = SystemSecurityKey ^ (ulong long)StackBuffer;
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(ResourceManagerPointer + 0x238) == *(float *)(ConfigurationDataPointer + 0x44) &&
       (*(float *)(ResourceManagerPointer + 0x23c) == *(float *)(ConfigurationDataPointer + 0x48))) &&
      (*(float *)(ResourceManagerPointer + 0x240) == *(float *)(ConfigurationDataPointer + 0x4c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x4c);
    *(void* *)(ResourceManagerPointer + 0x238) = *(void* *)(AdditionalParameter + 0x44);
    *(void* *)(ResourceManagerPointer + 0x240) = currentThreadId;
  }
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(ResourceManagerPointer + 0x248) == *(float *)(ConfigurationDataPointer + 0x54) &&
       (*(float *)(ResourceManagerPointer + 0x24c) == *(float *)(ConfigurationDataPointer + 0x58))) &&
      (*(float *)(ResourceManagerPointer + 0x250) == *(float *)(ConfigurationDataPointer + 0x5c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x5c);
    *(void* *)(ResourceManagerPointer + 0x248) = *(void* *)(AdditionalParameter + 0x54);
    *(void* *)(ResourceManagerPointer + 0x250) = currentThreadId;
  }
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(ResourceManagerPointer + 0x2a8) == *(float *)(ConfigurationDataPointer + 100) &&
       (*(float *)(ResourceManagerPointer + 0x2ac) == *(float *)(ConfigurationDataPointer + 0x68))) &&
      (*(float *)(ResourceManagerPointer + 0x2b0) == *(float *)(ConfigurationDataPointer + 0x6c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x6c);
    *(void* *)(ResourceManagerPointer + 0x2a8) = *(void* *)(AdditionalParameter + 100);
    *(void* *)(ResourceManagerPointer + 0x2b0) = currentThreadId;
  }
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(ResourceManagerPointer + 0x2b8) == *(float *)(ConfigurationDataPointer + 0x74) &&
       (*(float *)(ResourceManagerPointer + 700) == *(float *)(ConfigurationDataPointer + 0x78))) &&
      (*(float *)(ResourceManagerPointer + 0x2c0) == *(float *)(ConfigurationDataPointer + 0x7c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x7c);
    *(void* *)(ResourceManagerPointer + 0x2b8) = *(void* *)(AdditionalParameter + 0x74);
    *(void* *)(ResourceManagerPointer + 0x2c0) = currentThreadId;
  }
  if (sourceString == 0) {
    *(uint32_t *)(ResourceManagerPointer + 0x100) = *(uint32_t *)(AdditionalParameter + 0x30);
  }
  else {
    systemStatus7 = 1;
    systemStatus1 = 2;
    do {
      pointerToUnsigned10 = (uint *)(ResourceManagerPointer + 0x100);
      systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
      systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      if ((systemStatus7 & systemStatus6) != (systemStatus7 & systemStatus4)) {
        if ((systemStatus7 & systemStatus4) == 0) {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) & ~(1 << (systemStatus1 - 2 & 0x1f));
        }
        else {
          systemStatus6 = *pointerToUnsigned10 | 1 << (systemStatus1 - 2 & 0x1f);
        }
        *pointerToUnsigned10 = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 1 & systemStatus4;
      if ((systemStatus7 << 1 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 - 1 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 - 1 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 2 & systemStatus4;
      if ((systemStatus7 << 2 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 3 & systemStatus4;
      if ((systemStatus7 << 3 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 1 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 1 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 4 & systemStatus4;
      if ((systemStatus7 << 4 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 2 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 2 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 5 & systemStatus4;
      if ((systemStatus7 << 5 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          *pointerToUnsigned10 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 3 & 0x1f));
          systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
          systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
        }
        else {
          *(uint *)(ResourceManagerPointer + 0x100) = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 3 & 0x1f);
          systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
          systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
        }
      }
      pointerToUnsigned10 = (uint *)(ResourceManagerPointer + 0x100);
      systemStatus3 = systemStatus7 << 6 & systemStatus4;
      if ((systemStatus7 << 6 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 4 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 4 & 0x1f);
        }
        *pointerToUnsigned10 = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 7 & systemStatus4;
      if ((systemStatus7 << 7 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 5 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 5 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 8 & systemStatus4;
      if ((systemStatus7 << 8 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 6 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 6 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 9 & systemStatus4;
      if ((systemStatus7 << 9 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 7 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 7 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus3 = systemStatus7 << 10 & systemStatus4;
      if ((systemStatus7 << 10 & systemStatus6) != systemStatus3) {
        if (systemStatus3 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 8 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 8 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
        systemStatus6 = *(uint *)(ConfigurationDataPointer + 0x30);
        systemStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      systemStatus4 = systemStatus7 << 0xb & systemStatus4;
      if ((systemStatus7 << 0xb & systemStatus6) != systemStatus4) {
        if (systemStatus4 == 0) {
          systemStatus6 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 9 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 9 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
      }
      systemStatus6 = systemStatus7 << 0xc & *(uint *)(AdditionalParameter + 0x30);
      if ((systemStatus7 << 0xc & *(uint *)(ConfigurationDataPointer + 0x30)) != systemStatus6) {
        if (systemStatus6 == 0) {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) & ~(1 << (systemStatus1 + 10 & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 10 & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
      }
      systemStatus6 = systemStatus7 << 0xd & *(uint *)(AdditionalParameter + 0x30);
      if ((systemStatus7 << 0xd & *(uint *)(ConfigurationDataPointer + 0x30)) != systemStatus6) {
        if (systemStatus6 == 0) {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) & ~(1 << (systemStatus1 + 0xb & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 0xb & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
      }
      systemStatus6 = systemStatus7 << 0xe & *(uint *)(AdditionalParameter + 0x30);
      if ((systemStatus7 << 0xe & *(uint *)(ConfigurationDataPointer + 0x30)) != systemStatus6) {
        pointerToUnsigned10 = (uint *)(ResourceManagerPointer + 0x100);
        if (systemStatus6 == 0) {
          *pointerToUnsigned10 = *pointerToUnsigned10 & ~(1 << (systemStatus1 + 0xc & 0x1f));
        }
        else {
          *pointerToUnsigned10 = *pointerToUnsigned10 | 1 << (systemStatus1 + 0xc & 0x1f);
        }
      }
      systemStatus6 = systemStatus7 << 0xf & *(uint *)(AdditionalParameter + 0x30);
      if ((systemStatus7 << 0xf & *(uint *)(ConfigurationDataPointer + 0x30)) != systemStatus6) {
        if (systemStatus6 == 0) {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) & ~(1 << (systemStatus1 + 0xd & 0x1f));
        }
        else {
          systemStatus6 = *(uint *)(ResourceManagerPointer + 0x100) | 1 << (systemStatus1 + 0xd & 0x1f);
        }
        *(uint *)(ResourceManagerPointer + 0x100) = systemStatus6;
      }
      systemStatus7 = systemStatus7 << 0x10 | systemStatus7 >> 0x10;
      systemStatus = systemStatus1 + 0xe;
      systemStatus1 = systemStatus1 + 0x10;
    } while (systemStatus < 0x20);
  }
  *(uint32_t *)(ResourceManagerPointer + 0x208) = *(uint32_t *)(AdditionalParameter + 0x84);
  *(uint32_t *)(ResourceManagerPointer + 0x1f8) = *(uint32_t *)(AdditionalParameter + 0x88);
  *(uint32_t *)(ResourceManagerPointer + 0x1fc) = *(uint32_t *)(AdditionalParameter + 0x8c);
  *(uint32_t *)(ResourceManagerPointer + 0x200) = *(uint32_t *)(AdditionalParameter + 0x90);
  *(uint32_t *)(ResourceManagerPointer + 0x204) = *(uint32_t *)(AdditionalParameter + 0x94);
  currentThreadId = *(void* *)(AdditionalParameter + 0xa0);
  *(void* *)(ResourceManagerPointer + 0x274) = *(void* *)(AdditionalParameter + 0x98);
  *(void* *)(ResourceManagerPointer + 0x27c) = currentThreadId;
  currentThreadId = *(void* *)(AdditionalParameter + 0xb0);
  *(void* *)(ResourceManagerPointer + 0x284) = *(void* *)(AdditionalParameter + 0xa8);
  *(void* *)(ResourceManagerPointer + 0x28c) = currentThreadId;
  creationFlags = *(uint32_t *)(AdditionalParameter + 0xbc);
  allocationContext = *(uint32_t *)(AdditionalParameter + 0xc0);
  unsignedSystemValue4 = *(uint32_t *)(AdditionalParameter + 0xc4);
  *(uint32_t *)(ResourceManagerPointer + 0x294) = *(uint32_t *)(AdditionalParameter + 0xb8);
  *(uint32_t *)(ResourceManagerPointer + 0x298) = creationFlags;
  *(uint32_t *)(ResourceManagerPointer + 0x29c) = allocationContext;
  *(uint32_t *)(ResourceManagerPointer + 0x2a0) = unsignedSystemValue4;
  *(uint32_t *)(ResourceManagerPointer + 0x2a4) = *(uint32_t *)(AdditionalParameter + 200);
  plStack_30 = (long long *)0x0;
  lStack_28 = 0;
  if (ConfigurationDataPointer != 0) {
    plocalSystemFlags = (long long *)(ConfigurationDataPointer + 0x158);
    if ((*plocalSystemFlags == 0) && (*(long long *)(ConfigurationDataPointer + 0x160) == 0)) {
      plocalSystemFlags = (long long *)(ConfigurationDataPointer + 0x34);
    }
    plStack_30 = (long long *)*plocalSystemFlags;
    lStack_28 = plocalSystemFlags[1];
  }
  uStack_38 = 0;
  plocalSystemFlags = (long long *)(ResourceManagerPointer + 0x1b8);
  plongValue40 = (long long *)*plocalSystemFlags;
  *plocalSystemFlags = 0;
  if (plongValue40 != (long long *)0x0) {
    (**(code **)(*plongValue40 + 0x38))();
  }
  plocalMemoryAddress = (long long *)(AdditionalParameter + 0x158);
  if ((*plocalMemoryAddress == 0) && (*(long long *)(AdditionalParameter + 0x160) == 0)) {
    plocalMemoryAddress = (long long *)(AdditionalParameter + 0x34);
  }
  localDataIndex = ProcessSystemDataRequest(*(void* *)(ResourceManagerPointer + 0xa8),&SystemRequestTemplate,plocalMemoryAddress);
  if (localDataIndex != 0) {
    FUN_180080810(plocalSystemFlags,localDataIndex + 0xb0);
  }
  if (*plocalSystemFlags == 0) {
    psystemStatus2 = &SystemStringTemplate;
    if (*(void* **)(ResourceManagerPointer + 0x18) != (void* *)0x0) {
      psystemStatus2 = *(void* **)(ResourceManagerPointer + 0x18);
    }
    FUN_180627020(&UNK_1809ffb88,psystemStatus2);
    plocalMemoryAddress = (long long *)FUN_1800be9a0(SystemMemoryContextPointer,&plStack_30,0);
    localDataIndex = *plocalMemoryAddress;
    *plocalMemoryAddress = 0;
    plongValue40 = (long long *)*plocalSystemFlags;
    *plocalSystemFlags = localDataIndex;
    if (plongValue40 != (long long *)0x0) {
      (**(code **)(*plongValue40 + 0x38))();
    }
    if (plStack_30 != (long long *)0x0) {
      (**(code **)(*plStack_30 + 0x38))();
    }
  }
  FUN_1800781e0(ResourceManagerPointer);
  if ((*(long long *)(ResourceManagerPointer + 600) == 0) &&
     ((*(uint *)(*(long long *)(ResourceManagerPointer + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    punsignedSystemValue9 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,0x1c);
    *(void* *)((long long)punsignedSystemValue9 + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(punsignedSystemValue9 + 9) = 0xffffffff;
    *punsignedSystemValue9 = 0;
    punsignedSystemValue9[2] = 0;
    punsignedSystemValue9[7] = 0;
    *(uint32_t *)(punsignedSystemValue9 + 5) = 0xffffffff;
    *(uint32_t *)(punsignedSystemValue9 + 4) = 0xffffffff;
    punsignedSystemValue9[3] = 0;
    *(uint32_t *)(punsignedSystemValue9 + 8) = 0;
    *(uint32_t *)(punsignedSystemValue9 + 1) = 0;
    *(uint8_t *)((long long)punsignedSystemValue9 + 0x44) = 0;
    *(uint8_t *)((long long)punsignedSystemValue9 + 0x24) = 0;
    *(void* **)(ResourceManagerPointer + 600) = punsignedSystemValue9;
  }
  *(uint8_t *)(ResourceManagerPointer + 0xf6) = *(uint8_t *)(AdditionalParameter + 0xcc);
  if ((void* *)(ResourceManagerPointer + 0x218) != (void* *)(AdditionalParameter + 0xd0)) {
    FUN_1800588c0((void* *)(ResourceManagerPointer + 0x218),*(void* *)(AdditionalParameter + 0xd0),
                  *(void* *)(AdditionalParameter + 0xd8));
  }
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x10) = *(uint32_t *)(AdditionalParameter + 0xf0);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x14) = *(uint32_t *)(AdditionalParameter + 0x144);
  *(uint8_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x18) = *(uint8_t *)(AdditionalParameter + 0x148);
  *(uint8_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x19) = *(uint8_t *)(AdditionalParameter + 0x149);
  *(uint8_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x1a) = *(uint8_t *)(AdditionalParameter + 0x14a);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x44) = *(uint32_t *)(AdditionalParameter + 0x118);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x48) = *(uint32_t *)(AdditionalParameter + 0x11c);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x4c) = *(uint32_t *)(AdditionalParameter + 0x120);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x50) = *(uint32_t *)(AdditionalParameter + 0x124);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x54) = *(uint32_t *)(AdditionalParameter + 0x128);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x58) = *(uint32_t *)(AdditionalParameter + 300);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x5c) = *(uint32_t *)(AdditionalParameter + 0x130);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x60) = *(uint32_t *)(AdditionalParameter + 0x134);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 100) = *(uint32_t *)(AdditionalParameter + 0x138);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x68) = *(uint32_t *)(AdditionalParameter + 0x13c);
  *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x268) + 0x6c) = *(uint32_t *)(AdditionalParameter + 0x140);
  localDataIndex = *(long long *)(ResourceManagerPointer + 0x268);
  systemStatus1 = *(uint *)(AdditionalParameter + 0x108);
  systemStatus5 = (ulong long)systemStatus1;
  if (*(long long *)(AdditionalParameter + 0x100) != 0) {
    ExecuteSystemCommand(localDataIndex + 0x20,systemStatus5);
  }
  if (systemStatus1 != 0) {
      memcpy(*(void* *)(localDataIndex + 0x28),*(void* *)(AdditionalParameter + 0x100),systemStatus5);
  }
  *(uint32_t *)(localDataIndex + 0x30) = 0;
  if (*(long long *)(localDataIndex + 0x28) != 0) {
    *(uint8_t *)(systemStatus5 + *(long long *)(localDataIndex + 0x28)) = 0;
  }
  *(uint32_t *)(localDataIndex + 0x3c) = *(uint32_t *)(AdditionalParameter + 0x114);
    ValidateSystemChecksum(unsignedValue20 ^ (ulong long)aEncryptionValue68);
}




/**
 * @brief 系统初始化参数配置函数
 * 
 * 该函数负责配置系统初始化参数，设置初始化标志和配置选项
 * 用于系统初始化过程的参数配置和验证
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志指针
 * @param InitializationFlag 初始化标志
 * 
 * 原始函数名为FUN_18007c490，现已重命名为ConfigureSystemInitializationParameters
 */
void ConfigureSystemInitializationParameters(long long *ResourceManagerPointer,byte ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag,char InitializationFlag)

{
  char *SystemCharacterPointer;
  long long *resourcePoolPointer;
  long long *LocalResourceOffset;
  long long* SystemMemoryPointer;
  code *SystemCodePointer;
  char SystemCharacterFlag;
  void* *HashBucketNode;
  uint32_t SystemStatusFlag1;
  uint32_t SystemStatusFlag2;
  uint32_t SystemStatusFlag3;
  uint32_t SystemStatusFlag4;
  code *SystemFunctionPointer1;
  void* *SystemNodePointer;
  void* ResourceManagerPointer1;
  uint32_t SystemConfigurationFlag1;
  uint32_t SystemConfigurationFlag2;
  long long *SystemDataPointer1;
  byte SystemDataByte1;
  long long *SystemDataPointer2;
  long long *SystemDataPointer3;
  long long *SystemDataPointer4;
  byte SystemDataByte2;
  long long *SystemDataPointer5;
  long long *SystemDataPointer6;
  void* SystemStackParameter;
  long long **SystemDoublePointer;
  uint8_t SystemBuffer1 [16];
  code *SystemFunctionPointer2;
  uint8_t SystemBuffer2 [16];
  code *SystemFunctionPointer3;
  
  SystemStackParameter = 0xfffffffffffffffe;
  resourcePoolPointer = (long long *)*ConfigurationFlag;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
  }
  LocalResourceOffset = (long long *)*AdditionalParameter;
  if (LocalResourceOffset != (long long *)0x0) {
    (**(code **)(*LocalResourceOffset + 0x28))(LocalResourceOffset);
  }
  SystemConfigurationFlag1 = CONCAT31(SystemConfigurationFlag1._1_3_,ConfigurationDataPointer);
  ResourceManagerPointer1 = ResourceManagerPointer;
  if ((void* *)*ResourceManagerPointer == &UNK_180a00270) {
    LOCK();
    *(int *)(ResourceManagerPointer + 1) = (int)ResourceManagerPointer[1] + 1;
    UNLOCK();
  }
  else {
    (**(code **)((void* *)*ResourceManagerPointer + 0x28))(ResourceManagerPointer);
  }
  if (InitializationFlag == '\0') {
    LocalBufferAddress = *(long long **)(ResourceManagerPointer[0x15] + 0x88);
    SystemCodePointer = *(code **)(*LocalBufferAddress + 0x70);
    SystemFunctionPointer1 = (code *)&UNK_180083180;
    SystemNodePointer = &UNK_180083170;
    SystemStatusFlag1 = (uint32_t)ResourceManagerPointer1;
    SystemStatusFlag2 = ResourceManagerPointer1._4_4_;
    SystemStatusFlag3 = SystemConfigurationFlag1;
    SystemStatusFlag4 = SystemConfigurationFlag2;
    SystemDataPointer4 = ResourceManagerPointer;
    SystemDataByte2 = ConfigurationDataPointer;
    SystemDataPointer5 = resourcePoolPointer;
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
    }
    SystemDataPointer6 = LocalResourceOffset;
    if (LocalResourceOffset != (long long *)0x0) {
      (**(code **)(*LocalResourceOffset + 0x28))(LocalResourceOffset);
    }
    FUN_180081120(SystemBuffer2,&SystemDataPointer4);
    (*SystemCodePointer)(LocalBufferAddress,&SystemInitializationData,ResourceManagerPointer + 0x17,0,SystemBuffer2,&SystemStatusFlag1);
    if (SystemFunctionPointer3 != (code *)0x0) {
      (*SystemFunctionPointer3)(SystemBuffer2,0,0);
    }
    if (SystemFunctionPointer1 != (code *)0x0) {
      (*SystemFunctionPointer1)(&SystemStatusFlag1,0,0);
    }
  }
  else {
    LocalBufferAddress = *(long long **)(ResourceManagerPointer[0x15] + 0x88);
    SystemCodePointer = *(code **)(*LocalBufferAddress + 0x60);
    SystemDoublePointer = &SystemDataPointer1;
    SystemDataPointer1 = ResourceManagerPointer;
    SystemDataByte1 = ConfigurationDataPointer;
    SystemDataPointer2 = resourcePoolPointer;
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
    }
    SystemDataPointer3 = LocalResourceOffset;
    if (LocalResourceOffset != (long long *)0x0) {
      (**(code **)(*LocalResourceOffset + 0x28))(LocalResourceOffset);
    }
    FUN_180081120(SystemBuffer1,&SystemDataPointer1);
    SystemCharacterFlag = (*SystemCodePointer)(LocalBufferAddress,&SystemInitializationData,ResourceManagerPointer + 0x17,0,SystemBuffer1);
    if (SystemFunctionPointer2 != (code *)0x0) {
      (*SystemFunctionPointer2)(SystemBuffer1,0,0);
    }
    if (SystemCharacterFlag == '\0') {
      HashBucketNode = &SystemStringTemplate;
      if ((void* *)ResourceManagerPointer[3] != (void* *)0x0) {
        HashBucketNode = (void* *)ResourceManagerPointer[3];
      }
      AllocateSystemMemory(&SystemHashBuffer,HashBucketNode);
      systemFunctionPointer = (char *)(ResourceManagerPointer[0x3c] + 0x15 + (ulong long)ConfigurationDataPointer * 0x18);
      LOCK();
      if (*systemFunctionPointer == '\x01') {
        *systemFunctionPointer = '\x04';
      }
      UNLOCK();
      (**(code **)(*ResourceManagerPointer + 0x38))(ResourceManagerPointer);
    }
  }
  if (plocalResourceOffset != (long long *)0x0) {
    (**(code **)(*plocalResourceOffset + 0x38))(plocalResourceOffset);
  }
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))(resourcePoolPointer);
  }
  if ((long long *)*AdditionalParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*AdditionalParameter + 0x38))();
  }
  if ((long long *)*ConfigurationFlag != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationFlag + 0x38))();
  }
  return;
}




// 函数: void FUN_18007c790(long long *ResourceManagerPointer)
void FUN_18007c790(long long *ResourceManagerPointer)

{
  char *systemFunctionPointer;
  void* *HashEntryStatus;
  
  HashEntryStatus = &SystemStringTemplate;
  if (*(void* **)(*ResourceManagerPointer + 0x18) != (void* *)0x0) {
    HashEntryStatus = *(void* **)(*ResourceManagerPointer + 0x18);
  }
  AllocateSystemMemory(&SystemHashBuffer,HashEntryStatus);
  systemFunctionPointer = (char *)(*(long long *)(*ResourceManagerPointer + 0x1e0) + 0x15 +
                   (ulong long)*(byte *)(ResourceManagerPointer + 1) * 0x18);
  LOCK();
  if (*systemFunctionPointer == '\x01') {
    *systemFunctionPointer = '\x04';
  }
  UNLOCK();
                    00018007c7e6. Too many branches
                      (**(code **)(*(long long *)*ResourceManagerPointer + 0x38))();
  return;
}



void* * FUN_18007c7f0(void* *ResourceManagerPointer,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  
  *ResourceManagerPointer = *ConfigurationDataPointer;
  *(uint8_t *)(ResourceManagerPointer + 1) = *(uint8_t *)(ConfigurationDataPointer + 1);
  PrimaryResourcePointer = (long long *)ConfigurationDataPointer[2];
  ResourceManagerPointer[2] = PrimaryResourcePointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  PrimaryResourcePointer = (long long *)ConfigurationDataPointer[3];
  ResourceManagerPointer[3] = PrimaryResourcePointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  return ResourceManagerPointer;
}




// 函数: void FUN_18007c860(long long ResourceManagerPointer,uint8_t ConfigurationDataPointer)
void FUN_18007c860(long long ResourceManagerPointer,uint8_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  long long localSystemHandle;
  
  localSystemHandle = ResourceManagerPointer;
  if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
    localSystemHandle = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
  }
  if (0 < *(int *)(localSystemHandle + 0x200)) {
    localSystemHandle = *(long long *)(ResourceManagerPointer + 0x1b8);
    charStatus = *(char *)(localSystemHandle + 0x38c);
    if (charStatus == '\t') {
      charStatus = func_0x00018022d300();
      *(char *)(localSystemHandle + 0x38c) = charStatus;
    }
    charStatus = FUN_18007b240(ResourceManagerPointer,ResourceManagerPointer + 0x1e8,charStatus,ConfigurationDataPointer);
    if (initializationStatusFlag == '\0') {
      *(byte *)(ResourceManagerPointer + 0xfe) = *(byte *)(ResourceManagerPointer + 0xfe) & 0xfb;
    }
  }
  return;
}



00018007cad0)


/**
 * @brief 系统线程状态管理器
 * 
 * 该函数负责管理系统线程的状态，包括线程ID验证、线程安全锁定、
 * 状态标志设置和线程相关回调函数的调用。它确保多线程环境下的
 * 数据一致性和线程安全。
 * 
 * @param systemContext 系统上下文指针
 * @param threadStatus 线程状态标志
 * @param threadCallback1 线程回调函数指针1
 * @param threadCallback2 线程回调函数指针2
 */
void SystemThreadStatusManager(long long systemContext,byte threadStatus,long long *threadCallback1,long long *threadCallback2)

{
  long long ThreadDataOffset;
  char *ThreadStatusPointer;
  int ThreadCompareResult;
  int CurrentThreadId;
  void* ThreadObjectPointer;
  long long *ThreadContextPointer;
  long long *SecondaryThreadStack;
  long long *PrimaryThreadStack;
  long long *ThreadDataStack;
  long long **ThreadStackPointer;
  long long ThreadTimeoutValue;
  byte ThreadLockStatus;
  long long *ThreadQueuePointer;
  long long *ThreadSyncPointer;
  long long ThreadSyncValue;
  byte ThreadPriority;
  long long *ThreadMessagePointer;
  long long *ThreadEventPointer;
  long long *ThreadHandleArray [2];
  code *ThreadCallbackFunction1;
  code *ThreadCallbackFunction2;
  void* StackGuardParameter;
  long long *ThreadStackPointer;
  
  uStack_38 = 0xfffffffffffffffe;
  systemCounter = *(int *)(*(long long *)(*(long long *)(SystemAllocationFlagsTemplate + 8) + 8) + 0x48);
  systemIndex = _Thrd_id();
  if (systemIndex == systemCounter) {
    nextDataIndex = (ulong long)ConfigurationDataPointer * 0x18;
    currentThreadId = *(void* *)(*(long long *)(ResourceManagerPointer + 0x1e0) + nextDataIndex);
    pplStack_a0 = &plStack_a8;
    plStack_a8 = (long long *)*AdditionalParameter;
    if (plStack_a8 != (long long *)0x0) {
      (**(code **)(*plStack_a8 + 0x28))();
    }
    FUN_180255880(currentThreadId,&plStack_a8);
    currentThreadId = *(void* *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 8 + nextDataIndex);
    pplStack_a0 = &plStack_b8;
    plStack_b8 = (long long *)*ConfigurationFlag;
    if (plStack_b8 != (long long *)0x0) {
      (**(code **)(*plStack_b8 + 0x28))();
    }
    FUN_180255b70(currentThreadId,&plStack_b8);
    pcharResult = (char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + nextDataIndex);
    LOCK();
    if (*pcharResult == '\x01') {
      *pcharResult = '\x03';
    }
    UNLOCK();
  }
  else {
    currentThreadId = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x40,8,0x20);
    pplStack_a0 = aplStack_58;
    plStack_b0 = &lStack_98;
    plStack_88 = (long long *)*AdditionalParameter;
    lStack_98 = ResourceManagerPointer;
    bStack_90 = ConfigurationDataPointer;
    if (plStack_88 != (long long *)0x0) {
      (**(code **)(*plStack_88 + 0x28))();
    }
    plStack_80 = (long long *)*ConfigurationFlag;
    if (plStack_80 != (long long *)0x0) {
      (**(code **)(*plStack_80 + 0x28))();
    }
    plStack_b0 = &lStack_98;
    lStack_78 = lStack_98;
    bStack_70 = bStack_90;
    plStack_68 = plStack_88;
    plStack_88 = (long long *)0x0;
    plStack_60 = plStack_80;
    plStack_80 = (long long *)0x0;
    plStack_b8 = &lStack_78;
    pcStack_48 = FUN_180082e70;
    pcStack_40 = FUN_180082da0;
    plStack_a8 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag);
    *plStack_a8 = lStack_78;
    *(byte *)(plStack_a8 + 1) = bStack_70;
    plStack_a8[2] = (long long)plStack_68;
    plStack_a8[3] = (long long)plStack_60;
    plStack_60 = (long long *)0x0;
    plStack_68 = (long long *)0x0;
    aplStack_58[0] = plStack_a8;
    if (plStack_80 != (long long *)0x0) {
      (**(code **)(*plStack_80 + 0x38))();
    }
    if (plStack_88 != (long long *)0x0) {
      (**(code **)(*plStack_88 + 0x38))();
    }
    plocalSystemFlags = (long long *)CreateMemoryAllocationHandle(currentThreadId,aplStack_58);
    plStack_30 = plocalSystemFlags;
    if (plocalSystemFlags != (long long *)0x0) {
      (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
    }
    pplStack_a0 = &plStack_b0;
    plStack_b0 = plocalSystemFlags;
    if (plocalSystemFlags != (long long *)0x0) {
      (**(code **)(*plocalSystemFlags + 0x28))(plocalSystemFlags);
    }
    SetupMemoryAllocationContext(SystemAllocationFlagsTemplate,&plStack_b0);
    pcharResult = (char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + (ulong long)ConfigurationDataPointer * 0x18);
    LOCK();
    if (*pcharResult == '\x01') {
      *pcharResult = '\x02';
    }
    UNLOCK();
    if (plocalSystemFlags != (long long *)0x0) {
      (**(code **)(*plocalSystemFlags + 0x38))(plocalSystemFlags);
    }
  }
  if ((long long *)*AdditionalParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*AdditionalParameter + 0x38))();
  }
  if ((long long *)*ConfigurationFlag != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationFlag + 0x38))();
  }
  return;
}





// 函数: void FUN_18007cbb0(uint ResourceManagerPointer,long long ConfigurationDataPointer,long long *AdditionalParameter,void* ConfigurationFlag)
void FUN_18007cbb0(uint ResourceManagerPointer,long long ConfigurationDataPointer,long long *AdditionalParameter,void* ConfigurationFlag)

{
  float FloatVariable1;
  int systemResult;
  long long *plocalResourceOffset;
  long long bufferBaseAddress;
  bool isMemoryReady;
  ushort hashValue;
  void*2 unsignedSystemValue7;
  int systemCode;
  uint unsignedSystemValue9;
  long long *PrimaryResourcePointer0;
  int *pointerToInteger11;
  int *pointerToInteger12;
  float *pinterpolationFactor1;
  uint systemStatus4;
  float *pinterpolationFactor3;
  uint32_t *pointerToUnsigned16;
  uint32_t *pointerToUnsigned17;
  byte *pisByteValid8;
  uint8_t *pointerToUnsigned19;
  float *pfloatValue20;
  long long localSystemHandle1;
  long long localSystemHandle2;
  uint creationFlags3;
  long long localSystemHandle4;
  long long localSystemHandle5;
  ulong long creationFlags6;
  long long localSystemHandle7;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  float floatValue31;
  float floatValue32;
  float floatValue33;
  float floatValue34;
  long long *plStackX_20;
  uint32_t allocationContext5;
  float fStack_128;
  float fStack_124;
  float fStack_120;
  float fStack_11c;
  float fStack_118;
  float fStack_114;
  float fStack_110;
  uint32_t unsignedValue10c;
  float fStack_108;
  float fStack_104;
  float fStack_100;
  float fStack_fc;
  float fStack_f8;
  float fStack_f4;
  float fStack_f0;
  float fStack_ec;
  float fStack_e8;
  float fStack_e4;
  float fStack_e0;
  float fStack_dc;
  
  localSystemHandle1 = 0;
  if (ResourceManagerPointer < 0xe) {
    systemCode = func_0x000180204ae0(ResourceManagerPointer,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0,0xfffffffffffffffe);
  }
  else {
    systemCode = -1;
  }
  systemResult = *(int *)(ConfigurationDataPointer + 0x60);
  localSystemHandle7 = (long long)systemResult;
  PrimaryResourcePointer0 = (long long *)FUN_180081480(LocalBufferAddress,&plStackX_20,systemResult * systemCode);
  PrimaryResourcePointer0 = (long long *)*PrimaryResourcePointer0;
  if (PrimaryResourcePointer0 != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
  }
  plocalResourceOffset = (long long *)*AdditionalParameter;
  *AdditionalParameter = (long long)PrimaryResourcePointer0;
  if (plocalResourceOffset != (long long *)0x0) {
    (**(code **)(*plocalResourceOffset + 0x38))();
  }
  allocationContext5 = 0;
  if (plStackX_20 != (long long *)0x0) {
    (**(code **)(*plStackX_20 + 0x38))();
  }
  pfloatValue20 = *(float **)(*AdditionalParameter + 0x10);
  switch(ResourceManagerPointer) {
  case 0:
    if (0 < systemResult) {
      do {
        *pfloatValue20 = *(float *)(localSystemHandle1 + 0x54 + *(long long *)(ConfigurationDataPointer + 0x68));
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 1:
    if (0 < systemResult) {
      do {
        *pfloatValue20 = *(float *)(localSystemHandle1 + 0x58 + *(long long *)(ConfigurationDataPointer + 0x68));
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 2:
    if (3 < localSystemHandle7) {
      localSystemHandle5 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x48);
      pinterpolationFactor1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x100);
      localSystemHandle2 = (localSystemHandle7 - 4U >> 2) + 1;
      localSystemHandle1 = localSystemHandle2 * 4;
      do {
        *pfloatValue20 = pinterpolationFactor3[-1];
        pfloatValue20[1] = 1.0 - *pinterpolationFactor3;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor3[0x16];
        pfloatValue20[1] = 1.0 - pinterpolationFactor3[0x17];
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor1[-1];
        pfloatValue20[1] = 1.0 - *pinterpolationFactor1;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor1[0x16];
        pfloatValue20[1] = 1.0 - pinterpolationFactor1[0x17];
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        pscaleResult1 = pinterpolationFactor3 + 0x5c;
        pinterpolationFactor1 = pinterpolationFactor1 + 0x5c;
        localSystemHandle2 = localSystemHandle2 + -1;
      } while (localSystemHandle2 != 0);
    }
    if (localSystemHandle1 < localSystemHandle7) {
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x48 + localSystemHandle1 * 0x5c);
      localSystemHandle7 = localSystemHandle7 - localSystemHandle1;
      do {
        *pfloatValue20 = pinterpolationFactor3[-1];
        pfloatValue20[1] = 1.0 - *pinterpolationFactor3;
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        pscaleResult1 = pinterpolationFactor3 + 0x17;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 3:
    if (3 < localSystemHandle7) {
      localSystemHandle5 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x50);
      pinterpolationFactor1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x108);
      localSystemHandle2 = (localSystemHandle7 - 4U >> 2) + 1;
      localSystemHandle1 = localSystemHandle2 * 4;
      do {
        *pfloatValue20 = pinterpolationFactor3[-1];
        pfloatValue20[1] = 1.0 - *pinterpolationFactor3;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor3[0x16];
        pfloatValue20[1] = 1.0 - pinterpolationFactor3[0x17];
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor1[-1];
        pfloatValue20[1] = 1.0 - *pinterpolationFactor1;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor1[0x16];
        pfloatValue20[1] = 1.0 - pinterpolationFactor1[0x17];
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        pscaleResult1 = pinterpolationFactor3 + 0x5c;
        pinterpolationFactor1 = pinterpolationFactor1 + 0x5c;
        localSystemHandle2 = localSystemHandle2 + -1;
      } while (localSystemHandle2 != 0);
    }
    if (localSystemHandle1 < localSystemHandle7) {
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x50 + localSystemHandle1 * 0x5c);
      localSystemHandle7 = localSystemHandle7 - localSystemHandle1;
      do {
        *pfloatValue20 = pinterpolationFactor3[-1];
        pfloatValue20[1] = 1.0 - *pinterpolationFactor3;
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        pscaleResult1 = pinterpolationFactor3 + 0x17;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 4:
  case 5:
    if ((ResourceManagerPointer == 5) && (0 < *(int *)(ConfigurationDataPointer + 0x38))) {
      isMemoryReady = true;
    }
    else {
      isMemoryReady = false;
    }
    pointerToInteger12 = (int *)(ConfigurationDataPointer + 0x38);
    if (!isMemoryReady) {
      pointerToInteger12 = (int *)(ConfigurationDataPointer + 0x10);
    }
    if (3 < localSystemHandle7) {
      localSystemHandle5 = *(long long *)(pointerToInteger12 + 2);
      localSystemHandle4 = (long long)systemCode;
      pointerToInteger11 = (int *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0xb8);
      localSystemHandle2 = (localSystemHandle7 - 4U >> 2) + 1;
      localSystemHandle1 = localSystemHandle2 * 4;
      do {
        *pfloatValue20 = *(float *)(localSystemHandle5 + (long long)pointerToInteger11[-0x2e] * 0x10);
        pfloatValue20[1] = *(float *)(localSystemHandle5 + 4 + (long long)pointerToInteger11[-0x2e] * 0x10);
        pfloatValue20[2] = *(float *)(localSystemHandle5 + 8 + (long long)pointerToInteger11[-0x2e] * 0x10);
        pointerToUnsigned16 = (uint32_t *)((long long)pfloatValue20 + localSystemHandle4);
        *pointerToUnsigned16 = *(uint32_t *)(localSystemHandle5 + (long long)pointerToInteger11[-0x17] * 0x10);
        pointerToUnsigned16[1] = *(uint32_t *)(localSystemHandle5 + 4 + (long long)pointerToInteger11[-0x17] * 0x10);
        pointerToUnsigned16[2] = *(uint32_t *)(localSystemHandle5 + 8 + (long long)pointerToInteger11[-0x17] * 0x10);
        pointerToUnsigned16 = (uint32_t *)((long long)pointerToUnsigned16 + localSystemHandle4);
        *pointerToUnsigned16 = *(uint32_t *)(localSystemHandle5 + (long long)*pointerToInteger11 * 0x10);
        pointerToUnsigned16[1] = *(uint32_t *)(localSystemHandle5 + 4 + (long long)*pointerToInteger11 * 0x10);
        pointerToUnsigned16[2] = *(uint32_t *)(localSystemHandle5 + 8 + (long long)*pointerToInteger11 * 0x10);
        pointerToUnsigned16 = (uint32_t *)((long long)pointerToUnsigned16 + localSystemHandle4);
        *pointerToUnsigned16 = *(uint32_t *)(localSystemHandle5 + (long long)pointerToInteger11[0x17] * 0x10);
        pointerToUnsigned16[1] = *(uint32_t *)(localSystemHandle5 + 4 + (long long)pointerToInteger11[0x17] * 0x10);
        pointerToUnsigned16[2] = *(uint32_t *)(localSystemHandle5 + 8 + (long long)pointerToInteger11[0x17] * 0x10);
        pfloatValue20 = (float *)((long long)pointerToUnsigned16 + localSystemHandle4);
        pointerToInteger11 = pointerToInteger11 + 0x5c;
        localSystemHandle2 = localSystemHandle2 + -1;
      } while (localSystemHandle2 != 0);
    }
    if (localSystemHandle1 < localSystemHandle7) {
      localSystemHandle5 = *(long long *)(pointerToInteger12 + 2);
      pfloatValue20 = pfloatValue20 + 2;
      pointerToInteger12 = (int *)(localSystemHandle1 * 0x5c + *(long long *)(ConfigurationDataPointer + 0x68));
      localSystemHandle7 = localSystemHandle7 - localSystemHandle1;
      do {
        pfloatValue20[-2] = *(float *)(localSystemHandle5 + (long long)*pointerToInteger12 * 0x10);
        pfloatValue20[-1] = *(float *)(localSystemHandle5 + 4 + (long long)*pointerToInteger12 * 0x10);
        *pfloatValue20 = *(float *)(localSystemHandle5 + 8 + (long long)*pointerToInteger12 * 0x10);
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        pointerToInteger12 = pointerToInteger12 + 0x17;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 6:
    if (3 < localSystemHandle7) {
      localSystemHandle5 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x38);
      pointerToUnsigned16 = (uint32_t *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0xf0);
      localSystemHandle2 = (localSystemHandle7 - 4U >> 2) + 1;
      localSystemHandle1 = localSystemHandle2 * 4;
      do {
        *pfloatValue20 = pinterpolationFactor3[-1];
        pfloatValue20[1] = *pinterpolationFactor3;
        pfloatValue20[2] = pinterpolationFactor3[1];
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle5);
        *pfloatValue20 = pinterpolationFactor3[0x16];
        pfloatValue20[1] = pinterpolationFactor3[0x17];
        pfloatValue20[2] = pinterpolationFactor3[0x18];
        pointerToUnsigned17 = (uint32_t *)((long long)pfloatValue20 + localSystemHandle5);
        *pointerToUnsigned17 = pointerToUnsigned16[-1];
        pointerToUnsigned17[1] = *pointerToUnsigned16;
        pointerToUnsigned17[2] = pointerToUnsigned16[1];
        pointerToUnsigned17 = (uint32_t *)((long long)pointerToUnsigned17 + localSystemHandle5);
        *pointerToUnsigned17 = pointerToUnsigned16[0x16];
        pointerToUnsigned17[1] = pointerToUnsigned16[0x17];
        pointerToUnsigned17[2] = pointerToUnsigned16[0x18];
        pfloatValue20 = (float *)((long long)pointerToUnsigned17 + localSystemHandle5);
        pscaleResult1 = pinterpolationFactor3 + 0x5c;
        pointerToUnsigned16 = pointerToUnsigned16 + 0x5c;
        localSystemHandle2 = localSystemHandle2 + -1;
      } while (localSystemHandle2 != 0);
    }
    if (localSystemHandle1 < localSystemHandle7) {
      pfloatValue20 = pfloatValue20 + 2;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x38 + localSystemHandle1 * 0x5c);
      localSystemHandle7 = localSystemHandle7 - localSystemHandle1;
      do {
        pfloatValue20[-2] = pinterpolationFactor3[-1];
        pfloatValue20[-1] = *pinterpolationFactor3;
        *pfloatValue20 = pinterpolationFactor3[1];
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        pscaleResult1 = pinterpolationFactor3 + 0x17;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 7:
    if (3 < localSystemHandle7) {
      localSystemHandle2 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x14);
      pinterpolationFactor1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0xc0);
      localSystemHandle5 = (localSystemHandle7 - 4U >> 2) + 1;
      localSystemHandle1 = localSystemHandle5 * 4;
      do {
        *pfloatValue20 = *pinterpolationFactor3;
        pfloatValue20[1] = pinterpolationFactor3[1];
        pfloatValue20[2] = pinterpolationFactor3[2];
        if ((pinterpolationFactor1[-0x2e] * pinterpolationFactor1[-0x29] - pinterpolationFactor1[-0x2d] * pinterpolationFactor1[-0x2a]) * pinterpolationFactor3[4] +
            (pinterpolationFactor1[-0x2d] * *pinterpolationFactor3 - pinterpolationFactor3[-4] * pinterpolationFactor1[-0x29]) * pinterpolationFactor1[-0x26] +
            (pinterpolationFactor3[-4] * pinterpolationFactor1[-0x2a] - *pinterpolationFactor3 * pinterpolationFactor1[-0x2e]) * pinterpolationFactor1[-0x25] <= 0.0) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pfloatValue20[3] = floatValue28;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle2);
        *pfloatValue20 = pinterpolationFactor3[0x17];
        pfloatValue20[1] = pinterpolationFactor3[0x18];
        pfloatValue20[2] = pinterpolationFactor3[0x19];
        if ((pinterpolationFactor1[-0x17] * pinterpolationFactor1[-0x12] - pinterpolationFactor1[-0x16] * pinterpolationFactor1[-0x13]) * pinterpolationFactor3[0x1b] +
            (pinterpolationFactor3[0x17] * pinterpolationFactor1[-0x16] - pinterpolationFactor3[0x13] * pinterpolationFactor1[-0x12]) * pinterpolationFactor1[-0xf] +
            (pinterpolationFactor3[0x13] * pinterpolationFactor1[-0x13] - pinterpolationFactor3[0x17] * pinterpolationFactor1[-0x17]) * pinterpolationFactor1[-0xe] <= 0.0
           ) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pfloatValue20[3] = floatValue28;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle2);
        *pfloatValue20 = pinterpolationFactor1[3];
        pfloatValue20[1] = pinterpolationFactor1[4];
        pfloatValue20[2] = pinterpolationFactor1[5];
        if ((pinterpolationFactor1[1] * pinterpolationFactor1[3] - pinterpolationFactor1[5] * pinterpolationFactor1[-1]) * pinterpolationFactor1[8] +
            (pinterpolationFactor1[5] * *pinterpolationFactor1 - pinterpolationFactor1[1] * pinterpolationFactor1[4]) * pinterpolationFactor1[7] +
            (pinterpolationFactor1[4] * pinterpolationFactor1[-1] - *pinterpolationFactor1 * pinterpolationFactor1[3]) * pinterpolationFactor1[9] <= 0.0) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pfloatValue20[3] = floatValue28;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle2);
        *pfloatValue20 = pinterpolationFactor1[0x1a];
        pfloatValue20[1] = pinterpolationFactor1[0x1b];
        pfloatValue20[2] = pinterpolationFactor1[0x1c];
        if ((pinterpolationFactor1[0x1c] * pinterpolationFactor1[0x17] - pinterpolationFactor1[0x18] * pinterpolationFactor1[0x1b]) * pinterpolationFactor1[0x1e] +
            (pinterpolationFactor1[0x1a] * pinterpolationFactor1[0x18] - pinterpolationFactor1[0x1c] * pinterpolationFactor1[0x16]) * pinterpolationFactor1[0x1f] +
            (pinterpolationFactor1[0x16] * pinterpolationFactor1[0x1b] - pinterpolationFactor1[0x1a] * pinterpolationFactor1[0x17]) * pinterpolationFactor1[0x20] <= 0.0)
        {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pfloatValue20[3] = floatValue28;
        pfloatValue20 = (float *)((long long)pfloatValue20 + localSystemHandle2);
        pscaleResult1 = pinterpolationFactor3 + 0x5c;
        pinterpolationFactor1 = pinterpolationFactor1 + 0x5c;
        localSystemHandle5 = localSystemHandle5 + -1;
      } while (localSystemHandle5 != 0);
    }
    if (localSystemHandle1 < localSystemHandle7) {
      pfloatValue20 = pfloatValue20 + 2;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 8 + localSystemHandle1 * 0x5c);
      localSystemHandle7 = localSystemHandle7 - localSystemHandle1;
      do {
        pfloatValue20[-2] = pinterpolationFactor3[3];
        pfloatValue20[-1] = pinterpolationFactor3[4];
        *pfloatValue20 = pinterpolationFactor3[5];
        if ((pinterpolationFactor3[5] * *pinterpolationFactor3 - pinterpolationFactor3[1] * pinterpolationFactor3[4]) * pinterpolationFactor3[7] +
            (pinterpolationFactor3[3] * pinterpolationFactor3[1] - pinterpolationFactor3[-1] * pinterpolationFactor3[5]) * pinterpolationFactor3[8] +
            (pinterpolationFactor3[-1] * pinterpolationFactor3[4] - pinterpolationFactor3[3] * *pinterpolationFactor3) * pinterpolationFactor3[9] <= 0.0) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pfloatValue20[1] = floatValue28;
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        pscaleResult1 = pinterpolationFactor3 + 0x17;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 8:
    if (*(int *)(ConfigurationDataPointer + 200) < 1) {
code_r0x00018007db1b:
        memset(pfloatValue20,0,(long long)(systemResult * 4));
    }
    localSystemHandle5 = localSystemHandle1;
    if (3 < localSystemHandle7) {
      localSystemHandle4 = (long long)systemCode;
      localSystemHandle2 = (localSystemHandle7 - 4U >> 2) + 1;
      localSystemHandle5 = localSystemHandle2 * 4;
      do {
        bufferBaseAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *(char *)pfloatValue20 =
             (char)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                   (long long)*(int *)(localSystemHandle1 + bufferBaseAddress) * 0x14) * 255.0);
        *(char*)((long long)pfloatValue20 + 1) =
             (char)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                   (long long)*(int *)(localSystemHandle1 + bufferBaseAddress) * 0x14) * 255.0);
        unsignedSystemValue9 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(localSystemHandle1 + bufferBaseAddress) * 0x14) * 255.0);
        *(char*)((long long)pfloatValue20 + 2) = (char)unsignedSystemValue9;
        floatValue28 = (float)((unsignedSystemValue9 & 0xff) + (uint)*(byte *)((long long)pfloatValue20 + 1) +
                        (uint)*(byte *)pfloatValue20);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        *(char*)((long long)pfloatValue20 + 3) = (char)(int)(1.0 - floatValue28);
        pisByteValid8 = (byte *)((long long)pfloatValue20 + localSystemHandle4);
        bufferBaseAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *pisByteValid8 = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                         (long long)*(int *)(localSystemHandle1 + 0x5c + bufferBaseAddress) * 0x14) * 255.0);
        pisByteValid8[1] = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                           (long long)*(int *)(localSystemHandle1 + 0x5c + bufferBaseAddress) * 0x14) * 255.0
                                );
        unsignedSystemValue9 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(localSystemHandle1 + 0x5c + bufferBaseAddress) * 0x14) * 255.0);
        pisByteValid8[2] = (byte)unsignedSystemValue9;
        floatValue28 = (float)((unsignedSystemValue9 & 0xff) + (uint)pisByteValid8[1] + (uint)*pisByteValid8);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pisByteValid8[3] = (byte)(int)(1.0 - floatValue28);
        pisByteValid8 = pisByteValid8 + localSystemHandle4;
        bufferBaseAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *pisByteValid8 = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                         (long long)*(int *)(localSystemHandle1 + 0xb8 + bufferBaseAddress) * 0x14) * 255.0);
        pisByteValid8[1] = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                           (long long)*(int *)(localSystemHandle1 + 0xb8 + bufferBaseAddress) * 0x14) * 255.0
                                );
        unsignedSystemValue9 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(localSystemHandle1 + 0xb8 + bufferBaseAddress) * 0x14) * 255.0);
        pisByteValid8[2] = (byte)unsignedSystemValue9;
        floatValue28 = (float)((unsignedSystemValue9 & 0xff) + (uint)pisByteValid8[1] + (uint)*pisByteValid8);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pisByteValid8[3] = (byte)(int)(1.0 - floatValue28);
        pisByteValid8 = pisByteValid8 + localSystemHandle4;
        bufferBaseAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *pisByteValid8 = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                         (long long)*(int *)(localSystemHandle1 + 0x114 + bufferBaseAddress) * 0x14) * 255.0)
        ;
        pisByteValid8[1] = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                           (long long)*(int *)(localSystemHandle1 + 0x114 + bufferBaseAddress) * 0x14) *
                                255.0);
        unsignedSystemValue9 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(localSystemHandle1 + 0x114 + bufferBaseAddress) * 0x14) * 255.0);
        pisByteValid8[2] = (byte)unsignedSystemValue9;
        floatValue28 = (float)((unsignedSystemValue9 & 0xff) + (uint)pisByteValid8[1] + (uint)*pisByteValid8);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pisByteValid8[3] = (byte)(int)(1.0 - floatValue28);
        pfloatValue20 = (float *)(pisByteValid8 + localSystemHandle4);
        localSystemHandle1 = localSystemHandle1 + 0x170;
        localSystemHandle2 = localSystemHandle2 + -1;
      } while (localSystemHandle2 != 0);
    }
    if (localSystemHandle5 < localSystemHandle7) {
      localSystemHandle1 = localSystemHandle5 * 0x5c;
      pointerToUnsigned19 = (uint8_t *)((long long)pfloatValue20 + 2);
      localSystemHandle7 = localSystemHandle7 - localSystemHandle5;
      do {
        localSystemHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        creationFlags3 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                  (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14) * 255.0);
        pointerToUnsigned19[-2] = (char)creationFlags3;
        systemStatus4 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                  (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14) * 255.0);
        pointerToUnsigned19[-1] = (char)systemStatus4;
        unsignedSystemValue9 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14) * 255.0);
        *pointerToUnsigned19 = (char)unsignedSystemValue9;
        floatValue28 = (float)((unsignedSystemValue9 & 0xff) + (systemStatus4 & 0xff) + (creationFlags3 & 0xff));
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pointerToUnsigned19[1] = (char)(int)(1.0 - floatValue28);
        pointerToUnsigned19 = pointerToUnsigned19 + systemCode;
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 9:
    if (*(int *)(ConfigurationDataPointer + 200) < 1) goto code_r0x00018007db1b;
    if (0 < systemResult) {
      do {
        localSystemHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        *(uint8_t *)pfloatValue20 =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x10 + (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14);
        *(uint8_t *)((long long)pfloatValue20 + 1) =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x11 + (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14);
        *(uint8_t *)((long long)pfloatValue20 + 2) =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x12 + (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14);
        *(uint8_t *)((long long)pfloatValue20 + 3) =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x13 + (long long)*(int *)(localSystemHandle1 + localSystemHandle5) * 0x14);
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 10:
    if (0 < systemResult) {
      do {
        localSystemHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        floatValue29 = *(float *)(localSystemHandle1 + 0x34 + localSystemHandle5) * 0.5;
        floatValue34 = *(float *)(localSystemHandle1 + 0x38 + localSystemHandle5) * 0.5;
        floatValue28 = *(float *)(localSystemHandle1 + 0x3c + localSystemHandle5) * 0.5;
        floatValue31 = floatValue29 + 0.5;
        floatValue32 = floatValue34 + 0.5;
        floatValue33 = floatValue28 + 0.5;
        if (-0.5 <= floatValue28) {
          if (1.0 <= floatValue33) {
            floatValue33 = 1.0;
          }
        }
        else {
          floatValue33 = 0.0;
        }
        if (-0.5 <= floatValue34) {
          if (1.0 <= floatValue32) {
            floatValue32 = 1.0;
          }
        }
        else {
          floatValue32 = 0.0;
        }
        if (-0.5 <= floatValue29) {
          if (1.0 <= floatValue31) {
            floatValue31 = 1.0;
          }
        }
        else {
          floatValue31 = 0.0;
        }
        *pfloatValue20 = (float)(((uint)(long long)(floatValue32 * 2047.0) & 0x7ff |
                           (int)(long long)(floatValue31 * 2047.0) << 0xb) << 10 |
                          (uint)(long long)(floatValue33 * 1023.0) & 0x3ff);
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 0xb:
    if (0 < systemResult) {
      localSystemHandle5 = 0x40;
      if (*(int *)(ConfigurationDataPointer + 0x38) < 1) {
        localSystemHandle5 = 0x18;
      }
      hashValue = func_0x0001800840d0(0x3f800000);
      creationFlags6 = (ulong long)hashValue;
      do {
        localSystemHandle2 = *(long long *)(ConfigurationDataPointer + 0x68);
        unsignedSystemValue7 = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(localSystemHandle5 + ConfigurationDataPointer) +
                                     (long long)*(int *)(localSystemHandle1 + localSystemHandle2) * 0x10));
        *(void*2 *)pfloatValue20 = unsignedSystemValue7;
        unsignedSystemValue7 = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(localSystemHandle5 + ConfigurationDataPointer) + 4 +
                                     (long long)*(int *)(localSystemHandle1 + localSystemHandle2) * 0x10));
        *(void*2 *)((long long)pfloatValue20 + 2) = unsignedSystemValue7;
        unsignedSystemValue7 = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(localSystemHandle5 + ConfigurationDataPointer) + 8 +
                                     (long long)*(int *)(localSystemHandle1 + localSystemHandle2) * 0x10));
        *(void*2 *)(pfloatValue20 + 1) = unsignedSystemValue7;
        *(short *)((long long)pfloatValue20 + 6) = (short)creationFlags6;
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 0xc:
    if (0 < systemResult) {
      do {
        localSystemHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        floatValue28 = *(float *)(localSystemHandle1 + 0x1c + localSystemHandle5);
        floatValue31 = *(float *)(localSystemHandle1 + 0x18 + localSystemHandle5);
        floatValue32 = *(float *)(localSystemHandle1 + 0x14 + localSystemHandle5);
        floatValue33 = *(float *)(localSystemHandle1 + 4 + localSystemHandle5);
        floatValue34 = floatValue32 * 0.5 + 0.5;
        floatValue29 = floatValue31 * 0.5 + 0.5;
        floatValue30 = floatValue28 * 0.5 + 0.5;
        if (-0.5 <= floatValue28 * 0.5) {
          if (1.0 <= floatValue30) {
            floatValue30 = 1.0;
          }
        }
        else {
          floatValue30 = 0.0;
        }
        if (-0.5 <= floatValue31 * 0.5) {
          if (1.0 <= floatValue29) {
            floatValue29 = 1.0;
          }
        }
        else {
          floatValue29 = 0.0;
        }
        if (-0.5 <= floatValue32 * 0.5) {
          if (1.0 <= floatValue34) {
            floatValue34 = 1.0;
          }
        }
        else {
          floatValue34 = 0.0;
        }
        unsignedSystemValue9 = 0;
        if ((floatValue32 * *(float *)(localSystemHandle1 + 0xc + localSystemHandle5) - floatValue33 * floatValue28) *
            *(float *)(localSystemHandle1 + 0x28 + localSystemHandle5) +
            (floatValue28 * *(float *)(localSystemHandle1 + 8 + localSystemHandle5) - floatValue31 * *(float *)(localSystemHandle1 + 0xc + localSystemHandle5))
            * *(float *)(localSystemHandle1 + 0x24 + localSystemHandle5) +
            (floatValue33 * floatValue31 - floatValue32 * *(float *)(localSystemHandle1 + 8 + localSystemHandle5)) *
            *(float *)(localSystemHandle1 + 0x2c + localSystemHandle5) < 0.0) {
          unsignedSystemValue9 = 0x80000000;
        }
        *pfloatValue20 = (float)((((uint)(long long)(floatValue34 * 1023.0) & 0x3ff) << 0xb |
                           (uint)(long long)(floatValue29 * 2047.0) & 0x7ff) << 10 |
                           (uint)(long long)(floatValue30 * 1023.0) & 0x3ff | unsignedSystemValue9);
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
    break;
  case 0xd:
    if (0 < systemResult) {
      localSystemHandle2 = 0x48;
      localSystemHandle5 = *(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
      floatValue28 = fRam0000000180d49154;
      do {
        localSystemHandle4 = *(long long *)(ConfigurationDataPointer + 0x68);
        pscaleResult1 = (float *)(localSystemHandle1 + 0x34 + localSystemHandle4);
        fStack_108 = *pinterpolationFactor3;
        fStack_104 = pinterpolationFactor3[1];
        fStack_100 = pinterpolationFactor3[2];
        fStack_fc = pinterpolationFactor3[3];
        pscaleResult1 = (float *)(localSystemHandle1 + 0x14 + localSystemHandle4);
        fStack_f8 = *pinterpolationFactor3;
        fStack_f4 = pinterpolationFactor3[1];
        fStack_f0 = pinterpolationFactor3[2];
        fStack_ec = pinterpolationFactor3[3];
        pscaleResult1 = (float *)(localSystemHandle1 + 0x24 + localSystemHandle4);
        fStack_e8 = *pinterpolationFactor3;
        fStack_e4 = pinterpolationFactor3[1];
        fStack_e0 = pinterpolationFactor3[2];
        fStack_dc = pinterpolationFactor3[3];
        floatValue31 = fStack_100 * fStack_f8 - fStack_f0 * fStack_108;
        if ((fStack_f0 * fStack_104 - fStack_100 * fStack_f4) * fStack_e8 + fStack_e4 * floatValue31 +
            fStack_e0 * (fStack_f4 * fStack_108 - fStack_f8 * fStack_104) < 0.0) {
          fStack_e0 = -fStack_e0;
          fStack_118 = -fStack_e8;
          fStack_114 = -fStack_e4;
          unsignedValue10c = 0x7f7fffff;
          fStack_e8 = -fStack_e8;
          fStack_e4 = -fStack_e4;
          fStack_dc = 3.4028235e+38;
          fStack_110 = fStack_e0;
        }
        FUN_18063b470(&fStack_128,&fStack_108,fStack_e0,floatValue31,allocationContext5);
        FUN_180084000(&fStack_128);
        if (fStack_128 < 0.0) {
          fStack_128 = -fStack_128;
          fStack_124 = -fStack_124;
          fStack_120 = -fStack_120;
          fStack_11c = -fStack_11c;
        }
        floatValue34 = fStack_11c;
        floatValue33 = fStack_120;
        floatValue32 = fStack_124;
        floatValue31 = fStack_128;
        if (*(int *)(localSystemHandle5 + localSystemHandle2) < iRam0000000180d49150) {
          CheckSystemDataAvailability(0x180d49150);
          if (iRam0000000180d49150 == -1) {
            fRam0000000180d49154 = 1.0;
            InitializeSystemDataPointer(0x180d49150);
          }
          localSystemHandle2 = 0x48;
          floatValue28 = fRam0000000180d49154;
        }
        if (floatValue31 < 3.051851e-05) {
          floatValue31 = 3.051851e-05;
          fStack_128 = 3.051851e-05;
          floatValue32 = floatValue32 * floatValue28;
          floatValue33 = floatValue33 * floatValue28;
          floatValue34 = floatValue34 * floatValue28;
          fStack_124 = floatValue32;
          fStack_120 = floatValue33;
          fStack_11c = floatValue34;
        }
        floatValue29 = *(float *)(localSystemHandle1 + 0x18 + localSystemHandle4);
        floatValue30 = *(float *)(localSystemHandle1 + 0x1c + localSystemHandle4);
        floatValue1 = *(float *)(localSystemHandle1 + 0x14 + localSystemHandle4);
        if ((floatValue30 * *(float *)(localSystemHandle1 + 0x34 + localSystemHandle4) -
            floatValue1 * *(float *)(localSystemHandle1 + 0x3c + localSystemHandle4)) * *(float *)(localSystemHandle1 + 0x28 + localSystemHandle4) +
            (floatValue29 * *(float *)(localSystemHandle1 + 0x3c + localSystemHandle4) -
            floatValue30 * *(float *)(localSystemHandle1 + 0x38 + localSystemHandle4)) * *(float *)(localSystemHandle1 + 0x24 + localSystemHandle4) +
            (floatValue1 * *(float *)(localSystemHandle1 + 0x38 + localSystemHandle4) -
            floatValue29 * *(float *)(localSystemHandle1 + 0x34 + localSystemHandle4)) * *(float *)(localSystemHandle1 + 0x2c + localSystemHandle4) <= 0.0
           ) {
          floatValue31 = -floatValue31;
          floatValue32 = -floatValue32;
          floatValue33 = -floatValue33;
          floatValue34 = -floatValue34;
          fStack_128 = floatValue31;
          fStack_124 = floatValue32;
          fStack_120 = floatValue33;
          fStack_11c = floatValue34;
        }
        *(short *)pfloatValue20 = (short)(int)(floatValue32 * 32767.0);
        *(short *)((long long)pfloatValue20 + 2) = (short)(int)(floatValue33 * 32767.0);
        *(short *)(pfloatValue20 + 1) = (short)(int)(floatValue34 * 32767.0);
        *(short *)((long long)pfloatValue20 + 6) = (short)(int)(floatValue31 * 32767.0);
        pfloatValue20 = (float *)((long long)pfloatValue20 + (long long)systemCode);
        localSystemHandle1 = localSystemHandle1 + 0x5c;
        localSystemHandle7 = localSystemHandle7 + -1;
      } while (localSystemHandle7 != 0);
    }
  }
  return;
}




// 函数: void FUN_18007df50(long long ResourceManagerPointer,long long *ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 配置系统资源数据结构
 * 
 * 该函数负责配置系统资源的数据结构，包括数据复制和初始化。
 * 根据不同的参数模式，执行不同的数据配置操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（决定配置模式）
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18007df50，现已重命名为ConfigureSystemResourceDataStructure
 */
void ConfigureSystemResourceDataStructure(long long ResourceManagerPointer,long long *ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  long long localSystemHandle;
  uint allocationContext;
  void* unsignedSystemValue4;
  uint currentThreadId;
  long long *plStackX_8;
  
  if (*(int *)(ResourceManagerPointer + 0x88) != 0) {
    if (AdditionalParameter == '\0') {
      unsignedSystemValue4 = FUN_180081350(ResourceManagerPointer,&plStackX_8,*(int *)(ResourceManagerPointer + 0x88) * 3,ConfigurationFlag,
                            0xfffffffffffffffe);
      FUN_180080810(ConfigurationDataPointer,unsignedSystemValue4);
    }
    else {
      unsignedSystemValue4 = FUN_180081220();
      FUN_180080810(ConfigurationDataPointer,unsignedSystemValue4);
    }
    if (plStackX_8 != (long long *)0x0) {
      (**(code **)(*plStackX_8 + 0x38))();
    }
    localSystemHandle = *(long long *)(*ConfigurationDataPointer + 0x10);
    if (AdditionalParameter != '\0') {
                    0001808ffc47. Too many branches
                            memcpy(localSystemHandle,*(void* *)(ResourceManagerPointer + 0x90),(long long)*(int *)(ResourceManagerPointer + 0x88) * 0xc);
      return;
    }
    currentThreadId = 0;
    if (*(int *)(ResourceManagerPointer + 0x88) != 0) {
      do {
        nextDataIndex = (long long)(int)currentThreadId * 0xc;
        allocationContext = currentThreadId * 3;
        *(void*2 *)(localSystemHandle + (ulong long)allocationContext * 2) =
             *(void*2 *)(nextDataIndex + *(long long *)(ResourceManagerPointer + 0x90));
        *(void*2 *)(localSystemHandle + (ulong long)(allocationContext + 1) * 2) =
             *(void*2 *)(*(long long *)(ResourceManagerPointer + 0x90) + 4 + nextDataIndex);
        *(void*2 *)(localSystemHandle + (ulong long)(allocationContext + 2) * 2) =
             *(void*2 *)(*(long long *)(ResourceManagerPointer + 0x90) + 8 + nextDataIndex);
        currentThreadId = currentThreadId + 1;
      } while (currentThreadId < *(uint *)(ResourceManagerPointer + 0x88));
    }
  }
  return;
}





// 函数: void FUN_18007e080(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag)
/**
 * @brief 处理系统纹理管理器配置
 * 
 * 该函数负责处理系统纹理管理器的配置，包括纹理数据的初始化和配置。
 * 根据不同的配置类型执行相应的配置操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志指针
 * 
 * 原始函数名为FUN_18007e080，现已重命名为ProcessSystemTextureManagerConfiguration
 */
void ProcessSystemTextureManagerConfiguration(long long ResourceManagerPointer,ulong long ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag)

{
  long long nextDataIndex;
  int *pointerToInteger2;
  int MemoryComparisonResult;
  int systemIndex;
  long long SystemTimeValue;
  int systemFlag;
  long long StackOffset1;
  uint32_t EncryptionValue68;
  long long StackOffset2;
  long long StackOffset3;
  uint32_t unsignedValue50;
  void* EncryptionValue48;
  
  localSystemPointer = (ConfigurationDataPointer & 0xff) * 0x1c0 + SystemTextureManagerPointer;
  systemIndex = *(int *)(localSystemPointer + 0x70);
  nextDataIndex = (long long)systemIndex;
  if (0 < systemIndex) {
    EncryptionValue68 = 0;
    lStack_70 = ResourceManagerPointer;
    FUN_18007f770(&lStack_70);
    if (lStack_60 != 0) {
      systemCounter = 0;
      systemFlag = -1;
      if (0 < systemIndex) {
        pointerToInteger2 = (int *)(localSystemPointer + 0x128);
        localSystemPointer = lStack_60;
        systemIndex = systemFlag;
        do {
          switch(*pointerToInteger2) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 10:
          case 0xb:
          case 0xc:
          case 0xd:
            FUN_18007cbb0((long long)*pointerToInteger2,localSystemPointer,*AdditionalParameter + 0x18 + (long long)systemCounter * 8);
            localSystemPointer = lStack_60;
            break;
          case 8:
            systemFlag = systemCounter;
            break;
          case 9:
            systemIndex = systemCounter;
          }
          systemCounter = systemCounter + 1;
          pointerToInteger2 = pointerToInteger2 + 3;
          nextDataIndex = nextDataIndex + -1;
        } while (nextDataIndex != 0);
        if (systemFlag != -1) {
          lStack_58 = ResourceManagerPointer;
          if ((((*(byte *)(ResourceManagerPointer + 0xfd) & 0x40) == 0) || (*(long long *)(ResourceManagerPointer + 0x210) == 0))
             && (*(long long *)(ResourceManagerPointer + 0x1b0) != 0)) {
            lStack_58 = FUN_180085900();
          }
          unsignedValue50 = 0;
          FUN_18007f770(&lStack_58);
          FUN_18007cbb0(8,EncryptionValue48,*AdditionalParameter + 0x18 + (long long)systemFlag * 8);
          FUN_18007cbb0(9,EncryptionValue48,*AdditionalParameter + 0x18 + (long long)systemIndex * 8);
          FUN_18007f840(&lStack_58);
        }
      }
      if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
        ResourceManagerPointer = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
      }
      FUN_18007df50(lStack_60,*ConfigurationFlag + 0x20,0xffff < *(int *)(ResourceManagerPointer + 0x200));
    }
    FUN_18007f840(&lStack_70);
  }
  if ((long long *)*AdditionalParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*AdditionalParameter + 0x38))();
  }
  if ((long long *)*ConfigurationFlag != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationFlag + 0x38))();
  }
  return;
}




// 函数: void FUN_18007e2b0(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统资源配置
 * 
 * 该函数负责初始化系统资源配置，设置资源状态和配置参数。
 * 主要用于系统资源的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名为FUN_18007e2b0，现已重命名为InitializeSystemResourceConfiguration
 */
void InitializeSystemResourceConfiguration(long long ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int systemStatus;
  int systemResult;
  void* allocationContext;
  
  allocationContext = 0xfffffffffffffffe;
  FUN_180080650(ResourceManagerPointer + 0x10);
  FUN_180080650(ResourceManagerPointer + 0x38,ConfigurationDataPointer);
  *(uint8_t *)(ResourceManagerPointer + 0x80) = *(uint8_t *)(ConfigurationDataPointer + 0x1a);
  *(uint32_t *)(ResourceManagerPointer + 0x60) = **(uint32_t **)(ConfigurationDataPointer + 8);
  *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + 4;
  systemStatus = *(int *)(ResourceManagerPointer + 0x60);
  systemResult = *(int *)(ResourceManagerPointer + 100);
  if (systemResult < systemStatus) {
    if (systemStatus == 0) {
      if (systemResult < 2) {
        *(uint32_t *)(ResourceManagerPointer + 100) = 8;
      }
      else {
        *(int *)(ResourceManagerPointer + 100) = (systemResult >> 1) + systemResult;
      }
    }
    else {
      *(int *)(ResourceManagerPointer + 100) = systemStatus;
    }
    FUN_180086010(ResourceManagerPointer + 0x60);
  }
  *(int *)(ResourceManagerPointer + 0x60) = systemStatus;
    memcpy(*(void* *)(ResourceManagerPointer + 0x68),*(void* *)(ConfigurationDataPointer + 8),(long long)(systemStatus * 0x5c),
         ConfigurationFlag,allocationContext);
}




// 函数: void FUN_18007e5b0(long long ResourceManagerPointer,long long *ConfigurationDataPointer)
/**
 * @brief 处理系统资源数据缓冲区
 * 
 * 该函数负责处理系统资源数据缓冲区，包括数据的读取、写入和验证。
 * 主要用于系统资源数据的管理和操作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_18007e5b0，现已重命名为ProcessSystemResourceDataBuffer
 */
void ProcessSystemResourceDataBuffer(long long ResourceManagerPointer,long long *ConfigurationDataPointer)

{
  uint32_t systemStatus;
  int *pointerToInteger2;
  uint32_t *HashNodePointer;
  long long bufferBaseAddress;
  int systemValue;
  int systemFlag;
  long long localDataIndex;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  void* systemOperationFlags;
  
  systemOperationFlags = 0xfffffffffffffffe;
  FUN_1800806e0(ResourceManagerPointer + 0x10);
  FUN_1800806e0(ResourceManagerPointer + 0x38,ConfigurationDataPointer);
  systemFlag = *(int *)(ResourceManagerPointer + 0x60);
  unsignedSystemValue9 = (long long)systemFlag * 0x5c + 4;
  localDataIndex = ConfigurationDataPointer[2];
  pointerToInteger2 = (int *)ConfigurationDataPointer[1];
  bufferBaseAddress = *ConfigurationDataPointer;
  if ((ulong long)((bufferBaseAddress - (long long)pointerToInteger2) + localDataIndex) <= unsignedSystemValue9) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pointerToInteger2 + (unsignedSystemValue9 - bufferBaseAddress),localDataIndex,unsignedSystemValue9,systemOperationFlags);
    systemFlag = *(int *)(ResourceManagerPointer + 0x60);
    localDataIndex = ConfigurationDataPointer[2];
    pointerToInteger2 = (int *)ConfigurationDataPointer[1];
    bufferBaseAddress = *ConfigurationDataPointer;
  }
  if ((ulong long)((bufferBaseAddress - (long long)pointerToInteger2) + localDataIndex) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)pointerToInteger2 + (4 - bufferBaseAddress));
    pointerToInteger2 = (int *)ConfigurationDataPointer[1];
  }
  *pointerToInteger2 = systemFlag;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  systemValue = 0;
  systemFlag = systemValue;
  if (0 < *(int *)(ResourceManagerPointer + 0x60)) {
    do {
      FUN_180078c70((long long)systemFlag * 0x5c + *(long long *)(ResourceManagerPointer + 0x68),ConfigurationDataPointer);
      systemFlag = systemFlag + 1;
    } while (systemFlag < *(int *)(ResourceManagerPointer + 0x60));
    HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  systemStatus = *(uint32_t *)(ResourceManagerPointer + 0x88);
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashNodePointer) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashNodePointer + (4 - *ConfigurationDataPointer));
    HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashNodePointer = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  FUN_18063a180(ConfigurationDataPointer,*(void* *)(ResourceManagerPointer + 0x90),(long long)*(int *)(ResourceManagerPointer + 0x88) * 0xc);
  unsignedSystemValue8 = (ulong long)*(ushort *)(ResourceManagerPointer + 0xc0);
  unsignedSystemValue9 = unsignedSystemValue8 * 4 + 4;
  localDataIndex = ConfigurationDataPointer[2];
  HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  bufferBaseAddress = *ConfigurationDataPointer;
  if ((ulong long)((bufferBaseAddress - (long long)HashNodePointer) + localDataIndex) <= unsignedSystemValue9) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashNodePointer + (unsignedSystemValue9 - bufferBaseAddress));
    unsignedSystemValue8 = (ulong long)*(ushort *)(ResourceManagerPointer + 0xc0);
    localDataIndex = ConfigurationDataPointer[2];
    HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
    bufferBaseAddress = *ConfigurationDataPointer;
  }
  if ((ulong long)((bufferBaseAddress - (long long)HashNodePointer) + localDataIndex) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashNodePointer + (4 - bufferBaseAddress));
    HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashNodePointer = (int)unsignedSystemValue8;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  FUN_18063a180(ConfigurationDataPointer,*(void* *)(ResourceManagerPointer + 0xb8),(ulong long)*(ushort *)(ResourceManagerPointer + 0xc0) << 2)
  ;
  if (*(short *)(ResourceManagerPointer + 0xc0) != 0) {
    do {
      localDataIndex = (long long)systemValue * 0x50 + *(long long *)(ResourceManagerPointer + 0xb0);
      FUN_1800806e0(localDataIndex,ConfigurationDataPointer);
      FUN_1800806e0(localDataIndex + 0x28,ConfigurationDataPointer);
      systemValue = systemValue + 1;
    } while (systemValue < (int)(uint)*(ushort *)(ResourceManagerPointer + 0xc0));
  }
  systemStatus = *(uint32_t *)(ResourceManagerPointer + 200);
  HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashNodePointer) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashNodePointer + (4 - *ConfigurationDataPointer));
    HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashNodePointer = systemStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  FUN_18063a180(ConfigurationDataPointer,*(void* *)(ResourceManagerPointer + 0xd0),(long long)*(int *)(ResourceManagerPointer + 200) * 0x14);
  HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)HashNodePointer) + ConfigurationDataPointer[2]) < 5) {
    FUN_180639bf0(ConfigurationDataPointer,(long long)HashNodePointer + (4 - *ConfigurationDataPointer));
    HashNodePointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *HashNodePointer = 0;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  FUN_18063a180(ConfigurationDataPointer,0,0);
  return;
}





// 函数: void FUN_18007e880(long long ResourceManagerPointer,char ConfigurationDataPointer,void* AdditionalParameter)
/**
 * @brief 配置系统资源数据指针
 * 
 * 该函数负责配置系统资源数据指针，包括内存分配和数据复制。
 * 主要用于系统资源数据的动态管理。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 * 原始函数名为FUN_18007e880，现已重命名为ConfigureSystemResourceDataPointer
 */
void ConfigureSystemResourceDataPointer(long long ResourceManagerPointer,char ConfigurationDataPointer,void* AdditionalParameter)

{
  long long nextDataIndex;
  void* creationFlags;
  long long localResourceOffset;
  
  *(int *)(*(long long *)(ResourceManagerPointer + 600) + 0x18) = (int)ConfigurationDataPointer;
  FUN_18007e990(ResourceManagerPointer,*(int *)(*(long long *)(ResourceManagerPointer + 600) + 0x1c) +
                        *(int *)(*(long long *)(ResourceManagerPointer + 600) + 0x18));
  nextDataIndex = *(long long *)(ResourceManagerPointer + 600);
  if (*(long long *)(nextDataIndex + 0x10) != 0) {
      SystemCleanupFunction();
  }
  creationFlags = 0;
  localResourceOffset = (long long)ConfigurationDataPointer;
  *(void* *)(nextDataIndex + 0x10) = 0;
  if (localResourceOffset != 0) {
    creationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,localResourceOffset,0x10,CONCAT71((int7)((ulong long)nextDataIndex >> 8),3));
  }
  *(void* *)(*(long long *)(ResourceManagerPointer + 600) + 0x10) = creationFlags;
                    0001808ffc47. Too many branches
                        memcpy(*(void* *)(*(long long *)(ResourceManagerPointer + 600) + 0x10),AdditionalParameter,localResourceOffset);
  return;
}





// 函数: void FUN_18007e930(long long ResourceManagerPointer)
/**
 * @brief 初始化系统资源内存块
 * 
 * 该函数负责初始化系统资源内存块，分配内存并清零。
 * 主要用于系统资源内存的前期准备工作。
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18007e930，现已重命名为InitializeSystemResourceMemoryBlock
 */
void InitializeSystemResourceMemoryBlock(long long ResourceManagerPointer)

{
  void* systemStatus;
  
  if (*(long long *)(ResourceManagerPointer + 0x2c8) == 0) {
    *(uint *)(ResourceManagerPointer + 0x100) = *(uint *)(ResourceManagerPointer + 0x100) | 8;
    systemStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xd0,4,9);
      memset(systemStatus,0,0xd0);
  }
  return;
}




// 函数: void FUN_18007e95f(void)
/**
 * @brief 分配系统内存块
 * 
 * 该函数负责分配系统内存块并初始化为零。
 * 主要用于系统内存的动态分配。
 * 
 * 原始函数名为FUN_18007e95f，现已重命名为AllocateSystemMemoryBlock
 */
void AllocateSystemMemoryBlock(void)

{
  void* systemStatus;
  
  systemStatus = SystemMemoryAllocationFunction();
    memset(systemStatus,0,0xd0);
}




// 函数: void FUN_18007e988(void)
/**
 * @brief 系统空操作函数F
 * 
 * 该函数是一个空操作函数，不做任何实际操作
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_18007e988，现已重命名为SystemNoOperationF
 */
void SystemNoOperationF(void)

{
  return;
}





// 函数: void FUN_18007e990(long long ResourceManagerPointer,int ConfigurationDataPointer)
void FUN_18007e990(long long ResourceManagerPointer,int ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  void* creationFlags;
  
  PrimaryResourcePointer = *(long long **)(ResourceManagerPointer + 600);
  if ((int)PrimaryResourcePointer[1] != ConfigurationDataPointer) {
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
    creationFlags = 0;
    *PrimaryResourcePointer = 0;
    if (ConfigurationDataPointer != 0) {
      creationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)ConfigurationDataPointer << 6,0x10,4);
    }
    **(void* **)(ResourceManagerPointer + 600) = creationFlags;
    *(int *)(*(long long *)(ResourceManagerPointer + 600) + 8) = ConfigurationDataPointer;
  }
  return;
}




// 函数: void FUN_18007ea10(long long ResourceManagerPointer,char ConfigurationDataPointer)
void FUN_18007ea10(long long ResourceManagerPointer,char ConfigurationDataPointer)

{
  byte isByteValid;
  long long localSystemHandle;
  long long *plocalResourceOffset;
  uint8_t StackBuffer40 [8];
  long long longValue38;
  uint32_t unsignedValue30;
  long long *plStack_28;
  
  if (*(char *)(ResourceManagerPointer + 0xf4) == ConfigurationDataPointer) {
    return;
  }
  localSystemHandle = 0;
  if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) != 0) {
    FUN_18007baa0();
    do {
      *(char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x14 + localSystemHandle) = ConfigurationDataPointer;
      localSystemHandle = localSystemHandle + 0x18;
    } while (localSystemHandle < 0x180);
  }
  plStack_28 = (long long *)0x0;
  StackBuffer40[0] = 0;
  unsignedValue30 = 1;
  longValue38 = ResourceManagerPointer;
  FUN_18007f4c0(StackBuffer40);
  if (plStack_28 == (long long *)0x0) goto LAB_18007eb55;
  plocalResourceOffset = plStack_28;
  if (ConfigurationDataPointer != '\0') {
    if ((ConfigurationDataPointer != '\x01') || ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0)) goto LAB_18007eb55;
    localSystemHandle = *(long long *)(ResourceManagerPointer + 0x1b8);
    isByteValid = *(byte *)(localSystemHandle + 0x38c);
    if (isByteValid == 9) {
      isByteValid = func_0x00018022d300();
      *(byte *)(localSystemHandle + 0x38c) = isByteValid;
    }
    plocalResourceOffset = plStack_28;
    if ((*(char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + (ulong long)isByteValid * 0x18) != '\x03') &&
       (*(char *)(*(long long *)(ResourceManagerPointer + 0x1e0) + 0x15 + (ulong long)isByteValid * 0x18) != '\x02'))
    goto LAB_18007eb55;
  }
  plStack_28 = (long long *)0x0;
  if (plocalResourceOffset != (long long *)0x0) {
    (**(code **)(*plocalResourceOffset + 0x38))();
  }
LAB_18007eb55:
  *(char *)(ResourceManagerPointer + 0xf4) = ConfigurationDataPointer;
  FUN_18007f6a0(StackBuffer40);
  if (plStack_28 != (long long *)0x0) {
    (**(code **)(*plStack_28 + 0x38))();
  }
  return;
}




/**
 * @brief 系统资源配置函数
 * 
 * 该函数负责配置系统资源，包括内存分配、资源链接和初始化设置
 * 用于系统资源的动态配置和管理
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置结果代码指针
 * 
 * 原始函数名为FUN_18007eb80，现已重命名为ConfigureSystemResources
 */
code * ConfigureSystemResources(long long ResourceManagerPointer,char ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  code *ResultCode;
  void* AllocatedMemory;
  code *ResourcePointer;
  long long* SystemMemoryPointer;
  long long LocalContext;
  uint32_t ConfigurationFlags;
  code *FunctionPointer1;
  code *FunctionPointer2;
  
  ResourcePointer = (code *)(ResourceManagerPointer + 0x210);
  if (*(long long *)ResourcePointer == 0) {
    if ((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0) {
      LocalContext = func_0x000180085de0(*(void* *)(ResourceManagerPointer + 0x1b0));
      if (LocalContext != ResourceManagerPointer) {
        ConfigurationFlags = 0;
        FUN_18007f770(&LocalContext);
        AllocatedMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xf0,8,3);
        AllocatedMemory = FUN_18007f2f0(AllocatedMemory);
        SystemResourceManagerLink(ResourcePointer,AllocatedMemory);
        FUN_1800860f0(*(long long *)ResourcePointer + 0x10,(long long)FunctionPointer1 + 0x10);
        FUN_1800860f0(*(long long *)ResourcePointer + 0x38,(long long)FunctionPointer1 + 0x38);
        FUN_180086090(*(long long *)ResourcePointer + 0x60,(long long)FunctionPointer1 + 0x60);
        FUN_180085fb0(*(long long *)ResourcePointer + 0x88,(long long)FunctionPointer1 + 0x88);
        if (ConfigurationDataPointer != '\0') {
          *(byte *)(ResourceManagerPointer + 0xfd) = *(byte *)(ResourceManagerPointer + 0xfd) | 0x40;
          FUN_180085ec0(*(long long *)ResourcePointer + 200,(long long)FunctionPointer1 + 200);
          FUN_180085680(*(long long *)ResourcePointer + 0xb0,(long long)FunctionPointer1 + 0xb0);
        }
        ResultCode = (code *)FUN_18007f840(&LocalContext);
        return ResultCode;
      }
    }
    if (*(long long *)(ResourceManagerPointer + 0xa8) == 0) {
      if ((*(byte *)(ResourceManagerPointer + 0xfd) & 4) != 0) {
        AllocatedMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xf0,8,3);
        PrimaryResourcePointer = (long long *)FUN_18007f2f0(AllocatedMemory);
        FunctionPointer2 = (code *)0xfffffffffffffffe;
        if (PrimaryResourcePointer != (long long *)0x0) {
          (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
        }
        PrimaryResourcePointer = *(long long **)ResourcePointer;
        *(long long **)ResourcePointer = PrimaryResourcePointer;
        if (PrimaryResourcePointer != (long long *)0x0) {
          (**(code **)(*PrimaryResourcePointer + 0x38))();
        }
        return ResourcePointer;
      }
      InitializeSystemResource(&SystemResourceInitializer);
      ResultCode = (code *)AllocateSystemMemory(&SystemFunctionAllocator);
    }
    else {
      PrimaryResourcePointer = *(long long **)(*(long long *)(ResourceManagerPointer + 0xa8) + 0x88);
      FunctionPointer1 = (code *)&SystemEntryPoint;
      FunctionPointer2 = SystemMainFunction;
      LocalContext = ResourceManagerPointer;
      (**(code **)(*PrimaryResourcePointer + 0x60))(PrimaryResourcePointer,&GAME_CORE_SYSTEM_ID,ResourceManagerPointer + 0xb8,0,&LocalContext);
      ResultCode = FunctionPointer1;
      if (FunctionPointer1 != (code *)0x0) {
        ResourcePointer = (code *)(*FunctionPointer1)(&LocalContext,0,0);
        return ResourcePointer;
      }
    }
  }
  return ResultCode;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，包括内存释放和状态重置
 * 用于系统资源的清理和释放操作
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 * 原始函数名为FUN_18007edd0，现已重命名为CleanupSystemResources
 */
void CleanupSystemResources(long long ResourceManagerPointer,char ConfigurationDataPointer)

{
  long long *ResourceToRelease;
  
  if (*(long long *)(ResourceManagerPointer + 0x210) != 0) {
    FUN_1800791a0();
    if (ConfigurationDataPointer != '\0') {
      *(byte *)(ResourceManagerPointer + 0xfd) = *(byte *)(ResourceManagerPointer + 0xfd) | 0x20;
      *(byte *)(ResourceManagerPointer + 0xfe) = *(byte *)(ResourceManagerPointer + 0xfe) | 1;
      FUN_18007baa0(ResourceManagerPointer);
    }
    if (((*(char *)(ResourceManagerPointer + 0xfc) == '\0') && (*(char *)(ResourceManagerPointer + 0xf4) == '\0')) &&
       (((*(byte *)(ResourceManagerPointer + 0xfd) & 0x20) == 0 || ((*(byte *)(ResourceManagerPointer + 0xfe) & 1) == 0)))) {
      ResourceToRelease = *(long long **)(ResourceManagerPointer + 0x210);
      *(void* *)(ResourceManagerPointer + 0x210) = 0;
      if (ResourceToRelease != (long long *)0x0) {
                    00018007ee5b. Too many branches
                            (**(code **)(*ResourceToRelease + 0x38))();
        return;
      }
    }
  }
  return;
}





/**
 * @brief 系统状态检查函数
 * 
 * 该函数负责检查系统状态，验证系统配置和资源状态
 * 用于系统状态监控和验证
 * 
 * @param ResourceManagerPointer 系统资源指针
 * 
 * 原始函数名为FUN_18007ee70，现已重命名为CheckSystemStatus
 */
void CheckSystemStatus(long long ResourceManagerPointer)

{
  int StatusFlags;
  uint ResourceCount;
  void* ResourcePointer;
  int SystemIndex;
  uint ConfigurationFlags;
  uint MemoryFlags;
  int MemoryOffset;
  uint ValidationFlags;
  long long ResourceHandle;
  long long AllocationContext;
  ulong long SystemTimestamp;
  void* *ResourceArray;
  ulong long systemStatus3;
  ulong long systemStatus4;
  long long nextDataIndex5;
  
  allocationFlags = *(long long *)(ResourceManagerPointer + 0x2d0);
  systemStatus = *(int *)(SystemStatusFlagsPointer + 0x224);
  if (*(int *)(allocationFlags + 0xc) != systemStatus) {
    if (*(int *)(allocationFlags + 8) < 1) {
      if (*(int *)(allocationFlags + 0xc) == systemStatus + -1) {
        hashValue = *(int *)(SystemMemoryContext + 0x9c8) + 1U & 0x80000001;
        if ((int)hashValue < 0) {
          hashValue = (hashValue - 1 | 0xfffffffe) + 1;
        }
        nextDataIndex5 = (long long)(int)hashValue * 0x488 + SystemMemoryContext + 0xb8;
        resourceCounter = (long long)*(int *)(SystemMemoryContext + 0x9c8) * 0x488 + SystemMemoryContext + 0xb8;
        systemStatus4 = FUN_180080480(resourceCounter,*(uint32_t *)(allocationFlags + 0x14));
        systemOffset = (int)systemStatus4;
        systemStatus1 = systemStatus4 & 0xffffffff;
        if (-1 < systemOffset) {
          systemStatus3 = systemStatus4 >> 0xb & 0x1fffff;
          hashValue = *(uint *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x14);
          systemStatus4 = (ulong long)hashValue;
          creationFlags = *(uint *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x18);
          currentThreadId = (uint)systemStatus3;
          if (currentThreadId == hashValue + systemOffset >> 0xb) {
            unsignedSystemValue8 = creationFlags >> 0xb;
            if (unsignedSystemValue8 == creationFlags + hashValue >> 0xb) {
                memcpy(*(long long *)(resourceCounter + 8 + systemStatus3 * 8) + (ulong long)(systemOffset + currentThreadId * -0x800) * 8
                     ,*(long long *)(nextDataIndex5 + 8 + (ulong long)unsignedSystemValue8 * 8) +
                      (ulong long)(creationFlags + unsignedSystemValue8 * -0x800) * 8,(long long)(int)hashValue << 3);
            }
          }
          if (0 < (int)hashValue) {
            do {
              systemIndex = (int)systemStatus1;
              currentThreadId = (creationFlags - systemOffset) + systemIndex;
              hashValue = currentThreadId >> 0xb;
              systemStatus3 = systemStatus1 >> 0xb;
              systemStatus1 = (ulong long)(systemIndex + 1);
              *(void* *)
               (*(long long *)(resourceCounter + 8 + systemStatus3 * 8) +
               (ulong long)(uint)(systemIndex + (int)systemStatus3 * -0x800) * 8) =
                   *(void* *)
                    (*(long long *)(nextDataIndex5 + 8 + (ulong long)hashValue * 8) +
                    (ulong long)(currentThreadId + hashValue * -0x800) * 8);
              systemStatus4 = systemStatus4 - 1;
            } while (systemStatus4 != 0);
          }
          *(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x18) = systemOffset;
          *(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0xc) = systemStatus;
        }
      }
      else {
        *(uint32_t *)(allocationFlags + 0x14) = 0;
      }
    }
    else {
      allocationFlags = (long long)*(int *)(SystemMemoryContext + 0x9c8) * 0x488 + SystemMemoryContext + 0xb8;
      currentThreadId = FUN_180080480(allocationFlags);
      creationFlags = currentThreadId >> 0xb;
      hashValue = *(uint *)(*(void* **)(ResourceManagerPointer + 0x2d0) + 1);
      systemStatus4 = (ulong long)hashValue;
      psystemStatus2 = (void* *)**(void* **)(ResourceManagerPointer + 0x2d0);
      if (creationFlags == hashValue + currentThreadId >> 0xb) {
          memcpy(*(long long *)(allocationFlags + 8 + (ulong long)creationFlags * 8) +
               (ulong long)(currentThreadId + creationFlags * -0x800) * 8,psystemStatus2,(ulong long)hashValue << 3);
      }
      creationFlags = currentThreadId;
      if (hashValue != 0) {
        do {
          allocationContext = *psystemStatus2;
          psystemStatus2 = psystemStatus2 + 1;
          *(void* *)
           (*(long long *)(allocationFlags + 8 + (ulong long)(creationFlags >> 0xb) * 8) +
           (ulong long)(creationFlags + (creationFlags >> 0xb) * -0x800) * 8) = allocationContext;
          systemStatus4 = systemStatus4 - 1;
          creationFlags = creationFlags + 1;
        } while (systemStatus4 != 0);
      }
      *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x14) =
           *(uint32_t *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 8);
      *(uint *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0x18) = currentThreadId;
      *(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 0xc) = systemStatus;
    }
  }
  return;
}





// 函数: void FUN_18007eea1(long long ResourceManagerPointer,int ConfigurationDataPointer,int AdditionalParameter)
void FUN_18007eea1(long long ResourceManagerPointer,int ConfigurationDataPointer,int AdditionalParameter)

{
  uint systemStatus;
  void* creationFlags;
  int MemoryComparisonResult;
  uint unsignedSystemValue4;
  uint currentThreadId;
  int systemFlag;
  uint unsignedSystemValue7;
  long long systemMemoryBlockPtr;
  int unaff_EBP;
  long long localMemoryAddress;
  ulong long unsignedSystemValue9;
  void* *pointerToUnsigned10;
  ulong long systemStatus1;
  ulong long systemStatus2;
  long long nextDataIndex3;
  
  if (ConfigurationDataPointer < 1) {
    if (AdditionalParameter == unaff_EBP + -1) {
      currentThreadId = *(int *)(SystemMemoryContext + 0x9c8) + 1U & 0x80000001;
      if ((int)currentThreadId < 0) {
        currentThreadId = (currentThreadId - 1 | 0xfffffffe) + 1;
      }
      nextDataIndex3 = (long long)(int)currentThreadId * 0x488 + SystemMemoryContext + 0xb8;
      localMemoryAddress = (long long)*(int *)(SystemMemoryContext + 0x9c8) * 0x488 + SystemMemoryContext + 0xb8;
      systemStatus2 = FUN_180080480(localMemoryAddress,*(uint32_t *)(ResourceManagerPointer + 0x14));
      systemFlag = (int)systemStatus2;
      unsignedSystemValue9 = systemStatus2 & 0xffffffff;
      if (-1 < systemFlag) {
        systemStatus1 = systemStatus2 >> 0xb & 0x1fffff;
        currentThreadId = *(uint *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14);
        systemStatus2 = (ulong long)currentThreadId;
        systemStatus = *(uint *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x18);
        unsignedSystemValue4 = (uint)systemStatus1;
        if (unsignedSystemValue4 == currentThreadId + systemFlag >> 0xb) {
          unsignedSystemValue7 = systemStatus >> 0xb;
          if (unsignedSystemValue7 == systemStatus + currentThreadId >> 0xb) {
              memcpy(*(long long *)(localMemoryAddress + 8 + systemStatus1 * 8) + (ulong long)(systemFlag + unsignedSystemValue4 * -0x800) * 8,
                   *(long long *)(nextDataIndex3 + 8 + (ulong long)unsignedSystemValue7 * 8) +
                   (ulong long)(systemStatus + unsignedSystemValue7 * -0x800) * 8,(long long)(int)currentThreadId << 3);
          }
        }
        if (0 < (int)currentThreadId) {
          do {
            systemCounter = (int)unsignedSystemValue9;
            unsignedSystemValue4 = (systemStatus - systemFlag) + systemCounter;
            currentThreadId = unsignedSystemValue4 >> 0xb;
            systemStatus1 = unsignedSystemValue9 >> 0xb;
            unsignedSystemValue9 = (ulong long)(systemCounter + 1);
            *(void* *)
             (*(long long *)(localMemoryAddress + 8 + systemStatus1 * 8) +
             (ulong long)(uint)(systemCounter + (int)systemStatus1 * -0x800) * 8) =
                 *(void* *)
                  (*(long long *)(nextDataIndex3 + 8 + (ulong long)currentThreadId * 8) +
                  (ulong long)(unsignedSystemValue4 + currentThreadId * -0x800) * 8);
            systemStatus2 = systemStatus2 - 1;
          } while (systemStatus2 != 0);
        }
        *(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x18) = systemFlag;
        *(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0xc) = unaff_EBP;
      }
    }
    else {
      *(uint32_t *)(ResourceManagerPointer + 0x14) = 0;
    }
  }
  else {
    localMemoryAddress = (long long)*(int *)(SystemMemoryContext + 0x9c8) * 0x488 + SystemMemoryContext + 0xb8;
    unsignedSystemValue4 = FUN_180080480(localMemoryAddress);
    systemStatus = unsignedSystemValue4 >> 0xb;
    currentThreadId = *(uint *)(*(void* **)(systemMemoryBlockPtr + 0x2d0) + 1);
    systemStatus2 = (ulong long)currentThreadId;
    pointerToUnsigned10 = (void* *)**(void* **)(systemMemoryBlockPtr + 0x2d0);
    if (systemStatus == currentThreadId + unsignedSystemValue4 >> 0xb) {
        memcpy(*(long long *)(localMemoryAddress + 8 + (ulong long)systemStatus * 8) +
             (ulong long)(unsignedSystemValue4 + systemStatus * -0x800) * 8,pointerToUnsigned10,(ulong long)currentThreadId << 3);
    }
    systemStatus = unsignedSystemValue4;
    if (currentThreadId != 0) {
      do {
        creationFlags = *pointerToUnsigned10;
        pointerToUnsigned10 = pointerToUnsigned10 + 1;
        *(void* *)
         (*(long long *)(localMemoryAddress + 8 + (ulong long)(systemStatus >> 0xb) * 8) +
         (ulong long)(systemStatus + (systemStatus >> 0xb) * -0x800) * 8) = creationFlags;
        systemStatus2 = systemStatus2 - 1;
        systemStatus = systemStatus + 1;
      } while (systemStatus2 != 0);
    }
    *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14) =
         *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 8);
    *(uint *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x18) = unsignedSystemValue4;
    *(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0xc) = unaff_EBP;
  }
  return;
}




// 函数: void FUN_18007ef9a(long long ResourceManagerPointer,long long ConfigurationDataPointer)
void FUN_18007ef9a(long long ResourceManagerPointer,long long ConfigurationDataPointer)

{
  uint systemStatus;
  int systemResult;
  uint allocationContext;
  int systemIndex;
  ulong long currentThreadId;
  uint hashValue;
  uint unsignedSystemValue7;
  long long systemMemoryBlockPtr;
  uint32_t unaff_EBP;
  ulong long unsignedSystemValue8;
  ulong long unsignedSystemValue9;
  long long allocationFlags;
  
  allocationContext = *(int *)(ConfigurationDataPointer + 0x910) + 1U & 0x80000001;
  if ((int)allocationContext < 0) {
    allocationContext = (allocationContext - 1 | 0xfffffffe) + 1;
  }
  allocationFlags = (long long)(int)allocationContext * 0x488 + ConfigurationDataPointer;
  ConfigurationDataPointer = (long long)*(int *)(ConfigurationDataPointer + 0x910) * 0x488 + ConfigurationDataPointer;
  currentThreadId = FUN_180080480(ConfigurationDataPointer,*(uint32_t *)(ResourceManagerPointer + 0x14));
  systemIndex = (int)currentThreadId;
  unsignedSystemValue8 = currentThreadId & 0xffffffff;
  if (-1 < systemIndex) {
    unsignedSystemValue9 = currentThreadId >> 0xb & 0x1fffff;
    allocationContext = *(uint *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x14);
    currentThreadId = (ulong long)allocationContext;
    systemStatus = *(uint *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x18);
    unsignedSystemValue7 = (uint)unsignedSystemValue9;
    if (unsignedSystemValue7 == allocationContext + systemIndex >> 0xb) {
      hashValue = systemStatus >> 0xb;
      if (hashValue == systemStatus + allocationContext >> 0xb) {
          memcpy(*(long long *)(ConfigurationDataPointer + 8 + unsignedSystemValue9 * 8) + (ulong long)(systemIndex + unsignedSystemValue7 * -0x800) * 8,
               *(long long *)(allocationFlags + 8 + (ulong long)hashValue * 8) +
               (ulong long)(systemStatus + hashValue * -0x800) * 8,(long long)(int)allocationContext << 3);
      }
    }
    if (0 < (int)allocationContext) {
      do {
        systemResult = (int)unsignedSystemValue8;
        unsignedSystemValue7 = (systemStatus - systemIndex) + systemResult;
        allocationContext = unsignedSystemValue7 >> 0xb;
        unsignedSystemValue9 = unsignedSystemValue8 >> 0xb;
        unsignedSystemValue8 = (ulong long)(systemResult + 1);
        *(void* *)
         (*(long long *)(ConfigurationDataPointer + 8 + unsignedSystemValue9 * 8) +
         (ulong long)(uint)(systemResult + (int)unsignedSystemValue9 * -0x800) * 8) =
             *(void* *)
              (*(long long *)(allocationFlags + 8 + (ulong long)allocationContext * 8) +
              (ulong long)(unsignedSystemValue7 + allocationContext * -0x800) * 8);
        currentThreadId = currentThreadId - 1;
      } while (currentThreadId != 0);
    }
    *(int *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0x18) = systemIndex;
    *(uint32_t *)(*(long long *)(systemMemoryBlockPtr + 0x2d0) + 0xc) = unaff_EBP;
  }
  return;
}




/**
 * @brief 系统空操作函数G
 * 
 * 该函数是一个空操作函数，不做任何实际操作
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_18007f0b5，现已重命名为SystemNoOperationG
 */
void SystemNoOperationG(void)

{
  return;
}




/**
 * @brief 系统空操作函数H
 * 
 * 该函数是一个空操作函数，不做任何实际操作
 * 
 * @return 无返回值
 * 
 * 原始函数名为FUN_18007f0bf，现已重命名为SystemNoOperationH
 */
void SystemNoOperationH(void)

{
  return;
}




// 函数: void FUN_18007f0ca(long long ResourceManagerPointer)
void FUN_18007f0ca(long long ResourceManagerPointer)

{
  *(uint32_t *)(ResourceManagerPointer + 0x14) = 0;
  return;
}





// 函数: void FUN_18007f0e0(long long ResourceManagerPointer,long long ConfigurationDataPointer,int AdditionalParameter)
void FUN_18007f0e0(long long ResourceManagerPointer,long long ConfigurationDataPointer,int AdditionalParameter)

{
  int *pointerToInteger1;
  void** SystemDataTable;
  void* *HashNodePointer;
  void* *punsignedSystemValue4;
  uint currentThreadId;
  int *pointerToInteger7;
  long long localMemoryAddress;
  ulong long unsignedSystemValue9;
  long long allocationFlags;
  void** SystemRootNode;
  
  unsignedSystemValue9 = (ulong long)AdditionalParameter;
  if (**(long long **)(ResourceManagerPointer + 0x2d0) != 0) {
      SystemCleanupFunction();
  }
  punsignedSystemValue4 = (void* *)0x0;
  **(long long **)(ResourceManagerPointer + 0x2d0) = 0;
  if (0 < AdditionalParameter) {
    HashEntryStatus = punsignedSystemValue4;
    if (AdditionalParameter != 0) {
      HashEntryStatus = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,unsignedSystemValue9 * 8,3);
      HashNodePointer = HashEntryStatus;
      resourceEntryPointer = punsignedSystemValue4;
      do {
        currentThreadId = (int)resourceEntryPointer + 1;
        resourceEntryPointer = (void* *)(ulong long)currentThreadId;
        *HashNodePointer = 0;
        HashNodePointer = HashNodePointer + 1;
      } while ((ulong long)(long long)(int)currentThreadId < unsignedSystemValue9);
    }
    **(void* **)(ResourceManagerPointer + 0x2d0) = HashEntryStatus;
    if (3 < (long long)unsignedSystemValue9) {
      allocationFlags = -8 - ConfigurationDataPointer;
      localMemoryAddress = (unsignedSystemValue9 - 4 >> 2) + 1;
      punsignedSystemValue4 = (void* *)(localMemoryAddress * 4);
      pointerToInteger7 = (int *)(ConfigurationDataPointer + 8);
      do {
        pointerToInteger1 = pointerToInteger7 + 8;
        *(float *)((long long)pointerToInteger7 + **(long long **)(ResourceManagerPointer + 0x2d0) + allocationFlags) = (float)pointerToInteger7[-2]
        ;
        *(int *)((long long)pointerToInteger7 + **(long long **)(ResourceManagerPointer + 0x2d0) + 4 + allocationFlags) = pointerToInteger7[-1];
        *(float *)((long long)pointerToInteger7 + **(long long **)(ResourceManagerPointer + 0x2d0) + 8 + allocationFlags) =
             (float)*pointerToInteger7;
        *(int *)((long long)pointerToInteger7 + **(long long **)(ResourceManagerPointer + 0x2d0) + 0xc + allocationFlags) = pointerToInteger7[1];
        *(float *)((**(long long **)(ResourceManagerPointer + 0x2d0) - ConfigurationDataPointer) + -0x18 + (long long)pointerToInteger1) =
             (float)pointerToInteger7[2];
        *(int *)((long long)pointerToInteger7 + **(long long **)(ResourceManagerPointer + 0x2d0) + 0x14 + allocationFlags) = pointerToInteger7[3];
        *(float *)((**(long long **)(ResourceManagerPointer + 0x2d0) - ConfigurationDataPointer) + -0x10 + (long long)pointerToInteger1) =
             (float)pointerToInteger7[4];
        *(int *)((long long)pointerToInteger7 + **(long long **)(ResourceManagerPointer + 0x2d0) + 0x1c + allocationFlags) = pointerToInteger7[5];
        localMemoryAddress = localMemoryAddress + -1;
        pointerToInteger7 = pointerToInteger1;
      } while (localMemoryAddress != 0);
    }
    for (; (long long)punsignedSystemValue4 < (long long)unsignedSystemValue9; punsignedSystemValue4 = (void* *)((long long)punsignedSystemValue4 + 1)) {
      *(float *)(**(long long **)(ResourceManagerPointer + 0x2d0) + (long long)punsignedSystemValue4 * 8) =
           (float)*(int *)(ConfigurationDataPointer + (long long)punsignedSystemValue4 * 8);
      *(uint32_t *)(**(long long **)(ResourceManagerPointer + 0x2d0) + 4 + (long long)punsignedSystemValue4 * 8) =
           *(uint32_t *)(ConfigurationDataPointer + 4 + (long long)punsignedSystemValue4 * 8);
    }
    *(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 8) = AdditionalParameter;
    return;
  }
  *(int *)(*(long long *)(ResourceManagerPointer + 0x2d0) + 8) = AdditionalParameter;
  return;
}





// 函数: void FUN_18007f11f(void)
void FUN_18007f11f(void)

{
  int *pointerToInteger1;
  ulong long *HashEntryStatus;
  ulong long *HashNodePointer;
  ulong long systemMemoryBlockPtr;
  long long systemStackFramePtr;
  long long systemDataIndexPtr;
  uint unsignedSystemValue4;
  ulong long currentThreadId;
  int *pointerToInteger6;
  long long localDataIndex;
  ulong long systemResourceCounter;
  long long localMemoryAddress;
  bool in_ZF;
  
  if (in_ZF) {
    HashEntryStatus = (ulong long *)(systemMemoryBlockPtr & 0xffffffff);
  }
  else {
    HashEntryStatus = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,systemResourceCounter * 8,3);
    currentThreadId = systemMemoryBlockPtr & 0xffffffff;
    HashNodePointer = HashEntryStatus;
    do {
      unsignedSystemValue4 = (int)currentThreadId + 1;
      currentThreadId = (ulong long)unsignedSystemValue4;
      *HashNodePointer = systemMemoryBlockPtr;
      HashNodePointer = HashNodePointer + 1;
    } while ((ulong long)(long long)(int)unsignedSystemValue4 < systemResourceCounter);
  }
  **(long long **)(systemDataIndexPtr + 0x2d0) = (long long)HashEntryStatus;
  if (3 < (long long)systemResourceCounter) {
    localMemoryAddress = -8 - systemStackFramePtr;
    localDataIndex = (systemResourceCounter - 4 >> 2) + 1;
    systemMemoryBlockPtr = localDataIndex * 4;
    pointerToInteger6 = (int *)(systemStackFramePtr + 8);
    do {
      pointerToInteger1 = pointerToInteger6 + 8;
      *(float *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + localMemoryAddress) = (float)pointerToInteger6[-2];
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 4 + localMemoryAddress) = pointerToInteger6[-1];
      *(float *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 8 + localMemoryAddress) = (float)*pointerToInteger6
      ;
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0xc + localMemoryAddress) = pointerToInteger6[1];
      *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x18 + (long long)pointerToInteger1) =
           (float)pointerToInteger6[2];
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x14 + localMemoryAddress) = pointerToInteger6[3];
      *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x10 + (long long)pointerToInteger1) =
           (float)pointerToInteger6[4];
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x1c + localMemoryAddress) = pointerToInteger6[5];
      localDataIndex = localDataIndex + -1;
      pointerToInteger6 = pointerToInteger1;
    } while (localDataIndex != 0);
  }
  for (; (long long)systemMemoryBlockPtr < (long long)systemResourceCounter; systemMemoryBlockPtr = systemMemoryBlockPtr + 1) {
    *(float *)(**(long long **)(systemDataIndexPtr + 0x2d0) + systemMemoryBlockPtr * 8) =
         (float)*(int *)(systemStackFramePtr + systemMemoryBlockPtr * 8);
    *(uint32_t *)(**(long long **)(systemDataIndexPtr + 0x2d0) + 4 + systemMemoryBlockPtr * 8) =
         *(uint32_t *)(systemStackFramePtr + 4 + systemMemoryBlockPtr * 8);
  }
  *(int *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = (int)systemResourceCounter;
  return;
}




// 函数: void FUN_18007f176(void)
void FUN_18007f176(void)

{
  int *pointerToInteger1;
  long long localSystemHandle;
  long long systemStackFramePtr;
  long long systemDataIndexPtr;
  int *pointerToInteger3;
  long long bufferBaseAddress;
  long long systemResourceCounter;
  long long SystemTimeValue;
  
  localSystemPointer = -8 - systemStackFramePtr;
  bufferBaseAddress = (systemResourceCounter - 4U >> 2) + 1;
  localSystemHandle = bufferBaseAddress * 4;
  pointerToInteger3 = (int *)(systemStackFramePtr + 8);
  do {
    pointerToInteger1 = pointerToInteger3 + 8;
    *(float *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + localSystemPointer) = (float)pointerToInteger3[-2];
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 4 + localSystemPointer) = pointerToInteger3[-1];
    *(float *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 8 + localSystemPointer) = (float)*pointerToInteger3;
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0xc + localSystemPointer) = pointerToInteger3[1];
    *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x18 + (long long)pointerToInteger1) =
         (float)pointerToInteger3[2];
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x14 + localSystemPointer) = pointerToInteger3[3];
    *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x10 + (long long)pointerToInteger1) =
         (float)pointerToInteger3[4];
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x1c + localSystemPointer) = pointerToInteger3[5];
    bufferBaseAddress = bufferBaseAddress + -1;
    pointerToInteger3 = pointerToInteger1;
  } while (bufferBaseAddress != 0);
  for (; localSystemHandle < systemResourceCounter; localSystemHandle = localSystemHandle + 1) {
    *(float *)(**(long long **)(systemDataIndexPtr + 0x2d0) + localSystemHandle * 8) =
         (float)*(int *)(systemStackFramePtr + localSystemHandle * 8);
    *(uint32_t *)(**(long long **)(systemDataIndexPtr + 0x2d0) + 4 + localSystemHandle * 8) =
         *(uint32_t *)(systemStackFramePtr + 4 + localSystemHandle * 8);
  }
  *(int *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = (int)systemResourceCounter;
  return;
}




// 函数: void FUN_18007f27a(void)
void FUN_18007f27a(void)

{
  long long systemMemoryBlockPtr;
  long long systemStackFramePtr;
  long long systemDataIndexPtr;
  long long systemResourceCounter;
  
  if (systemMemoryBlockPtr < systemResourceCounter) {
    do {
      *(float *)(**(long long **)(systemDataIndexPtr + 0x2d0) + systemMemoryBlockPtr * 8) =
           (float)*(int *)(systemStackFramePtr + systemMemoryBlockPtr * 8);
      *(uint32_t *)(**(long long **)(systemDataIndexPtr + 0x2d0) + 4 + systemMemoryBlockPtr * 8) =
           *(uint32_t *)(systemStackFramePtr + 4 + systemMemoryBlockPtr * 8);
      systemMemoryBlockPtr = systemMemoryBlockPtr + 1;
    } while (systemMemoryBlockPtr < systemResourceCounter);
  }
  *(int *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = (int)systemResourceCounter;
  return;
}




// 函数: void FUN_18007f2cf(void)
void FUN_18007f2cf(void)

{
  long long systemDataIndexPtr;
  uint32_t systemResourceCounterD;
  
  *(uint32_t *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = systemResourceCounterD;
  return;
}



void* * FUN_18007f2f0(void* *ResourceManagerPointer)

{
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *(uint32_t *)(ResourceManagerPointer + 1) = 0;
  *ResourceManagerPointer = &UNK_1809fffc8;
  ResourceManagerPointer[2] = 0;
  ResourceManagerPointer[3] = 0;
  *(uint8_t *)(ResourceManagerPointer + 6) = 3;
  ResourceManagerPointer[7] = 0;
  ResourceManagerPointer[8] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0xb) = 3;
  ResourceManagerPointer[0xc] = 0;
  ResourceManagerPointer[0xd] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x10) = 3;
  ResourceManagerPointer[0x11] = 0;
  ResourceManagerPointer[0x12] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x15) = 3;
  *(void*2 *)(ResourceManagerPointer + 0x18) = 0;
  ResourceManagerPointer[0x16] = 0;
  ResourceManagerPointer[0x17] = 0;
  ResourceManagerPointer[0x19] = 0;
  ResourceManagerPointer[0x1a] = 0;
  *(uint8_t *)(ResourceManagerPointer + 0x1d) = 3;
  *(uint8_t *)(ResourceManagerPointer + 6) = 0xf;
  *(uint8_t *)(ResourceManagerPointer + 0xb) = 0xf;
  *(uint8_t *)(ResourceManagerPointer + 0x10) = 0xf;
  *(uint8_t *)(ResourceManagerPointer + 0x15) = 0xf;
  *(uint8_t *)(ResourceManagerPointer + 0x1d) = 0xf;
  return ResourceManagerPointer;
}



void* * FUN_18007f3b0(void* *ResourceManagerPointer,ulong long ConfigurationDataPointer)

{
  *ResourceManagerPointer = &UNK_1809fffc8;
  if (ResourceManagerPointer[0x1a] != 0) {
      SystemCleanupFunction();
  }
  FUN_180085530(ResourceManagerPointer[0x16]);
  ResourceManagerPointer[0x16] = 0;
  if (ResourceManagerPointer[0x17] != 0) {
      SystemCleanupFunction();
  }
  ResourceManagerPointer[0x17] = 0;
  if (ResourceManagerPointer[0x12] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[0xd] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[8] != 0) {
      SystemCleanupFunction();
  }
  if (ResourceManagerPointer[3] != 0) {
      SystemCleanupFunction();
  }
  *ResourceManagerPointer = &SystemMemoryTemplateB;
  *ResourceManagerPointer = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(ResourceManagerPointer,0xf0);
  }
  return ResourceManagerPointer;
}





// 函数: void FUN_18007f4c0(uint8_t *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FUN_18007f4c0(uint8_t *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  long long *resourcePoolPointer;
  long long *plocalResourceOffset;
  char systemStatusFlag;
  int systemValue;
  uint32_t hashValue;
  long long localDataIndex;
  void* *newThreadLocalStorage;
  bool isSystemBusy;
  void* systemOperationFlags;
  
  systemOperationFlags = 0xfffffffffffffffe;
  isSystemBusy = false;
  if ((*(byte *)(*(long long *)(ResourceManagerPointer + 8) + 0xfd) & 0x20) != 0) {
    FUN_18007baa0();
    localDataIndex = 0;
    do {
      systemStatusFlag = *(char *)(*(long long *)(*(long long *)(ResourceManagerPointer + 8) + 0x1e0) + 0x15 + localDataIndex * 0x18);
      if (systemStatusFlag == '\x01') {
        Sleep(0);
        isSystemBusy = true;
      }
      nextDataIndex = localDataIndex + 1;
      localDataIndex = 0;
      if (systemStatusFlag != '\x01') {
        localDataIndex = nextDataIndex;
      }
    } while (localDataIndex < 0x10);
    if ((isSystemBusy) &&
       ((localDataIndex = *(long long *)(ResourceManagerPointer + 8), *(char *)(localDataIndex + 0xfa) == '\0' ||
        (*(char *)(localDataIndex + 0xfb) == '\0')))) {
      newThreadLocalStorage = &SystemStringTemplate;
      if (*(void* **)(localDataIndex + 0x18) != (void* *)0x0) {
        newThreadLocalStorage = *(void* **)(localDataIndex + 0x18);
      }
        UpdateContextManagerSystem(SystemContextManagerPointer,&UNK_1809ffc28,newThreadLocalStorage,ConfigurationFlag,systemOperationFlags);
    }
  }
  localDataIndex = *(long long *)(ResourceManagerPointer + 8);
  while( true ) {
    LOCK();
    systemStatusFlag = *(char *)(localDataIndex + 0xec);
    isSystemBusy = systemStatusFlag == '\0';
    if (isSystemBusy) {
      *(char *)(localDataIndex + 0xec) = '\x01';
      systemStatusFlag = '\0';
    }
    UNLOCK();
    if (isSystemBusy) break;
    systemValue = _Thrd_id();
    if (*(int *)(localDataIndex + 0xf0) == systemValue) goto LAB_18007f5cb;
    Sleep();
  }
  systemStatusFlag = '\0';
LAB_18007f5cb:
  hashValue = _Thrd_id();
  *(uint32_t *)(localDataIndex + 0xf0) = hashValue;
  if (systemStatusFlag == '\0') {
    *ResourceManagerPointer = 1;
  }
  while (*(int *)(localDataIndex + 0xe8) != 0) {
    Sleep(0);
  }
  if ((*(uint *)(ResourceManagerPointer + 0x10) & 1) == 0) {
    FUN_18007eb80(*(void* *)(ResourceManagerPointer + 8),(byte)(*(uint *)(ResourceManagerPointer + 0x10) >> 2) & 1);
  }
  resourcePoolPointer = *(long long **)(*(long long *)(ResourceManagerPointer + 8) + 0x210);
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
  }
  plocalResourceOffset = *(long long **)(ResourceManagerPointer + 0x18);
  *(long long **)(ResourceManagerPointer + 0x18) = resourcePoolPointer;
  if (plocalResourceOffset != (long long *)0x0) {
    (**(code **)(*plocalResourceOffset + 0x38))();
  }
  return;
}




/**
 * @brief 系统状态更新函数
 * 
 * 该函数负责更新系统状态，处理系统事件和消息
 * 用于游戏运行时的状态管理和事件处理
 * 
 * @param SystemState 系统状态参数
 */
void UpdateSystemState(long long SystemState)

{
  FUN_18007f6a0();
  if (*(long long **)(ResourceManagerPointer + 0x18) != (long long *)0x0) {
    (**(code **)(**(long long **)(ResourceManagerPointer + 0x18) + 0x38))();
  }
  return;
}




// 函数: void FUN_18007f6a0(char *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FUN_18007f6a0(char *ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long nextDataIndex;
  long long *resourcePoolPointer;
  long long *plocalResourceOffset;
  long long bufferBaseAddress;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
  if (nextDataIndex != 0) {
    resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x18);
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
    }
    plocalResourceOffset = *(long long **)(nextDataIndex + 0x210);
    *(long long **)(nextDataIndex + 0x210) = resourcePoolPointer;
    if (plocalResourceOffset != (long long *)0x0) {
      (**(code **)(*plocalResourceOffset + 0x38))();
    }
    nextDataIndex = *(long long *)(ResourceManagerPointer + 8);
    if (*ResourceManagerPointer != '\0') {
      bufferBaseAddress = nextDataIndex;
      if ((ResourceManagerPointer[0x10] & 2U) == 0) {
        FUN_180079520(nextDataIndex);
        FUN_180079520(*(void* *)(ResourceManagerPointer + 8));
        bufferBaseAddress = *(long long *)(ResourceManagerPointer + 8);
      }
      FUN_18007edd0(bufferBaseAddress,1,AdditionalParameter,ConfigurationFlag,currentThreadId);
      *(uint32_t *)(nextDataIndex + 0xf0) = 0;
      LOCK();
      *(uint8_t *)(nextDataIndex + 0xec) = 0;
      UNLOCK();
    }
  }
  ResourceManagerPointer[8] = '\0';
  ResourceManagerPointer[9] = '\0';
  ResourceManagerPointer[10] = '\0';
  ResourceManagerPointer[0xb] = '\0';
  ResourceManagerPointer[0xc] = '\0';
  ResourceManagerPointer[0xd] = '\0';
  ResourceManagerPointer[0xe] = '\0';
  ResourceManagerPointer[0xf] = '\0';
  resourcePoolPointer = *(long long **)(ResourceManagerPointer + 0x18);
  ResourceManagerPointer[0x18] = '\0';
  ResourceManagerPointer[0x19] = '\0';
  ResourceManagerPointer[0x1a] = '\0';
  ResourceManagerPointer[0x1b] = '\0';
  ResourceManagerPointer[0x1c] = '\0';
  ResourceManagerPointer[0x1d] = '\0';
  ResourceManagerPointer[0x1e] = '\0';
  ResourceManagerPointer[0x1f] = '\0';
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  return;
}




/**
 * @brief 初始化系统线程同步器
 * 
 * 该函数负责初始化系统线程同步器，设置线程同步所需的锁和计数器。
 * 主要用于系统线程的同步和管理工作。
 * 
 * @param ResourceManagerPointer 系统资源指针，指向线程同步器数据结构
 * 
 * 原始函数名为FUN_18007f770，现已重命名为InitializeSystemThreadSynchronizer
 */
void InitializeSystemThreadSynchronizer(long long *ResourceManagerPointer)

{
  long long nextDataIndex;
  char validationStatusFlag;
  int MemoryComparisonResult;
  bool isResourceAvailable;
  
  nextDataIndex = *ResourceManagerPointer;
  systemCounter = _Thrd_id();
  while( true ) {
    LOCK();
    charResult = *(char *)(nextDataIndex + 0xec);
    isResourceAvailable = charResult == '\0';
    if (isResourceAvailable) {
      *(char *)(nextDataIndex + 0xec) = '\x01';
      validationStatusFlag = '\0';
    }
    UNLOCK();
    if (isResourceAvailable) break;
    if (*(int *)(nextDataIndex + 0xf0) == systemCounter) goto LAB_18007f7cf;
    Sleep(0);
  }
  validationStatusFlag = '\0';
LAB_18007f7cf:
  LOCK();
  *(int *)(nextDataIndex + 0xe8) = *(int *)(nextDataIndex + 0xe8) + 1;
  UNLOCK();
  if ((*(uint *)(ResourceManagerPointer + 1) & 1) == 0) {
    FUN_18007eb80(*ResourceManagerPointer,(byte)(*(uint *)(ResourceManagerPointer + 1) >> 2) & 1);
  }
  if (validationStatusFlag == '\0') {
    LOCK();
    *(uint8_t *)(nextDataIndex + 0xec) = 0;
    UNLOCK();
  }
  ResourceManagerPointer[2] = *(long long *)(*ResourceManagerPointer + 0x210);
  return;
}




// 函数: void FUN_18007f820(void)
void FUN_18007f820(void)

{
  FUN_18007f840();
  return;
}




/**
 * @brief 系统资源句柄处理函数
 * 
 * 该函数负责处理系统资源句柄的操作，包括句柄的验证、索引和状态检查。
 * 它会遍历资源句柄数组，检查每个句柄的有效性，并进行相应的处理。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含资源句柄信息
 * 
 * 原始函数名为FUN_18007f840，现已重命名为ProcessSystemResourceHandle
 */
void ProcessSystemResourceHandle(long long *ResourceManagerPointer)

{
  int *ResourceIndexPointer;
  long long SystemHandle;
  char SystemStatus;
  int ResourceIndex;
  bool IsHandleAvailable;
  
  SystemHandle = *ResourceManagerPointer;
  if (SystemHandle != 0) {
    while( true ) {
      LOCK();
      SystemStatus = *(char *)(SystemHandle + 0xec);
      IsHandleAvailable = SystemStatus == '\0';
      if (IsHandleAvailable) {
        *(char *)(SystemHandle + 0xec) = '\x01';
        SystemStatus = '\0';
      }
      UNLOCK();
      if (IsHandleAvailable) break;
      ResourceIndex = _Thrd_id();
      if ((*(int *)(SystemHandle + 0xf0) == ResourceIndex) || (*(int *)(SystemHandle + 0xf0) != 0)) goto LAB_18007f89f;
      Sleep();
    }
    SystemStatus = '\0';
LAB_18007f89f:
    LOCK();
    ResourceIndexPointer = (int *)(SystemHandle + 0xe8);
    ResourceIndex = *ResourceIndexPointer;
    *ResourceIndexPointer = *ResourceIndexPointer + -1;
    UNLOCK();
    if (SystemStatus == '\0') {
      if (ResourceIndex == 1) {
        FUN_18007edd0(*ResourceManagerPointer,0);
      }
      LOCK();
      *(uint8_t *)(SystemHandle + 0xec) = 0;
      UNLOCK();
    }
    *ResourceManagerPointer = 0;
  }
  return;
}



uint FUN_18007f859(void)

{
  uint *pointerToUnsigned1;
  byte isSystemActive;
  char characterProcessingFlag;
  int systemIndex;
  uint currentThreadId;
  long long systemMemoryBlockPtr;
  void* *systemStringIteratorPtr;
  bool isThreadActive;
  
  while( true ) {
    LOCK();
    charFlag = *(char *)(systemMemoryBlockPtr + 0xec);
    isThreadActive = charFlag == '\0';
    if (isThreadActive) {
      *(char *)(systemMemoryBlockPtr + 0xec) = '\x01';
      charFlag = '\0';
    }
    UNLOCK();
    if (isThreadActive) break;
    systemIndex = _Thrd_id();
    if ((*(int *)(systemMemoryBlockPtr + 0xf0) == systemIndex) || (*(int *)(systemMemoryBlockPtr + 0xf0) != 0))
    goto LAB_18007f89f;
    Sleep();
  }
  charFlag = '\0';
LAB_18007f89f:
  LOCK();
  pointerToUnsigned1 = (uint *)(systemMemoryBlockPtr + 0xe8);
  currentThreadId = *pointerToUnsigned1;
  *pointerToUnsigned1 = *pointerToUnsigned1 - 1;
  UNLOCK();
  if (characterProcessingFlag == '\0') {
    if (currentThreadId == 1) {
      FUN_18007edd0(*systemStringIteratorPtr,0);
    }
    LOCK();
    isSystemActive = *(byte *)(systemMemoryBlockPtr + 0xec);
    *(byte *)(systemMemoryBlockPtr + 0xec) = 0;
    currentThreadId = (uint)isSystemActive;
    UNLOCK();
  }
  *systemStringIteratorPtr = 0;
  return currentThreadId;
}



uint8_t FUN_18007f8bb(void)

{
  uint8_t systemStatus;
  int in_EAX;
  long long systemMemoryBlockPtr;
  void* *systemStringIteratorPtr;
  
  if (in_EAX == 1) {
    FUN_18007edd0(*systemStringIteratorPtr,0);
  }
  LOCK();
  systemStatus = *(uint8_t *)(systemMemoryBlockPtr + 0xec);
  *(uint8_t *)(systemMemoryBlockPtr + 0xec) = 0;
  UNLOCK();
  *systemStringIteratorPtr = 0;
  return systemStatus;
}





// 函数: void FUN_18007f8f0(long long ResourceManagerPointer)
void FUN_18007f8f0(long long ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char systemStatusFlag;
  uint32_t currentThreadId;
  uint hashValue;
  long long *plocalDataIndex;
  long long localMemoryAddress;
  int systemId;
  int systemStatus0;
  long long nextDataIndex1;
  ulong long systemStatus2;
  char *systemFunctionPointer3;
  uint *pointerToUnsigned14;
  int systemStatus5;
  uint systemStatus6;
  int systemStatus7;
  int systemStatus8;
  uint32_t *pointerToUnsigned19;
  uint *HashEntryStatus0;
  ulong long creationFlags1;
  ulong long creationFlags2;
  bool isSystemActive3;
  
  if (*(int *)(ResourceManagerPointer + 0x28) != *(int *)(SystemStatusFlagsPointer + 0x224)) {
    systemStatus5 = *(int *)(ResourceManagerPointer + 0x1c) + *(int *)(ResourceManagerPointer + 0x18);
    *(int *)(ResourceManagerPointer + 0x28) = *(int *)(SystemStatusFlagsPointer + 0x224);
    if (0 < systemStatus5) {
      nextDataIndex1 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
      currentThreadId = FUN_180080380(nextDataIndex1,systemStatus5);
      *(uint32_t *)(ResourceManagerPointer + 0x30) = currentThreadId;
      FUN_1800802e0(nextDataIndex1,currentThreadId);
      if (*(long long *)(ResourceManagerPointer + 0x10) == 0) {
        if (*(int *)(ResourceManagerPointer + 0x18) != 0) {
          *(uint32_t *)(ResourceManagerPointer + 0x2c) = *(uint32_t *)(ResourceManagerPointer + 0x30);
          return;
        }
      }
      else {
        systemStatusFlag = *(char *)(ResourceManagerPointer + 0x44);
        systemStatus2 = (ulong long)systemStatusFlag;
        PrimaryResourcePointer = (long long *)(ResourceManagerPointer + 0x38);
        systemStatus5 = (int)systemStatusFlag;
        if (*(int *)(ResourceManagerPointer + 0x40) == (int)systemStatusFlag) {
          plocalDataIndex = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(ResourceManagerPointer + 0x40) = systemStatus5;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (systemStatusFlag == '\0') {
            plocalDataIndex = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)systemStatusFlag * 4);
            *PrimaryResourcePointer = (long long)plocalDataIndex;
          }
        }
        if (plocalDataIndex != (long long *)0x0) {
          systemStatus7 = 0;
          systemStatus6 = (uint)systemStatusFlag;
          systemStatus8 = systemStatus7;
          if ((0 < systemStatus5) && (0xf < systemStatus6)) {
            systemStatus0 = *(int *)(ResourceManagerPointer + 0x2c);
            resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(systemStatusFlag + -1) * 4);
            if ((((long long *)(ResourceManagerPointer + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(ResourceManagerPointer + 0x2c)))
               && ((PrimaryResourcePointer < plocalDataIndex || (systemStatus8 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              hashValue = systemStatus6 & 0x8000000f;
              if ((int)hashValue < 0) {
                hashValue = (hashValue - 1 | 0xfffffff0) + 1;
              }
              plocalDataIndex = plocalDataIndex + 4;
              systemId = 8;
              do {
                *(int *)(plocalDataIndex + -4) = systemStatus7 + systemStatus0;
                *(int *)((long long)plocalDataIndex + -0x1c) = systemStatus7 + 1 + systemStatus0;
                *(int *)(plocalDataIndex + -3) = systemStatus7 + 2 + systemStatus0;
                *(int *)((long long)plocalDataIndex + -0x14) = systemStatus7 + 3 + systemStatus0;
                systemStatus7 = systemStatus7 + 0x10;
                *(int *)(plocalDataIndex + -2) = systemId + -4 + systemStatus0;
                *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + systemStatus0;
                *(int *)(plocalDataIndex + -1) = systemId + -2 + systemStatus0;
                *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + systemStatus0;
                *(int *)plocalDataIndex = systemId + systemStatus0;
                *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + systemStatus0;
                *(int *)(plocalDataIndex + 1) = systemId + 2 + systemStatus0;
                *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + systemStatus0;
                *(int *)(plocalDataIndex + 2) = systemId + 4 + systemStatus0;
                *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + systemStatus0;
                *(int *)(plocalDataIndex + 3) = systemId + 6 + systemStatus0;
                *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + systemStatus0;
                plocalDataIndex = plocalDataIndex + 8;
                systemId = systemId + 0x10;
                systemStatus8 = systemStatus7;
              } while (systemStatus7 < (int)(systemStatus6 - hashValue));
            }
          }
          for (nextDataIndex1 = (long long)systemStatus8; nextDataIndex1 < (long long)systemStatus2; nextDataIndex1 = nextDataIndex1 + 1) {
            systemStatus7 = *(int *)(ResourceManagerPointer + 0x2c) + systemStatus8;
            systemStatus8 = systemStatus8 + 1;
            *(int *)(*PrimaryResourcePointer + nextDataIndex1 * 4) = systemStatus7;
          }
          systemStatus8 = *(int *)(ResourceManagerPointer + 0x18);
          systemStatus7 = 0;
          if (0 < (long long)systemStatus8) {
            nextDataIndex1 = 0;
            do {
              systemStatus0 = *(int *)(ResourceManagerPointer + 0x30) + systemStatus7;
              systemStatus7 = systemStatus7 + 1;
              pisOperationComplete = (byte *)(*(long long *)(ResourceManagerPointer + 0x10) + nextDataIndex1);
              nextDataIndex1 = nextDataIndex1 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemStatus0;
            } while (nextDataIndex1 < systemStatus8);
          }
        }
        pointerToUnsigned14 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 +
                          SystemMemoryContext + 0x9d0);
        if (systemStatus5 == 0) {
          systemStatus6 = (int)systemStatusFlag - 1;
        }
        else {
          LOCK();
          systemStatus6 = *pointerToUnsigned14;
          *pointerToUnsigned14 = *pointerToUnsigned14 + (int)systemStatusFlag;
          UNLOCK();
          creationFlags1 = (ulong long)(systemStatus6 >> 0xb);
          creationFlags2 = (ulong long)(systemStatusFlag + -1 + systemStatus6 >> 0xb);
          if (creationFlags1 <= creationFlags2) {
            systemFunctionPointer3 = (char *)((long long)pointerToUnsigned14 + creationFlags1 + 0x108);
            nextDataIndex1 = (creationFlags2 - creationFlags1) + 1;
            HashEntryStatus0 = pointerToUnsigned14 + creationFlags1 * 2 + 2;
            do {
              systemStatus8 = (int)creationFlags1;
              if (*(long long *)HashEntryStatus0 == 0) {
                localMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isSystemActive3 = *(long long *)(pointerToUnsigned14 + (long long)systemStatus8 * 2 + 2) == 0;
                if (isSystemActive3) {
                  *(long long *)(pointerToUnsigned14 + (long long)systemStatus8 * 2 + 2) = localMemoryAddress;
                }
                UNLOCK();
                if (isSystemActive3) {
                  LOCK();
                  *(uint8_t *)((long long)systemStatus8 + 0x108 + (long long)pointerToUnsigned14) = 0;
                  UNLOCK();
                }
                else {
                  if (localMemoryAddress != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*systemFunctionPointer3 != '\0');
                }
              }
              else {
                do {
                } while (*systemFunctionPointer3 != '\0');
              }
              creationFlags1 = (ulong long)(systemStatus8 + 1);
              HashEntryStatus0 = HashEntryStatus0 + 2;
              systemFunctionPointer3 = systemFunctionPointer3 + 1;
              nextDataIndex1 = nextDataIndex1 + -1;
            } while (nextDataIndex1 != 0);
          }
        }
        pointerToUnsigned19 = *(uint32_t **)(ResourceManagerPointer + 0x38);
        hashValue = systemStatus6 >> 0xb;
        *(uint *)(ResourceManagerPointer + 0x2c) = systemStatus6;
        if (hashValue == (int)systemStatusFlag + systemStatus6 >> 0xb) {
            memcpy(*(long long *)(pointerToUnsigned14 + (ulong long)hashValue * 2 + 2) +
                 (ulong long)(systemStatus6 + hashValue * -0x800) * 4,pointerToUnsigned19,(systemStatus2 & 0xffffffff) << 2);
        }
        if (systemStatus5 != 0) {
          systemStatus2 = systemStatus2 & 0xffffffff;
          do {
            currentThreadId = *pointerToUnsigned19;
            pointerToUnsigned19 = pointerToUnsigned19 + 1;
            *(uint32_t *)
             (*(long long *)(pointerToUnsigned14 + (ulong long)(systemStatus6 >> 0xb) * 2 + 2) +
             (ulong long)(systemStatus6 + (systemStatus6 >> 0xb) * -0x800) * 4) = currentThreadId;
            systemStatus2 = systemStatus2 - 1;
            systemStatus6 = systemStatus6 + 1;
          } while (systemStatus2 != 0);
        }
      }
    }
  }
  return;
}





// 函数: void FUN_18007f90f(uint32_t ResourceManagerPointer)
void FUN_18007f90f(uint32_t ResourceManagerPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char systemStatusFlag;
  uint32_t currentThreadId;
  uint hashValue;
  long long *plocalDataIndex;
  long long localMemoryAddress;
  int systemId;
  int systemStatus0;
  long long nextDataIndex1;
  ulong long systemStatus2;
  char *systemFunctionPointer3;
  uint *pointerToUnsigned14;
  int systemStatus5;
  uint systemStatus6;
  long long systemDataIndexPtr;
  int systemStatus7;
  int systemStatus8;
  uint32_t *pointerToUnsigned19;
  uint *HashEntryStatus0;
  ulong long creationFlags1;
  ulong long creationFlags2;
  bool isSystemActive3;
  
  systemStatus5 = *(int *)(systemDataIndexPtr + 0x1c) + *(int *)(systemDataIndexPtr + 0x18);
  *(uint32_t *)(systemDataIndexPtr + 0x28) = ResourceManagerPointer;
  if (0 < systemStatus5) {
    nextDataIndex1 = (long long)*(int *)(SystemMemoryContext + 0xe78) * 0x128 + SystemMemoryContext + 0xc28;
    currentThreadId = FUN_180080380(nextDataIndex1,systemStatus5);
    *(uint32_t *)(systemDataIndexPtr + 0x30) = currentThreadId;
    FUN_1800802e0(nextDataIndex1,currentThreadId);
    if (*(long long *)(systemDataIndexPtr + 0x10) == 0) {
      if (*(int *)(systemDataIndexPtr + 0x18) != 0) {
        *(uint32_t *)(systemDataIndexPtr + 0x2c) = *(uint32_t *)(systemDataIndexPtr + 0x30);
        return;
      }
    }
    else {
      systemStatusFlag = *(char *)(systemDataIndexPtr + 0x44);
      systemStatus2 = (ulong long)systemStatusFlag;
      PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
      systemStatus5 = (int)systemStatusFlag;
      if (*(int *)(systemDataIndexPtr + 0x40) == (int)systemStatusFlag) {
        plocalDataIndex = (long long *)*PrimaryResourcePointer;
      }
      else {
        *(int *)(systemDataIndexPtr + 0x40) = systemStatus5;
        if (*PrimaryResourcePointer != 0) {
            SystemCleanupFunction();
        }
        *PrimaryResourcePointer = 0;
        if (systemStatusFlag == '\0') {
          plocalDataIndex = (long long *)0x0;
          *PrimaryResourcePointer = 0;
        }
        else {
          plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)systemStatusFlag * 4);
          *PrimaryResourcePointer = (long long)plocalDataIndex;
        }
      }
      if (plocalDataIndex != (long long *)0x0) {
        systemStatus7 = 0;
        systemStatus6 = (uint)systemStatusFlag;
        systemStatus8 = systemStatus7;
        if ((0 < systemStatus5) && (0xf < systemStatus6)) {
          systemStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
          resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(systemStatusFlag + -1) * 4);
          if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) ||
              (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c))) &&
             ((PrimaryResourcePointer < plocalDataIndex || (systemStatus8 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
            hashValue = systemStatus6 & 0x8000000f;
            if ((int)hashValue < 0) {
              hashValue = (hashValue - 1 | 0xfffffff0) + 1;
            }
            plocalDataIndex = plocalDataIndex + 4;
            systemId = 8;
            do {
              *(int *)(plocalDataIndex + -4) = systemStatus7 + systemStatus0;
              *(int *)((long long)plocalDataIndex + -0x1c) = systemStatus7 + 1 + systemStatus0;
              *(int *)(plocalDataIndex + -3) = systemStatus7 + 2 + systemStatus0;
              *(int *)((long long)plocalDataIndex + -0x14) = systemStatus7 + 3 + systemStatus0;
              systemStatus7 = systemStatus7 + 0x10;
              *(int *)(plocalDataIndex + -2) = systemId + -4 + systemStatus0;
              *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + systemStatus0;
              *(int *)(plocalDataIndex + -1) = systemId + -2 + systemStatus0;
              *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + systemStatus0;
              *(int *)plocalDataIndex = systemId + systemStatus0;
              *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + systemStatus0;
              *(int *)(plocalDataIndex + 1) = systemId + 2 + systemStatus0;
              *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + systemStatus0;
              *(int *)(plocalDataIndex + 2) = systemId + 4 + systemStatus0;
              *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + systemStatus0;
              *(int *)(plocalDataIndex + 3) = systemId + 6 + systemStatus0;
              *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + systemStatus0;
              plocalDataIndex = plocalDataIndex + 8;
              systemId = systemId + 0x10;
              systemStatus8 = systemStatus7;
            } while (systemStatus7 < (int)(systemStatus6 - hashValue));
          }
        }
        for (nextDataIndex1 = (long long)systemStatus8; nextDataIndex1 < (long long)systemStatus2; nextDataIndex1 = nextDataIndex1 + 1) {
          systemStatus7 = *(int *)(systemDataIndexPtr + 0x2c) + systemStatus8;
          systemStatus8 = systemStatus8 + 1;
          *(int *)(*PrimaryResourcePointer + nextDataIndex1 * 4) = systemStatus7;
        }
        systemStatus8 = *(int *)(systemDataIndexPtr + 0x18);
        systemStatus7 = 0;
        if (0 < (long long)systemStatus8) {
          nextDataIndex1 = 0;
          do {
            systemStatus0 = *(int *)(systemDataIndexPtr + 0x30) + systemStatus7;
            systemStatus7 = systemStatus7 + 1;
            pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + nextDataIndex1);
            nextDataIndex1 = nextDataIndex1 + 1;
            *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemStatus0;
          } while (nextDataIndex1 < systemStatus8);
        }
      }
      pointerToUnsigned14 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 + SystemMemoryContext + 0x9d0
                        );
      if (systemStatus5 == 0) {
        systemStatus6 = (int)systemStatusFlag - 1;
      }
      else {
        LOCK();
        systemStatus6 = *pointerToUnsigned14;
        *pointerToUnsigned14 = *pointerToUnsigned14 + (int)systemStatusFlag;
        UNLOCK();
        creationFlags1 = (ulong long)(systemStatus6 >> 0xb);
        creationFlags2 = (ulong long)(systemStatusFlag + -1 + systemStatus6 >> 0xb);
        if (creationFlags1 <= creationFlags2) {
          systemFunctionPointer3 = (char *)((long long)pointerToUnsigned14 + creationFlags1 + 0x108);
          nextDataIndex1 = (creationFlags2 - creationFlags1) + 1;
          HashEntryStatus0 = pointerToUnsigned14 + creationFlags1 * 2 + 2;
          do {
            systemStatus8 = (int)creationFlags1;
            if (*(long long *)HashEntryStatus0 == 0) {
              localMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
              LOCK();
              isSystemActive3 = *(long long *)(pointerToUnsigned14 + (long long)systemStatus8 * 2 + 2) == 0;
              if (isSystemActive3) {
                *(long long *)(pointerToUnsigned14 + (long long)systemStatus8 * 2 + 2) = localMemoryAddress;
              }
              UNLOCK();
              if (isSystemActive3) {
                LOCK();
                *(uint8_t *)((long long)systemStatus8 + 0x108 + (long long)pointerToUnsigned14) = 0;
                UNLOCK();
              }
              else {
                if (localMemoryAddress != 0) {
                    SystemCleanupFunction();
                }
                do {
                } while (*systemFunctionPointer3 != '\0');
              }
            }
            else {
              do {
              } while (*systemFunctionPointer3 != '\0');
            }
            creationFlags1 = (ulong long)(systemStatus8 + 1);
            HashEntryStatus0 = HashEntryStatus0 + 2;
            systemFunctionPointer3 = systemFunctionPointer3 + 1;
            nextDataIndex1 = nextDataIndex1 + -1;
          } while (nextDataIndex1 != 0);
        }
      }
      pointerToUnsigned19 = *(uint32_t **)(systemDataIndexPtr + 0x38);
      hashValue = systemStatus6 >> 0xb;
      *(uint *)(systemDataIndexPtr + 0x2c) = systemStatus6;
      if (hashValue == (int)systemStatusFlag + systemStatus6 >> 0xb) {
          memcpy(*(long long *)(pointerToUnsigned14 + (ulong long)hashValue * 2 + 2) +
               (ulong long)(systemStatus6 + hashValue * -0x800) * 4,pointerToUnsigned19,(systemStatus2 & 0xffffffff) << 2);
      }
      if (systemStatus5 != 0) {
        systemStatus2 = systemStatus2 & 0xffffffff;
        do {
          currentThreadId = *pointerToUnsigned19;
          pointerToUnsigned19 = pointerToUnsigned19 + 1;
          *(uint32_t *)
           (*(long long *)(pointerToUnsigned14 + (ulong long)(systemStatus6 >> 0xb) * 2 + 2) +
           (ulong long)(systemStatus6 + (systemStatus6 >> 0xb) * -0x800) * 4) = currentThreadId;
          systemStatus2 = systemStatus2 - 1;
          systemStatus6 = systemStatus6 + 1;
        } while (systemStatus2 != 0);
      }
    }
  }
  return;
}





// 函数: void FUN_18007f933(void* ResourceManagerPointer,long long ConfigurationDataPointer)
void FUN_18007f933(void* ResourceManagerPointer,long long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char systemStatusFlag;
  uint32_t currentThreadId;
  uint hashValue;
  long long *plocalDataIndex;
  long long localMemoryAddress;
  int systemId;
  int systemStatus0;
  long long nextDataIndex1;
  ulong long systemStatus2;
  char *systemFunctionPointer3;
  uint *pointerToUnsigned14;
  uint32_t unaff_ESI;
  uint systemStatus5;
  long long systemDataIndexPtr;
  int systemStatus6;
  int systemStatus7;
  uint32_t *pointerToUnsigned18;
  int systemStatus9;
  uint *HashEntryStatus0;
  ulong long creationFlags1;
  ulong long creationFlags2;
  bool isSystemActive3;
  
  ConfigurationDataPointer = (long long)*(int *)(ConfigurationDataPointer + 0x250) * 0x128 + ConfigurationDataPointer;
  currentThreadId = FUN_180080380(ConfigurationDataPointer,unaff_ESI);
  *(uint32_t *)(systemDataIndexPtr + 0x30) = currentThreadId;
  FUN_1800802e0(ConfigurationDataPointer,currentThreadId);
  if (*(long long *)(systemDataIndexPtr + 0x10) == 0) {
    if (*(int *)(systemDataIndexPtr + 0x18) != 0) {
      *(uint32_t *)(systemDataIndexPtr + 0x2c) = *(uint32_t *)(systemDataIndexPtr + 0x30);
      return;
    }
  }
  else {
    systemStatusFlag = *(char *)(systemDataIndexPtr + 0x44);
    systemStatus2 = (ulong long)systemStatusFlag;
    PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
    systemStatus9 = (int)systemStatusFlag;
    if (*(int *)(systemDataIndexPtr + 0x40) == (int)systemStatusFlag) {
      plocalDataIndex = (long long *)*PrimaryResourcePointer;
    }
    else {
      *(int *)(systemDataIndexPtr + 0x40) = systemStatus9;
      if (*PrimaryResourcePointer != 0) {
          SystemCleanupFunction();
      }
      *PrimaryResourcePointer = 0;
      if (systemStatusFlag == '\0') {
        plocalDataIndex = (long long *)0x0;
        *PrimaryResourcePointer = 0;
      }
      else {
        plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)systemStatusFlag * 4);
        *PrimaryResourcePointer = (long long)plocalDataIndex;
      }
    }
    if (plocalDataIndex != (long long *)0x0) {
      systemStatus6 = 0;
      systemStatus5 = (uint)systemStatusFlag;
      systemStatus7 = systemStatus6;
      if ((0 < systemStatus9) && (0xf < systemStatus5)) {
        systemStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
        resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(systemStatusFlag + -1) * 4);
        if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c)))
           && ((PrimaryResourcePointer < plocalDataIndex || (systemStatus7 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
          hashValue = systemStatus5 & 0x8000000f;
          if ((int)hashValue < 0) {
            hashValue = (hashValue - 1 | 0xfffffff0) + 1;
          }
          plocalDataIndex = plocalDataIndex + 4;
          systemId = 8;
          do {
            *(int *)(plocalDataIndex + -4) = systemStatus6 + systemStatus0;
            *(int *)((long long)plocalDataIndex + -0x1c) = systemStatus6 + 1 + systemStatus0;
            *(int *)(plocalDataIndex + -3) = systemStatus6 + 2 + systemStatus0;
            *(int *)((long long)plocalDataIndex + -0x14) = systemStatus6 + 3 + systemStatus0;
            systemStatus6 = systemStatus6 + 0x10;
            *(int *)(plocalDataIndex + -2) = systemId + -4 + systemStatus0;
            *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + systemStatus0;
            *(int *)(plocalDataIndex + -1) = systemId + -2 + systemStatus0;
            *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + systemStatus0;
            *(int *)plocalDataIndex = systemId + systemStatus0;
            *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + systemStatus0;
            *(int *)(plocalDataIndex + 1) = systemId + 2 + systemStatus0;
            *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + systemStatus0;
            *(int *)(plocalDataIndex + 2) = systemId + 4 + systemStatus0;
            *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + systemStatus0;
            *(int *)(plocalDataIndex + 3) = systemId + 6 + systemStatus0;
            *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + systemStatus0;
            plocalDataIndex = plocalDataIndex + 8;
            systemId = systemId + 0x10;
            systemStatus7 = systemStatus6;
          } while (systemStatus6 < (int)(systemStatus5 - hashValue));
        }
      }
      for (nextDataIndex1 = (long long)systemStatus7; nextDataIndex1 < (long long)systemStatus2; nextDataIndex1 = nextDataIndex1 + 1) {
        systemStatus6 = *(int *)(systemDataIndexPtr + 0x2c) + systemStatus7;
        systemStatus7 = systemStatus7 + 1;
        *(int *)(*PrimaryResourcePointer + nextDataIndex1 * 4) = systemStatus6;
      }
      systemStatus7 = *(int *)(systemDataIndexPtr + 0x18);
      systemStatus6 = 0;
      if (0 < (long long)systemStatus7) {
        nextDataIndex1 = 0;
        do {
          systemStatus0 = *(int *)(systemDataIndexPtr + 0x30) + systemStatus6;
          systemStatus6 = systemStatus6 + 1;
          pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + nextDataIndex1);
          nextDataIndex1 = nextDataIndex1 + 1;
          *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemStatus0;
        } while (nextDataIndex1 < systemStatus7);
      }
    }
    pointerToUnsigned14 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 + SystemMemoryContext + 0x9d0);
    if (systemStatus9 == 0) {
      systemStatus5 = (int)systemStatusFlag - 1;
    }
    else {
      LOCK();
      systemStatus5 = *pointerToUnsigned14;
      *pointerToUnsigned14 = *pointerToUnsigned14 + (int)systemStatusFlag;
      UNLOCK();
      creationFlags1 = (ulong long)(systemStatus5 >> 0xb);
      creationFlags2 = (ulong long)(systemStatusFlag + -1 + systemStatus5 >> 0xb);
      if (creationFlags1 <= creationFlags2) {
        systemFunctionPointer3 = (char *)((long long)pointerToUnsigned14 + creationFlags1 + 0x108);
        nextDataIndex1 = (creationFlags2 - creationFlags1) + 1;
        HashEntryStatus0 = pointerToUnsigned14 + creationFlags1 * 2 + 2;
        do {
          systemStatus7 = (int)creationFlags1;
          if (*(long long *)HashEntryStatus0 == 0) {
            localMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
            LOCK();
            isSystemActive3 = *(long long *)(pointerToUnsigned14 + (long long)systemStatus7 * 2 + 2) == 0;
            if (isSystemActive3) {
              *(long long *)(pointerToUnsigned14 + (long long)systemStatus7 * 2 + 2) = localMemoryAddress;
            }
            UNLOCK();
            if (isSystemActive3) {
              LOCK();
              *(uint8_t *)((long long)systemStatus7 + 0x108 + (long long)pointerToUnsigned14) = 0;
              UNLOCK();
            }
            else {
              if (localMemoryAddress != 0) {
                  SystemCleanupFunction();
              }
              do {
              } while (*systemFunctionPointer3 != '\0');
            }
          }
          else {
            do {
            } while (*systemFunctionPointer3 != '\0');
          }
          creationFlags1 = (ulong long)(systemStatus7 + 1);
          HashEntryStatus0 = HashEntryStatus0 + 2;
          systemFunctionPointer3 = systemFunctionPointer3 + 1;
          nextDataIndex1 = nextDataIndex1 + -1;
        } while (nextDataIndex1 != 0);
      }
    }
    pointerToUnsigned18 = *(uint32_t **)(systemDataIndexPtr + 0x38);
    hashValue = systemStatus5 >> 0xb;
    *(uint *)(systemDataIndexPtr + 0x2c) = systemStatus5;
    if (hashValue == (int)systemStatusFlag + systemStatus5 >> 0xb) {
        memcpy(*(long long *)(pointerToUnsigned14 + (ulong long)hashValue * 2 + 2) +
             (ulong long)(systemStatus5 + hashValue * -0x800) * 4,pointerToUnsigned18,(systemStatus2 & 0xffffffff) << 2);
    }
    if (systemStatus9 != 0) {
      systemStatus2 = systemStatus2 & 0xffffffff;
      do {
        currentThreadId = *pointerToUnsigned18;
        pointerToUnsigned18 = pointerToUnsigned18 + 1;
        *(uint32_t *)
         (*(long long *)(pointerToUnsigned14 + (ulong long)(systemStatus5 >> 0xb) * 2 + 2) +
         (ulong long)(systemStatus5 + (systemStatus5 >> 0xb) * -0x800) * 4) = currentThreadId;
        systemStatus2 = systemStatus2 - 1;
        systemStatus5 = systemStatus5 + 1;
      } while (systemStatus2 != 0);
    }
  }
  return;
}





// 函数: void FUN_18007f976(void)
void FUN_18007f976(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  uint32_t unsignedSystemValue4;
  uint currentThreadId;
  uint hashValue;
  long long *plocalDataIndex;
  long long localMemoryAddress;
  int systemId;
  int systemStatus0;
  long long nextDataIndex1;
  uint systemStatus2;
  ulong long systemMemoryBlockPtr;
  char *systemFunctionPointer3;
  uint *pointerToUnsigned14;
  long long systemDataIndexPtr;
  int systemStatus5;
  int systemStatus6;
  uint32_t *pointerToUnsigned17;
  ulong long systemStatus8;
  uint *pointerToUnsigned19;
  ulong long creationFlags0;
  bool isSystemActive1;
  
  PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
  systemStatus2 = (uint)systemMemoryBlockPtr;
  if (*(uint *)(systemDataIndexPtr + 0x40) == systemStatus2) {
    plocalDataIndex = (long long *)*PrimaryResourcePointer;
  }
  else {
    *(uint *)(systemDataIndexPtr + 0x40) = systemStatus2;
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
    *PrimaryResourcePointer = 0;
    if ((char)systemMemoryBlockPtr == '\0') {
      plocalDataIndex = (long long *)0x0;
      *PrimaryResourcePointer = 0;
    }
    else {
      plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)(char)systemMemoryBlockPtr * 4);
      *PrimaryResourcePointer = (long long)plocalDataIndex;
    }
  }
  if (plocalDataIndex != (long long *)0x0) {
    systemStatus5 = 0;
    systemStatus6 = systemStatus5;
    if ((0 < (int)systemStatus2) && (0xf < systemStatus2)) {
      systemStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
      resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(int)(systemStatus2 - 1) * 4);
      if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c)))
         && ((PrimaryResourcePointer < plocalDataIndex || (systemStatus6 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
        hashValue = systemStatus2 & 0x8000000f;
        if ((int)hashValue < 0) {
          hashValue = (hashValue - 1 | 0xfffffff0) + 1;
        }
        plocalDataIndex = plocalDataIndex + 4;
        systemId = 8;
        do {
          *(int *)(plocalDataIndex + -4) = systemStatus5 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -0x1c) = systemStatus5 + 1 + systemStatus0;
          *(int *)(plocalDataIndex + -3) = systemStatus5 + 2 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -0x14) = systemStatus5 + 3 + systemStatus0;
          systemStatus5 = systemStatus5 + 0x10;
          *(int *)(plocalDataIndex + -2) = systemId + -4 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + systemStatus0;
          *(int *)(plocalDataIndex + -1) = systemId + -2 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + systemStatus0;
          *(int *)plocalDataIndex = systemId + systemStatus0;
          *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + systemStatus0;
          *(int *)(plocalDataIndex + 1) = systemId + 2 + systemStatus0;
          *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + systemStatus0;
          *(int *)(plocalDataIndex + 2) = systemId + 4 + systemStatus0;
          *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + systemStatus0;
          *(int *)(plocalDataIndex + 3) = systemId + 6 + systemStatus0;
          *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + systemStatus0;
          plocalDataIndex = plocalDataIndex + 8;
          systemId = systemId + 0x10;
          systemStatus6 = systemStatus5;
        } while (systemStatus5 < (int)(systemStatus2 - hashValue));
      }
    }
    for (nextDataIndex1 = (long long)systemStatus6; nextDataIndex1 < (long long)systemMemoryBlockPtr; nextDataIndex1 = nextDataIndex1 + 1) {
      systemStatus5 = *(int *)(systemDataIndexPtr + 0x2c) + systemStatus6;
      systemStatus6 = systemStatus6 + 1;
      *(int *)(*PrimaryResourcePointer + nextDataIndex1 * 4) = systemStatus5;
    }
    systemStatus6 = *(int *)(systemDataIndexPtr + 0x18);
    systemStatus5 = 0;
    if (0 < (long long)systemStatus6) {
      nextDataIndex1 = 0;
      do {
        systemStatus0 = *(int *)(systemDataIndexPtr + 0x30) + systemStatus5;
        systemStatus5 = systemStatus5 + 1;
        pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + nextDataIndex1);
        nextDataIndex1 = nextDataIndex1 + 1;
        *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemStatus0;
      } while (nextDataIndex1 < systemStatus6);
    }
  }
  pointerToUnsigned14 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 + SystemMemoryContext + 0x9d0);
  if (systemStatus2 == 0) {
    hashValue = 0xffffffff;
  }
  else {
    LOCK();
    hashValue = *pointerToUnsigned14;
    *pointerToUnsigned14 = *pointerToUnsigned14 + systemStatus2;
    UNLOCK();
    systemStatus8 = (ulong long)(hashValue >> 0xb);
    creationFlags0 = (ulong long)((systemStatus2 - 1) + hashValue >> 0xb);
    if (systemStatus8 <= creationFlags0) {
      systemFunctionPointer3 = (char *)((long long)pointerToUnsigned14 + systemStatus8 + 0x108);
      nextDataIndex1 = (creationFlags0 - systemStatus8) + 1;
      pointerToUnsigned19 = pointerToUnsigned14 + systemStatus8 * 2 + 2;
      do {
        systemStatus6 = (int)systemStatus8;
        if (*(long long *)pointerToUnsigned19 == 0) {
          localMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
          LOCK();
          isSystemActive1 = *(long long *)(pointerToUnsigned14 + (long long)systemStatus6 * 2 + 2) == 0;
          if (isSystemActive1) {
            *(long long *)(pointerToUnsigned14 + (long long)systemStatus6 * 2 + 2) = localMemoryAddress;
          }
          UNLOCK();
          if (isSystemActive1) {
            LOCK();
            *(uint8_t *)((long long)systemStatus6 + 0x108 + (long long)pointerToUnsigned14) = 0;
            UNLOCK();
          }
          else {
            if (localMemoryAddress != 0) {
                SystemCleanupFunction();
            }
            do {
            } while (*systemFunctionPointer3 != '\0');
          }
        }
        else {
          do {
          } while (*systemFunctionPointer3 != '\0');
        }
        systemStatus8 = (ulong long)(systemStatus6 + 1);
        pointerToUnsigned19 = pointerToUnsigned19 + 2;
        systemFunctionPointer3 = systemFunctionPointer3 + 1;
        nextDataIndex1 = nextDataIndex1 + -1;
      } while (nextDataIndex1 != 0);
    }
  }
  pointerToUnsigned17 = *(uint32_t **)(systemDataIndexPtr + 0x38);
  currentThreadId = hashValue >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = hashValue;
  if (currentThreadId == systemStatus2 + hashValue >> 0xb) {
      memcpy(*(long long *)(pointerToUnsigned14 + (ulong long)currentThreadId * 2 + 2) +
           (ulong long)(hashValue + currentThreadId * -0x800) * 4,pointerToUnsigned17,(systemMemoryBlockPtr & 0xffffffff) << 2);
  }
  if (systemStatus2 != 0) {
    systemStatus8 = systemMemoryBlockPtr & 0xffffffff;
    do {
      unsignedSystemValue4 = *pointerToUnsigned17;
      pointerToUnsigned17 = pointerToUnsigned17 + 1;
      *(uint32_t *)
       (*(long long *)(pointerToUnsigned14 + (ulong long)(hashValue >> 0xb) * 2 + 2) +
       (ulong long)(hashValue + (hashValue >> 0xb) * -0x800) * 4) = unsignedSystemValue4;
      systemStatus8 = systemStatus8 - 1;
      hashValue = hashValue + 1;
    } while (systemStatus8 != 0);
  }
  return;
}





// 函数: void FUN_18007f983(void)
void FUN_18007f983(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  uint32_t unsignedSystemValue4;
  uint currentThreadId;
  uint hashValue;
  long long *plocalDataIndex;
  long long localMemoryAddress;
  int systemId;
  int systemStatus0;
  long long nextDataIndex1;
  int unaff_EBX;
  char *systemFunctionPointer2;
  uint *pointerToUnsigned13;
  long long systemDataIndexPtr;
  int systemStatus4;
  int systemStatus5;
  uint32_t *pointerToUnsigned16;
  ulong long systemStatus7;
  uint systemStatus8;
  ulong long systemAllocationOffset;
  uint *pointerToUnsigned19;
  ulong long creationFlags0;
  bool isSystemActive1;
  
  PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
  systemStatus8 = (uint)systemAllocationOffset;
  if (*(int *)(systemDataIndexPtr + 0x40) == unaff_EBX) {
    plocalDataIndex = (long long *)*PrimaryResourcePointer;
  }
  else {
    *(uint *)(systemDataIndexPtr + 0x40) = systemStatus8;
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
    *PrimaryResourcePointer = 0;
    if ((char)unaff_EBX == '\0') {
      plocalDataIndex = (long long *)0x0;
      *PrimaryResourcePointer = 0;
    }
    else {
      plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)(char)unaff_EBX * 4);
      *PrimaryResourcePointer = (long long)plocalDataIndex;
    }
  }
  if (plocalDataIndex != (long long *)0x0) {
    systemStatus4 = 0;
    systemStatus5 = systemStatus4;
    if ((0 < (int)systemStatus8) && (0xf < systemStatus8)) {
      systemStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
      resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(int)(systemStatus8 - 1) * 4);
      if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c)))
         && ((PrimaryResourcePointer < plocalDataIndex || (systemStatus5 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
        hashValue = systemStatus8 & 0x8000000f;
        if ((int)hashValue < 0) {
          hashValue = (hashValue - 1 | 0xfffffff0) + 1;
        }
        plocalDataIndex = plocalDataIndex + 4;
        systemId = 8;
        do {
          *(int *)(plocalDataIndex + -4) = systemStatus4 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -0x1c) = systemStatus4 + 1 + systemStatus0;
          *(int *)(plocalDataIndex + -3) = systemStatus4 + 2 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -0x14) = systemStatus4 + 3 + systemStatus0;
          systemStatus4 = systemStatus4 + 0x10;
          *(int *)(plocalDataIndex + -2) = systemId + -4 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + systemStatus0;
          *(int *)(plocalDataIndex + -1) = systemId + -2 + systemStatus0;
          *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + systemStatus0;
          *(int *)plocalDataIndex = systemId + systemStatus0;
          *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + systemStatus0;
          *(int *)(plocalDataIndex + 1) = systemId + 2 + systemStatus0;
          *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + systemStatus0;
          *(int *)(plocalDataIndex + 2) = systemId + 4 + systemStatus0;
          *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + systemStatus0;
          *(int *)(plocalDataIndex + 3) = systemId + 6 + systemStatus0;
          *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + systemStatus0;
          plocalDataIndex = plocalDataIndex + 8;
          systemId = systemId + 0x10;
          systemStatus5 = systemStatus4;
        } while (systemStatus4 < (int)(systemStatus8 - hashValue));
      }
    }
    for (nextDataIndex1 = (long long)systemStatus5; nextDataIndex1 < (long long)systemAllocationOffset; nextDataIndex1 = nextDataIndex1 + 1) {
      systemStatus4 = *(int *)(systemDataIndexPtr + 0x2c) + systemStatus5;
      systemStatus5 = systemStatus5 + 1;
      *(int *)(*PrimaryResourcePointer + nextDataIndex1 * 4) = systemStatus4;
    }
    systemStatus5 = *(int *)(systemDataIndexPtr + 0x18);
    systemStatus4 = 0;
    if (0 < (long long)systemStatus5) {
      nextDataIndex1 = 0;
      do {
        systemStatus0 = *(int *)(systemDataIndexPtr + 0x30) + systemStatus4;
        systemStatus4 = systemStatus4 + 1;
        pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + nextDataIndex1);
        nextDataIndex1 = nextDataIndex1 + 1;
        *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemStatus0;
      } while (nextDataIndex1 < systemStatus5);
    }
  }
  pointerToUnsigned13 = (uint *)((long long)*(int *)(SystemMemoryContext + 0xc20) * 0x128 + SystemMemoryContext + 0x9d0);
  if (systemStatus8 == 0) {
    hashValue = 0xffffffff;
  }
  else {
    LOCK();
    hashValue = *pointerToUnsigned13;
    *pointerToUnsigned13 = *pointerToUnsigned13 + systemStatus8;
    UNLOCK();
    systemStatus7 = (ulong long)(hashValue >> 0xb);
    creationFlags0 = (ulong long)((systemStatus8 - 1) + hashValue >> 0xb);
    if (systemStatus7 <= creationFlags0) {
      systemFunctionPointer2 = (char *)((long long)pointerToUnsigned13 + systemStatus7 + 0x108);
      nextDataIndex1 = (creationFlags0 - systemStatus7) + 1;
      pointerToUnsigned19 = pointerToUnsigned13 + systemStatus7 * 2 + 2;
      do {
        systemStatus5 = (int)systemStatus7;
        if (*(long long *)pointerToUnsigned19 == 0) {
          localMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
          LOCK();
          isSystemActive1 = *(long long *)(pointerToUnsigned13 + (long long)systemStatus5 * 2 + 2) == 0;
          if (isSystemActive1) {
            *(long long *)(pointerToUnsigned13 + (long long)systemStatus5 * 2 + 2) = localMemoryAddress;
          }
          UNLOCK();
          if (isSystemActive1) {
            LOCK();
            *(uint8_t *)((long long)systemStatus5 + 0x108 + (long long)pointerToUnsigned13) = 0;
            UNLOCK();
          }
          else {
            if (localMemoryAddress != 0) {
                SystemCleanupFunction();
            }
            do {
            } while (*systemFunctionPointer2 != '\0');
          }
        }
        else {
          do {
          } while (*systemFunctionPointer2 != '\0');
        }
        systemStatus7 = (ulong long)(systemStatus5 + 1);
        pointerToUnsigned19 = pointerToUnsigned19 + 2;
        systemFunctionPointer2 = systemFunctionPointer2 + 1;
        nextDataIndex1 = nextDataIndex1 + -1;
      } while (nextDataIndex1 != 0);
    }
  }
  pointerToUnsigned16 = *(uint32_t **)(systemDataIndexPtr + 0x38);
  currentThreadId = hashValue >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = hashValue;
  if (currentThreadId == systemStatus8 + hashValue >> 0xb) {
      memcpy(*(long long *)(pointerToUnsigned13 + (ulong long)currentThreadId * 2 + 2) +
           (ulong long)(hashValue + currentThreadId * -0x800) * 4,pointerToUnsigned16,(systemAllocationOffset & 0xffffffff) << 2);
  }
  if (systemStatus8 != 0) {
    systemStatus7 = systemAllocationOffset & 0xffffffff;
    do {
      unsignedSystemValue4 = *pointerToUnsigned16;
      pointerToUnsigned16 = pointerToUnsigned16 + 1;
      *(uint32_t *)
       (*(long long *)(pointerToUnsigned13 + (ulong long)(hashValue >> 0xb) * 2 + 2) +
       (ulong long)(hashValue + (hashValue >> 0xb) * -0x800) * 4) = unsignedSystemValue4;
      systemStatus7 = systemStatus7 - 1;
      hashValue = hashValue + 1;
    } while (systemStatus7 != 0);
  }
  return;
}





// 函数: void FUN_18007fb5f(void)
void FUN_18007fb5f(void)

{
  uint32_t systemStatus;
  long long localSystemHandle;
  uint allocationContext;
  char *psystemStatusFlag;
  uint *systemStackFramePtr;
  uint currentThreadId;
  long long systemDataIndexPtr;
  uint32_t *resourceEntryPointer;
  ulong long unsignedSystemValue7;
  uint systemAllocationOffsetD;
  void* *unaff_R13;
  uint *newThreadLocalStorage;
  int systemId;
  ulong long systemOperationFlags;
  long long nextDataIndex1;
  bool isByteValid2;
  
  LOCK();
  currentThreadId = *systemStackFramePtr;
  *systemStackFramePtr = *systemStackFramePtr + systemAllocationOffsetD;
  UNLOCK();
  unsignedSystemValue7 = (ulong long)(currentThreadId >> 0xb);
  systemOperationFlags = (ulong long)((systemAllocationOffsetD - 1) + currentThreadId >> 0xb);
  if (unsignedSystemValue7 <= systemOperationFlags) {
    psystemStatusFlag = (char *)((long long)systemStackFramePtr + unsignedSystemValue7 + 0x108);
    nextDataIndex1 = (systemOperationFlags - unsignedSystemValue7) + 1;
    newThreadLocalStorage = systemStackFramePtr + (ulong long)(currentThreadId >> 0xb) * 2 + 2;
    do {
      systemId = (int)unsignedSystemValue7;
      if (*(long long *)newThreadLocalStorage == 0) {
        localSystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
        LOCK();
        isByteValid2 = *(long long *)(systemStackFramePtr + (long long)systemId * 2 + 2) == 0;
        if (isByteValid2) {
          *(long long *)(systemStackFramePtr + (long long)systemId * 2 + 2) = localSystemHandle;
        }
        UNLOCK();
        if (isByteValid2) {
          LOCK();
          *(uint8_t *)((long long)systemId + 0x108 + (long long)systemStackFramePtr) = 0;
          UNLOCK();
        }
        else {
          if (localSystemHandle != 0) {
              SystemCleanupFunction();
          }
          do {
          } while (*psystemStatusFlag != '\0');
        }
      }
      else {
        do {
        } while (*psystemStatusFlag != '\0');
      }
      unsignedSystemValue7 = (ulong long)(systemId + 1);
      newThreadLocalStorage = newThreadLocalStorage + 2;
      psystemStatusFlag = psystemStatusFlag + 1;
      nextDataIndex1 = nextDataIndex1 + -1;
    } while (nextDataIndex1 != 0);
    unaff_R13 = (void* *)(systemDataIndexPtr + 0x38);
  }
  resourceEntryPointer = (uint32_t *)*unaff_R13;
  allocationContext = currentThreadId >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = currentThreadId;
  if (allocationContext != systemAllocationOffsetD + currentThreadId >> 0xb) {
    if (systemAllocationOffsetD != 0) {
      unsignedSystemValue7 = (ulong long)systemAllocationOffsetD;
      do {
        systemStatus = *resourceEntryPointer;
        resourceEntryPointer = resourceEntryPointer + 1;
        *(uint32_t *)
         (*(long long *)(systemStackFramePtr + (ulong long)(currentThreadId >> 0xb) * 2 + 2) +
         (ulong long)(currentThreadId + (currentThreadId >> 0xb) * -0x800) * 4) = systemStatus;
        unsignedSystemValue7 = unsignedSystemValue7 - 1;
        currentThreadId = currentThreadId + 1;
      } while (unsignedSystemValue7 != 0);
    }
    return;
  }
    memcpy(*(long long *)(systemStackFramePtr + (ulong long)allocationContext * 2 + 2) +
         (ulong long)(currentThreadId + allocationContext * -0x800) * 4,resourceEntryPointer,(ulong long)systemAllocationOffsetD << 2);
}




// 函数: void FUN_18007fc19(void)
void FUN_18007fc19(void)

{
  uint32_t systemStatus;
  uint creationFlags;
  long long systemStackFramePtr;
  uint unaff_ESI;
  long long systemDataIndexPtr;
  uint32_t *HashNodePointer;
  ulong long unsignedSystemValue4;
  uint systemAllocationOffsetD;
  void* *unaff_R13;
  
  HashNodePointer = (uint32_t *)*unaff_R13;
  creationFlags = unaff_ESI >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = unaff_ESI;
  if (creationFlags != systemAllocationOffsetD + unaff_ESI >> 0xb) {
    if (systemAllocationOffsetD != 0) {
      unsignedSystemValue4 = (ulong long)systemAllocationOffsetD;
      do {
        systemStatus = *HashNodePointer;
        HashNodePointer = HashNodePointer + 1;
        *(uint32_t *)
         (*(long long *)(systemStackFramePtr + 8 + (ulong long)(unaff_ESI >> 0xb) * 8) +
         (ulong long)(unaff_ESI + (unaff_ESI >> 0xb) * -0x800) * 4) = systemStatus;
        unsignedSystemValue4 = unsignedSystemValue4 - 1;
        unaff_ESI = unaff_ESI + 1;
      } while (unsignedSystemValue4 != 0);
    }
    return;
  }
    memcpy(*(long long *)(systemStackFramePtr + 8 + (ulong long)creationFlags * 8) +
         (ulong long)(unaff_ESI + creationFlags * -0x800) * 4,HashNodePointer,(ulong long)systemAllocationOffsetD << 2);
}




// 函数: void FUN_18007fc35(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FUN_18007fc35(long long ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long systemStackFramePtr;
  int unaff_ESI;
  uint systemAllocationOffsetD;
  
    memcpy(*(long long *)(systemStackFramePtr + 8 + ResourceManagerPointer * 8) +
         (ulong long)(uint)(unaff_ESI + (int)ResourceManagerPointer * -0x800) * 4,ConfigurationFlag,(ulong long)systemAllocationOffsetD << 2
        );
}




// 函数: void FUN_18007fc63(void)
void FUN_18007fc63(void)

{
  return;
}




// 函数: void FUN_18007fc68(void)
void FUN_18007fc68(void)

{
  return;
}




// 函数: void FUN_18007fc6d(void)
void FUN_18007fc6d(void)

{
  return;
}




// 函数: void InitializeSystemPreferences(void)
void InitializeSystemPreferences(void)

{
  uint32_t systemStatus;
  long long systemStackFramePtr;
  uint unaff_ESI;
  uint32_t *in_R9;
  ulong long creationFlags;
  uint systemAllocationOffsetD;
  
  if (systemAllocationOffsetD != 0) {
    creationFlags = (ulong long)systemAllocationOffsetD;
    do {
      systemStatus = *in_R9;
      in_R9 = in_R9 + 1;
      *(uint32_t *)
       (*(long long *)(systemStackFramePtr + 8 + (ulong long)(unaff_ESI >> 0xb) * 8) +
       (ulong long)(unaff_ESI + (unaff_ESI >> 0xb) * -0x800) * 4) = systemStatus;
      creationFlags = creationFlags - 1;
      unaff_ESI = unaff_ESI + 1;
    } while (creationFlags != 0);
  }
  return;
}




// 函数: void InitializePreferenceManager(void)
void InitializePreferenceManager(void)

{
  long long systemDataIndexPtr;
  
  if (*(int *)(systemDataIndexPtr + 0x18) != 0) {
    *(uint32_t *)(systemDataIndexPtr + 0x2c) = *(uint32_t *)(systemDataIndexPtr + 0x30);
    return;
  }
  return;
}





// 函数: void SystemInitializationFunction(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter)
void SystemInitializationFunction(void* ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter)

{
  void* systemStatus;
  long long *resourcePoolPointer;
  
  systemStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xf0,8,3,0xfffffffffffffffe);
  resourcePoolPointer = (long long *)FUN_18007f2f0(systemStatus);
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
  }
  FUN_18007e2b0(resourcePoolPointer,ResourceManagerPointer);
  FUN_18007e5b0(resourcePoolPointer,AdditionalParameter);
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))(resourcePoolPointer);
  }
  return;
}





/**
 * @brief 系统资源数据加密处理函数
 * 
 * 该函数负责处理系统资源数据的加密操作，包括配置数据的处理和加密密钥的应用。
 * 它会调用系统资源分配函数，并对资源数据进行加密处理。
 * 
 * @param ResourceManagerPointer 系统资源指针，包含需要处理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置参数和数据
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制处理流程
 * 
 * 原始函数名为FUN_18007fd60，现已重命名为ProcessSystemResourceDataWithEncryption
 */
void ProcessSystemResourceDataWithEncryption(void* ResourceManagerPointer,long long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  int systemResult;
  uint8_t EncryptionKeyBuffer [32];
  long long *ResourceHandlePointer;
  long long *ResourceArrayPointer [2];
  void* EncryptionFlag;
  ulong long EncryptedKey;
  
  EncryptionFlag = 0xfffffffffffffffe;
  EncryptedKey = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionKeyBuffer;
  *(long long *)(ConfigurationFlag + 8) = *(long long *)(ConfigurationFlag + 8) + 4;
  systemResult = *(int *)(ConfigurationDataPointer + 0x14) * *(int *)(ConfigurationDataPointer + 0x10);
  PrimaryResourcePointer = (long long *)FUN_180081590(ResourceManagerPointer,ResourceArrayPointer,systemResult);
  PrimaryResourcePointer = (long long *)*PrimaryResourcePointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    ResourceHandlePointer = PrimaryResourcePointer;
    (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
  }
  ResourceHandlePointer = *(long long **)(ConfigurationDataPointer + 0x20);
  *(long long **)(ConfigurationDataPointer + 0x20) = PrimaryResourcePointer;
  if (ResourceHandlePointer != (long long *)0x0) {
    (**(code **)(*ResourceHandlePointer + 0x38))();
  }
  if (ResourceArrayPointer[0] != (long long *)0x0) {
    (**(code **)(*ResourceArrayPointer[0] + 0x38))();
  }
    memcpy(*(void* *)(*(long long *)(ConfigurationDataPointer + 0x20) + 0x10),*(void* *)(ConfigurationFlag + 8),
         (long long)systemResult);
}





/**
 * @brief 初始化系统入口点
 * 
 * 该函数负责初始化系统的主要入口点
 * 设置系统上下文、入口点数据、内存池和初始化标志
 * 
 * @param systemContext 系统上下文，包含系统运行所需的环境信息
 * @param entryPointData 入口点数据，包含入口点初始化所需的参数
 * @param memoryPool 内存池，用于分配入口点所需的内存资源
 * @param InitializationFlags 初始化标志，控制初始化过程的选项
 */
void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* InitializationFlags);

/**
 * @brief 执行系统入口点
 * 
 * 该函数负责执行指定的系统入口点
 * 调用入口点函数并传递必要的参数
 * 
 * @param entryPointPtr 入口点指针，指向要执行的入口点函数
 */
void ExecuteSystemEntryPoint(void* *entryPointPtr);

// 函数: 系统初始化完成检查函数
void* SystemInitializationCompleteCheck;

// 函数: 系统配置验证函数
void* SystemConfigurationValidation;
uint32_t SystemStatusIndicator;
void* SystemInitializationFlag;
void* SystemConfigurationFlag;

/**
 * @brief 音频数据归一化处理函数
 * 
 * 该函数负责对音频数据进行归一化处理，包括：
 * - 计算音频数据的幅度
 * - 应用归一化系数
 * - 处理多通道音频数据
 * - 批量优化处理以提高性能
 * 
 * @return void* 返回处理结果指针
 * 
 * @note 这是音频处理系统的核心函数，用于音频数据的预处理
 */
void* NormalizeAudioData(void)

{
  float audioChannelSample1;
  float audioChannelSample2;
  float audioChannelSample3;
  float audioChannelSample4;
  float audioChannelSample5;
  float audioChannelSample6;
  float audioChannelSample7;
  float audioChannelSample8;
  uint audioBitMask;
  uint processedAudioBit;
  int audioProcessingLoop;
  float *audioBufferPointer;
  int audioNormalizationFactor;
  float *audioInputData;
  uint audioShiftRegister;
  int audioProcessingIndex;
  uint totalAudioChannels;
  uint currentAudioSample;
  int audioBitDepth;
  long long audioProcessingContext;
  uint audioThresholdFlag1;
  uint audioThresholdFlag2;
  float audioNormalizedValue;
  uint8_t audioCoefficientArray [16];
  float audioIntermediateResult;
  int audioWindowOffset1;
  float audioFilterCoeff1;
  int audioWindowOffset2;
  float audioFilterCoeff2;
  int audioWindowOffset3;
  float audioFilterCoeff3;
  int audioWindowOffset4;
  float audioFilterCoeff4;
  uint8_t audioInverseCoeffArray [16];
  float audioFilterResult;
  float audioAccumulatedSum1;
  float audioAccumulatedSum2;
  float audioAccumulatedSum3;
  float audioAccumulatedSum4;
  float audioWeightedSum1;
  float audioWeightedSum2;
  float audioWeightedSum3;
  float audioWeightedSum4;
  float audioMaxAmplitude;
  float audioChannelSum1;
  float audioChannelSum2;
  float audioChannelSum3;
  float audioChannelSum4;
  int audioWeightFactor1;
  int audioWeightFactor2;
  int audioWeightFactor3;
  int audioWeightFactor4;
  float *audioOutputBufferPtr;
  
  audioBufferPointer = audioInputData;
  do {
    processedAudioBit = 0;
    audioProcessingLoop = audioBitDepth;
    audioShiftRegister = currentAudioSample;
    if (audioBitDepth != 0) {
      do {
        audioBitMask = audioShiftRegister & 1;
        audioShiftRegister = audioShiftRegister >> 1;
        processedAudioBit = processedAudioBit * 2 | audioBitMask;
        audioProcessingLoop = audioProcessingLoop + -1;
      } while (audioProcessingLoop != 0);
    }
    currentAudioSample = currentAudioSample + 1;
    audioNormalizedValue = *(float *)(*(long long *)(audioProcessingContext + 0x218) + 4 + (long long)(int)processedAudioBit * 8);
    audioWeightedSum2 = *(float *)(*(long long *)(audioProcessingContext + 0x218) + (long long)(int)processedAudioBit * 8);
    audioNormalizedValue = SQRT(audioWeightedSum2 * audioWeightedSum2 + audioNormalizedValue * audioNormalizedValue) * 2.5;
    if (audioMaxAmplitude <= audioNormalizedValue) {
      audioNormalizedValue = audioMaxAmplitude;
    }
    *audioBufferPointer = audioNormalizedValue;
    audioBufferPointer = audioBufferPointer + 1;
  } while ((int)currentAudioSample < (int)totalAudioChannels);
  if (audioOutputBufferPtr != (float *)0x0) {
    audioProcessingIndex = 0;
    if (0 < (int)totalAudioChannels) {
      audioNormalizedValue = audioAccumulatedSum1;
      if (7 < totalAudioChannels) {
        audioShiftRegister = totalAudioChannels & 0x80000007;
        if ((int)audioShiftRegister < 0) {
          audioShiftRegister = (audioShiftRegister - 1 | 0xfffffff8) + 1;
        }
        audioInverseCoeffArray._0_4_ = audioWindowOffset1 + -1;
        audioInverseCoeffArray._4_4_ = audioWindowOffset2 + -1;
        audioInverseCoeffArray._8_4_ = audioWindowOffset3 + -1;
        audioInverseCoeffArray._12_4_ = audioWindowOffset4 + -1;
        audioCoefficientArray._0_4_ = (float)audioInverseCoeffArray._0_4_;
        audioCoefficientArray._4_4_ = (float)audioInverseCoeffArray._4_4_;
        audioCoefficientArray._8_4_ = (float)audioInverseCoeffArray._8_4_;
        audioCoefficientArray._12_4_ = (float)audioInverseCoeffArray._12_4_;
        audioInverseCoeffArray = rcpps(audioInverseCoeffArray,audioCoefficientArray);
        audioNormalizedValue = 0.0;
        audioWeightedSum2 = 0.0;
        audioWeightedSum3 = 0.0;
        audioIntermediateResult = 0.0;
        audioFilterCoeff1 = audioInverseCoeffArray._0_4_;
        audioFilterCoeff2 = audioInverseCoeffArray._4_4_;
        audioFilterCoeff3 = audioInverseCoeffArray._8_4_;
        audioFilterCoeff4 = audioInverseCoeffArray._12_4_;
        audioWeightedSum1 = 0.0;
        audioWeightedSum4 = 0.0;
        audioChannelSum1 = 0.0;
        audioChannelSum2 = 0.0;
        audioChannelSum3 = 0.0;
        audioChannelSum4 = 0.0;
        audioFilterResult = 0.0;
        audioAccumulatedSum1 = 0.0;
        audioAccumulatedSum2 = 0.0;
        audioAccumulatedSum3 = 0.0;
        audioAccumulatedSum4 = 0.0;
        audioFilterCoeff1 = (audioFilterCoeff1 + audioFilterCoeff1) - audioFilterCoeff1 * audioFilterCoeff1 * audioCoefficientArray._0_4_;
        audioFilterCoeff2 = (audioFilterCoeff2 + audioFilterCoeff2) - audioFilterCoeff2 * audioFilterCoeff2 * audioCoefficientArray._4_4_;
        audioFilterCoeff3 = (audioFilterCoeff3 + audioFilterCoeff3) - audioFilterCoeff3 * audioFilterCoeff3 * audioCoefficientArray._8_4_;
        audioFilterCoeff4 = (audioFilterCoeff4 + audioFilterCoeff4) - audioFilterCoeff4 * audioFilterCoeff4 * audioCoefficientArray._12_4_;
        audioBufferPointer = audioInputData;
        audioProcessingIndex = audioProcessingIndex;
        do {
          audioSampleValue1 = *audioDataPointer;
          audioSampleValue2 = audioDataPointer[1];
          audioSampleValue3 = audioDataPointer[2];
          audioSampleValue4 = audioDataPointer[3];
          audioProcessingFlags = -(uint)(0.0001 < audioSampleValue1);
          audioThresholdFlag9 = -(uint)(0.0001 < audioSampleValue2);
          audioThresholdFlag15 = -(uint)(0.0001 < audioSampleValue3);
          audioThresholdFlag16 = -(uint)(0.0001 < audioSampleValue4);
          audioStatusIndex1 = audioStatusIndex4 + 8;
          audioSampleValue5 = audioDataPointer[4];
          audioSampleValue6 = audioDataPointer[5];
          audioSampleValue7 = audioDataPointer[6];
          audioSampleValue8 = audioDataPointer[7];
          audioDataPointer = audioDataPointer + 8;
          audioWeightedResult17 = (float)((uint)((float)audioStatusIndex4 * (float)audioCoeffA * 0.5 * audioCoeff20 * audioSampleValue1 +
                                 audioWeightedResult17) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult17);
          audioWeightedResult29 = (float)((uint)((float)(audioStatusIndex4 + 1) * (float)audioCoeffB * 0.5 * audioCoeff22 * audioSampleValue2
                                 + audioWeightedResult29) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult29);
          audioWeightedResult31 = (float)((uint)((float)(audioStatusIndex4 + 2) * (float)audioCoeffC * 0.5 * audioCoeff23 * audioSampleValue3
                                 + audioWeightedResult31) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult31);
          audioWeightedResult19 = (float)((uint)((float)(audioStatusIndex4 + 3) * (float)audioCoeffD * 0.5 * audioCoeff24 * audioSampleValue4
                                 + audioWeightedResult19) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult19);
          audioWeightedResult25 = (float)((uint)(audioSampleValue1 + audioWeightedResult25) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult25);
          audioWeightedResult26 = (float)((uint)(audioSampleValue2 + audioWeightedResult26) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult26);
          audioWeightedResult27 = (float)((uint)(audioSampleValue3 + audioWeightedResult27) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult27);
          audioWeightedResult28 = (float)((uint)(audioSampleValue4 + audioWeightedResult28) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult28);
          audioProcessingFlags = -(uint)(0.0001 < audioSampleValue5);
          audioThresholdFlag9 = -(uint)(0.0001 < audioSampleValue6);
          audioThresholdFlag15 = -(uint)(0.0001 < audioSampleValue7);
          audioThresholdFlag16 = -(uint)(0.0001 < audioSampleValue8);
          audioWeightedResult30 = (float)((uint)((float)(audioStatusIndex4 + 4) * (float)audioCoeffA * 0.5 * audioCoeff20 * audioSampleValue5
                                 + audioWeightedResult30) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult30);
          audioWeightedResult32 = (float)((uint)((float)(audioStatusIndex4 + 5) * (float)audioCoeffB * 0.5 * audioCoeff22 * audioSampleValue6
                                 + audioWeightedResult32) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult32);
          audioWeightedResult33 = (float)((uint)((float)(audioStatusIndex4 + 6) * (float)audioCoeffC * 0.5 * audioCoeff23 * audioSampleValue7
                                 + audioWeightedResult33) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult33);
          audioWeightedResult34 = (float)((uint)((float)(audioStatusIndex4 + 7) * (float)audioCoeffD * 0.5 * audioCoeff24 * audioSampleValue8
                                 + audioWeightedResult34) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult34);
          audioWeightedResult35 = (float)((uint)(audioSampleValue5 + audioWeightedResult35) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult35);
          audioWeightedResult36 = (float)((uint)(audioSampleValue6 + audioWeightedResult36) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult36);
          audioWeightedResult37 = (float)((uint)(audioSampleValue7 + audioWeightedResult37) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult37);
          audioWeightedResult38 = (float)((uint)(audioSampleValue8 + audioWeightedResult38) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult38);
          audioStatusIndex4 = audioStatusIndex1;
        } while (audioStatusIndex1 < (int)(audioTotalChannels - audioThresholdFlag13));
        audioTotalSum = audioWeightedResult27 + audioWeightedResult37 + audioWeightedResult25 + audioWeightedResult35 + audioWeightedResult28 + audioWeightedResult38 + audioWeightedResult26 + audioWeightedResult36;
        audioWeightedResult17 = audioWeightedResult31 + audioWeightedResult33 + audioWeightedResult17 + audioWeightedResult30 + audioWeightedResult19 + audioWeightedResult34 + audioWeightedResult29 + audioWeightedResult32;
      }
      if (audioStatusIndex1 < (int)audioTotalChannels) {
        if (3 < (int)(audioTotalChannels - audioStatusIndex1)) {
          audioStatusIndex4 = audioStatusIndex1 + 2;
          audioWeightedResult29 = (float)audioProcessingFactor;
          audioDataPointer = audioDataIndexPtr + (long long)audioStatusIndex1 + 2;
          audioWeightedResult31 = (float)(int)audioTotalChannels;
          do {
            audioWeightedResult19 = audioDataPointer[-2];
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + ((audioWeightedResult29 * 0.5 * (float)audioStatusIndex1) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioWeightedResult19 = audioDataPointer[-1];
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + (((float)(audioStatusIndex4 + -1) * audioWeightedResult29 * 0.5) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioWeightedResult19 = *audioDataPointer;
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + (((float)audioStatusIndex4 * audioWeightedResult29 * 0.5) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioWeightedResult19 = audioDataPointer[1];
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + (((float)(audioStatusIndex4 + 1) * audioWeightedResult29 * 0.5) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioDataPointer = audioDataPointer + 4;
            audioStatusIndex1 = audioStatusIndex1 + 4;
            audioStatusIndex4 = audioStatusIndex4 + 4;
          } while (audioStatusIndex1 < (int)(audioTotalChannels - 3));
        }
        if (audioStatusIndex1 < (int)audioTotalChannels) {
          audioDataPointer = audioDataIndexPtr + audioStatusIndex1;
          do {
            audioWeightedResult29 = *audioDataPointer;
            if (0.0001 < audioWeightedResult29) {
              audioTotalSum = audioTotalSum + audioWeightedResult29;
              audioWeightedResult17 = audioWeightedResult17 + (((float)audioProcessingFactor * 0.5 * (float)audioStatusIndex1) / (float)(int)audioTotalChannels) *
                                audioWeightedResult29;
            }
            audioDataPointer = audioDataPointer + 1;
            audioStatusIndex1 = audioStatusIndex1 + 1;
          } while (audioStatusIndex1 < (int)audioTotalChannels);
        }
      }
      if (0.001 < audioTotalSum) {
        *audioResultOutput = audioWeightedResult17 / audioTotalSum;
        return 0;
      }
    }
    *audioResultOutput = 0.0;
  }
  return 0;
}



/**
 * @brief 音频信号处理函数
 * 
 * 该函数负责处理音频信号，包括：
 * - 音频数据的读取和处理
 * - 信号滤波和加权计算
 * - 多通道音频数据的并行处理
 * - 音频信号的统计分析和结果计算
 * 
 * @return void* 返回处理结果指针
 * 
 * @note 这是音频处理系统的重要函数，用于音频信号的深度处理
 */
void* ProcessAudioSignal(void)

{
  float audioSignal1;
  float audioSignal2;
  float audioSignal3;
  float audioSignal4;
  float audioSignal5;
  float audioSignal6;
  float audioSignal7;
  float audioSignal8;
  uint audioProcessingFlag9;
  int audioStatusIndex0;
  float *audioDataPointer11;
  int audioProcessingFactor;
  float *audioDataIndexPtr;
  int audioStatusIndex2;
  uint audioTotalChannels;
  float *audioOutputBuffer;
  uint audioThresholdFlag13;
  uint audioThresholdFlag14;
  uint audioThresholdFlag15;
  uint audioThresholdFlag16;
  uint8_t audioCoefficientArray17 [16];
  float audioSignal18;
  int audioFilterCoeffA;
  float audioSignal19;
  int audioFilterCoeffB;
  float audioSignal21;
  int audioFilterCoeffC;
  float audioSignal22;
  int audioFilterCoeffD;
  uint8_t audioCoefficientArray20 [16];
  float audioSignal23;
  float audioTotalSum;
  float audioSignal24;
  float audioSignal25;
  float audioSignal26;
  float audioSignal27;
  float audioSignal28;
  float audioSignal29;
  float audioSignal30;
  float audioSignal31;
  float audioSignal32;
  float audioSignal33;
  float audioSignal34;
  float audioSignal35;
  float audioSignal36;
  float audioSignal37;
  float audioSignal38;
  int unaff_XMM12_Da;
  int unaff_XMM12_Db;
  int unaff_XMM12_Dc;
  int unaff_XMM12_Dd;
  
  audioStatusIndex0 = 0;
  if (0 < (int)audioTotalChannels) {
    audioSignal25 = audioTotalSum;
    if (7 < audioTotalChannels) {
      audioProcessingFlag9 = audioTotalChannels & 0x80000007;
      if ((int)audioProcessingFlag9 < 0) {
        audioProcessingFlag9 = (audioProcessingFlag9 - 1 | 0xfffffff8) + 1;
      }
      audioCoefficientArray20._0_4_ = audioFilterCoeffA + -1;
      audioCoefficientArray20._4_4_ = audioFilterCoeffB + -1;
      audioCoefficientArray20._8_4_ = audioFilterCoeffC + -1;
      audioCoefficientArray20._12_4_ = audioFilterCoeffD + -1;
      audioCoefficientArray17._0_4_ = (float)audioCoefficientArray20._0_4_;
      audioCoefficientArray17._4_4_ = (float)audioCoefficientArray20._4_4_;
      audioCoefficientArray17._8_4_ = (float)audioCoefficientArray20._8_4_;
      audioCoefficientArray17._12_4_ = (float)audioCoefficientArray20._12_4_;
      audioCoefficientArray20 = rcpps(audioCoefficientArray20,audioCoefficientArray17);
      audioSignal25 = 0.0;
      audioSignal29 = 0.0;
      audioSignal31 = 0.0;
      audioSignal18 = 0.0;
      audioSignal19 = audioCoefficientArray20._0_4_;
      audioSignal21 = audioCoefficientArray20._4_4_;
      audioSignal22 = audioCoefficientArray20._8_4_;
      audioSignal23 = audioCoefficientArray20._12_4_;
      audioSignal30 = 0.0;
      audioSignal32 = 0.0;
      audioSignal33 = 0.0;
      audioSignal34 = 0.0;
      audioSignal35 = 0.0;
      audioSignal36 = 0.0;
      audioSignal37 = 0.0;
      audioSignal38 = 0.0;
      audioSignal24 = 0.0;
      audioSignal26 = 0.0;
      audioSignal27 = 0.0;
      audioSignal28 = 0.0;
      audioSignal19 = (audioSignal19 + audioSignal19) - audioSignal19 * audioSignal19 * audioCoefficientArray17._0_4_;
      audioSignal21 = (audioSignal21 + audioSignal21) - audioSignal21 * audioSignal21 * audioCoefficientArray17._4_4_;
      audioSignal22 = (audioSignal22 + audioSignal22) - audioSignal22 * audioSignal22 * audioCoefficientArray17._8_4_;
      audioSignal23 = (audioSignal23 + audioSignal23) - audioSignal23 * audioSignal23 * audioCoefficientArray17._12_4_;
      audioDataPointer11 = audioDataIndexPtr;
      audioStatusIndex2 = audioStatusIndex0;
      do {
        audioSignal1 = *audioDataPointer11;
        audioSignal2 = audioDataPointer11[1];
        audioSignal3 = audioDataPointer11[2];
        audioSignal4 = audioDataPointer11[3];
        audioThresholdFlag13 = -(uint)(0.0001 < audioSignal1);
        audioThresholdFlag14 = -(uint)(0.0001 < audioSignal2);
        audioThresholdFlag15 = -(uint)(0.0001 < audioSignal3);
        audioThresholdFlag16 = -(uint)(0.0001 < audioSignal4);
        audioStatusIndex0 = audioStatusIndex2 + 8;
        audioSignal5 = audioDataPointer11[4];
        audioSignal6 = audioDataPointer11[5];
        audioSignal7 = audioDataPointer11[6];
        audioSignal8 = audioDataPointer11[7];
        audioDataPointer11 = audioDataPointer11 + 8;
        audioSignal25 = (float)((uint)((float)audioStatusIndex2 * (float)unaff_XMM12_Da * 0.5 * audioSignal19 * audioSignal1 +
                               audioSignal25) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal25);
        audioSignal29 = (float)((uint)((float)(audioStatusIndex2 + 1) * (float)unaff_XMM12_Db * 0.5 * audioSignal21 * audioSignal2 +
                               audioSignal29) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal29);
        audioSignal31 = (float)((uint)((float)(audioStatusIndex2 + 2) * (float)unaff_XMM12_Dc * 0.5 * audioSignal22 * audioSignal3 +
                               audioSignal31) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal31);
        audioSignal18 = (float)((uint)((float)(audioStatusIndex2 + 3) * (float)unaff_XMM12_Dd * 0.5 * audioSignal23 * audioSignal4 +
                               audioSignal18) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal18);
        audioSignal24 = (float)((uint)(audioSignal1 + audioSignal24) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal24);
        audioSignal26 = (float)((uint)(audioSignal2 + audioSignal26) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal26);
        audioSignal27 = (float)((uint)(audioSignal3 + audioSignal27) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal27);
        audioSignal28 = (float)((uint)(audioSignal4 + audioSignal28) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal28);
        audioThresholdFlag13 = -(uint)(0.0001 < audioSignal5);
        audioThresholdFlag14 = -(uint)(0.0001 < audioSignal6);
        audioThresholdFlag15 = -(uint)(0.0001 < audioSignal7);
        audioThresholdFlag16 = -(uint)(0.0001 < audioSignal8);
        audioSignal30 = (float)((uint)((float)(audioStatusIndex2 + 4) * (float)unaff_XMM12_Da * 0.5 * audioSignal19 * audioSignal5 +
                               audioSignal30) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal30);
        audioSignal32 = (float)((uint)((float)(audioStatusIndex2 + 5) * (float)unaff_XMM12_Db * 0.5 * audioSignal21 * audioSignal6 +
                               audioSignal32) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal32);
        audioSignal33 = (float)((uint)((float)(audioStatusIndex2 + 6) * (float)unaff_XMM12_Dc * 0.5 * audioSignal22 * audioSignal7 +
                               audioSignal33) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal33);
        audioSignal34 = (float)((uint)((float)(audioStatusIndex2 + 7) * (float)unaff_XMM12_Dd * 0.5 * audioSignal23 * audioSignal8 +
                               audioSignal34) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal34);
        audioSignal35 = (float)((uint)(audioSignal5 + audioSignal35) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal35);
        audioSignal36 = (float)((uint)(audioSignal6 + audioSignal36) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal36);
        audioSignal37 = (float)((uint)(audioSignal7 + audioSignal37) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal37);
        audioSignal38 = (float)((uint)(audioSignal8 + audioSignal38) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal38);
        audioStatusIndex2 = audioStatusIndex0;
      } while (audioStatusIndex0 < (int)(audioTotalChannels - audioProcessingFlag9));
      audioTotalSum = audioSignal27 + audioSignal37 + audioSignal24 + audioSignal35 + audioSignal28 + audioSignal38 + audioSignal26 + audioSignal36;
      audioSignal25 = audioSignal31 + audioSignal33 + audioSignal25 + audioSignal30 + audioSignal18 + audioSignal34 + audioSignal29 + audioSignal32;
    }
    if (audioStatusIndex0 < (int)audioTotalChannels) {
      if (3 < (int)(audioTotalChannels - audioStatusIndex0)) {
        audioStatusIndex2 = audioStatusIndex0 + 2;
        audioSignal29 = (float)audioProcessingFactor;
        audioDataPointer11 = audioDataIndexPtr + (long long)audioStatusIndex0 + 2;
        audioSignal31 = (float)(int)audioTotalChannels;
        do {
          audioSignal18 = audioDataPointer11[-2];
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + ((audioSignal29 * 0.5 * (float)audioStatusIndex0) / audioSignal31) * audioSignal18;
          }
          audioSignal18 = audioDataPointer11[-1];
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + (((float)(audioStatusIndex2 + -1) * audioSignal29 * 0.5) / audioSignal31) * audioSignal18;
          }
          audioSignal18 = *audioDataPointer11;
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + (((float)audioStatusIndex2 * audioSignal29 * 0.5) / audioSignal31) * audioSignal18;
          }
          audioSignal18 = audioDataPointer11[1];
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + (((float)(audioStatusIndex2 + 1) * audioSignal29 * 0.5) / audioSignal31) * audioSignal18;
          }
          audioDataPointer11 = audioDataPointer11 + 4;
          audioStatusIndex0 = audioStatusIndex0 + 4;
          audioStatusIndex2 = audioStatusIndex2 + 4;
        } while (audioStatusIndex0 < (int)(audioTotalChannels - 3));
      }
      if (audioStatusIndex0 < (int)audioTotalChannels) {
        audioDataPointer11 = audioDataIndexPtr + audioStatusIndex0;
        do {
          audioSignal29 = *audioDataPointer11;
          if (0.0001 < audioSignal29) {
            audioTotalSum = audioTotalSum + audioSignal29;
            audioSignal25 = audioSignal25 + (((float)audioProcessingFactor * 0.5 * (float)audioStatusIndex0) / (float)(int)audioTotalChannels) *
                              audioSignal29;
          }
          audioDataPointer11 = audioDataPointer11 + 1;
          audioStatusIndex0 = audioStatusIndex0 + 1;
        } while (audioStatusIndex0 < (int)audioTotalChannels);
      }
    }
    if (0.001 < audioTotalSum) {
      *audioOutputBuffer = audioSignal25 / audioTotalSum;
      return 0;
    }
  }
  *audioOutputBuffer = 0.0;
  return 0;
}



/**
 * @brief 系统资源配置处理函数
 * 
 * 该函数负责处理系统资源的配置和管理，包括：
 * - 系统资源的初始化和配置
 * - 配置数据的处理和应用
 * - 系统参数的优化和调整
 * - 资源状态的监控和管理
 * 
 * @param ResourceManagerPointer 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return void* 返回处理结果指针
 * 
 * @note 这是系统资源管理的核心函数，用于系统配置的深度处理
 */
void* ProcessSystemResourceConfiguration(int ResourceManagerPointer,void* ConfigurationDataPointer,void* AdditionalParameter,uint ConfigurationFlag)

{
  float audioSignal1;
  float audioSignal2;
  float audioSignal3;
  float audioSignal4;
  float audioSignal5;
  float audioSignal6;
  float audioSignal7;
  float audioSignal8;
  uint audioProcessingFlag9;
  float *audioDataPointer10;
  int audioProcessingFactor;
  float *audioDataIndexPtr;
  int audioStatusIndex1;
  float *audioOutputBuffer;
  uint audioThresholdFlag12;
  uint audioThresholdFlag13;
  uint audioThresholdFlag14;
  uint audioThresholdFlag15;
  uint8_t audioCoefficientArray16 [16];
  float audioSignal17;
  int audioFilterCoeffA;
  float audioSignal18;
  int audioFilterCoeffB;
  float audioSignal20;
  int audioFilterCoeffC;
  float audioSignal21;
  int audioFilterCoeffD;
  uint8_t audioCoefficientArray19 [16];
  float audioSignal22;
  float audioSignal23;
  float audioSignal24;
  float audioSignal25;
  float audioSignal26;
  float audioSignal27;
  float audioSignal28;
  float audioSignal29;
  float audioSignal30;
  float audioSignal31;
  float audioSignal32;
  float audioSignal33;
  float floatValue34;
  float floatValue35;
  float floatValue36;
  float floatValue37;
  int unaff_XMM12_Da;
  int unaff_XMM12_Db;
  int unaff_XMM12_Dc;
  int unaff_XMM12_Dd;
  
  unsignedSystemValue9 = ConfigurationFlag & 0x80000007;
  if ((int)unsignedSystemValue9 < 0) {
    unsignedSystemValue9 = (unsignedSystemValue9 - 1 | 0xfffffff8) + 1;
  }
  asystemStatus9._0_4_ = in_XMM5_Da + -1;
  asystemStatus9._4_4_ = in_XMM5_Db + -1;
  asystemStatus9._8_4_ = in_XMM5_Dc + -1;
  asystemStatus9._12_4_ = in_XMM5_Dd + -1;
  asystemStatus6._0_4_ = (float)asystemStatus9._0_4_;
  asystemStatus6._4_4_ = (float)asystemStatus9._4_4_;
  asystemStatus6._8_4_ = (float)asystemStatus9._8_4_;
  asystemStatus6._12_4_ = (float)asystemStatus9._12_4_;
  asystemStatus9 = rcpps(asystemStatus9,asystemStatus6);
  floatValue24 = 0.0;
  floatValue28 = 0.0;
  floatValue30 = 0.0;
  interpolationFactor5 = 0.0;
  magnitudeSquared1 = asystemStatus9._0_4_;
  floatValue20 = asystemStatus9._4_4_;
  floatValue21 = asystemStatus9._8_4_;
  floatValue22 = asystemStatus9._12_4_;
  floatValue29 = 0.0;
  floatValue31 = 0.0;
  floatValue32 = 0.0;
  floatValue33 = 0.0;
  floatValue34 = 0.0;
  floatValue35 = 0.0;
  floatValue36 = 0.0;
  floatValue37 = 0.0;
  floatValue23 = 0.0;
  floatValue25 = 0.0;
  floatValue26 = 0.0;
  floatValue27 = 0.0;
  magnitudeSquared1 = (magnitudeSquared1 + magnitudeSquared1) - magnitudeSquared1 * magnitudeSquared1 * asystemStatus6._0_4_;
  floatValue20 = (floatValue20 + floatValue20) - floatValue20 * floatValue20 * asystemStatus6._4_4_;
  floatValue21 = (floatValue21 + floatValue21) - floatValue21 * floatValue21 * asystemStatus6._8_4_;
  floatValue22 = (floatValue22 + floatValue22) - floatValue22 * floatValue22 * asystemStatus6._12_4_;
  pFloatScaleFactor = systemDataIndexPtr;
  do {
    systemStatus1 = ResourceManagerPointer;
    floatValue1 = *pFloatScaleFactor;
    floatValue2 = pFloatScaleFactor[1];
    floatValue3 = pFloatScaleFactor[2];
    floatValue4 = pFloatScaleFactor[3];
    systemStatus2 = -(uint)(0.0001 < floatValue1);
    systemStatus3 = -(uint)(0.0001 < floatValue2);
    systemStatus4 = -(uint)(0.0001 < floatValue3);
    systemStatus5 = -(uint)(0.0001 < floatValue4);
    ResourceManagerPointer = systemStatus1 + 8;
    floatValue5 = pFloatScaleFactor[4];
    floatValue6 = pFloatScaleFactor[5];
    floatValue7 = pFloatScaleFactor[6];
    floatValue8 = pFloatScaleFactor[7];
    pFloatScaleFactor = pFloatScaleFactor + 8;
    floatValue24 = (float)((uint)((float)systemStatus1 * (float)unaff_XMM12_Da * 0.5 * magnitudeSquared1 * floatValue1 + floatValue24) &
                     systemStatus2 | ~systemStatus2 & (uint)floatValue24);
    floatValue28 = (float)((uint)((float)(systemStatus1 + 1) * (float)unaff_XMM12_Db * 0.5 * floatValue20 * floatValue2 +
                           floatValue28) & systemStatus3 | ~systemStatus3 & (uint)floatValue28);
    floatValue30 = (float)((uint)((float)(systemStatus1 + 2) * (float)unaff_XMM12_Dc * 0.5 * floatValue21 * floatValue3 +
                           floatValue30) & systemStatus4 | ~systemStatus4 & (uint)floatValue30);
    interpolationFactor5 = (float)((uint)((float)(systemStatus1 + 3) * (float)unaff_XMM12_Dd * 0.5 * floatValue22 * floatValue4 +
                           interpolationFactor5) & systemStatus5 | ~systemStatus5 & (uint)interpolationFactor5);
    floatValue23 = (float)((uint)(floatValue1 + floatValue23) & systemStatus2 | ~systemStatus2 & (uint)floatValue23);
    floatValue25 = (float)((uint)(floatValue2 + floatValue25) & systemStatus3 | ~systemStatus3 & (uint)floatValue25);
    floatValue26 = (float)((uint)(floatValue3 + floatValue26) & systemStatus4 | ~systemStatus4 & (uint)floatValue26);
    floatValue27 = (float)((uint)(floatValue4 + floatValue27) & systemStatus5 | ~systemStatus5 & (uint)floatValue27);
    systemStatus2 = -(uint)(0.0001 < floatValue5);
    systemStatus3 = -(uint)(0.0001 < floatValue6);
    systemStatus4 = -(uint)(0.0001 < floatValue7);
    systemStatus5 = -(uint)(0.0001 < floatValue8);
    floatValue29 = (float)((uint)((float)(systemStatus1 + 4) * (float)unaff_XMM12_Da * 0.5 * magnitudeSquared1 * floatValue5 +
                           floatValue29) & systemStatus2 | ~systemStatus2 & (uint)floatValue29);
    floatValue31 = (float)((uint)((float)(systemStatus1 + 5) * (float)unaff_XMM12_Db * 0.5 * floatValue20 * floatValue6 +
                           floatValue31) & systemStatus3 | ~systemStatus3 & (uint)floatValue31);
    floatValue32 = (float)((uint)((float)(systemStatus1 + 6) * (float)unaff_XMM12_Dc * 0.5 * floatValue21 * floatValue7 +
                           floatValue32) & systemStatus4 | ~systemStatus4 & (uint)floatValue32);
    floatValue33 = (float)((uint)((float)(systemStatus1 + 7) * (float)unaff_XMM12_Dd * 0.5 * floatValue22 * floatValue8 +
                           floatValue33) & systemStatus5 | ~systemStatus5 & (uint)floatValue33);
    floatValue34 = (float)((uint)(floatValue5 + floatValue34) & systemStatus2 | ~systemStatus2 & (uint)floatValue34);
    floatValue35 = (float)((uint)(floatValue6 + floatValue35) & systemStatus3 | ~systemStatus3 & (uint)floatValue35);
    floatValue36 = (float)((uint)(floatValue7 + floatValue36) & systemStatus4 | ~systemStatus4 & (uint)floatValue36);
    floatValue37 = (float)((uint)(floatValue8 + floatValue37) & systemStatus5 | ~systemStatus5 & (uint)floatValue37);
  } while (ResourceManagerPointer < (int)(ConfigurationFlag - unsignedSystemValue9));
  magnitudeSquared1 = floatValue26 + floatValue36 + floatValue23 + floatValue34 + floatValue27 + floatValue37 + floatValue25 + floatValue35;
  floatValue24 = floatValue30 + floatValue32 + floatValue24 + floatValue29 + interpolationFactor5 + floatValue33 + floatValue28 + floatValue31;
  if (ResourceManagerPointer < (int)ConfigurationFlag) {
    if (3 < (int)(ConfigurationFlag - ResourceManagerPointer)) {
      systemStatus1 = systemStatus1 + 10;
      floatValue28 = (float)unaff_EBX;
      pFloatScaleFactor = systemDataIndexPtr + (long long)ResourceManagerPointer + 2;
      floatValue30 = (float)(int)ConfigurationFlag;
      do {
        interpolationFactor5 = pFloatScaleFactor[-2];
        if (0.0001 < interpolationFactor5) {
          magnitudeSquared1 = magnitudeSquared1 + interpolationFactor5;
          floatValue24 = floatValue24 + ((floatValue28 * 0.5 * (float)ResourceManagerPointer) / floatValue30) * interpolationFactor5;
        }
        interpolationFactor5 = pFloatScaleFactor[-1];
        if (0.0001 < interpolationFactor5) {
          magnitudeSquared1 = magnitudeSquared1 + interpolationFactor5;
          floatValue24 = floatValue24 + (((float)(systemStatus1 + -1) * floatValue28 * 0.5) / floatValue30) * interpolationFactor5;
        }
        interpolationFactor5 = *pFloatScaleFactor;
        if (0.0001 < interpolationFactor5) {
          magnitudeSquared1 = magnitudeSquared1 + interpolationFactor5;
          floatValue24 = floatValue24 + (((float)systemStatus1 * floatValue28 * 0.5) / floatValue30) * interpolationFactor5;
        }
        interpolationFactor5 = pFloatScaleFactor[1];
        if (0.0001 < interpolationFactor5) {
          magnitudeSquared1 = magnitudeSquared1 + interpolationFactor5;
          floatValue24 = floatValue24 + (((float)(systemStatus1 + 1) * floatValue28 * 0.5) / floatValue30) * interpolationFactor5;
        }
        pFloatScaleFactor = pFloatScaleFactor + 4;
        ResourceManagerPointer = ResourceManagerPointer + 4;
        systemStatus1 = systemStatus1 + 4;
      } while (ResourceManagerPointer < (int)(ConfigurationFlag - 3));
    }
    if (ResourceManagerPointer < (int)ConfigurationFlag) {
      pFloatScaleFactor = systemDataIndexPtr + ResourceManagerPointer;
      do {
        floatValue28 = *pFloatScaleFactor;
        if (0.0001 < floatValue28) {
          magnitudeSquared1 = magnitudeSquared1 + floatValue28;
          floatValue24 = floatValue24 + (((float)unaff_EBX * 0.5 * (float)ResourceManagerPointer) / (float)(int)ConfigurationFlag) *
                            floatValue28;
        }
        pFloatScaleFactor = pFloatScaleFactor + 1;
        ResourceManagerPointer = ResourceManagerPointer + 1;
      } while (ResourceManagerPointer < (int)ConfigurationFlag);
    }
  }
  if (magnitudeSquared1 <= 0.001) {
    *in_R11 = 0.0;
  }
  else {
    *in_R11 = floatValue24 / magnitudeSquared1;
  }
  return 0;
}



/**
 * @brief 计算浮点数组的加权平均值
 * 
 * 该函数计算一个浮点数组的加权平均值，通过遍历数组元素并应用权重计算。
 * 这是一个用于数学统计和数据分析的函数。
 * 
 * @param startIndex 起始索引，指定数组的开始位置
 * @param arrayBasePointer 数组基址指针，指向浮点数组的起始位置
 * @param resultPointer 结果指针，用于存储计算结果
 * @param weightFactor 权重因子，用于计算加权平均值
 * @return 计算成功返回0，失败返回非零值
 */
void* CalculateWeightedAverageFloatArray(int startIndex, void* arrayBasePointer, void* resultPointer, float weightFactor)

{
  float currentValue;
  float *arrayPointer;
  int stepSize;
  long long baseAddress;
  int endIndex;
  float *resultStorage;
  float weightedSum;
  float rangeFactor;
  int offsetIndex;
  
  if (startIndex < endIndex) {
    if (3 < endIndex - startIndex) {
      offsetIndex = startIndex + 2;
      rangeFactor = (float)stepSize;
      arrayPointer = (float *)(baseAddress + ((long long)startIndex + 2) * 4);
      float totalCount = (float)endIndex;
      do {
        currentValue = arrayPointer[-2];
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + ((rangeFactor * 0.5 * (float)startIndex) / totalCount) * currentValue;
        }
        currentValue = arrayPointer[-1];
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + (((float)(offsetIndex + -1) * rangeFactor * 0.5) / totalCount) * currentValue;
        }
        currentValue = *arrayPointer;
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + (((float)offsetIndex * rangeFactor * 0.5) / totalCount) * currentValue;
        }
        currentValue = arrayPointer[1];
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + (((float)(offsetIndex + 1) * rangeFactor * 0.5) / totalCount) * currentValue;
        }
        arrayPointer = arrayPointer + 4;
        startIndex = startIndex + 4;
        offsetIndex = offsetIndex + 4;
      } while (startIndex < endIndex + -3);
    }
    if (startIndex < endIndex) {
      arrayPointer = (float *)(baseAddress + (long long)startIndex * 4);
      do {
        rangeFactor = *arrayPointer;
        if (0.0001 < rangeFactor) {
          weightFactor = weightFactor + rangeFactor;
          weightedSum =
               weightedSum + (((float)stepSize * 0.5 * (float)startIndex) / (float)endIndex) * rangeFactor;
        }
        arrayPointer = arrayPointer + 1;
        startIndex = startIndex + 1;
      } while (startIndex < endIndex);
    }
  }
  if (weightFactor <= 0.001) {
    *resultStorage = 0.0;
  }
  else {
    *resultStorage = weightedSum / weightFactor;
  }
  return 0;
}



/**
 * @brief 计算旋转变换矩阵
 * 
 * 该函数根据给定的旋转位数计算变换矩阵，用于3D图形渲染中的旋转操作。
 * 这是一个复杂的数学计算函数，涉及位操作、三角函数和矩阵运算。
 * 
 * @param transformContext 变换上下文指针，包含变换所需的数据
 * @param rotationBits 旋转位数，控制旋转的精度
 * @return 变换结果指针
 * @note 这是一个简化的实现，部分变量名仍需要进一步美化
 */
void* CalculateRotationTransform(long long transformContext, uint rotationBits)

{
  float sineValue;
  float cosineValue;
  float angleValue;
  long long matrixPointer;
  int bitMask;
  uint halfRange;
  ulong long bitValue;
  ulong long maxBits;
  uint bitIndex;
  uint reversedBits;
  long long rowIndex;
  int colIndex;
  int chunkIndex;
  uint elementIndex;
  ulong long chunkSize;
  long long startRow;
  ulong long currentChunk;
  ulong long elementOffset;
  ulong long matrixElement;
  float rotationSine;
  float rotationCosine;
  float tempFloat1;
  float tempFloat2;
  uint32_t loopCounter;
  
  maxBits = (ulong long)rotationBits;
  loopCounter = 1;
  bitMask = 1 << ((byte)rotationBits & 0x1f);
  halfRange = bitMask / 2;
  if (0 < (int)rotationBits) {
    do {
      int rowIndex = 0;
      if (0 < (int)loopCounter) {
        ulong long columnCount = (ulong long)loopCounter;
        do {
          ulong long normalizedIndex = (long long)rowIndex / (long long)(int)halfRange & 0xffffffff;
          uint reversedBits = 0;
          uint bitCount = rotationBits;
          if (rotationBits != 0) {
            do {
              uint currentBit = (uint)normalizedIndex;
              normalizedIndex = normalizedIndex >> 1;
              reversedBits = reversedBits * 2 | currentBit & 1;
              bitCount = bitCount - 1;
            } while (bitCount != 0);
          }
          float angleValue = (float)(int)reversedBits * (1.0 / (float)bitMask);
          uint lookupIndex = (uint)(angleValue * 32768.0);
          if ((int)lookupIndex < 0) {
            lookupIndex = -lookupIndex;
          }
          lookupIndex = lookupIndex & 0x7fff;
          ulong long sineLookupIndex = (ulong long)lookupIndex;
          uint quadrant = lookupIndex >> 0xd;
          float sineValue;
          if (lookupIndex >> 0xd == 0) {
            sineValue = *(float *)(transformContext + 0x4cc + sineLookupIndex * 4);
          }
          else if (quadrant == 1) {
            sineValue = -*(float *)(transformContext + (0x4132 - (ulong long)lookupIndex) * 4);
          }
          else if (quadrant == 2) {
            sineValue = -*(float *)(transformContext + -0xfb34 + sineLookupIndex * 4);
          }
          else if (quadrant == 3) {
            sineValue = *(float *)(transformContext + (0x8132 - sineLookupIndex) * 4);
          }
          else {
            sineValue = 0.0;
          }
          lookupIndex = (uint)((angleValue - 0.25) * 32768.0);
          if ((int)lookupIndex < 0) {
            lookupIndex = -lookupIndex;
          }
          lookupIndex = lookupIndex & 0x7fff;
          sineLookupIndex = (ulong long)lookupIndex;
          quadrant = lookupIndex >> 0xd;
          float cosineValue;
          if (lookupIndex >> 0xd == 0) {
            cosineValue = *(float *)(transformContext + 0x4cc + sineLookupIndex * 4);
          }
          else if (quadrant == 1) {
            cosineValue = -*(float *)(transformContext + (0x4132 - (ulong long)lookupIndex) * 4);
          }
          else if (quadrant == 2) {
            cosineValue = -*(float *)(transformContext + -0xfb34 + sineLookupIndex * 4);
          }
          else if (quadrant == 3) {
            cosineValue = *(float *)(transformContext + (0x8132 - sineLookupIndex) * 4);
          }
          else {
            cosineValue = 0.0;
          }
          long long startRow = (long long)rowIndex;
          long long endRow = (long long)(int)(rowIndex + halfRange);
          cosineValue = -cosineValue;
          if (startRow < endRow) {
            int currentRow = rowIndex;
            if (3 < endRow - startRow) {
              uint targetRow = rowIndex + halfRange + 3;
              currentRow = rowIndex + ((int)(((endRow + -3) - startRow) - 1U >> 2) + 1) * 4;
              do {
                ulong long row4 = (ulong long)targetRow;
                long long matrixPointer = *(long long *)(transformContext + 0x218);
                ulong long row3 = (ulong long)(targetRow - 1);
                ulong long row2 = (ulong long)(targetRow - 2);
                uint row1 = targetRow - 3;
                float sine4 = *(float *)(matrixPointer + 4 + (ulong long)row1 * 8);
                float cosine4 = *(float *)(matrixPointer + (ulong long)row1 * 8);
                float matrixVal1 = *(float *)(matrixPointer + startRow * 8);
                float matrixVal2 = *(float *)(matrixPointer + 4 + startRow * 8);
                float result1 = cosine4 * sineValue - sine4 * cosineValue;
                float result2 = sine4 * sineValue + cosine4 * cosineValue;
                *(float *)(matrixPointer + startRow * 8) = result1 + matrixVal1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + startRow * 8) = result2 + matrixVal2;
                *(float *)(*(long long *)(transformContext + 0x218) + (ulong long)row1 * 8) = matrixVal1 - result1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + (ulong long)row1 * 8) =
                     matrixVal2 - result2;
                matrixPointer = *(long long *)(transformContext + 0x218);
                result2 = *(float *)(matrixPointer + 4 + row2 * 8);
                result1 = *(float *)(matrixPointer + row2 * 8);
                matrixVal1 = *(float *)(matrixPointer + 8 + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 0xc + startRow * 8);
                float tempResult1 = result1 * sineValue - result2 * cosineValue;
                result2 = result2 * sineValue + result1 * cosineValue;
                *(float *)(matrixPointer + 8 + startRow * 8) = tempResult1 + matrixVal1;
                *(float *)(*(long long *)(transformContext + 0x218) + 0xc + startRow * 8) = result2 + matrixVal2;
                *(float *)(*(long long *)(transformContext + 0x218) + row2 * 8) = matrixVal1 - tempResult1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + row2 * 8) = matrixVal2 - result2;
                matrixPointer = *(long long *)(transformContext + 0x218);
                result2 = *(float *)(matrixPointer + row3 * 8);
                result1 = *(float *)(matrixPointer + 4 + row3 * 8);
                matrixVal1 = *(float *)(matrixPointer + 0x10 + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 0x14 + startRow * 8);
                tempResult1 = result2 * sineValue - result1 * cosineValue;
                result2 = result1 * sineValue + result2 * cosineValue;
                *(float *)(matrixPointer + 0x10 + startRow * 8) = tempResult1 + matrixVal1;
                *(float *)(*(long long *)(transformContext + 0x218) + 0x14 + startRow * 8) = result2 + matrixVal2;
                *(float *)(*(long long *)(transformContext + 0x218) + row3 * 8) = matrixVal1 - tempResult1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + row3 * 8) = matrixVal2 - result2;
                matrixPointer = *(long long *)(transformContext + 0x218);
                result2 = *(float *)(matrixPointer + row4 * 8);
                result1 = *(float *)(matrixPointer + 4 + row4 * 8);
                matrixVal1 = *(float *)(matrixPointer + 0x18 + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 0x1c + startRow * 8);
                tempResult1 = result2 * sineValue - result1 * cosineValue;
                result2 = result1 * sineValue + result2 * cosineValue;
                *(float *)(matrixPointer + 0x18 + startRow * 8) = tempResult1 + matrixVal1;
                *(float *)(*(long long *)(transformContext + 0x218) + 0x1c + startRow * 8) = result2 + matrixVal2;
                startRow = startRow + 4;
                *(float *)(*(long long *)(transformContext + 0x218) + row4 * 8) = matrixVal1 - tempResult1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + row4 * 8) = matrixVal2 - result2;
                targetRow = targetRow + 4;
              } while (startRow < endRow + -3);
            }
            if (startRow < endRow) {
              targetRow = currentRow + halfRange;
              do {
                ulong long targetIndex = (ulong long)targetRow;
                matrixPointer = *(long long *)(transformContext + 0x218);
                result2 = *(float *)(matrixPointer + targetIndex * 8);
                result1 = *(float *)(matrixPointer + 4 + targetIndex * 8);
                matrixVal1 = *(float *)(matrixPointer + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 4 + startRow * 8);
                tempResult1 = result2 * sineValue - result1 * cosineValue;
                result2 = result1 * sineValue + result2 * cosineValue;
                *(float *)(matrixPointer + startRow * 8) = tempResult1 + matrixVal1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + startRow * 8) = result2 + matrixVal2;
                startRow = startRow + 1;
                *(float *)(*(long long *)(transformContext + 0x218) + targetIndex * 8) = matrixVal1 - tempResult1;
                *(float *)(*(long long *)(transformContext + 0x218) + 4 + targetIndex * 8) = matrixVal2 - result2;
                targetRow = targetRow + 1;
              } while (startRow < endRow);
            }
          }
          rowIndex = rowIndex + halfRange * 2;
          columnCount = columnCount - 1;
        } while (columnCount != 0);
      }
      loopCounter = loopCounter * 2;
      halfRange = halfRange >> 1;
      maxBits = maxBits - 1;
    } while (maxBits != 0);
  }
  return 0;
}



/**
 * @brief 执行快速傅里叶变换
 * 
 * 该函数实现了快速傅里叶变换算法，用于在频域分析信号数据。
 * 主要用于音频处理、图像处理和信号分析等场景。
 * 
 * @param context 上下文指针，包含变换所需的配置数据
 * @param dataBuffer 数据缓冲区，包含要变换的输入数据
 * @param dataSize 数据大小，指定要处理的数据点数
 * @return 执行结果状态码
 */
void* FastFourierTransform(void* context, void* dataBuffer, uint dataSize)

{
  float tempFloat1;
  float tempFloat2;
  float tempFloat3;
  long long matrixPointer;
  ulong long bitValue;
  ulong long maxBits;
  uint reversedBits;
  uint currentBit;
  long long endRow;
  int currentRow;
  int rowIndex;
  uint lookupIndex;
  ulong long targetRow;
  long long startRow;
  long long contextData;
  ulong long targetIndex;
  uint bitCount;
  uint halfRange;
  ulong long row4;
  float sineValue;
  float cosineValue;
  float angleValue;
  float resultValue;
  float scaleValue;
  uint stackParam;
  
  hashValue = (ulong long)unaff_R13D;
  do {
    systemStatus1 = 0;
    if (0 < (int)AdditionalParameter) {
      systemStatus5 = (ulong long)AdditionalParameter;
      do {
        currentThreadId = (long long)systemStatus1 / (long long)(int)systemResourceCounterD & 0xffffffff;
        unsignedSystemValue7 = 0;
        systemStatus2 = unaff_R13D;
        if (unaff_R13D != 0) {
          do {
            unsignedSystemValue8 = (uint)currentThreadId;
            currentThreadId = currentThreadId >> 1;
            unsignedSystemValue7 = unsignedSystemValue7 * 2 | unsignedSystemValue8 & 1;
            systemStatus2 = systemStatus2 - 1;
          } while (systemStatus2 != 0);
        }
        systemStatus2 = (uint)((float)(int)unsignedSystemValue7 * unaff_XMM10_Da * 32768.0);
        if ((int)systemStatus2 < 0) {
          systemStatus2 = -systemStatus2;
        }
        systemStatus2 = systemStatus2 & 0x7fff;
        currentThreadId = (ulong long)systemStatus2;
        unsignedSystemValue8 = systemStatus2 >> 0xd;
        if (systemStatus2 >> 0xd == 0) {
          floatValue20 = *(float *)(in_R11 + 0x4cc + currentThreadId * 4);
        }
        else if (unsignedSystemValue8 == 1) {
          floatValue20 = -*(float *)(in_R11 + (0x4132 - (ulong long)systemStatus2) * 4);
        }
        else if (unsignedSystemValue8 == 2) {
          floatValue20 = -*(float *)(in_R11 + -0xfb34 + currentThreadId * 4);
        }
        else if (unsignedSystemValue8 == 3) {
          floatValue20 = *(float *)(in_R11 + (0x8132 - currentThreadId) * 4);
        }
        else {
          floatValue20 = 0.0;
        }
        systemStatus2 = (uint)(((float)(int)unsignedSystemValue7 * unaff_XMM10_Da - 0.25) * 32768.0);
        if ((int)systemStatus2 < 0) {
          systemStatus2 = -systemStatus2;
        }
        systemStatus2 = systemStatus2 & 0x7fff;
        currentThreadId = (ulong long)systemStatus2;
        unsignedSystemValue7 = systemStatus2 >> 0xd;
        if (systemStatus2 >> 0xd == 0) {
          floatValue19 = *(float *)(in_R11 + 0x4cc + currentThreadId * 4);
        }
        else if (unsignedSystemValue7 == 1) {
          floatValue19 = -*(float *)(in_R11 + (0x4132 - (ulong long)systemStatus2) * 4);
        }
        else if (unsignedSystemValue7 == 2) {
          floatValue19 = -*(float *)(in_R11 + -0xfb34 + currentThreadId * 4);
        }
        else if (unsignedSystemValue7 == 3) {
          floatValue19 = *(float *)(in_R11 + (0x8132 - currentThreadId) * 4);
        }
        else {
          floatValue19 = 0.0;
        }
        nextDataIndex4 = (long long)systemStatus1;
        resourceCounter = (long long)(int)(systemStatus1 + systemResourceCounterD);
        floatValue19 = -floatValue19;
        if (nextDataIndex4 < resourceCounter) {
          systemStatus0 = systemStatus1;
          if (3 < resourceCounter - nextDataIndex4) {
            systemStatus2 = systemStatus1 + systemResourceCounterD + 3;
            systemStatus0 = systemStatus1 + ((int)(((resourceCounter + -3) - nextDataIndex4) - 1U >> 2) + 1) * 4;
            do {
              systemStatus6 = (ulong long)systemStatus2;
              bufferBaseAddress = *(long long *)(in_R11 + 0x218);
              systemStatus3 = (ulong long)(systemStatus2 - 1);
              currentThreadId = (ulong long)(systemStatus2 - 2);
              unsignedSystemValue7 = systemStatus2 - 3;
              magnitudeSquared1 = *(float *)(bufferBaseAddress + 4 + (ulong long)unsignedSystemValue7 * 8);
              floatValue1 = *(float *)(bufferBaseAddress + (ulong long)unsignedSystemValue7 * 8);
              floatValue2 = *(float *)(bufferBaseAddress + nextDataIndex4 * 8);
              floatValue3 = *(float *)(bufferBaseAddress + 4 + nextDataIndex4 * 8);
              interpolationFactor5 = floatValue1 * floatValue20 - magnitudeSquared1 * floatValue19;
              magnitudeSquared1 = magnitudeSquared1 * floatValue20 + floatValue1 * floatValue19;
              *(float *)(bufferBaseAddress + nextDataIndex4 * 8) = interpolationFactor5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + nextDataIndex4 * 8) = magnitudeSquared1 + floatValue3;
              *(float *)(*(long long *)(in_R11 + 0x218) + (ulong long)unsignedSystemValue7 * 8) = floatValue2 - interpolationFactor5;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + (ulong long)unsignedSystemValue7 * 8) = floatValue3 - magnitudeSquared1;
              bufferBaseAddress = *(long long *)(in_R11 + 0x218);
              magnitudeSquared1 = *(float *)(bufferBaseAddress + 4 + currentThreadId * 8);
              floatValue1 = *(float *)(bufferBaseAddress + currentThreadId * 8);
              floatValue2 = *(float *)(bufferBaseAddress + 8 + nextDataIndex4 * 8);
              floatValue3 = *(float *)(bufferBaseAddress + 0xc + nextDataIndex4 * 8);
              interpolationFactor5 = floatValue1 * floatValue20 - magnitudeSquared1 * floatValue19;
              magnitudeSquared1 = magnitudeSquared1 * floatValue20 + floatValue1 * floatValue19;
              *(float *)(bufferBaseAddress + 8 + nextDataIndex4 * 8) = interpolationFactor5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 0xc + nextDataIndex4 * 8) = magnitudeSquared1 + floatValue3;
              *(float *)(*(long long *)(in_R11 + 0x218) + currentThreadId * 8) = floatValue2 - interpolationFactor5;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + currentThreadId * 8) = floatValue3 - magnitudeSquared1;
              bufferBaseAddress = *(long long *)(in_R11 + 0x218);
              magnitudeSquared1 = *(float *)(bufferBaseAddress + systemStatus3 * 8);
              floatValue1 = *(float *)(bufferBaseAddress + 4 + systemStatus3 * 8);
              floatValue2 = *(float *)(bufferBaseAddress + 0x10 + nextDataIndex4 * 8);
              floatValue3 = *(float *)(bufferBaseAddress + 0x14 + nextDataIndex4 * 8);
              interpolationFactor5 = magnitudeSquared1 * floatValue20 - floatValue1 * floatValue19;
              magnitudeSquared1 = floatValue1 * floatValue20 + magnitudeSquared1 * floatValue19;
              *(float *)(bufferBaseAddress + 0x10 + nextDataIndex4 * 8) = interpolationFactor5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 0x14 + nextDataIndex4 * 8) = magnitudeSquared1 + floatValue3;
              *(float *)(*(long long *)(in_R11 + 0x218) + systemStatus3 * 8) = floatValue2 - interpolationFactor5;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + systemStatus3 * 8) = floatValue3 - magnitudeSquared1;
              bufferBaseAddress = *(long long *)(in_R11 + 0x218);
              magnitudeSquared1 = *(float *)(bufferBaseAddress + systemStatus6 * 8);
              floatValue1 = *(float *)(bufferBaseAddress + 4 + systemStatus6 * 8);
              floatValue2 = *(float *)(bufferBaseAddress + 0x18 + nextDataIndex4 * 8);
              floatValue3 = *(float *)(bufferBaseAddress + 0x1c + nextDataIndex4 * 8);
              interpolationFactor5 = magnitudeSquared1 * floatValue20 - floatValue1 * floatValue19;
              magnitudeSquared1 = floatValue1 * floatValue20 + magnitudeSquared1 * floatValue19;
              *(float *)(bufferBaseAddress + 0x18 + nextDataIndex4 * 8) = interpolationFactor5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 0x1c + nextDataIndex4 * 8) = magnitudeSquared1 + floatValue3;
              nextDataIndex4 = nextDataIndex4 + 4;
              *(float *)(*(long long *)(in_R11 + 0x218) + systemStatus6 * 8) = floatValue2 - interpolationFactor5;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + systemStatus6 * 8) = floatValue3 - magnitudeSquared1;
              systemStatus2 = systemStatus2 + 4;
            } while (nextDataIndex4 < resourceCounter + -3);
          }
          if (nextDataIndex4 < resourceCounter) {
            systemStatus2 = systemStatus0 + systemResourceCounterD;
            do {
              currentThreadId = (ulong long)systemStatus2;
              bufferBaseAddress = *(long long *)(in_R11 + 0x218);
              magnitudeSquared1 = *(float *)(bufferBaseAddress + currentThreadId * 8);
              floatValue1 = *(float *)(bufferBaseAddress + 4 + currentThreadId * 8);
              floatValue2 = *(float *)(bufferBaseAddress + nextDataIndex4 * 8);
              floatValue3 = *(float *)(bufferBaseAddress + 4 + nextDataIndex4 * 8);
              interpolationFactor5 = magnitudeSquared1 * floatValue20 - floatValue1 * floatValue19;
              magnitudeSquared1 = floatValue1 * floatValue20 + magnitudeSquared1 * floatValue19;
              *(float *)(bufferBaseAddress + nextDataIndex4 * 8) = interpolationFactor5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + nextDataIndex4 * 8) = magnitudeSquared1 + floatValue3;
              nextDataIndex4 = nextDataIndex4 + 1;
              *(float *)(*(long long *)(in_R11 + 0x218) + currentThreadId * 8) = floatValue2 - interpolationFactor5;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + currentThreadId * 8) = floatValue3 - magnitudeSquared1;
              systemStatus2 = systemStatus2 + 1;
            } while (nextDataIndex4 < resourceCounter);
          }
        }
        systemStatus1 = systemStatus1 + systemResourceCounterD * 2;
        systemStatus5 = systemStatus5 - 1;
        AdditionalParameter = in_stack_000000a8;
      } while (systemStatus5 != 0);
    }
    AdditionalParameter = AdditionalParameter * 2;
    systemResourceCounterD = systemResourceCounterD >> 1;
    hashValue = hashValue - 1;
    in_stack_000000a8 = AdditionalParameter;
  } while (hashValue != 0);
  return 0;
}



/**
 * @brief 检查系统状态
 * 
 * 该函数是一个简单的状态检查函数，用于检查系统的当前状态。
 * 它返回固定的状态值0，表示系统状态正常。
 * 
 * @return 系统状态码，0表示正常
 * @note 这是一个状态检查函数，用于系统初始化过程中的状态验证
 */
void* CheckSystemStatus(void)

{
  return 0;
}




// 函数: 系统模块加载器 - 负责加载系统模块
void* SystemModuleLoader;

// 函数: 系统接口管理器 - 负责管理系统接口
void* SystemInterfaceManager;
void* SystemModuleLoadFlag;
void* SystemInterfaceHandle;
uint32_t SystemInterfaceVersion;
void* *SystemInterfaceTable;
uint8_t *SystemInterfaceData;
uint32_t SystemInterfaceConfig;
long long SystemInterfaceMemoryBase;
long long SystemInterfaceMemorySize;
long long SystemInterfaceDataOffset;
long long SystemInterfaceDataSize;
uint32_t SystemInterfaceFlags;
uint32_t SystemInterfaceStatus;
void* SystemModuleConfigData;
void* SystemModuleRuntimeData;
void* SystemGlobalConfigFlag;
void* SystemRuntimeDataFlag;
void* SystemModuleLoadStatus;
long long SystemModuleLoadTime;
void* SystemModuleUnloadTime;
long long SystemModuleExecutionTime;
long long *SystemModuleExecutionCounter;

// 系统字符串常量模板
void* SystemStringConstantErrorMessageCritical;
void* SystemStringConstantErrorMessageWarning;
void* SystemStringConstantConfigPathDefault;
void* SystemStringConstantBufferTemplateStandard;
void* SystemStringConstantBufferSizeDefault;
void* SystemStringConstantComputerNameError;
void* SystemStringConstantUserNameError;
void* SystemStringConstantLibraryNameDefault;
void* SystemStringConstantFunctionNameDefault;
void* SystemStringConstantWindowTitleDefault;

// 系统虚拟函数表模板
void* SystemVirtualTableBaseClassPrimary;
void* SystemVirtualTableDerivedClassSecondary;
void* SystemVirtualTableInterfaceStandard;
void* SystemVirtualTableAbstractClassBase;
void* SystemVirtualTableSingletonClassInstance;

// 系统内存管理模板
void* SystemMemoryPoolTemplatePrimary;
void* SystemMemoryPoolTemplateSecondary;
void* SystemMemoryPoolTemplateTertiary;
void* SystemMemoryPoolTemplateQuaternary;
void* SystemMemoryPoolTemplateQuinary;
void* SystemMemoryPoolTemplateSenary;
void* SystemMemoryPoolTemplateSeptenary;

// 系统数据缓冲区模板
void* SystemDataBufferMainTemplatePrimary;
void* SystemDataBufferBackupTemplateSecondary;
void* SystemDataBufferCacheTemplateTertiary;
void* SystemDataBufferTemporaryTemplateQuaternary;
void* SystemDataBufferInputTemplateQuinary;
void* SystemDataBufferOutputTemplateSenary;
void* SystemDataBufferNetworkTemplateSeptenary;
void* SystemDataBufferFileTemplateOctonary;
void* SystemDataBufferMemoryTemplateNonary;
void* SystemDataBufferSystemTemplateDenary;
void* SystemDataBufferUserTemplateUndenary;
void* SystemDataBufferSharedTemplateDuodenary;
void* SystemDataBufferProtectedTemplateTridenary;
void* SystemDataBufferSecureTemplateQuattuordenary;
void* SystemDataBufferDebugTemplateQuindenary;
void* SystemDataBufferTestTemplateSexdenary;
void* SystemDataBufferProductionTemplateSeptendenary;
void* SystemDataBufferDevelopmentTemplateOctodenary;
void* SystemDataBufferStagingTemplateNovendenary;
void* SystemDataBufferArchiveTemplateVigintenary;
void* SystemDataBufferLegacyTemplateUnvigintenary;
void* SystemDataBufferFutureTemplateDuovigintenary;
void* SystemDataBufferExperimentalTemplateTrevigintenary;
void* SystemDataBufferDeprecatedTemplateQuattuorvigintenary;
void* SystemDataBufferReservedTemplateQuinvigintenary;
void* SystemDataBufferEmergencyTemplateSexvigintenary;
void* SystemDataBufferTemplateSeptenvigintenary;
void* SystemDataBufferTemplateOctovigintenary;
void* SystemDataBufferTemplateNovemvigintenary;

/**
 * @brief 获取资源偏移指针函数
 * 
 * 该函数负责获取系统资源的偏移指针，用于资源定位和访问
 * 
 * @param resourcePointer 资源指针
 * @return 资源偏移指针
 * 
 * 原始函数名为FUN_18005ff50，现已重命名为GetResourceOffsetPointer
 */
void* GetResourceOffsetPointer(void* resourcePointer);

/**
 * @brief 获取系统资源状态函数
 * 
 * 该函数负责获取系统资源的当前状态，用于资源监控和管理
 * 
 * @return 系统资源状态
 * 
 * 原始函数名为FUN_18005f430，现已重命名为GetSystemResourceStatus
 */
long long GetSystemResourceStatus(void);

/**
 * @brief 初始化系统资源处理器函数
 * 
 * 该函数负责初始化系统资源处理器，设置资源处理环境和参数
 * 
 * 原始函数名为FUN_180060200，现已重命名为InitializeSystemResourceHandler
 */
void InitializeSystemResourceHandler(void);

/**
 * @brief 验证系统资源上下文函数
 * 
 * 该函数负责验证系统资源上下文的有效性和完整性
 * 
 * 原始函数名为FUN_180060420，现已重命名为ValidateSystemResourceContext
 */
void ValidateSystemResourceContext(void);

/**
 * @brief 配置系统资源上下文函数
 * 
 * 该函数负责配置系统资源上下文，设置资源处理参数和属性
 * 
 * @param resourcePointer 资源指针
 * @param configFlag 配置标志
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * @param configurationMask 配置掩码
 * @return 配置结果状态
 * 
 * 原始函数名为FUN_18020eba0，现已重命名为ConfigureSystemResourceContext
 */
char ConfigureSystemResourceContext(void* resourcePointer, int configFlag, long long additionalParameter, long long configurationFlag, long long configurationMask);

/**
 * @brief 完成系统资源配置函数
 * 
 * 该函数负责完成系统资源的配置过程，进行最终的状态设置
 * 
 * 原始函数名为FUN_18020f530，现已重命名为FinalizeSystemResourceConfiguration
 */
void FinalizeSystemResourceConfiguration(void);

/**
 * @brief 清理系统资源处理器函数
 * 
 * 该函数负责清理系统资源处理器，释放相关资源
 * 
 * 原始函数名为FUN_18020e6c0，现已重命名为CleanupSystemResourceHandler
 */
void CleanupSystemResourceHandler(void);

/**
 * @brief 释放系统资源句柄函数
 * 
 * 该函数负责释放系统资源句柄，清理相关资源
 * 
 * @param resourceHandle 资源句柄
 * @param releaseFlag 释放标志
 * 
 * 原始函数名为FUN_18064e0d0，现已重命名为ReleaseSystemResourceHandle
 */
void ReleaseSystemResourceHandle(void* resourceHandle, int releaseFlag);

/**
 * @brief 处理系统资源数据函数
 * 
 * 该函数负责处理系统资源数据，进行数据的操作和管理
 * 
 * @param resourcePointer 资源指针
 * @param dataPointer 数据指针
 * @param resultPointer 结果指针
 * @param configurationFlag 配置标志
 * @param systemStatus 系统状态
 * @return 处理结果状态
 * 
 * 原始函数名为FUN_180060e40，现已重命名为ProcessSystemResourceData
 */
char ProcessSystemResourceData(void* resourcePointer, void* dataPointer, void* resultPointer, long long configurationFlag, long long systemStatus);

/**
 * @brief 验证系统资源状态函数
 * 
 * 该函数负责验证系统资源的当前状态
 * 
 * @return 系统资源状态
 * 
 * 原始函数名为FUN_180060a50，现已重命名为ValidateSystemResourceStatus
 */
char ValidateSystemResourceStatus(void);

