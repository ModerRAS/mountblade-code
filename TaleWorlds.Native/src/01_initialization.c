#include "TaleWorlds.Native.Split.h"

#define SYSTEM_EVENT_HANDLER_PRIMARY_ADDRESS    0x180c91700
#define SYSTEM_EVENT_HANDLER_SECONDARY_ADDRESS  0x180c91800
#define SYSTEM_FLOAT_TABLE_START_ADDRESS       0x180c8aa70
#define SYSTEM_FLOAT_TABLE_END_ADDRESS         0x180c8ea71
#define SYSTEM_FLOAT_TABLE_SECOND_START_ADDRESS 0x180c8eb70
#define SYSTEM_SECURITY_CONTEXT_ADDRESS        0x180d49d50
#define SYSTEM_MUTEX_PRIMARY_ADDRESS           0x180c96690
#define SYSTEM_MUTEX_SECONDARY_ADDRESS         0x180c966f0
#define SYSTEM_MUTEX_TERTIARY_ADDRESS          0x180c96740
#define SYSTEM_MEMORY_MANAGER_ADDRESS          0x180c0c340
#define SYSTEM_VTABLE_POINTER_ADDRESS          0x180c35590
#define SYSTEM_DATABASE_ADDRESS                0x180c4f510
#define SYSTEM_MUTEX_QUATERNARY_ADDRESS        0x180c82170
#define SYSTEM_CONTROLLER_ADDRESS               0x180c91060
#define SYSTEM_MUTEX_UNLOCK_ADDRESS            0x180c91970
#define SYSTEM_MUTEX_LOCK_ADDRESS              0x180c91288
#define SYSTEM_RESOURCE_STRING_ADDRESS         0x180d48d24
#define SYSTEM_STRING_OFFSET_ADDRESS           0x180c84871
#define SYSTEM_MUTEX_SECURITY_ADDRESS          0x180c91910
#define SYSTEM_DATA_CHECK_ADDRESS             0x180d49150

// SystemResourceManager结构体字段偏移量
#define SYSTEM_RESOURCE_DATA_POINTER_OFFSET    1
#define SYSTEM_RESOURCE_HASH_TABLE_OFFSET     2
#define SYSTEM_RESOURCE_FLAGS_OFFSET          4
#define SYSTEM_RESOURCE_MEMORY_POOL_OFFSET     5

// 系统节点相关常量
#define SYSTEM_NODE_ACTIVE_FLAG_OFFSET         0x19
#define SYSTEM_IDENTIFIER_SIZE                 0x10
#define SYSTEM_NODE_NEXT_POINTER_OFFSET       2
#define SYSTEM_NODE_HEAD_POINTER_OFFSET       0
#define SYSTEM_NODE_ALLOCATION_EXTRA_SIZE     0x20

// 系统节点结构体字段索引
#define SYSTEM_NODE_IDENTIFIER1_INDEX         6
#define SYSTEM_NODE_IDENTIFIER2_INDEX         7
#define SYSTEM_NODE_DATA_POINTER_INDEX        8
#define SYSTEM_NODE_FLAG_INDEX                 9
#define SYSTEM_NODE_HANDLER_INDEX            10
#define GAME_CORE_NODE_IDENTIFIER1             0x4fc124d23d41985f
#define GAME_CORE_NODE_IDENTIFIER2             0xe2f4a30d6e6ae482
#define BASE_ALLOCATOR_NODE_IDENTIFIER1       0x4770584fbb1df897
#define BASE_ALLOCATOR_NODE_IDENTIFIER2       0x47f249e43f66f2ab
#define BASE_ALLOCATOR_NODE_FLAG              1
#define SYSTEM_DATA_TABLE_NODE_IDENTIFIER1     0x544e41445441424c
#define SYSTEM_DATA_TABLE_NODE_IDENTIFIER2     0x4552455345525441
#define SYSTEM_DATA_TABLE_NODE_FLAG           2
#define SYSTEM_MEMORY_NODE_IDENTIFIER1         0x46ecbd4daf41613e
#define SYSTEM_MEMORY_NODE_IDENTIFIER2         0xdc42c056bbde8482
#define SYSTEM_MEMORY_NODE_FLAG               0
#define SYSTEM_ALLOCATOR_NODE_IDENTIFIER1      0x4c868a42644030f6
#define SYSTEM_ALLOCATOR_NODE_IDENTIFIER2      0xc29193aa9d9b35b9
#define SYSTEM_ALLOCATOR_NODE_FLAG            0
#define SYSTEM_CONFIGURATION_NODE_IDENTIFIER1  0x40ea3a798283cbbb
#define SYSTEM_CONFIGURATION_NODE_IDENTIFIER2  0x7f74eb2c5a7fadae
#define SYSTEM_CONFIGURATION_NODE_FLAG        3

// 位操作和数学计算相关常量
#define BitMask32Bit                        0x1f
#define MaxUnsigned32Bit                   0xffffffff
#define SystemIdentifierSize               0x10
#define NodeActiveFlagOffset                0x19
#define NodeAllocationExtraSize             0x20
#define SineLookupTableSize                0x7fff
#define QuadrantShiftBits                   0xd
#define SineTableOffset4CC                  0x4cc
#define SineTableOffset4132                 0x4132
#define SineTableOffsetFB34                0xfb34
#define SineTableOffset8132                 0x8132
#define TransformContextOffset218         0x218

// 系统标识符常量
#define SYSTEM_EVENT_NODE_IDENTIFIER1          0x45b8d074df27d12f
#define SYSTEM_EVENT_NODE_IDENTIFIER2          0x8d98f4c06880eda4
#define SYSTEM_RESOURCE_NODE_IDENTIFIER1       0x42d293584c8cf3e5
#define SYSTEM_RESOURCE_NODE_IDENTIFIER2       0x355ffeb2d29e668a
#define SYSTEM_DATA_COMPARISON_TEMPLATE_A_ID1   0x421c3cedd07d816d
#define SYSTEM_DATA_COMPARISON_TEMPLATE_A_ID2   0xbec25de793b7afa6
#define SYSTEM_DATA_COMPARISON_TEMPLATE_B_ID1   0x4c22bb0c326587ce
#define SYSTEM_DATA_COMPARISON_TEMPLATE_B_ID2   0x5e3cf00ce2978287
#define SYSTEM_DATA_COMPARISON_TEMPLATE_J_ID1   0x4b2d79e470ee4e2c
#define SYSTEM_DATA_COMPARISON_TEMPLATE_J_ID2   0x9c552acd3ed5548d
#define SYSTEM_DATA_COMPARISON_TEMPLATE_K_ID1   0x49086ba08ab981a7
#define SYSTEM_DATA_COMPARISON_TEMPLATE_K_ID2   0xa9191d34ad910696

// 数据比较模板标识符
#define SYSTEM_DATA_COMPARISON_TEMPLATE_D_ID1   0x406be72011d07d37
#define SYSTEM_DATA_COMPARISON_TEMPLATE_D_ID2   0x71876af946c867ab
#define SYSTEM_DATA_COMPARISON_TEMPLATE_E_ID1   0x449bafe9b77ddd3c
#define SYSTEM_DATA_COMPARISON_TEMPLATE_E_ID2   0xc160408bde99e59f
#define SYSTEM_DATA_COMPARISON_TEMPLATE_F_ID1   0x45425dc186a5d575
#define SYSTEM_DATA_COMPARISON_TEMPLATE_F_ID2   0xfab48faa65382fa5
#define SYSTEM_DATA_COMPARISON_TEMPLATE_G_ID1   0x40afa5469b6ac06d
#define SYSTEM_DATA_COMPARISON_TEMPLATE_G_ID2   0x2f4bab01d34055a5
#define SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1   0x43330a43fcdb3653
#define SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2   0xdcfdc333a769ec93
#define SYSTEM_DATA_COMPARISON_TEMPLATE_I_ID1   0x431d7c8d7c475be2
#define SYSTEM_DATA_COMPARISON_TEMPLATE_I_ID2   0xb97f048d2153e1b0
#define SYSTEM_DATA_COMPARISON_TEMPLATE_L_ID1   0x402feffe4481676e
#define SYSTEM_DATA_COMPARISON_TEMPLATE_L_ID2   0xd4c2151109de93a0
#define SYSTEM_DATA_COMPARISON_TEMPLATE_M_ID1   0x4384dcc4b6d3f417
#define SYSTEM_DATA_COMPARISON_TEMPLATE_M_ID2   0x92a15d52fe2679bd
#define SYSTEM_DATA_COMPARISON_TEMPLATE_N_ID1   0x4140994454d56503
#define SYSTEM_DATA_COMPARISON_TEMPLATE_N_ID2   0x399eced9bb5517ad
#define SYSTEM_DATA_COMPARISON_TEMPLATE_O_ID1   0x40db4257e97d3df8
#define SYSTEM_DATA_COMPARISON_TEMPLATE_O_ID2   0x81d539e33614429f
#define SYSTEM_MEMORY_COMPARISON_TEMPLATE_ID1   0x4e33c4803e67a08f
#define SYSTEM_MEMORY_COMPARISON_TEMPLATE_ID2   0x703a29a844ce399

// 系统参数常量
#define MaxSemaphoreCount                    0x7fffffff
#define StringBufferSize                     0x80
#define InvalidHandleValue                    0xfffffffffffffffe
#define SystemSemaphoreMaxCount              0x7fffffff
#define SystemEventHandlerSize               0x20
#define SystemEventHandlerCapacity          8

/**
 * @brief 处理系统内存页面
 * 
 * 处理系统内存页面，包括页面分配、映射和管理操作。
 * 用于系统内存管理的基础操作。
 * 
 * @param MemoryAddress 内存地址，指定要处理的内存页面位置
 * @return 无返回值
 */
void ProcessSystemMemoryPage(long long memoryAddress);

/**
 * @brief 释放系统资源
 * 
 * 释放系统资源，包括内存、句柄和对象。
 * 用于系统资源的清理和回收。
 * 
 * @return 无返回值
 */
void ReleaseSystemResource(void);

/**
 * @brief 初始化系统内存缓冲区
 * 
 * 初始化系统内存缓冲区，设置缓冲区参数和属性。
 * 用于系统内存缓冲区的配置和准备工作。
 * 
 * @param MemoryTemplate 内存模板，用于初始化缓冲区的模板数据
 * @param BufferSize 缓冲区大小，指定缓冲区的大小
 * @param SourceData 源数据，用于初始化缓冲区的数据源
 * @return 无返回值
 */
void InitializeSystemMemoryBuffer(void* memoryTemplate, long long bufferSize, void* sourceData);

/**
 * @brief 写入数据到缓冲区
 * 
 * 将数据写入到指定的缓冲区中，支持可变参数。
 * 用于系统数据的写入和存储操作。
 * 
 * @param Buffer 缓冲区指针，指定要写入数据的缓冲区
 * @param DataSize 数据大小，指定要写入的数据大小
 * @param ... 可变参数，表示要写入的数据
 * @return 无返回值
 */
void WriteDataToBuffer(void* buffer, long long dataSize, ...);

/**
 * @brief 初始化系统内存分配器
 * 
 * 初始化系统内存分配器，设置分配策略和参数。
 * 用于系统内存分配的配置和准备工作。
 * 
 * @param memoryHandle 内存句柄，指定要初始化的内存分配器句柄
 * @param bufferContext 缓冲区上下文，包含缓冲区的相关信息
 * @return 分配器指针，返回初始化后的内存分配器指针
 */
void* InitializeSystemMemoryAllocator(long long memoryHandle, void* bufferContext);

/**
 * @brief 初始化系统数据
 * 
 * 初始化系统数据，设置数据结构和属性。
 * 用于系统数据的配置和准备工作。
 * 
 * @param dataContext 数据上下文，包含要初始化的数据相关信息
 * @param templateContext 模板上下文，包含数据模板的相关信息
 * @return 无返回值
 */
void InitializeSystemData(void* dataContext, void* templateContext);

/**
 * @brief 验证系统配置
 * 
 * 验证系统配置的有效性和完整性。
 * 用于系统配置的安全检查和验证。
 * 
 * @param configFlags 配置标志，指定要验证的配置项
 * @param configContext 配置上下文，包含配置的相关信息
 * @return 验证结果，返回0表示成功，非0表示失败
 */
int ValidateSystemConfiguration(long long configFlags, void* configContext);

/**
 * @brief 获取系统状态标志
 * 
 * 获取系统的状态标志，用于监控系统运行状态。
 * 用于系统状态的管理和监控。
 * 
 * @return 系统状态标志，返回当前系统的状态标志位
 */
long long GetSystemStatusFlags(void);

/**
 * @brief 配置系统数据
 * 
 * 配置系统数据，设置数据参数和属性。
 * 用于系统数据的配置和管理。
 * 
 * @param bufferAddress 缓冲区地址，指定要配置的数据缓冲区
 * @param configData 配置数据，包含配置的相关信息
 * @param contextPointer 上下文指针，包含上下文相关信息
 * @param parameterArray 参数数组，包含配置参数的相关信息
 * @return 无返回值
 */
void ConfigureSystemData(void* bufferAddress, void* configData, void* contextPointer, void* parameterArray);

/**
 * @brief 释放系统资源
 * 
 * 释放系统资源，包括内存、句柄和对象。
 * 用于系统资源的清理和回收。
 * 
 * @param resourcePointer 资源指针，指定要释放的系统资源
 * @return 无返回值
 */
void ReleaseSystemResources(void* resourcePointer);

/**
 * @brief 初始化系统缓冲区
 * 
 * 初始化系统缓冲区，设置缓冲区参数和属性。
 * 用于系统缓冲区的配置和准备工作。
 * 
 * @param bufferAddress 缓冲区地址，指定要初始化的缓冲区
 * @param initFlag 初始化标志，指定初始化的方式和选项
 * @param parameter 参数，包含初始化所需的参数信息
 * @return 无返回值
 */
void InitializeSystemBuffer(void* bufferAddress, int initFlag, int parameter);

/**
 * @brief 更新系统数据
 * 
 * 更新系统数据，刷新数据内容和状态。
 * 用于系统数据的维护和更新。
 * 
 * @param dataPointer 数据指针，指定要更新的系统数据
 * @return 无返回值
 */
void UpdateSystemData(void* dataPointer);

/**
 * @brief 验证系统内存分配
 * 
 * 验证系统内存分配的有效性和完整性。
 * 用于系统内存管理的安全检查和验证。
 * 
 * @param memoryContext 内存上下文指针
 * @return 验证结果状态码，返回0表示成功，非0表示失败
 */
char ValidateSystemMemoryAllocation(void* memoryContext);

/**
 * @brief 分配系统内存资源
 * 
 * 分配系统内存资源，设置内存池和分配策略。
 * 用于系统内存管理的前期准备工作。
 * 
 * @param memoryContext 内存上下文指针
 * @param allocationBuffer 分配缓冲区指针
 * @return 无返回值
 */
void AllocateSystemMemoryResources(void* memoryContext, void* allocationBuffer);

/**
 * @brief 配置系统数据缓冲区
 * 
 * 配置系统数据缓冲区，设置缓冲区参数和属性。
 * 用于系统数据缓冲区的配置和管理。
 * 
 * @param bufferContext 缓冲区上下文指针
 * @param configTemplate 配置模板指针
 * @param dataSource 数据源指针
 * @return 无返回值
 */
void ConfigureSystemDataBuffer(void* bufferContext, void* configTemplate, void* dataSource);

/**
 * @brief 系统内存分配释放函数
 * 
 * 该函数负责释放系统内存分配，清理内存和句柄
 * 用于系统内存资源的清理和释放
 * 
 * @param memoryContext 内存上下文指针
 */
void ReleaseSystemMemoryAllocation(void* memoryContext);

/**
 * @brief 系统内存状态检查函数
 * 
 * 该函数负责检查系统内存状态，监控内存使用情况
 * 用于系统内存状态的管理和监控
 * 
 * @param memoryContext 内存上下文指针
 * @return 检查结果状态码
 */
char CheckSystemMemoryStatus(void* memoryContext);

/**
 * @brief 系统操作执行函数
 * 
 * 该函数负责执行系统操作，处理系统级别的各种操作
 * 用于系统操作的管理和执行
 * 
 * @param operationContext 操作上下文指针
 * @param parameterBuffer 参数缓冲区指针
 * @param operationId 操作ID
 * @param operationFlags 操作标志
 */
void ExecuteSystemOperation(void* operationContext, void* parameterBuffer, int operationId, uint operationFlags);

/**
 * @brief 系统数据传输处理函数
 * 
 * 该函数负责处理系统数据传输，管理数据流和传输操作
 * 用于系统数据传输的管理和控制
 * 
 * @param sourceContext 源上下文指针
 * @param targetContext 目标上下文指针
 */
void ProcessSystemDataTransfer(void* sourceContext, void* targetContext);

/**
 * @brief 系统数据指针获取函数
 * 
 * 该函数负责获取系统数据指针，提供数据访问接口
 * 用于系统数据的访问和管理
 * 
 * @param dataIndex 数据索引
 * @return 数据指针
 */
void* GetSystemDataPointer(int dataIndex);

/**
 * @brief 系统配置初始化函数
 * 
 * 该函数负责初始化系统配置，设置配置参数和属性
 * 用于系统配置的前期准备工作
 * 
 * @param configContext 配置上下文指针
 * @param configFlags 配置标志
 * @param primaryConfigParam 主要配置参数
 * @param secondaryConfigParam 次要配置参数
 */
void InitializeSystemConfiguration(void* configContext, int configFlags, int primaryConfigParam, int secondaryConfigParam);

/**
 * @brief 系统数据字段设置函数
 * 
 * 该函数负责设置系统数据字段，配置数据结构和属性
 * 用于系统数据字段的配置和管理
 * 
 * @param dataFieldContext 数据字段上下文指针
 * @param fieldValue 字段值
 * @param additionalParameter 额外参数
 */
void SetupSystemDataField(void* dataFieldContext, uint fieldValue, uint additionalParameter);

/**
 * @brief 系统初始化完成函数
 * 
 * 该函数负责完成系统初始化，执行最后的初始化操作
 * 用于系统初始化的收尾工作
 */
void FinalizeSystemInitialization(void);

/**
 * @brief 游戏系统主入口点
 * 
 * 这是整个游戏系统的主要入口点，负责初始化和管理所有核心系统组件
 */
void* GameSystemMainEntryPoint;
void* SystemGlobalDataReference;              // 全局系统数据引用
void* SystemPrimaryMemoryPool;                // 主系统内存池
void* SystemPrimaryDataTable;                 // 系统数据表引用
void* SystemBackupMemoryPool;                  // 备份系统内存池
void* SystemBackupDataTable;                   // 备份系统数据表
void* SystemCacheMemoryPool;                   // 缓存系统内存池
void* SystemCacheDataTable;                    // 缓存系统数据表
void* SystemTemporaryMemoryPool;              // 临时系统内存池
void* SystemTemporaryDataTable;               // 临时系统数据表
void* SystemReservedMemoryPool;               // 保留系统内存池
void* SystemReservedDataTable;                // 保留系统数据表
void* SystemEmergencyMemoryPool;              // 紧急系统内存池
void* SystemEmergencyDataTable;               // 紧急系统数据表

// 核心系统函数指针和相关数据
/**
 * @brief 游戏核心系统主入口点
 * 
 * 负责初始化游戏的核心系统组件，包括物理引擎、渲染系统等
 */
void* GameCoreSystemMainEntryPoint;
void* CoreSystemMemoryAllocator;                // 核心系统内存分配器
void* CoreSystemDataTable;                     // 核心系统数据表
void* CoreSystemMemoryBuffer;                  // 核心系统内存缓冲区
void* CoreSystemPrimaryConfiguration;           // 核心系统主配置
void* CoreSystemBackupConfiguration;           // 核心系统备份配置
void* CoreSystemCacheConfiguration;            // 核心系统缓存配置
void* CoreSystemEmergencyConfiguration;        // 核心系统紧急配置

void* PhysicsSystemPointer;                     // 物理系统指针
void* NetworkSystemPointer;                     // 网络系统指针
void* GameLogicSystemPointer;                   // 游戏逻辑系统指针
void* UISystemPointer;                          // UI系统指针

/**
 * @brief 游戏渲染系统主入口点
 * 
 * 负责初始化和管理游戏的渲染系统，包括图形管线、着色器等
 */
void* GameRenderingMainEntryPoint;
void* RenderingSystemContext;                   // 渲染系统上下文

/**
 * @brief 游戏网络系统主入口点
 * 
 * 负责初始化和管理游戏的网络系统，包括网络连接、数据传输等
 */
void* GameNetworkMainEntryPoint;
void* NetworkSystemContext;                     // 网络系统上下文

/**
 * @brief 游戏音频系统主入口点
 * 
 * 负责初始化和管理游戏的音频系统，包括音效播放、音乐管理等
 */
void* GameAudioMainEntryPoint;
void* AudioSystemContext;                       // 音频系统上下文

/**
 * @brief 游戏输入系统主入口点
 * 
 * 负责初始化和管理游戏的输入系统，包括键盘、鼠标、手柄等输入设备
 */
void* GameInputMainEntryPoint;
void* InputSystemDataBuffer;                    // 输入系统数据缓冲区
void* InputSystemEventQueueManager;              // 输入系统事件队列管理器
void* InputSystemCurrentStateData;               // 输入系统当前状态数据
void* InputSystemDeviceManager;                  // 输入系统设备管理器
void* InputSystemKeyMappingTable;                 // 输入系统按键映射表
void* InputSystemAxisMappingTable;               // 输入系统轴映射表
void* InputSystemActionBindingsTable;            // 输入系统动作绑定表
void* InputSystemConfiguration;                  // 输入系统配置
void* GameSubsystemMainEntryPoint;              // 游戏子系统主入口点
void* SubsystemMainContext;                     // 子系统主上下文
void* InputSystemDataTable;                     // 输入系统数据表
uint8_t InputSystemStatusFlags;                  // 输入系统状态标志
void* InputSystemMainConfiguration;             // 输入系统主配置
void* InputSystemDeviceConfigurationTable;      // 输入系统设备配置表
void* InputSystemMappingConfigurationTable;     // 输入系统映射配置表
void* InputSystemProfileConfigurationTable;      // 输入系统配置文件表

// 物理系统初始化函数
/**
 * @brief 游戏物理系统主入口点
 * 
 * 负责初始化和管理游戏的物理系统，包括碰撞检测、物理模拟等
 */
void* GamePhysicsMainEntryPoint;
void* PhysicsSystemContext;                      // 物理系统上下文

// 文件系统初始化函数
/**
 * @brief 游戏文件系统主入口点
 * 
 * 负责初始化和管理游戏的文件系统，包括文件读写、资源加载等
 */
void* GameFileSystemMainEntryPoint;

// 字符串处理系统初始化
void* GameStringProcessingMainInitializer;       // 游戏字符串处理主初始化器
void* StringProcessingDataBuffer;                // 字符串处理数据缓冲区
void* StringProcessingMainStructure;              // 字符串处理主结构
void* StringProcessingBackupStructure;            // 字符串处理备份结构
void* StringProcessingCacheStructure;             // 字符串处理缓存结构
void* StringProcessingTemporaryStructure;         // 字符串处理临时结构
void* StringProcessingSecurityCheckHandler;       // 字符串处理安全检查处理器

// 内存管理系统初始化
void* GameMemoryManagementMainInitializer;       // 游戏内存管理主初始化器

// 系统资源管理器初始化
void* GameResourceManagementMainInitializer;     // 游戏资源管理主初始化器
void* ResourceMemoryRegionMain;                   // 资源内存区域主分区
void* ResourceMemoryRegionBackup;                 // 资源内存区域备份分区
void* ResourceMemoryRegionCache;                  // 资源内存区域缓存分区
void* ResourceMemoryRegionTemporary;              // 资源内存区域临时分区
void* ResourceMemoryRegionReserved;               // 资源内存区域保留分区
void* ResourceMemoryRegionEmergency;              // 资源内存区域紧急分区
void* ResourceMemoryRegionSystem;                 // 资源内存区域系统分区
void* ResourceMemoryRegionUser;                   // 资源内存区域用户分区
void* ResourceMemoryRegionShared;                 // 资源内存区域共享分区
void* ResourceMemoryRegionProtected;              // 资源内存区域保护分区
void* ResourceMemoryRegionSecure;                 // 资源内存区域安全分区
void* ResourceFunctionPointerMain;                // 资源函数指针主入口
void* ResourceFunctionPointerBackup;              // 资源函数指针备份入口
void* ResourceMemoryRegionDebug;                  // 资源内存区域调试分区
void* ResourceMemoryRegionTest;                   // 资源内存区域测试分区
void* ResourceMemoryRegionDevelopment;            // 资源内存区域开发分区
void* ResourceMemoryRegionProduction;             // 资源内存区域生产分区
void* ResourceSystemGlobalConstant;                // 资源系统全局常量
void* ResourceDataBufferBackup;                   // 资源数据缓冲区备份区域
/**
 * @brief 资源数据表备份
 */
void* ResourceDataTableBackup;

/**
 * @brief 资源内存区域暂存区
 */
void* ResourceMemoryRegionStaging;

/**
 * @brief 资源数据表缓存
 */
void* ResourceDataTableCache;

/**
 * @brief 资源内存区域存档区
 */
void* ResourceMemoryRegionArchive;

/**
 * @brief 资源数据表临时区
 */
void* ResourceDataTableTemporary;

/**
 * @brief 资源入口点主函数
 */
void* ResourceEntryPointMain;

/**
 * @brief 资源内存区域遗留区
 */
void* ResourceMemoryRegionLegacy;

/**
 * @brief 资源内存区域未来扩展区
 */
void* ResourceMemoryRegionFuture;

/**
 * @brief 资源内存区域实验区
 */
void* ResourceMemoryRegionExperimental;

/**
 * @brief 资源内存区域已废弃区
 */
void* ResourceMemoryRegionDeprecated;

/**
 * @brief 资源系统状态标志
 */
int ResourceSystemOperationalStatus;

/**
 * @brief 资源系统时间戳
 */
long long ResourceSystemLastUpdateTime;

/**
 * @brief 资源内存区域热修复区
 */
void* ResourceMemoryRegionHotfix;

// 函数: 系统初始化函数D - 数据表管理器初始化
void* GameDataTableManagerInitializer;
/**
 * @brief 系统内存区域扩展A
 */
void* SystemMemoryRegionExpansionAlpha;
/**
 * @brief 系统内存区域扩展B
 */
void* SystemMemoryRegionExpansionBeta;
void* SystemDataTableEmergency;                  // 紧急系统数据表
/**
 * @brief 系统内存区域扩展C
 */
void* SystemMemoryRegionExpansionC;

/**
 * @brief 系统内存区域扩展D
 */
void* SystemMemoryRegionExpansionD;

/**
 * @brief 系统内存区域扩展E
 */
void* SystemMemoryRegionExpansionE;

/**
 * @brief 系统内存区域扩展F
 */
void* SystemMemoryRegionExpansionF;

/**
 * @brief 系统内存区域扩展G
 */
void* SystemMemoryRegionExpansionG;

/**
 * @brief 系统内存区域扩展H
 */
void* SystemMemoryRegionExpansionH;

/**
 * @brief 系统内存区域扩展I
 */
void* SystemMemoryRegionExpansionI;
void* SystemDataTableHotfix;                     // 热修复系统数据表
void* SystemMemoryRegionExpansionJ;
void* SystemMemoryRegionExpansionK;
void* SystemMemoryRegionExpansionL;
void* SystemMemoryRegionExpansionM;
void* SystemMemoryRegionExpansionN;
void* SystemMemoryRegionExpansionO;
void* SystemMemoryRegionExpansionP;
void* SystemDataTableLegacy;                     // 遗留系统数据表
void* SystemMemoryRegionExpansionQ;
void* SystemMemoryRegionExpansionR;
void* SystemMemoryRegionExpansionS;
void* SystemMemoryRegionExpansionT;
void* SystemMemoryRegionExpansionU;
void* SystemMemoryRegionExpansionV;
void* SystemMemoryRegionExpansionW;
/**
 * @brief 系统数据指针主指针
 */
void* SystemDataPointerMain;

/**
 * @brief 系统数据指针备份指针
 */
void* SystemDataPointerBackup;

/**
 * @brief 系统数据指针缓存指针
 */
void* SystemDataPointerCache;

/**
 * @brief 系统数据指针临时指针
 */
void* SystemDataPointerTemporary;

/**
 * @brief 系统数据指针保留指针
 */
void* SystemDataPointerReserved;

/**
 * @brief 系统数据指针安全指针
 */
void* SystemDataPointerSecure;
/**
 * @brief 系统数据表条目主条目
 */
void* SystemDataTableEntryMain;

/**
 * @brief 系统数据表条目备份条目
 */
void* SystemDataTableEntryBackup;

/**
 * @brief 系统状态标志主标志
 */
char SystemPrimaryStatusFlag;

/**
 * @brief 系统状态标志备份标志
 */
char SystemBackupStatusFlag;

/**
 * @brief 系统状态标志缓存标志
 */
char SystemCacheStatusFlag;

/**
 * @brief 系统状态标志临时标志
 */
char SystemTemporaryStatusFlag;
/**
 * @brief 系统内存块主块
 */
void* SystemMemoryBlockMain;
void* SystemMemoryBlockBackup;
void* SystemMemoryBlockCache;
void* SystemMemoryBlockTemporary;
void* SystemMemoryBlockReserved;
void* SystemDataTableEntryCache;
void* SystemMemoryBlockSecure;
void* SystemMemoryBlockProtected;
void* SystemMemoryBlockShared;
void* SystemMemoryBlockUser;
void* SystemMemoryBlockKernel;
void* SystemMemoryBlockDriver;
void* SystemMemoryBlockFirmware;
void* SystemMemoryBootBlock;
void* SystemMemoryBlockRecovery;
void* SystemMemoryBlockDiagnostic;
void* SystemFunctionPointerCache;
void* SystemFunctionPointerTemporary;
void* SystemMemoryBlockHibernation;
void* SystemMemoryBlockCrashDump;
void* SystemMemoryPageFile;
void* SystemDataTableEntryTemporary;
void* SystemDataTableEntryReserved;
void* SystemMemoryBlockStandby;
void* SystemMemoryBlockSleep;
long long SystemPrimaryTimestamp;
void* SystemDataTableEntryEmergency;
void* SystemMemoryBlockHybrid;
void* SystemMemoryBlockFastStartup;
unsigned long long SystemPrimaryMemorySize;
unsigned long long SystemBackupMemorySize;
unsigned long long SystemCacheMemorySize;
uint8_t SystemPrimaryByteValue;
uint8_t SystemBackupByteValue;
uint8_t SystemCacheByteValue;
long long SystemBackupTimestamp;
bool SystemFlagMain;
void* SystemMemoryBlockCompression;
void* SystemMemoryBlockEncryption;
void* SystemMemoryBlockVirtualization;
void* SystemMemoryBlockSandbox;
char SystemStatusFlagReserved;
void* SystemFunctionPointerReserved;
void* SystemMemoryBlockSnapshot;
void* SystemMemoryBlockCheckpoint;
void* SystemMemoryBlockRollback;
bool SystemFlagBackup;
void* SystemMemoryBlockMirror;
void* SystemMemoryBlockReplica;
void* SystemMemoryBlockShadow;
void* SystemMemoryBlockClone;
char SystemStatusFlagSecure;
void* SystemMemoryBlockVault;
void* SystemMemoryBlockSafe;
void* SystemMemoryBlockLockbox;
void* SystemMemoryBlockArchivePrimary;
void* SystemMemoryBlockArchiveSecondary;
void* SystemMemoryBlockArchiveTertiary;
void* SystemMemoryBlockArchiveQuaternary;
char SystemStatusFlagProtected;
void* SystemDataTableEntrySystem;
void* SystemMemoryBlockArchiveQuinary;
void* SystemDataTableEntryKernel;
void* SystemMemoryBlockArchiveSenary;
void* SystemMemoryBlockArchiveSeptenary;
void* SystemMemoryBlockArchiveOctonary;
void* SystemMemoryBlockArchiveNonary;
void* SystemMemoryBlockArchiveDenary;
void* SystemMemoryBlockArchiveUndenary;
void* SystemMemoryBlockArchiveDuodenary;
void* SystemMemoryBlockArchiveTridenary;
void* SystemMemoryBlockArchiveQuattuordenary;
void* SystemMemoryBlockArchiveQuindenary;
void* SystemMemoryBlockArchiveP;
void* SystemMemoryBlockArchiveQ;
void* SystemMemoryBlockArchiveR;
void* SystemMemoryBlockArchiveS;
void* SystemMemoryBlockArchiveT;
void* SystemMemoryBlockArchiveU;
void* SystemMemoryBlockArchiveV;
void* SystemMemoryBlockArchiveW;
void* SystemFunctionPointerEmergency;

// 函数: 系统初始化入口点A
/**
 * @brief 系统初始化入口点A
 * 
 * 该函数是系统初始化的主要入口点之一，负责初始化系统的核心组件
 * 和数据结构，为后续的系统启动做准备
 */
void* SystemInitializationEntryPointAlpha;
void* SystemMemoryRegionReservedAlpha;
void* SystemMemoryRegionReservedBeta;
void* SystemMemoryRegionReservedGamma;
void* SystemDataTableEntryDriver;
void* SystemMemoryRegionReservedDelta;
void* SystemMemoryRegionReservedEpsilon;
void* SystemDataTableEntryFirmware;

// 函数: 系统初始化入口点B
/**
 * @brief 系统初始化入口点B
 * 
 * 该函数是系统初始化的另一个入口点，负责处理特定的系统组件
 * 初始化任务，与入口点A协同工作
 */
void* SystemInitializationEntryPointBeta;
void* SystemMemoryRegionExtendedSix;

// 函数: 系统初始化入口点C
/**
 * @brief 系统初始化入口点C
 * 
 * 该函数负责系统初始化过程中的特定任务，通常与内存管理
 * 或资源分配相关
 */
void* SystemInitializationEntryPointGamma;

// 函数: 系统初始化入口点D
/**
 * @brief 系统初始化入口点D
 * 
 * 该函数负责系统初始化过程中的设备检测和配置
 */
void* SystemInitializationEntryPointDelta;

// 函数: 系统初始化入口点E
/**
 * @brief 系统初始化入口点E
 * 
 * 该函数负责系统初始化过程中的网络组件配置
 */
void* SystemInitializationEntryPointEpsilon;
void* SystemMemoryRegionExtendedSeven;
void* SystemMemoryRegionExtendedEight;
void* SystemMemoryRegionExtendedNine;
void* SystemMemoryRegionExtendedTwoHundred;
void* SystemMemoryRegionExtendedTwoHundredOne;
void* SystemMemoryRegionExtendedTwoHundredTwo;

// 函数: 系统初始化入口点F
/**
 * @brief 系统初始化入口点F
 * 
 * 该函数负责系统初始化过程中的音频组件配置
 */
void* SystemInitializationEntryPointZeta;
void* SystemMemoryRegionTwoHundredThree;
void* SystemMemoryRegionTwoHundredFour;
void* SystemMemoryRegionTwoHundredFive;
void* SystemMemoryRegionExtendedTwoHundredSix;
char SystemStatusFlagEighth;
void* SystemMemoryRegionExtendedTwoHundredSeven;
void* SystemMemoryRegionExtendedTwoHundredEight;
void* SystemDataTableEntryTwelfth;
void* SystemMemoryRegionExtendedTwoHundredNine;
void* SystemMemoryRegionExtendedThreeHundred;
void* SystemMemoryRegionExtendedThreeHundredOne;
// 系统全局数据常量块
// 系统配置和状态数据块
void* SystemGlobalDataConfigBlockPrimary;
void* SystemGlobalDataConfigBlockSecondary;
void* SystemGlobalDataConfigBlockTertiary;
void* SystemGlobalDataConfigBlockQuaternary;
void* SystemGlobalDataConfigBlockQuinary;
void* SystemMemoryConfigDataTablePrimary;
void* SystemMemoryConfigDataTableSecondary;
void* SystemMemoryConfigDataTableTertiary;
void* SystemMemoryConfigDataTableQuaternary;
void* SystemInitializationStatusBlockPrimary;
void* SystemInitializationStatusBlockSecondary;
void* SystemInitializationStatusBlockTertiary;
void* SystemInitializationStatusBlockQuaternary;
void* SystemPerformanceMetricsBlockPrimary;
void* SystemPerformanceMetricsBlockSecondary;
void* SystemPerformanceMetricsBlockTertiary;
uint32_t SystemGlobalConfigurationFlag;
void* SystemMemoryAllocatorState;
uint32_t SystemMemoryPoolSize;
uint32_t SystemMemoryPoolAlignment;
uint32_t SystemMemoryPoolAttributes;
void* SystemMemoryPoolConfiguration;
void* SystemInitializationProgressStatus;

// 系统内存分配器 - 负责动态内存分配和管理

// 系统数据比较模板和节点指针
void* SystemDataComparisonTemplateA;  // 系统数据比较模板A
void* SystemDataComparisonTemplateB;  // 系统数据比较模板B
void* SystemDataComparisonTemplateC;  // 系统数据比较模板C
void* SystemDataComparisonTemplateD;  // 系统数据比较模板D
void* SystemDataComparisonTemplateE;  // 系统数据比较模板E
void* SystemDataComparisonTemplateF;  // 系统数据比较模板F
void* SystemDataComparisonTemplateG;  // 系统数据比较模板G
void* SystemDataComparisonTemplateH;  // 系统数据比较模板H
void* SystemDataComparisonTemplateI;  // 系统数据比较模板I
void* SystemDataComparisonTemplateJ;  // 系统数据比较模板J
void* SystemDataComparisonTemplateK;  // 系统数据比较模板K
void* SystemDataComparisonTemplateL;  // 系统数据比较模板L
void* SystemDataComparisonTemplateM;  // 系统数据比较模板M
void* SystemDataComparisonTemplateN;  // 系统数据比较模板N
void* SystemDataComparisonTemplateO;  // 系统数据比较模板O

// 系统内存分配表条目 - 用于存储内存分配的结果
void* SystemMemoryAllocationTableEntryPrimary;
void* SystemMemoryAllocationTableEntrySecondary;
void* SystemMemoryAllocationTableEntryTertiary;
void* SystemMemoryAllocationTableEntryQuaternary;
void* SystemMemoryAllocationTableEntryQuinary;
void* SystemMemoryAllocationTableEntrySenary;
void* SystemMemoryAllocationTableEntrySeptenary;
void* SystemMemoryAllocationTableEntryOctonary;
void* SystemMemoryAllocationTableEntryNonary;
void* SystemMemoryAllocationTableEntryDenary;
void* SystemMemoryAllocationTableEntryUndenary;
void* SystemMemoryAllocationTableEntryDuodenary;
void* SystemMemoryAllocationTableEntryTridenary;
void* SystemMemoryAllocationTableEntryQuattuordenary;
void* SystemMemoryAllocationTableEntryQuindenary;
void* SystemMemoryAllocationTableEntrySexdenary;
void* SystemMemoryAllocationTableEntrySeptendecenary;
void* SystemMemoryAllocationTableEntryOctodecenary;

void* SystemDataNodePrimaryRoot;       // 系统数据节点主根节点
void* SystemDataNodeSecondaryRoot;     // 系统数据节点次根节点
void* SystemDataNodeTertiaryRoot;      // 系统数据节点第三根节点
void* SystemDataNodeQuaternaryRoot;    // 系统数据节点第四根节点
void* SystemDataNodeQuinaryRoot;       // 系统数据节点第五根节点
void* SystemDataNodePrimary;           // 系统数据节点主节点
void* SystemDataNodeSecondary;         // 系统数据节点次节点
void* SystemDataNodeTertiary;          // 系统数据节点第三节点
void* SystemDataNodeQuaternary;        // 系统数据节点第四节点
void* SystemDataNodeQuinary;           // 系统数据节点第五节点
void* SystemDataNodeSenary;            // 系统数据节点第六节点
void* SystemDataNodeSeptenary;         // 系统数据节点第七节点
void* SystemDataNodeOctonary;          // 系统数据节点第八节点
void* SystemDataNodeNonary;            // 系统数据节点第九节点
void* SystemDataNodeDenary;            // 系统数据节点第十节点
void* SystemDataNodeUndenary;          // 系统数据节点第十一节点
void* SystemDataNodeDuodenary;         // 系统数据节点第十二节点
void* SystemDataNodeTridenary;         // 系统数据节点第十三节点
void* SystemDataNodeQuattuordenary;    // 系统数据节点第十四节点
void* SystemDataNodeQuindenary;        // 系统数据节点第十五节点
void* SystemDataNodeSexdenary;         // 系统数据节点第十六节点
void* SystemDataNodeLinkageTable;                // 系统数据节点链接表
void* SystemDataNodeLinkageManager;               // 系统数据节点链接管理器
void* SystemDataNodeLinkageHandler;               // 系统数据节点链接处理器
void* SystemConfigurationDataTemplate;  // SystemConfigurationTemplate
void* SystemStringTemplate;  // SystemStringTemplate
void* SystemDataTemplate;  // SystemDataTemplate
void* SystemDataNodeLinkageCache;                // 系统数据节点链接缓存
void* SystemDataNodeLinkageBackup;                // 系统数据节点链接备份
void* SystemDataNodeLinkagePrimary;               // 系统数据节点链接主表
void* SystemDataNodeLinkageSecondary;             // 系统数据节点链接次表
// 系统数据比较模板变量已在上面声明
void* SystemDataNodeLinkageTertiary;              // 系统数据节点链接第三表
void* SystemDataNodeLinkageQuaternary;            // 系统数据节点链接第四表
void* SystemDataNodeLinkageQuinary;               // 系统数据节点链接第五表
void* SystemConfigDataPointerGamma;        // 系统配置数据指针Gamma
void* SystemConfigDataPointerEta;        // 系统配置数据指针Eta
void* SystemResourceTemplate;        // 系统资源模板
void* SystemDebugStatusFlag;  // 系统调试状态标志
void* SystemStringBuffer;        // 系统字符串缓冲区
void* SystemNodeLinkPointerPrimary;        // 系统节点链接指针主表
void* SystemNodeLinkPointerSecondary;        // 系统节点链接指针次表
void* SystemRootNodePointer;         // 系统根节点指针

// 系统初始化状态变量
uint32_t SystemInitializationStatusCode;      // 系统初始化状态码
uint32_t SystemInitializationProgress;       // 系统初始化进度
uint32_t SystemInitializationErrorFlag;       // 系统初始化错误标志
uint32_t SystemInitializationMemoryStatus;   // 系统初始化内存状态
uint32_t SystemInitializationThreadStatus;    // 系统初始化线程状态
uint32_t SystemInitializationResourceStatus; // 系统初始化资源状态

// 系统内存状态标志变量
uint32_t SystemMemoryStatusFlagPrimary;      // 系统内存状态标志主标志
uint32_t SystemMemoryStatusFlagSecondary;      // 系统内存状态标志次标志

// 系统回调函数指针
void* SystemEventNotificationHandler;     // SystemEventNotificationHandler
void* SystemInitializationHandlerPrimary;  // SystemInitializationHandlerA
void* SystemInitializationHandlerSecondary;  // SystemInitializationHandlerB
void* SystemDebugMessageHandler;            // SystemDebugMessageHandler
void* SystemEventProcessor;            // SystemEventProcessor
void* SystemNetworkEventHandler;          // SystemNetworkEventHandler
void* SystemGlobalDataManager;      // SystemGlobalDataManager

// 系统全局数据指针
void* SystemGlobalDataReference;        // SystemGlobalDataReference
void* SystemGlobalDataSecondary;        // SystemGlobalDataSecondary
void* SystemGlobalDataTertiary;        // SystemGlobalDataTertiary

// 系统配置数据指针
void* SystemConfigDataPrimary;        // SystemConfigDataPointerA
void* SystemConfigDataSecondary;        // SystemConfigDataPointerB
void* SystemConfigDataTertiary;        // SystemConfigDataPointerC
void* SystemConfigDataQuaternary;        // SystemConfigDataPointerD
void* SystemConfigDataQuinary;        // SystemConfigDataSecondary
void* SystemConfigDataSenary;        // SystemConfigDataTertiary
void* SystemSemaphoreInstance;            // 系统信号量实例
/**
 * @brief 系统内存分配器函数
 * 
 * 负责动态内存分配和管理，包括内存分配、释放和重新分配操作
 */
void* SystemMemoryAllocatorFunction;

// 函数: 系统数据初始化器 - 负责初始化系统核心数据结构
/**
 * @brief 系统数据初始化器函数
 * 
 * 负责初始化系统核心数据结构，设置系统运行所需的基本数据
 */
void* SystemDataInitializerFunction;
void* SystemDataBufferPrimary;
void* SystemDataBufferSecondary;
void* SystemDataBufferTertiary;
void* SystemDataBufferQuaternary;
void* SystemDataBufferQuinary;
void* SystemDataBufferSenary;
void* SystemDataTablePrimary;
void* SystemDataTableSecondary;                // 次级系统数据表
void* SystemDataStructurePrimary;
void* SystemDataStructureSecondary;
void* SystemMemoryRegionPrimary;
void* SystemMemoryRegionSecondary;
void* SystemMemoryRegionTertiary;
void* SystemMemoryRegionQuaternary;
void* SystemMemoryRegionQuinary;
void* SystemMemoryRegionSenary;
void* SystemConfigurationDataPrimary;
void* SystemConfigurationDataSecondary;
void* SystemConfigurationDataTertiary;
void* SystemConfigurationDataQuaternary;
void* SystemConfigurationDataQuinary;
void* SystemConfigurationDataSenary;
// 系统数据缓冲区
void* SystemDataBufferPrimaryFirst;
void* SystemDataBufferPrimarySecond;
void* SystemDataBufferPrimaryThird;
void* SystemDataBufferPrimaryFourth;
void* SystemDataBufferPrimaryFifth;
void* SystemDataBufferPrimarySixth;
void* SystemDataBufferPrimarySeventh;
void* SystemDataBufferPrimaryEighth;
void* SystemDataBufferPrimaryNinth;

// 函数: 系统配置加载器 - 负责加载系统配置参数
// 系统配置管理器
void* SystemConfigurationManager;
void* SystemDataBufferConfigurationPrimary;
void* SystemDataBufferConfigurationSecondary;
void* SystemDataBufferConfigurationTertiary;
void* SystemDataBufferConfigurationQuaternary;
void* SystemDataBufferConfigurationQuinary;
void* SystemDataBufferConfigurationSenary;
void* SystemDataBufferConfigurationSeptenary;
void* SystemDataBufferConfigurationOctonary;

// 系统核心功能组件
void* SystemErrorHandler;
void* SystemLogger;
void* SystemPerformanceMonitor;
void* SystemResourceCleaner;
// 系统数据缓冲区 - 核心功能组件使用
void* SystemDataBufferCorePrimary;
void* SystemDataBufferCoreSecondary;
void* SystemDataBufferCoreTertiary;
void* SystemDataBufferCoreQuaternary;
void* SystemDataBufferCoreQuinary;
void* SystemDataBufferCoreSenary;
void* SystemDataBufferCoreSeptenary;
void* SystemDataBufferCoreOctonary;
void* SystemDataBufferCoreNonary;
void* SystemDataBufferCoreDenary;
void* SystemDataBufferCoreUndenary;
void* SystemDataBufferCoreDuodenary;
void* SystemDataBufferCoreTredecenary;
void* SystemDataBufferCoreQuattuordecenary;
void* SystemDataBufferCoreQuindecenary;
void* SystemDataBufferCoreSexdecenary;
void* SystemDataBufferCoreSeptendecenary;
void* SystemDataBufferCoreOctodecenary;
void* SystemDataBufferCoreNovemdecenary;
void* SystemDataBufferCoreVigesimal;
void* SystemDataBufferCoreUnvigesimal;
void* SystemDataBufferCoreDuovigesimal;

// 系统状态管理器
void* SystemStateManager;
// 系统状态数据缓冲区
void* SystemDataBufferStatePrimary;
void* SystemDataBufferStateSecondary;
void* SystemDataBufferStateTertiary;
void* SystemDataBufferStateQuaternary;
void* SystemDataBufferStateQuinary;
void* SystemDataBufferStateSenary;
// 系统状态标志缓冲区
char SystemStateFlagBufferPrimary;
char SystemStateFlagBufferSecondary;
// 系统数据缓冲区 - 状态管理使用
void* SystemDataBufferStateSeptenary;
void* SystemDataBufferStateOctonary;
void* SystemDataBufferStateNonary;
void* SystemDataBufferStateDenary;
void* SystemDataBufferStateUndenary;
uint8_t SystemDataBufferStateSpecial;
void* SystemDataBufferStateDuodenary;
void* SystemDataBufferStateTredecenary;
void* SystemDataBufferStateQuattuordecenary;
void* SystemDataBufferStateQuindecenary;
void* SystemDataBufferStateSexdecenary;
void* SystemDataBufferStateSeptendecenary;
uint32_t SystemDataBufferExtendedPrimary;
uint32_t SystemDataBufferExtendedSecondary;
uint32_t SystemDataBufferExtendedTertiary;
void* SystemDataBufferStateOctodecenary;
// 系统状态和数据缓冲区
char SystemStatusBufferPrimary;
void* SystemDataBufferGeneralPrimary;
void* SystemDataBufferGeneralSecondary;
void* SystemDataBufferGeneralTertiary;
void* SystemDataBufferGeneralQuaternary;
void* SystemDataBufferGeneralQuinary;
void* SystemDataBufferGeneralSenary;
void* SystemDataBufferGeneralSeptenary;
void* SystemDataBufferGeneralOctonary;
void* SystemDataBufferGeneralNonary;
void* SystemDataBufferGeneralDenary;
// 系统通用数据缓冲区
char SystemGeneralFlagBufferPrimary;
void* SystemDataBufferCommonPrimary;
void* SystemDataBufferCommonSecondary;
void* SystemDataBufferCommonTertiary;
void* SystemDataBufferCommonQuaternary;
void* SystemDataBufferCommonQuinary;
void* SystemDataBufferCommonSenary;
void* SystemDataBufferCommonSeptenary;
// 系统数据缓冲区 - 通用用途
char SystemCommonFlagBufferPrimary;
void* SystemDataBufferStandardPrimary;
void* SystemDataBufferStandardSecondary;
void* SystemDataBufferStandardTertiary;
void* SystemDataBufferStandardQuaternary;
void* SystemDataBufferStandardQuinary;
void* SystemDataBufferStandardSenary;
void* SystemDataBufferStandardSeptenary;
void* SystemDataBufferStandardOctonary;
void* SystemDataBufferStandardNonary;
void* SystemDataBufferStandardDenary;
// 系统数据缓冲区 - 标准化命名
void* SystemDataBufferStandardUndenary;
void* SystemDataBufferStandardDuodenary;
void* SystemDataBufferStandardTredecenary;
void* SystemDataBufferStandardQuattuordecenary;
void* SystemDataBufferStandardQuindecenary;
void* SystemDataBufferStandardSexdecenary;
void* SystemDataBufferStandardSeptendecenary;
void* SystemDataBufferStandardOctodecenary;
void* SystemDataBufferStandardNovemdecenary;
void* SystemDataBufferStandardVigesimal;
void* SystemDataBufferStandardUnvigesimal;
void* SystemDataBufferStandardDuovigesimal;
void* SystemDataBufferStandardTrevigesimal;
void* SystemDataBufferStandardQuattuorvigesimal;
void* SystemDataBufferStandardQuinvigesimal;
void* SystemDataBufferStandardSexvigesimal;
void* SystemDataBufferStandardSeptenvigesimal;
void* SystemDataBufferStandardOctovigesimal;
void* SystemDataBufferStandardNovemvigesimal;
void* SystemDataBufferStandardTrigesimal;
void* SystemDataBufferExtendedOne;
void* SystemDataBufferExtendedTwo;
void* SystemDataBufferExtendedThree;
void* SystemDataBufferExtendedFour;
void* SystemDataBufferExtendedFive;
void* SystemDataBufferExtendedSix;
void* SystemDataBufferExtendedSeven;
void* SystemDataBufferExtendedEight;
void* SystemDataBufferExtendedNine;
void* SystemDataBufferExtendedTen;
void* SystemDataBufferExtendedEleven;
void* SystemDataBufferExtendedTwelve;
void* SystemDataBufferExtendedThirteen;
void* SystemDataBufferExtendedFourteen;
void* SystemDataBufferExtendedFifteen;
void* SystemDataBufferExtendedSixteen;
void* SystemDataBufferExtendedSeventeen;
void* SystemDataBufferExtendedEighteen;
void* SystemDataBufferExtendedNineteen;
void* SystemDataBufferExtendedTwenty;
void* SystemDataBufferExtendedTwentyOne;
void* SystemDataBufferExtendedTwentyTwo;
void* SystemDataBufferExtendedTwentyThree;
void* SystemDataBufferExtendedTwentyFour;
void* SystemDataBufferExtendedTwentyFive;
void* SystemDataBufferExtendedTwentySix;
void* SystemDataBufferExtendedTwentySeven;
void* SystemDataBufferExtendedTwentyEight;
void* SystemDataBufferExtendedTwentyNine;
void* SystemDataBufferExtendedThirty;
void* SystemDataBufferExtendedThirtyOne;
void* SystemDataBufferStandardExtraThirtyTwo;
void* SystemDataBufferStandardExtraThirtyThree;
void* SystemDataBufferStandardExtraThirtyFour;
void* SystemDataBufferStandardExtraThirtyFive;
void* SystemDataBufferStandardExtraThirtySix;
void* SystemDataBufferStandardExtraThirtySeven;
void* SystemDataBufferStandardExtraThirtyEight;
void* SystemDataBufferStandardExtraThirtyNine;
void* SystemDataBufferStandardExtraForty;
void* SystemDataBufferStandardExtraFortyOne;

// 系统初始化协调器
void* SystemInitializationCoordinator;
// 系统初始化数据缓冲区
void* SystemDataBufferInitPrimary;
void* SystemDataBufferInitSecondary;
void* SystemDataBufferInitTertiary;
void* SystemDataBufferInitQuaternary;
void* SystemDataBufferInitQuinary;
void* SystemDataBufferInitSenary;
void* SystemDataBufferInitSeptenary;
void* SystemDataBufferInitOctonary;
void* SystemDataBufferInitNonary;
void* SystemDataBufferInitDenary;
void* SystemDataBufferInitUndenary;
void* SystemDataBufferInitDuodenary;
void* SystemDataBufferInitTredecenary;
void* SystemDataBufferInitQuattuordecenary;
void* SystemDataBufferInitQuindecenary;
void* SystemDataBufferInitSexdecenary;
void* SystemDataBufferInitSeptendecenary;
void* SystemDataBufferInitOctodecenary;
void* SystemDataBufferInitNovemdecenary;
void* SystemDataBufferInitVigesimal;
void* SystemDataBufferInitUnvigesimal;
void* SystemDataBufferInitDuovigesimal;
void* SystemDataBufferInitTrevigesimal;
void* SystemDataBufferInitQuattuorvigesimal;
void* SystemDataBufferInitQuinvigesimal;
void* SystemDataBufferInitSexvigesimal;
void* SystemDataBufferInitSeptenvigesimal;
void* SystemDataBufferInitOctovigesimal;
void* SystemDataBufferInitNovemvigesimal;
void* SystemDataBufferInitTrigesimal;
void* SystemDataBufferInitExtraOne;
void* SystemDataBufferInitExtraTwo;
void* SystemDataBufferInitExtraThree;
void* SystemDataBufferInitExtraFour;
void* SystemDataBufferInitExtraFive;
void* SystemDataBufferInitExtraSix;
void* SystemDataBufferInitExtraSeven;
void* SystemDataBufferInitExtraEight;
void* SystemDataBufferInitExtraNine;
void* SystemDataBufferInitExtraTen;
// 系统配置数据块
void* SystemConfigurationDataBlockPrimary;
void* SystemConfigurationDataBlockSecondary;
void* SystemConfigurationDataBlockTertiary;
void* SystemConfigurationDataBlockQuaternary;
void* SystemConfigurationDataBlockQuinary;
void* SystemConfigurationDataBlockSenary;
void* SystemConfigurationDataBlockSeptenary;
void* SystemConfigurationDataBlockOctonary;
void* SystemConfigurationDataBlockNonary;
void* SystemConfigurationDataBlockDenary;
void* SystemConfigurationDataBlockUndenary;
void* SystemConfigurationDataBlockDuodenary;
void* SystemConfigurationDataTable;
void* SystemMemoryAllocatorTable;
void* SystemThreadControlTable;
void* SystemProcessControlTable;
void* SystemNetworkControlTable;
void* SystemResourceControlTable;
void* SystemSecurityControlTable;
void* SystemFileSystemControlTable;
void* SystemMemoryControlTable;
void* SystemProcessSchedulerTable;
void* SystemThreadSchedulerTable;
void* SystemInterruptControlTable;
void* SystemSecurityControlTable;
void* SystemPerformanceControlTable;
void* SystemDebugControlTable;
// 系统设备控制表
void* SystemDeviceControlTable;
void* SystemAudioControlTable;
void* SystemVideoControlTable;
void* SystemInputControlTable;
void* SystemGraphicsControlTable;
void* SystemDisplayControlTable;
void* SystemSoundControlTable;
void* SystemSensorControlTable;
void* SystemControllerControlTable;
void* SystemPowerControlTable;
// 系统状态和控制块
void* SystemStatusControlBlock;
void* SystemInitializationControlBlock;
void* SystemShutdownControlBlock;

// 系统进程和内存管理变量
void* SystemCurrentProcessHandle;          // 当前系统进程句柄
void* SystemMemoryRegionCacheA;            // 系统内存区域缓存A
void* SystemMemoryRegionCacheB;            // 系统内存区域缓存B
void* SystemMemoryRegionCacheC;            // 系统内存区域缓存C
void* SystemMemoryRegionCacheD;            // 系统内存区域缓存D
void* SystemMemoryRegionCacheE;            // 系统内存区域缓存E
void* SystemNetworkBufferPointer;          // 系统网络缓冲区指针
void* SystemPerformanceCounterA;           // 系统性能计数器A
void* SystemPerformanceCounterB;           // 系统性能计数器B
void* SystemPerformanceCounterC;           // 系统性能计数器C
void* SystemPerformanceCounterD;           // 系统性能计数器D
void* SystemPerformanceCounterE;           // 系统性能计数器E
uint32_t SystemPerformanceStatusFlag;      // 系统性能状态标志
long long SystemPerformanceTimestamp;      // 系统性能时间戳

// 系统配置和状态变量
uint32_t SystemConfigurationSize;          // 系统配置大小
void* SystemDeviceContextPointer;          // 系统设备上下文指针
uint32_t SystemDeviceStatusFlag;           // 系统设备状态标志
void* SystemDisplayContextA;               // 系统显示上下文A
void* SystemDisplayContextB;               // 系统显示上下文B
void* SystemAudioContextA;                 // 系统音频上下文A
void* SystemAudioContextB;                 // 系统音频上下文B
void* SystemInputContextA;                 // 系统输入上下文A
void* SystemInputContextB;                 // 系统输入上下文B
void* SystemNetworkContextA;                // 系统网络上下文A

// 函数: 系统启动验证器 - 负责验证系统启动条件
void* SystemStartupValidator;

// 函数: 获取系统根指针 - 获取系统根节点指针
void* GetSystemRootPointer;

// 函数: 获取系统初始化函数 - 获取系统初始化相关函数
void* GetSystemInitializationFunction;

/**
 * @brief 初始化游戏核心系统
 * 
 * 初始化游戏核心系统，包括系统节点的创建、配置和激活。
 * 用于游戏核心系统的启动和初始化工作。
 * 
 * @note 该函数会遍历系统节点树，查找或创建游戏核心系统节点，
 *       并设置相关的系统数据和回调函数。
 * @note 函数使用全局常量GAME_CORE_SYSTEM_ID进行系统识别
 * @note 函数依赖GetSystemRootPointer和GetGameCoreSystemInitializationFunction等辅助函数
 * @note 函数会设置GAME_CORE_NODE_DATA相关配置
 * 
 * @return 无返回值
 */
void InitializeGameCoreSystem(void)
{
  bool IsSystemNodeActive;
  void** SystemRootNodePointer;
  int NodeIdentifierComparisonResult;
  long long* SystemDataTablePointer;
  long long RequiredAllocationSize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* CoreSystemInitializationHandler;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(bool*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  CoreSystemInitializationHandler = GetGameCoreSystemInitializationFunction;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (!IsSystemNodeActive) {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &GAME_CORE_SYSTEM_ID, SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_NEXT_POINTER_OFFSET];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_HEAD_POINTER_OFFSET];
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(bool*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID, PreviousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    RequiredAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, RequiredAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, RequiredAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = GAME_CORE_NODE_IDENTIFIER1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = GAME_CORE_NODE_IDENTIFIER2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = CoreSystemInitializationHandler;
  return;
}




/**
 * @brief 初始化系统数据表基础分配器
 * 
 * 该函数负责初始化系统数据表的基础分配器，为数据表的内存分配
 * 和管理提供基础支持。它会遍历系统节点树，查找合适的位置
 * 来初始化基础分配器功能。
 * 
 * @note 该函数在系统初始化过程中调用，确保数据表的基础
 * 分配功能正常工作。
 */
void InitializeSystemDataTableBaseAllocator(void)
{
  bool IsSystemNodeActive;
  void** SystemRootNodePointer;
  int NodeIdentifierComparisonResult;
  long long* SystemDataTablePointer;
  long long RequiredAllocationSize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* BaseAllocatorInitializationHandler;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(bool*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  BaseAllocatorInitializationHandler = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (!IsSystemNodeActive) {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &BASE_ALLOCATOR_ID, SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_NEXT_POINTER_OFFSET];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_HEAD_POINTER_OFFSET];
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(bool*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID, PreviousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    RequiredAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, RequiredAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, RequiredAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = BASE_ALLOCATOR_NODE_IDENTIFIER1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = BASE_ALLOCATOR_NODE_IDENTIFIER2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &BaseAllocatorNodeData;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = BASE_ALLOCATOR_NODE_FLAG;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = BaseAllocatorInitializationHandler;
  return;
}




/**
 * @brief 初始化系统数据表分配器
 * 
 * 该函数负责初始化系统数据表的分配器，为系统数据表的内存分配
 * 和管理提供支持。它会遍历系统节点树，查找合适的位置来初始化
 * 数据表分配器功能。
 * 
 * @note 该函数在系统初始化过程中调用，确保数据表的分配功能
 * 正常工作。
 */
void InitializeSystemDataTableAllocator(void)
{
  char IsSystemNodeActive;
  void** SystemDataTablePointer;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNodePointer;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void** AllocatedSystemNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (IsSystemNodeActive == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &SystemDataTableIdentifier, SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_NEXT_POINTER_OFFSET];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_HEAD_POINTER_OFFSET];
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (NodeIdentifierComparisonResult = memcmp(&SystemDataTableIdentifier, PreviousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, MemoryAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_TABLE_NODE_IDENTIFIER1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_TABLE_NODE_IDENTIFIER2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemNodeIdentifier;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = SYSTEM_DATA_TABLE_NODE_FLAG;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统核心配置
 * 
 * 该函数负责初始化系统的核心配置，包括系统参数设置、
 * 配置文件加载和系统环境准备。这是系统初始化过程中的
 * 重要步骤。
 * 
 * @note 该函数在系统启动时调用，确保所有核心配置都正确设置。
 */
void InitializeSystemCoreConfig(void)
{
  char IsSystemNodeActive;
  void** SystemDataTablePointer;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNodePointer;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void** AllocatedSystemNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (IsSystemNodeActive == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &SystemMemoryIdentifier, SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_NEXT_POINTER_OFFSET];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_HEAD_POINTER_OFFSET];
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  
  if ((PreviousSystemNode == SystemRootNodePointer) || 
      (NodeIdentifierComparisonResult = memcmp(&SystemMemoryIdentifier, PreviousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, MemoryAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_MEMORY_NODE_IDENTIFIER1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_MEMORY_NODE_IDENTIFIER2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeId;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = SYSTEM_MEMORY_NODE_FLAG;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存池
 * 
 * 该函数负责初始化系统的内存池，为系统运行提供内存管理基础。
 * 它会设置内存池的大小、分配策略和管理机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保内存池功能正常工作。
 */
void InitializeSystemMemoryPool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** HashTableNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_ALLOCATOR_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_ALLOCATOR_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = SYSTEM_ALLOCATOR_NODE_FLAG;
  hashTableNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统线程池
 * 
 * 该函数负责初始化系统的线程池，为系统提供多线程处理能力。
 * 它会设置线程池的大小、工作线程和管理机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保线程池功能正常工作。
 */
void InitializeSystemThreadPool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_CONFIGURATION_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_CONFIGURATION_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = SYSTEM_CONFIGURATION_NODE_FLAG;
  hashTableNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理器，为系统提供事件处理和
 * 分发机制。它会设置事件队列、事件处理器和事件分发机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保事件管理功能正常工作。
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器，为系统提供资源加载、释放和管理机制。
 * 它会设置资源池、资源分配策略和资源回收机制。
 * 
 * @note 该函数在系统初始化过程中调用，确保资源管理功能正常工作。
 * @note 函数会遍历系统节点树，查找或创建资源管理器节点。
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  long long MemoryAllocationSize;
  void** SystemAllocatedNode;
  void* ResourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = ResourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统核心数据结构
 * 
 * 该函数负责初始化系统的核心数据结构，设置系统启动所需的基本数据结构和初始化参数。
 * 它会遍历系统节点树，查找或创建核心数据结构节点。
 * 
 * @note 该函数在系统初始化过程中调用，确保核心数据结构正确设置。
 * @note 函数使用SystemDataComparisonTemplateA进行系统识别。
 */
void InitializeSystemCoreData(void)

{
  char SystemNodeFlag;
  void** SystemRootNodePointer;
  int NodeIdentifierComparisonResult;
  long long *SystemDataTablePointer;
  long long RequiredAllocationSize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* SystemInitializationCallback;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  SystemNodeFlag = *(char*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationCallback = GetSystemInitializationCallback;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void**)SystemRootNodePointer[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4,&SystemDataComparisonTemplateA,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    SystemNodeFlag = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousSystemNode == SystemRootNodePointer) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateA,PreviousSystemNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    RequiredAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer,&AllocatedSystemNode,PreviousSystemNode,RequiredAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,RequiredAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_A_ID1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_A_ID2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemNodeLinkPointerA;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = SystemInitializationCallback;
  return;
}




/**
 * 初始化系统数据表结构
 * 设置系统数据表和相关的内存结构
 */
void InitializeSystemDataTable(void)

{
  char StatusFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemHandle;
  long long MemorySize;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** NewNode;
  void* SystemFlag;
  
  SystemHandle = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemHandle;
  StatusFlag = *(char*)((long long)SystemRootPointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemFlag = 0;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* )SystemRootPointer[1];
  while (StatusFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateB,System_IDENTIFIER_SIZE);
    if (ComparisonResult < 0) {
      NextNode = (void* )CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* )*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    StatusFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateB,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    MemorySize = GetSystemMemorySize(SystemHandle);
    AllocateSystemMemory(SystemHandle,&NewNode,PreviousNode,MemorySize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemorySize);
    PreviousNode = NewNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_B_ID1;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_B_ID2;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemNodeLinkPointerB;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  PreviousNode[10] = SystemFlag;
  return;
}




/**
 * @brief 初始化系统全局变量
 * 
 * 初始化系统的全局变量，设置各种状态标志和计数器。
 * 该函数负责系统启动时的全局状态初始化工作。
 * 
 * @return 初始化成功返回0，失败返回非0值
 */
int InitializeSystemGlobalVariables(void)

{
  long long InitializationStatus;
  
  SystemInitializationStatusCode = 0;
  SystemInitializationProgress = 0;
  SystemMemoryStatusFlagA = 0;
  SystemInitializationErrorFlag = 3;
  SystemInitializationMemoryStatus = 0;
  SystemInitializationThreadStatus = 0;
  SystemMemoryStatusFlagB = 0;
  SystemInitializationResourceStatus = 3;
  SystemConfigDataPointerA = &SystemGlobalDataPointerA;
  SystemConfigDataPointerB = 0;
  SystemConfigDataPointerC = 0;
  SystemConfigDataPointerD = 0;
  
  InitializationStatus = 0;
  return InitializationStatus;
}

/**
 * @brief 初始化核心引擎
 * 
 * 该函数负责初始化游戏引擎的核心系统
 * 设置基本的运行环境和管理结构
 */
void InitializeCoreEngine(void)

/**
 * @brief 初始化渲染系统配置
 * 
 * 该函数负责初始化渲染系统的配置节点，包括创建系统节点、分配内存空间
 * 和设置渲染系统的基本参数。它会遍历系统节点树，找到合适的位置
 * 来创建渲染系统配置节点，并设置相关的标识符和处理器。
 * 
 * @note 该函数在系统初始化过程中调用，确保渲染系统能够正确配置
 * 和运行。函数会创建新的系统节点或使用现有节点来存储渲染配置。
 * 
 * @param void 无参数
 * @return void 无返回值
 */
void InitializeRenderingSystemConfig(void)

{
  char IsSystemNodeActive;
  void** SystemRootNodePointer;
  int NodeIdentifierComparisonResult;
  long long *SystemDataTablePointer;
  long long RequiredAllocationSize;
  void** CurrentSystemNode;
  void** PreviousSystemNode;
  void** NextSystemNode;
  void** AllocatedSystemNode;
  void* RenderingSystemHandler;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void* *)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  RenderingSystemHandler = 0;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void* *)SystemRootNodePointer[1];
  while (!IsSystemNodeActive) {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &RENDERING_CONFIG_TEMPLATE_ID, SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_NEXT_POINTER_OFFSET];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousSystemNode == SystemRootNodePointer) || (NodeIdentifierComparisonResult = memcmp(&RENDERING_CONFIG_TEMPLATE_ID, PreviousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    RequiredAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &AllocatedSystemNode, PreviousSystemNode, RequiredAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, RequiredAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = RENDERING_CONFIG_NODE_IDENTIFIER1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = RENDERING_CONFIG_NODE_IDENTIFIER2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeSecondaryRoot;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = RenderingSystemHandler;
  return;
}



/**
 * @brief 初始化音频系统资源池
 * 
 * 创建并配置音频系统的资源池，注册音频系统事件处理器，
 * 并初始化音频系统配置。该函数是音频系统初始化的核心入口点。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeAudioSystemResourcePool(void)

{
  long long AudioInitializationStatus;
  
  RegisterSystemEventHandler(SYSTEM_EVENT_HANDLER_PRIMARY_ADDRESS, SystemEventHandlerSize, SystemEventHandlerCapacity, GetSystemEventCallbackA, GetSystemEventCallbackB);
  AudioInitializationStatus = InitializeAudioSystem(&AudioSystemConfiguration);
  return (AudioInitializationStatus != 0) - 1;
}



/**
 * @brief 初始化输入系统资源池
 * 
 * 创建并配置输入系统的资源池，注册输入系统事件处理器，
 * 并初始化输入系统配置。该函数是输入系统初始化的核心入口点。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeInputSystemResourcePool(void)

{
  long long InputInitializationStatus;
  
  RegisterSystemEventHandler(SYSTEM_EVENT_HANDLER_SECONDARY_ADDRESS, SystemEventHandlerSize, SystemEventHandlerCapacity, GetSystemEventCallbackC, GetSystemEventCallbackB);
  InputInitializationStatus = InitializeInputSystem(&InputSystemConfiguration);
  return (InputInitializationStatus != 0) - 1;
}




/**
 * @brief 初始化系统信号量
 * 
 * 创建系统级的信号量用于线程同步，初始化信号量系统配置。
 * 该函数确保系统中的线程能够正确同步和协调工作。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemSemaphore(void)

{
  long long SemaphoreInitializationStatus;
  
  SystemSemaphoreHandle = CreateSemaphoreW(0, 1, SystemSemaphoreMaxCount, 0, InvalidHandleValue);
  SemaphoreInitializationStatus = InitializeSemaphoreSystem(GetSemaphoreSystemConfiguration);
  return (SemaphoreInitializationStatus != 0) - 1;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统内存管理器，设置内存分配策略
 * 和管理机制，确保系统内存资源的有效利用。函数会遍历系统节点树，
 * 查找或创建内存管理器节点，并配置相关的标识符和回调函数。
 * 
 * @note 该函数是系统初始化过程中的关键组件，负责建立内存管理的基础架构。
 * 
 * @param void 无参数
 * @return void 无返回值
 */
void InitializeSystemMemoryManager(void)

{
  char IsNodeActive;
  void** SystemDataTable;
  int IdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimestamp;
  void** RootSystemNode;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** HashTableNode;
  void* EventCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  RootSystemNode = (void**)*SystemDataTable;
  IsNodeActive = *(char*)((long long)RootSystemNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemSearchFunctionPointer = GetSystemSearchFunction;
  HashTableNode = RootSystemNode;
  CurrentSystemNode = (void**)RootSystemNode[1];
  while (IsNodeActive == '\0') {
    IdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &SystemDataComparisonTemplateD, SYSTEM_IDENTIFIER_SIZE);
    if (IdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = HashTableNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    HashTableNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((HashTableNode == RootSystemNode) || (IdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateD, HashTableNode + 4, SYSTEM_IDENTIFIER_SIZE), IdentifierComparisonResult < 0)) {
    SystemMemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable, &SystemAllocatedNode, HashTableNode, SystemMemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, SystemMemoryAllocationSize);
    HashTableNode = SystemAllocatedNode;
  }
  HashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_D_ID1;
  HashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_D_ID2;
  HashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeTertiaryRoot;
  HashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  HashTableNode[10] = EventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存分配器
 * 
 * 该函数负责初始化系统内存分配器，设置内存分配策略和管理机制，
 * 为系统提供高效的内存分配服务。它会遍历系统节点树，创建或查找
 * 内存分配器节点，并设置相关的标识符和回调函数。
 * 
 * @note 该函数在系统初始化过程中调用，确保内存分配器能够正确配置
 * 和运行。函数会创建新的系统节点或使用现有节点来存储内存分配器配置。
 * 
 * @param void 无参数
 * @return void 无返回值
 */
void InitializeSystemMemoryAllocator(void)

{
  char IsNodeActive;
  void** SystemDataTable;
  int IdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimestamp;
  void** RootSystemNode;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void* AllocatorCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  RootSystemNode = (void**)*SystemDataTable;
  IsNodeActive = *(char*)((long long)RootSystemNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemSearchFunctionPointerB = GetSystemSearchFunctionB;
  PreviousSystemNode = RootSystemNode;
  CurrentSystemNode = (void**)RootSystemNode[1];
  while (!IsNodeActive) {
    IdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &MEMORY_ALLOCATOR_TEMPLATE_ID, SYSTEM_IDENTIFIER_SIZE);
    if (IdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[SYSTEM_NODE_NEXT_POINTER_OFFSET];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousSystemNode == RootSystemNode) || (IdentifierComparisonResult = memcmp(&MEMORY_ALLOCATOR_TEMPLATE_ID, PreviousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), IdentifierComparisonResult < 0)) {
    SystemMemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable, &SystemAllocatedNode, PreviousSystemNode, SystemMemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, SystemMemoryAllocationSize);
    PreviousSystemNode = SystemAllocatedNode;
  }
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = MEMORY_ALLOCATOR_NODE_IDENTIFIER1;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = MEMORY_ALLOCATOR_NODE_IDENTIFIER2;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuaternaryRoot;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = AllocatorCallbackPointer;
  return;
}



/**
 * @brief 初始化系统线程同步机制
 * 
 * 该函数负责初始化系统的线程同步机制，包括互斥锁和信号量
 * 确保多线程环境下的数据安全和同步操作。该函数是系统多线程
 * 支持的基础组件，为后续的并发操作提供同步保障。
 * 
 * @param ThreadPool 线程池指针，用于管理线程资源
 * @param SyncConfig 同步配置参数，包含同步机制的配置信息
 * @param MutexSize 互斥锁大小，指定互斥锁的内存大小
 * @param SemaphoreConfig 信号量配置，包含信号量的配置参数
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemThreadSynchronization(void* ThreadPool, void* SyncConfig, size_t MutexSize, void* SemaphoreConfig)

{
  long long SynchronizationInitializationStatus;
  
  // 初始化互斥锁和信号量
  InitializeMutexInSitu(SystemMutexPool, 2, MutexSize, SemaphoreConfig, MAX_THREAD_COUNT);
  SynchronizationInitializationStatus = InitializeThreadPool(SystemThreadPoolInstance);
  return (SynchronizationInitializationStatus != 0) - 1;
}





/**
 * @brief 初始化系统字符串处理模块
 * 
 * 该函数负责初始化系统字符串处理模块，设置字符串缓冲区
 * 和处理机制，为系统提供字符串操作支持。该函数配置字符串
 * 处理器回调函数，初始化字符串数据缓冲区，并建立字符串处理的基础架构。
 * 
 * @note 该函数是系统字符串处理的核心组件，为所有字符串操作提供支持。
 * 
 * @param void 无参数
 * @return void 无返回值
 */
void InitializeSystemStringHandler(void)

{
  uint64_t StringProcessorParameter;
  void* StringProcessorCallbackPointer;
  uint8_t* StringBufferPointer;
  uint32_t StringBufferSize;
  uint8_t StringBuffer [136];
  
  StringProcessorCallbackPointer = &SystemStringProcessorNode;
  StringBufferPointer = StringBuffer;
  StringBuffer[0] = 0;
  StringBufferSize = 7;
  strcpy_s(StringBuffer, StringBufferSize, &SystemStringProcessorTemplate, StringProcessorParameter, InvalidHandleValue);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&StringProcessorCallbackPointer);
  return;
}




/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统线程管理器，设置线程创建和管理机制，
 * 为系统提供多线程支持。该函数会遍历系统节点树，查找或创建
 * 线程管理器节点，并配置相关的标识符和回调函数。
 * 
 * @note 该函数是系统多线程管理的核心组件，负责建立线程管理的基础架构。
 * 
 * @param void 无参数
 * @return void 无返回值
 */
void InitializeSystemThreadManager(void)

{
  char IsNodeActive;
  void** SystemDataTable;
  int IdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimestamp;
  void** RootSystemNode;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** HashTableNode;
  void* ThreadManagerCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  RootSystemNode = (void**)*SystemDataTable;
  IsNodeActive = *(char*)((long long)RootSystemNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemSearchFunctionPointerC = GetSystemSearchFunctionC;
  HashTableNode = RootSystemNode;
  CurrentSystemNode = (void**)RootSystemNode[1];
  while (IsNodeActive == '\0') {
    IdentifierComparisonResult = memcmp(CurrentSystemNode + 4, &SystemDataComparisonTemplateH, 0x10);
    if (IdentifierComparisonResult < 0) {
      NextSystemNode = (void**)CurrentSystemNode[2];
      CurrentSystemNode = HashTableNode;
    }
    else {
      NextSystemNode = (void**)*CurrentSystemNode;
    }
    HashTableNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((HashTableNode == RootSystemNode) || (IdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH, HashTableNode + 4, 0x10), IdentifierComparisonResult < 0)) {
    SystemMemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable, &SystemAllocatedNode, HashTableNode, SystemMemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, SystemMemoryAllocationSize);
    HashTableNode = SystemAllocatedNode;
  }
  HashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x43330a43fcdb3653;
  HashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdcfdc333a769ec93;
  HashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  HashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  HashTableNode[10] = EventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，设置事件处理机制和事件队列，
 * 为系统提供事件驱动支持。
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点结构
 * 设置系统配置的基本参数和数据结构
 */
void InitializeSystemConfigurationNode(void)

{
  char NodeFlag;
  void* *SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long AllocationSize;
  void* *CurrentNode;
  void* *PreviousNode;
  void* *NextNode;
  void* *AllocatedNode;
  void* InitializationFlag;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  InitializationFlag = 0;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateJ,PreviousNode + 4,System_IDENTIFIER_SIZE), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_J_ID1;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_J_ID2;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousNode[10] = InitializationFlag;
  return;
}




// 函数: void InitializeSystemResourceNode(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点结构
 * 设置系统资源管理的基本参数和数据结构
 */
void InitializeSystemResourceNode(void)

{
  char NodeFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** AllocatedNode;
  void** InitializationCallback;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  InitializationCallback = GetSystemInitializationCallbackB;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateK,System_IDENTIFIER_SIZE);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateK,PreviousNode + 4,System_IDENTIFIER_SIZE), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_K_ID1;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_K_ID2;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousNode[10] = InitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryNode(void)
/**
 * @brief 初始化系统内存节点
 * 
 * 该函数负责初始化系统的内存节点结构
 * 设置系统内存管理的基本参数和数据结构
 */
void InitializeSystemMemoryNode(void)

{
  char NodeFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** AllocatedNode;
  void* InitializationFlag;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  InitializationFlag = 0;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateL,PreviousNode + 4,0x10), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousNode[10] = InitializationFlag;
  return;
}




/**
 * @brief 初始化系统数据表结构A
 * 
 * 该函数负责初始化系统数据表结构A，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureA(void)

{
  char DataTypeFlag;
  void** DataTablePointer;
  int NodeIdentifierComparisonResult;
  long long *SystemRootPointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void* *NewNodePointer;
  void** SystemDataReference;
  
  SystemRootPointer = (long long*)GetSystemRootPointer();
  DataTablePointer = (void* *)*SystemRootPointer;
  DataTypeFlag = *(char*)((long long)DataTablePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemDataReference = &SystemDataNodeJ;
  PreviousNode = DataTablePointer;
  CurrentNode = (void* *)DataTablePointer[1];
  while (DataTypeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    DataTypeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == DataTablePointer) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,PreviousNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemRootPointer);
    AllocateSystemMemory(SystemRootPointer,&NewNodePointer,PreviousNode,currentThreadId + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,currentThreadId);
    PreviousNode = NewNodePointer;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousNode[10] = systemDataReference;
  return;
}




/**
 * @brief 初始化系统数据表结构B
 * 
 * 该函数负责初始化系统数据表结构B，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureB(void)

{
  char DataTypeFlag;
  void** DataTablePointer;
  int NodeIdentifierComparisonResult;
  long long* SystemRootPointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** NewNodePointer;
  void* InitializationFlag;
  
  SystemRootPointer = (long long*)GetSystemRootPointer();
  DataTablePointer = (void**)*SystemRootPointer;
  DataTypeFlag = *(char*)((long long)DataTablePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  InitializationFlag = 0;
  PreviousNode = DataTablePointer;
  CurrentNode = (void**)DataTablePointer[1];
  while (DataTypeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      NextNode = (void**)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void**)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    DataTypeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == DataTablePointer) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,PreviousNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemRootPointer);
    AllocateSystemMemory(SystemRootPointer,&NewNodePointer,PreviousNode,currentThreadId + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,currentThreadId);
    PreviousNode = NewNodePointer;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousNode[10] = InitializationFlag;
  return;
}




/**
 * @brief 初始化系统数据表结构C
 * 
 * 该函数负责初始化系统数据表结构C，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateE,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x449bafe9b77ddd3c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc160408bde99e59f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构D
 * 
 * 该函数负责初始化系统数据表结构D，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构E
 * 
 * 该函数负责初始化系统数据表结构E，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateD,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x406be72011d07d37;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x71876af946c867ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeTertiaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构F
 * 
 * 该函数负责初始化系统数据表结构F，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateG,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40afa5469b6ac06d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x2f4bab01d34055a5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuaternaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构G
 * 
 * 该函数负责初始化系统数据表结构G，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateC,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x42bea5b911d9c4bf;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x1aa83fc0020dc1b6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeSecondaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表结构H
 * 
 * 该函数负责初始化系统数据表结构H，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateO,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40db4257e97d3df8;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x81d539e33614429f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeN;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构I
 * 
 * 该函数负责初始化系统数据表结构I，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemEventCallbackPointer;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemMemoryComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4e33c4803e67a08f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x703a29a844ce399;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeO;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统字符串处理全局变量
 * 
 * 初始化游戏引擎字符串处理系统的全局变量和数据结构。
 * 该函数负责设置字符串处理系统的基础配置和引用。
 * 
 * @return 初始化状态，成功返回0，失败返回非零值
 */
int InitializeSystemStringProcessingGlobals(void)

{
  long long systemInitializationStatus;
  void* SystemConfigurationValue;
  
  SystemStringProcessingPrimaryBuffer = &SystemStringProcessingReferenceTable;
  SystemStringProcessingSecondaryBuffer = &SystemStringProcessingConfigurationTable;
  
  return systemInitializationStatus;
}

/**
 * @brief 初始化系统字符串处理功能
 * 
 * 初始化游戏引擎的字符串处理子系统，设置字符串缓冲区和处理函数。
 * 该函数负责配置字符串操作的基础设施，为后续的文本处理提供支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是文本处理系统的基础
 */
void InitializeSystemStringProcessor(void)

{
  uint64_t SystemStringParameter;
  void* StringProcessCallbackPointer;
  uint8_t* StringDataBufferPointer;
  uint32_t StringBufferSize;
  uint8_t StringDataBuffer [136];
  
  StringProcessCallbackPointer = &SystemStringProcessorNode;
  StringDataBufferPointer = StringDataBuffer;
  StringDataBuffer[0] = 0;
  StringBufferSize = 0xb;
  strcpy_s(StringDataBuffer,StringBufferSize,&SystemStringProcessorTemplate,SystemStringParameter,InvalidHandleValue);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&StringProcessCallbackPointer);
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 初始化游戏引擎的内存管理子系统，设置内存分配策略和管理机制。
 * 该函数负责配置内存池、分配器和回收机制，为系统运行提供内存管理支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是内存管理系统的核心组件
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据结构
 * 
 * 初始化游戏引擎的数据结构子系统，设置数据表和管理节点。
 * 该函数负责配置数据结构的基础设施，为系统数据管理提供支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是数据管理系统的核心组件
 */
void InitializeSystemDataStructure(void)

{
  char NodeFlag;
  void** SystemRootPointer;
  int ComparisonResult;
  long long *SystemTablePointer;
  long long currentThreadId;
  void** CurrentNode;
  void** PreviousNode;
  void** NextNode;
  void** AllocatedNode;
  void* *initializationFunction;
  
  SystemTablePointer = (long long*)GetSystemRootPointer();
  SystemRootPointer = (void* *)*SystemTablePointer;
  NodeFlag = *(char*)((long long)SystemRootPointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  initializationFunction = (void* *)SystemInitializationCallbackA;
  PreviousNode = SystemRootPointer;
  CurrentNode = (void* *)SystemRootPointer[1];
  while (NodeFlag == '\0') {
    ComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateI,System_IDENTIFIER_SIZE);
    if (ComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == SystemRootPointer) || (ComparisonResult = memcmp(&SystemDataComparisonTemplateI,PreviousNode + 4,System_IDENTIFIER_SIZE), ComparisonResult < 0)) {
    currentThreadId = GetSystemMemorySize(SystemTablePointer);
    AllocateSystemMemory(SystemTablePointer,&AllocatedNode,PreviousNode,currentThreadId + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,currentThreadId);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_I_ID1;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_I_ID2;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  PreviousNode[10] = initializationFunction;
  return;
}




// 函数: 初始化系统数据表
// 负责创建和配置系统的主数据表结构
void InitializeSystemDataTable(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化系统节点树
// 负责创建和管理系统的节点树结构
void InitializeSystemNodeTree(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: 初始化内存分配器
// 负责设置和管理系统的内存分配机制
void InitializeMemoryAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化资源池
// 负责创建和管理系统的资源池结构
void InitializeResourcePool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* ResourcePoolCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  resourcePoolCallbackPointer = &ResourcePoolCallbackNode;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: 初始化配置管理器
// 负责设置和管理系统的配置参数
void InitializeConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化事件系统
// 负责设置和管理系统的事件处理机制
void InitializeEventSystem(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理器，设置内存分配策略
 * 和内存池管理结构，确保系统内存的有效利用
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统线程池管理器
 * 
 * 该函数负责初始化系统的线程池管理器，设置线程池的
 * 基本参数和线程管理策略，优化系统并发处理能力
 */
void InitializeSystemThreadPoolManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器，设置资源的分配、
 * 释放和监控机制，确保系统资源的合理使用
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统节点树结构
 * 
 * 初始化游戏引擎的系统节点树，构建节点之间的链接关系。
 * 该函数负责设置系统节点的内存分配和初始化节点数据结构。
 * 
 * @note 该函数在系统初始化阶段被调用，用于构建系统树形结构
 */
void InitializeSystemNodeTree(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构
 * 
 * 初始化游戏引擎的数据表结构，设置数据表的基本配置和内存分配。
 * 该函数负责创建数据表的基本框架，为后续的数据存储和访问做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立数据表的基础结构
 */
void InitializeSystemDataTable(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件处理器
 * 
 * 该函数负责初始化系统的事件处理器，设置事件的监听、
 * 分发和处理机制，确保系统事件的及时响应
 */
void InitializeSystemEventHandler(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理器，设置网络连接、
 * 数据传输和协议处理机制，确保系统网络功能的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统安全管理器
 * 
 * 该函数负责初始化系统的安全管理器，设置安全策略、
 * 权限控制和防护机制，确保系统的安全性
 */
void InitializeSystemSecurityManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控器，设置性能指标的
 * 收集、分析和报告机制，确保系统性能的实时监控
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理器，设置调试信息的
 * 收集、存储和分析机制，便于系统问题的诊断和解决
 */
void InitializeSystemDebugManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存分配器
 * 
 * 初始化游戏引擎的内存分配器，设置内存池和分配策略。
 * 该函数负责配置内存管理的基础设施，为系统运行提供内存支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是内存管理的核心组件
 */
void InitializeSystemMemoryAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源池
 * 
 * 初始化游戏引擎的资源池，设置资源管理和分配的基础设施。
 * 该函数负责创建资源池的基本结构，为系统资源的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立资源管理的基础
 */
void InitializeSystemResourcePool(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 初始化游戏引擎的配置管理器，设置系统配置的基础设施。
 * 该函数负责创建配置管理的基本结构，为系统配置的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立配置管理的基础
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 初始化游戏引擎的资源管理器，设置系统资源的基础设施。
 * 该函数负责创建资源管理的基本结构，为系统资源的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立资源管理的基础
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* *resourceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  resourceInitializationCallback = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 初始化游戏引擎的性能监控器，设置性能监控和统计的基础设施。
 * 该函数负责创建性能监控的基本结构，为系统性能的监控和统计做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立性能监控的基础
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateC,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x42bea5b911d9c4bf;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x1aa83fc0020dc1b6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeSecondaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 初始化游戏引擎的调试管理器，设置系统调试的基础设施。
 * 该函数负责创建调试管理的基本结构，为系统调试和日志记录做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立调试管理的基础
 */
void InitializeSystemDebugManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *debugInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  debugInitializationCallback = SystemDebugCallback;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件处理器
 * 
 * 初始化游戏引擎的事件处理器，设置事件处理的基础设施。
 * 该函数负责创建事件处理的基本结构，为系统事件的管理和分发做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立事件处理的基础
 */
void InitializeSystemEventHandler(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 初始化游戏引擎的网络管理器，设置网络通信的基础设施。
 * 该函数负责创建网络管理的基本结构，为系统网络通信做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立网络管理的基础
 */
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统安全管理器
 * 
 * 初始化游戏引擎的安全管理器，设置系统安全的基础设施。
 * 该函数负责创建安全管理的基本结构，为系统安全验证和权限控制做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立安全管理的基础
 */
void InitializeSystemSecurityManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表结构A
 * 
 * 该函数负责初始化系统数据表的基本结构，设置数据表的根节点和初始状态。
 * 它会在系统中创建一个新的数据表结构，用于存储系统运行时的数据。
 * 
 * @note 该函数在系统启动时被调用，是系统初始化过程的重要组成部分。
 */
void InitializeSystemDataTableStructureA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器组件，设置资源分配的基础结构。
 * 它会创建资源管理节点，配置资源分配回调函数，并建立资源标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* systemCallbackData;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackData = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能数据收集的基础结构。
 * 它会创建性能监控节点，配置性能数据回调函数，并建立性能监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemPerformanceCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemPerformanceCallback = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = systemPerformanceCallback;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理组件，设置调试功能的基础结构。
 * 它会创建调试管理节点，配置调试回调函数，并建立调试功能标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试系统的正常运行
 */
void InitializeSystemDebugManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* systemDebugData;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemDebugData = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理组件，设置字符串操作的基础结构。
 * 它会创建字符串处理缓冲区，配置字符串复制操作，并建立字符串处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessor(void)

{
  long long StringParameter;
  void* *CallbackPointer;
  uint8_t *DataBufferPointer;
  int BufferSize;
  uint8_t DataBuffer [136];
  
  CallbackPointer = &SystemStringProcessorNode;
  DataBufferPointer = DataBuffer;
  DataBuffer[0] = 0;
  BufferSize = 8;
  strcpy_s(DataBuffer,StringBufferSize,&SystemStringProcessorTemplate,StringParameter,InvalidHandleValue);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&CallbackPointer);
  return;
}




/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统的数据管理组件，设置数据处理的基础结构。
 * 它会创建数据管理节点，配置数据操作回调函数，并建立数据管理标识符。
 * 
 * @return 初始化结果状态码
 * @note 这是系统初始化过程中的重要组成部分，确保数据管理系统的正常运行
 */
int InitializeSystemDataManager(void)

{
  long long SystemDataOffset;
  void* SystemParameter;
  
  SystemConfigDataPointerE = &SystemGlobalDataPointerB;
  SystemConfigDataPointerG = &SystemConfigDataPointerH;

// 函数: void InitializeSystemEventManager(void)
/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理组件，设置事件处理的基础结构。
 * 它会创建事件管理节点，配置事件处理回调函数，并建立事件管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char NodeFlag;
  void* *DataTable;
  int NodeIdentifierComparisonResult;
  long long *MemoryPointer;
  long long TimeValue;
  void* *RootNode;
  void** CurrentNode;
  void** NextNode;
  void** PreviousNode;
  code *eventCallbackPointer;
  
  DataTable = (long long*)GetSystemRootPointer();
  RootNode = (void* *)*DataTable;
  NodeFlag = *(char*)((long long)RootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  eventCallbackPointer = SystemEventCallback;
  PreviousNode = RootNode;
  CurrentNode = (void* *)RootNode[1];
  while (NodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateD,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** SystemAllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(DataTable);
    AllocateSystemMemory(DataTable,&SystemAllocatedNode,PreviousNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    PreviousNode = SystemAllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x406be72011d07d37;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x71876af946c867ab;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeTertiaryRoot;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络通信的基础结构。
 * 它会创建网络管理节点，配置网络通信回调函数，并建立网络管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char NodeFlag;
  void* *dataTable;
  int NodeIdentifierComparisonResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void** CurrentNode;
  void** NextNode;
  void** PreviousNode;
  code *networkCallbackPointer;
  
  dataTable = (long long*)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  NodeFlag = *(char*)((long long)rootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  networkCallbackPointer = SystemNetworkCallback;
  PreviousNode = rootNode;
  CurrentNode = (void* *)rootNode[1];
  while (NodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == rootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateG,PreviousNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** AllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&AllocatedNode,PreviousNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40afa5469b6ac06d;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x2f4bab01d34055a5;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuaternaryRoot;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  PreviousNode[SYSTEM_NODE_HANDLER_INDEX] = networkCallbackPointer;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理器节点，用于管理系统配置信息。
 * 它会在系统数据表中查找或创建配置管理器节点，并设置相关的配置参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理器正确建立
 */
void InitializeSystemConfigurationManager(void)

{
  char IsSystemNodeActive;
  void* *SystemDataTablePointer;
  int NodeIdentifierComparisonResult;
  long long *SystemMemoryPointer;
  long long SystemTimestamp;
  void* *SystemRootNodePointer;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void* ConfigurationManagerInitializationFunction;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void* *)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  ConfigurationManagerInitializationFunction = GetSystemConfigurationManagerFunction;
  PreviousSystemNode = SystemRootNodePointer;
  CurrentSystemNode = (void* *)SystemRootNodePointer[1];
  while (IsSystemNodeActive == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentSystemNode + 4,&CONFIGURATION_MANAGER_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      NextSystemNode = (void* *)CurrentSystemNode[2];
      CurrentSystemNode = PreviousSystemNode;
    }
    else {
      NextSystemNode = (void* *)*CurrentSystemNode;
    }
    PreviousSystemNode = CurrentSystemNode;
    CurrentSystemNode = NextSystemNode;
    IsSystemNodeActive = *(char*)((long long)NextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousSystemNode == SystemRootNodePointer) || (NodeIdentifierComparisonResult = memcmp(&CONFIGURATION_MANAGER_ID,PreviousSystemNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long SystemMemoryAllocationSize;
    void** AllocatedSystemNode;
    SystemMemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer,&AllocatedSystemNode,PreviousSystemNode,SystemMemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,SystemMemoryAllocationSize);
    PreviousSystemNode = AllocatedSystemNode;
  }
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x406be72011d07d37;
  PreviousSystemNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x71876af946c867ab;
  PreviousSystemNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &ConfigurationManagerNodeData;
  PreviousSystemNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  PreviousSystemNode[SYSTEM_NODE_HANDLER_INDEX] = ConfigurationManagerInitializationFunction;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器节点，用于管理系统资源分配和释放。
 * 它会在系统数据表中查找或创建资源管理器节点，并设置相关的资源管理参数。
 * 
 * @note 这是系统初始化过程中的关键组成部分，确保资源管理器正确建立
 */
void InitializeSystemResourceManager(void)

{
  char IsSystemNodeActive;
  void* *SystemDataTablePointer;
  int NodeIdentifierComparisonResult;
  long long *SystemMemoryPointer;
  long long SystemTimestamp;
  void* *SystemRootNodePointer;
  void** CurrentSystemNode;
  void** NextSystemNode;
  void** PreviousSystemNode;
  void* ResourceManagerInitializationFunction;
  
  dataTable = (long long*)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  NodeFlag = *(char*)((long long)rootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  initializationFunction = GetSystemResourceManagerFunction;
  PreviousNode = rootNode;
  CurrentNode = (void* *)rootNode[1];
  while (NodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(CurrentNode + 4,&RESOURCE_MANAGER_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      NextNode = (void* *)CurrentNode[2];
      CurrentNode = PreviousNode;
    }
    else {
      NextNode = (void* *)*CurrentNode;
    }
    PreviousNode = CurrentNode;
    CurrentNode = NextNode;
    NodeFlag = *(char*)((long long)NextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((PreviousNode == rootNode) || (NodeIdentifierComparisonResult = memcmp(&RESOURCE_MANAGER_ID,PreviousNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize;
    void** AllocatedNode;
    MemoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&AllocatedNode,PreviousNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    PreviousNode = AllocatedNode;
  }
  PreviousNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40afa5469b6ac06d;
  PreviousNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x2f4bab01d34055a5;
  PreviousNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &ResourceManagerNodeData;
  PreviousNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  PreviousNode[10] = initializationFunction;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理器节点，用于管理系统事件的分发和处理。
 * 它会在系统数据表中查找或创建事件管理器节点，并设置相关的事件处理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理器正确建立
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *systemInitializationFunction;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = GetSystemEventManagerFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&EVENT_MANAGER_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&EVENT_MANAGER_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &EventManagerNodeData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统的数据管理器节点，用于管理系统数据的存储和检索。
 * 它会在系统数据表中查找或创建数据管理器节点，并设置相关的数据管理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据管理器正确建立
 */
void InitializeSystemDataManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *systemInitializationFunction;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = GetSystemDataManagerFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&DATA_MANAGER_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&DATA_MANAGER_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &DataManagerNodeData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点，用于管理系统资源的分配和释放。
 * 它会在系统数据表中查找或创建资源节点，并设置相关的资源管理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源节点正确建立
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* systemResourceFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemResourceFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&RESOURCE_NODE_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&RESOURCE_NODE_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &ResourceNodeData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统节点管理器
 * 
 * 该函数负责初始化系统的节点管理组件，设置节点操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点管理系统的正常运行
 */
void InitializeSystemNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* nodeManagerCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  nodeManagerCallbackPointer = SystemNodeManagerCallback;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
/**
 * @brief 初始化系统数据节点管理器
 * 
 * 该函数负责初始化系统的数据节点管理组件，设置数据节点操作的基础结构。
 * 它会遍历系统数据节点树，进行内存比较，分配必要的内存，并设置数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据节点管理系统的正常运行
 */
void InitializeSystemDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统资源节点管理器
 * 
 * 该函数负责初始化系统的资源节点管理组件，设置资源节点操作的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源节点管理系统的正常运行
 */
void InitializeSystemResourceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemMemoryNodeManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理组件，设置内存节点操作的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存节点管理系统的正常运行
 */
void InitializeSystemMemoryNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemStringConfigurationManager(void)
/**
 * @brief 初始化系统字符串配置管理器
 * 
 * 该函数负责初始化系统的字符串配置管理组件，设置字符串配置操作的基础结构。
 * 它会创建字符串配置缓冲区，配置字符串复制操作，并建立字符串配置标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串配置管理系统的正常运行
 */
void InitializeSystemStringConfigurationManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xb;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemConfigurationTemplateA,SystemRegisterValue,InvalidHandleValue);
  SystemGlobalDataProcessorResult = SystemGlobalDataProcessor(&SystemDataPointer);
  return;
}




/**
 * @brief 初始化系统配置节点管理器
 * 
 * 该函数负责初始化系统的配置节点管理组件，设置配置节点操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置节点管理系统的正常运行
 */
void InitializeSystemConfigurationNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件节点管理器
 * 
 * 该函数负责初始化系统的事件节点管理组件，设置事件节点操作的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件节点管理系统的正常运行
 */
void InitializeSystemEventNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统资源管理器的节点结构，包括内存分配、
 * 节点链接和回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的资源节点。
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void* SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (void*)GetSystemRootPointer();
  SystemRootNode = (void**)*(long long*)SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp((void*)((long long)SystemCurrentNode + 4),&SystemDataComparisonTemplateJ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((SystemCurrentNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,(void*)((long long)SystemCurrentNode + 4),0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void** SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  SystemCurrentNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  SystemCurrentNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  SystemCurrentNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  SystemCurrentNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统事件管理器的节点结构，包括内存分配、
 * 节点链接和事件回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的事件节点。
 */
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void *SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void *SystemRootNode;
  void *SystemCurrentNode;
  void *SystemNextNode;
  void *hashTableNode;
  void *SystemValidationCallback;
  
  SystemDataTable = (void*)GetSystemRootPointer();
  SystemRootNode = (void *)*(long long *)SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemValidationCallback = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp((void*)((long long)SystemCurrentNode + 4),&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((SystemCurrentNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,(void*)((long long)SystemCurrentNode + 4),0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void *SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  SystemCurrentNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  SystemCurrentNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  SystemCurrentNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存节点
 * 
 * 该函数负责初始化系统内存管理器的节点结构，包括内存分配、
 * 节点链接和内存管理回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的内存节点。
 */
void InitializeSystemMemoryNode(void)

{
  char SystemNodeFlag;
  void *SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void *SystemRootNode;
  void *SystemCurrentNode;
  void *SystemNextNode;
  void *hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (void*)GetSystemRootPointer();
  SystemRootNode = (void *)*(long long *)SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp((void*)((long long)SystemCurrentNode + 4),&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((SystemCurrentNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,(void*)((long long)SystemCurrentNode + 4),0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void *SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  SystemCurrentNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  SystemCurrentNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  SystemCurrentNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  SystemCurrentNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeRenderingSystem(void)
/**
 * @brief 初始化渲染系统
 * 
 * 该函数负责初始化游戏渲染系统，设置渲染相关的系统节点和数据结构。
 * 通过遍历系统节点链表来配置渲染系统的初始化参数。
 */
void InitializeRenderingSystem(void)

{
  bool SystemNodeIsActive;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* RenderingInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





/**
 * @brief 初始化系统消息处理器
 * 
 * 该函数负责初始化系统的消息处理组件，设置消息操作的基础结构。
 * 它会创建消息处理缓冲区，配置消息回调函数，并建立消息处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保消息处理系统的正常运行
 */
void InitializeSystemMessageProcessor(void)

{
  void* SystemContextParameter;
  void* *messageProcessorReference;
  uint8_t *MessageConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t MessageConfigurationBuffer [136];
  
  messageProcessorReference = &SystemMessageProcessorNode;
  MessageConfigurationBuffer = MessageConfigurationBuffer;
  MessageConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 10;
  strcpy_s(MessageConfigurationBuffer,StringBufferSize,&SystemMessageProcessorTemplate,SystemContextParameter,InvalidHandleValue);
  SystemMessageProcessorHandle = InitializeMessageProcessorCallback(&messageProcessorReference);
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理组件，设置调试操作的基础结构。
 * 它会创建调试管理节点，配置调试回调函数，并建立调试管理标识符。
 * 
 * @return 初始化结果状态码
 * @note 这是系统初始化过程中的重要组成部分，确保调试管理系统的正常运行
 */
int InitializeSystemDebugManager(void)

{
  long long DebugManagerStatus;
  void* SystemRegisterValue;
  
  SystemConfigDataPointerF = &SystemGlobalDataPointerB;
  SystemGlobalDataReferenceA = &SystemGlobalDataBufferA;

/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志操作的基础结构。
 * 它会创建日志处理缓冲区，配置日志回调函数，并建立日志处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  void* SystemContextParameter;
  void* *logManagerReference;
  uint8_t *LogConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t LogConfigurationBuffer [136];
  
  logManagerReference = &SystemLogManagerNode;
  LogConfigurationBuffer = LogConfigurationBuffer;
  LogConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 9;
  strcpy_s(LogConfigurationBuffer,StringBufferSize,&SystemLogManagerTemplate,SystemContextParameter,InvalidHandleValue);
  SystemLogManagerHandle = InitializeLogManagerCallback(&logManagerReference);
  return;
}





/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控的基础结构。
 * 它会创建性能监控缓冲区，配置性能回调函数，并建立性能监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  void* SystemContextParameter;
  void* *performanceMonitorReference;
  uint8_t *PerformanceConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t PerformanceConfigurationBuffer [136];
  
  performanceMonitorReference = &SystemPerformanceMonitorNode;
  PerformanceConfigurationBuffer = PerformanceConfigurationBuffer;
  PerformanceConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 0xf;
  strcpy_s(PerformanceConfigurationBuffer,StringBufferSize,&SystemPerformanceMonitorTemplate,SystemContextParameter,InvalidHandleValue);
  SystemPerformanceMonitorHandle = InitializePerformanceMonitorCallback(&performanceMonitorReference);
  return;
}





/**
 * @brief 初始化系统安全监控器
 * 
 * 该函数负责初始化系统的安全监控组件，设置安全监控的基础结构。
 * 它会创建安全监控缓冲区，配置安全回调函数，并建立安全监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保安全监控系统的正常运行
 */
void InitializeSystemSecurityMonitor(void)

{
  void* SystemContextParameter;
  void* *securityMonitorReference;
  uint8_t *SecurityConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t SecurityConfigurationBuffer [136];
  
  securityMonitorReference = &SystemSecurityMonitorNode;
  SecurityConfigurationBuffer = SecurityConfigurationBuffer;
  SecurityConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 0xc;
  strcpy_s(SecurityConfigurationBuffer,StringBufferSize,&SystemSecurityMonitorTemplate,SystemContextParameter,InvalidHandleValue);
  SystemSecurityMonitorHandle = InitializeSecurityMonitorCallback(&securityMonitorReference);
  return;
}





/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源管理的基础结构。
 * 它会创建资源管理缓冲区，配置资源回调函数，并建立资源管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  void* SystemContextParameter;
  void* *resourceManagerReference;
  uint8_t *ResourceConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t ResourceConfigurationBuffer [136];
  
  resourceManagerReference = &SystemResourceManagerNode;
  ResourceConfigurationBuffer = ResourceConfigurationBuffer;
  ResourceConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 7;
  strcpy_s(ResourceConfigurationBuffer,StringBufferSize,&SystemResourceManagerTemplate,SystemContextParameter,InvalidHandleValue);
  SystemResourceManagerHandle = InitializeResourceManagerCallback(&resourceManagerReference);
  return;
}





/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络管理的基础结构。
 * 它会创建网络管理缓冲区，配置网络回调函数，并建立网络管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  void* SystemContextParameter;
  void* *networkManagerReference;
  uint8_t *NetworkConfigurationBuffer;
  uint32_t ConfigurationBufferSize;
  uint8_t NetworkConfigurationBuffer [136];
  
  networkManagerReference = &SystemNetworkManagerNode;
  NetworkConfigurationBuffer = NetworkConfigurationBuffer;
  NetworkConfigurationBuffer[0] = 0;
  ConfigurationBufferSize = 0x13;
  strcpy_s(NetworkConfigurationBuffer,StringBufferSize,&SystemNetworkManagerTemplate,SystemContextParameter,InvalidHandleValue);
  SystemNetworkManagerHandle = InitializeNetworkManagerCallback(&networkManagerReference);
  return;
}




/**
 * @brief 初始化系统存储管理器
 * 
 * 该函数负责初始化系统的存储管理组件，设置存储管理的基础结构。
 * 它会遍历系统存储节点树，进行内存比较，分配必要的内存，并设置存储节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保存储管理系统的正常运行
 */
void InitializeSystemStorageManager(void)

{
  char SystemNodeTraversalFlag;
  void** SystemDataTableReference;
  int NodeIdentifierComparisonResult;
  long long *systemMemoryAllocationPointer;
  long long systemTimestamp;
  void** SystemRootStorageNode;
  void** SystemCurrentStorageNode;
  void** SystemNextStorageNode;
  void** SystemPreviousStorageNode;
  void* StorageManagerCallbackFunction;
  
  SystemDataTableReference = (long long*)GetSystemRootPointer();
  SystemRootStorageNode = (void* *)*SystemDataTableReference;
  SystemNodeTraversalFlag = *(char*)((long long)SystemRootStorageNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  storageManagerCallbackFunction = SystemStorageManagerCallback;
  SystemPreviousStorageNode = SystemRootStorageNode;
  SystemCurrentStorageNode = (void* *)SystemRootStorageNode[1];
  while (SystemNodeTraversalFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentStorageNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextStorageNode = (void* *)SystemCurrentStorageNode[2];
      SystemCurrentStorageNode = SystemPreviousStorageNode;
    }
    else {
      SystemNextStorageNode = (void* *)*SystemCurrentStorageNode;
    }
    SystemPreviousStorageNode = SystemCurrentStorageNode;
    SystemCurrentStorageNode = SystemNextStorageNode;
    SystemNodeTraversalFlag = *(char*)((long long)SystemNextStorageNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((SystemCurrentStorageNode == SystemRootStorageNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateO,SystemCurrentStorageNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTableReference);
    void** SystemAllocatedStorageNode;
    AllocateSystemMemory(SystemDataTableReference,&systemAllocatedStorageNode,SystemPreviousStorageNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    SystemPreviousStorageNode = systemAllocatedStorageNode;
  }
  SystemCurrentStorageNode[6] = 0x40db4257e97d3df8;
  SystemCurrentStorageNode[7] = 0x81d539e33614429f;
  SystemCurrentStorageNode[8] = &SystemDataNodeN;
  SystemCurrentStorageNode[9] = 4;
  SystemPreviousStorageNode[10] = storageManagerCallbackFunction;
  return;
}




// 函数: void InitializeSystemMemoryManagerNode(void)
/**
 * @brief 初始化系统内存管理器节点
 * 
 * 该函数负责初始化系统的内存管理器节点，设置内存管理的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManagerNode(void)

{
  char SystemNodeTraversalFlag;
  void** SystemDataTableReference;
  int NodeIdentifierComparisonResult;
  long long *systemMemoryAllocationPointer;
  long long systemTimestamp;
  void** SystemRootMemoryNode;
  void** SystemCurrentMemoryNode;
  void* *SystemNextMemoryNode;
  void* *SystemPreviousMemoryNode;
  void* MemoryManagerCallbackFunction;
  
  SystemDataTableReference = (long long*)GetSystemRootPointer();
  SystemRootMemoryNode = (void* *)*SystemDataTableReference;
  SystemNodeTraversalFlag = *(char*)((long long)SystemRootMemoryNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  MemoryManagerCallbackFunction = SystemMemoryManagerCallback;
  SystemPreviousMemoryNode = SystemRootMemoryNode;
  SystemCurrentMemoryNode = (void* *)SystemRootMemoryNode[1];
  while (SystemNodeTraversalFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentMemoryNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextMemoryNode = (void* *)SystemCurrentMemoryNode[2];
      SystemCurrentMemoryNode = SystemPreviousMemoryNode;
    }
    else {
      SystemNextMemoryNode = (void* *)*SystemCurrentMemoryNode;
    }
    SystemPreviousMemoryNode = SystemCurrentMemoryNode;
    SystemCurrentMemoryNode = SystemNextMemoryNode;
    SystemNodeTraversalFlag = *(char*)((long long)SystemNextMemoryNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((SystemCurrentMemoryNode == SystemRootMemoryNode) || (NodeIdentifierComparisonResult = memcmp(&SystemMemoryComparisonTemplate,SystemCurrentMemoryNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTableReference);
    void* *SystemAllocatedMemoryNode;
    AllocateSystemMemory(SystemDataTableReference,&SystemAllocatedMemoryNode,SystemPreviousMemoryNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    SystemPreviousMemoryNode = SystemAllocatedMemoryNode;
  }
  SystemCurrentMemoryNode[6] = 0x4e33c4803e67a08f;
  SystemCurrentMemoryNode[7] = 0x703a29a844ce399;
  SystemCurrentMemoryNode[8] = &SystemDataNodeO;
  SystemCurrentMemoryNode[9] = 3;
  SystemPreviousMemoryNode[10] = MemoryManagerCallbackFunction;
  return;
}




// 函数: void InitializeSystemDataTableNode(void)
/**
 * @brief 初始化系统数据表节点
 * 
 * 该函数负责初始化系统的数据表节点，设置数据表操作的基础结构。
 * 它会遍历系统数据表节点树，进行内存比较，分配必要的内存，并设置数据表节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据表系统的正常运行
 */
void InitializeSystemDataTableNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点，设置配置操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置系统的正常运行
 */
void InitializeSystemConfigurationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventNode(void)
/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统的事件节点，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件系统的正常运行
 */
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNodeTreeProcessor(void)
/**
 * @brief 初始化系统节点树处理器
 * 
 * 该函数负责初始化系统的节点树处理组件，设置节点操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点树处理系统的正常运行
 */
void InitializeSystemNodeTreeProcessor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryPoolManager(void)
/**
 * @brief 初始化系统内存池管理器
 * 
 * 该函数负责初始化系统的内存池管理组件，设置内存池操作的基础结构。
 * 它会遍历系统内存池节点树，进行内存比较，分配必要的内存，并设置内存池属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存池管理系统的正常运行
 */
void InitializeSystemMemoryPoolManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemServiceManager(void)
/**
 * @brief 初始化系统服务管理器
 * 
 * 该函数负责初始化系统的服务管理组件，设置服务操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置服务节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保服务管理系统的正常运行
 */
void InitializeSystemServiceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventHandler(void)
/**
 * @brief 初始化系统事件处理器
 * 
 * 该函数负责初始化系统的事件处理组件，设置事件处理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置事件处理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件处理系统的正常运行
 */
void InitializeSystemEventHandler(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemTaskManager(void)
/**
 * @brief 初始化系统任务管理器
 * 
 * 该函数负责初始化系统的任务管理组件，设置任务操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置任务管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保任务管理系统的正常运行
 */
void InitializeSystemTaskManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDataProcessor(void)
/**
 * @brief 初始化系统数据处理器
 * 
 * 该函数负责初始化系统的数据处理组件，设置数据处理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置数据处理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据处理系统的正常运行
 */
void InitializeSystemDataProcessor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemCommunicationManager(void)
/**
 * @brief 初始化系统通信管理器
 * 
 * 该函数负责初始化系统的通信管理组件，设置通信操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置通信管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保通信管理系统的正常运行
 */
void InitializeSystemCommunicationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerEx(void)
/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理组件，设置内存操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置内存管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理组件，设置线程操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置线程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保线程管理系统的正常运行
 */
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理的基础数据结构。
 * 它会遍历系统节点树，查找资源管理器节点，并进行相应的初始化操作。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void** SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统浮点数计算器
 * 
 * 该函数负责初始化系统的浮点数计算组件，设置浮点运算的基础结构。
 * 它会计算浮点数的平方根值，进行数值归一化处理，并设置浮点计算表。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保浮点计算系统的正常运行
 */
void InitializeSystemFloatingPointCalculator(void)

{
  ulong long LoopCounter;
  float *FloatTablePointer;
  int NodeIdentifierComparisonResult;
  ulong long OuterLoopCounter;
  uint InnerLoopCounter;
  ulong long BaseCounter;
  int RangeOffset;
  float *CurrentFloatTable;
  float CalculatedValue;
  
  CurrentFloatTable = (float *)SYSTEM_FLOAT_TABLE_START_ADDRESS;
  BaseCounter = 0;
  RangeOffset = -3;
  OuterLoopCounter = BaseCounter;
  do {
    if (0 < (long long)OuterLoopCounter) {
      int InnerOffset = -3;
      LoopCounter = BaseCounter;
      FloatTablePointer = CurrentFloatTable;
      do {
        CalculatedValue = 0.0;
        if (-1 < (long long)LoopCounter) {
          if ((long long)LoopCounter < 3) {
            CalculatedValue = 0.75;
          }
          else {
            CalculatedValue = 1.0 - (float)InnerOffset / (float)RangeOffset;
            CalculatedValue = SQRT(CalculatedValue) * CalculatedValue;
          }
        }
        *FloatTablePointer = CalculatedValue;
        InnerOffset = InnerOffset + 1;
        FloatTablePointer = FloatTablePointer + 1;
        LoopCounter = LoopCounter + 1;
      } while ((long long)LoopCounter < (long long)OuterLoopCounter);
    }
    RangeOffset = RangeOffset + 1;
    OuterLoopCounter = OuterLoopCounter + 1;
    CurrentFloatTable = CurrentFloatTable + 0x40;
  } while ((long long)CurrentFloatTable < SYSTEM_FLOAT_TABLE_END_ADDRESS);
  CurrentFloatTable = (float *)SYSTEM_FLOAT_TABLE_SECOND_START_ADDRESS;
  do {
    InnerLoopCounter = (int)BaseCounter + 1;
    *CurrentFloatTable = 1.0 / SQRT((float)BaseCounter) + 1.0 / SQRT((float)BaseCounter);
    CurrentFloatTable = CurrentFloatTable + 1;
    BaseCounter = (ulong long)InnerLoopCounter;
  } while (InnerLoopCounter < 0x40);
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，设置事件处理的基础数据结构。
 * 它会遍历系统节点树，查找事件管理器节点，并进行相应的初始化操作。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *eventHandlerFunction;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  eventHandlerFunction = SystemEventDispatcher;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    long long MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    void** SystemAllocatedNode;
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSearchManager(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理组件，设置搜索功能的基础结构。
 * 它会遍历系统搜索节点树，进行内存比较，分配必要的内存，并设置搜索节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索管理系统的正常运行
 */
void InitializeSystemSearchManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateE,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x449bafe9b77ddd3c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc160408bde99e59f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemIndexManager(void)
/**
 * @brief 初始化系统索引管理器
 * 
 * 该函数负责初始化系统的索引管理组件，设置索引功能的基础结构。
 * 它会遍历系统索引节点树，进行内存比较，分配必要的内存，并设置索引节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保索引管理系统的正常运行
 */
void InitializeSystemIndexManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateD,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x406be72011d07d37;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x71876af946c867ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeTertiaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemCacheManager(void)
/**
 * @brief 初始化系统缓存管理器
 * 
 * 该函数负责初始化系统的缓存管理组件，设置缓存功能的基础结构。
 * 它会遍历系统缓存节点树，进行内存比较，分配必要的内存，并设置缓存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保缓存管理系统的正常运行
 */
void InitializeSystemCacheManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateG,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40afa5469b6ac06d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x2f4bab01d34055a5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuaternaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLogManager(void)
/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志功能的基础结构。
 * 它会遍历系统日志节点树，进行内存比较，分配必要的内存，并设置日志节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemPerformanceMonitor(void)
/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控的基础结构。
 * 它会遍历系统性能监控节点树，进行内存比较，分配必要的内存，并设置性能监控节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源管理的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventDispatcher(void)
/**
 * @brief 初始化系统事件分发器
 * 
 * 该函数负责初始化系统的事件分发组件，设置事件分发的基础结构。
 * 它会遍历系统事件分发节点树，进行内存比较，分配必要的内存，并设置事件分发节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件分发系统的正常运行
 */
void InitializeSystemEventDispatcher(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSecurityManager(void)
/**
 * @brief 初始化系统安全管理器
 * 
 * 该函数负责初始化系统的安全管理组件，设置安全管理的基础结构。
 * 它会遍历系统安全节点树，进行内存比较，分配必要的内存，并设置安全管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保安全管理系统的正常运行
 */
void InitializeSystemSecurityManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置管理的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemNetworkManager(void)
/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络管理的基础结构。
 * 它会遍历系统网络节点树，进行内存比较，分配必要的内存，并设置网络管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStorageManager(void)
/**
 * @brief 初始化系统存储管理器
 * 
 * 该函数负责初始化系统的存储管理组件，设置存储管理的基础结构。
 * 它会遍历系统存储节点树，进行内存比较，分配必要的内存，并设置存储管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保存储管理系统的正常运行
 */
void InitializeSystemStorageManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateO,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40db4257e97d3df8;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x81d539e33614429f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeN;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统进程管理器
 * 
 * 该函数负责初始化系统的进程管理组件，设置进程管理的基础结构。
 * 它会遍历系统进程节点树，进行内存比较，分配必要的内存，并设置进程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保进程管理系统的正常运行
 */
void InitializeSystemProcessManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemEventCallbackPointer;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemMemoryComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4e33c4803e67a08f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x703a29a844ce399;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeO;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理组件，设置线程管理的基础结构。
 * 它会遍历系统线程节点树，进行内存比较，分配必要的内存，并设置线程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保线程管理系统的正常运行
 */
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventProcessor(void)
// 系统事件处理器初始化函数
// 初始化系统事件处理相关的数据结构和回调函数
void InitializeSystemEventProcessor(void)

{
  char EventNodeFlag;
  void* *eventSystemDataTable;
  int NodeIdentifierComparisonResult;
  long long *eventMemoryPointer;
  long long eventSystemTimeValue;
  void* *eventRootNode;
  void* *eventCurrentNode;
  void* *eventNextNode;
  void* *eventPreviousNode;
  code *eventStackPointer;
  
  eventSystemDataTable = (long long*)GetSystemRootPointer();
  eventRootNode = (void* *)*eventSystemDataTable;
  EventNodeFlag = *(char*)((long long)eventRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  eventSearchFunctionPointer = GetSystemSearchFunctionD;
  eventPreviousNode = eventRootNode;
  eventCurrentNode = (void* *)eventRootNode[1];
  while (EventNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      eventNextNode = (void* *)eventCurrentNode[2];
      eventCurrentNode = eventPreviousNode;
    }
    else {
      eventNextNode = (void* *)*eventCurrentNode;
    }
    eventPreviousNode = eventCurrentNode;
    eventCurrentNode = eventNextNode;
    EventNodeFlag = *(char*)((long long)eventNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(eventSystemDataTable);
    AllocateSystemMemory(eventSystemDataTable,&eventAllocatedNode,eventPreviousNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    eventPreviousNode = eventAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  eventPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
// 功能: 初始化系统资源管理器，负责管理系统资源的分配和释放
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
// 功能: 初始化系统内存管理器，负责内存分配、释放和管理
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLogManager(void)
// 功能: 初始化系统日志管理器，负责系统日志的记录和管理
void InitializeSystemLogManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemPerformanceMonitor(void)
// 功能: 初始化系统性能监视器，负责监控系统性能指标
void InitializeSystemPerformanceMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemSecurityMonitor(void)
// 功能: 初始化系统安全监视器，负责系统安全监控和防护
void InitializeSystemSecurityMonitor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNetworkManager(void)
// 功能: 初始化系统网络管理器，负责网络连接和通信管理
void InitializeSystemNetworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateE,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x449bafe9b77ddd3c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc160408bde99e59f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStorageManager(void)
// 功能: 初始化系统存储管理器，负责数据存储和文件系统管理
void InitializeSystemStorageManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerNode(void)
// 功能: 初始化系统内存管理器节点，负责内存管理节点的初始化
void InitializeSystemMemoryManagerNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateO,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40db4257e97d3df8;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x81d539e33614429f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeN;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
// 功能: 初始化系统配置管理器，负责系统配置的加载和管理
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemEventCallbackPointer;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemMemoryComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4e33c4803e67a08f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x703a29a844ce399;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeO;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
// 功能: 初始化系统线程管理器，负责线程的创建、调度和管理
void InitializeSystemThreadManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateC,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x42bea5b911d9c4bf;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x1aa83fc0020dc1b6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeSecondaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
// 功能: 初始化系统进程管理器，负责进程的创建、调度和管理
void InitializeSystemProcessManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDeviceManager(void)
// 功能: 初始化系统设备管理器，负责硬件设备的检测和管理
void InitializeSystemDeviceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemServiceManager(void)
// 功能: 初始化系统服务管理器，负责系统服务的启动和管理
void InitializeSystemServiceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDriverManager(void)
// 功能: 初始化系统驱动管理器，负责设备驱动的加载和管理
void InitializeSystemDriverManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统模块管理器
 * 
 * 该函数负责初始化系统模块管理器，包括系统模块的加载、
 * 管理和配置。这是系统初始化过程的重要组成部分。
 * 
 * @return 无返回值
 * @note 此函数在系统启动时调用，用于建立模块管理基础设施
 */
void InitializeSystemModuleManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemComponentManager(void)
// 功能: 初始化系统组件管理器，负责系统组件的注册和管理
void InitializeSystemComponentManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemPluginManager(void)
// 功能: 初始化系统插件管理器，负责系统插件的加载和管理
void InitializeSystemPluginManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置参数的基础结构。
 * 它会创建配置缓冲区，设置配置字符串，并建立配置管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xc;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemConfigurationTemplateB,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntryPrimary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}




/**
 * @brief 初始化系统模块加载器
 * 
 * 该函数负责初始化系统的模块加载器组件，设置系统模块加载的基础指针和配置。
 * 它会初始化系统模块相关的全局变量，为后续的模块加载做准备。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化过程中的重要组成部分，确保模块加载系统的正常运行
 */
int InitializeSystemModuleLoader(void)

{
  long long systemModuleStatus;
  void* SystemModuleConfig;
  
  SystemModuleLoaderPrimary = &SystemModuleLoaderConfig;
  SystemModuleLoaderSecondary = &SystemModuleLoaderStatus;

// 函数: void InitializeSystemExtensionManager(void)
// 功能: 初始化系统扩展管理器，负责系统扩展的加载和管理
void InitializeSystemExtensionManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x16;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantA,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntrySecondary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





// 函数: void InitializeSystemLibraryManager(void)
// 功能: 初始化系统库管理器，负责系统库的加载和管理
void InitializeSystemLibraryManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x16;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantB,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntryTertiary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}




// 函数: void InitializeSystemFrameworkManager(void)
// 功能: 初始化系统框架管理器，负责系统框架的初始化和管理
void InitializeSystemFrameworkManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统搜索管理器D
 * 
 * 该函数负责初始化系统的搜索管理器组件，设置搜索相关的
 * 数据结构和回调函数。
 */
void InitializeSystemSearchManagerD(void)
{
  char IsSystemNodeActive;
  void** SystemDataTablePointer;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNodePointer;
  void** currentSystemNode;
  void** nextSystemNode;
  void** previousSystemNode;
  void** allocatedSystemNode;
  void* SystemSearchFunctionPointer;
  long long MemoryAllocationSize;
  
  SystemDataTablePointer = (long long*)GetSystemRootPointer();
  SystemRootNodePointer = (void**)*SystemDataTablePointer;
  IsSystemNodeActive = *(char*)((long long)SystemRootNodePointer[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  previousSystemNode = SystemRootNodePointer;
  currentSystemNode = (void**)SystemRootNodePointer[1];
  
  while (IsSystemNodeActive == '\0') {
    NodeIdentifierComparisonResult = memcmp(currentSystemNode + 4, &SystemDataComparisonTemplateI, SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    IsSystemNodeActive = *(char*)((long long)nextSystemNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  
  if ((previousSystemNode == SystemRootNodePointer) || 
      (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI, previousSystemNode + 4, SYSTEM_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTablePointer);
    AllocateSystemMemory(SystemDataTablePointer, &allocatedSystemNode, previousSystemNode, MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE, MemoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x431d7c8d7c475be2;
  previousSystemNode[7] = 0xb97f048d2153e1b0;
  previousSystemNode[8] = &SystemDataNodeF;
  previousSystemNode[9] = 4;
  previousSystemNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEntryPoint(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 初始化系统资源管理器中的资源节点，设置资源节点的配置和回调函数
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存节点
 * 
 * 初始化系统内存管理器中的内存节点，设置内存节点的配置和回调函数
 */
void InitializeSystemMemoryNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *systemInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationCallback = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表节点
 * 
 * 初始化系统数据表管理器中的数据表节点，设置数据表节点的配置和回调函数
 */
void InitializeSystemDataTableNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置节点
 * 
 * 初始化系统配置管理器中的配置节点，设置配置节点的配置数据和回调函数
 */
void InitializeSystemConfigurationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemConfigurationData;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemConfigurationData = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = systemConfigurationData;
  return;
}




// 函数: void InitializeSystemEventNode(void)
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadNode(void)
void InitializeSystemThreadNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateC,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x42bea5b911d9c4bf;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x1aa83fc0020dc1b6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeSecondaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemPerformanceNode(void)
void InitializeSystemPerformanceNode(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1c;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemInitializationStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntryQuaternary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}




// 函数: void InitializeSystemSecurityNode(void)
void InitializeSystemSecurityNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = SystemInitializationFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4fc124d23d41985f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xe2f4a30d6e6ae482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemNetworkNode(void)
void InitializeSystemNetworkNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4770584fbb1df897;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x47f249e43f66f2ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统音频节点
 * 
 * 该函数负责初始化系统音频节点，创建音频处理所需的系统节点结构。
 * 它会在系统数据表中查找或创建音频节点，并设置节点的标识符和回调函数。
 * 音频节点用于管理音频相关的资源和处理流程。
 * 
 * @return 无返回值
 * 
 * @note 该函数使用内存分配和节点比较操作来确保音频节点的正确初始化
 * @note 节点标识符为 0x4666df49b97e0f10 和 0x4e4b0d63a6ad1d8f
 * 
 *FUN_18005926c：InitializeSystemAudioNode
 */
void InitializeSystemAudioNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateP,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4666df49b97e0f10;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x4e4b0d63a6ad1d8f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateB;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统输入节点
 * 
 * 该函数负责初始化系统输入节点，创建输入处理所需的系统节点结构。
 * 它会在系统数据表中查找或创建输入节点，并设置节点的标识符和回调函数。
 * 输入节点用于管理用户输入相关的资源和处理流程。
 * 
 * @return 无返回值
 * 
 * @note 该函数使用内存分配和节点比较操作来确保输入节点的正确初始化
 * @note 节点标识符为 0x46ecbd4daf41613e 和 0xdc42c056bbde8482
 * 
 *FUN_180059350：InitializeSystemInputNode
 */
void InitializeSystemInputNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateQ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46ecbd4daf41613e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdc42c056bbde8482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统物理节点
 * 
 * 该函数负责初始化系统物理节点，创建物理处理所需的系统节点结构。
 * 它会在系统数据表中查找或创建物理节点，并设置节点的标识符和回调函数。
 * 物理节点用于管理物理模拟相关的资源和处理流程。
 * 
 * @return 无返回值
 * 
 * @note 该函数使用内存分配和节点比较操作来确保物理节点的正确初始化
 * @note 节点标识符为 0x4c868a42644030f6 和 0xc29193aa9d9b35b9
 * 
 *FUN_1800593b0：InitializeSystemPhysicsNode
 */
void InitializeSystemPhysicsNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c868a42644030f6;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc29193aa9d9b35b9;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统文件系统节点
 * 
 * 该函数负责初始化系统文件系统节点，创建文件系统处理所需的系统节点结构。
 * 它会在系统数据表中查找或创建文件系统节点，并设置节点的标识符和回调函数。
 * 文件系统节点用于管理文件操作相关的资源和处理流程。
 * 
 * @return 无返回值
 * 
 * @note 该函数使用内存分配和节点比较操作来确保文件系统节点的正确初始化
 * @note 节点标识符为 0x40ea3a798283cbbb 和 0x7f74eb2c5a7fadae
 * 
 *FUN_180059400：InitializeSystemFileSystemNode
 */
void InitializeSystemFileSystemNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40ea3a798283cbbb;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x7f74eb2c5a7fadae;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据库节点
 * 
 * 该函数负责初始化系统数据库节点，创建数据库处理所需的系统节点结构。
 * 它会在系统数据表中查找或创建数据库节点，并设置节点的标识符和回调函数。
 * 数据库节点用于管理数据库操作相关的资源和处理流程。
 * 
 * @return 无返回值
 * 
 * @note 该函数使用内存分配和节点比较操作来确保数据库节点的正确初始化
 * @note 节点标识符为 SYSTEM_EVENT_NODE_IDENTIFIER1 和 SYSTEM_EVENT_NODE_IDENTIFIER2
 * 
 *FUN_180059450：InitializeSystemDatabaseNode
 */
void InitializeSystemDatabaseNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeStringProcessingSystem(void)
/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置系统配置节点的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置系统配置节点的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和内存管理。
 * 
 * @return 无返回值
 * 
 * @note 该函数使用内存分配和节点比较操作来确保配置节点的正确初始化
 * @note 节点标识符为 SYSTEM_RESOURCE_NODE_IDENTIFIER1 和 SYSTEM_RESOURCE_NODE_IDENTIFIER2
 * 
 *FUN_1800594a0：InitializeSystemConfigurationManager
 */
void InitializeSystemConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemCallbackManager;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateR,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x421c3cedd07d816d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xbec25de793b7afa6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeResourceManagementSystem(void)
/**
 * @brief 初始化系统网络配置管理器
 * 
 * 该函数负责初始化系统的网络配置管理组件，设置网络配置节点的基础结构。
 * 它会遍历系统网络配置节点树，进行内存比较，分配必要的内存，并设置网络配置节点属性。
 * 该函数还负责配置系统网络资源的初始化回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络配置管理系统的正常运行
 */
void InitializeSystemNetworkConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateB,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c22bb0c326587ce;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x5e3cf00ce2978287;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateE;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeDataTableManager(void)
/**
 * @brief 初始化系统搜索配置管理器
 * 
 * 该函数负责初始化系统的搜索配置管理组件，设置搜索配置节点的基础结构。
 * 它会遍历系统搜索配置节点树，进行内存比较，分配必要的内存，并设置搜索配置节点属性。
 * 该函数还负责配置系统搜索功能的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索配置管理系统的正常运行
 */
void InitializeSystemSearchConfigurationManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}





// 函数: void InitializeSystemConfiguration(void)
/**
 * @brief 初始化系统调试信息管理器
 * 
 * 该函数负责初始化系统的调试信息管理组件，设置调试信息的基础结构。
 * 它会配置调试信息的字符串缓冲区，设置调试信息的处理函数，并建立调试信息的管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试信息管理系统的正常运行
 */
void InitializeSystemDebugInfoManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 9;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemConfigurationStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntryQuinary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





// 函数: void InitializeSystemMemoryAllocator(void)
/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志处理的基础结构。
 * 它会配置日志信息的字符串缓冲区，设置日志信息的处理函数，并建立日志信息的管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 8;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemResourceStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntrySenary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





// 函数: void InitializeSystemStringProcessorA(void)
/**
 * @brief 初始化系统字符串处理器A
 * 
 * 该函数负责初始化系统的字符串处理组件A，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorA(void)

{
  void* SystemRegisterValue;
  void* *SystemStringPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemStringPointer = &SystemStringConstant;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xb;
  strcpy_s(SystemStringBuffer,0x80,&SystemStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemStringProcessorA = SystemStringProcessingCallback(&systemStringPointer);
  return;
}





// 函数: void InitializeSystemStringProcessorB(void)
/**
 * @brief 初始化系统字符串处理器B
 * 
 * 该函数负责初始化系统的字符串处理组件B，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorB(void)

{
  void* SystemRegisterValue;
  void* *SystemStringPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemStringPointer = &SystemStringConstant;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xd;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringTemplateB,SystemRegisterValue,InvalidHandleValue);
  SystemStringProcessorB = SystemStringProcessingCallback(&SystemStringPointer);
  return;
}





// 函数: void InitializeSystemStringProcessorC(void)
/**
 * @brief 初始化系统字符串处理器C
 * 
 * 该函数负责初始化系统的字符串处理组件C，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorC(void)

{
  void* SystemRegisterValue;
  void* *SystemStringPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemStringPointer = &SystemStringConstant;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1c;
  strcpy_s(SystemStringBuffer,0x80,&SystemStringTemplateC,SystemRegisterValue,InvalidHandleValue);
  SystemStringProcessorC = SystemStringProcessingCallback(&systemStringPointer);
  return;
}





// 函数: void InitializeSystemStringProcessorA(void)
void InitializeSystemStringProcessorA(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x15;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemMemoryStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntrySeptenary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





// 函数: void InitializeSystemStringProcessorB(void)
void InitializeSystemStringProcessorB(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xe;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemThreadStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntryOctonary = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





/**
 * @brief 初始化系统字符串处理器C
 * 
 * 该函数负责初始化系统的字符串处理组件C，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorC(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1a;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemFileSystemStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry009 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





/**
 * @brief 初始化系统字符串处理器D
 * 
 * 该函数负责初始化系统的字符串处理组件D，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorD(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x13;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemNetworkStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry010 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}




// 函数: void InitializeSystemStringProcessorE(void)
void InitializeSystemStringProcessorE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorF(void)
void InitializeSystemStringProcessorF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorG(void)
void InitializeSystemStringProcessorG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorH(void)
void InitializeSystemStringProcessorH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorI(void)
void InitializeSystemStringProcessorI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorJ(void)
void InitializeSystemStringProcessorJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorK(void)
void InitializeSystemStringProcessorK(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorL(void)
void InitializeSystemStringProcessorL(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorM(void)
void InitializeSystemStringProcessorM(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorN(void)
void InitializeSystemStringProcessorN(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorO(void)
void InitializeSystemStringProcessorO(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorP(void)
void InitializeSystemStringProcessorP(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorQ(void)
void InitializeSystemStringProcessorQ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorR(void)
void InitializeSystemStringProcessorR(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorS(void)
void InitializeSystemStringProcessorS(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorT(void)
void InitializeSystemStringProcessorT(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorU(void)
void InitializeSystemStringProcessorU(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorV(void)
void InitializeSystemStringProcessorV(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorW(void)
void InitializeSystemStringProcessorW(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorX(void)
void InitializeSystemStringProcessorX(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorY(void)
void InitializeSystemStringProcessorY(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统字符串处理器Z
 * 
 * 该函数负责初始化系统字符串处理器Z，设置字符串处理的相关参数和配置。
 * 用于系统字符串处理的初始化工作。
 * 
 * @param void 无参数
 * @return void 无返回值
 */
void InitializeSystemStringProcessorZ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerA(void)
void InitializeSystemMemoryManagerA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerB(void)
void InitializeSystemMemoryManagerB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerC(void)
void InitializeSystemMemoryManagerC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerD(void)
void InitializeSystemMemoryManagerD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerE(void)
void InitializeSystemMemoryManagerE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerF(void)
void InitializeSystemMemoryManagerF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 系统初始化函数 - 内存分配器设置
 * 
 * 该函数负责初始化系统内存分配器，设置内存池和数据结构
 * 用于管理游戏运行时的内存分配和释放
 */
void InitializeSystemMemoryAllocatorSetup(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = SystemInitializationFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4fc124d23d41985f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xe2f4a30d6e6ae482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 系统初始化函数 - 数据表配置器
 * 
 * 该函数负责初始化系统数据表配置器，设置数据结构和索引
 * 用于管理游戏运行时的数据存储和检索
 */
void InitializeSystemDataTableConfigurator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4770584fbb1df897;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x47f249e43f66f2ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerG(void)
void InitializeSystemMemoryManagerG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateP,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4666df49b97e0f10;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x4e4b0d63a6ad1d8f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateB;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerH(void)
void InitializeSystemMemoryManagerH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateQ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46ecbd4daf41613e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdc42c056bbde8482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerI(void)
void InitializeSystemMemoryManagerI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c868a42644030f6;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc29193aa9d9b35b9;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理组件，设置配置数据节点操作的基础结构。
 * 它会遍历系统配置数据节点树，进行内存比较，分配必要的内存，并设置配置数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置数据节点管理系统的正常运行
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40ea3a798283cbbb;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x7f74eb2c5a7fadae;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理组件，设置事件数据节点操作的基础结构。
 * 它会遍历系统事件数据节点树，进行内存比较，分配必要的内存，并设置事件数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件数据节点管理系统的正常运行
 */
void InitializeSystemEventDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventSystem(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统资源节点，设置资源节点的相关配置和回调函数。
 * 它会遍历系统资源树，找到合适的位置插入新的资源节点，并设置节点的属性。
 * 
 * @note 这是一个系统资源管理的核心函数，确保资源节点的正确初始化
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemTimerManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理组件，设置内存节点操作的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存节点管理系统的正常运行
 */
void InitializeSystemMemoryNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemCallbackManager;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateR,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x421c3cedd07d816d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xbec25de793b7afa6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemCore(void)
/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理组件，设置设备节点操作的基础结构。
 * 它会遍历系统设备节点树，进行内存比较，分配必要的内存，并设置设备节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保设备节点管理系统的正常运行
 */
void InitializeSystemDeviceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateB,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c22bb0c326587ce;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x5e3cf00ce2978287;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateE;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理组件，设置字符串处理的相关配置。
 * 它会初始化字符串处理所需的数据结构和缓冲区。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessor(void)

{
  void* SystemRegisterValue;
  void* *SystemStackPointerPrimary;
  uint8_t *SystemStackBufferPointer;
  uint32_t SystemConfigurationFlag;
  uint8_t SystemStringProcessingBuffer [136];
  
  SystemStackPointerPrimary = &SystemGlobalDataTertiary;
  SystemStackBufferPointer = SystemStringProcessingBuffer;
  SystemStringProcessingBuffer[0] = 0;
  SystemConfigurationFlag = 0x16;
  strcpy_s(SystemStringProcessingBuffer,0x80,&SystemSecurityStringTemplate,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry011 = SystemMemoryAllocationFunction(&SystemStackPointerPrimary);
  return;
}




/**
 * @brief 初始化系统服务管理器
 * 
 * 该函数负责初始化系统的服务管理器组件，设置系统服务管理的基础指针和配置。
 * 它会初始化系统服务相关的全局变量，为后续的服务管理做准备。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化过程中的重要组成部分，确保服务管理系统的正常运行
 */
int InitializeSystemServiceManager(void)

{
  long long systemServiceStatus;
  void* systemServiceConfig;
  
  SystemServiceManagerPrimary = &SystemServiceManagerConfig;
  SystemServiceManagerSecondary = &SystemServiceManagerStatus;

/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理器，设置内存节点的相关配置和状态。
 * 它会初始化内存管理所需的数据结构和节点信息。
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存节点的正确管理
 */
void InitializeSystemMemoryNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = SystemInitializationFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4fc124d23d41985f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xe2f4a30d6e6ae482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理器，设置设备节点的相关配置和状态。
 * 它会初始化设备管理所需的数据结构和节点信息。
 * 
 * @note 这是系统设备管理的重要组成部分，确保设备节点的正确管理
 */
void InitializeSystemDeviceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4770584fbb1df897;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x47f249e43f66f2ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理器，设置配置节点的相关配置和状态。
 * 它会初始化配置管理所需的数据结构和节点信息。
 * 
 * @note 这是系统配置管理的重要组成部分，确保配置节点的正确管理
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateP,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4666df49b97e0f10;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x4e4b0d63a6ad1d8f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateB;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理器，设置事件节点的相关配置和状态。
 * 它会初始化事件管理所需的数据结构和节点信息。
 * 
 * @note 这是系统事件管理的重要组成部分，确保事件节点的正确管理
 */
void InitializeSystemEventDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateQ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46ecbd4daf41613e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdc42c056bbde8482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryAllocatorNode(void)
/**
 * @brief 初始化系统内存分配器节点
 * 
 * 该函数负责初始化系统的内存分配器节点，设置内存分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入内存分配器节点，
 * 并设置节点的标识符和回调函数。
 */
void InitializeSystemMemoryAllocatorNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c868a42644030f6;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc29193aa9d9b35b9;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点，设置系统配置的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入配置节点，
 * 并设置节点的标识符和配置数据。
 */
void InitializeSystemConfigurationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40ea3a798283cbbb;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x7f74eb2c5a7fadae;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventNode(void)
/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统的事件节点，设置系统事件处理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入事件节点，
 * 并设置节点的标识符和事件数据。
 */
void InitializeSystemEventNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceNode(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点，设置系统资源管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源节点，
 * 并设置节点的标识符和资源数据。
 */
void InitializeSystemResourceNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDataNode(void)
/**
 * @brief 初始化系统数据节点
 * 
 * 该函数负责初始化系统的数据节点，设置系统数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据节点，
 * 并设置节点的标识符和数据指针。
 */
void InitializeSystemDataNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemCallbackManager;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateR,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x421c3cedd07d816d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xbec25de793b7afa6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessor(void)
/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理器，设置字符串处理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入字符串处理器节点，
 * 并设置节点的标识符和字符串处理回调函数。
 */
void InitializeSystemStringProcessor(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateB,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c22bb0c326587ce;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x5e3cf00ce2978287;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateE;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemMemoryNodeManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理器，设置内存节点管理的基础结构。
 * 它会创建内存节点的标识符，并设置相关的内存管理回调函数。
 */
void InitializeSystemMemoryNodeManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x12;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringTemplateA,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry012 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





// 函数: void InitializeSystemDeviceNodeManager(void)
/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理器，设置设备节点管理的基础结构。
 * 它会创建设备节点的标识符，并设置相关的设备管理回调函数。
 */
void InitializeSystemDeviceNodeManager(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 8;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringTemplateB,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry013 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}




// 函数: void InitializeSystemConfigurationDataNodeManager(void)
/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理器，设置配置数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入配置数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventDataNodeManager(void)
/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理器，设置事件数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入事件数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemEventDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceDataNodeManager(void)
/**
 * @brief 初始化系统资源数据节点管理器
 * 
 * 该函数负责初始化系统的资源数据节点管理器，设置资源数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemResourceDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDataNodeManager(void)
/**
 * @brief 初始化系统数据节点管理器
 * 
 * 该函数负责初始化系统的数据节点管理器，设置数据节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringDataNodeManager(void)
/**
 * @brief 初始化系统字符串数据节点管理器
 * 
 * 该函数负责初始化系统的字符串数据节点管理器，设置字符串数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入字符串数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemStringDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryDataNodeManager(void)
/**
 * @brief 初始化系统内存数据节点管理器
 * 
 * 该函数负责初始化系统的内存数据节点管理器，设置内存数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入内存数据节点，
 * 并设置节点的标识符和内存管理回调函数。
 */
void InitializeSystemMemoryDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemDeviceDataNodeManager(void)
/**
 * @brief 初始化系统设备数据节点管理器
 * 
 * 该函数负责初始化系统的设备数据节点管理器，设置设备数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入设备数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemDeviceDataNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统全局数据表
 * 
 * 该函数负责初始化系统的全局数据表指针，设置系统数据访问的入口点。
 * 它会配置全局数据表的引用，确保其他系统组件可以正确访问系统数据。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化的基础步骤，为后续的系统组件初始化提供数据访问支持
 */
int InitializeSystemGlobalDataTable(void)

{
  long long DataTableStatus;
  void* SystemRegisterValue;
  
  SystemGlobalDataPointerD = &SystemMemoryNodeTemplateA;
  SystemGlobalDataReferenceB = &SystemGlobalDataBufferB;

// 函数: void InitializeSystemSearchNodeManager(void)
/**
 * @brief 初始化系统搜索节点管理器
 * 
 * 该函数负责初始化系统的搜索节点管理器，设置搜索节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入搜索节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemSearchNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDebugNodeManager(void)
/**
 * @brief 初始化系统调试节点管理器
 * 
 * 该函数负责初始化系统的调试节点管理器，设置调试节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入调试节点，
 * 并设置节点的标识符和调试回调函数。
 */
void InitializeSystemDebugNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLoggingNodeManager(void)
/**
 * @brief 初始化系统日志节点管理器
 * 
 * 该函数负责初始化系统的日志节点管理器，设置日志节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入日志节点，
 * 并设置节点的标识符和日志回调函数。
 */
void InitializeSystemLoggingNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemPerformanceNodeManager(void)
/**
 * @brief 初始化系统性能节点管理器
 * 
 * 该函数负责初始化系统的性能节点管理器，设置性能节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入性能节点，
 * 并设置节点的标识符和性能监控回调函数。
 */
void InitializeSystemPerformanceNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSecurityNodeManager(void)
/**
 * @brief 初始化系统安全节点管理器
 * 
 * 该函数负责初始化系统的安全节点管理器，设置安全节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入安全节点，
 * 并设置节点的标识符和安全检查回调函数。
 */
void InitializeSystemSecurityNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemNetworkNodeManager(void)
/**
 * @brief 初始化系统网络节点管理器
 * 
 * 该函数负责初始化系统的网络节点管理器，设置网络节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入网络节点，
 * 并设置节点的标识符和网络回调函数。
 */
void InitializeSystemNetworkNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadNodeManager(void)
/**
 * @brief 初始化系统线程节点管理器
 * 
 * 该函数负责初始化系统的线程节点管理器，设置线程节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入线程节点，
 * 并设置节点的标识符和线程管理回调函数。
 */
void InitializeSystemThreadNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemProcessNodeManager(void)
/**
 * @brief 初始化系统进程节点管理器
 * 
 * 该函数负责初始化系统的进程节点管理器，设置进程节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入进程节点，
 * 并设置节点的标识符和进程管理回调函数。
 */
void InitializeSystemProcessNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
/**
 * @brief 初始化系统事件管理器G
 * 
 * 该函数负责初始化系统的第七个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDataTableManager(void)
/**
 * @brief 初始化系统事件管理器H
 * 
 * 该函数负责初始化系统的第八个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统事件管理器I
 * 
 * 该函数负责初始化系统的第九个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventManagerJ(void)
// 功能: 初始化系统事件管理器J，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置事件回调指针
void InitializeSystemEventManagerJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventManagerK(void)
// 功能: 初始化系统事件管理器K，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置资源初始化回调
void InitializeSystemEventManagerK(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventManagerL(void)
// 功能: 初始化系统事件管理器L，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置系统回调指针
void InitializeSystemEventManagerL(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemEventManagerM(void)
// 功能: 初始化系统事件管理器M，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置相关系统配置
void InitializeSystemEventManagerM(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemEventManagerN(void)
// 功能: 初始化系统事件管理器N，用于管理特定类型的事件处理
// 该函数会设置系统字符串配置并初始化相关系统组件
void InitializeSystemEventManagerN(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1b;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringTemplateC,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry014 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}



/**
 * @brief 初始化系统模块A
 * 
 * 该函数负责初始化系统的A类模块，执行系统预初始化并验证系统配置。
 * 这是系统初始化过程中的重要步骤，确保系统配置的正确性。
 * 
 * @return 返回初始化状态码，0表示成功，非0表示失败
 * @note 此函数在系统启动时调用，用于初始化核心系统组件
 */
int InitializeSystemModuleA(void)

{
  long long SystemOperationStatus;
  
  ExecuteSystemPreInitialization();
  SystemOperationStatus = ValidateSystemConfiguration(SystemConfigValidatorPrimary);
  return (SystemOperationStatus != 0) - 1;
}



/**
 * @brief 初始化系统模块B
 * 
 * 该函数负责初始化系统的B类模块，配置系统模块并验证系统配置。
 * 它会设置系统配置数据表，然后验证配置的正确性。
 * 
 * @return 返回初始化状态码，0表示成功，非0表示失败
 * @note 此函数在系统启动时调用，用于初始化系统配置组件
 */
int InitializeSystemModuleB(void)

{
  long long SystemOperationStatus;
  uint8_t SystemConfigBuffer [32];
  
  SystemConfigBuffer[0] = 1;
  ConfigureSystemModule(&SystemConfigDataTableA,SystemConfigBuffer);
  SystemOperationStatus = ValidateSystemConfiguration(SystemConfigValidatorSecondary);
  return (SystemOperationStatus != 0) - 1;
}



int InitializeSystemModuleC(void)

{
  long long SystemOperationStatus;
  uint8_t SystemConfigBuffer [32];
  
  SystemConfigBuffer[0] = 0;
  ConfigureSystemModule(&SystemConfigDataTableB,SystemConfigBuffer);
  SystemOperationStatus = ValidateSystemConfiguration(SystemConfigValidatorTertiary);
  return (SystemOperationStatus != 0) - 1;
}



int InitializeSystemModuleD(void)

{
  long long SystemOperationStatus;
  
  SystemOperationStatus = ValidateSystemConfiguration(SystemConfigValidatorQuaternary);
  return (SystemOperationStatus != 0) - 1;
}



int InitializeSystemModuleE(void)

{
  long long SystemOperationStatus;
  
  InitializeSystemSecurityContext(SYSTEM_SECURITY_CONTEXT_ADDRESS);
  SystemOperationStatus = ValidateSystemConfiguration(SystemConfigValidatorQuinary);
  return (SystemOperationStatus != 0) - 1;
}




// 函数: void InitializeSystemResourceManagerA(void)
// 功能: 初始化系统资源管理器A，用于管理游戏核心系统资源
// 该函数会创建系统节点并设置游戏核心系统ID和初始化函数
void InitializeSystemResourceManagerA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = SystemInitializationFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4fc124d23d41985f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xe2f4a30d6e6ae482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManagerB(void)
// 功能: 初始化系统资源管理器B，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的回调函数
void InitializeSystemResourceManagerB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4770584fbb1df897;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x47f249e43f66f2ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerC(void)
// 功能: 初始化系统资源管理器C，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的配置参数
void InitializeSystemResourceManagerC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateP,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4666df49b97e0f10;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x4e4b0d63a6ad1d8f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateB;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerD(void)
// 功能: 初始化系统资源管理器D，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的处理函数
void InitializeSystemResourceManagerD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateQ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46ecbd4daf41613e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdc42c056bbde8482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerE(void)
// 功能: 初始化系统资源管理器E，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的初始化参数
void InitializeSystemResourceManagerE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c868a42644030f6;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc29193aa9d9b35b9;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统配置资源管理器
 * 设置系统配置标识符和相关数据结构
 */
void InitializeSystemResourceManagerF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40ea3a798283cbbb;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x7f74eb2c5a7fadae;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统事件资源管理器
 * 设置系统事件标识符和相关数据结构
 */
void InitializeSystemResourceManagerG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统资源管理器
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统资源管理器I
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemCallbackManager;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateR,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x421c3cedd07d816d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xbec25de793b7afa6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * 初始化系统资源管理器J
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateB,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c22bb0c326587ce;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x5e3cf00ce2978287;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateE;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





/**
 * 初始化系统资源管理器K
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerK(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x10;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringTemplateD,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry015 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





/**
 * 初始化系统资源管理器L
 * 处理系统资源字符串初始化
 */
void InitializeSystemResourceManagerL(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xf;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantC,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry016 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





/**
 * 初始化系统资源管理器M
 * 处理系统资源字符串初始化
 */
void InitializeSystemResourceManagerM(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x19;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantD,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry017 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





/**
 * 初始化系统资源管理器N
 * 处理系统资源初始化
 */
void InitializeSystemResourceManagerN(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x14;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantE,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryAllocationTableEntry018 = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}




int InitializeSystemModuleF(void)

{
  long long SystemOperationStatus;
  void* SystemRegister;
  
  SystemGlobalDataPointerE = &SystemMemoryNodeTemplateB;
  SystemGlobalDataReferenceC = &SystemGlobalDataBufferC;

/**
 * 初始化系统调试管理器A
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateS,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46c54bc98fc3fc2a;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x727b256e3af32585;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统调试管理器B
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateT,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x41ffd0b76c1e136f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x25db30365f277abb;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统调试管理器C
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = SystemInitializationFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4fc124d23d41985f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xe2f4a30d6e6ae482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统的资源分配器组件，设置资源分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源分配器节点，
 * 并设置节点的标识符和回调函数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源分配系统的正常运行
 */
void InitializeSystemResourceAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4770584fbb1df897;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x47f249e43f66f2ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表分配器
 * 
 * 该函数负责初始化系统的数据表分配器组件，设置数据表分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据表分配器节点，
 * 并设置节点的标识符和回调函数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据表分配系统的正常运行
 */
void InitializeSystemDataTableAllocator(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateP,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4666df49b97e0f10;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x4e4b0d63a6ad1d8f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateB;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemResourceComponent
// 初始化系统资源组件，负责管理系统资源的分配和释放
void InitializeSystemResourceComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateQ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46ecbd4daf41613e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdc42c056bbde8482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemAllocatorComponent
// 初始化系统内存分配器组件，负责管理内存分配策略
void InitializeSystemAllocatorComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c868a42644030f6;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc29193aa9d9b35b9;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemConfigurationComponent
// 初始化系统配置组件，负责管理系统配置信息
void InitializeSystemConfigurationComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40ea3a798283cbbb;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x7f74eb2c5a7fadae;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemCoreComponent
// 初始化系统核心组件，负责管理核心系统功能
void InitializeSystemCoreComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemMemoryComponent
// 初始化系统内存管理组件，负责内存池管理
void InitializeSystemMemoryComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemThreadComponent
// 初始化系统线程组件，负责线程管理和同步
void InitializeSystemThreadComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemCallbackManager;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateR,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x421c3cedd07d816d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xbec25de793b7afa6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemEventComponent
// 初始化系统事件组件，负责事件处理和分发
void InitializeSystemEventComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateB,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c22bb0c326587ce;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x5e3cf00ce2978287;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateE;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemSecurityComponent
// 初始化系统安全组件，负责系统安全策略
void InitializeSystemSecurityComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateS,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46c54bc98fc3fc2a;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x727b256e3af32585;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemNetworkComponent
// 初始化系统网络组件，负责网络通信
void InitializeSystemNetworkComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateT,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x41ffd0b76c1e136f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x25db30365f277abb;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemDatabaseComponent
// 初始化系统数据库组件，负责数据存储
void InitializeSystemDatabaseComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateF,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x45425dc186a5d575;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xfab48faa65382fa5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeM;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemLoggingComponent
// 初始化系统日志组件，负责日志记录
void InitializeSystemLoggingComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateE,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x449bafe9b77ddd3c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc160408bde99e59f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemPerformanceComponent
// 初始化系统性能监控组件，负责性能分析
void InitializeSystemPerformanceComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateD,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x406be72011d07d37;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x71876af946c867ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeTertiaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemDiagnosticComponent
// 初始化系统诊断组件，负责系统诊断
void InitializeSystemDiagnosticComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateG,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40afa5469b6ac06d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x2f4bab01d34055a5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuaternaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemDebugComponent
// 初始化系统调试组件，负责调试功能
void InitializeSystemDebugComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemPluginComponent
// 初始化系统插件组件，负责插件管理
void InitializeSystemPluginComponent(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateI,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentA(void)
// 功能: 初始化系统子组件A - 负责系统资源初始化回调的设置
// 该函数通过系统根指针遍历系统节点，设置资源初始化相关的回调函数和系统标识
void InitializeSystemSubcomponentA(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateJ,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateJ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentB(void)
// 功能: 初始化系统子组件B - 负责系统事件回调的设置
// 该函数通过系统根指针遍历系统节点，设置事件处理相关的回调函数和系统标识
void InitializeSystemSubcomponentB(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateK,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentC(void)
// 功能: 初始化系统子组件C - 负责系统内存管理组件的初始化
// 该函数初始化系统内存管理相关的数据结构和配置参数
void InitializeSystemSubcomponentC(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateL,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentD(void)
// 功能: 初始化系统子组件D - 负责系统线程管理组件的初始化
// 该函数初始化系统线程管理相关的数据结构和同步机制
void InitializeSystemSubcomponentD(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentE(void)
// 功能: 初始化系统子组件E - 负责系统文件管理组件的初始化
// 该函数初始化系统文件管理相关的数据结构和文件句柄
void InitializeSystemSubcomponentE(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentF(void)
// 功能: 初始化系统子组件F - 负责系统网络管理组件的初始化
// 该函数初始化系统网络管理相关的数据结构和网络配置
void InitializeSystemSubcomponentF(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateC,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x42bea5b911d9c4bf;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x1aa83fc0020dc1b6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeSecondaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentG(void)
// 功能: 初始化系统子组件G - 负责系统安全管理组件的初始化
// 该函数初始化系统安全管理相关的数据结构和访问控制
void InitializeSystemSubcomponentG(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateS,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46c54bc98fc3fc2a;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x727b256e3af32585;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentH(void)
// 功能: 初始化系统子组件H - 负责系统日志管理组件的初始化
// 该函数初始化系统日志管理相关的数据结构和日志配置
void InitializeSystemSubcomponentH(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateT,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x41ffd0b76c1e136f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x25db30365f277abb;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: int InitializeSystemSynchronizationMechanism(void)
/**
 * @brief 初始化系统同步机制
 * 
 * 该函数负责初始化系统的同步机制，包括互斥锁初始化、
 * 同步数据结构设置和系统同步状态管理。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemSynchronizationMechanism(void)

{
  long long systemInitializationResult;
  
  InitializeSystemSynchronizationData(&SystemSynchronizationDataPrimary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemSynchronizationData(&SystemSynchronizationDataSecondary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemSynchronizationData(&SystemSynchronizationDataTertiary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemMutex(&SystemSynchronizationMutex,2);
  SystemSynchronizationStatusPrimary = 0;
  SystemSynchronizationStatusSecondary = 0;
  SystemSynchronizationStatusTertiary = 0;
  SystemSynchronizationFlagPrimary = 3;
  SystemSynchronizationStatusQuaternary = 0;
  SystemSynchronizationStatusQuinary = 0;
  SystemSynchronizationStatusSenary = 0;
  SystemSynchronizationFlagSecondary = 3;
  SystemSynchronizationStatusSeptenary = 0;
  SystemSynchronizationStatusOctonary = 0;
  SystemSynchronizationFlagTertiary = 3;
  InitializeSystemSynchronizationCore();
  systemInitializationResult = CheckSystemSynchronizationStatus(&SystemSynchronizationControlData);
  return (systemInitializationResult != 0) - 1;
}




// 函数: int InitializeSystemPerformanceMonitor(void)
/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控数据结构
 * 和性能计数器，为系统性能分析提供基础支持。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemPerformanceMonitor(void)

{
  long long systemInitializationResult;
  void* SystemParameter;
  
  SystemPerformanceMonitorData = &SystemPerformanceMonitorConfiguration;
  SystemPerformanceMonitorStatus = &SystemPerformanceMonitorStatusData;

// 函数: void InitializeSystemSubcomponentI(void)
// 功能: 初始化系统子组件I - 负责系统性能监控组件的初始化
// 该函数初始化系统性能监控相关的数据结构和性能计数器
void InitializeSystemSubcomponentI(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateS,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46c54bc98fc3fc2a;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x727b256e3af32585;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentJ(void)
// 功能: 初始化系统子组件J - 负责系统配置管理组件的初始化
// 该函数初始化系统配置管理相关的数据结构和配置参数
void InitializeSystemSubcomponentJ(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateT,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x41ffd0b76c1e136f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x25db30365f277abb;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentK(void)
// 功能: 初始化系统子组件K - 负责系统插件管理组件的初始化
// 该函数初始化系统插件管理相关的数据结构和插件接口
void InitializeSystemSubcomponentK(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateS,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46c54bc98fc3fc2a;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x727b256e3af32585;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentL(void)
// 功能: 初始化系统子组件L - 负责系统调试管理组件的初始化
// 该函数初始化系统调试管理相关的数据结构和调试工具
void InitializeSystemSubcomponentL(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateT,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x41ffd0b76c1e136f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x25db30365f277abb;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: void InitializeSystemSubcomponentM(void)
// 功能: 初始化系统子组件M - 负责系统备份管理组件的初始化
// 该函数初始化系统备份管理相关的数据结构和备份策略
void InitializeSystemSubcomponentM(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0xd;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantErrorMessageA,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryRegionCacheB = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}



/**
 * @brief 初始化系统互斥锁
 * 
 * 该函数负责初始化系统的互斥锁机制，确保多线程环境下的资源同步访问。
 * 它使用 mtx_init_in_situ 函数来初始化互斥锁，并设置适当的同步参数。
 * 
 * @param mutexIdentifier 互斥锁标识符
 * @param mutexType 互斥锁类型
 * @param syncParameter1 同步参数1
 * @param syncParameter2 同步参数2
 * @return int 初始化成功返回0，失败返回-1
 */
int InitializeSystemMutex(void* MutexIdentifier,void* MutexType,void* SyncParameter1,void* SyncParameter2)

{
  long long initializationResult;
  
  _Mtx_init_in_situ(SYSTEM_MUTEX_PRIMARY_ADDRESS,2,SyncParameter1,SyncParameter2,InvalidHandleValue);
  initializationResult = InitializeSystemSyncMechanism(SystemSyncCallbackFunction);
  return (initializationResult != 0) - 1;
}




// 函数: void InitializeSystemSubcomponentN(void)
// 功能: 初始化系统子组件N - 负责系统更新管理组件的初始化
// 该函数初始化系统更新管理相关的数据结构和更新机制
void InitializeSystemSubcomponentN(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateS,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateS,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46c54bc98fc3fc2a;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x727b256e3af32585;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNodeManagerPrimary(void)
/**
 * @brief 初始化系统节点管理器（主节点）
 * 
 * 该函数负责初始化系统的节点管理器主节点，设置节点树结构，
 * 进行内存比较和节点插入操作，确保系统节点管理器的正常运行。
 */
void InitializeSystemNodeManagerPrimary(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateT,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateT,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x41ffd0b76c1e136f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x25db30365f277abb;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 2;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSearchManager(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理器，设置搜索相关的数据结构和
 * 搜索函数指针，为系统提供搜索功能支持。
 */
void InitializeSystemSearchManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *systemSearchCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateD,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x406be72011d07d37;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x71876af946c867ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeTertiaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统节点管理器
 * 
 * 该函数负责初始化系统的节点管理组件，设置节点管理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点管理系统的正常运行
 */
void InitializeSystemNodeManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateG,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40afa5469b6ac06d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x2f4bab01d34055a5;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuaternaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSyncMechanism(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理组件，设置搜索节点的基础结构。
 * 它会遍历系统搜索节点树，进行内存比较，分配必要的内存，并设置搜索节点属性。
 * 该函数还负责配置系统搜索的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索管理系统的正常运行
 */
void InitializeSystemSearchManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateH,System_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateH,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_DATA_COMPARISON_TEMPLATE_H_ID2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeQuinaryRoot;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理组件，设置事件处理节点的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 该函数还负责配置系统事件的回调函数和事件管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *eventSearchFunctionPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  eventSearchFunctionPointer = GetSystemSearchFunctionD;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x431d7c8d7c475be2;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xb97f048d2153e1b0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventNodeF;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 4;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源节点的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和资源管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4b2d79e470ee4e2c;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x9c552acd3ed5548d;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeG;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统设备管理器
 * 
 * 该函数负责初始化系统的设备管理组件，设置设备节点的基础结构。
 * 它会遍历系统设备节点树，进行内存比较，分配必要的内存，并设置设备节点属性。
 * 该函数还负责配置系统设备的回调函数和设备管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保设备管理系统的正常运行
 */
void InitializeSystemDeviceManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  code *deviceInitializationCallback;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  deviceInitializationCallback = SystemInitializationCallbackB;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDeviceComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDeviceComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x49086ba08ab981a7;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xa9191d34ad910696;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDeviceNodeH;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = deviceEventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理组件，设置内存节点的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 该函数还负责配置系统内存的初始化回调函数和内存管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManager(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemMemoryComparisonTemplate,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x402feffe4481676e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xd4c2151109de93a0;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemMemoryNodeI;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = memoryInitializationCallback;
  return;
}




// 函数: 系统数据节点初始化器M
/**
 * @brief 系统数据节点初始化器M
 * 
 * 该函数负责初始化系统数据节点M，在系统数据表中创建和配置
 * 特定的数据节点结构，用于存储系统运行时数据
 */
void SystemDataNodeInitializerM(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void** SystemStackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemStackPointer = &SystemDataNodeJ;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateM,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4384dcc4b6d3f417;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x92a15d52fe2679bd;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeK;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = SystemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源初始化节点
 * 
 * 该函数负责初始化系统资源初始化节点，在系统节点树中查找合适的位置
 * 插入资源初始化节点，并设置节点的标识符和回调函数。
 * 这是系统资源管理的重要组成部分。
 */
void InitializeSystemResourceInitializationNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateN,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4140994454d56503;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x399eced9bb5517ad;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemDataNodeL;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化游戏核心系统节点
 * 
 * 该函数负责初始化游戏核心系统节点，在系统节点树中查找合适的位置
 * 插入游戏核心系统节点，并设置节点的标识符和事件回调函数。
 * 这是游戏核心系统管理的重要组成部分。
 */
void InitializeGameCoreSystemNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemInitializationFunction = SystemInitializationFunction;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&GAME_CORE_SYSTEM_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4fc124d23d41985f;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xe2f4a30d6e6ae482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &GAME_CORE_NODE_DATA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化基础分配器节点
 * 
 * 该函数负责初始化基础分配器节点，在系统节点树中查找合适的位置
 * 插入基础分配器节点，并设置节点的标识符和回调函数。
 * 这是系统内存管理的重要组成部分。
 */
void InitializeBaseAllocatorNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&BASE_ALLOCATOR_ID,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4770584fbb1df897;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x47f249e43f66f2ab;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateA;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表节点
 * 
 * 该函数负责初始化系统数据表节点，在系统节点树中查找合适的位置
 * 插入数据表节点，并设置节点的标识符和回调函数。
 * 这是系统数据管理的重要组成部分。
 */
void InitializeSystemDataTableNode(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateP,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateP,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4666df49b97e0f10;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x4e4b0d63a6ad1d8f;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateB;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 资源初始化回调设置器
/**
 * @brief 资源初始化回调设置器
 * 
 * 该函数负责设置资源初始化的回调函数，配置系统资源管理
 * 的初始化流程，确保资源能够正确加载和初始化
 */
void ResourceInitializationCallbackSetter(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateQ,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateQ,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x46ecbd4daf41613e;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xdc42c056bbde8482;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateC;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统分配器节点初始化器
/**
 * @brief 系统分配器节点初始化器
 * 
 * 该函数负责初始化系统分配器节点，配置内存分配器的
 * 基础数据结构，为系统内存管理提供支持
 */
void SystemAllocatorNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemAllocatorIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemAllocatorIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c868a42644030f6;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xc29193aa9d9b35b9;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemAllocatorNodeId;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统配置节点初始化器
/**
 * @brief 系统配置节点初始化器
 * 
 * 该函数负责初始化系统配置节点，创建和配置系统的
 * 配置数据结构，用于存储系统运行时的配置信息
 */
void SystemConfigurationNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemConfigurationIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemConfigurationIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x40ea3a798283cbbb;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x7f74eb2c5a7fadae;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemConfigurationData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统事件节点初始化器
/**
 * @brief 系统事件节点初始化器
 * 
 * 该函数负责初始化系统事件节点，创建和配置系统的
 * 事件处理数据结构，用于管理系统事件的分发和处理
 */
void SystemEventNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemEventIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemEventIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_EVENT_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemEventData;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 3;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统内存管理节点初始化器
/**
 * @brief 系统内存管理节点初始化器
 * 
 * 该函数负责初始化系统内存管理节点，创建和配置系统的
 * 内存管理数据结构，用于优化内存分配和回收
 */
void SystemMemoryManagementNodeInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemResourceIdentifier,SYSTEM_IDENTIFIER_SIZE);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemResourceIdentifier,hashTableNode + 4,System_IDENTIFIER_SIZE), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER1;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = SYSTEM_RESOURCE_NODE_IDENTIFIER2;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemRootNodePointer;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统线程管理器初始化器
/**
 * @brief 系统线程管理器初始化器
 * 
 * 该函数负责初始化系统线程管理器，创建和配置系统的
 * 线程管理数据结构，用于管理多线程环境下的任务调度
 */
void SystemThreadManagerInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  void* SystemCallbackPointer;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  systemCallbackPointer = SystemCallbackManager;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateR,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x421c3cedd07d816d;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0xbec25de793b7afa6;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateD;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 0;
  hashTableNode[10] = eventCallbackPointer;
  return;
}




// 函数: 系统资源跟踪器初始化器
/**
 * @brief 系统资源跟踪器初始化器
 * 
 * 该函数负责初始化系统资源跟踪器，创建和配置系统的
 * 资源跟踪数据结构，用于监控和管理系统资源的使用情况
 */
void SystemResourceTrackerInitializer(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void** hashTableNode;
  uint64_t SystemInitializationFlag;
  
  SystemDataTable = (long long*)GetSystemRootPointer();
  SystemRootNode = (void**)*SystemDataTable;
  SystemNodeFlag = *(char*)((long long)SystemRootNode[1] + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  SystemInitializationFlag = 0;
  hashTableNode = SystemRootNode;
  SystemCurrentNode = (void**)SystemRootNode[1];
  while (SystemNodeFlag == '\0') {
    NodeIdentifierComparisonResult = memcmp(SystemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (NodeIdentifierComparisonResult < 0) {
      SystemNextNode = (void**)SystemCurrentNode[2];
      SystemCurrentNode = hashTableNode;
    }
    else {
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    hashTableNode = SystemCurrentNode;
    SystemCurrentNode = SystemNextNode;
    SystemNodeFlag = *(char*)((long long)SystemNextNode + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  }
  if ((hashTableNode == SystemRootNode) || (NodeIdentifierComparisonResult = memcmp(&SystemDataComparisonTemplateB,hashTableNode + 4,0x10), NodeIdentifierComparisonResult < 0)) {
    MemoryAllocationSize = GetSystemMemorySize(SystemDataTable);
    AllocateSystemMemory(SystemDataTable,&SystemAllocatedNode,hashTableNode,MemoryAllocationSize + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,MemoryAllocationSize);
    hashTableNode = SystemAllocatedNode;
  }
  hashTableNode[SYSTEM_NODE_IDENTIFIER1_INDEX] = 0x4c22bb0c326587ce;
  hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0x5e3cf00ce2978287;
  hashTableNode[SYSTEM_NODE_DATA_POINTER_INDEX] = &SystemResourceNodeTemplateE;
  hashTableNode[SYSTEM_NODE_FLAG_INDEX] = 1;
  hashTableNode[10] = resourceInitializationCallback;
  return;
}





// 函数: 系统性能监控器初始化器
/**
 * @brief 系统性能监控器初始化器
 * 
 * 该函数负责初始化系统性能监控器，创建和配置系统的
 * 性能监控数据结构，用于收集和分析系统性能数据
 */
void SystemPerformanceMonitorInitializer(void)

{
  void* SystemRegisterValue;
  void** SystemDataPointer;
  uint8_t* SystemBufferPointer;
  uint32_t SystemConfigurationValue;
  uint8_t SystemProcessingBuffer[136];
  
  SystemDataPointer = &SystemGlobalDataPointerC;
  SystemBufferPointer = SystemProcessingBuffer;
  SystemProcessingBuffer[0] = 0;
  SystemConfigurationValue = 0x1b;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantErrorMessageB,SystemRegisterValue,InvalidHandleValue);
  SystemMemoryRegionCacheA = SystemMemoryAllocationFunction(&SystemParameterPointerA);
  return;
}





// 函数: 系统安全管理器初始化器
/**
 * @brief 系统安全管理器初始化器
 * 
 * 该函数负责初始化系统安全管理器，获取当前进程信息，
 * 为系统安全功能提供基础的进程上下文
 */
void SystemSecurityManagerInitializer(void)

{
  SystemCurrentProcessHandle = GetCurrentProcess();
  return;
}



/**
 * @brief 初始化系统性能计数器
 * 
 * 该函数负责初始化系统的性能计数器组件，设置性能监控的基础结构。
 * 它会调用性能计数器初始化函数，并返回初始化状态。
 * 
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemPerformanceCounters(void)

{
  long long InitializationStatus;
  
  InitializePerformanceCounterHardware();
  InitializationStatus = ValidatePerformanceCounterInitialization(&SystemPerformanceCounterConfig);
  return (InitializationStatus != 0) - 1;
}



/**
 * @brief 初始化系统互斥锁
 * 
 * 该函数负责初始化系统的互斥锁组件，设置线程同步的基础结构。
 * 它会初始化互斥锁，并返回初始化状态。
 * 
 * @param mutexParameter1 互斥锁参数1
 * @param mutexParameter2 互斥锁参数2
 * @param mutexParameter3 互斥锁参数3
 * @param mutexParameter4 互斥锁参数4
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemMutex(void* MutexParameter1,void* MutexParameter2,void* MutexParameter3,void* MutexParameter4)

{
  long long InitializationStatus;
  
  _Mtx_init_in_situ(SYSTEM_MUTEX_SECONDARY_ADDRESS,2,MutexParameter3,MutexParameter4,InvalidHandleValue);
  InitializationStatus = ValidateSystemConfiguration(SystemConfigValidatorSenary);
  return (InitializationStatus != 0) - 1;
}



/**
 * @brief 初始化系统信号量
 * 
 * 该函数负责初始化系统的信号量组件，设置线程同步的基础结构。
 * 它会初始化信号量，并返回初始化状态。
 * 
 * @param semaphoreParameter1 信号量参数1
 * @param semaphoreParameter2 信号量参数2
 * @param semaphoreParameter3 信号量参数3
 * @param semaphoreParameter4 信号量参数4
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemSemaphore(void* SemaphoreParameter1,void* SemaphoreParameter2,void* SemaphoreParameter3,void* SemaphoreParameter4)

{
  long long InitializationStatus;
  
  _Mtx_init_in_situ(SYSTEM_MUTEX_TERTIARY_ADDRESS,2,SemaphoreParameter3,SemaphoreParameter4,InvalidHandleValue);
  InitializationStatus = ValidateSystemConfiguration(SystemConfigValidatorSeptenary);
  return (InitializationStatus != 0) - 1;
}




/**
 * @brief 初始化系统线程池
 * 
 * 该函数负责初始化系统的线程池组件，设置线程池的基础结构。
 * 它会初始化线程池的全局变量，并返回初始化状态。
 * 
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemThreadPool(void)

{
  long long InitializationStatus;
  
  SystemPerformanceStatusFlag = 3;
  SystemGlobalDataReferenceD = &SystemGlobalDataBufferD;
  SystemPerformanceCounterA = &SystemPerformanceDataBufferA;  // 系统性能计数器数据缓冲区A
  SystemPerformanceCounterB = 0;
  SystemPerformanceCounterC = 0;
  SystemPerformanceCounterD = 0;
  InitializationStatus = ValidateSystemConfiguration(SystemConfigValidatorOctonary);
  return (InitializationStatus != 0) - 1;
}





// 函数: 系统网络管理器初始化器
/**
 * @brief 系统网络管理器初始化器
 * 
 * 该函数负责初始化系统网络管理器，设置网络相关的
 * 基础数据结构和配置，为网络通信功能提供支持
 */
void SystemNetworkManagerInitializer(void)

{
  void* registerR9Value;
  void* *stackPointerParameter;
  uint8_t *StackBufferPointer;
  uint32_t StackBufferSize;
  uint8_t SystemProcessingBuffer[136];
  
  stackPointerParameter = &SystemGlobalDataPointerC;
  StackBufferPointer = StackBuffer;
  SystemProcessingBuffer[0] = 0;
  StackBufferSize = 0x10;
  strcpy_s(SystemProcessingBuffer,StringBufferSize,&SystemStringConstantConfigPathC,registerR9Value,InvalidHandleValue);
  SystemMemoryRegionCacheC = SystemMemoryAllocationFunction(&stackPointerParameter);
  return;
}




/**
 * 初始化线程本地存储的回调函数表
 * 设置线程本地存储中的函数指针和回调表
 * 
 * @return 成功返回0，失败返回-1
 */
uint64_t InitializeThreadLocalStorageCallbackTable(void)

{
  uint64_t threadLocalStoragePtr;
  int *callbackTable;
  
  threadLocalStoragePtr = *(uint64_t *)((uint64_t)ThreadLocalStoragePointer + (uint64_t)__tls_index * 8);
  *(uint64_t *)(threadLocalStoragePtr + 0x18) = &SystemMemoryAllocatorReference;
  *(uint64_t *)(threadLocalStoragePtr + 0x20) = 0;
  *(uint32_t *)(threadLocalStoragePtr + 0x28) = 0;
  *(uint64_t *)(threadLocalStoragePtr + 0x18) = &SystemGlobalDataReference;
  *(uint64_t *)(threadLocalStoragePtr + 0x30) = 0;
  *(uint64_t *)(threadLocalStoragePtr + 0x20) = 0;
  *(uint32_t *)(threadLocalStoragePtr + 0x28) = 0;
  threadLocalStoragePtr = *(uint64_t *)((uint64_t)ThreadLocalStoragePointer + (uint64_t)__tls_index * 8);
  callbackTable = *(int **)(threadLocalStoragePtr + 0x50);
  if (callbackTable == (int *)0x0) {
    callbackTable = (int *)(threadLocalStoragePtr + 0x60);
  }
  else {
    if (*callbackTable != 0x1e) goto CallbackTableInitializationComplete;
    callbackTable = (int *)malloc(0x100);
    free(0);
    if (callbackTable == (int *)0x0) {
      return 0xffffffff;
    }
    *(uint64_t *)(callbackTable + 2) = *(uint64_t *)(threadLocalStoragePtr + 0x50);
  }
  *callbackTable = 0;
  *(int **)(threadLocalStoragePtr + 0x50) = callbackTable;
CallbackTableInitializationComplete:
  *(code **)(callbackTable + (uint64_t)*callbackTable * 2 + 4) = SystemTableCallbackFunction;
  *callbackTable = *callbackTable + 1;
  return 0;
}





/**
 * 初始化引擎模块A
 * 设置引擎初始化参数和配置
 */
void InitializeEngineModuleA(void)

{
  uint64_t registerR9;
  void *ParameterStackPointer;
  uint8_t *bufferPtr;
  uint32_t bufferSize;
  uint8_t stringBuffer [136];
  
  paramStackPtr = &SystemDataBufferMainTemplateA;
  bufferPtr = stringBuffer;
  stringBuffer[0] = 0;
  bufferSize = 0x17;
  strcpy_s(stringBuffer,0x80,&SystemStringConstantBufferTemplateD,registerR9,InvalidHandleValue);
  SystemMemoryRegionCacheD = SystemMemoryAllocationFunction(&paramStackPtr);
  return;
}





/**
 * 初始化引擎模块B
 * 设置引擎初始化参数和配置
 */
void InitializeEngineModuleB(void)

{
  uint64_t registerR9;
  void *ParameterStackPointer;
  uint8_t *bufferPtr;
  uint32_t bufferSize;
  uint8_t stringBuffer [136];
  
  paramStackPtr = &SystemDataBufferMainTemplateA;
  bufferPtr = stringBuffer;
  stringBuffer[0] = 0;
  bufferSize = 0x11;
  strcpy_s(stringBuffer,0x80,&SystemStringConstantBufferSizeE,registerR9,InvalidHandleValue);
  SystemMemoryRegionCacheE = SystemMemoryAllocationFunction(&paramStackPtr);
  return;
}




/**
 * 初始化引擎核心系统
 * 设置引擎核心系统的全局变量和初始状态
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeEngineCoreSystem(void)

{
  uint64_t InitializationResult;
  
  SystemPerformanceTimestamp = 3;
  SystemPerformanceCounterE = &SystemPerformanceDataBufferE;  // 系统性能计数器数据缓冲区E
  SystemNetworkBufferPointer = &SystemNetworkDataBuffer;  // 系统网络数据缓冲区
  SystemInitializationStatusFlagA = 0;  // 系统初始化状态标志A
  SystemInitializationStatusFlagB = 0;  // 系统初始化状态标志B
  SystemInitializationStatusFlagC = 0;  // 系统初始化状态标志C
  InitializationResult = ValidateSystemConfiguration(SystemConfigValidatorNonary);
  return (InitializationResult != 0) - 1;
}




/**
 * 初始化系统配置和权限设置
 * 设置系统标志位、初始化权限配置，并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeSystemConfiguration(void)

{
  long long SystemCallbackResult;
  int ConfigurationIndex;
  
  SystemConfigurationSize = 0x100;
  ConfigurationIndex = 0;
  do {
    ConfigureSystemParameters(ConfigurationIndex,0x4000000000000000,0xffff7fff,0);
    ConfigurationIndex = ConfigurationIndex + 1;
  } while (ConfigurationIndex < 0xd);
  *(uint *)(SystemDeviceContextPointer + 0x330) = *(uint *)(SystemDeviceContextPointer + 0x330) | 4;
  SystemDeviceStatusFlag = 0xffffffff;
  SystemCallbackResult = SystemEventCallback(&SystemEventParameterA);
  return (SystemCallbackResult != 0) - 1;
}



/**
 * 初始化引擎模块B
 * 调用引擎初始化函数并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeEngineModuleB(void)

{
  long long CallbackResult;
  
  SystemMemoryManagerInitialize(SYSTEM_MEMORY_MANAGER_ADDRESS);
  CallbackResult = SystemEventCallback(&SystemEventParameterB);
  return (CallbackResult != 0) - 1;
}





/**
 * 设置系统指针A
 * 根据系统配置设置适当的系统指针地址
 * 检查系统状态并选择合适的指针地址
 */
void SetSystemPointerA(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(0);
  SystemDisplayContextA = 0x180be14a8;
  if (SystemOperationStatus != 0) {
    SystemDisplayContextA = 0x180be14c0;
  }
  return;
}





/**
 * 设置系统指针B
 * 根据系统配置设置复杂的系统指针地址
 * 首先检查高级配置，然后回退到基础配置
 */
void SetSystemPointerB(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(1);
  if (SystemOperationStatus != 0) {
    SystemDisplayContextB = 0x180be15c0;
    return;
  }
  SystemOperationStatus = GetSystemStatus(0);
  SystemDisplayContextB = 0x180be14e0;
  if (SystemOperationStatus != 0) {
    SystemDisplayContextB = 0x180be1550;
  }
  return;
}





/**
 * 设置渲染系统指针
 * 根据系统配置设置渲染相关的系统指针地址
 */
void SetRenderSystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(0);
  SystemAudioContextA = 0x180be1c00;
  if (SystemOperationStatus != 0) {
    SystemAudioContextA = 0x180be1c08;
  }
  return;
}





/**
 * 设置音频系统指针
 * 根据系统配置设置音频相关的系统指针地址
 */
void SetAudioSystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(0);
  SystemAudioContextB = 0x180be23a0;
  if (SystemOperationStatus != 0) {
    SystemAudioContextB = 0x180be23c0;
  }
  return;
}





/**
 * 设置输入系统指针
 * 根据系统配置设置输入相关的系统指针地址
 */
void SetInputSystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(0);
  SystemInputContextA = 0x180be2ad8;
  if (SystemOperationStatus != 0) {
    SystemInputContextA = 0x180be2af8;
  }
  return;
}





/**
 * 设置物理系统指针
 * 根据系统配置设置物理相关的系统指针地址
 */
void SetPhysicsSystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(0);
  PhysicsSystemPointer = 0x180be4710;
  if (SystemOperationStatus != 0) {
    PhysicsSystemPointer = 0x180be4728;
  }
  return;
}





/**
 * 设置网络系统指针
 * 根据系统配置设置网络相关的系统指针地址
 * 首先检查高级配置，然后回退到基础配置
 */
void SetNetworkSystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(1);
  if (SystemOperationStatus != 0) {
    NetworkSystemPointer = 0x180be6078;
    return;
  }
  SystemOperationStatus = GetSystemStatus(0);
  NetworkSystemPointer = 0x180be6068;
  if (SystemOperationStatus != 0) {
    NetworkSystemPointer = 0x180be6070;
  }
  return;
}



/**
 * 初始化虚拟函数表数组
 * 初始化一个包含16个元素的虚拟函数表数组，并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeVirtualFunctionTableArray(void)

{
  void* *vtablePointer;
  long long VirtualFunctionCounter;
  
  vtablePointer = (void* *)0x180c35590;
  VirtualFunctionCounter = 0x10;
  do {
    SystemVirtualTableInitialize(vtablePointer);
    *vtablePointer = &SystemVirtualTableTemplateA;
    vtablePointer = vtablePointer + 0x2b;
    VirtualFunctionCounter = VirtualFunctionCounter + -1;
  } while (VirtualFunctionCounter != 0);
  VirtualFunctionCounter = ProcessSystemEvent(&SystemEventDataA);
  return (VirtualFunctionCounter != 0) - 1;
}





/**
 * 设置游戏逻辑系统指针
 * 根据系统配置设置游戏逻辑相关的系统指针地址
 */
void SetGameLogicSystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(0);
  GameLogicSystemPointer = 0x180bebac8;
  if (SystemOperationStatus != 0) {
    GameLogicSystemPointer = 0x180bebad8;
  }
  return;
}





/**
 * 设置UI系统指针
 * 根据系统配置设置UI相关的系统指针地址
 * 按优先级检查不同的系统配置级别
 */
void SetUISystemPointer(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = GetSystemStatus(3);
  if (SystemOperationStatus != 0) {
    UISystemPointer = 0x180bebc10;
    return;
  }
  SystemOperationStatus = GetSystemStatus(2);
  if (SystemOperationStatus != 0) {
    UISystemPointer = 0x180bebbb0;
    return;
  }
  SystemOperationStatus = GetSystemStatus(0);
  UISystemPointer = 0x180bebaf0;
  if (SystemOperationStatus != 0) {
    UISystemPointer = 0x180bebb50;
  }
  return;
}



/**
 * 初始化调试系统
 * 初始化调试相关的系统组件并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeDebugSystem(void)

{
  long long CallbackResult;
  
  InitializeSystemDatabase(0x180c4f510);
  CallbackResult = ProcessSystemEvent(&SystemEventDataB);
  return (CallbackResult != 0) - 1;
}



/**
 * 初始化线程安全互斥锁
 * 初始化线程安全的互斥锁机制并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeThreadSafetyMutex(void)

{
  long long CallbackResult;
  
  _Mtx_init_in_situ(0x180c82170,2);
  CallbackResult = ProcessSystemEvent(&SystemEventDataC);
  return (CallbackResult != 0) - 1;
}



/**
 * @brief Wots主SDL入口点函数
 * 
 * 这是Wots系统的主SDL入口点函数，负责初始化和启动系统。
 * 
 * @param SystemParameter 系统参数指针
 * @return 无返回值
 * @note 这是系统的主入口函数，处理SDL相关的初始化工作
 */
void WotsMainSDLL(void* SystemParameter)

{
  void* stackVariables [2];
  
  // SDL主入口点初始化

/**
 * 初始化主系统控制器
 * 初始化游戏主系统控制器，处理系统状态和事件管理
 * 
 * @param systemParameter 系统参数
 */
/**
 * @brief 初始化主系统控制器
 * 
 * 此函数负责初始化游戏主系统控制器，处理系统状态和事件管理。
 * 函数会创建系统控制器对象，初始化数据表管理器，并设置系统事件分发器。
 * 
 * @param systemParameter 系统参数，用于配置系统控制器的初始化
 * @note 函数会调用InitializeSystemMemoryPool和InitializeCoreEngine进行基础初始化
 * @note 函数会管理系统全局控制器的生命周期和状态切换
 */
void InitializeMainSystemController(long long systemParameter)
{
  long long SystemObject;
  long long *ControllerPointer;
  bool IsActiveFlag;
  long long *SystemMemoryBlock;
  long long **SystemVirtualTablePointer;
  long long *SystemGlobalDataPointer;
  long long* InitializationCounter;
  long long *SystemControllerPointer;
  void* MemoryAllocationFlags;
  
  MemoryAllocationFlags = (void*)0xfffffffffffffffe;
  InitializeSystemMemoryPool();
  InitializationCounter = InitializationCounter + 1;
  InitializeCoreEngine();
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    if ((void* )SystemGlobalControllerPointer == &SystemCoreObjectTemplate) {
      IsActiveFlag = (bool)SystemGlobalControllerPointer[2] != false;
    }
    else {
      IsActiveFlag = (**(code **)((void* )SystemGlobalControllerPointer + 0x68))();
    }
    if (!IsActiveFlag) goto SkipControllerInitialization;
  }
  ControllerPointer = (long long )SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,3,SystemAllocationFlags);
  SystemControllerPointer = ControllerPointer;
  InitializeSystemDataTableManager(ControllerPointer);
  ControllerPointer = (long long)&SystemVirtualTableTemplateB;
  ControllerPointer[3] = -4;
  SystemVirtualTablePointer = (long long )ControllerPointer;
  (**(code **)(ControllerPointer + 0x28))(ControllerPointer);
  SystemVirtualTablePointer = (long long )SystemGlobalControllerPointer;
  if (SystemGlobalControllerPointer != (long long )0x0) {
    SystemObject = SystemGlobalControllerPointer;
    SystemGlobalControllerPointer = ControllerPointer;
    (**(code **)(SystemObject + 0x38))();
    ControllerPointer = SystemGlobalControllerPointer;
  }
  SystemGlobalControllerPointer = ControllerPointer;
  if ((void* )SystemGlobalControllerPointer == &SystemVirtualTableTemplateB) {
    if (SystemInitializationFlag != 0) {
      InitializeSystemEventDispatcher();
    }
  }
  else {
    (**(code **)((void* )SystemGlobalControllerPointer + 0x60))();
  }
  ControllerPointer = SystemGlobalControllerPointer;
  SystemGlobalDataPointer = SystemGlobalControllerPointer;
  SystemGlobalControllerPointer = (long long )0x0;
  if (ControllerPointer != (long long )0x0) {
    (**(code **)(ControllerPointer + 0x38))();
  }
SkipControllerInitialization:
  SystemThreadSyncBroadcast((void* )(SystemResourceManager + 0x20));
  if ((char )(SystemGlobalStatusFlags + 0x1ed) != '\0') {
    ControllerPointer = (long long )SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,3);
    ControllerPointer = (long long)&SystemMemoryTemplateA;
    ControllerPointer = (long long)&SystemMemoryTemplateB;
    (uint32_t )(ControllerPointer + 1) = 0;
    ControllerPointer = (long long)&SystemMemoryTemplateC;
    LOCK();
    (uint8_t )(ControllerPointer + 2) = 0;
    UNLOCK();
    ControllerPointer[3] = -1;
    ControllerPointer = (long long)&SystemMemoryTemplateD;
    ControllerPointer[4] = 0x180c91060;
    SystemControllerPointer = ControllerPointer;
    (**(code **)(ControllerPointer + 0x28))(ControllerPointer);
    SystemAllocationFlags = SystemAllocationFlagsTemplate;
    SystemVirtualTablePointer = &SystemMemoryBlock;
    SystemMemoryBlock = ControllerPointer;
    (**(code **)(ControllerPointer + 0x28))(ControllerPointer);
    SystemManagerInitialize(SystemAllocationFlags,&SystemMemoryBlock);
    (**(code **)(ControllerPointer + 0x38))(ControllerPointer);
  }
  return;
}



/**
 * 内存管理器清理函数
 * 清理内存管理器相关的指针和资源
 * 
 * @param SystemResourceManager 内存管理器指针
 * @param cleanupFlags 清理标志
 * @param reservedParam3 保留参数
 * @param reservedParam4 保留参数
 * @return 返回内存管理器指针
 */
void* *
CleanupSystemMemoryManager(void* *memoryManager,ulong long cleanupFlags,void* reservedParam3,void* reservedParam4)

{
  *memoryManager = &SystemMemoryTemplateD;
  *memoryManager = &SystemMemoryTemplateC;
  *memoryManager = &SystemMemoryTemplateB;
  *memoryManager = &SystemMemoryTemplateA;
  if ((cleanupFlags & 1) != 0) {
    free(memoryManager,0x28,reservedParam3,reservedParam4,InvalidHandleValue);
  }
  return memoryManager;
}




/**
 * @brief 系统终止函数
 * 
 * 该函数负责终止系统的运行，执行必要的清理工作。
 * 它会调用系统数据操作函数来完成系统终止过程。
 * 
 * @note 这是系统关闭时调用的最后一个主要函数
 */
void TerminateSystem(void)

{
    SystemDataOperation();
}




/**
 * 设置默认系统指针
 * 设置系统默认的指针地址
 * 
 * @param SystemResourceManager 系统指针
 */
void SetDefaultSystemPointer(void* *systemPointer)

{
  *systemPointer = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 初始化系统信息和用户环境
 * 
 * 该函数负责初始化系统信息和用户环境，包括获取计算机名、用户名，
 * 设置系统环境变量和配置参数。这是系统初始化的重要组成部分。
 * 
 * @note 该函数会在系统启动时调用，用于建立基本的系统环境
 */
void InitializeSystemInfoAndUserEnvironment(void)

{
  void* *systemInfoPtr;
  code *systemCallback;
  long long systemHandle;
  int operationResult;
  void* SystemAllocationFlags;
  long long *controllerPtr;
  uint8_t SystemEncryptionBuffer [32];
  void* *SystemConfigurationTemplatePointer;
  void* *SystemStringTemplatePointer;
  void* *SystemStringTemplatePointerSecondary;
  long long *SystemMemoryOffsetPointer;
  uint32_t GameControllerStatusFlag;
  void* *SystemGlobalDataReferencePointer;
  void* *SystemFunctionPointer;
  uint32_t SystemInitializationFlag;
  ulong long SystemFlags;
  void* *SystemGlobalDataReferencePointerSecondary;
  void* *SystemFunctionPointerSecondary;
  uint32_t SystemDataProcessingFlag;
  ulong long SystemFlags2;
  void* *GameControllerPointer;
  long long SystemMemorySize;
  uint32_t SystemOperationFlags;
  void* SystemMemoryHandle;
  long long *SystemMemoryPointer;
  void* *SystemMemoryTemplatePointer;
  void* *SystemDataBufferPointer;
  uint32_t SystemDataFlags;
  void* SystemDataArray [32];
  long long **ApplicationPointerArray [3];
  uint8_t SystemDataProcessingBuffer [272];
  uint8_t SystemTemporaryBuffer [32];
  ulong long SystemEncryptionKey;
  
  SystemStackFlag = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)SystemEncryptionBuffer;
  GameControllerStatusFlag = 0;
  if (*(char *)(SystemContextManagerPointer + 0x18) == '\0') {
    InitializeGameController(&SystemGameControllerBuffer);
    (**(code **)(**(long long **)(SystemGlobalStatusFlags + 0x2b0) + 0x98))
              (*(long long **)(SystemGlobalStatusFlags + 0x2b0),&SystemGameControllerBuffer);
    StartInputSystem();
    SystemContextHandle = SystemContextManagerPointer;
    MemoryAllocationSize = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
    AllocatedMemoryPointer = (long long *)AllocateSystemMemory(MemoryAllocationSize,8,SystemContextHandle);
    MemoryBlockPointer = AllocatedMemoryPointer;
    if (AllocatedMemoryPointer != (long long *)0x0) {
      (**(code **)(*AllocatedMemoryPointer + 0x28))(AllocatedMemoryPointer);
    }
    *(uint32_t *)(AllocatedMemoryPointer + 0xd) = 0xbb80073;
    SystemInterfacePointer = *(void* **)(SystemContextHandle + 400);
    InterfaceFunctionPointer = *(code **)*SystemInterfacePointer;
    ComputerNameBufferPointer = &MemoryBufferSize;
    MemoryBufferSize = AllocatedMemoryPointer;
    (**(code **)(*AllocatedMemoryPointer + 0x28))(AllocatedMemoryPointer);
    (*InterfaceFunctionPointer)(SystemInterfacePointer,&MemoryBufferSize);
    (**(code **)(*AllocatedMemoryPointer + 0x38))(AllocatedMemoryPointer);
    ConfigureInputSystem();
    SystemGlobalDataReferencePtr = &SystemGlobalDataReference;
    GlobalDataFlags = 0;
    AlternateStringBuffer = (void* *)0x0;
    SystemDataProcessingFlag = 0;
    SystemGlobalDataReferencePtr2 = &SystemGlobalDataReference;
    GlobalDataFlags2 = 0;
    AlternateStringBuffer2 = (void* *)0x0;
    SystemInitializationFlag = 0;
    SystemMemoryOffset = (long long *)ConcatenatedValue44(SystemMemoryOffset.HighPart,0x10);
    OperationResult = GetComputerNameA(ComputerNameBufferPointer,&MemoryBufferSize);
    if (OperationResult == 0) {
      LogSystemError(&SystemStringConstantComputerNameErrorF);
    }
    else {
      if (0xf < ((ulong long)MemoryBufferSize & MAX_UNSIGNED_32_BIT)) goto HandleMemoryBufferOverflow;
      *(uint8_t *)((long long)ComputerNameBufferPointer + ((ulong long)MemoryBufferSize & MAX_UNSIGNED_32_BIT)) = 0;
      (**(code **)(SystemGlobalDataReferencePtr + 0x10))(&SystemGlobalDataReferencePtr,ComputerNameBufferPointer);
    }
    UserNameBufferSize = (long long *)ConcatenatedValue44(UserNameBufferSize.HighPart,0x101);
    OperationResult = GetUserNameA(UserNameBuffer,&MemoryBufferSize);
    if (OperationResult == 0) {
      LogSystemError(&SystemStringConstantUserNameErrorG);
    }
    else {
      if (0x100 < ((ulong long)MemoryBufferSize & MAX_UNSIGNED_32_BIT)) {
        ProcessSystemEvent();
HandleMemoryBufferOverflow:
        ProcessSystemEvent();
        ExceptionHandlerFunction = (code *)swi(3);
        (*ExceptionHandlerFunction)();
        return;
      }
      UserNameBuffer[(ulong long)MemoryBufferSize & MAX_UNSIGNED_32_BIT] = 0;
      (**(code **)(SystemGlobalDataReferencePtr2 + 0x10))(&SystemGlobalDataReferencePtr2,UserNameBuffer);
    }
    SystemStringTemplatePtr = &SystemStringTemplate;
    if (AlternateStringBuffer2 != (void* *)0x0) {
      SystemStringTemplatePtr = AlternateStringBuffer2;
    }
    SystemStringTemplatePtr2 = &SystemStringTemplate;
    if (AlternateStringBuffer != (void* *)0x0) {
      SystemStringTemplatePtr2 = AlternateStringBuffer;
    }
    SystemConfigurationTemplatePtr = &SystemConfigurationTemplatePrimary;
    SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffffffffffff,4);
    SystemMemoryTemplatePtr = &SystemMemoryTemplateE;
    LocalStackBuffer = SystemTemporaryBuffer;
    CalculationFlags178 = 0;
    SystemTemporaryBuffer[0] = 0;
    GameControllerStatusFlag = 2;
    InitializeGameSettings(&SystemMemoryTemplatePtr,&SystemDataBufferTemplateI,0x130a7);
    SystemStringTemplatePtr2 = &SystemStringTemplate;
    if (LocalStackBuffer != (void* *)0x0) {
      SystemStringTemplatePtr2 = LocalStackBuffer;
    }
    SystemConfigurationTemplatePtr = &SystemConfigurationTemplateSecondary;
    SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffffffffffff,4);
    GameControllerStatusFlag = 0;
    SystemMemoryTemplatePtr = &SystemMemoryAllocatorReference;
    SystemGlobalDataReferencePtr2 = &SystemGlobalDataReference;
    if (AlternateStringBuffer2 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    AlternateStringBuffer2 = (void* *)0x0;
    GlobalDataFlags2 = GlobalDataFlags2 & MAX_UNSIGNED_32_BIT00000000;
    SystemGlobalDataReferencePtr2 = &SystemMemoryAllocatorReference;
    SystemGlobalDataReferencePtr = &SystemGlobalDataReference;
    if (AlternateStringBuffer != (void* *)0x0) {
        SystemCleanupFunction();
    }
    AlternateStringBuffer = (void* *)0x0;
    GlobalDataFlags = GlobalDataFlags & MAX_UNSIGNED_32_BIT00000000;
    SystemGlobalDataReferencePtr = &SystemMemoryAllocatorReference;
    SystemGameControllerBuffer = &SystemGlobalDataReference;
    if (StackCleanupFlag != 0) {
        SystemCleanupFunction();
    }
    StackCleanupFlag = 0;
    CalculationFlags1A0 = 0;
    SystemGameControllerBuffer = &SystemMemoryAllocatorReference;
  }
  GameControllerStatusFlag = 0;
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)SystemEncryptionBuffer);
}





/**
 * @brief 初始化系统调试符号管理器
 * 
 * 该函数负责初始化系统的调试符号处理组件，包括符号表的初始化、
 * 动态库加载、符号搜索路径设置和性能计数器配置。它还会初始化
 * 线程管理器和时间相关功能。
 * 
 * @param systemContext 系统上下文参数
 * @param InitializationFlag 初始化标志
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试功能的正常运行
 */
void InitializeSystemDebugSymbolManager(void* systemContext,long long InitializationFlag)

{
  long long **symbolTablePointer;
  int initializationResult;
  uint symbolFlags;
  uint32_t SymbolOptions;
  void* systemHandle;
  long long *libraryHandle;
  long long performanceFrequency;
  void* *symbolNextNode;
  void* *debugContextPointer;
  void* *threadContextPointer;
  uint8_t* MemoryAllocationFlag;
  char *searchPathPointer;
  void* *stackPointer;
  ulong long systemTimestamp;
  uint stackFlags;
  char ThreadState;
  long long *threadLocalData;
  long long **threadManagerPointer;
  long long performanceCounter;
  void* *StackBufferLarge1;
  void* *StackBufferLarge2;
  uint32_t SystemResourceHandle;
  void* *StackBufferMedium1;
  long long SystemMemorySize;
  uint SystemOperationFlag;
  void* *StackBufferSmall1;
  void* *StackBufferSmall2;
  uint32_t SystemConfigurationFlag;
  void* StackParameter5;
  long long **mutexPointer;
  long long *threadLocalStorage;
  
  StackParameter5 = 0xfffffffffffffffe;
  systemHandle = GetSystemDebugHandle();
  InitializeSystemCore();
  libraryHandle = (long long *)AllocateSystemMemory(SystemMemoryPoolTemplate,0x68,8,3);
  symbolTablePointer = (long long **)(libraryHandle + 1);
  threadLocalData = libraryHandle;
  threadManagerPointer = symbolTablePointer;
  InitializeMutex(symbolTablePointer,2);
  libraryHandle[0xb] = 0;
  libraryHandle[0xc] = 0;
  *(void*2 *)libraryHandle = 0;
  SystemLibraryHandleStorage = libraryHandle;
  if ((char)*libraryHandle != '\0') goto SkipLibraryHandleInitialization;
  mutexPointer = symbolTablePointer;
  initializationResult = LockMutex(symbolTablePointer);
  if (initializationResult != 0) {
    __Throw_C_error_std__YAXH_Z(initializationResult);
  }
  SymSetOptions(0x2017);
  InitializeSystemLogging(&systemGlobalDataPtrB8);
  SearchPathTemplate = &SystemStringTemplate;
  if (CustomSearchPath != (void* *)0x0) {
    SearchPathTemplate = CustomSearchPath;
  }
  SymSetSearchPath(SystemCurrentProcessHandle,SearchPathTemplate);
  LibraryHandle = AllocatedMemoryPointer[0xb];
  if (LibraryHandle == 0) {
    LibraryHandle = LoadLibraryA(&SystemStringConstantLibraryNameH);
    AllocatedMemoryPointer[0xb] = LibraryHandle;
    if (LibraryHandle != 0) goto LibraryHandleLoadedSuccessfully;
    systemGlobalDataPtrB8 = &SystemGlobalDataReference;
    if (alternateBufferPtrB0 != (void* *)0x0) {
        SystemCleanupFunction();
    }
  }
  else {
LibraryHandleLoadedSuccessfully:
    if (AllocatedMemoryPointer[0xc] == 0) {
      FunctionAddress = GetProcAddress(LibraryHandle,&SystemStringConstantFunctionNameI);
      AllocatedMemoryPointer[0xc] = FunctionAddress;
      if (FunctionAddress == 0) {
        systemGlobalDataPtrB8 = &SystemGlobalDataReference;
        if (alternateBufferPtrB0 != (void* *)0x0) {
            SystemCleanupFunction();
        }
        goto SymbolInitializationCleanup;
      }
    }
    SymbolSearchPath = &SystemStringTemplate;
    if (CustomSearchPath != (void* *)0x0) {
      SymbolSearchPath = CustomSearchPath;
    }
    SymbolInitializationResult = SymInitialize(SystemCurrentProcessHandle,SymbolSearchPath,1);
    if (SymbolInitializationResult == 0) {
      systemGlobalDataPtrB8 = &SystemGlobalDataReference;
      if (alternateBufferPtrB0 != (void* *)0x0) {
          SystemCleanupFunction();
      }
    }
    else {
      *(char *)AllocatedMemoryPointer = '\x01';
      systemGlobalDataPtrB8 = &SystemGlobalDataReference;
      if (alternateBufferPtrB0 != (void* *)0x0) {
          SystemCleanupFunction();
      }
    }
  }
SymbolInitializationCleanup:
  SystemDataProcessingCounter = 0;
  SecondarySystemBuffer = (void* *)0x0;
  SystemGlobalDataPointer = &SystemMemoryAllocatorReference;
  int mutexUnlockResult = _Mtx_unlock(threadMutexPointer);
  if (mutexUnlockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexUnlockResult);
  }
SkipLibraryHandleInitialization:
  void* allocatedMemoryBlock1 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,8,8,3);
  *allocatedMemoryBlock1 = 0;
  void* allocatedMemoryBlock2 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,8,8,3);
  *allocatedMemoryBlock1 = &SystemDebugDataBufferA;
  *allocatedMemoryBlock2 = &SystemDebugDataBufferB;
  void* allocatedMemoryBlock3 = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,3);
  uint8_t* allocatedMemoryBlock4 = (uint8_t *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,1,1,3);
  *allocatedMemoryBlock4 = 0;
  allocatedMemoryBlock3[2] = allocatedMemoryBlock4;
  SystemMemoryBlockStorage = allocatedMemoryBlock3;
  *allocatedMemoryBlock3 = allocatedMemoryBlock2;
  allocatedMemoryBlock3[1] = allocatedMemoryBlock1;
  allocatedMemoryBlock3[3] = timerMemoryBlock;
  timerMemoryBlock = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x198,8,3);
  SystemTimerStoragePointer = CreateSystemTimer(timerMemoryBlock);
  counterMemoryBlock = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xa8,8,3);
  SystemCounterStoragePointer = CreateSystemCounter(counterMemoryBlock);
  SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,1,1,3);
  int performanceQueryResult = QueryPerformanceFrequency(&performanceFrequencyData);
  if (performanceQueryResult == 0) {
    InitializeSystemSemaphores(&SystemSemaphoreTemplate);
  }
  SystemPerformanceFrequencyStorage = 1.0 / (double)(long long)performanceFrequencyData;
  timeBeginPeriod(1);
  QueryPerformanceCounter(&performanceCounterData);
  if (SystemPerformanceTimerEnabled != '\0') {
    SystemPerformanceCounterStorage = SystemPerformanceCounterStorage + (performanceCounterData - SystemPerformancePreviousStorage);
  }
  SystemPerformancePreviousStorage = 0;
  SystemPerformanceCurrentStorage = performanceCounterData;

/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理器，创建线程对象并设置线程状态。
 * 线程管理器负责管理系统中的所有线程，包括创建、销毁和调度。
 * 
 * @note 此函数在系统启动时被调用
 * @warning 函数中使用了系统特定的内存池模板
 */
void InitializeSystemThreadManager(void)
{
  void* CurrentThreadHandle;
  uint32_t ThreadCreationResult;
  void* ThreadManagerObject;
  void* ThreadRegisterR9;
  void* ErrorHandlingPointer;
  void* ThreadManagerInstance;
  uint32_t ThreadOperationFlags;
  void* ThreadStackMemory;
  
  ErrorHandlingPointer = &SystemGlobalDataReference;
  ThreadStackMemory = 0;
  ThreadManagerInstance = (void* *)0x0;
  ThreadOperationFlags = 0;
  ThreadManagerObject = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,ThreadRegisterR9,InvalidHandleValue);
  *(uint8_t *)ThreadManagerObject = 0;
  ThreadManagerInstance = ThreadManagerObject;
  ThreadCreationResult = StartSystemThread(ThreadManagerObject);
  ThreadStackMemory = ConcatenatedValue44(ThreadStackMemory.HighPart,ThreadCreationResult);
  *ThreadManagerObject = 0x72657472617453;
  ThreadOperationFlags = 7;
  CurrentThreadHandle = GetCurrentThread();
  InitializeSystemThreadContext(CurrentThreadHandle,&ErrorHandlingPointer);
  ErrorHandlingPointer = &SystemGlobalDataReference;
    SystemCleanupFunction(ThreadManagerObject);
}




/**
 * @brief 执行系统最终初始化
 * 
 * 该函数负责执行系统的最终初始化工作，包括等待系统就绪、
 * 初始化管理器、分配内存资源、设置回调函数等。
 * 这是系统启动过程中的最后一个初始化步骤。
 * 
 * @return 初始化结果状态码，0表示成功，非0表示失败
 */
uint32_t FinalSystemInitialization(void)
{
  void* SystemInterfacePointer;
  void* SystemCallbackFunction;
  long long** SystemControllerInstance;
  uint32_t InitializationResult;
  int WaitOperationResult;
  long long**** SystemManagerInstance;
  void* MemoryAllocationFlags;
  long long**** TemporaryManager8;
  long long*** TemporaryManager9;
  long long SystemObjectHandle;
  char SystemActiveStatus;
  long long**** StackManager8;
  long long*** StackManager10;
  long long** StackController18;
  long long*** StackManager20;
  void* CalculationFlags;
  long long***** SystemSuperManager;
  long long**** TemporaryManager14;
  long long SystemValue;
  void* ResourceAddress;
  
  CalculationFlags = 0xfffffffffffffffe;
  if (SystemGlobalControllerPointer != (void* *)0x0) {
    while( true ) {
      if ((void* *)*SystemGlobalControllerPointer == &SystemVirtualTableTemplateB) {
        SystemActiveStatus = *(char *)(SystemGlobalControllerPointer + 2) != '\0';
      }
      else {
        SystemActiveStatus = (**(code **)((void* *)*SystemGlobalControllerPointer + 0x68))();
      }
      if (SystemActiveStatus != '\0') break;
      Sleep(1);
    }
  }
  SystemManagerInstance = (long long ****)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,3,CalculationFlags);
  StackManager8 = SystemManagerInstance;
  InitializeSystemDataTableManager(SystemManagerInstance);
  *SystemManagerInstance = (long long ***)&SystemManagerGlobalTable;
  StackManager20 = (long long ***)SystemManagerInstance;
  (*(code *)(*SystemManagerInstance)[5])(SystemManagerInstance);
  SystemObjectHandle = SystemAllocationFlagsTemplate;
  SystemSuperManager = &StackManager8;
  StackManager8 = SystemManagerInstance;
  (*(code *)(*SystemManagerInstance)[5])(SystemManagerInstance);
  SystemManagerInitialize(SystemObjectHandle,&StackManager8);
  while( true ) {
    if (*SystemManagerInstance == (long long ***)&SystemManagerGlobalTable) {
      SystemActiveStatus = *(char *)(SystemManagerInstance + 2) != '\0';
    }
    else {
      SystemActiveStatus = (*(code *)(*SystemManagerInstance)[0xd])(SystemManagerInstance);
    }
    if (SystemActiveStatus != '\0') break;
    Sleep(1);
  }
  InitializeSystemManager();
  SystemObjectHandle = SystemContextManagerPointer;
  MemoryAllocationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  TemporaryManager8 = (long long ****)AllocateSystemMemory(MemoryAllocationFlags,2,SystemObjectHandle);
  TemporaryManager14 = TemporaryManager8;
  if (TemporaryManager8 != (long long ****)0x0) {
    (*(code *)(*TemporaryManager8)[5])(TemporaryManager8);
  }
  SystemInterfacePointer = *(void* **)(SystemObjectHandle + 400);
  SystemCallbackFunction = *(code **)*SystemInterfacePointer;
  StackManager8 = &StackManager10;
  StackManager10 = (long long ***)TemporaryManager8;
  if (TemporaryManager8 != (long long ****)0x0) {
    (*(code *)(*TemporaryManager8)[5])(TemporaryManager8);
  }
  (*SystemCallbackFunction)(SystemInterfacePointer,&StackManager10);
  CalculationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,CalculationFlags,SystemSuperManager,TemporaryManager14);
  TemporaryManager9 = (long long ***)AllocateSystemMemory(CalculationFlags,0,SystemObjectHandle);
  if (TemporaryManager9 != (long long ***)0x0) {
    (*(code *)(*TemporaryManager9)[5])(TemporaryManager9);
  }
  SystemInterfacePointer = *(void* **)(SystemObjectHandle + 400);
  SystemCallbackFunction = *(code **)*SystemInterfacePointer;
  StackManager8 = (long long ****)&StackController18;
  StackController18 = (long long **)TemporaryManager9;
  if (TemporaryManager9 != (long long ***)0x0) {
    (*(code *)(*TemporaryManager9)[5])(TemporaryManager9);
  }
  (*SystemCallbackFunction)(SystemInterfacePointer,&StackController18);
  ProcessSystemCallback(*(void* *)(SystemObjectHandle + 400));
  if (TemporaryManager9 != (long long ***)0x0) {
    (*(code *)(*TemporaryManager9)[7])(TemporaryManager9);
  }
  if (TemporaryManager8 != (long long ****)0x0) {
    (*(code *)(*TemporaryManager8)[7])(TemporaryManager8);
  }
  TemporaryManager14 = SystemManagerPointerStorage;
  *(uint8_t *)(SystemManagerPointerStorage[1] + 0x80) = 1;
  while( true ) {
    SystemControllerInstance = *TemporaryManager14[1];
    if (SystemControllerInstance == (long long **)&SystemControllerDefaultTable) {
      SystemActiveStatus = *(char *)(TemporaryManager14[1] + 2) != '\0';
    }
    else {
      SystemActiveStatus = (*(code *)SystemControllerInstance[0xd])();
    }
    TemporaryManager8 = SystemManagerPointerStorage;
    if (SystemActiveStatus != '\0') break;
    Sleep(1);
  }
  StackManager8 = SystemManagerPointerStorage;
  if (SystemManagerPointerStorage != (long long ****)0x0) {
    SystemManagerPointer = __RTCastToVoid(SystemManagerPointerStorage);
    *SystemManagerTable = (long long ***)&SystemManagerCompletionTable;
    PostQueuedCompletionStatus(SystemManagerTable[0x42686],0,0xffffffffffffffff);
    CloseHandle(SystemManagerTable[0x42686]);
    SystemResourceManager = (long long ***)(SystemManagerTable + 0x42687);
    if ((long long ***)*SystemCleanupFlagPointer != (long long ***)0x0) {
        SystemCleanupFunction();
    }
    SystemResourceTriplePointer = (long long ***)(ppppSystemMemoryAddress + 0x4267c);
    _Mtx_destroy_in_situ();
    SystemResourceTriplePointer2 = (long long ***)(ppppSystemMemoryAddress + 0x40070);
    _Mtx_destroy_in_situ();
    ConfigureSystemBuffer(ppppSystemMemoryAddress);
    if (MemoryAllocationFlags != 0) {
        SystemCleanupFunction(MemoryAllocationFlags);
    }
  }
  pppPrimaryResourcePointer4 = SystemInitializationFlag;
  MemoryAllocationFlags = SystemAllocationFlagsTemplate;
  SystemManagerPointerStorage = (long long ****)0x0;
  if (SystemAllocationFlagsTemplate != 0) {
    InitializeSystemLogger(SystemAllocationFlagsTemplate);
      SystemCleanupFunction(MemoryAllocationFlags);
  }
  SystemAllocationFlagsTemplate = 0;
  *(uint32_t *)(SystemInitializationFlag + 0x2d) = 2;
  SystemResourceQuadruplePointer = pppPrimaryResourcePointer4;
  if (pppPrimaryResourcePointer4 == (long long ****)0x0) {
    SystemInitializationFlag = (long long ****)0x0;
    WaitForSingleObject(SystemSemaphoreHandle,0xffffffff);
    do {
      SystemValue = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (SystemValue == 0);
    SystemSecondaryStatus = __acrt_iob_func(1);
    fflush(SystemSecondaryStatus);
    SystemSecondaryStatus = __acrt_iob_func(2);
    fflush(SystemSecondaryStatus);
    ResourceAddress = SystemGlobalStateStorage;
    (*(code *)(*ppppSystemThreadFlags)[7])(ppppSystemThreadFlags);
    return resourceAddress;
  }
  ReleaseSystemResource(pppPrimaryResourcePointer4 + 0x1e);
  ReleaseSystemResource(pppPrimaryResourcePointer4 + 0xf);
  ReleaseSystemResource(pppPrimaryResourcePointer4);
    SystemCleanupFunction(pppPrimaryResourcePointer4);
}



/**
 * @brief 系统主入口函数
 * 
 * 这是整个系统的主入口函数，负责初始化和管理整个系统的运行。
 * 它接收系统资源管理器作为参数，并协调各个系统组件的初始化和运行。
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于管理系统资源
 * @note 这是系统启动时调用的第一个主要函数
 */
void WotsMain(void* SystemResourceManager)

{
  void* LocalStackBuffer [2];
  
  // 系统事件表大小常量
  #define SystemEventTableSize 0x45a00

/**
 * @brief 执行系统回调函数
 * 
 * 该函数负责执行系统的回调函数，检查参数指针是否有效，然后调用相应的回调函数。
 * 
 * @param callbackParameter 指向回调函数参数的指针
 * @note 这是系统回调机制的重要组成部分，确保回调函数的正确执行
 */
void ExecuteSystemCallback(long long *callbackParameter)

{
  if ((long long *)*callbackParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*callbackParameter + 0x38))();
  }
  return;
}




/**
 * @brief 处理系统字符串复制
 * 
 * 该函数负责处理系统字符串的复制操作，检查源字符串长度，执行字符串复制，
 * 并设置相应的长度标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 * @note 这是系统字符串处理的重要组成部分，确保字符串复制的安全性
 */
void ProcessSystemStringCopy(long long targetBuffer,long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(sourceString + stringLength) != '\0');
  if ((int)stringLength < 0x1000) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
                    000180045b59. Too many branches
                        strcpy_s(*(void* *)(SystemResourceManager + 8),0x1000);
    return;
  }
  ProcessSystemStringAllocation(&SystemMemoryTemplateG,0x1000,ConfigurationDataPointer);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 处理系统内存复制
 * 
 * 该函数负责处理系统内存的复制操作，检查复制长度是否安全，执行内存复制，
 * 并设置相应的结束标志。
 * 
 * @param SystemResourceManager 目标缓冲区指针
 * @param SourceDataPointer 源数据指针
 * @param BytesToCopy 要复制的字节数
 * @note 这是系统内存处理的重要组成部分，确保内存复制的安全性
 */
void ProcessSystemMemoryCopy(long long SystemResourceManager,void* SourceDataPointer,int BytesToCopy)

{
  if (BytesToCopy + 1 < 0x1000) {
      memcpy(*(uint8_t **)(SystemResourceManager + 8),SourceDataPointer,(long long)BytesToCopy);
  }
  **(uint8_t **)(SystemResourceManager + 8) = 0;
  *(uint32_t *)(SystemResourceManager + 0x10) = 0;
  return;
}




/**
 * @brief 系统内存拷贝操作
 * 
 * 该函数执行系统内存拷贝操作，用于在系统初始化过程中复制内存数据。
 * 
 * @note 这是一个低级别的系统操作函数
 */
void ExecuteSystemMemoryCopyOperation(void)

{
    memcpy();
}




/**
 * @brief 重置系统缓冲区
 * 
 * 该函数负责重置系统缓冲区，将缓冲区内容清零，
 * 并重置相关的偏移量计数器。
 * 
 * @param bufferPointer 指向需要重置的缓冲区的指针
 * @note 这是一个辅助函数，用于清理和重置系统缓冲区状态
 */
void ResetSystemBuffer(uint8_t *bufferPointer)

{
  long long bufferOffset;
  
  *bufferPointer = 0;
  bufferOffset = (long long)bufferPointer;
  *(uint32_t *)(bufferOffset + 0x10) = 0;
  return;
}




/**
 * @brief 系统初始化完成处理函数
 * 
 * 该函数在系统初始化完成后执行，调用系统的完成处理函数。
 * 
 * @note 这是一个系统完成处理函数，通常在初始化过程结束时调用
 */
void FinalizeSystemInitialization(void)

{
    SystemDataOperation();
}



/**
 * @brief 初始化系统指针池
 * 
 * 该函数负责初始化系统指针池，设置默认的指针地址，
 * 并根据清理标志决定是否释放相关内存资源
 * 
 * @param systemPointerPool 系统指针池指针
 * @param InitializationFlags 初始化标志，用于控制内存清理行为
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回系统指针池指针
 */
void* *
InitializeSystemPointerPool(void* *systemPointerPool,ulong long InitializationFlags,void* reservedParam3,void* reservedParam4)

{
  *systemPointerPool = &SystemMemoryAllocatorReference;
  if ((InitializationFlags & 1) != 0) {
    free(systemPointerPool,0x1018,reservedParam3,reservedParam4,InvalidHandleValue);
  }
  return systemPointerPool;
}



/**
 * @brief 清理系统完成端口资源
 * 
 * 该函数负责清理系统的完成端口资源，关闭句柄，销毁互斥体，
 * 并根据标志释放相关内存。这是系统资源清理的重要组成部分。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param cleanupFlags 清理标志，用于控制是否释放内存
 * @return 返回清理后的系统资源指针
 */
void* CleanupSystemCompletionPortResources(void* systemResourcePointer, uint32_t cleanupFlags)

{
  *systemResourcePointer = &SystemCompletionPortTemplate;
  PostQueuedCompletionStatus(systemResourcePointer[0x42686],0,0xffffffffffffffff,0,InvalidHandleValue);
  CloseHandle(systemResourcePointer[0x42686]);
  if (systemResourcePointer[0x42687] != 0) {
      TerminateSystemProcess();
  }
  _Mtx_destroy_in_situ();
  _Mtx_destroy_in_situ();
  CleanupSystemResourceData(systemResourcePointer);
  if ((cleanupFlags & 1) != 0) {
    free(systemResourcePointer,0x213458);
  }
  return systemResourcePointer;
}



/**
 * @brief 执行ICALL（内部调用）安全检查
 * 
 * 该函数用于执行内部调用的安全检查，确保调用的合法性
 * 这是.NET运行时安全机制的一部分
 */
void GuardCheckICall(void)

{
  return;
}



/**
 * @brief 系统内存分配器引用管理器
 * 
 * 该函数管理系统内存分配器的引用，根据标志位决定是否释放内存。
 * 
 * @param SystemResourceManager 指向内存分配器引用的指针
 * @param MemoryFlags 标志位，控制是否释放内存
 * @param MemoryFreeParam1 内存释放参数1
 * @param MemoryFreeParam2 内存释放参数2
 * @return 返回内存分配器引用指针
 */
void* * SystemMemoryAllocatorReferenceManager(void* *SystemResourceManager,ulong long MemoryFlags,void* MemoryFreeParam1,void* MemoryFreeParam2)

{
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  if ((MemoryFlags & 1) != 0) {
    free(SystemResourceManager,0x418,MemoryFreeParam1,MemoryFreeParam2,InvalidHandleValue);
  }
  return SystemResourceManager;
}




// 函数: void InitializeSystemResources(long long SystemResourceManager,long long ResourceFlags)
/**
 * @brief 系统字符串复制处理器
 * 
 * 该函数处理系统字符串复制操作，包括长度验证和安全复制。
 * 当源字符串长度小于0x400时，直接复制；否则调用安全处理函数。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 */
/**
 * @brief 处理系统字符串复制操作
 * 
 * 该函数负责处理系统字符串的复制操作，包括字符串长度计算和
 * 安全复制。当字符串长度超过限制时，会调用字符串分配函数。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 */
void ProcessSystemStringCopy(long long targetBuffer,long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(sourceString + stringLength) != '\0');
  if ((int)stringLength < 0x400) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
                    000180045f19. Too many branches
                        strcpy_s(*(void* *)(targetBuffer + 8),0x400);
    return;
  }
  ProcessSystemStringAllocation(&SystemStringAllocationHandler,0x400,sourceString);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




// 函数: void ProcessSystemConfiguration(long long SystemResourceManager,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统内存复制处理器
 * 
 * 该函数处理系统内存复制操作，包括边界检查和安全复制。
 * 当复制长度小于0x400时，执行内存复制操作。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 */
void ProcessSystemMemoryCopy(long long targetBuffer,void* sourceData,int copyLength)

{
  if (copyLength + 1 < 0x400) {
      memcpy(*(uint8_t **)(targetBuffer + 8),sourceData,(long long)copyLength);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




// 函数: void ValidateSystemState(void)
/**
 * @brief 执行系统内存复制操作
 * 
 * 该函数执行系统内存复制操作，是一个内存复制的辅助函数。
 */
void ExecuteSystemMemoryCopyOperation(void)

{
    memcpy();
}




// 函数: void SetupSystemMemory(uint8_t *SystemResourceManager)
/**
 * @brief 重置系统缓冲区
 * 
 * 该函数重置系统缓冲区，将缓冲区内容清零并重置相关计数器。
 * 
 * @param bufferPointer 缓冲区指针
 */
void ResetSystemBuffer(uint8_t *bufferPointer)

{
  long long systemRegister;
  
  *bufferPointer = 0;
  *(uint32_t *)(systemRegister + 0x10) = 0;
  return;
}





// 函数: void ConfigureSystemParameters(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 处理系统三参数缓冲区操作
 * 
 * 该函数负责处理需要三个参数的系统缓冲区操作，包括内存分配、
 * 数据复制和缓冲区管理。它使用栈缓冲区来处理临时数据，
 * 并执行相应的系统操作。
 * 
 * @param MainParameter 主操作参数
 * @param AuxiliaryParameter 辅助操作参数
 * @param ConfigurationParameter 配置参数
 * 
 * @note 这是一个通用的系统缓冲区处理函数
 */
void ProcessSystemThreeParameterBuffer(long long MainParameter,long long AuxiliaryParameter,long long ConfigurationParameter)

{
  long long StringSearchResult;
  long long StringLengthCounter;
  long long BufferLengthCounter;
  uint8_t StackSecurityBuffer [32];
  void* SystemSecurityFlag;
  void* *SystemMemoryReference;
  uint8_t* SystemBufferPointer;
  uint32_t SystemBufferLength;
  uint8_t SystemDataBuffer [1032];
  ulong long SystemChecksumValue;
  
  SystemSecurityFlag = 0xfffffffffffffffe;
  SystemChecksumValue = SystemEncryptionKeyTemplate ^ (ulong long)StackSecurityBuffer;
  SystemMemoryReference = &SystemMemoryTemplateF;
  SystemBufferPointer = SystemDataBuffer;
  SystemBufferLength = 0;
  SystemDataBuffer[0] = 0;
  StringSearchResult = strstr(*(void* *)(MainParameter + 8));
  if (StringSearchResult != 0) {
    StringLengthCounter = -1;
    BufferLengthCounter = -1;
    do {
      StringLengthCounter = StringLengthCounter + 1;
    } while (*(char *)(AuxiliaryParameter + StringLengthCounter) != '\0');
    do {
      BufferLengthCounter = BufferLengthCounter + 1;
    } while (*(char *)(BufferLengthCounter + ConfigurationParameter) != '\0');
      memcpy(SystemBufferPointer,*(long long *)(MainParameter + 8),StringSearchResult - *(long long *)(MainParameter + 8));
  }
  SystemMemoryReference = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemChecksumValue ^ (ulong long)StackSecurityBuffer);
}




// 函数: void InitializeSystemData(void* *SystemResourceManager,uint32_t ConfigurationDataPointer)
/**
 * @brief 释放系统信号量
 * 
 * 该函数负责释放系统信号量，它会重复调用ReleaseSemaphore函数
 * 直到成功释放为止。这确保了信号量的正确释放和系统同步。
 * 
 * @param SemaphoreHandle 信号量句柄指针
 * @param ReleaseCount 释放计数
 * 
 * @note 这是系统同步机制的重要组成部分，确保信号量的正确释放
 */
void ReleaseSystemSemaphore(void* *SemaphoreHandle,uint32_t ReleaseCount)

{
  int ReleaseResult;
  
  do {
    ReleaseResult = ReleaseSemaphore(*SemaphoreHandle,ReleaseCount,0);
  } while (ReleaseResult == 0);
  return;
}




// 函数: void FinalizeSystemSetup(void* *SystemResourceManager)
/**
 * @brief 解锁系统互斥锁
 * 
 * 该函数负责解锁系统互斥锁，它会检查互斥锁的状态，
 * 然后调用_Mtx_unlock函数进行解锁操作。如果解锁失败，
 * 会抛出相应的错误。
 * 
 * @param MutexHandle 互斥锁指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确解锁
 */
void UnlockSystemMutex(void* *MutexHandle)

{
  int UnlockResult;
  
  if (*(char *)(MutexHandle + 1) != '\0') {
    UnlockResult = _Mtx_unlock(*MutexHandle);
    if (UnlockResult != 0) {
      __Throw_C_error_std__YAXH_Z(UnlockResult);
    }
  }
  return;
}



/**
 * @brief 等待系统节点就绪
 * 
 * 该函数负责等待系统节点就绪状态，使用互斥锁和条件变量来同步
 * 系统节点的状态变化。这是系统初始化过程中的同步机制。
 * 
 * @param systemNodePointer 系统节点指针
 * @param timeoutParameter 超时参数
 * @param conditionVariable 条件变量
 * @param syncFlag 同步标志
 * @return 成功返回1，失败返回错误代码
 */
uint64_t WaitForSystemNodeReady(long long systemNodePointer, uint64_t timeoutParameter, uint64_t conditionVariable, uint64_t syncFlag)

{
  bool systemNodeReady;
  int mutexLockResult;
  long long mutexHandle;
  uint64_t waitTimeout;
  bool waitFlag;
  
  waitTimeout = 0xfffffffffffffffe;
  mutexHandle = systemNodePointer + 0x48;
  mutexLockResult = _Mtx_lock();
  if (mutexLockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexLockResult);
  }
  waitFlag = true;
  if (*(char *)(systemNodePointer + 0x98) != '\x01') {
    char NodeStatus = *(char *)(systemNodePointer + 0x98);
    while (systemNodeReady == false) {
      mutexLockResult = _Cnd_wait(systemNodePointer,mutexHandle,conditionVariable,syncFlag,waitTimeout,mutexHandle,waitFlag);
      if (mutexLockResult != 0) {
        __Throw_C_error_std__YAXH_Z(mutexLockResult);
      }
      NodeStatus = *(char *)(systemNodePointer + 0x98);
    }
  }
  *(char *)(systemNodePointer + 0x98) = 0;
  mutexLockResult = _Mtx_unlock(mutexHandle);
  if (mutexLockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexLockResult);
  }
  return 1;
}



/**
 * @brief 处理系统节点配置
 * 
 * 该函数负责处理系统节点的配置信息，包括节点回调、参数验证
 * 和配置更新。这是系统配置管理的重要组成部分。
 * 
 * @param nodeConfigPointer 节点配置指针
 * @param parameterBuffer 参数缓冲区
 * @return 返回处理结果状态码
 */
long long ProcessSystemNodeConfiguration(uint32_t* nodeConfigPointer, uint32_t* parameterBuffer)

{
  uint32_t configValue;
  char CallbackResult;
  void* errorStringPointer;
  
  if (*(long long *)(nodeConfigPointer + 0x18) != 0) {
    CallbackResult = (**(code **)(nodeConfigPointer + 0x1a))(parameterBuffer,nodeConfigPointer + 0x14);
    if (CallbackResult == '\0') {
      if (SystemDebugModeEnabled == '\0') {
        errorStringPointer = &SystemErrorMessageTemplate;
        if (*(void **)(nodeConfigPointer + 4) != (void *)0x0) {
          errorStringPointer = *(void **)(nodeConfigPointer + 4);
        }
        LogSystemErrorMessage(&SystemErrorLogBuffer,errorStringPointer);
      }
      *nodeConfigPointer = nodeConfigPointer[0x12];
      return (ulong long)(uint3)((uint)nodeConfigPointer[0x12] >> 8) << 8;
    }
  }
  configValue = *parameterBuffer;
  *nodeConfigPointer = configValue;
  return CONCAT71((uint7)(uint3)((uint)configValue >> 8),1);
}





/**
 * @brief 更新系统配置参数
 * 
 * 该函数负责更新系统的配置参数，执行配置验证回调，
 * 并根据验证结果决定是否应用配置更改。这是系统配置管理的核心功能。
 * 
 * @param configHandle 配置句柄
 * @param configValue 配置值
 */
void UpdateSystemConfigurationParameter(uint64_t configHandle, uint32_t configValue)

{
  long long systemConfigBase;
  char ValidationResult;
  void* errorMessagePointer;
  uint32_t parameterStack [6];
  
  systemConfigBase = SystemConfigurationDataBase;
  if ((*(long long *)(SystemConfigurationDataBase + 0x22f0) != 0) &&
     (parameterStack[0] = configValue, ValidationResult = (**(code **)(SystemConfigurationDataBase + 0x22f8))(parameterStack),
     configValue = parameterStack[0], ValidationResult == '\0')) {
    if (SystemDebugModeEnabled == '\0') {
      errorMessagePointer = &SystemErrorMessageTemplate;
      if (*(void **)(systemConfigBase + 0x22a0) != (void *)0x0) {
        errorMessagePointer = *(void **)(systemConfigBase + 0x22a0);
      }
      LogSystemErrorMessage(&SystemErrorLogBuffer,errorMessagePointer);
    }
    *(uint32_t *)(systemConfigBase + 0x2290) = *(uint32_t *)(systemConfigBase + 0x22d8);
    return;
  }
  *(uint32_t *)(systemConfigBase + 0x2290) = configValue;
  return;
}



/**
 * @brief 释放系统内存资源
 * 
 * 该函数负责释放系统的内存资源，设置资源模板，并根据标志位
 * 决定是否执行内存释放操作。这是系统内存管理的重要组成部分。
 * 
 * @param resourcePointer 资源指针
 * @param freeFlags 释放标志，用于控制是否释放内存
 * @param freeParameter1 释放参数1
 * @param freeParameter2 释放参数2
 * @return 返回处理后的资源指针
 */
void*
ReleaseSystemMemoryResource(void* resourcePointer, uint64_t freeFlags, uint64_t freeParameter1, uint64_t freeParameter2)

{
  *resourcePointer = &SystemMemoryResourceTemplate;
  if ((freeFlags & 1) != 0) {
    free(resourcePointer,0x38,freeParameter1,freeParameter2,InvalidHandleValue);
  }
  return resourcePointer;
}




/**
 * @brief 系统字符串复制函数（带长度限制）
 * 
 * 该函数用于将字符串从源地址复制到目标地址，有长度限制。
 * 如果源字符串为空，则清空目标字符串；如果字符串长度超过限制，
 * 则调用系统错误处理函数。
 * 
 * @param SystemResourceManager 目标字符串结构体指针
 * @param sourceString 源字符串指针
 * @note 最大字符串长度限制为0x20字节
 */
void ProcessSystemStringCopyWithLimit(long long targetBuffer,long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(sourceString + stringLength) != '\0');
  if ((int)stringLength < 0x20) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
                    0001800463b7. Too many branches
                        strcpy_s(*(void* *)(targetBuffer + 8),0x20);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x20,sourceString);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




// 函数: void SetupSystemMemoryPool(long long SystemResourceManager,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统内存复制操作（带长度限制）
 * 
 * 该函数执行系统内存复制操作，限制最大复制长度为0x20字节。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 */
void ExecuteSystemMemoryCopyWithLimit(long long targetBuffer,void* sourceData,int copyLength)

{
  if (copyLength + 1 < 0x20) {
      memcpy(*(uint8_t **)(targetBuffer + 8),sourceData,(long long)copyLength);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




/**
 * @brief 系统内存复制操作
 * 
 * 该函数执行系统内存复制操作，用于初始化过程中的数据复制。
 * 
 * @note 这是一个低级别的系统操作函数
 */
void ExecuteSystemMemoryCopy(void)

{
    memcpy();
}




/**
 * @brief 重置系统数据缓冲区
 * 
 * 该函数负责重置系统数据缓冲区，将缓冲区内容清零，
 * 并重置相关的偏移量计数器。
 * 
 * @param dataBufferPointer 指向需要重置的数据缓冲区的指针
 */
void ResetSystemDataBuffer(uint8_t *dataBufferPointer)

{
  long long bufferOffset;
  
  *dataBufferPointer = 0;
  *(uint32_t *)(bufferOffset + 0x10) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统内存分配器的引用，设置内存分配器的
 * 基础结构和相关参数。这是内存管理系统的重要组成部分。
 * 
 * @param memoryAllocatorPointer 内存分配器指针的指针
 * @return 返回初始化后的内存分配器指针
 */
void* * InitializeSystemMemoryAllocatorReference(void* *memoryAllocatorPointer)

{
  *memoryAllocatorPointer = &SystemMemoryAllocatorReference;
  memoryAllocatorPointer[1] = 0;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *memoryAllocatorPointer = &SystemMemoryTemplateE;
  memoryAllocatorPointer[1] = memoryAllocatorPointer + 3;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *(uint8_t *)(memoryAllocatorPointer + 3) = 0;
  return memoryAllocatorPointer;
}





// 函数: void ConfigureSystemBuffers(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统三参数数据处理函数
 * 
 * 该函数处理需要三个参数的系统数据操作，包括内存分配、
 * 数据处理和缓冲区管理。
 * 
 * @param param1 第一个参数
 * @param param2 第二个参数
 * @param param3 第三个参数
 */
void ProcessSystemThreeParameterData(long long sourceStringPointer,long long targetStringPointer,long long searchStringLength)

{
  long long StringSearchResult;
  long long SourceStringLength;
  long long TargetStringLength;
  uint8_t StackSecurityBuffer [32];
  void* SecurityFlags;
  void* *MemoryReference;
  uint8_t *DataBuffer;
  uint32_t BufferLength;
  uint8_t TempDataBuffer [32];
  ulong long ChecksumValue;
  
  SecurityFlags = 0xfffffffffffffffe;
  ChecksumValue = SystemEncryptionKeyTemplate ^ (ulong long)StackSecurityBuffer;
  MemoryReference = &SystemMemoryTemplateE;
  DataBuffer = TempDataBuffer;
  BufferLength = 0;
  TempDataBuffer[0] = 0;
  StringSearchResult = strstr(*(void* *)(param1 + 8));
  if (StringSearchResult != 0) {
    SourceStringLength = -1;
    TargetStringLength = -1;
    do {
      TargetStringLength = TargetStringLength + 1;
    } while (*(char *)(param2 + TargetStringLength) != '\0');
    do {
      SourceStringLength = SourceStringLength + 1;
    } while (*(char *)(SourceStringLength + param3) != '\0');
      memcpy(DataBuffer,*(long long *)(param1 + 8),StringSearchResult - *(long long *)(param1 + 8));
  }
  MemoryReference = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(ChecksumValue ^ (ulong long)StackSecurityBuffer);
}



void* * GetSystemMemoryAllocatorReference(void* *MemoryAllocatorPointer,ulong long MemoryAllocationFlags)

{
  *MemoryAllocatorPointer = &SystemMemoryAllocatorReference;
  if ((MemoryAllocationFlags & 1) != 0) {
    free(MemoryAllocatorPointer,0x18);
  }
  return MemoryAllocatorPointer;
}




// 函数: void UnlockSystemMutex(void* *SystemResourceManager)
void UnlockSystemMutex(void* *MutexHandle)

{
  int UnlockResult;
  
  UnlockResult = _Mtx_unlock(*MutexHandle);
  if (UnlockResult != 0) {
    __Throw_C_error_std__YAXH_Z(UnlockResult);
  }
  return;
}




// 函数: void LockSystemMutexAndBroadcast(long long SystemResourceManager)
void LockSystemMutexAndBroadcast(long long SystemContextPointer)

{
  int LockResult;
  
  LockResult = _Mtx_lock(SystemContextPointer + 0x48);
  if (LockResult != 0) {
    __Throw_C_error_std__YAXH_Z(LockResult);
  }
  *(uint8_t *)(SystemContextPointer + 0x98) = 1;
  LockResult = _Cnd_broadcast(SystemContextPointer);
  if (LockResult != 0) {
    __Throw_C_error_std__YAXH_Z(LockResult);
  }
  LockResult = _Mtx_unlock(SystemContextPointer + 0x48);
  if (LockResult != 0) {
    __Throw_C_error_std__YAXH_Z(LockResult);
  }
  return;
}




// 函数: void InitializeSystemReferencePointers(void* *SystemResourceManager)
void InitializeSystemReferencePointers(void* *SystemReferencePointer)

{
  *SystemReferencePointer = &SystemMemoryTemplateC;
  *SystemReferencePointer = &SystemMemoryTemplateB;
  *SystemReferencePointer = &SystemMemoryTemplateA;
  return;
}



void* *
InitializeSystemReferencePointersWithCleanup(void* *SystemReferencePointer,ulong long CleanupFlags,void* CleanupParameter1,void* CleanupParameter2)

{
  *SystemReferencePointer = &SystemMemoryTemplateC;
  *SystemReferencePointer = &SystemMemoryTemplateB;
  *SystemReferencePointer = &SystemMemoryTemplateA;
  if ((CleanupFlags & 1) != 0) {
    free(SystemReferencePointer,0x20,CleanupParameter1,CleanupParameter2,InvalidHandleValue);
  }
  return SystemReferencePointer;
}




// 函数: void ProcessSystemMemoryRange(long long* SystemResourceManager)
void ProcessSystemMemoryRange(long long *MemoryRangePointer)

{
  long long MemoryRangeEnd;
  long long CurrentMemoryAddress;
  
  MemoryRangeEnd = MemoryRangePointer[1];
  for (CurrentMemoryAddress = *MemoryRangePointer; CurrentMemoryAddress != MemoryRangeEnd; CurrentMemoryAddress = CurrentMemoryAddress + 0x100) {
    ProcessSystemMemoryPage(CurrentMemoryAddress);
  }
  if (*MemoryRangePointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemDataPointers(long long* SystemResourceManager)
void InitializeSystemDataPointers(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 5) {
    *SystemHashEntryPointer = &SystemGlobalDataReference;
    if (SystemHashEntryPointer[1] != 0) {
        SystemCleanupFunction();
    }
    SystemHashEntryPointer[1] = 0;
    *(uint32_t *)(SystemHashEntryPointer + 3) = 0;
    *SystemHashEntryPointer = &SystemMemoryAllocatorReference;
  }
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * 内存管理器 - 释放内存块引用
 * 管理内存块的引用计数，当引用计数为0时释放内存
 * 
 * @param SystemResourceManager 内存块指针的指针
 */
void ReleaseMemoryBlockReference(ulong long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = (void* *)*SystemResourceManager;
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 系统核心组件初始化函数
 * 
 * 该函数负责初始化游戏系统的核心组件，包括内存管理、数据处理和系统配置。
 * 函数会创建必要的系统对象，初始化内存池，并设置系统参数。
 * 
 * @param SystemResourceManager 资源管理器指针，用于管理系统资源
 * @param InitializationFlags 初始化标志，控制初始化过程的不同阶段
 * @return 初始化结果状态码，成功返回0，失败返回错误码
 * 
 * 原始函数名可能为类似FUN_xxxxx的形式：InitializeSystemCoreComponents
 */
/**
 * @brief 初始化系统核心组件
 * 
 * 该函数负责初始化系统的核心组件，包括内存管理器、资源管理器、
 * 加密上下文和其他关键系统组件。这是系统启动过程中的重要步骤。
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于管理系统资源
 * @param InitializationFlags 初始化标志，指定初始化的方式和选项
 * @return 初始化结果，返回0表示成功，非0表示失败
 * 
 * 系统核心组件初始化器
 */
int InitializeSystemCoreComponents(long long SystemResourceManager,long long InitializationFlags)

{
  void*** SystemResourcePointer;           // 系统资源指针
  long long SystemHandle;                  // 系统句柄
  void** SystemSystemHashNodeData;            // 系统哈希节点指针
  long long MemoryBufferBase;              // 内存缓冲区基地址
  int SystemResultValue;                    // 系统结果值
  long long LocalSystemFlags;               // 本地系统标志
  long long DataIndex;                     // 数据索引
  ulong long MemoryAddress;                // 内存地址
  void* ****SystemResourceTablePointer;
  void* ***EncryptionContextPointer;
  void* *SystemMemoryContextPointer;
  long long LocalMemoryBufferHandle;
  uint32_t ResourceAllocationFlags;
  void* SystemContextPrimary;
  void* SystemContextSecondary;
  void* MemoryBufferPrimary;
  void* MemoryBufferSecondary;
  void* MemoryBufferTertiary;
  void* MemoryBufferQuaternary;
  void* MemoryBufferQuinary;
  void* MemoryBufferSenary;
  void* MemoryBufferSeptenary;
  void* MemoryBufferOctonary;
  void* MemoryBufferNonary;
  void* MemoryBufferDenary;
  void* MemoryBufferUndenary;
  void* MemoryBufferDuodenary;
  void* MemoryBufferTredecenary;
  void* MemoryBufferQuattuordecenary;
  void* MemoryBufferQuindecenary;
  void* ThreadLocalStorageParameter;
  void* MemoryBufferSexdecenary;
  void* MemoryBufferSeptendecenary;
  void* MemoryBufferOctodecenary;
  void* MemoryBufferNovemdecenary;
  void* ***ResourceEncryptionContext;
  void* ***SystemResourceManagerContext;
  void* MemoryBufferVigesimal;
  void* MemoryBufferUnvigesimal;
  void* EncryptionKeyValue;
  uint32_t SystemOperationStatus;
  void* SystemResourceHandle;
  
  SystemGlobalHandle = 0xfffffffffffffffe;
  SystemHandle = 0;
  SystemMemoryContext = (void* *)&SystemGlobalDataReference;
  SystemContextPrimary = 0;
  LocalMemoryBufferHandle = 0;
  ResourceAllocationFlags = 0;
  MemoryBufferSecondary = 0;
  MemoryBufferTertiary = 0;
  MemoryBufferQuaternary = 0;
  MemoryBufferQuinary = 0;
  MemoryBufferSenary = 0;
  MemoryBufferSeptenary = 0;
  MemoryBufferOctonary = 0;
  MemoryBufferNonary = 0;
  MemoryBufferDenary = 0;
  SystemOperationStatus = 3;
  MemoryBufferVigesimal = 0;
  MemoryBufferUnvigesimal = 0;
  EncryptionKeyValue = 0;
  SystemHashNodeData = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemHashNodeData = *(void* **)(ConfigurationDataPointer + 8);
  }
  EncryptionContextPointer = &SystemEncryptionValueTriple;
  SystemEncryptionValueTriple = &SystemEncryptionValueTriple;
  SystemEncryptionPointer60 = &SystemEncryptionValueTriple;
  InitializeSystemStructure(&SystemMemoryContextPointer,SystemHashNodeData);
  SystemResourceCounter118 = 0;
  SystemResourceCounter110 = 0;
  SystemResourceCounterC0 = 0;
  SystemDataBufferPointer = 0;
  SystemStackStatusFlagB0 = 0;
  SystemResourceCounterA8 = 0;
  SystemResourceCounterA0 = 0;
  SystemConfigurationValue1 = 0;
  SystemConfigurationValue2 = 0;
  SystemResourceCounter88 = 0;
  SystemResourceCounter80 = 0;
  SystemResourceCounter78 = 0;
  SystemProcessFlags70 = 0;
  OperationCode = *(ulong long *)(SystemResourceManager + 0x10);
  if (OperationCode < *(ulong long *)(SystemResourceManager + 0x18)) {
    *(ulong long *)(SystemResourceManager + 0x10) = OperationCode + 0x100;
    ProcessSystemData(OperationCode,&SystemMemoryContextPointer);
    SystemResourceTablePointer = *(void* *****)(SystemResourceManager + 0x10);
    goto MemoryAllocationComplete;
  }
  SystemMemoryBaseAddress = *(long long *)(SystemResourceManager + 8);
  SystemMemoryOffset = (long long)(OperationCode - SystemMemoryBaseAddress) >> 8;
  if (SystemMemoryOffset == 0) {
    SystemMemoryOffset = 1;
SystemMemoryOffsetCheck:
    SystemResourceHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemMemoryOffset << 8,*(uint8_t *)(SystemResourceManager + 0x20));
    OperationCode = *(ulong long *)(SystemResourceManager + 0x10);
    SystemMemoryBaseAddress = *(long long *)(SystemResourceManager + 8);
  }
  else {
    SystemMemoryOffset = SystemMemoryOffset * 2;
    if (SystemMemoryOffset != 0) goto SystemMemoryOffsetCheck;
  }
  InitializeSystemBuffer(&SystemEncryptionContext,SystemMemoryBaseAddress,OperationCode,SystemResourceHandle);
  SystemDataPointerPointer = SystemEncryptionContext;
  ProcessSystemData(SystemEncryptionContext,&SystemMemoryContext);
  SystemResourceManagerContext = (void* ****)(SystemDataPointerPointer + 0x20);
  SystemResourceTableSize = *(long long *)(SystemResourceManager + 0x10);
  SystemResourceTablePointer = *(long long *)(SystemResourceManager + 8);
  if (SystemResourceTablePointer != SystemResourceTableSize) {
    do {
      ProcessSystemMemoryPage(SystemResourceTablePointer);
      SystemResourceTablePointer = SystemResourceTablePointer + 0x100;
    } while (SystemResourceTablePointer != SystemResourceTableSize);
    SystemResourceTablePointer = *(long long *)(SystemResourceManager + 8);
  }
  if (SystemResourceTablePointer != 0) {
      SystemCleanupFunction(SystemResourceTablePointer);
  }
  *(long long *)(SystemResourceManager + 8) = SystemResourceHandle;
  *(void* *****)(SystemResourceManager + 0x10) = SystemResourceManagerContext;
  *(long long *)(SystemResourceManager + 0x18) = SystemMemoryOffset * 0x100 + SystemResourceHandle;
SystemValueCalculation:
  systemValue = (int)((ulong long)((long long)SystemResourceManagerContext - *(long long *)(SystemResourceManager + 8)) >> 8) + -1;
  *(int *)(SystemResourceManager + 0x68) = systemValue;
  SystemEncryptionContext = &SystemEncryptionValueTriple;
  InitializeAndCleanupSystemMemoryAllocator(&SystemEncryptionValueTriple,SystemProcessFlags58);
  SystemEncryptionContext = (void* ***)&SystemMemoryContext;
  SystemMemoryContext = (void* *)&SystemGlobalDataReference;
  if (LocalStackInitializationFlag == 0) {
    return systemValue;
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemDataBlock(void* *SystemResourceManager,void* SourceDataPointer,void* MemoryBufferSize,void* AllocationFlags)
void InitializeSystemDataBlock(void* *SystemResourceManager,void* SourceDataPointer,void* MemoryBufferSize,void* AllocationFlags)

{
  InitializeAndCleanupSystemMemoryAllocator(SystemResourceManager + 0x1a,SystemResourceManager[0x1c],MemoryBufferSize,AllocationFlags,InvalidHandleValue);
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}



ulong long CompareSystemDataBlocks(long long SystemResourceManager,long long ComparisonDataPointer)

{
  byte *comparisonBytePointer;
  int systemResult;
  long long ResourceDataOffset;
  byte *sourceBytePointer;
  int systemValue;
  int CalculationFlags;
  ulong long dataSizeLimit;
  long long SystemMemoryAddress;
  uint indexCounter;
  ulong long comparisonIndex;
  ulong long loopCounter;
  
  comparisonIndex = (ulong long)*(int *)(SystemResourceManager + 0x68);
  ResourceDataOffset = *(long long *)(SystemResourceManager + 8);
  if (comparisonIndex < (ulong long)(*(long long *)(SystemResourceManager + 0x10) - ResourceDataOffset >> 8)) {
    systemValue = *(int *)(ComparisonDataPointer + 0x10);
    systemResult = *(int *)(comparisonIndex * 0x100 + 0x10 + ResourceDataOffset);
    if (systemResult == systemValue) {
      if (systemResult != 0) {
        sourceBytePointer = *(byte **)(comparisonIndex * 0x100 + 8 + ResourceDataOffset);
        SystemMemoryAddress = *(long long *)(ComparisonDataPointer + 8) - (long long)sourceBytePointer;
        do {
          comparisonBytePointer = sourceBytePointer + SystemMemoryAddress;
          systemValue = (uint)*sourceBytePointer - (uint)*comparisonBytePointer;
          if (systemValue != 0) break;
          sourceBytePointer = sourceBytePointer + 1;
        } while (*comparisonBytePointer != 0);
      }
    }
    else if (systemResult != 0) goto SystemResultCheck;
    if (systemValue == 0) {
SystemResultHandler:
      return comparisonIndex & MAX_UNSIGNED_32_BIT;
    }
  }
SystemResultCheck:
  comparisonIndex = 0;
  dataSizeLimit = *(long long *)(SystemResourceManager + 0x10) - ResourceDataOffset >> 8;
  if (dataSizeLimit != 0) {
    systemValue = *(int *)(ComparisonDataPointer + 0x10);
    loopCounterValue = comparisonIndex;
    do {
      systemResult = *(int *)(loopCounter + 0x10 + ResourceDataOffset);
      CalculationFlags = systemValue;
      if (systemResult == systemValue) {
        if (systemResult != 0) {
          sourceBytePointer = *(byte **)(loopCounter + 8 + ResourceDataOffset);
          SystemMemoryAddress = *(long long *)(ComparisonDataPointer + 8) - (long long)sourceBytePointer;
          do {
            comparisonBytePointer = sourceBytePointer + SystemMemoryAddress;
            CalculationFlags = (uint)*sourceBytePointer - (uint)*comparisonBytePointer;
            if (CalculationFlags != 0) break;
            sourceBytePointer = sourceBytePointer + 1;
          } while (*comparisonBytePointer != 0);
        }
SystemResultZeroHandler:
        if (CalculationFlags == 0) {
          *(int *)(SystemResourceManager + 0x68) = (int)comparisonIndex;
          goto SystemResultHandler;
        }
      }
      else if (systemResult == 0) goto SystemResultZeroHandler;
      indexCounter = (int)comparisonIndex + 1;
      comparisonIndex = (ulong long)indexCounter;
      loopCounterValue = loopCounter + 0x100;
    } while ((ulong long)(long long)(int)indexCounter < dataSizeLimit);
  }
  return 0xffffffff;
}





/**
 * 初始化系统控制器
 * 设置系统控制器并分配必要的内存资源
 * 
 * @param SystemResourceManager 系统资源指针
 * @param SystemConfigurationPointer 系统配置指针
 */
void InitializeSystemController(long long* SystemResourceManager,void* *SystemConfigurationPointer)

{
  long long *PrimaryResourcePointer;
  long long *ResourceStackPointer;
  void** hashTableNode;
  long long *MemoryStackPointer;
  long long **StackReferencePointer;
  uint32_t SystemStatusFlag;
  void* SystemMemoryHandle;
  
  SystemMemoryHandle = 0xfffffffffffffffe;
  SystemStatusFlag = 0;
  ResourceStackPointer = SystemResourceManager;
  SystemConfigurationPointer = SystemConfigurationPointer;
  SystemMemoryCleanupHandler();
  PrimaryResourcePointer = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,200,8,3,SystemStatusFlag,SystemMemoryHandle);
  ResourceStackPointer = PrimaryResourcePointer;
  InitializeSystemDataTableManager(PrimaryResourcePointer);
  *PrimaryResourcePointer = (long long)&SystemDataTableTemplate;
  PrimaryResourcePointer[0x18] = (long long)&SystemMemoryCleanupCallback;
  MemoryStackPointer = PrimaryResourcePointer;
  (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
  SystemMemoryHandle = SystemAllocationFlagsTemplate;
  StackReferencePointer = &ResourceStackPointer;
  ResourceStackPointer = PrimaryResourcePointer;
  (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
  SystemManagerInitialize(SystemMemoryHandle,&ResourceStackPointer);
  (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer);
  SystemMemoryAllocationCounter = (long long)*(int *)(SystemGlobalStatusFlags + 0x224);
  ConfigureSystemSettings(&SystemConfigurationTemplate,SystemConfigurationPointer);
  *SystemConfigurationPointer = &SystemGlobalDataReference;
  if (SystemConfigurationPointer[1] != 0) {
      SystemCleanupFunction();
  }
  SystemConfigurationPointer[1] = 0;
  *(uint32_t *)(SystemConfigurationPointer + 3) = 0;
  *SystemConfigurationPointer = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 初始化系统核心引擎
 * 
 * 该函数负责初始化系统的核心引擎组件，设置系统启动所需的基础结构。
 * 它会配置内存管理器、初始化系统参数、设置核心服务，并建立系统状态监控。
 * 这是系统初始化过程中的核心函数，确保引擎组件正确启动和运行。
 * 
 * @note 这是系统初始化过程中的关键函数，负责整个引擎的初始化工作
 */
void InitializeSystemCoreEngine(void)

{
  void* SystemOperationStatusFlag;
  char InitializationStatus;
  int NodeIdentifierComparisonResult;
  long long ***systemMemoryManager;
  ulong long SystemConfigValue;
  long long SystemTimeValue;
  void** SystemCurrentNode;
  uint32_t *systemParameterPointer;
  uint8_t *systemDataBuffer;
  uint32_t systemControlFlag;
  float systemPerformanceValue1;
  float systemPerformanceValue2;
  uint8_t systemSecurityBuffer [32];
  long long systemMemoryHandle;
  long long systemResourceHandle;
  int systemInitStatus;
  void* *systemCallbackPointer;
  uint8_t *systemEventBuffer;
  uint systemEventCounter;
  ulong long systemTimestamp;
  uint32_t systemOperationFlag;
  long long ***systemMemoryPool;
  long long **systemMemoryTable;
  long long ****systemMemoryRoot;
  void* *systemErrorHandler;
  void* systemContext;
  uint32_t systemPriority;
  void* systemSemaphore;
  void* *systemLock;
  long long systemThreadId;
  int systemThreadStatus;
  uint32_t systemThreadFlag;
  void* *systemThreadContext;
  long long systemHeapHandle;
  uint32_t systemHeapSize;
  long long ***systemHeapArray [2];
  void* *systemHeapManager;
  code *systemEntryPoint;
  void* systemEntryPointParam;
  long long **SystemTablePointer;
  void* *systemTableLock;
  uint8_t *systemTableBuffer;
  uint32_t systemTableFlag;
  uint8_t systemTableData [72];
  void* *systemCacheManager;
  uint8_t *systemCacheBuffer;
  uint32_t systemCacheFlag;
  uint8_t systemCacheData [72];
  void* *systemIoManager;
  uint8_t *systemIoBuffer;
  uint32_t systemIoFlag;
  uint8_t systemIoData [72];
  void* *systemNetworkManager;
  uint8_t *systemNetworkBuffer;
  uint32_t systemNetworkFlag;
  uint8_t systemNetworkData [72];
  void* *systemRenderManager;
  uint8_t *systemRenderBuffer;
  uint32_t systemRenderFlag;
  uint8_t systemRenderData [72];
  void* *systemAudioManager;
  uint8_t *systemAudioBuffer;
  uint32_t systemAudioFlag;
  uint8_t systemAudioData [72];
  void* *systemInputManager;
  uint8_t *systemInputBuffer;
  uint32_t systemInputFlag;
  uint8_t systemInputData [648];
  ulong long systemSecurityHash;
  
  CalculationFlagss4f8 = 0xfffffffffffffffe;
  EncryptionValue68 = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer698;
  systemStateFlags5b8 = 0;
  if (*(int *)(SystemGlobalStatusFlags + 0x224) - SystemMemoryAllocationCounter < 0xfb) {
      ValidateSystemChecksum(EncryptionValue68 ^ (ulong long)EncryptionBuffer698);
  }
  *(uint8_t *)(SystemSystemResourceManager + 0x39) = 1;
  SystemDataTablePointer = (long long ***)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,200,8,3);
  SystemDataTableManager = SystemDataTablePointer;
  InitializeSystemDataTableManager(SystemDataTablePointer);
  *SystemDataTablePointer = (long long **)&SystemDataTableTemplate;
  SystemDataTablePointer[0x18] = (long long **)&SystemMemoryAllocationCallback;
  SystemMemoryCallbackHandler = (long long **)SystemDataTablePointer;
  (*(code *)(*SystemDataTablePointer)[5])(SystemDataTablePointer);
  SystemOperationStatus = SystemAllocationFlagsTemplate;
  SystemInitializationFlag = 1;
  SystemDataTableManager = &SystemMemoryCallbackHandler;
  SystemMemoryCallbackHandler = (long long **)SystemDataTablePointer;
  (*(code *)(*SystemDataTablePointer)[5])(SystemDataTablePointer);
  SystemManagerInitialize(SystemOperationStatus,&SystemMemoryCallbackHandler);
  SystemInitializationFlag = 0;
  (*(code *)(*SystemDataTablePointer)[7])(SystemDataTablePointer);
  InitializeSystemContext(&LocalStackConfigurationPointer,&SystemConfigurationTemplate);
  if (IntegerStackInitializationFlag == 0) {
    (**(code **)(LocalStackConfigurationPointer + 0x10))(&LocalStackConfigurationPointer,&SystemRuntimeDataTemplate);
    validationStatusFlag = ValidateSystemConfiguration(&LocalStackConfigurationPointer);
    if (validationStatusFlag == '\0') {
      SetupSystemResources(&LocalStackConfigurationPointer);
    }
  }
  validationStatusFlag = ValidateSystemConfiguration(&LocalStackConfigurationPointer);
  if (validationStatusFlag == '\0') {
    SetupSystemResources(&LocalStackConfigurationPointer);
  }
  SystemDataBufferPointer = &SystemDataBufferTemplateB;
  DataBufferPtr4E0 = DataBuffer4D0;
  DataBuffer4D0[0] = 0;
  configurationFlags4d8 = 0x18;
  strcpy_s(DataBuffer4D0,0x40,&SystemDataBufferTemplateJ);
  InitializeResourceManager(SystemSystemResourceManager,&SystemDataBufferPointer,&LocalStackConfigurationPointer);
  SystemDataBufferPointer = &SystemMemoryAllocatorReference;
  pSystemEncryptionKey8 = &SystemDataBufferTemplateB;
  DataBufferPtr480 = DataBuffer470;
  DataBuffer470[0] = 0;
  configurationFlags478 = 0xb;
  strcpy_s(DataBuffer470,0x40,&SystemDataBufferTemplateK);
  InitializeResourceManager(SystemSystemResourceManager,&pSystemEncryptionKey8,&LocalStackConfigurationPointer);
  pSystemEncryptionKey8 = &SystemMemoryAllocatorReference;
  SystemScaleFactorBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr420 = SystemScaleFactorXBuffer;
  SystemScaleFactorXBuffer[0] = 0;
  configurationFlags418 = 0x18;
  SystemOperationFlags = strcpy_s(SystemScaleFactorXBuffer,0x40,&SystemDataBufferTemplateJ);
  SystemScaleFactorXStorage = (float)GetSystemScaleFactor(SystemOperationFlags,&SystemScaleFactorBuffer);
  SystemScaleFactorXStorage = 1.0 / SystemScaleFactorXStorage;
  SystemScaleFactorBuffer = &SystemMemoryAllocatorReference;
  SystemResolutionFactorBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr3C0 = SystemScaleFactorYBuffer;
  SystemScaleFactorYBuffer[0] = 0;
  configurationFlags3b8 = 0xb;
  SystemOperationFlags = strcpy_s(SystemScaleFactorYBuffer,0x40,&SystemDataBufferTemplateK);
  SystemScaleFactorYStorage = (float)GetSystemScaleFactor(SystemOperationFlags,&SystemResolutionFactorBuffer);
  SystemScaleFactorYStorage = 1.0 / SystemScaleFactorYStorage;
  SystemResolutionFactorBuffer = &SystemMemoryAllocatorReference;
  HorizontalResolutionBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr360 = SystemHorizontalResolutionBuffer;
  SystemHorizontalResolutionBuffer[0] = 0;
  configurationFlags358 = 0xb;
  SystemOperationFlags = strcpy_s(SystemHorizontalResolutionBuffer,0x40,&SystemDataBufferTemplateK);
  horizontalResolutionFactor = (float)GetSystemResolutionFactor(SystemOperationFlags,&HorizontalResolutionBuffer);
  HorizontalResolutionBuffer = &SystemMemoryAllocatorReference;
  VerticalResolutionBuffer = &SystemDataBufferTemplateB;
  DataBufferPtr300 = SystemVerticalResolutionBuffer;
  SystemVerticalResolutionBuffer[0] = 0;
  configurationFlags2f8 = 0x18;
  SystemOperationFlags = strcpy_s(SystemVerticalResolutionBuffer,0x40,&SystemDataBufferTemplateJ);
  verticalResolutionFactor = (float)GetSystemResolutionFactor(SystemOperationFlags,&VerticalResolutionBuffer);
  VerticalResolutionBuffer = &SystemMemoryAllocatorReference;
  currentThreadId = GetSystemInitializationStatus();
  if (0 < SystemConfigDataPointerD) {
    InitializeSystemConfiguration(&SystemConfigurationTemplate,&SystemConfigPathBuffer,0,SystemConfigDataPointerD + -1);
    SystemPathLengthCounter = SystemPathLengthCounter + -1;
    SystemPathOffset = (long long)SystemPathLengthCounter;
    systemCounter = -1;
    if (-1 < SystemPathLengthCounter) {
      do {
        systemCounter = SystemPathLengthCounter;
        if (*(char *)(LocalStackStringBuffer + SystemPathOffset) == '/') break;
        SystemPathLengthCounter = SystemPathLengthCounter + -1;
        SystemPathOffset = SystemPathOffset + -1;
        systemCounter = -1;
      } while (-1 < SystemPathOffset);
    }
    InitializeSystemConfiguration(&SystemConfigPathBuffer,&SystemConfigNameBuffer,systemCounter + 1,0xffffffff);
    systemCounter = FindSystemResourceIndex(&SystemResourceTemplate,&SystemConfigNameBuffer);
    if (systemCounter == -1) {
      systemCounter = FindSystemResourceHandle(&SystemResourceTemplate,&SystemConfigNameBuffer);
    }
    SystemThreadFlags = (long long)systemCounter * 0x100;
    SystemResourceDataTablePointer = (long long ***)(SystemInitializationDataStart + 0x30 + SystemThreadFlags);
    SystemResourceArrayPointer = arrayPointerTriple518;
    SystemStringTemplatePointer = &SystemStringFormatTemplate;
    SystemStringProcessor = SystemStringFormatProcessor;
    arrayPointerTriple518[0] = (long long ***)&SystemResourceDataTablePointer;
    ProcessSystemResourceData(arrayPointerTriple518);
    *(double *)(SystemThreadFlags + 0xa0 + SystemInitializationDataStart) = (double)(1.0 / verticalResolutionFactor);
    *(double *)(SystemThreadFlags + 0xb8 + SystemInitializationDataStart) = (double)(1.0 / horizontalResolutionFactor);
    *(int *)(SystemThreadFlags + 0xb0 + SystemInitializationDataStart) = (int)(long long)SystemScaleFactorXStorage;
    *(int *)(SystemThreadFlags + 200 + SystemInitializationDataStart) = (int)(long long)SystemScaleFactorYStorage;
    *(double *)(SystemThreadFlags + 0x20 + SystemInitializationDataStart) = (double)(currentThreadId >> 0x14);
    SystemGlobalDataReference = &SystemGlobalDataReference;
    if (SystemCleanupRequiredFlag != 0) {
        SystemCleanupFunction();
    }
    SystemCleanupRequiredFlag = 0;
    SystemMemoryManagementFlag = 0;
    SystemMemoryAllocatorReference = &SystemMemoryAllocatorReference;
    SystemGlobalDataReferenceSecondary = &SystemGlobalDataReference;
    if (LocalStackStringBuffer != 0) {
        SystemCleanupFunction();
    }
    LocalStackStringBuffer = 0;
    SystemStringProcessingFlag = 0;
    SystemMemoryAllocatorReferenceSecondary = &SystemMemoryAllocatorReference;
  }
  SystemGlobalDataReferenceTertiary = &SystemGlobalDataReference;
  SystemDataProcessingFlag1 = 0;
  SystemDataProcessingFlag2 = 0;
  SystemDataProcessingFlag3 = 0;
  SystemGlobalDataReferenceQuaternary = &SystemGlobalDataReference;
  SystemBufferProcessingFlag = 0;
  SystemDataBufferPointer = (uint8_t *)0x0;
  SystemBufferOffsetCounter = 0;
  WriteDataToBuffer(&SystemGlobalDataReferenceQuaternary,SystemThreadInitializedFlag);
  if (SystemThreadInitializedFlag != 0) {
      memcpy(SystemDataBufferPointer,SystemDataBufferSize,SystemThreadInitializedFlag + 1);
  }
  if (SystemDataBufferSize != 0) {
    SystemBufferOffsetCounter = 0;
    if (SystemDataBufferPointer != (uint8_t *)0x0) {
      *SystemDataBufferPointer = 0;
    }
    SystemBufferProcessingFlag = SystemBufferProcessingFlag & MAX_UNSIGNED_32_BIT;
  }
  InitializeSystemRuntimeState(&LocalStackConfigurationPointer,1);
  SystemResourceCounter = SystemBufferOffsetCounter + 0x11;
  WriteDataToBuffer(&SystemGlobalDataReferenceQuaternary,SystemResourceCounter);
  SystemThreadLocalStorage = (uint32_t *)(SystemDataBufferPointer + SystemBufferOffsetCounter);
  *SystemThreadLocalStorage = 0x69676e65;
  SystemThreadLocalStorage[1] = 0x635f656e;
  SystemThreadLocalStorage[2] = 0x69666e6f;
  SystemThreadLocalStorage[3] = 0x78742e67;
  *(void*2 *)(SystemThreadLocalStorage + 4) = 0x74;
  SystemBufferOffsetCounter = SystemResourceCounter;
  hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x18,8,3);
  systemTemplatePointer = &SystemStringTemplate;
  if (SystemDataBufferPointer != (uint8_t *)0x0) {
    SystemStringTemplatePointer = SystemDataBufferPointer;
  }
  *hashTableNode = 0;
  *(uint8_t *)(hashTableNode + 2) = 0;
  ConfigureSystemNodeParameters(hashTableNode,SystemStringTemplatePointer,&SystemConfigurationDataTemplate);
  RegisterSystemNode(SystemNodeManagerPointer,hashTableNode);
  if (hashTableNode[1] != 0) {
    fclose();
    hashTableNode[1] = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
    if (hashTableNode[1] != 0) {
      fclose();
      hashTableNode[1] = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
  }
    SystemCleanupFunction(hashTableNode);
}



void* *
/**
 * @brief 复制系统数据结构
 * 
 * 该函数负责复制系统数据结构，包括基本数据、标志位和配置信息。
 * 它会递归地复制复杂的数据结构，确保数据的完整性和一致性。
 * 
 * @param SystemResourceManager 目标数据结构指针
 * @param sourceDataPointer 源数据结构指针
 * @param copyFlags 复制标志参数
 * @param additionalParams 附加参数
 * @return 返回复制后的目标数据结构指针
 * @note 这是系统数据管理的重要组成部分，确保数据复制的正确性
 */
void* CopySystemDataStructure(void* *SystemResourceManager,void* *sourceDataPointer,void* copyFlags,void* additionalParams)

{
  *SystemResourceManager = *sourceDataPointer;
  *(uint32_t *)(SystemResourceManager + 1) = *(uint32_t *)(sourceDataPointer + 1);
  InitializeSystemResourceExtended(SystemResourceManager + 2,sourceDataPointer + 2,copyFlags,additionalParams,InvalidHandleValue);
  *(uint32_t *)(SystemResourceManager + 0x15) = *(uint32_t *)(sourceDataPointer + 0x15);
  *(uint32_t *)((long long)SystemResourceManager + 0xac) = *(uint32_t *)((long long)sourceDataPointer + 0xac);
  SystemResourceManager[0x16] = sourceDataPointer[0x16];
  SystemResourceManager[0x17] = sourceDataPointer[0x17];
  SystemResourceManager[0x18] = sourceDataPointer[0x18];
  *(uint8_t *)(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = *(uint8_t *)(sourceDataPointer + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  *(uint8_t *)((long long)SystemResourceManager + 0xc9) = *(uint8_t *)((long long)sourceDataPointer + 0xc9);
  *(uint8_t *)((long long)SystemResourceManager + 0xca) = *(uint8_t *)((long long)sourceDataPointer + 0xca);
  *(uint8_t *)((long long)SystemResourceManager + 0xcb) = *(uint8_t *)((long long)sourceDataPointer + 0xcb);
  *(uint8_t *)((long long)SystemResourceManager + 0xcc) = *(uint8_t *)((long long)sourceDataPointer + 0xcc);
  return SystemResourceManager;
}




// 函数: void SetSystemMemoryAllocatorReference(long long SystemResourceManager)
/**
 * @brief 设置系统内存分配器引用
 * 
 * 该函数负责在指定对象的偏移量0x10处设置系统内存分配器的引用。
 * 这是一个简单的指针设置操作，用于初始化对象的内存分配器引用。
 * 
 * @param systemObject 系统对象指针
 */
void SetSystemMemoryAllocatorReference(long long systemObject)

{
  *(void* **)(systemObject + 0x10) = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 设置系统内存分配器指针
 * 
 * 该函数负责在指定指针位置设置系统内存分配器的指针。
 * 这是一个简单的指针赋值操作，用于初始化内存分配器指针。
 * 
 * @param allocatorPointer 内存分配器指针的指针
 */
void SetSystemMemoryAllocatorPointer(void* *allocatorPointer)

{
  *allocatorPointer = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 系统数据查找和匹配
 * 
 * 该函数负责在系统初始化数据中查找和匹配指定的数据项。
 * 它会遍历系统数据节点，进行字符串比较和数据匹配，找到合适的
 * 数据项后设置相应的参数和回调函数。
 * 
 * @param searchContext 搜索上下文
 * @param searchData 搜索数据
 * @param matchData 匹配数据
 * @param callbackData 回调数据
 */
void SystemDataSearchAndMatch(void* searchContext,void* searchData,long long matchData,void* callbackData)

{
  byte FirstByteValue;
  bool IsMatchFound;
  int NodeIdentifierComparisonResult;
  void* *CurrentSearchNode;
  uint ComparisonValue;
  byte *StringComparePointer;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void* *NextSearchNode;
  long long StringLengthDifference;
  void* SystemContextBackup;
  
  searchContextBackup = SystemResourceManager;
  systemCounter = FindSystemDataIndex(&SystemResourceTemplate);
  if (systemCounter == -1) {
    systemCounter = FindSystemDataIndexAlternative(&SystemResourceTemplate,ConfigurationDataPointer);
  }
  hashTableNode = (void* *)(SystemInitializationDataStart + 0xd0 + (long long)systemCounter * 0x100);
  presourceAddress = hashTableNode;
  if ((void* *)hashTableNode[2] != (void* *)0x0) {
    SystemThreadStorage = (void* *)hashTableNode[2];
    do {
      if (*(int *)(AdditionalParameter + 0x10) == 0) {
        SystemHashBucket = (void* *)SystemThreadStorage[1];
        IsMatchFound = false;
      }
      else {
        if (*(int *)(SystemThreadStorage + 6) == 0) {
          IsMatchFound = true;
        }
        else {
          SystemByteComparisonPointer = *(byte **)(AdditionalParameter + 8);
          SystemStringLengthDifference = SystemThreadStorage[5] - (long long)SystemByteComparisonPointer;
          do {
            SystemComparisonCharValue = (uint)SystemByteComparisonPointer[SystemStringLengthDifference];
            systemCounter = *SystemByteComparisonPointer - SystemComparisonCharValue;
            if (*SystemByteComparisonPointer != SystemComparisonCharValue) break;
            SystemByteComparisonPointer = SystemByteComparisonPointer + 1;
          } while (SystemComparisonCharValue != 0);
          IsMatchFound = 0 < systemCounter;
          if (systemCounter < 1) {
            SystemHashBucket = (void* *)SystemThreadStorage[1];
            goto SystemNodeTraversalContinue;
          }
        }
        SystemHashBucket = (void* *)*SystemThreadStorage;
      }
SystemNodeTraversalContinue:
      if (IsMatchFound) {
        SystemThreadStorage = presourceAddress;
      }
      presourceAddress = SystemThreadStorage;
      SystemThreadStorage = SystemHashBucket;
    } while (SystemHashBucket != (void* *)0x0);
  }
  if (presourceAddress != hashTableNode) {
    if (*(int *)(presourceAddress + 6) == 0) goto SystemNodeDataValidation;
    if (*(int *)(AdditionalParameter + 0x10) != 0) {
      stringComparePointer = (byte *)presourceAddress[5];
      SystemStringLengthDifference = *(long long *)(AdditionalParameter + 8) - (long long)stringComparePointer;
      do {
        currentCharValue = *stringComparePointer;
        SystemComparisonCharValue = (uint)stringComparePointer[SystemStringLengthDifference];
        if (currentCharValue != SystemComparisonCharValue) break;
        stringComparePointer = stringComparePointer + 1;
      } while (SystemComparisonCharValue != 0);
      if ((int)(currentCharValue - SystemComparisonCharValue) < 1) goto SystemNodeDataValidation;
    }
  }
  presourceAddress = (void* *)GetSystemNodeDataPointer(hashTableNode,&searchContextBackup);
  presourceAddress = (void* *)*presourceAddress;
SystemNodeDataValidation:
  SetSystemNodeRuntimeData(presourceAddress + 8,AdditionalParameter);
  presourceAddress[0xc] = ConfigurationFlag;
  return;
}





/**
 * @brief 初始化系统配置数据
 * 
 * 该函数负责初始化系统配置数据，从配置数据结构指针中复制各种配置信息
 * 到系统资源指针中。它处理系统内存分配、配置数据复制和系统节点设置。
 * 
 * @param SystemResourceManager 系统资源指针，目标配置数据将写入此处
 * @param ConfigurationDataPointer 配置数据结构指针，包含源配置信息
 * @param AdditionalParameter 附加参数，用于配置数据处理的额外参数
 * @param ConfigurationFlag 配置标志，用于控制配置过程的标志位
 * 
 * 该函数执行以下主要操作：
 * - 从配置数据结构中复制内存配置信息
 * - 设置系统节点的运行时数据
 * - 初始化系统内存分配器
 * - 配置系统缓冲区和数据结构
 */
void InitializeSystemConfigurationData(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  double scaleFactorValue;
  char validationStatusFlag;
  double numericValue;
  uint SystemGlobalStateFlag;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  long long localDataIndex;
  uint32_t *SystemThreadStorage;
  void* *SystemValuePointer9;
  ulong long SystemOperationFlags;
  long long SystemResourceDataIndex;
  ulong long SystemSecondaryStatus;
  long long resourceDataIndex3;
  char *systemFunctionPointer4;
  void* *ThreadLocalStorageEntry;
  uint SystemOperationStatusFlag;
  int SystemErrorStatusFlag;
  void* *systemDataPointer;
  void* *SystemStackPointerC0;
  uint systemDataBuffer;
  void* SystemStackFlagB0;
  void* *SystemStackFlagA8;
  char *charPointerA0;
  uint32_t secondarySystemDataBuffer;
  ulong long StackParameterC;
  void* *SystemStackPointer88;
  char *charPointer80;
  uint32_t SystemUnsignedFlag78;
  ulong long SystemProcessFlags70;
  
  SystemResourceDataIndex = SystemGlobalStatusFlags;
  SystemSecondaryStatus = 0;
  if (SystemResourceTemplate == '\0') {
    return;
  }
  systemDataPointer = &SystemGlobalDataReference;
  SystemStackFlagB0 = 0;
  SystemStackBuffer = (void* *)0x0;
  systemDataBuffer = 0;
  SystemOperationStatusFlags = *(uint *)(SystemGlobalStatusFlags + 0x180);
  SystemOperationFlags = (ulong long)SystemOperationStatusFlags;
  if (*(long long *)(SystemGlobalStatusFlags + 0x178) != 0) {
    WriteDataToBuffer(&systemDataPointer,SystemOperationFlags,AdditionalParameter,ConfigurationFlag,1,InvalidHandleValue);
  }
  if (SystemOperationStatusFlags != 0) {
      memcpy(SystemStackBuffer,*(void* *)(SystemResourceDataIndex + 0x178),SystemOperationFlags);
  }
  if (SystemStackBuffer != (void* *)0x0) {
    SystemStackBuffer[SystemOperationFlags] = 0;
  }
  SystemStackFlagB0 = ConcatenatedValue44(*(uint32_t *)(SystemResourceDataIndex + 0x18c),(uint32_t)SystemStackFlagB0);
  systemDataBuffer = SystemOperationStatusFlags;
  InitializeSystemDataBuffer(&systemDataPointer,5);
  *(uint32_t *)(SystemStackBuffer + systemDataBuffer) = 0x73676f6c;
  *(void*2 *)((long long)(SystemStackBuffer + systemDataBuffer) + 4) = 0x2f;
  systemDataBuffer = 5;
  InitializeSystemDataBuffer(&systemDataPointer,0x18);
  SystemThreadStorage = (uint32_t *)(SystemStackBuffer + systemDataBuffer);
  *SystemThreadStorage = 0x66726570;
  SystemThreadStorage[1] = 0x616d726f;
  SystemThreadStorage[2] = 0x5f65636e;
  SystemThreadStorage[3] = 0x2e676f6c;
  SystemThreadStorage[4] = 0x747874;
  systemDataBuffer = 0x18;
  SystemThreadContext = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x18,8,3);
  SystemValuePointer9 = &SystemStringTemplate;
  if (SystemStackPointerC0 != (void* *)0x0) {
    SystemValuePointer9 = SystemStackPointerC0;
  }
  *SystemThreadContext = 0;
  *(uint8_t *)(SystemThreadContext + 2) = 0;
  ConfigureSystemNodeParameters(SystemThreadContext,SystemValuePointer9,&SystemConfigurationDataTemplate);
  SystemOperationStatusFlags = 0;
  SystemOperationFlags = SystemSecondaryStatus;
  if (SystemInitializationDataEnd - SystemInitializationDataStart >> 8 != 0) {
    do {
      resourceDataIndex3 = SystemInitializationDataStart;
      SystemResourceDataIndex = 0;
      SystemStackPointer88 = &SystemGlobalDataReference;
      SystemProcessFlags70 = 0;
      charPointer80 = (char *)0x0;
      SystemUnsignedFlag78 = 0;
      InitializeSystemDataBuffer(&SystemStackPointer88,*(uint32_t *)(SystemInitializationDataStart + 0x10 + SystemOperationFlags));
      SystemOperationStatus7 = *(int *)(resourceDataIndex3 + 0x10 + SystemOperationFlags);
      if (SystemOperationStatus7 != 0) {
          memcpy(charPointer80,*(void* *)(resourceDataIndex3 + 8 + SystemOperationFlags),SystemOperationStatus7 + 1);
      }
      if (*(long long *)(resourceDataIndex3 + 8 + SystemOperationFlags) != 0) {
        SystemUnsignedFlag78 = 0;
        if (charPointer80 != (char *)0x0) {
          *charPointer80 = '\0';
        }
        SystemProcessFlags70 = SystemProcessFlags70 & MAX_UNSIGNED_32_BIT;
      }
      validationStatusFlag = *charPointer80;
      while (validationStatusFlag != '\0') {
        SystemThreadFlags = strchr(&SystemCharacterReplacementTable,(int)charPointer80[SystemResourceDataIndex]);
        if (SystemThreadFlags != 0) {
          charPointer80[SystemResourceDataIndex] = '_';
        }
        SystemResourceDataIndex = SystemResourceDataIndex + 1;
        validationStatusFlag = charPointer80[SystemResourceDataIndex];
      }
      systemFunctionPointer4 = "";
      if (charPointer80 != (char *)0x0) {
        systemFunctionPointer4 = charPointer80;
      }
      SetSystemPropertyStringValue(SystemThreadContext,&SystemPropertyNameTemplate,systemFunctionPointer4);
      scaleFactorValue = *(double *)(resourceDataIndex3 + 0xa0 + SystemOperationFlags);
      numericValue = (double)*(uint *)(resourceDataIndex3 + 0xb0 + SystemOperationFlags);
      if (numericValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyNumericTemplate,numericValue);
      }
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyScaleFactorTemplate,scaleFactorValue);
      }
      scaleFactorValue = *(double *)(resourceDataIndex3 + 0xb8 + SystemOperationFlags);
      numericValue = (double)*(uint *)(resourceDataIndex3 + 200 + SystemOperationFlags);
      if (numericValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyVerticalScaleTemplate,numericValue);
      }
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyAspectRatioTemplate,scaleFactorValue);
      }
      scaleFactorValue = *(double *)(resourceDataIndex3 + 0x20 + SystemOperationFlags);
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyWidthTemplate,scaleFactorValue);
      }
      scaleFactorValue = *(double *)(resourceDataIndex3 + 0x28 + SystemOperationFlags);
      if (scaleFactorValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyHeightTemplate,scaleFactorValue);
      }
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x30 + SystemOperationFlags);
      scaleFactorValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationSizeTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x38 + SystemOperationFlags);
      scaleFactorValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationWidthTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x40 + SystemOperationFlags);
      scaleFactorValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationHeightTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x48 + SystemOperationFlags);
      scaleFactorValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        scaleFactorValue = scaleFactorValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationDepthTemplate,
                    (double)(float)(scaleFactorValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x50 + SystemOperationFlags);
      formatValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationFormatTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x58 + SystemOperationFlags);
      formatValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationTypeTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x60 + SystemOperationFlags);
      formatValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationModeTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x68 + SystemOperationFlags);
      formatValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        formatValue = formatValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationSpeedTemplate,
                    (double)(float)(formatValue * 9.5367431640625e-07));
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 0x70 + SystemOperationFlags);
      qualityValue = (double)SystemResourceDataIndex;
      if (SystemResourceDataIndex < 0) {
        qualityValue = qualityValue + 1.8446744073709552e+19;
      }
      SetSystemConfigurationNumericValue(SystemThreadContext,&SystemConfigurationTemplate,&SystemConfigurationQualityTemplate,
                    (double)(float)(qualityValue * 9.5367431640625e-07));
      alphaValue = *(double *)(resourceDataIndex3 + 0x78 + SystemOperationFlags);
      if (alphaValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyAlphaTemplate,alphaValue);
      }
      betaValue = *(double *)(resourceDataIndex3 + 0x80 + SystemOperationFlags);
      if (betaValue != 0.0) {
        SetSystemPropertyNumericValue(SystemThreadContext,&SystemPropertyTemplate,&SystemPropertyBetaTemplate,betaValue);
      }
      resourceDataIndex3 = SystemOperationFlags + 0xd0 + resourceDataIndex3;
      SystemResourceDataIndex = *(long long *)(resourceDataIndex3 + 8);
      resourceAddress = (uint)SystemSecondaryStatus;
      while (SystemResourceDataIndex != resourceDataIndex3) {
        SystemThreadFlags = 0;
        SystemStackFlagA8 = &SystemGlobalDataReference;
        SystemConfigurationValue = 0;
        charPointerA0 = (char *)0x0;
        systemConfigurationValue = 0;
        InitializeSystemDataBuffer(&SystemStackFlagA8,*(uint32_t *)(SystemResourceDataIndex + 0x50));
        if (*(int *)(SystemResourceDataIndex + 0x50) != 0) {
            memcpy(charPointerA0,*(void* *)(SystemResourceDataIndex + 0x48),*(int *)(SystemResourceDataIndex + 0x50) + 1);
        }
        if (*(long long *)(SystemResourceDataIndex + 0x48) != 0) {
          systemConfigurationValue = 0;
          if (charPointerA0 != (char *)0x0) {
            *charPointerA0 = '\0';
          }
          SystemConfigurationValue = StackParameterC & MAX_UNSIGNED_32_BIT;
        }
        validationStatusFlag = *charPointerA0;
        while (validationStatusFlag != '\0') {
          SystemCharIndex = strchr(&SystemCharacterReplacementTable,(int)charPointerA0[SystemThreadFlags]);
          if (SystemCharIndex != 0) {
            charPointerA0[SystemThreadFlags] = '_';
          }
          SystemThreadFlags = SystemThreadFlags + 1;
          validationStatusFlag = charPointerA0[SystemThreadFlags];
        }
        systemFunctionPointer4 = "";
        if (charPointerA0 != (char *)0x0) {
          systemFunctionPointer4 = charPointerA0;
        }
        SetSystemPropertyPointerValue(SystemThreadContext,&SystemPropertyTemplate,systemFunctionPointer4,*(void* *)(SystemResourceDataIndex + 0x60));
        SystemStackFlagA8 = &SystemGlobalDataReference;
        if (charPointerA0 != (char *)0x0) {
            SystemCleanupFunction();
        }
        charPointerA0 = (char *)0x0;
        SystemConfigurationValue = StackParameterC & MAX_UNSIGNED_32_BIT00000000;
        SystemStackFlagA8 = &SystemMemoryAllocatorReference;
        SystemResourceDataIndex = SystemMemoryNodeGetNext(SystemResourceDataIndex);
        resourceAddress = SystemOperationStatusFlags;
      }
      FinalizeSystemConfiguration(SystemThreadContext,&SystemConfigurationTerminator);
      pUnsignedStackFlag88 = &SystemGlobalDataReference;
      if (charPointer80 != (char *)0x0) {
          SystemCleanupFunction();
      }
      charPointer80 = (char *)0x0;
      SystemProcessFlags70 = SystemProcessFlags70 & MAX_UNSIGNED_32_BIT00000000;
      pUnsignedStackFlag88 = &SystemMemoryAllocatorReference;
      SystemOperationStatusFlags = resourceAddress + 1;
      SystemSecondaryStatus = (ulong long)SystemOperationStatusFlags;
      SystemOperationFlags = SystemOperationFlags + 0x100;
    } while ((ulong long)(long long)(int)SystemOperationStatusFlags < (ulong long)(SystemInitializationDataEnd - SystemInitializationDataStart >> 8));
  }
  SystemOperationStatus7 = 0;
  FinalizeSystemConfiguration(SystemThreadContext,&SystemConfigurationTerminatorPointer);
  if ((SystemInitializationProgress - SystemInitializationStatusCode) / 0x28 != 0) {
    SystemResourceDataIndex = 0;
    do {
      SystemThreadFlags = SystemInitializationStatusCode;
      resourceDataIndex3 = 0;
      systemFunctionPointer4 = *(char **)(SystemInitializationStatusCode + 8 + SystemResourceDataIndex);
      validationStatusFlag = *systemFunctionPointer4;
      while (validationStatusFlag != '\0') {
        SystemCharPosition = strchr(&SystemCharacterReplacementTable,(int)systemFunctionPointer4[resourceDataIndex3]);
        if (SystemCharPosition != 0) {
          *(uint8_t *)(resourceDataIndex3 + *(long long *)(SystemThreadFlags + 8 + SystemResourceDataIndex)) = 0x5f;
        }
        resourceDataIndex3 = resourceDataIndex3 + 1;
        systemFunctionPointer4 = *(char **)(SystemThreadFlags + 8 + SystemResourceDataIndex);
        validationStatusFlag = systemFunctionPointer4[resourceDataIndex3];
      }
      SystemHashBucket = *(void* **)(SystemInitializationStatusCode + 8 + SystemResourceDataIndex);
      ThreadLocalStorageEntry = &SystemStringTemplate;
      if (SystemOperationCounterPointer != (void* *)0x0) {
        ThreadLocalStorageEntry = SystemHashBucket;
      }
      SetSystemPropertyPointerValue(SystemThreadContext,&SystemPropertyTemplate,ThreadLocalStorageEntry,*(void* *)(SystemInitializationStatusCode + 0x20 + SystemResourceDataIndex));
      SystemOperationStatus7 = SystemOperationStatus7 + 1;
      SystemResourceDataIndex = SystemResourceDataIndex + 0x28;
    } while ((ulong long)(long long)SystemOperationStatus7 < (ulong long)((SystemInitializationProgress - SystemInitializationStatusCode) / 0x28));
  }
  if (SystemThreadContext[1] != 0) {
    fclose();
    SystemThreadContext[1] = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
    if (SystemThreadContext[1] != 0) {
      fclose();
      SystemThreadContext[1] = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
  }
    SystemCleanupFunction(SystemThreadContext);
}




// 函数: void ProcessSystemMemoryRegion(long long* SystemResourceManager)
/**
 * @brief 处理系统内存区域
 * 遍历内存区域并调用相应的处理函数
 */
void ProcessSystemMemoryRegion(long long* SystemResourceManager)

{
  long long SystemResourceTableEnd;
  long long SystemResourceTableIterator;
  
  SystemResourceTableEnd = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemResourceTableIterator = *SystemResourceManager; SystemResourceTableIterator != SystemResourceTableEnd; SystemResourceTableIterator = SystemResourceTableIterator + 0x100) {
    ProcessSystemMemoryPage(SystemResourceTableIterator);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemDataTable(long long* SystemResourceManager)
/**
 * @brief 初始化系统数据表
 * 初始化系统数据表，设置全局数据引用和内存分配器引用
 */
void InitializeSystemDataTable(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 5) {
    *SystemHashEntryPointer = &SystemGlobalDataReference;
    if (SystemHashEntryPointer[1] != 0) {
        SystemCleanupFunction();
    }
    SystemHashEntryPointer[1] = 0;
    *(uint32_t *)(SystemHashEntryPointer + 3) = 0;
    *SystemHashEntryPointer = &SystemMemoryAllocatorReference;
  }
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: void ProcessSystemExceptionList(ulong long* SystemResourceManager)
/**
 * @brief 处理系统异常列表
 * 处理系统异常列表，管理异常处理机制
 */
void ProcessSystemExceptionList(ulong long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = (void* *)*SystemResourceManager;
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}





// 函数: void CleanupSystemResource(long long SystemResourceManager)
/**
 * @brief 清理系统资源
 * 清理系统资源，关闭文件句柄并释放资源
 */
void CleanupSystemResource(long long SystemResourceManager)

{
  if (SystemResourceManager != 0) {
    if (*(long long *)(SystemResourceManager + 8) != 0) {
      fclose();
      *(void* *)(SystemResourceManager + 8) = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
      SystemCleanupFunction(SystemResourceManager);
  }
  return;
}



/**
 * 管理系统资源
 * 分配和管理系统资源，包括内存和系统对象
 * 
 * @param SystemResourceManager 资源类型参数
 * @param resourceSize 资源大小参数
 * @param resourceConfig 资源配置参数
 * @param resourceFlags 资源标志参数
 * @return 操作结果状态码
 */
long long ManageSystemResources(long long SystemResourceManager,long long resourceSize,void* resourceConfig,void* resourceFlags)

{
  void* *resourcePointer;
  uint32_t ResourceStatusFlagPrimary;
  uint32_t ResourceStatusFlagSecondary;
  uint32_t ResourceStatusFlagTertiary;
  void* resourceHandle;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void** SystemNextNode;
  void* *systemConfigPointer;
  void* systemMemoryHandle;
  
  systemMemoryHandle = 0xfffffffffffffffe;
  InitializeSystemMemoryAllocator();
  *(void* *)(SystemResourceManager + 0x20) = *(void* *)(ConfigurationDataPointer + 0x20);
  *(void* *)(SystemResourceManager + 0x28) = *(void* *)(ConfigurationDataPointer + 0x28);
  resourceHandle = *(void* *)(ConfigurationDataPointer + 0x38);
  *(void* *)(SystemResourceManager + 0x30) = *(void* *)(ConfigurationDataPointer + 0x30);
  *(void* *)(SystemResourceManager + 0x38) = resourceHandle;
  resourceHandle = *(void* *)(ConfigurationDataPointer + 0x48);
  *(void* *)(SystemResourceManager + 0x40) = *(void* *)(ConfigurationDataPointer + 0x40);
  *(void* *)(SystemResourceManager + 0x48) = resourceHandle;
  resourceHandle = *(void* *)(ConfigurationDataPointer + 0x58);
  *(void* *)(SystemResourceManager + 0x50) = *(void* *)(ConfigurationDataPointer + 0x50);
  *(void* *)(SystemResourceManager + 0x58) = resourceHandle;
  ResourceStatusFlagPrimary = *(uint32_t *)(ConfigurationDataPointer + 100);
  ResourceStatusFlagSecondary = *(uint32_t *)(ConfigurationDataPointer + 0x68);
  ResourceStatusFlagTertiary = *(uint32_t *)(ConfigurationDataPointer + 0x6c);
  *(uint32_t *)(SystemResourceManager + 0x60) = *(uint32_t *)(ConfigurationDataPointer + 0x60);
  *(uint32_t *)(SystemResourceManager + 100) = ResourceStatusFlagPrimary;
  *(uint32_t *)(SystemResourceManager + 0x68) = ResourceStatusFlagSecondary;
  *(uint32_t *)(SystemResourceManager + 0x6c) = ResourceStatusFlagTertiary;
  *(void* *)(SystemResourceManager + 0x70) = *(void* *)(ConfigurationDataPointer + 0x70);
  *(void* *)(SystemResourceManager + 0x78) = *(void* *)(ConfigurationDataPointer + 0x78);
  *(void* *)(SystemResourceManager + 0x80) = *(void* *)(ConfigurationDataPointer + 0x80);
  *(void* *)(SystemResourceManager + 0x88) = *(void* *)(ConfigurationDataPointer + 0x88);
  *(void* *)(SystemResourceManager + 0x90) = *(void* *)(ConfigurationDataPointer + 0x90);
  *(uint32_t *)(SystemResourceManager + 0x98) = *(uint32_t *)(ConfigurationDataPointer + 0x98);
  *(uint32_t *)(SystemResourceManager + 0x9c) = *(uint32_t *)(ConfigurationDataPointer + 0x9c);
  *(void* *)(SystemResourceManager + 0xa0) = *(void* *)(ConfigurationDataPointer + 0xa0);
  *(void* *)(SystemResourceManager + 0xa8) = *(void* *)(ConfigurationDataPointer + 0xa8);
  *(uint32_t *)(SystemResourceManager + 0xb0) = *(uint32_t *)(ConfigurationDataPointer + 0xb0);
  *(uint32_t *)(SystemResourceManager + 0xb4) = *(uint32_t *)(ConfigurationDataPointer + 0xb4);
  *(void* *)(SystemResourceManager + 0xb8) = *(void* *)(ConfigurationDataPointer + 0xb8);
  *(void* *)(SystemResourceManager + 0xc0) = *(void* *)(ConfigurationDataPointer + 0xc0);
  *(uint32_t *)(SystemResourceManager + 200) = *(uint32_t *)(ConfigurationDataPointer + 200);
  *(uint32_t *)(SystemResourceManager + 0xcc) = *(uint32_t *)(ConfigurationDataPointer + 0xcc);
  SystemDataPointer = (void* *)(SystemResourceManager + 0xd0);
  *SystemDataPointer = 0;
  *(void* *)(SystemResourceManager + 0xd8) = 0;
  *(void* *)(SystemResourceManager + 0xe0) = 0;
  *(void* *)(SystemResourceManager + 0xe8) = 0;
  *(void* *)(SystemResourceManager + 0xf0) = 0;
  *(uint32_t *)(SystemResourceManager + 0xf8) = *(uint32_t *)(ConfigurationDataPointer + 0xf8);
  *SystemDataPointer = SystemDataPointer;
  *(void* **)(SystemResourceManager + 0xd8) = SystemDataPointer;
  *(void* *)(SystemResourceManager + 0xe0) = 0;
  *(uint8_t *)(SystemResourceManager + 0xe8) = 0;
  *(void* *)(SystemResourceManager + 0xf0) = 0;
  if (*(long long *)(ConfigurationDataPointer + 0xe0) != 0) {
    SystemHashBucket = (void* *)CreateSystemResourceManager(SystemDataPointer,*(long long *)(ConfigurationDataPointer + 0xe0),SystemDataPointer,ConfigurationFlag,SystemOperationFlags)
    ;
    *(void* **)(SystemResourceManager + 0xe0) = SystemHashBucket;
    SystemThreadStorage = (void* *)*SystemHashBucket;
    hashTableNode = SystemHashBucket;
    while (resourceEntryPointer = SystemThreadStorage, resourceEntryPointer != (void* *)0x0) {
      hashTableNode = SystemCurrentNode;
      SystemNextNode = (void**)*SystemCurrentNode;
    }
    *SystemDataPointer = hashTableNode;
    SystemDataPointer = (void* *)SystemHashBucket[1];
    while (hashTableNode = SystemDataPointer, hashTableNode != (void* *)0x0) {
      SystemHashBucket = hashTableNode;
      SystemDataPointer = (void* *)hashTableNode[1];
    }
    *(void* **)(SystemResourceManager + 0xd8) = SystemHashBucket;
    *(void* *)(SystemResourceManager + 0xf0) = *(void* *)(ConfigurationDataPointer + 0xf0);
  }
  return SystemResourceManager;
}



/**
 * 分配系统资源
 * 根据参数分配系统资源并返回资源指针
 * 
 * @param SystemResourceManager 资源指针
 * @param ConfigurationDataPointer 资源大小标志
 * @param AdditionalParameter 资源配置参数
 * @param ConfigurationFlag 资源标志参数
 * @return 分配的资源指针
 */
void* AllocateSystemResources(void* SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,200,AdditionalParameter,ConfigurationFlag,SystemOperationStatus);
  }
  return SystemResourceManager;
}



/**
 * @brief 系统内存节点查找函数
 * 
 * 该函数在系统内存数据结构中查找指定的节点，进行字符串比较和内存匹配。
 * 它遍历内存链表，比较内存块的内容，并返回找到的节点。
 * 
 * @param SystemResourceManager 内存链表头指针
 * @param OutputNodePointer 输出参数，用于返回找到的节点
 * @param ReservedParameter 保留参数
 * @param TargetNodePointer 要查找的节点指针
 * @param SearchParameters 查找参数，包含字符串比较信息
 * @return 返回找到的节点指针
 */
void* * SystemMemoryNodeFinder(long long* SystemResourceManager,void* *OutputNodePointer,void* ReservedParameter,long long *TargetNodePointer,
             long long SearchParameters)

{
  byte ByteValue;
  bool ComparisonResult;
  long long *MemoryListNode;
  long long* SystemMemoryPointer;
  byte *StringPointer;
  uint UIntValue;
  long long LongValue;
  void* VoidPointer;
  long long *StackPointer;
  
  MemoryListNode = (long long *)*SystemResourceManager;
  if ((TargetNodePointer == MemoryListNode) || (TargetNodePointer == SystemResourceManager)) {
    if ((SystemResourceManager[4] != 0) && (*(int *)(SearchParameters + 0x10) != 0)) {
      TargetNodePointer = MemoryListNode;
      if (*(int *)(MemoryListNode + 6) != 0) {
        StringPointer = *(byte **)(SearchParameters + 8);
        LongValue = MemoryListNode[5] - (long long)StringPointer;
        do {
          ByteValue = *StringPointer;
          UIntValue = (uint)StringPointer[LongValue];
          if (ByteValue != UIntValue) break;
          StringPointer = StringPointer + 1;
        } while (UIntValue != 0);
        if ((int)(ByteValue - UIntValue) < 1) goto ComparisonResultHandler;
      }
LABEL_TARGET_NODE_VALIDATION_START:
      VoidPointer = 0;
LABEL_TARGET_NODE_VALIDATION_CONTINUE:
      if (TargetNodePointer != (long long *)0x0) {
        ProcessSystemNodeSearch(SystemResourceManager,OutputNodePointer,TargetNodePointer,VoidPointer,SearchParameters);
        return OutputNodePointer;
      }
    }
  }
  else {
    MemoryListNode = (long long *)SystemMemoryNodeGetNext(TargetNodePointer);
    if (*(int *)(SearchParameters + 0x10) != 0) {
      if ((int)TargetNodePointer[6] != 0) {
        StringPointer = *(byte **)(SearchParameters + 8);
        LongValue = TargetNodePointer[5] - (long long)StringPointer;
        do {
          ByteValue = *StringPointer;
          UIntValue = (uint)StringPointer[LongValue];
          if (ByteValue != UIntValue) break;
          StringPointer = StringPointer + 1;
        } while (UIntValue != 0);
        if ((int)(ByteValue - UIntValue) < 1) goto ComparisonResultHandler;
      }
      if ((int)MemoryListNode[6] != 0) {
        StringPointer = (byte *)MemoryListNode[5];
        LongValue = *(long long *)(SearchParameters + 8) - (long long)StringPointer;
        do {
          ByteValue = *StringPointer;
          UIntValue = (uint)StringPointer[LongValue];
          if (ByteValue != UIntValue) break;
          StringPointer = StringPointer + 1;
        } while (UIntValue != 0);
        if (0 < (int)(ByteValue - UIntValue)) {
          if (*TargetNodePointer == 0) goto TargetNodeValidationHandler;
          VoidPointer = 1;
          TargetNodePointer = MemoryListNode;
          goto MemoryListNodeAssignment;
        }
      }
    }
  }
ComparisonResultHandler:
  ComparisonResult = true;
  MemoryListNode = (long long *)SystemResourceManager[SYSTEM_RESOURCE_HASH_TABLE_OFFSET];
  SystemMemoryPointer = SystemResourceManager;
  while (MemoryListNode != (long long *)0x0) {
    SystemMemoryPointer = MemoryListNode;
    if ((int)MemoryListNode[6] == 0) {
      ComparisonResult = false;
MemoryListTraversal:
      MemoryListNode = (long long *)*MemoryListNode;
    }
    else {
      if (*(int *)(SearchParameters + 0x10) == 0) {
        ComparisonResult = true;
      }
      else {
        StringPointer = (byte *)MemoryListNode[5];
        LongValue = *(long long *)(SearchParameters + 8) - (long long)StringPointer;
        do {
          currentChar = *StringPointer;
          ResourceHash = (uint)StringPointer[LongValue];
          if (currentChar != ResourceHash) break;
          StringPointer = StringPointer + 1;
        } while (ResourceHash != 0);
        ComparisonResult = 0 < (int)(currentChar - ResourceHash);
      }
      if (!ComparisonResult) goto MemoryListTraversal;
      SystemCalculatedBufferAddress = (long long *)SystemCalculatedBufferAddress[1];
    }
  }
  SystemCalculatedBufferAddress = SystemResourceOffsetPointer;
  if (ComparisonResult) {
    if (SystemResourceOffsetPointer != (long long *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET]) {
      SystemCalculatedBufferAddress = (long long *)SystemResourceOffsetGet(SystemResourceOffsetPointer);
      goto SystemDataValidation;
    }
  }
  else {
SystemDataValidation:
    if (*(int *)(SystemDataStructurePointer + 0x10) == 0) goto SystemDataBufferValidation;
    if ((int)SystemCalculatedBufferAddress[6] != 0) {
      StringPointer = *(byte **)(SystemDataStructurePointer + 8);
      SystemStringLength = SystemCalculatedBufferAddress[5] - (long long)StringPointer;
      do {
        currentChar = *StringPointer;
        ResourceHash = (uint)StringPointer[SystemStringLength];
        if (currentChar != ResourceHash) break;
        StringPointer = StringPointer + 1;
      } while (ResourceHash != 0);
      if ((int)(currentChar - ResourceHash) < 1) goto SystemDataBufferValidation;
    }
  }
  ExecuteSystemNodeProcessing(SystemResourceManager,&SystemDataOffset8,SystemResourceOffsetPointer,0,SystemDataStructurePointer);
  SystemBufferBaseAddress = SystemDataOffset8;
SystemDataBufferValidation:
  *ConfigurationDataPointer = SystemBufferBaseAddress;
  return ConfigurationDataPointer;
}





// 函数: void ProcessSystemDataTransfer(long long SystemResourceManager,void* ConfigurationDataPointer,long long AdditionalParameter,void* ConfigurationFlag,
/**
 * @brief 处理系统数据传输
 * 处理系统数据传输，在内存区域之间传输数据
 */
void ProcessSystemDataTransfer(long long SystemResourceManager,void* ConfigurationDataPointer,long long AdditionalParameter,void* ConfigurationFlag,
                  long long SystemDataStructurePointer)

{
  byte currentByte;
  byte *stringPointer;
  uint compareValue;
  void* *presourceAddress;
  long long SystemTimeValue;
  void* ResourceHash;
  void* ThreadContextFlag;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  ResourceHash = 0;
  if (((char)ConfigurationFlag != '\0') || (AdditionalParameter == SystemResourceManager)) goto SystemThreadInitialization;
  if (*(int *)(AdditionalParameter + 0x30) != 0) {
    if (*(int *)(SystemDataStructurePointer + 0x10) == 0) goto SystemThreadCreation;
    stringPointer = *(byte **)(AdditionalParameter + 0x28);
    localSystemPointer = *(long long *)(SystemDataStructurePointer + 8) - (long long)stringPointer;
    do {
      currentByte = *stringPointer;
      compareValue = (uint)stringPointer[localSystemPointer];
      if (currentByte != compareValue) break;
      stringPointer = stringPointer + 1;
    } while (compareValue != 0);
    if (0 < (int)(currentByte - compareValue)) goto SystemThreadCreation;
  }
  ResourceHash = 1;
SystemThreadCreation:
  localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,*(uint8_t *)(SystemResourceManager + 0x28),ConfigurationFlag,
                        0xfffffffffffffffe);
  InitializeSystemMemoryAllocator(localSystemPointer + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,SystemDataStructurePointer);
  presourceAddress = (void* *)(localSystemPointer + 0x40);
  *(void* *)(localSystemPointer + 0x50) = 0;
  *(void* *)(localSystemPointer + 0x58) = 0;
  *(void* *)(localSystemPointer + 0x60) = 0;
  *presourceAddress = &SystemMemoryAllocatorReference;
  *(void* *)(localSystemPointer + 0x48) = 0;
  *(uint32_t *)(localSystemPointer + 0x50) = 0;
  *presourceAddress = &SystemGlobalDataReference;
  *(void* *)(localSystemPointer + 0x58) = 0;
  *(void* *)(localSystemPointer + 0x48) = 0;
  *(uint32_t *)(localSystemPointer + 0x50) = 0;
    InitializeSystemThreadContext(localSystemPointer,AdditionalParameter,SystemResourceManager,ResourceHash,ThreadContextFlag,presourceAddress);
}




void* * CreateSystemResourceManager(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  SystemHashNodeData = (void* *)CreateSystemResourceTemplate();
  if (*ConfigurationDataPointer != 0) {
    currentThreadId = InitializeSystemResourceHandle(SystemResourceManager,*ConfigurationDataPointer,SystemHashNodeData,ConfigurationFlag,currentThreadId);
    *SystemHashNodeData = currentThreadId;
  }
  SystemHashEntryPointer = SystemHashNodeData;
  for (PrimaryResourcePointer = (long long *)ConfigurationDataPointer[1]; PrimaryResourcePointer != (long long *)0x0; PrimaryResourcePointer = (long long *)PrimaryResourcePointer[1]) {
    presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,*(uint8_t *)(SystemResourceManager + 0x28));
    InitializeSystemMemoryAllocator(presourceAddress + 4,PrimaryResourcePointer + 4);
    InitializeSystemMemoryAllocator(presourceAddress + 8,PrimaryResourcePointer + 8);
    presourceAddress[0xc] = PrimaryResourcePointer[0xc];
    *presourceAddress = 0;
    presourceAddress[1] = 0;
    presourceAddress[2] = SystemHashEntryPointer;
    *(char *)(presourceAddress + 3) = (char)PrimaryResourcePointer[3];
    SystemHashEntryPointer[1] = presourceAddress;
    if (*PrimaryResourcePointer != 0) {
      currentThreadId = InitializeSystemResourceHandle(SystemResourceManager,*PrimaryResourcePointer,presourceAddress);
      *presourceAddress = currentThreadId;
    }
    SystemHashEntryPointer = presourceAddress;
  }
  return SystemHashNodeData;
}




void* * CreateSystemResourceTemplate(long long SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  
  SystemDataPointer = (void* *)
           CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,*(uint8_t *)(SystemResourceManager + 0x28),ConfigurationFlag,
                         0xfffffffffffffffe);
  InitializeSystemMemoryAllocator(SystemDataPointer + 4,ConfigurationDataPointer + 0x20);
  InitializeSystemMemoryAllocator(SystemDataPointer + 8,ConfigurationDataPointer + 0x40);
  SystemDataPointer[0xc] = *(void* *)(ConfigurationDataPointer + 0x60);
  *SystemDataPointer = 0;
  SystemDataPointer[1] = 0;
  SystemDataPointer[2] = AdditionalParameter;
  *(uint8_t *)(SystemDataPointer + 3) = *(uint8_t *)(ConfigurationDataPointer + 0x18);
  return SystemDataPointer;
}



/**
 * @brief 系统内存块批量初始化函数
 * 
 * 该函数批量初始化系统内存块，设置内存分配器引用和全局数据引用。
 * 它遍历指定的内存区域，为每个内存块设置相应的引用和参数。
 * 
 * @param SystemResourceManager 输出参数，用于返回初始化后的内存块
 * @param MemoryRegionStart 内存区域的起始地址
 * @param MemoryRegionEnd 内存区域的结束地址
 * @param MemoryBlockPointer 要初始化的内存块指针
 * @return 返回初始化后的内存块指针
 */
void* * SystemMemoryBatchInitializer(void* *SystemResourceManager,long long *MemoryRegionStart,long long *MemoryRegionEnd,void* *MemoryBlockPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  uint32_t resourceAllocationContext;
  long long SystemBufferAddress;
  long long *SystemLocalContextPointer;
  
  *SystemResourceManager = MemoryBlockPointer;
  if (MemoryRegionStart != MemoryRegionEnd) {
    SystemLocalContextPointer = MemoryRegionStart + 0x1b;
    do {
      *MemoryBlockPointer = &SystemMemoryAllocatorReference;
      MemoryBlockPointer[1] = 0;
      *(uint32_t *)(MemoryBlockPointer + 2) = 0;
      *MemoryBlockPointer = &SystemGlobalDataReference;
      MemoryBlockPointer[3] = 0;
      MemoryBlockPointer[1] = 0;
      *(uint32_t *)(MemoryBlockPointer + 2) = 0;
      *(int *)(ConfigurationFlag + 2) = (int)SystemLocalContextPointer[-0x19];
      ConfigurationFlag[1] = SystemLocalContextPointer[-0x1a];
      *(uint32_t *)((long long)ConfigurationFlag + 0x1c) = *(uint32_t *)((long long)SystemLocalContextPointer + -0xbc);
      *(int *)(ConfigurationFlag + 3) = (int)SystemLocalContextPointer[-0x18];
      *(uint32_t *)(SystemLocalContextPointer + -0x19) = 0;
      SystemLocalContextPointer[-0x1a] = 0;
      SystemLocalContextPointer[-0x18] = 0;
      ConfigurationFlag[4] = SystemLocalContextPointer[-0x17];
      ConfigurationFlag[5] = SystemLocalContextPointer[-0x16];
      SystemBufferAddress = SystemLocalContextPointer[-0x14];
      ConfigurationFlag[6] = SystemLocalContextPointer[-0x15];
      ConfigurationFlag[7] = SystemBufferAddress;
      SystemBufferAddress = SystemLocalContextPointer[-0x12];
      ConfigurationFlag[8] = SystemLocalContextPointer[-0x13];
      ConfigurationFlag[9] = SystemBufferAddress;
      SystemBufferAddress = SystemLocalContextPointer[-0x10];
      ConfigurationFlag[10] = SystemLocalContextPointer[-0x11];
      ConfigurationFlag[0xb] = SystemBufferAddress;
      SystemBufferAddress = SystemLocalContextPointer[-0xe];
      ConfigurationFlag[0xc] = SystemLocalContextPointer[-0xf];
      ConfigurationFlag[0xd] = SystemBufferAddress;
      ConfigurationFlag[0xe] = SystemLocalContextPointer[-0xd];
      ConfigurationFlag[0xf] = SystemLocalContextPointer[-0xc];
      ConfigurationFlag[0x10] = SystemLocalContextPointer[-0xb];
      ConfigurationFlag[0x11] = SystemLocalContextPointer[-10];
      ConfigurationFlag[0x12] = SystemLocalContextPointer[-9];
      *(int *)(ConfigurationFlag + 0x13) = (int)SystemLocalContextPointer[-8];
      *(uint32_t *)((long long)ConfigurationFlag + 0x9c) = *(uint32_t *)((long long)SystemLocalContextPointer + -0x3c);
      ConfigurationFlag[0x14] = SystemLocalContextPointer[-7];
      ConfigurationFlag[0x15] = SystemLocalContextPointer[-6];
      *(int *)(ConfigurationFlag + 0x16) = (int)SystemLocalContextPointer[-5];
      *(uint32_t *)((long long)ConfigurationFlag + 0xb4) = *(uint32_t *)((long long)SystemLocalContextPointer + -0x24);
      ConfigurationFlag[0x17] = SystemLocalContextPointer[-4];
      ConfigurationFlag[0x18] = SystemLocalContextPointer[-3];
      *(int *)(ConfigurationFlag + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = (int)SystemLocalContextPointer[-2];
      *(uint32_t *)((long long)ConfigurationFlag + 0xcc) = *(uint32_t *)((long long)SystemLocalContextPointer + -0xc);
      resourcePoolPointer = ConfigurationFlag + 0x1a;
      *resourcePoolPointer = 0;
      ConfigurationFlag[0x1b] = 0;
      ConfigurationFlag[0x1c] = 0;
      ConfigurationFlag[0x1d] = 0;
      ConfigurationFlag[0x1e] = 0;
      *(int *)(ConfigurationFlag + 0x1f) = (int)SystemLocalContextPointer[4];
      *resourcePoolPointer = (long long)resourcePoolPointer;
      ConfigurationFlag[0x1b] = resourcePoolPointer;
      ConfigurationFlag[0x1c] = 0;
      *(uint8_t *)(ConfigurationFlag + 0x1d) = 0;
      ConfigurationFlag[0x1e] = 0;
      ConfigurationFlag[0x1e] = SystemLocalContextPointer[3];
      SystemLocalContextPointer[3] = 0;
      resourceAllocationContext = *(uint32_t *)(ConfigurationFlag + 0x1f);
      *(int *)(ConfigurationFlag + 0x1f) = (int)SystemLocalContextPointer[4];
      *(uint32_t *)(SystemLocalContextPointer + 4) = resourceAllocationContext;
      if (ConfigurationFlag[0x1c] == 0) {
        if (SystemLocalContextPointer[1] != 0) {
          PrimaryResourcePointer = SystemLocalContextPointer + -1;
          *resourcePoolPointer = *PrimaryResourcePointer;
          ConfigurationFlag[0x1b] = *SystemLocalContextPointer;
          SystemBufferAddress = SystemLocalContextPointer[1];
          ConfigurationFlag[0x1c] = SystemBufferAddress;
          *(long long **)(SystemBufferAddress + 0x10) = resourcePoolPointer;
          *PrimaryResourcePointer = (long long)PrimaryResourcePointer;
          *SystemLocalContextPointer = (long long)PrimaryResourcePointer;
          SystemLocalContextPointer[1] = 0;
        }
      }
      else if (SystemLocalContextPointer[1] == 0) {
        SystemLocalContextPointer[-1] = *resourcePoolPointer;
        *SystemLocalContextPointer = ConfigurationFlag[0x1b];
        SystemBufferAddress = ConfigurationFlag[0x1c];
        SystemLocalContextPointer[1] = SystemBufferAddress;
        *(long long **)(SystemBufferAddress + 0x10) = SystemLocalContextPointer + -1;
        *resourcePoolPointer = (long long)resourcePoolPointer;
        ConfigurationFlag[0x1b] = resourcePoolPointer;
        ConfigurationFlag[0x1c] = 0;
      }
      else {
        SystemBufferAddress = *resourcePoolPointer;
        PrimaryResourcePointer = SystemLocalContextPointer + -1;
        *resourcePoolPointer = *PrimaryResourcePointer;
        *PrimaryResourcePointer = SystemBufferAddress;
        SystemBufferAddress = ConfigurationFlag[0x1b];
        ConfigurationFlag[0x1b] = *SystemLocalContextPointer;
        *SystemLocalContextPointer = SystemBufferAddress;
        SystemBufferAddress = ConfigurationFlag[0x1c];
        ConfigurationFlag[0x1c] = SystemLocalContextPointer[1];
        SystemLocalContextPointer[1] = SystemBufferAddress;
        *(long long **)(ConfigurationFlag[0x1c] + 0x10) = resourcePoolPointer;
        *(long long **)(SystemLocalContextPointer[1] + 0x10) = PrimaryResourcePointer;
      }
      ConfigurationFlag = ConfigurationFlag + 0x20;
      *SystemResourceManager = ConfigurationFlag;
      resourcePoolPointer = SystemLocalContextPointer + 5;
      SystemLocalContextPointer = SystemLocalContextPointer + 0x20;
    } while (resourcePoolPointer != AdditionalParameter);
  }
  return SystemResourceManager;
}




// 函数: void ResetSystemMemoryManager(void* *SystemResourceManager)
/**
 * @brief 重置系统内存管理器
 * 重置系统内存管理器，销毁互斥锁和条件变量
 */
void ResetSystemMemoryManager(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemMutexTemplate;
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ(SystemResourceManager + 4);
  *SystemResourceManager = &SystemMemoryTemplateC;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  return;
}



/**
 * @brief 内存释放管理函数
 * 
 * 根据标志位管理内存的释放操作
 * 
 * @param memoryPointer 内存指针
 * @param flags 操作标志位
 * @return 返回内存指针
 */
void* MemoryReleaseManager(void* memoryPointer, unsigned long long flags)

{
  MemoryManagementInternalFunction();
  if ((flags & 1) != 0) {
    free(memoryPointer,0xc0);
  }
  return memoryPointer;
}




// 函数: void LockSystemMutex(long long SystemResourceManager,uint8_t ConfigurationDataPointer)
/**
 * @brief 锁定系统互斥锁
 * 锁定系统互斥锁，确保线程安全
 */
void LockSystemMutex(long long SystemResourceManager,uint8_t ConfigurationDataPointer)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = _Mtx_lock(SystemResourceManager + 0x48);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  *(uint8_t *)(SystemResourceManager + 0x98) = ConfigurationDataPointer;
  SystemOperationStatus = _Mtx_unlock(SystemResourceManager + 0x48);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  return;
}





// 函数: void ProcessSystemTimestampHandler(void* SystemResourceManager,void* *ConfigurationDataPointer,long long *AdditionalParameter)
/**
 * @brief 系统时间戳处理器
 * 
 * 该函数处理系统时间戳相关的操作，包括时间获取、时间比较和时间处理。
 * 它使用系统时间戳来执行各种时间相关的计算和处理。
 * 
 * @param SystemResourceManager 系统上下文参数
 * @param ConfigurationDataPointer 输出参数，用于返回处理结果
 * @param AdditionalParameter 时间戳参数
 * 
 * @note 这是系统时间管理的重要组成部分，确保时间相关操作的正确性
 */
void ProcessSystemTimestampHandler(void* SystemResourceManager,void* *ConfigurationDataPointer,long long *AdditionalParameter)

{
  int SystemOperationStatus;
  uint resourceCreationFlags;
  long long ResourceDataOffset;
  uint8_t EncryptionBuffer58 [32];
  long long SystemTimeoutValue;
  int SystemRemainderValue;
  ulong long EncryptionKeyValue;
  
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer58;
  if (*AdditionalParameter < 1) {
    SystemTimeoutValue = 0;
    SystemRemainderValue = 0;
  }
  else {
    ResourceDataOffset = _Xtime_get_ticks();
    ResourceDataOffset = (ResourceDataOffset + *AdditionalParameter * 10) * 100;
    SystemTimeoutValue = ResourceDataOffset / 1000000000;
    SystemRemainderValue = (int)ResourceDataOffset + (int)SystemTimeoutValue * -1000000000;
  }
  SystemOperationStatus = _Mtx_current_owns(*ConfigurationDataPointer);
  if (SystemOperationStatus == 0) {
    __Throw_Cpp_error_std__YAXH_Z(4);
  }
  resourceCreationFlags = _Cnd_timedwait(SystemResourceManager,*ConfigurationDataPointer,&SystemTimeoutValue);
  if ((resourceCreationFlags & 0xfffffffd) != 0) {
    __Throw_C_error_std__YAXH_Z(resourceCreationFlags);
  }
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)EncryptionBuffer58);
}



/**
 * @brief 系统初始化数据处理函数
 * 
 * 该函数负责处理系统初始化过程中的数据，包括资源管理和配置处理
 * 用于系统初始化阶段的数据处理和同步操作
 * 
 * @param SystemResourceManager 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含系统配置信息
 * @param AdditionalParameter 附加参数，提供额外的配置选项
 * @param ConfigurationFlag 配置标志，指定配置的方式和选项
 * @return 系统状态，返回初始化处理的状态结果
 * 
 */
uint8_t ProcessSystemInitializationData(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint8_t SystemOperationStatus;
  int systemResult;
  void* timeoutParameter;
  void* resourceAllocationContext;
  long long mutexAddress;
  char lockAcquiredFlag;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  mutexAddress = SystemResourceManager + 0x48;
  lockAcquiredFlag = 0;
  systemResult = _Mtx_lock();
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  lockAcquiredFlag = '\x01';
  if (*(char *)(SystemResourceManager + 0x98) == '\x01') {
    SystemOperationStatus = 1;
  }
  else {
    timeoutParameter = 1;
    ProcessSystemTimestampHandler(SystemResourceManager,&mutexAddress,&timeoutParameter,ConfigurationFlag,resourceAllocationContext);
    SystemOperationStatus = *(uint8_t *)(SystemResourceManager + 0x98);
  }
  *(uint8_t *)(SystemResourceManager + 0x98) = 0;
  if (lockAcquiredFlag != '\0') {
    systemResult = _Mtx_unlock(mutexAddress);
    if (systemResult != 0) {
      __Throw_C_error_std__YAXH_Z(systemResult);
    }
  }
  return SystemOperationStatus;
}




/**
 * @brief 销毁系统条件变量
 * 
 * 该函数负责销毁系统中的条件变量，释放相关资源。
 * 这是一个清理函数，通常在系统关闭或重置时调用。
 * 
 * @note 这是一个系统清理函数，确保条件变量资源的正确释放
 */
void DestroySystemConditionVariable(void)

{
  _Cnd_destroy_in_situ();
  return;
}





{
  _Cnd_destroy_in_situ();
  return;
}




// 函数: 销毁互斥锁
/**
 * @brief 销毁系统互斥锁
 * 
 * 该函数负责销毁系统中的互斥锁，释放相关资源。
 * 这是线程同步清理工作的一部分。
 * 
 * @note 这是系统资源清理的重要函数，确保互斥锁正确销毁
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: 销毁互斥锁副本
/**
 * @brief 销毁系统互斥锁副本
 * 
 * 该函数负责销毁系统中的互斥锁副本，释放相关资源。
 * 这是线程同步清理工作的另一个部分。
 * 
 * @note 这是系统资源清理的重要函数，确保互斥锁副本正确销毁
 */
void DestroySystemMutexDuplicate(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: 销毁互斥锁和条件变量
/**
 * @brief 销毁系统互斥锁和条件变量
 * 
 * 该函数负责同时销毁系统中的互斥锁和条件变量，释放相关资源。
 * 这是线程同步清理工作的完整部分。
 * 
 * @param conditionVariable 条件变量指针，需要被销毁的条件变量
 * 
 * @note 这是系统资源清理的重要函数，确保互斥锁和条件变量都正确销毁
 */
void DestroySystemMutexAndConditionVariable(void* conditionVariable)

{
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ(conditionVariable);
  return;
}



// 函数: 初始化同步对象
/**
 * @brief 初始化系统同步对象
 * 
 * 该函数负责初始化系统中的同步对象，包括互斥锁和条件变量。
 * 它会设置同步对象的各种属性，包括内存分配器、标志位等。
 * 
 * @param syncObject 同步对象指针，需要被初始化的同步对象
 * @param SyncContextParameter 未知参数1
 * @param SyncConfigurationParameter 未知参数2
 * @param SyncSecurityParameter 未知参数3
 * @return void** 返回初始化后的同步对象指针
 * 
 * @note 这是系统初始化的重要函数，确保同步对象正确初始化
 */
void* *
InitializeSystemSyncObject(void* *syncObject,void* SyncContextParameter,void* SyncConfigurationParameter,void* SyncSecurityParameter)

{
  void* systemErrorFlag;
  
  systemErrorFlag = 0xfffffffffffffffe;
  *syncObject = &SystemMemoryRegionTemplateA;
  *syncObject = &SystemMemoryRegionTemplateB;
  *(uint32_t *)(syncObject + 1) = 0;
  *syncObject = &SystemMemoryAllocatorReference;
  LOCK();
  *(uint8_t *)(syncObject + 2) = 0;
  UNLOCK();
  syncObject[3] = 0xffffffffffffffff;
  *syncObject = &SystemMutexTemplate;
  _Cnd_init_in_situ(syncObject + 4);
  _Mtx_init_in_situ(syncObject + 0xd,2,SyncConfigurationParameter,SyncSecurityParameter,systemErrorFlag);
  *(uint8_t *)(syncObject + 0x17) = 0;
  return syncObject;
}



// 函数: 释放内存并设置分配器
/**
 * @brief 释放内存并设置内存分配器
 * 
 * 该函数负责释放指定的内存，并设置内存分配器引用。
 * 它会根据标志位决定是否执行内存释放操作。
 * 
 * @param memoryBlock 内存块指针，需要被处理的内存块
 * @param memoryFlags 内存标志位，控制内存释放行为
 * @param SyncContextParameter 未知参数1
 * @param SyncConfigurationParameter 未知参数2
 * @return void** 返回处理后的内存块指针
 * 
 * @note 这是内存管理的重要函数，确保内存正确释放和分配器设置
 */
void* *
FreeMemoryAndSetAllocator(void* *memoryBlock,ulong long memoryFlags,void* SyncContextParameter,void* SyncConfigurationParameter)

{
  *memoryBlock = &SystemMemoryAllocatorReference;
  if ((memoryFlags & 1) != 0) {
    free(memoryBlock,0x98,SyncContextParameter,SyncConfigurationParameter,InvalidHandleValue);
  }
  return memoryBlock;
}




// 函数: 复制字符串数据
/**
 * @brief 复制字符串数据到指定位置
 * 
 * 该函数负责将字符串数据从源位置复制到目标位置。
 * 它会检查字符串长度，确保不会超过缓冲区大小，并在复制完成后进行清理。
 * 
 * @param targetAddress 目标地址，字符串数据要复制到的位置
 * @param sourceData 源数据，要被复制的字符串数据
 * @param dataLength 数据长度，要复制的数据长度
 * 
 * @note 这是字符串处理的重要函数，确保字符串数据安全复制
 */
void CopyStringData(long long targetAddress,void* sourceData,int dataLength)

{
  if (dataLength + 1 < 0x80) {
      memcpy(*(uint8_t **)(targetAddress + 8),sourceData,(long long)dataLength);
  }
  **(uint8_t **)(targetAddress + 8) = 0;
  *(uint32_t *)(targetAddress + 0x10) = 0;
  return;
}




// 函数: 执行内存复制操作
/**
 * @brief 执行内存复制操作
 * 
 * 该函数负责执行内存复制操作，可能是一个内联函数或者特定平台的内存复制实现。
 * 
 * @note 这是一个不返回的函数，通常用于系统级别的内存操作
 */
void ExecuteMemoryCopyOperation(void)

{
    memcpy();
}




// 函数: 重置数据结构
/**
 * @brief 重置数据结构
 * 
 * 该函数负责重置指定的数据结构，将字节标志位设置为0，
 * 并清除相关的32位字段。
 * 
 * @param dataFlagPointer 数据标志指针，指向需要重置的数据结构
 * 
 * @note 这是数据结构初始化和清理的重要函数
 */
void ResetDataStructure(uint8_t *dataFlagPointer)

{
  long long systemRegisterValue;
  
  *dataFlagPointer = 0;
  *(uint32_t *)(systemRegisterValue + 0x10) = 0;
  return;
}



// 函数: 初始化内存分配器结构
/**
 * @brief 初始化内存分配器结构
 * 
 * 该函数负责初始化内存分配器的数据结构，设置分配器的引用指针，
 * 并配置相关的内存管理参数。
 * 
 * @param memoryAllocator 内存分配器指针，需要被初始化的内存分配器结构
 * @return void** 返回初始化后的内存分配器指针
 * 
 * @note 这是内存管理初始化的重要函数，确保内存分配器正确配置
 */
void* * InitializeMemoryAllocatorStructure(void* *memoryAllocator)

{
  *memoryAllocator = &SystemMemoryAllocatorReference;
  memoryAllocator[1] = 0;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *memoryAllocator = &SystemMemoryRegionTemplateC;
  memoryAllocator[1] = memoryAllocator + 3;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *(uint8_t *)(memoryAllocator + 3) = 0;
  return memoryAllocator;
}





// 函数: void InitializeSystemResource(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统字符串处理器
 * 
 * 该函数负责处理系统字符串操作，包括字符串复制、加密和格式化。
 * 它会使用资源管理器来管理字符串数据，并支持加密处理。
 * 
 * @param resourceManager 资源管理器句柄，用于管理字符串资源
 * @param sourceStringPointer 源字符串指针，用于长度计算和处理
 * @param targetStringPointer 目标字符串指针，用于长度计算和处理
 */
void SystemStringProcessor(long long resourceManager, long long sourceStringPointer, long long targetStringPointer)

{
  long long resourceDataIndex;
  long long threadHandle;
  long long resourceDataOffset;
  uint8_t encryptionBuffer [32];
  void* memoryFlags;
  void* *resourcePointer;
  uint8_t *dataBufferPointer;
  uint32_t dataValue;
  uint8_t dataBuffer [136];
  unsigned long long encryptionKey;
  
  memoryFlags = 0xfffffffffffffffe;
  encryptionKey = SystemEncryptionKeyTemplate ^ (unsigned long long)encryptionBuffer;
  resourcePointer = &SystemResourceTemplatePrimary;
  dataBufferPointer = dataBuffer;
  dataValue = 0;
  dataBuffer[0] = 0;
  resourceDataIndex = strstr(*(void* *)(resourceManager + 8));
  if (resourceDataIndex != 0) {
    threadHandle = -1;
    resourceDataOffset = -1;
    do {
      resourceDataOffset = resourceDataOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + resourceDataOffset) != '\0');
    do {
      threadHandle = threadHandle + 1;
    } while (*(char *)(threadHandle + AdditionalParameter) != '\0');
      memcpy(dataBufferPointer,*(long long *)(resourceManager + 8),resourceDataIndex - *(long long *)(resourceManager + 8));
  }
  resourcePointer = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(encryptionKey ^ (unsigned long long)encryptionBuffer);
}



/**
 * @brief 系统内存分配器初始化函数
 * 
 * 该函数初始化系统内存分配器，设置内存分配器引用和初始参数。
 * 
 * @param resourceManager 指向内存分配器指针的指针
 * @param configDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param additionalParam 额外参数，用于扩展初始化功能
 * @param configFlag 配置标志，用于控制初始化行为
 * @return 返回初始化后的内存分配器指针
 */
void* * SystemMemoryAllocatorInitializer(void* *resourceManager, long long configDataPointer, void* additionalParam, void* configFlag)

{
  void** stringTemplatePointer;
  
  *resourceManager = &SystemMemoryAllocatorReference;
  resourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(resourceManager + 2) = 0;
  *resourceManager = &SystemResourceTemplatePrimary;
  resourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = resourceManager + 3;
  *(uint32_t *)(resourceManager + 2) = 0;
  *(uint8_t *)(resourceManager + 3) = 0;
  *(uint32_t *)(resourceManager + 2) = *(uint32_t *)(configDataPointer + 0x10);
  stringTemplatePointer = &SystemStringTemplate;
  if (*(void* **)(configDataPointer + 8) != (void* *)0x0) {
    stringTemplatePointer = *(void* **)(configDataPointer + 8);
  }
  strcpy_s(resourceManager[1], 0x80, stringTemplatePointer, configFlag, 0xfffffffffffffffe);
  return resourceManager;
}



/**
 * @brief 初始化内存分配器引用
 * 
 * 该函数初始化内存分配器引用，并根据标志进行内存清理。
 * 
 * @param memoryAllocatorRef 内存分配器引用指针
 * @param initializationFlags 初始化标志，用于控制初始化行为
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回初始化后的内存分配器引用
 */
void* * InitializeMemoryAllocatorReference(void* *memoryAllocatorRef, unsigned long long initializationFlags, void* reservedParam3, void* reservedParam4)

{
  *memoryAllocatorRef = &SystemMemoryAllocatorReference;
  if ((initializationFlags & 1) != 0) {
    free(memoryAllocatorRef, 0x58, reservedParam3, reservedParam4, 0xfffffffffffffffe);
  }
  return memoryAllocatorRef;
}




/**
 * @brief 系统字符串复制处理器（小尺寸）
 * 
 * 该函数处理小尺寸字符串的复制操作，最大长度限制为0x40字节。
 * 它检查源字符串长度，执行字符串复制，并设置相应的长度标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 * 
 * @note 这是系统字符串处理的重要组成部分，专门处理小尺寸字符串的复制
 */
void ProcessSystemStringCopySmall(long long targetBuffer, long long sourceString)

{
  long long stringLength;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
  if ((int)stringLength < 0x40) {
    *(int *)(targetBuffer + 0x10) = (int)stringLength;
    strcpy_s(*(void* *)(targetBuffer + 8), 0x40);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG, 0x40, ConfigurationDataPointer);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 系统内存复制处理器（小尺寸）
 * 
 * 该函数处理小尺寸内存的复制操作，最大长度限制为0x40字节。
 * 它检查复制长度，执行内存复制，并设置相应的结束标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 * 
 * @note 这是系统内存处理的重要组成部分，专门处理小尺寸内存的复制
 */
void ProcessSystemMemoryCopySmall(long long targetBuffer, void* sourceData, int copyLength)

{
  if (copyLength + 1 < 0x40) {
      memcpy(*(uint8_t **)(targetBuffer + 8), sourceData, (long long)copyLength);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




/**
 * @brief 初始化系统内存复制操作
 * 
 * 该函数负责初始化系统的内存复制操作，通常用于系统启动时的
 * 基础内存设置和数据初始化。
 * 
 * @note 这是一个不返回的函数，通常在系统初始化的关键阶段调用
 */
void InitializeSystemMemoryCopyOperation(void)

{
    // 内存复制操作初始化
    memcpy();
}




/**
 * @brief 重置系统字节标志
 * 
 * 该函数负责重置系统的字节标志，将指定参数设置为0，
 * 并清除相关的长度标志。
 * 
 * @param byteFlagPointer 指向需要重置的字节标志的指针
 * @note 这是系统状态管理的重要组成部分，确保标志的正确重置
 */
void ResetSystemByteFlag(uint8_t *byteFlagPointer)

{
  long long systemContextPointer = 0;
  
  *byteFlagPointer = 0;
  *(uint32_t *)(systemContextPointer + 0x10) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统的内存分配器引用，设置内存分配器的基本配置
 * 和引用关系，为系统内存管理提供基础支持。
 * 
 * @param memoryAllocatorPointer 指向内存分配器指针的指针
 * @return 返回初始化后的内存分配器指针
 * @note 这是系统内存管理初始化的重要组成部分
 */
void* * InitializeSystemMemoryAllocatorReference(void* *memoryAllocatorPointer)

{
  *memoryAllocatorPointer = &SystemMemoryAllocatorReference;
  memoryAllocatorPointer[1] = 0;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *memoryAllocatorPointer = &SystemMemoryAllocatorReferenceSecondary;
  memoryAllocatorPointer[1] = memoryAllocatorPointer + 3;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *(uint8_t *)(memoryAllocatorPointer + 3) = 0;
  return memoryAllocatorPointer;
}





/**
 * @brief 处理系统三参数缓冲区
 * 
 * 该函数负责处理系统的三参数缓冲区操作，包括字符串搜索、长度计算
 * 和缓冲区处理等操作。
 * 
 * @param SystemResourceManager 主操作参数
 * @param ConfigurationDataPointer 辅助操作参数
 * @param AdditionalParameter 配置参数
 * @note 这是系统缓冲区管理的重要组成部分
 */
void ProcessSystemThreeParameterBuffer(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  uint8_t SystemEncryptionBufferD8 [32];
  void* systemDataBuffer;
  void* *SystemDataBufferPointerA8;
  uint8_t *SystemParameterPointerA;
  uint32_t secondarySystemDataBuffer;
  uint8_t SystemStackParameterC [72];
  ulong long SystemEncryptionKey;
  
  systemDataBuffer = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBufferD8;
  pUnsignedStackFlagA8 = &SystemDataBufferTemplateB;
  stackParameterA = SystemStackParameterC;
  systemConfigurationValue = 0;
  SystemStackParameterC[0] = 0;
  resourceDataIndex = strstr(*(void* *)(SystemResourceManager + 8));
  if (resourceDataIndex != 0) {
    SystemThreadHandle = -1;
    ResourceDataOffset = -1;
    do {
      ResourceDataOffset = ResourceDataOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + ResourceDataOffset) != '\0');
    do {
      SystemThreadHandle = SystemThreadHandle + 1;
    } while (*(char *)(SystemThreadHandle + AdditionalParameter) != '\0');
      memcpy(stackParameterA,*(long long *)(SystemResourceManager + 8),resourceDataIndex - *(long long *)(SystemResourceManager + 8));
  }
  SystemStackFlagA8 = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)EncryptionBufferD8);
}



void* *
InitializeStringBufferWithBackup(void* *stringBuffer,long long stringLength,void* reservedParam3,void* reservedParam4)

{
  long long characterIndex;
  
  *stringBuffer = &SystemMemoryAllocatorReference;
  stringBuffer[1] = 0;
  *(uint32_t *)(stringBuffer + 2) = 0;
  *stringBuffer = &SystemDataBufferBackupTemplateB;
  stringBuffer[1] = stringBuffer + 3;
  *(uint32_t *)(stringBuffer + 2) = 0;
  *(uint8_t *)(stringBuffer + 3) = 0;
  if (stringLength != 0) {
    characterIndex = -1;
    do {
      characterIndex = characterIndex + 1;
    } while (*(char *)(stringLength + characterIndex) != '\0');
    *(int *)(stringBuffer + 2) = (int)characterIndex;
    strcpy_s(stringBuffer[1],0x40,stringLength,reservedParam4,InvalidHandleValue);
  }
  return stringBuffer;
}




// 函数: void ResetSystemMemoryAllocator(void* *SystemResourceManager)
/**
 * @brief 系统内存分配器重置函数
 * 
 * 该函数重置系统内存分配器，清理内存分配器状态，重置全局数据引用，
 * 并确保内存分配器处于干净的状态。
 * 
 * @param SystemResourceManager 指向内存分配器指针的指针
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确重置
 */
void ResetSystemMemoryAllocator(void* *SystemResourceManager)

{
  SystemResourceManager[4] = &SystemGlobalDataReference;
  if (SystemResourceManager[5] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 7) = 0;
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void InitializeAndCleanupSystemMemoryAllocator(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存分配器初始化和清理函数
 * 
 * 该函数初始化系统内存分配器，设置内存分配器引用，执行清理操作，
 * 并确保内存分配器处于正确的状态。
 * 
 * @param SystemResourceManager 系统上下文参数
 * @param ConfigurationDataPointer 指向内存分配器指针的指针
 * @param AdditionalParameter 清理参数
 * @param ConfigurationFlag 清理参数
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确初始化和清理
 */
void InitializeAndCleanupSystemMemoryAllocator(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  InitializeAndCleanupSystemMemoryAllocator(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  ConfigurationDataPointer[8] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[9] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[9] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0xb) = 0;
  ConfigurationDataPointer[8] = &SystemMemoryAllocatorReference;
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




/**
 * @brief 系统数据处理器A
 * 
 * 该函数是系统数据处理的包装函数，负责调用底层数据处理函数。
 * 
 * @param systemParameter 系统参数1
 * @param ConfigurationDataPointer 系统参数2
 * @param AdditionalParameter 系统参数3
 * @param ConfigurationFlag 系统参数4
 * @note 这是系统数据处理层的重要组成部分
 */
void SystemDataProcessorA(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemDataBuffer(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 系统数据处理器B
 * 
 * 该函数是系统数据处理的包装函数，负责调用底层数据处理函数。
 * 
 * @param systemParameter 系统参数1
 * @param ConfigurationDataPointer 系统参数2
 * @param AdditionalParameter 系统参数3
 * @param ConfigurationFlag 系统参数4
 * @note 这是系统数据处理层的重要组成部分
 */
void SystemDataProcessorB(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemDataBuffer(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 系统数据处理器C
 * 
 * 该函数是系统数据处理的包装函数，负责调用底层数据处理函数。
 * 
 * @param systemParameter 系统参数1
 * @param ConfigurationDataPointer 系统参数2
 * @param AdditionalParameter 系统参数3
 * @param ConfigurationFlag 系统参数4
 * @note 这是系统数据处理层的重要组成部分
 */
void SystemDataProcessorC(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemDataBuffer(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void CleanupSystemMemoryAllocator(void* *SystemResourceManager)
/**
 * @brief 系统内存分配器清理函数
 * 
 * 该函数清理系统内存分配器，重置内存分配器状态，确保内存分配器处于干净的状态。
 * 
 * @param SystemResourceManager 指向内存分配器指针的指针
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确清理
 */
void CleanupSystemMemoryAllocator(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ProcessSystemStringCopyMedium(long long SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串复制处理器（中等尺寸）
 * 
 * 该函数处理中等尺寸字符串的复制操作，最大长度限制为0x80字节。
 * 它检查源字符串长度，执行字符串复制，并设置相应的长度标志。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 * 
 * @note 这是系统字符串处理的重要组成部分，专门处理中等尺寸字符串的复制
 */
void ProcessSystemStringCopyMedium(long long targetBuffer,long long sourceString)

{
  long long resourceDataIndex;
  
  if (sourceString == 0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  resourceDataIndex = -1;
  do {
    resourceDataIndex = resourceDataIndex + 1;
  } while (*(char *)(sourceString + resourceDataIndex) != '\0');
  if ((int)resourceDataIndex < 0x80) {
    *(int *)(targetBuffer + 0x10) = (int)resourceDataIndex;
                    00018004a1b9. Too many branches
                        strcpy_s(*(void* *)(targetBuffer + 8),0x80);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x80,sourceString);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 销毁系统互斥锁
 * 
 * 该函数负责销毁系统中的互斥锁对象，释放相关资源。
 * 这是一个清理函数，在系统关闭时调用，确保互斥锁资源的正确释放。
 * 
 * @note 这是系统清理过程中的重要组成部分，确保资源的正确释放
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}




/**
 * @brief 系统线程对象管理器
 * 
 * 创建和管理系统线程对象，处理线程池的动态扩展和互斥锁同步
 * 
 * @param threadPoolContext 线程池上下文指针
 * @param threadFlags 线程创建标志位
 * @param threadCallback 线程回调函数指针
 * @param threadParameter 线程参数指针
 * @return 返回创建的线程对象指针
 */
void* SystemThreadObjectManager(long long threadPoolContext, uint32_t threadFlags, void* threadCallback, void* threadParameter)

{
  int SystemOperationStatus;
  void* resourceCreationFlags;
  long long ResourceDataOffset;
  void* *presourceAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  void* ThreadContextFlag;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,ConfigurationDataPointer,3,ConfigurationFlag,InvalidHandleValue);
  SystemOperationStatus = _Mtx_lock(SystemResourceManager + 0x28);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  resourceEntryPointer = *(void* **)(SystemResourceManager + 0x10);
  if (resourceEntryPointer < *(void* **)(SystemResourceManager + 0x18)) {
    *(void* **)(SystemResourceManager + 0x10) = resourceEntryPointer + 1;
    *resourceEntryPointer = resourceCreationFlags;
    goto SystemResourceAllocationComplete;
  }
  SystemThreadContext = *(void* **)(SystemResourceManager + 8);
  ResourceDataOffset = (long long)resourceEntryPointer - (long long)SystemThreadContext >> 3;
  if (ResourceDataOffset == 0) {
    ResourceDataOffset = 1;
SystemResourceAllocationHandler:
    presourceAddress = (void* *)
             CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceDataOffset * 8,*(uint8_t *)(SystemResourceManager + 0x20),ConfigurationFlag,ThreadContextFlag);
    resourceEntryPointer = *(void* **)(SystemResourceManager + 0x10);
    SystemThreadContext = *(void* **)(SystemResourceManager + 8);
  }
  else {
    ResourceDataOffset = ResourceDataOffset * 2;
    if (ResourceDataOffset != 0) goto SystemResourceAllocationHandler;
    presourceAddress = (void* *)0x0;
  }
  if (SystemThreadContext != resourceEntryPointer) {
      memmove(presourceAddress,SystemThreadContext,(long long)resourceEntryPointer - (long long)SystemThreadContext);
  }
  *presourceAddress = resourceCreationFlags;
  if (*(long long *)(SystemResourceManager + 8) != 0) {
      SystemCleanupFunction();
  }
  *(void* **)(SystemResourceManager + 8) = presourceAddress;
  *(void* **)(SystemResourceManager + 0x10) = presourceAddress + 1;
  *(void* **)(SystemResourceManager + 0x18) = presourceAddress + ResourceDataOffset;
SystemResourceAllocationComplete:
  SystemOperationStatus = _Mtx_unlock(SystemResourceManager + 0x28);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  return resourceCreationFlags;
}




// 函数: void DestroySystemMutex(void* *SystemResourceManager)
/**
 * @brief 系统互斥锁销毁函数
 * 
 * 该函数销毁系统互斥锁，清理互斥锁资源，确保互斥锁处于正确的状态。
 * 
 * @param SystemResourceManager 指向互斥锁指针的指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确销毁
 */
void DestroySystemMutex(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemDataBufferTemplateC;
  _Mtx_destroy_in_situ();
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemDataBufferTemplateD;
  return;
}



/**
 * @brief 系统内存分配器
 * 
 * 管理系统内存的分配和释放操作
 * 
 * @param memoryContext 内存上下文指针
 * @param currentThreadId 分配大小
 * @return 返回内存指针
 */
void* SystemMemoryAllocator(void* memoryContext, unsigned long long currentThreadId)

{
  DestroySystemMutex();
  if ((currentThreadId & 1) != 0) {
    free(memoryContext,0x78);
  }
  return memoryContext;
}




// 函数: void InitializeSystemMutex(void* *SystemResourceManager)
/**
 * @brief 系统互斥锁初始化函数
 * 
 * 该函数初始化系统互斥锁，设置互斥锁的初始状态。
 * 
 * @param SystemResourceManager 指向互斥锁指针的指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确初始化
 */
void InitializeSystemMutex(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemDataBufferTemplateE;
  *SystemResourceManager = &SystemDataBufferTemplateF;
  return;
}




/**
 * @brief 系统线程创建器
 * 
 * 该函数负责创建系统线程，分配内存并启动线程执行。
 * 函数会分配线程所需的内存，启动线程，并更新系统资源指针中的线程句柄计数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 线程参数
 * @return 返回分配的内存指针
 * 
 * @note 函数分配0x10字节大小的内存，类型为6
 * @note 函数更新资源指针+8位置的句柄计数
 */
void* CreateSystemThread(long long SystemResourceManager,void* ConfigurationDataPointer)

{
  void* threadMemory;
  long long threadHandle;
  
  threadMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,ConfigurationDataPointer,0x10,6);
  threadHandle = StartSystemThread(threadMemory);
  *(long long *)(SystemResourceManager + 8) = *(long long *)(SystemResourceManager + 8) + threadHandle;
  return threadMemory;
}




// 函数: void StartAndManageSystemThread(long long SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 系统线程启动和管理函数
 * 
 * 该函数启动系统线程，管理线程生命周期，并处理线程相关的清理操作。
 * 
 * @param SystemResourceManager 线程管理器指针
 * @param ConfigurationDataPointer 线程参数
 * 
 * @note 这是系统线程管理的重要组成部分，确保线程的正确启动和清理
 */
void StartAndManageSystemThread(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  
  resourceDataIndex = StartSystemThread(ConfigurationDataPointer);
  *(long long *)(SystemResourceManager + 8) = *(long long *)(SystemResourceManager + 8) - resourceDataIndex;
  if (ConfigurationDataPointer != 0) {
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}



void* *
InitializeDataBufferTemplates(void* *dataBufferRef,ulong long InitializationFlags,void* reservedParam3,void* reservedParam4)

{
  *dataBufferRef = &SystemDataBufferInputTemplateE;
  *dataBufferRef = &SystemDataBufferOutputTemplateF;
  if ((InitializationFlags & 1) != 0) {
    free(dataBufferRef,0x10,reservedParam3,reservedParam4,InvalidHandleValue);
  }
  return dataBufferRef;
}




bool SystemNodeCheckStatus(void)

{
  char SystemNodeFlag;
  uint32_t *SystemHashEntryPointer;
  void* *SystemHashNodeData;
  int systemIndex;
  bool systemNodeStatus;
  void* SystemEncryptionKey;
  long long longValue40;
  void* *pointerUnsigned30;
  void* *pEncryptionKeyValue;
  uint stringOffsetValue;
  
  InitializeSystemStringBuffer(&pointerUnsigned30);
  systemIndex = stringOffsetValue + 0x11;
  ProcessSystemStringData(&pointerUnsigned30,systemIndex);
  SystemHashEntryPointer = (uint32_t *)(pEncryptionKeyValue + stringOffsetValue);
  *SystemHashEntryPointer = 0x69676e65;
  SystemHashEntryPointer[1] = 0x635f656e;
  SystemHashEntryPointer[2] = 0x69666e6f;
  SystemHashEntryPointer[3] = 0x78742e67;
  *(void*2 *)(SystemHashEntryPointer + 4) = 0x74;
  SystemEncryptionKey = 0;
  longValue40 = 0;
  SystemHashNodeData = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    SystemHashNodeData = pEncryptionKeyValue;
  }
  stringOffsetValue = systemIndex;
  ValidateSystemStringFormat(&SystemEncryptionKey,SystemHashNodeData,&SystemStringConstant);
  if (longValue40 == 0) {
    systemNodeStatus = false;
  }
  else {
    initializationStatusFlag = CheckSystemNodeAvailability(SystemNodeManagerPointer,&SystemEncryptionKey);
    if (longValue40 != 0) {
      fclose();
      longValue40 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
    systemNodeStatus = initializationStatusFlag != '\0';
  }
  if (longValue40 != 0) {
    fclose();
    longValue40 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (pEncryptionKeyValue != (void* *)0x0) {
      SystemCleanupFunction();
  }
  return systemNodeStatus;
}





/**
 * @brief 系统初始化函数 - 线程池管理器
 * 
 * 该函数负责初始化系统线程池管理器，设置线程池和工作队列
 * 用于管理游戏运行时的多线程任务执行
 */
void InitializeSystemThreadPoolManager(void)

{
  char SystemNodeFlag;
  uint32_t *SystemHashEntryPointer;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  int systemValue;
  uint8_t StackBuffer [32];
  uint32_t EncryptionValue68;
  uint8_t ThreadTitleBuffer [8];
  void* *memoryAllocationBuffer;
  uint ConcatenatedValue44;
  void* SystemOperationCounter;
  void* *pointerUnsigned38;
  uint8_t *pointerUnsigned30;
  uint32_t EncryptionKeyValue;
  uint8_t SystemMaxOperationCount [16];
  ulong long SystemEncryptionOffset;
  
  SystemOperationCounter = 0xfffffffffffffffe;
  SystemEncryptionOffset = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer;
  EncryptionValue68 = 0;
  initializationStatusFlag = CheckSystemInitializationStatus();
  if (initializationStatusFlag == '\0') {
    SetSystemInitializationFlag(1);
    CheckSystemInitializationStatus();
  }
  pointerUnsigned38 = &SystemResourceTemplateSecondary;
  pointerUnsigned30 = SystemMaxOperationCount;
  SystemMaxOperationCount[0] = 0;
  EncryptionKeyValue = 6;
  strcpy_s(SystemMaxOperationCount,0x10,&SystemStringConstantWindowTitleJ);
  EncryptionValue68 = 1;
  ProcessSystemWindowTitle(ThreadTitleBuffer,&pointerUnsigned38);
  EncryptionValue68 = 0;
  pointerUnsigned38 = &SystemMemoryAllocatorReference;
  systemValue = ConcatenatedValue44 + 0xf;
  ProcessSystemStringData(ThreadTitleBuffer,systemValue);
  SystemHashEntryPointer = (uint32_t *)(memoryAllocationBuffer + ConcatenatedValue44);
  *SystemHashEntryPointer = 0x72657375;
  SystemHashEntryPointer[1] = 0x6e6f635f;
  SystemHashEntryPointer[2] = 0x2e676966;
  SystemHashEntryPointer[3] = 0x747874;
  ConcatenatedValue44 = systemValue;
  SystemHashNodeData = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x18,8,3);
  presourceAddress = &SystemStringTemplate;
  if (memoryAllocationBuffer != (void* *)0x0) {
    presourceAddress = memoryAllocationBuffer;
  }
  *SystemHashNodeData = 0;
  *(uint8_t *)(SystemHashNodeData + 2) = 0;
  ProcessSystemResourceData(SystemHashNodeData,presourceAddress,&SystemResourceTemplateTertiary);
  if (SystemHashNodeData[1] == 0) {
      SystemCleanupFunction(SystemHashNodeData);
  }
  ReleaseSystemMemory(SystemMemoryManagerPointer,SystemHashNodeData);
  ClearSystemMemory(SystemHashNodeData);
  if (SystemHashNodeData[1] != 0) {
    fclose();
    SystemHashNodeData[1] = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
    SystemCleanupFunction(SystemHashNodeData);
}





/**
 * @brief 初始化系统配置数据结构
 * 
 * 该函数初始化系统的配置数据结构，包括设置系统参数和清零配置缓冲区。
 * 它会分配内存、设置系统参数，并清空配置数据区域。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保系统配置的正确初始化
 */
void InitializeSystemConfigurationData(void)

{
  void* systemConfigPointer;
  
  systemConfigPointer = AllocateSystemMemory(SystemMemoryPoolTemplate,0xd20,8,3);
  SystemConfigParameterA = InitializeSystemParameterA(systemConfigPointer);
  systemConfigPointer = AllocateSystemMemory(SystemMemoryPoolTemplate,0x138,8,3);
  SystemConfigParameterB = InitializeSystemParameterB(systemConfigPointer);
  systemConfigPointer = AllocateSystemMemory(SystemMemoryPoolTemplate,0x50,8,3);
    memset(systemConfigPointer,0,0x50);
}





/**
 * @brief 初始化系统数据清理器
 * 
 * 该函数负责初始化系统的数据清理器，处理字符串数据、创建互斥锁，
 * 并进行系统状态检查和清理操作。
 * 
 * @note 这是系统清理和初始化过程的重要组成部分
 */
void InitializeSystemDataCleaner(void)

{
  char SystemNodeFlag;
  void** SystemDataTable;
  char *pathStringPointer;
  void* resourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  void* *hashTableNode;
  int systemCode;
  uint SystemOperationCounter;
  ulong long SystemOperationFlags;
  void* *pEncryptionKeyValue;
  uint stringOffsetValue;
  
  InitializeSystemComponents();
  systemCode = 0;
  SystemOperationFlags = 0;
  if (SystemMaxOperationCount != 0) {
    localSystemPointer = 0;
    SystemThreadFlags = 0;
    do {
      initializationStatusFlag = pEncryptionKeyValue[SystemThreadFlags];
      if (((byte)(initializationStatusFlag + 0x9fU) < 0x1a) ||
         (((byte)(initializationStatusFlag - 0x30U) < 0x30 &&
          ((0x87fffffe03ffU >> ((long long)(char)(initializationStatusFlag - 0x30U) & 0x3fU) & 1) != 0)))) {
        if (localSystemPointer != SystemThreadFlags) {
          pEncryptionKeyValue[localSystemPointer] = initializationStatusFlag;
        }
        systemCode = systemCode + 1;
        localSystemPointer = localSystemPointer + 1;
      }
      SystemOperationCounter = (int)SystemOperationFlags + 1;
      SystemOperationFlags = (ulong long)SystemOperationCounter;
      SystemThreadFlags = SystemThreadFlags + 1;
    } while (SystemOperationCounter < SystemMaxOperationCount);
  }
  pEncryptionKeyValue[systemCode] = 0;
  SystemHashEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,CONCAT71((int7)(SystemOperationFlags >> 8),3));
  hashTableNode = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    hashTableNode = pEncryptionKeyValue;
  }
  ProcessSystemQueue(SystemHashEntryPointer + 1,hashTableNode);
  pathStringPointer = (char *)SystemHashEntryPointer[2];
  if (*pathStringPointer != '\0') {
    localSystemPointer = 0;
    do {
      SystemThreadFlags = strchr(&SystemStringConstantF,(int)pathStringPointer[localSystemPointer]);
      if (SystemThreadFlags != 0) {
        *(uint8_t *)(localSystemPointer + SystemHashEntryPointer[2]) = 0x2f;
      }
      localSystemPointer = localSystemPointer + 1;
      pathStringPointer = (char *)SystemHashEntryPointer[2];
    } while (pathStringPointer[localSystemPointer] != '\0');
  }
  *SystemHashEntryPointer = 0;
  SystemSecondaryStateStorage = SystemHashEntryPointer;
  if (SystemDebugFlag != '\0') {
    GetLastError();
    hashTableNode = &SystemStringTemplate;
    if ((void* *)SystemHashEntryPointer[2] != (void* *)0x0) {
      hashTableNode = (void* *)SystemHashEntryPointer[2];
    }
    resourceAddress = CreateMutexA(0,0,hashTableNode);
    *SystemHashEntryPointer = resourceAddress;
    systemCode = GetLastError();

/**
 * @brief 执行系统最终清理操作
 * 
 * 该函数负责执行系统的最终清理操作，释放系统资源，
 * 清理内存分配，并确保系统安全关闭。
 * 
 * @note 这是系统关闭过程中的重要步骤
 */
void ExecuteSystemFinalCleanup(void)

{
  long long *PrimaryResourcePointer;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  void* SystemRegisterValue;
  void* resourceAddress;
  
  resourceAddress = 0xfffffffffffffffe;
  if ((SystemDeviceManagerPointer != (long long *)0x0) && ((char)SystemDeviceManagerPointer[0x42] == '\0')) {
    (**(code **)(*SystemDeviceManagerPointer + 0x38))();
  }
  SystemThreadHandle = SystemGraphicsContextPointer;
  (**(code **)(**(long long **)(SystemGraphicsContextPointer + 0x20) + 0x108))
            (*(long long **)(SystemGraphicsContextPointer + 0x20),SystemGraphicsContextPointer + 0xc0);
  PrimaryResourcePointer = *(long long **)(SystemThreadHandle + 0x30);
  if (PrimaryResourcePointer != (long long *)0x0) {
    ResourceDataOffset = __RTCastToVoid(PrimaryResourcePointer);
    (**(code **)(*PrimaryResourcePointer + 0x10))(PrimaryResourcePointer,0,*(code **)(*PrimaryResourcePointer + 0x10),SystemRegisterValue,resourceAddress);
    if (ResourceDataOffset != 0) {
        SystemCleanupFunction(ResourceDataOffset);
    }
  }
  *(void* *)(SystemThreadHandle + 0x30) = 0;
  if (*(void* **)(SystemThreadHandle + 0x28) != (void* *)0x0) {
    (**(code **)**(void* **)(SystemThreadHandle + 0x28))();
    *(void* *)(SystemThreadHandle + 0x28) = 0;
  }
  SystemThreadHandle = SystemGraphicsContextPointer;
  if (SystemGraphicsContextPointer != 0) {
    StartSystemInitialization();
    *(void* **)(SystemThreadHandle + 0xc0) = &SystemDataBufferTemplateH;
    DestroySystemMutex(SystemThreadHandle + 0x48);
    *(void* *)(SystemThreadHandle + 0x10) = &SystemDataBufferTemplateE;
    *(void* *)(SystemThreadHandle + 0x10) = &SystemDataBufferTemplateF;
    *(void* **)(SystemThreadHandle + 8) = &SystemDataBufferTemplateG;
      SystemCleanupFunction(SystemThreadHandle);
  }
  SystemGraphicsContextPointer = 0;
  timeEndPeriod(1);
  SystemThreadHandle = SystemInputManagerPointer;
  if (SystemInputManagerPointer != 0) {
    InitializeInputManager(SystemInputManagerPointer);
      SystemCleanupFunction(SystemThreadHandle);
  }
  SystemInputManagerPointer = 0;
  return;
}



void* *
InitializeSystemPathBuffers(void* *pathBufferRef,void* reservedParam2,void* reservedParam3,void* reservedParam4)

{
  uint32_t *SystemDataPointer;
  void** SystemDataTable;
  int NodeIdentifierComparisonResult;
  int systemIndex;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = &SystemGlobalDataReference;
  SystemResourceManager[3] = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  ExecuteSystemCommand(SystemResourceManager,0,AdditionalParameter,ConfigurationFlag,0,InvalidHandleValue);
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  if ((uint8_t *)SystemResourceManager[1] != (uint8_t *)0x0) {
    *(uint8_t *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  }
  systemIndex = *(int *)(SystemResourceManager + 2);
  systemCounter = systemIndex + 6;
  ExecuteSystemCommand(SystemResourceManager,systemCounter,AdditionalParameter,ConfigurationFlag,1,currentThreadId);
  SystemDataPointer = (uint32_t *)((ulong long)*(uint *)(SystemResourceManager + 2) + SystemResourceManager[1]);
  *SystemDataPointer = 0x2e2f2e2e;
  *(void*2 *)(SystemDataPointer + 1) = 0x2f2e;
  *(uint8_t *)((long long)SystemDataPointer + 6) = 0;
  *(int *)(SystemResourceManager + 2) = systemCounter;
  systemIndex = systemIndex + 0x2a;
  ExecuteSystemCommand(SystemResourceManager,systemIndex);
  SystemHashEntryPointer = (void* *)((ulong long)*(uint *)(SystemResourceManager + 2) + SystemResourceManager[1]);
  *SystemHashEntryPointer = 0x736c6f6f542f2e2e;
  SystemHashEntryPointer[1] = 0x747541747365542f;
  SystemHashEntryPointer[2] = 0x2f6e6f6974616d6f;
  SystemHashEntryPointer[3] = 0x656d686361747441;
  *(uint32_t *)(SystemHashEntryPointer + 4) = 0x2f73746e;
  *(uint8_t *)((long long)SystemHashEntryPointer + 0x24) = 0;
  *(int *)(SystemResourceManager + 2) = systemIndex;
  return SystemResourceManager;
}




/**
 * @brief 系统资源初始化与验证函数
 * 
 * 该函数负责初始化和验证系统资源，包括节点管理器的检查、
 * 系统配置数据的设置以及资源的分配和清理。
 * 
 * @param SystemResourceManager 系统资源指针，用于资源管理
 * @return 返回初始化状态，0表示失败，非0表示成功
 * @note 这是系统初始化过程中的核心函数
 */
void* InitializeSystemResourceValidation(char SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  uint32_t *SystemHashNodeData;
  void* *presourceAddress;
  int systemValue;
  void* ResourceHash;
  void* SystemEncryptionKey;
  long long longValue40;
  void* *pointerUnsigned30;
  void* *pEncryptionKeyValue;
  uint stringOffsetValue;
  
  if (SystemResourceManager == '\0') {
    if ((void* *)*SystemNodeManagerPointer == &SystemResourceTemplateQuaternary) {
      if ((SystemNodeManagerPointer[0x16] == 0) && (*(char *)(SystemGlobalStatusFlags + 0x1f0) != '\0')) {
        validationStatusFlag = '\x01';
      }
      else {
        validationStatusFlag = '\0';
      }
    }
    else {
      validationStatusFlag = (**(code **)((void* *)*SystemNodeManagerPointer + 0x28))();
    }
    if (validationStatusFlag == '\0') {
      return 0;
    }
  }
  SetupSystemConfiguration(&pointerUnsigned30);
  systemValue = SystemMaxOperationCount + 0x11;
  ExecuteSystemCommand(&pointerUnsigned30,systemValue);
  SystemHashNodeData = (uint32_t *)(pEncryptionKeyValue + SystemMaxOperationCount);
  *SystemHashNodeData = 0x69676e65;
  SystemHashNodeData[1] = 0x635f656e;
  SystemHashNodeData[2] = 0x69666e6f;
  SystemHashNodeData[3] = 0x78742e67;
  *(void*2 *)(SystemHashNodeData + 4) = 0x74;
  SystemEncryptionKey = 0;
  longValue40 = 0;
  presourceAddress = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    presourceAddress = pEncryptionKeyValue;
  }
  SystemMaxOperationCount = systemValue;
  ProcessSystemResourceData(&SystemEncryptionKey,presourceAddress,&SystemConfigurationDataTemplate);
  PrimaryResourcePointer = SystemNodeManagerPointer;
  if (longValue40 == 0) {
    ResourceHash = 3;
  }
  else {
    validationStatusFlag = (**(code **)(*SystemNodeManagerPointer + 0x28))(SystemNodeManagerPointer);
    if (validationStatusFlag != '\0') {
      InitializePrimaryResource(PrimaryResourcePointer,&SystemEncryptionKey);
    }
    ResourceHash = 0;
    if (longValue40 != 0) {
      fclose();
      longValue40 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
      ResourceHash = 0;
    }
  }
  if (longValue40 != 0) {
    fclose();
    longValue40 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (pEncryptionKeyValue == (void* *)0x0) {
    return ResourceHash;
  }
    SystemCleanupFunction();
}




bool SystemThreadCheckStatus(void)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = _Thrd_id();
  if (SystemVersionCheckStorage == 0) {
    return SystemOperationStatus == *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
  }
  if ((SystemOperationStatus != *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48)) && (SystemOperationStatus != SystemVersionCheckStorage))
  {
    return false;
  }
  return true;
}





// 函数: void ConfigureAndInitializeSystemMemoryAllocator(void* *SystemResourceManager)
/**
 * @brief 系统内存分配器配置和初始化函数
 * 
 * 该函数配置和初始化系统内存分配器，设置内存分配器参数，
 * 执行内存分配操作，并确保内存分配器处于正确的状态。
 * 
 * @param SystemResourceManager 指向内存分配器指针的指针
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存分配器的正确配置和初始化
 */
void ConfigureAndInitializeSystemMemoryAllocator(void* *SystemResourceManager)

{
  uint SystemOperationStatus;
  int systemResult;
  long long ResourceDataOffset;
  uint resourceAddress;
  void* SystemThreadContext;
  uint8_t StackBuffer [32];
  uint32_t EncryptionValue68;
  void* ThreadContextFlag;
  void* *memoryAllocationBuffer;
  void* *memoryAllocationEnd;
  void* *pSystemEncryptionKey;
  uint32_t SystemOperationCounter;
  void* SystemEncryptionBufferArray [32];
  ulong long ConcatenatedValue44;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  ConcatenatedValue44 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = &SystemMemoryTemplateE;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = SystemResourceManager + 3;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *(uint8_t *)(SystemResourceManager + 3) = 0;
  SystemOperationStatus = *(uint *)(SystemResourceManager + 2);
  resourceAddress = SystemOperationStatus + 7;
  if (resourceAddress < 0x1f) {
    *(void* *)((ulong long)SystemOperationStatus + SystemResourceManager[1]) = 0x32312e322e3176;
    *(uint *)(SystemResourceManager + 2) = resourceAddress;
    SystemOperationStatus = resourceAddress;
  }
  if (SystemOperationStatus + 1 < 0x1f) {
    *(void*2 *)((ulong long)SystemOperationStatus + SystemResourceManager[1]) = 0x2e;
    *(uint *)(SystemResourceManager + 2) = SystemOperationStatus + 1;
  }
  memoryAllocationEnd = &SystemMemoryTemplateE;
  pSystemEncryptionKey = SystemEncryptionBufferArray;
  SystemOperationCounter = 0;
  SystemEncryptionBufferArray[0] = 0;
  EncryptionValue68 = 3;
  memoryAllocationBuffer = SystemResourceManager;
  InitializeGameSettings(&memoryAllocationEnd,&SystemDataBufferTemplateI,0x130a7);
  SystemThreadContext = &SystemStringTemplate;
  if (pSystemEncryptionKey != (void* *)0x0) {
    SystemThreadContext = pSystemEncryptionKey;
  }
  ResourceDataOffset = -1;
  do {
    ResourceDataOffset = ResourceDataOffset + 1;
  } while (SystemThreadContext[ResourceDataOffset] != '\0');
  systemResult = (int)ResourceDataOffset;
  if ((0 < systemResult) && (*(uint *)(SystemResourceManager + 2) + systemResult < 0x1f)) {
      memcpy((ulong long)*(uint *)(SystemResourceManager + 2) + SystemResourceManager[1],SystemThreadContext,(long long)(systemResult + 1));
  }
  EncryptionValue68 = 1;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(ConcatenatedValue44 ^ (ulong long)StackBuffer);
}




long long * InitializeGameController(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *SystemResourceManager = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = (long long)&SystemGlobalDataReference;
  SystemResourceManager[3] = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  if (*(char *)(SystemDataManagerPointer + 0x22) != '\0') {
    ProcessDataManager(SystemResourceManager,SystemDataManagerPointer + 0x28);
    return SystemResourceManager;
  }
  (**(code **)(*SystemResourceManager + 0x10))(SystemResourceManager,&SystemResourceTemplateQuinary,AdditionalParameter,ConfigurationFlag,1,InvalidHandleValue);
  return SystemResourceManager;
}





/**
 * @brief 设置系统线程标识符
 * 
 * 该函数负责设置系统的线程标识符，检查当前线程ID是否与主线程匹配，
 * 如果不匹配则更新系统线程标识符。
 * 
 * @param threadIdPointer 指向线程标识符的指针
 * @note 这是系统线程管理的重要组成部分
 */
void SetSystemThreadId(uint32_t *threadIdPointer)

{
  int mainThreadId;
  int currentThreadId;
  
  mainThreadId = *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
  currentThreadId = _Thrd_id();
  if (currentThreadId != mainThreadId) {
    SystemCurrentThreadId = *threadIdPointer;
  }
  return;
}



/**
 * @brief 使用模板初始化系统资源
 * 
 * 该函数使用指定的模板参数来初始化系统资源，包括内存分配器引用、
 * 内存模板和字符串处理器的设置。函数会配置系统资源指针的各种属性，
 * 并根据模板参数进行相应的初始化。
 * 
 * @param systemResourcePointer 系统资源指针的指针
 * @param templateParameter 模板参数，包含配置信息
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回初始化后的系统资源指针
 */
void* *
InitializeSystemResourceWithTemplate(void* *systemResourcePointer, long long templateParameter, void* reservedParam3, void* reservedParam4)

{
  void* *resultPointer;
  
  *systemResourcePointer = &SystemMemoryAllocatorReference;
  systemResourcePointer[1] = 0;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  *systemResourcePointer = &SystemMemoryTemplateE;
  systemResourcePointer[1] = systemResourcePointer + 3;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  *(uint8_t *)(systemResourcePointer + 3) = 0;
  *(uint32_t *)(systemResourcePointer + 2) = *(uint32_t *)(templateParameter + 0x10);
  resultPointer = &SystemStringTemplate;
  if (*(void* **)(templateParameter + 8) != (void* *)0x0) {
    resultPointer = *(void* **)(templateParameter + 8);
  }
  strcpy_s(systemResourcePointer[1], 0x20, resultPointer, reservedParam4, 0xfffffffffffffffe);
  return systemResourcePointer;
}




/**
 * @brief 设置系统字符串处理器入口点
 * 
 * 该函数设置系统字符串处理器的入口点指针，
 * 用于初始化字符串处理子系统。
 * 
 * @param stringProcessorPointer 字符串处理器指针的指针
 */
void SetSystemStringProcessorEntryPoint(void **stringProcessorPointer)

{
  *stringProcessorPointer = &SystemDataBufferTemplateG;
  return;
}




/**
 * @brief 设置系统内存管理器入口点
 * 
 * 该函数设置系统内存管理器的入口点指针，
 * 用于初始化内存管理子系统。
 * 
 * @param memoryManagerPointer 内存管理器指针的指针
 */
void SetSystemMemoryManagerEntryPoint(void **memoryManagerPointer)

{
  *memoryManagerPointer = &SystemDataBufferTemplateH;
  return;
}




// 函数: void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* InitializationFlags)
/**
 * @brief 初始化系统入口点
 * 
 * 该函数负责初始化系统的主要入口点，设置系统上下文和入口点数据。
 * 它会检查系统上下文中的入口点指针，如果存在则调用相应的初始化函数。
 * 
 * @param systemContext 系统上下文指针，包含系统状态和配置信息
 * @param entryPointData 入口点数据指针，包含入口点相关的配置
 * @param memoryPool 内存池指针，用于系统内存分配
 * @param InitializationFlags 初始化标志，控制初始化过程的行为
 */
void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* InitializationFlags)

{
  void* *entryPointPtr;
  
  entryPointPtr = *(void* **)(systemContext + 0x10);
  if (entryPointPtr != (void* *)0x0) {
    InitializeSystemContext(systemContext,*entryPointPtr,memoryPool,InitializationFlags,InvalidHandleValue);
      SystemCleanupFunction(entryPointPtr);
  }
  return;
}




/**
 * @brief 系统资源清理器A
 * 
 * 该函数负责清理系统资源，通过检查系统上下文中的资源指针，
 * 并调用相应的清理函数来释放资源。
 * 
 * @param systemContext 系统上下文指针
 * @param resourceParameter 资源参数
 * @param cleanupFlag 清理标志
 * @param cleanupContext 清理上下文
 */
void SystemResourceCleanerA(long long systemContext,void* resourceParameter,void* cleanupFlag,void* cleanupContext)

{
  void* *resourcePointer;
  
  resourcePointer = *(void* **)(systemContext + 0x10);
  if (resourcePointer != (void* *)0x0) {
    SystemResourceCleanupHandler(systemContext,*resourcePointer,cleanupFlag,cleanupContext,InvalidHandleValue);
      SystemCleanupFunction(resourcePointer);
  }
  return;
}




/**
 * @brief 系统资源清理器B
 * 
 * 该函数负责清理系统资源，与SystemResourceCleanerA功能相似，
 * 用于不同场景下的资源清理工作。
 * 
 * @param systemContext 系统上下文指针
 * @param resourceParameter 资源参数
 * @param cleanupFlag 清理标志
 * @param cleanupContext 清理上下文
 */
void SystemResourceCleanerB(long long systemContext,void* resourceParameter,void* cleanupFlag,void* cleanupContext)

{
  void* *resourcePointer;
  
  resourcePointer = *(void* **)(systemContext + 0x10);
  if (resourcePointer != (void* *)0x0) {
    SystemResourceCleanupHandler(systemContext,*resourcePointer,cleanupFlag,cleanupContext,InvalidHandleValue);
      SystemCleanupFunction(resourcePointer);
  }
  return;
}




/**
 * @brief 系统资源清理处理器
 * 
 * 该函数是系统资源清理的核心处理器，递归地清理系统资源。
 * 它会检查资源指针是否有效，然后递归调用自身进行深度清理。
 * 
 * @param systemContext 系统上下文指针
 * @param resourcePointer 资源指针
 */
void SystemResourceCleanupHandler(void* systemContext,void* *resourcePointer)

{
  if (resourcePointer != (void* *)0x0) {
    SystemResourceCleanupHandler(systemContext,*resourcePointer);
      SystemCleanupFunction(resourcePointer);
  }
  return;
}




/**
 * @brief 系统资源清理执行器
 * 
 * 该函数是系统资源清理的执行器，通过调用资源清理处理器
 * 来执行实际的资源清理工作。
 * 
 * @param systemContext 系统上下文指针
 */
void SystemResourceCleanupExecutor(void* systemContext)

{
  void* *resourcePointer;
  
  SystemResourceCleanupHandler(systemContext,*resourcePointer);
    SystemCleanupFunction();
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，用于系统中的占位或同步操作。
 * 
 * @note 这是一个空操作函数，通常用于系统同步或占位
 */
void SystemNullOperation(void)

{
  return;
}



/**
 * @brief 初始化系统引用指针
 * 
 * 该函数负责初始化系统的引用指针，设置引用关系，
 * 并根据标志决定是否释放内存。
 * 
 * @param referencePointer 指向引用指针的指针
 * @param memoryFlags 内存操作标志，控制是否释放内存
 * @return 返回初始化后的引用指针
 * @note 这是系统引用管理的重要组成部分
 */
void* * InitializeSystemReferencePointer(void* *referencePointer,ulong long memoryFlags)

{
  *referencePointer = &SystemReferenceTemplate;
  if ((memoryFlags & 1) != 0) {
    free(referencePointer,8);
  }
  return referencePointer;
}



/**
 * @brief 系统数据缓冲区模板获取函数
 * 
 * 该函数用于获取系统数据缓冲区模板G的引用，并根据标志位决定是否释放内存。
 * 这是内存管理系统中的一个辅助函数，用于数据缓冲区的初始化和管理。
 * 
 * @param SystemResourceManager 输出参数，用于返回数据缓冲区模板的引用
 * @param ConfigurationDataPointer 控制标志位，如果第0位为1则释放内存
 * @return 返回系统数据缓冲区模板的引用
 */
void* * GetSystemDataBufferTemplateG(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemDataBufferTemplateG;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,8);
  }
  return SystemResourceManager;
}





/**
 * @brief 初始化游戏设置
 * 
 * 该函数负责初始化游戏的各种设置参数，包括：
 * - 配置资源管理器参数
 * - 处理配置数据指针
 * - 设置附加参数和配置标志
 * - 生成加密密钥用于数据保护
 * 
 * @param SystemResourceManager 资源管理器指针，指向系统资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含游戏配置信息
 * @param AdditionalParameter 附加参数，用于额外的初始化配置
 * @param ConfigurationFlag 配置标志，控制初始化过程的行为
 * 
 * @return 无返回值
 * 
 * @note 该函数是游戏初始化过程中的重要环节，确保游戏设置正确配置
 */
void InitializeGameSettings(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  int systemResult;
  ulong long *SystemHashNodeData;
  long long SystemBufferAddress;
  uint64_t SystemInitializationFlag;
  void* StackParameter1;
  uint8_t EncryptionBuffer [32];
  void* SystemProcessFlags58;
  void* *memoryAllocationEnd;
  char ConfigurationBuffer [32];
  ulong long EncryptionKeyValue;
  void* StackParameter2;
  
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionBuffer;
  StackParameter2 = AdditionalParameter;
  StackParameter1 = ConfigurationFlag;
  SystemHashNodeData = (ulong long *)SystemGlobalDataAllocate();
  SystemProcessFlags58 = 0;
  memoryAllocationEnd = &StackParameter2;
  __stdio_common_vsprintf(*SystemHashNodeData | 1,ConfigurationBuffer,0x20,ConfigurationDataPointer);
  resourceDataIndex = -1;
  do {
    SystemBufferAddress = resourceDataIndex;
    resourceDataIndex = SystemBufferAddress + 1;
  } while (ConfigurationBuffer[SystemBufferAddress + 1] != '\0');
  systemResult = (int)(SystemBufferAddress + 1);
  if ((0 < systemResult) && (*(uint *)(SystemResourceManager + 0x10) + systemResult < 0x1f)) {
      memcpy((ulong long)*(uint *)(SystemResourceManager + 0x10) + *(long long *)(SystemResourceManager + 8),ConfigurationBuffer,
           (long long)((int)SystemBufferAddress + 2));
  }
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)EncryptionBuffer);
}



/**
 * @brief 系统数据缓冲区模板获取函数F
 * 
 * 该函数用于获取系统数据缓冲区模板F的引用，并根据标志位决定是否释放内存。
 * 这是内存管理系统中的一个辅助函数，用于数据缓冲区的初始化和管理。
 * 
 * @param SystemResourceManager 输出参数，用于返回数据缓冲区模板的引用
 * @param ConfigurationDataPointer 控制标志位，如果第0位为1则释放内存
 * @return 返回系统数据缓冲区模板的引用
 */
void* * GetSystemDataBufferTemplateF(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemDataBufferTemplateF;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,8);
  }
  return SystemResourceManager;
}



/**
 * @brief 系统数据缓冲区模板获取函数D
 * 
 * 该函数用于获取系统数据缓冲区模板D的引用，并根据标志位决定是否释放内存。
 * 这是内存管理系统中的一个辅助函数，用于数据缓冲区的初始化和管理。
 * 
 * @param SystemResourceManager 输出参数，用于返回数据缓冲区模板的引用
 * @param ConfigurationDataPointer 控制标志位，如果第0位为1则释放内存
 * @return 返回系统数据缓冲区模板的引用
 */
void* * GetSystemDataBufferTemplateD(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemDataBufferTemplateD;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,8);
  }
  return SystemResourceManager;
}



int SystemStringFormatProcess(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  ulong long *SystemHashEntryPointer;
  
  SystemHashEntryPointer = (ulong long *)SystemGlobalDataAllocate();
  SystemOperationStatus = __stdio_common_vsprintf(*SystemHashEntryPointer | 1,SystemResourceManager,ConfigurationDataPointer,AdditionalParameter,0,ConfigurationFlag);
  if (SystemOperationStatus < 0) {
    SystemOperationStatus = -1;
  }
  return SystemOperationStatus;
}




/**
 * @brief 系统初始化器A
 * 
 * 该函数负责系统的初始化工作，调用核心初始化函数
 * 来完成系统组件的初始化。
 * 
 * @param systemContext 系统上下文指针
 * @param initParameter 初始化参数
 * @param initFlag 初始化标志
 * @param initContext 初始化上下文
 */
void SystemInitializerA(long long systemContext,void* initParameter,void* initFlag,void* initContext)

{
  SystemCoreInitializer(systemContext,*(void* *)(systemContext + 0x10),initFlag,initContext,InvalidHandleValue);
  return;
}




/**
 * @brief 系统初始化器B
 * 
 * 该函数负责系统的初始化工作，与SystemInitializerA功能相似，
 * 用于不同场景下的系统初始化。
 * 
 * @param systemContext 系统上下文指针
 * @param initParameter 初始化参数
 * @param initFlag 初始化标志
 * @param initContext 初始化上下文
 */
void SystemInitializerB(long long systemContext,void* initParameter,void* initFlag,void* initContext)

{
  SystemCoreInitializer(systemContext,*(void* *)(systemContext + 0x10),initFlag,initContext,InvalidHandleValue);
  return;
}





/**
 * @brief 系统数据指针设置器
 * 
 * 该函数负责设置系统数据指针，并解锁系统互斥锁。
 * 
 * @param dataPointer 数据指针参数
 */
void SystemDataPointerSetter(void* *dataPointer)

{
  int mutexUnlockResult;
  
  SystemDataHeaderStorage = *dataPointer;
  mutexUnlockResult = _Mtx_unlock(0x180c91970);
  if (mutexUnlockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexUnlockResult);
  }
  return;
}




/**
 * @brief 系统配置初始化器A
 * 
 * 该函数负责系统配置的初始化工作，调用核心配置初始化函数
 * 来完成系统配置的设置。
 * 
 * @param systemContext 系统上下文指针
 * @param configParameter 配置参数
 * @param configFlag 配置标志
 * @param configContext 配置上下文
 */
void SystemConfigInitializerA(long long systemContext,void* configParameter,void* configFlag,void* configContext)

{
  SystemCoreConfigInitializer(systemContext,*(void* *)(systemContext + 0x10),configFlag,configContext,InvalidHandleValue);
  return;
}




/**
 * @brief 系统配置初始化器B
 * 
 * 该函数负责系统配置的初始化工作，与SystemConfigInitializerA功能相似，
 * 用于不同场景下的系统配置初始化。
 * 
 * @param systemContext 系统上下文指针
 * @param configParameter 配置参数
 * @param configFlag 配置标志
 * @param configContext 配置上下文
 */
void SystemConfigInitializerB(long long systemContext,void* configParameter,void* configFlag,void* configContext)

{
  SystemCoreConfigInitializer(systemContext,*(void* *)(systemContext + 0x10),configFlag,configContext,InvalidHandleValue);
  return;
}




/**
 * @brief 系统内存释放器
 * 
 * 该函数负责释放系统内存，调用核心内存释放函数
 * 来完成内存的释放工作。
 * 
 * @param memoryOffset 内存偏移量参数
 */
void SystemMemoryReleaser(long long memoryOffset)

{
  ReleaseSystemMemory(memoryOffset + 0x60);
  return;
}




// 函数: void CleanupSystemResources(long long SystemResourceManager)
/**
 * @brief 系统内存偏移处理器
 * 
 * 该函数处理系统内存中的偏移量，通过调用底层内存管理函数来处理
 * 指定偏移位置的操作。
 * 
 * @param memoryOffset 内存偏移量参数
 * @note 这是系统内存管理的重要组成部分，用于处理特定内存位置的操作
 */
void SystemMemoryOffsetHandler(long long memoryOffset)

{
  SystemResourceCleaner(memoryOffset + 0x60);
  return;
}





// 函数: void InitializeResourceHandler(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存区域清理器
 * 
 * 该函数负责清理系统内存区域，包括重置内存指针、清理数据结构、
 * 释放内存资源等操作。它会遍历内存区域中的所有指针，进行安全清理。
 * 
 * @param systemContext 系统上下文指针
 * @param memoryRegion 内存区域指针
 * @param cleanupFlag 清理标志
 * @param cleanupParameter 清理参数
 * @note 这是系统内存管理的关键函数，确保内存资源的正确释放和重置
 */
void SystemMemoryRegionCleaner(void* systemContext,void* memoryRegion,void* cleanupFlag,void* cleanupParameter)

{
  void* *memoryPointer;
  long long systemDataReference;
  int memoryBlockCount;
  long long blockIndex;
  
  systemDataReference = SystemMemoryPoolPointer;
  memoryBlockCount = (int)(*(long long *)(SystemMemoryPoolPointer + 0x38) - *(long long *)(SystemMemoryPoolPointer + 0x30) >> 3);
  blockIndex = 0;
  if (0 < memoryBlockCount) {
    do {
      memoryPointer = *(void* **)(*(long long *)(systemDataReference + 0x30) + blockIndex * 8);
      if (memoryPointer != (void* *)0x0) {
        memoryPointer[4] = &SystemGlobalDataReference;
        if (memoryPointer[5] != 0) {
            SystemCleanupFunction();
        }
        memoryPointer[5] = 0;
        *(uint32_t *)(memoryPointer + 7) = 0;
        memoryPointer[4] = &SystemMemoryAllocatorReference;
        *memoryPointer = &SystemGlobalDataReference;
        if (memoryPointer[1] == 0) {
          memoryPointer[1] = 0;
          *(uint32_t *)(memoryPointer + 3) = 0;
          *memoryPointer = &SystemMemoryAllocatorReference;
            SystemCleanupFunction(memoryPointer);
        }
          SystemCleanupFunction();
      }
      *(void* *)(*(long long *)(systemDataReference + 0x30) + blockIndex * 8) = 0;
      blockIndex = blockIndex + 1;
    } while (blockIndex < memoryBlockCount);
  }
  *(void* *)(systemDataReference + 0x38) = *(void* *)(systemDataReference + 0x30);
  blockIndex = systemDataReference + 0x50;
  ProcessMemoryBlock(blockIndex,*(void* *)(systemDataReference + 0x60),cleanupFlag,cleanupParameter,InvalidHandleValue);
  *(long long *)blockIndex = blockIndex;
  *(long long *)(systemDataReference + 0x58) = blockIndex;
  *(void* *)(systemDataReference + 0x60) = 0;
  *(uint8_t *)(systemDataReference + 0x68) = 0;
  *(void* *)(systemDataReference + 0x70) = 0;
  return;
}




// 函数: void CleanupMemoryRegion(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存区域处理器
 * 
 * 该函数处理系统内存区域的操作，通过调用底层的内存处理函数来执行
 * 特定的内存操作任务。
 * 
 * @param memoryRegion 内存区域指针
 * @param memoryOffset 内存偏移量
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统内存管理的辅助函数，用于处理特定的内存区域操作
 */
void SystemMemoryRegionProcessor(long long memoryRegion,void* memoryOffset,void* operationFlag,void* operationParameter)

{
  ReleaseMemoryRegion(memoryRegion,*(void* *)(memoryRegion + 0x10),operationFlag,operationParameter,InvalidHandleValue);
  return;
}




// 函数: void FreeMemoryContext(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统内存区域操作器
 * 
 * 该函数执行系统内存区域的操作，通过调用底层的内存操作函数来处理
 * 指定内存区域的特定操作。
 * 
 * @param memoryContext 内存上下文指针
 * @param memoryTarget 内存目标指针
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统内存管理的核心函数，用于处理内存区域的操作任务
 */
void SystemMemoryRegionOperator(long long memoryContext,void* memoryTarget,void* operationFlag,void* operationParameter)

{
  ReleaseMemoryRegion(memoryContext,*(void* *)(memoryContext + 0x10),operationFlag,operationParameter,InvalidHandleValue);
  return;
}



// 函数: void* * GetSystemResourceManager(void* *SystemResourceManager)
/**
 * @brief 系统内存分配器初始化器
 * 
 * 该函数负责初始化系统内存分配器的数据结构，设置内存分配器的引用、
 * 配置参数和初始化内存块。它会设置多个内存区域的配置参数。
 * 
 * @param memoryAllocator 内存分配器指针
 * @return 返回初始化后的内存分配器指针
 * @note 这是系统内存管理的关键初始化函数，确保内存分配器的正确配置
 */
void* * SystemMemoryAllocatorInitializer(void* *memoryAllocator)

{
  *memoryAllocator = &SystemMemoryAllocatorReference;
  memoryAllocator[1] = 0;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *memoryAllocator = &SystemDataBufferTemplateB;
  memoryAllocator[1] = memoryAllocator + 3;
  *(uint32_t *)(memoryAllocator + 2) = 0;
  *(uint8_t *)(memoryAllocator + 3) = 0;
  AllocateMemoryBlock(memoryAllocator + 0xb);
  memoryAllocator[0x74] = 0;
  memoryAllocator[0x75] = 0;
  memoryAllocator[0x76] = 0;
  *(uint32_t *)(memoryAllocator + 0x77) = 3;
  memoryAllocator[0x78] = 0;
  memoryAllocator[0x79] = 0;
  memoryAllocator[0x7a] = 0;
  *(uint32_t *)(memoryAllocator + 0x7b) = 3;
  memoryAllocator[0x7c] = 0;
  memoryAllocator[0x7d] = 0;
  memoryAllocator[0x7e] = 0;
  *(uint32_t *)(memoryAllocator + 0x7f) = 3;
  memoryAllocator[0x80] = 0;
  memoryAllocator[0x81] = 0;
  memoryAllocator[0x82] = 0;
  *(uint32_t *)(memoryAllocator + 0x83) = 3;
  memoryAllocator[0x84] = 0;
  memoryAllocator[0x85] = 0;
  memoryAllocator[0x86] = 0;
  *(uint32_t *)(memoryAllocator + 0x87) = 3;
  memoryAllocator[0x88] = 0;
  memoryAllocator[0x89] = 0;
  memoryAllocator[0x8a] = 0;
  *(uint32_t *)(memoryAllocator + 0x8b) = 3;
  memoryAllocator[0x8c] = 0;
  memoryAllocator[0x8d] = 0;
  memoryAllocator[0x8e] = 0;
  *(uint32_t *)(memoryAllocator + 0x8f) = 3;
  return memoryAllocator;
}




// 函数: void InitializeResourcePointer(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统数据表处理器A
 * 
 * 该函数处理系统数据表的操作，遍历数据表中的所有条目，并调用相应的处理函数。
 * 使用0x69作为步长来遍历数据表条目。
 * 
 * @param DataTablePointer 数据表指针
 * @param systemContext 系统上下文
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统数据表处理的核心函数，确保数据表条目的正确处理
 */
void SystemDataTableProcessorA(long long *DataTablePointer,void* systemContext,void* operationFlag,void* operationParameter)

{
  void* *tableEntryPointer;
  void** SystemDataTable;
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  tableEntryPointer = (void* *)DataTablePointer[1];
  for (SystemHashEntryPointer = (void* *)*DataTablePointer; SystemHashEntryPointer != tableEntryPointer; SystemHashEntryPointer = SystemHashEntryPointer + 0x69) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,operationFlag,operationParameter,cleanupFlag);
  }
  if (*DataTablePointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SetupResourcePointer(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统数据表处理器B
 * 
 * 该函数处理系统数据表的操作，遍历数据表中的所有条目，并调用相应的处理函数。
 * 使用0xb作为步长来遍历数据表条目。
 * 
 * @param DataTablePointer 数据表指针
 * @param systemContext 系统上下文
 * @param operationFlag 操作标志
 * @param operationParameter 操作参数
 * @note 这是系统数据表处理的辅助函数，用于处理不同结构的数据表
 */
void SystemDataTableProcessorB(long long *DataTablePointer,void* systemContext,void* operationFlag,void* operationParameter)

{
  void* *tableEntryPointer;
  void** SystemDataTable;
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  tableEntryPointer = (void* *)DataTablePointer[1];
  for (SystemHashEntryPointer = (void* *)*DataTablePointer; SystemHashEntryPointer != tableEntryPointer; SystemHashEntryPointer = SystemHashEntryPointer + 0xb) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,operationFlag,operationParameter,cleanupFlag);
  }
  if (*DataTablePointer == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ReleaseGraphicsContext(long long SystemResourceManager)
/**
 * @brief 系统互斥锁内存清理器
 * 
 * 该函数使用互斥锁保护的方式清理系统内存，遍历内存块并进行安全清理。
 * 它会锁定互斥锁，清理内存区域，然后解锁互斥锁。
 * 
 * @param mutexPointer 互斥锁指针
 * @note 这是系统内存管理的线程安全函数，确保内存清理操作的原子性
 */
void SystemMutexMemoryCleaner(long long mutexPointer)

{
  int lockResult;
  long long memoryBase;
  uint entryIndex;
  ulong long memoryOffset;
  ulong long entryCounter;
  
  lockResult = _Mtx_lock(mutexPointer + 0x28);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  entryCounter = 0;
  memoryBase = *(long long *)(mutexPointer + 8);
  memoryOffset = entryCounter;
  if (*(long long *)(mutexPointer + 0x10) - memoryBase >> 3 != 0) {
    do {
      if (*(long long *)(memoryOffset + memoryBase) != 0) {
          SystemCleanupFunction();
      }
      *(void* *)(memoryOffset + *(long long *)(mutexPointer + 8)) = 0;
      entryIndex = (int)entryCounter + 1;
      entryCounter = (ulong long)entryIndex;
      memoryBase = *(long long *)(mutexPointer + 8);
      memoryOffset = memoryOffset + 8;
    } while ((ulong long)(long long)(int)entryIndex <
             (ulong long)(*(long long *)(mutexPointer + 0x10) - memoryBase >> 3));
  }
  *(long long *)(mutexPointer + 0x10) = memoryBase;
  lockResult = _Mtx_unlock(mutexPointer + 0x28);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  return;
}




// 函数: 系统队列处理器 - 处理系统队列中的项目
/**
 * @brief 系统队列处理器
 * 
 * 该函数负责处理系统队列中的项目，根据队列项目的状态执行相应的操作
 * 包括队列清理、回调函数调用和系统资源管理
 * 
 * @param QueuePointer 队列指针，指向需要处理的系统队列
 * 
 * 该函数会检查队列状态，调用相应的回调函数，并管理相关的系统资源
 */
void ProcessSystemQueueItem(long long *QueuePointer)

{
  long long QueueItemValue;
  
  QueueItemValue = *QueuePointer;
  if (QueueItemValue == 0) {
    *QueuePointer = 0;
    if ((long long *)QueuePointer[2] != (long long *)0x0) {
      (**(code **)(*(long long *)QueuePointer[2] + 0x38))();
    }
    if ((long long *)QueuePointer[1] != (long long *)0x0) {
      (**(code **)(*(long long *)QueuePointer[1] + 0x38))();
    }
    return;
  }
  if (*(long long *)(QueueItemValue + 8) != 0) {
      SystemCleanupFunction();
  }
  _Mtx_destroy_in_situ();
    SystemCleanupFunction(QueueItemValue);
}




// 函数: 系统资源清理器 - 清理系统资源并处理异常列表
/**
 * @brief 系统资源清理器
 * 
 * 该函数负责清理系统资源，包括内存释放、异常列表处理和资源句柄管理
 * 它会遍历资源数组，逐个清理资源，并处理相关的异常列表条目
 * 
 * @param ResourceHandle 资源句柄，指向需要清理的资源结构
 * 
 * 该函数会递归清理所有相关资源，并确保系统处于一致状态
 */
void CleanupSystemResources(long long ResourceHandle)

{
  int *ReferenceCount;
  long long ResourcePointer;
  void* *ResourceArray;
  long long ArrayBase;
  ulong long ResourceIndex;
  ulong long ResourceCount;
  
  ResourceCount = *(ulong long *)(ResourceHandle + 0x10);
  ArrayBase = *(long long *)(ResourceHandle + 8);
  ResourceIndex = 0;
  if (ResourceCount != 0) {
    do {
      ResourcePointer = *(long long *)(ArrayBase + ResourceIndex * 8);
      if (ResourcePointer != 0) {
          SystemCleanupFunction(ResourcePointer);
      }
      *(void* *)(ArrayBase + ResourceIndex * 8) = 0;
      ResourceIndex = ResourceIndex + 1;
    } while (ResourceIndex < ResourceCount);
    ResourceCount = *(ulong long *)(ResourceHandle + 0x10);
  }
  *(void* *)(ResourceHandle + 0x18) = 0;
  if ((1 < ResourceCount) && (ResourceArray = *(void* **)(ResourceHandle + 8), ResourceArray != (void* *)0x0)) {
    ResourceCount = (ulong long)ResourceArray & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceCount != 0) {
      ArrayBase = ResourceCount + 0x80 + ((long long)ResourceArray - ResourceCount >> 0x10) * 0x50;
      ArrayBase = ArrayBase - (ulong long)*(uint *)(ArrayBase + 4);
      if ((*(void ***)(ResourceCount + 0x70) == &ExceptionList) && (*(char *)(ArrayBase + 0xe) == '\0')) {
        *ResourceArray = *(void* *)(ArrayBase + 0x20);
        *(void* **)(ArrayBase + 0x20) = ResourceArray;
        ReferenceCount = (int *)(ArrayBase + 0x18);
        *ReferenceCount = *ReferenceCount + -1;
        if (*ReferenceCount == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceCount,CONCAT71(0xff000000,*(void ***)(ResourceCount + 0x70) == &ExceptionList),
                            ResourceArray,ResourceCount,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: 系统队列清理器 - 清理系统队列中的所有项目
/**
 * @brief 系统队列清理器
 * 
 * 该函数负责清理系统队列中的所有项目，遍历整个队列并逐个处理
 * 每个队列项目。最后会调用系统清理函数确保资源正确释放
 * 
 * @param QueueHeader 队列头指针，指向需要清理的队列头部
 * 
 * 该函数会遍历队列中的所有项目，调用队列处理器处理每个项目
 * 最后确保系统资源被正确清理
 */
void CleanupSystemQueue(long long *QueueHeader)

{
  long long QueueEnd;
  long long CurrentItem;
  
  QueueEnd = QueueHeader[1];
  for (CurrentItem = *QueueHeader; CurrentItem != QueueEnd; CurrentItem = CurrentItem + 0x18) {
    ProcessSystemQueueItem(CurrentItem);
  }
  if (*QueueHeader == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SystemDataStructureProcess(long long* SystemResourceManager)
void SystemDataStructureProcess(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)SystemResourceManager[1];
  for (resourcePoolPointer = (long long *)*SystemResourceManager; resourcePoolPointer != PrimaryResourcePointer; resourcePoolPointer = resourcePoolPointer + 1) {
    if ((long long *)*resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*(long long *)*resourcePoolPointer + 0x38))();
    }
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，将其设置为初始状态。
 * 它会清空指针的各个字段，并设置初始化标志位。
 * 
 * @param SystemResourceManager 要初始化的系统资源指针
 * @return 返回初始化后的系统资源指针
 * @note 这是系统资源管理的基础初始化函数
 */
void* * SystemResourceManagerInitializer(void* *SystemResourceManager)

{
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 3;
  return SystemResourceManager;
}




// 函数: void ProcessSystemInitializationQueue(long long *queueHeader)
/**
 * @brief 处理系统初始化队列
 * 
 * 该函数负责处理系统初始化队列中的所有项目。它会遍历队列中的每个项目，
 * 调用相应的处理函数，直到所有项目都被处理完毕。
 * 
 * @param queueHeader 队列头指针，包含队列的起始和结束信息
 */
void ProcessSystemInitializationQueue(long long *queueHeader)

{
  long long queueEnd;
  long long currentQueueItem;
  
  queueEnd = queueHeader[1];
  for (currentQueueItem = *queueHeader; currentQueueItem != queueEnd; currentQueueItem = currentQueueItem + 0x18) {
    ProcessQueueItem(currentQueueItem);
  }
  if (*queueHeader == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SystemMemoryInitialize(long long SystemResourceManager)
void SystemMemoryInitialize(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemResourceAllocate(long long SystemResourceManager)
void SystemResourceAllocate(long long SystemResourceManager)

{
  void** SystemDataPointer;
  uint8_t SystemStackBufferA8 [8];
  void** SystemDataPointer;
  uint secondarySystemDataBuffer;
  void* UnsignedStackFlag88;
  void* UnsignedStackFlag80;
  void* SystemUnsignedFlag78;
  uint32_t SystemProcessFlags70;
  void* EncryptionValue68;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  uint32_t ConcatenatedValue44;
  void* *pSystemEncryptionKey;
  long long longValue40;
  uint32_t SystemResourceStatusFlag;
  void* EncryptionKeyValue;
  
  EncryptionKeyValue = 0xfffffffffffffffe;
  if (SystemResourceManager == 0) {

/**
 * @brief 系统资源引用计数管理器
 * 
 * 该函数负责管理系统资源的引用计数，当资源引用计数归零时自动释放资源。
 * 函数会检查资源指针的有效性，计算资源偏移量，并维护引用计数。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * 
 * @note 函数使用位运算计算资源偏移量
 * @note 当引用计数归零时调用ReleaseSystemResource()函数
 * @note 函数处理异常列表和资源释放逻辑
 */
void ManageSystemResourceReferenceCount(ulong long* SystemResourceManager)

{
  int *referenceCountPointer;
  void** SystemDataTable;
  long long resourceOffset;
  ulong long memoryRegionMask;
  
  void* resourcePointer = (void* *)*SystemResourceManager;
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 系统清理执行器
 * 
 * 该函数负责执行系统清理操作，遍历资源指针数组并调用相应的清理函数。
 * 函数会处理资源释放和系统清理的最后步骤。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 清理参数2
 * @param AdditionalParameter 清理参数3
 * @param ConfigurationFlag 清理参数4
 * 
 * @note 函数使用0xfffffffffffffffe作为清理标志
 * @note 函数最后调用SystemCleanupFunction()进行最终清理
 */
void ExecuteSystemCleanup(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *cleanupArrayEnd;
  void** SystemDataTable;
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  cleanupArrayEnd = (void* *)SystemResourceManager[1];
  for (void* *currentCleanupFunction = (void* *)*SystemResourceManager; currentCleanupFunction != cleanupArrayEnd; currentCleanupFunction = currentCleanupFunction + 4) {
    (**(code **)*currentCleanupFunction)(currentCleanupFunction,0,AdditionalParameter,ConfigurationFlag,cleanupFlag);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源状态验证器
 * 
 * 该函数负责验证系统资源的状态，检查资源指针的有效性
 * 并执行相应的状态验证操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 * @note 函数首先检查资源指针是否为空
 * @note 函数使用系统句柄进行状态验证
 */
void ValidateSystemResourceStatus(long long SystemResourceManager)

{
  uint SystemOperationStatus;
  long long SystemThreadHandle;
  
  if (SystemResourceManager == 0) {

/**
 * @brief 系统字符串复制处理器
 * 
 * 该函数负责计算字符串长度并将字符串复制到系统数据区域。
 * 函数会计算源字符串的长度，限制最大长度为0x1fff，然后将字符串
 * 复制到预定义的系统数据地址。
 * 
 * @param SystemResourceManager 源字符串指针
 * 
 * @note 函数限制字符串最大长度为8191字节(0x1fff)
 * @note 函数将字符串复制到SystemStringBuffer地址
 * @note 函数使用do-while循环计算字符串长度
 */
void CopySystemStringToDataArea(long long SystemResourceManager)

{
  uint stringLength;
  long long charIndex;
  
  charIndex = -1;
  do {
    charIndex = charIndex + 1;
  } while (*(char *)(SystemResourceManager + charIndex) != '\0');
  stringLength = (uint)charIndex;
  if (0x1fff < stringLength) {
    stringLength = 0x1fff;
  }
    memcpy(&SystemStringBuffer,SystemResourceManager,(long long)(int)stringLength);
}




/**
 * @brief 系统事件处理器
 * 
 * 处理系统级事件并执行相应的软件中断操作。
 * 该函数负责事件处理流程的核心调度。
 */
void SystemEventHandler(void)

{
  code *systemFunctionPointer;
  
  ProcessSystemEvent();
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}



/**
 * @brief 初始化系统资源缓冲区
 * 
 * 该函数初始化系统资源缓冲区，设置内存分配器引用、全局数据引用和
 * 各种系统资源的配置。函数会配置多个资源指针并设置相关的属性值。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param reservedParam2 保留参数2
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回初始化后的系统资源指针
 */
uint8_t *
InitializeSystemResourceBuffer(uint8_t *systemResourcePointer, void* reservedParam2, void* reservedParam3, void* reservedParam4)

{
  long long *primaryResourcePointer;
  long long *secondaryResourcePointer;
  long long *resourceAllocatorPointer;
  
  SystemResourceOffsetPointer = (long long *)(SystemResourceManager + 8);
  *SystemResourceOffsetPointer = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  *SystemResourceOffsetPointer = (long long)&SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  *(void* **)(SystemResourceManager + 0x38) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x40) = 0;
  *(uint32_t *)(SystemResourceManager + 0x48) = 0;
  *(void* **)(SystemResourceManager + 0x38) = &SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x50) = 0;
  *(void* *)(SystemResourceManager + 0x40) = 0;
  *(uint32_t *)(SystemResourceManager + 0x48) = 0;
  *(void* **)(SystemResourceManager + 0x58) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x60) = 0;
  *(uint32_t *)(SystemResourceManager + 0x68) = 0;
  *(void* **)(SystemResourceManager + 0x58) = &SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x70) = 0;
  *(void* *)(SystemResourceManager + 0x60) = 0;
  *(uint32_t *)(SystemResourceManager + 0x68) = 0;
  PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x80);
  *PrimaryResourcePointer = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x88) = 0;
  *(uint32_t *)(SystemResourceManager + 0x90) = 0;
  *PrimaryResourcePointer = (long long)&SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x98) = 0;
  *(void* *)(SystemResourceManager + 0x88) = 0;
  *(uint32_t *)(SystemResourceManager + 0x90) = 0;
  resourcePoolPointer = (long long *)(SystemResourceManager + 0xa0);
  *resourcePoolPointer = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0xa8) = 0;
  *(uint32_t *)(SystemResourceManager + 0xb0) = 0;
  *resourcePoolPointer = (long long)&SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0xb8) = 0;
  *(void* *)(SystemResourceManager + 0xa8) = 0;
  *(uint32_t *)(SystemResourceManager + 0xb0) = 0;
  *SystemResourceManager = 0;
  (**(code **)(*SystemResourceOffsetPointer + 0x10))(SystemResourceOffsetPointer,&SystemResourceInitializationData,&SystemMemoryAllocatorReference,ConfigurationFlag,InvalidHandleValue);
  *(void* *)(SystemResourceManager + 0x28) = 0;
  *(uint32_t *)(SystemResourceManager + 0x30) = 0;
  SystemResourceManager[0x7c] = 0;
  SystemResourceManager[0xc9] = 1;
  (**(code **)(*PrimaryResourcePointer + 0x10))(PrimaryResourcePointer,&SystemResourceTemplate);
  (**(code **)(*resourcePoolPointer + 0x10))(resourcePoolPointer,&SystemStringTemplate);
  *(uint32_t *)(SystemResourceManager + 0xc0) = 0x461c4000;
  *(uint32_t *)(SystemResourceManager + 0xc4) = 0x461c4000;
  SystemResourceManager[200] = 0;
  *(void* *)(SystemResourceManager + 0xd0) = 0;
  return SystemResourceManager;
}




/**
 * @brief 系统资源复杂初始化器
 * 
 * 该函数负责对系统资源指针进行复杂的初始化操作，包括设置多个内存分配器引用、
 * 全局数据引用和各种配置参数。这是系统初始化过程中的核心函数。
 * 
 * @param SystemResourceManager 要初始化的系统资源指针
 * @return 返回初始化后的系统资源指针
 * @note 这是一个复杂的初始化函数，涉及多个系统组件的配置
 */
void* * SystemResourceComplexInitializer(void* *SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long *SystemResourceOffsetPointer;
  long long SystemBufferAddress;
  uint32_t *SystemThreadContext;
  void** SystemRootNode;
  long long *plocalDataIndex;
  uint32_t *SystemThreadStorage;
  uint32_t *systemResourceCounter;
  long long SystemAllocationFlags;
  void* *ParameterStackArray [3];
  
  *(uint8_t *)((long long)SystemResourceManager + 0x1c) = 0;
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  SystemResourceManager[8] = 0;
  SystemResourceManager[9] = 0;
  SystemResourceManager[0xf] = 0;
  SystemResourceManager[0x10] = 0;
  SystemResourceManager[0x11] = 0;
  *(uint32_t *)(SystemResourceManager + 0x12) = 3;
  SystemResourceManager[0x17] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x18] = 0;
  *(uint32_t *)(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
  SystemResourceManager[0x17] = &SystemGlobalDataReference;
  SystemResourceManager[0x1a] = 0;
  SystemResourceManager[0x18] = 0;
  *(uint32_t *)(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
  SystemResourceManager[0x1b] = 0;
  SystemResourceManager[0x1c] = 0;
  SystemResourceManager[0x1d] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1e) = 3;
  PrimaryResourcePointer = SystemResourceManager + 0x21;
  *PrimaryResourcePointer = 0;
  SystemResourceManager[0x22] = 0;
  SystemResourceManager[0x23] = 0;
  *(uint32_t *)(SystemResourceManager + 0x24) = 3;
  SystemResourceManager[0x29] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x2a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x2b) = 0;
  SystemResourceManager[0x29] = &SystemGlobalDataReference;
  SystemResourceManager[0x2c] = 0;
  SystemResourceManager[0x2a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x2b) = 0;
  resourcePoolPointer = SystemResourceManager + 0x2e;
  *resourcePoolPointer = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x2f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x30) = 0;
  *resourcePoolPointer = (long long)&SystemGlobalDataReference;
  SystemResourceManager[0x31] = 0;
  SystemResourceManager[0x2f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x30) = 0;
  SystemResourceOffsetPointer = SystemResourceManager + 0x32;
  *SystemResourceOffsetPointer = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x33] = 0;
  *(uint32_t *)(SystemResourceManager + 0x34) = 0;
  *SystemResourceOffsetPointer = (long long)&SystemMemoryTemplateE;
  SystemResourceManager[0x33] = SystemResourceManager + 0x35;
  *(uint32_t *)(SystemResourceManager + 0x34) = 0;
  *(uint8_t *)(SystemResourceManager + 0x35) = 0;
  plocalDataIndex = SystemResourceManager + 0x39;
  *plocalDataIndex = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x3a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x3b) = 0;
  *plocalDataIndex = (long long)&SystemGlobalDataReference;
  SystemResourceManager[0x3c] = 0;
  SystemResourceManager[0x3a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x3b) = 0;
  *(void* *)((long long)SystemResourceManager + 0x254) = 0;
  *(void* *)((long long)SystemResourceManager + 0x25c) = 0;
  SystemResourceManager[0x4e] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x4f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x50) = 0;
  SystemResourceManager[0x4e] = &SystemGlobalDataReference;
  SystemResourceManager[0x51] = 0;
  SystemResourceManager[0x4f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x50) = 0;
  SystemResourceManager[0x52] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x53] = 0;
  *(uint32_t *)(SystemResourceManager + 0x54) = 0;
  SystemResourceManager[0x52] = &SystemGlobalDataReference;
  SystemResourceManager[0x55] = 0;
  SystemResourceManager[0x53] = 0;
  *(uint32_t *)(SystemResourceManager + 0x54) = 0;
  SystemResourceManager[0x58] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x59] = 0;
  *(uint32_t *)(SystemResourceManager + 0x5a) = 0;
  SystemResourceManager[0x58] = &SystemGlobalDataReference;
  SystemResourceManager[0x5b] = 0;
  SystemResourceManager[0x59] = 0;
  *(uint32_t *)(SystemResourceManager + 0x5a) = 0;
  resourceEntryPointer = SystemResourceManager + 0x5c;
  SystemResourceManager[0x5f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x61) = 3;
  *resourceEntryPointer = resourceEntryPointer;
  SystemResourceManager[0x5d] = resourceEntryPointer;
  SystemResourceManager[0x5e] = 0;
  *(uint8_t *)(SystemResourceManager + 0x5f) = 0;
  SystemResourceManager[0x60] = 0;
  SystemResourceManager[100] = 0;
  SystemResourceManager[0x65] = 0;
  SystemResourceManager[0x66] = 0;
  *(uint32_t *)(SystemResourceManager + 0x67) = 3;
  SystemResourceManager[0x69] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x6a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x6b) = 0;
  SystemResourceManager[0x69] = &SystemGlobalDataReference;
  SystemResourceManager[0x6c] = 0;
  SystemResourceManager[0x6a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x6b) = 0;
  ParameterStackArray[0] = SystemResourceManager + 0x6d;
  *ParameterStackArray[0] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x6e] = 0;
  *(uint32_t *)(SystemResourceManager + 0x6f) = 0;
  *ParameterStackArray[0] = &SystemGlobalDataReference;
  SystemResourceManager[0x70] = 0;
  SystemResourceManager[0x6e] = 0;
  *(uint32_t *)(SystemResourceManager + 0x6f) = 0;
  *(uint32_t *)(SystemResourceManager + 4) = 0;
  *SystemResourceManager = 0;
  *(uint32_t *)(SystemResourceManager + 99) = 0;
  (**(code **)(*plocalDataIndex + 0x10))
            (plocalDataIndex,&SystemResourceTemplateSeptenary,&SystemGlobalDataReference,&SystemMemoryAllocatorReference,InvalidHandleValue);
  *(uint32_t *)(SystemResourceManager + 0x3d) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x1ed) = 0x1000001;
  SystemResourceManager[0x62] = 0;
  *(uint8_t *)(SystemResourceManager + 0xc) = 0;
  *(uint32_t *)(SystemResourceManager + 0x20) = 0xffffffff;
  *(uint8_t *)(SystemResourceManager + 0x14) = 0;
  SystemResourceManager[0x15] = 0;
  SystemResourceManager[0x16] = 0;
  *(uint8_t *)((long long)SystemResourceManager + 0x1ec) = 0;
  LOCK();
  *(uint8_t *)(SystemResourceManager + 0x79) = 0;
  UNLOCK();
  (**(code **)(*SystemResourceOffsetPointer + 0x10))(SystemResourceOffsetPointer,&SystemResourceConfigurationData);
  (**(code **)(*resourcePoolPointer + 0x10))(resourcePoolPointer,&SystemStringTemplate);
  *(uint8_t *)(SystemResourceManager + 0x2d) = 0;
  SystemResourceManager[0x13] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1f) = 0x1010101;
  *(void*2 *)((long long)SystemResourceManager + 0xfc) = 0x101;
  *(uint32_t *)((long long)SystemResourceManager + 0x104) = 0xffffffff;
  SystemAllocationFlags = 8;
  do {
    systemResourceCounter = (uint32_t *)SystemResourceManager[0x22];
    if (systemResourceCounter < (uint32_t *)SystemResourceManager[0x23]) {
      SystemResourceManager[0x22] = SystemOperationCounterPointer + 1;
      *SystemOperationCounterPointer = 0;
    }
    else {
      SystemThreadStorage = (uint32_t *)*PrimaryResourcePointer;
      SystemBufferAddress = (long long)SystemOperationCounterPointer - (long long)SystemThreadStorage >> 2;
      if (SystemBufferAddress == 0) {
        SystemBufferAddress = 1;
SystemBufferAllocationHandler:
        SystemThreadContext = (uint32_t *)
                 CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemBufferAddress * 4,*(uint8_t *)(SystemResourceManager + 0x24));
        systemResourceCounter = (uint32_t *)SystemResourceManager[0x22];
        SystemThreadStorage = (uint32_t *)*PrimaryResourcePointer;
      }
      else {
        SystemBufferAddress = SystemBufferAddress * 2;
        SystemThreadContext = (uint32_t *)0x0;
        if (SystemBufferAddress != 0) goto SystemBufferAllocationHandler;
      }
      if (SystemThreadStorage != SystemOperationCounterPointer) {
          memmove(SystemThreadContext,SystemThreadStorage,(long long)SystemOperationCounterPointer - (long long)SystemThreadStorage);
      }
      *SystemThreadContext = 0;
      if (*PrimaryResourcePointer != 0) {
          SystemCleanupFunction();
      }
      *PrimaryResourcePointer = (long long)SystemThreadContext;
      SystemResourceManager[0x22] = SystemThreadContext + 1;
      SystemResourceManager[0x23] = SystemThreadContext + SystemBufferAddress;
    }
    SystemAllocationFlags = SystemAllocationFlags + -1;
    if (SystemAllocationFlags == 0) {
      *(uint32_t *)((long long)SystemResourceManager + 0x24) = 0;
      *(uint32_t *)((long long)SystemResourceManager + 0x29) = 0x1010101;
      *(uint8_t *)(SystemResourceManager + 5) = 1;
      *(uint32_t *)(SystemResourceManager + 0x71) = 0x3f800000;
      *(uint8_t *)(SystemResourceManager + 0x76) = 1;
      *(uint32_t *)(SystemResourceManager + 0x25) = 0;
      SystemResourceManager[0x56] = 0;
      *(void* *)((long long)SystemResourceManager + 0x224) = 0;
      *(uint8_t *)((long long)SystemResourceManager + 0x22c) = 0;
      *(uint32_t *)(SystemResourceManager + 0x40) = 0;
      SystemResourceManager[0x41] = 0;
      resourceEntryPointer = SystemPerformancePreviousStorage;
      if (SystemPerformancePreviousStorage == (void* *)0x0) {
        QueryPerformanceCounter(ParameterStackArray);
        resourceEntryPointer = ParameterStackArray[0];
      }
      SystemResourceManager[0x42] = (double)((long long)resourceEntryPointer - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
      *(uint32_t *)(SystemResourceManager + 0x44) = 0;
      *(uint8_t *)((long long)SystemResourceManager + 0x264) = 0;
      *(uint32_t *)(SystemResourceManager + 0x4d) = 0;
      *(void* *)((long long)SystemResourceManager + 500) = 0;
      *(uint8_t *)(SystemResourceManager + 0x28) = 0;
      *(uint8_t *)((long long)SystemResourceManager + 0x1fc) = 0;
      SystemResourceManager[0x7b] = 0;
      SystemResourceManager[0x57] = 0;
      SystemAllocationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc,4,3);
      *(uint8_t *)(SystemAllocationFlags + 8) = 0;
      SystemResourceManager[6] = SystemAllocationFlags;
      SystemResourceManager[0x27] = 0;
      *(uint8_t *)(SystemResourceManager + 7) = 0;
      *(uint32_t *)((long long)SystemResourceManager + 0x3c) = 0xffffffff;
      SystemResourceManager[0x43] = 0;
      *(uint32_t *)(SystemResourceManager + 0x26) = 0xffffffff;
      resourceEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,3);
      resourceEntryPointer[1] = 0;
      resourceEntryPointer[2] = 0;
      resourceEntryPointer[3] = 0;
      resourceEntryPointer[4] = 0;
      resourceEntryPointer[5] = 0;
      *resourceEntryPointer = &SystemMemoryTemplateA;
      *resourceEntryPointer = &SystemMemoryTemplateB;
      *(uint32_t *)(resourceEntryPointer + 1) = 0;
      *resourceEntryPointer = &SystemResourceTemplateNonary;
      resourceEntryPointer[2] = 0;
      resourceEntryPointer[3] = 0;
      resourceEntryPointer[4] = 0;
      *(uint32_t *)(resourceEntryPointer + 5) = 3;
      SystemResourceManager[0x78] = resourceEntryPointer;
      return SystemResourceManager;
    }
  } while( true );
}




/**
 * 系统组件初始化器 - 初始化核心系统组件
 * @brief 执行系统资源回调函数
 * 
 * 该函数负责执行系统资源的回调函数，用于处理系统资源的异步操作。
 * 当系统资源完成某些操作时，会调用此函数来执行相应的回调处理。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void ExecuteSystemResourceCallback(long long* SystemResourceManager)

{
  if ((long long *)*callbackParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*callbackParameter + 0x38))();
  }
  return;
}



/**
 * @brief 系统内存模板管理器
 * 
 * 该函数管理系统内存模板的设置和清理。它会检查系统资源指针的状态，
 * 在需要时进行清理操作，然后设置相应的内存模板引用。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 控制标志位，第0位为1时释放内存
 * @param AdditionalParameter 内存释放参数1
 * @param ConfigurationFlag 内存释放参数2
 * @return 返回处理后的系统资源指针
 * @note 这是内存管理系统的核心函数之一
 */
void* *
SystemMemoryTemplateManager(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (SystemResourceManager[2] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x30,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}




/**
 * @brief 系统内存模板清理函数
 * 
 * 该函数负责清理系统内存模板，释放相关资源。
 * 当系统资源不再需要时，调用此函数进行内存模板的清理工作。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemMemoryTemplateCleanup(void* *SystemResourceManager)

{
  if (SystemResourceManager[2] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  return;
}





/**
 * @brief 计算渲染质量设置
 * 
 * 根据系统节点管理器的配置计算渲染质量相关的各种参数，
 * 包括纹理缩放、阴影缩放、基础渲染比例等。
 * 这些参数用于调整游戏的渲染质量和性能。
 * 
 * @param SystemResourceManager 系统资源指针，用于存储计算结果
 * 
 * @return 无返回值
 * 
 * @note 计算结果会直接写入系统资源指针指定的内存位置
 */
void CalculateRenderQualitySettings(long long SystemResourceManager)

{
  long long resourceDataIndex;
  int systemResult;
  int NodeIdentifierComparisonResult;
  float renderQualityMultiplier;
  float baseRenderScale;
  float textureScaleFactor;
  float shadowScaleFactor;
  float qualityLevel;
  
  resourceDataIndex = SystemNodeManagerPointer;
  systemResult = *(int *)(SystemNodeManagerPointer + 0xd90) + -1;
  systemCounter = 0;
  if ((-1 < systemResult) && (systemCounter = systemResult, 3 < systemResult)) {
    systemCounter = 3;
  }
  qualityLevel = (float)systemCounter;
  shadowScaleFactor = qualityLevel * 1.6750001 + 2.4750001;
  baseRenderScale = qualityLevel * 4.4666667 + 6.6000004;
  textureScaleFactor = qualityLevel * 3.3500001 + 4.9500003;
  renderQualityMultiplier = shadowScaleFactor + textureScaleFactor;
  *(float *)(SystemResourceManager + 0x38c) = textureScaleFactor * textureScaleFactor;
  shadowScaleFactor = shadowScaleFactor + renderQualityMultiplier;
  *(float *)(SystemResourceManager + 0x390) = renderQualityMultiplier * renderQualityMultiplier;
  renderQualityMultiplier = baseRenderScale + shadowScaleFactor;
  *(float *)(SystemResourceManager + 0x394) = shadowScaleFactor * shadowScaleFactor;
  baseRenderScale = baseRenderScale + renderQualityMultiplier;
  *(float *)(SystemResourceManager + 0x398) = renderQualityMultiplier * renderQualityMultiplier;
  renderQualityMultiplier = qualityLevel * 13.400001 + 19.800001 + baseRenderScale;
  *(float *)(SystemResourceManager + 0x39c) = baseRenderScale * baseRenderScale;
  baseRenderScale = qualityLevel * 17.866667 + 26.400002 + renderQualityMultiplier;
  *(float *)(SystemResourceManager + 0x3a0) = renderQualityMultiplier * renderQualityMultiplier;
  *(float *)(SystemResourceManager + 0x3a4) = baseRenderScale * baseRenderScale;
  *(uint32_t *)(SystemResourceManager + 0x3a8) = 0x7f7fffff;
  *(uint *)(SystemResourceManager + 0x3ac) = (uint)(*(int *)(resourceDataIndex + 0xd90) == 0);
  return;
}





/**
 * @brief 系统资源清理管理器
 * 
 * 负责管理系统资源的清理和释放，包括内存分配器、音频管理器、渲染管理器
 * 以及其他系统组件的资源回收。确保系统在关闭时正确释放所有资源。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含所有需要清理的系统资源
 */
void SystemResourceCleanupManager(long long* SystemResourceManager)
{
  void* *SystemResourceArray;
  long long LocalSystemHandle;
  
  SystemResourceArray = (void* *)SystemResourceManager[0x7c];
  if (SystemResourceArray != (void* *)0x0) {
    SystemResourceArray[0x14] = &SystemGlobalDataReference;
    if (SystemResourceArray[0x15] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[0x15] = 0;
    *(uint32_t *)(SystemResourceArray + 0x17) = 0;
    SystemResourceArray[0x14] = &SystemMemoryAllocatorReference;
    SystemResourceArray[0x10] = &SystemGlobalDataReference;
    if (SystemResourceArray[0x11] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[0x11] = 0;
    *(uint32_t *)(SystemResourceArray + 0x13) = 0;
    SystemResourceArray[0x10] = &SystemMemoryAllocatorReference;
    if (SystemResourceArray[0xc] != 0) {
        SystemCleanupFunction();
    }
    SystemMemoryDeallocationFunction();
    SystemMemoryDeallocationFunction();
    *SystemResourceArray = &SystemGlobalDataReference;
    if (SystemResourceArray[1] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[1] = 0;
    *(uint32_t *)(SystemResourceArray + 3) = 0;
    *SystemResourceArray = &SystemMemoryAllocatorReference;
      SystemCleanupFunction(SystemResourceArray);
  }
  SystemResourceManager[0x7c] = 0;
  SystemResourceArray = (void* *)SystemResourceManager[1];
  if (SystemResourceArray != (void* *)0x0) {
    LocalSystemHandle = __RTCastToVoid(SystemResourceArray);
    *SystemResourceArray = &SystemUnknownDataReference;
    SystemResourceReleaseFunction(SystemAllocationFlagsTemplate,SystemResourceArray[0x28]);
    SystemResourceArray[0x28] = 0;
    SystemResourceArray[0x29] = &SystemGlobalDataReference;
    if (SystemResourceArray[0x2a] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceArray[0x2a] = 0;
    *(uint32_t *)(SystemResourceArray + 0x2c) = 0;
    SystemResourceArray[0x29] = &SystemMemoryAllocatorReference;
    SystemResourceFinalizationFunction();
    if (LocalSystemHandle != 0) {
        SystemCleanupFunction(LocalSystemHandle);
    }
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  LocalSystemHandle = *SystemResourceManager;
  if (LocalSystemHandle != 0) {
    SystemResourceHandleCleanupFunction(LocalSystemHandle);
      SystemCleanupFunction(LocalSystemHandle);
  }
  *SystemResourceManager = 0;
  LocalSystemHandle = SystemAudioManagerPointer;
  if (SystemAudioManagerPointer != 0) {
    SystemAudioManagerCleanupFunction();
      SystemCleanupFunction(LocalSystemHandle);
  }
  SystemAudioManagerPointer = 0;
  SystemRenderManagerCleanupFunction();
  SystemRenderManagerPointer = 0;
  if (SystemResourceManager[6] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[6] = 0;
  SystemResourceManager[0x6d] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x6e] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x6e] = 0;
  *(uint32_t *)(SystemResourceManager + 0x70) = 0;
  SystemResourceManager[0x6d] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x69] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x6a] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x6a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x6c) = 0;
  SystemResourceManager[0x69] = (long long)&SystemMemoryAllocatorReference;
  SystemConfigurationCleanupFunction();
  SystemDataBufferCleanupFunction(SystemResourceManager + 0x5c,SystemResourceManager[0x5e]);
  SystemResourceManager[0x58] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x59] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x59] = 0;
  *(uint32_t *)(SystemResourceManager + 0x5b) = 0;
  SystemResourceManager[0x58] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x52] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x53] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x53] = 0;
  *(uint32_t *)(SystemResourceManager + 0x55) = 0;
  SystemResourceManager[0x52] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x4e] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x4f] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x4f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x51) = 0;
  SystemResourceManager[0x4e] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x39] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x3a] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x3a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x3c) = 0;
  SystemResourceManager[0x39] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x32] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x2e] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x2f] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x2f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x31) = 0;
  SystemResourceManager[0x2e] = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[0x29] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x2a] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x2a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x2c) = 0;
  SystemResourceManager[0x29] = (long long)&SystemMemoryAllocatorReference;
  if (SystemResourceManager[0x21] != 0) {
      SystemCleanupFunction();
  }
  SystemFinalCleanupFunction();
  SystemResourceManager[0x17] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x18] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x18] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1a) = 0;
  SystemResourceManager[0x17] = (long long)&SystemMemoryAllocatorReference;
  if (SystemResourceManager[0xf] != 0) {
      SystemCleanupFunction();
  }
  if ((long long *)SystemResourceManager[9] != (long long *)0x0) {
    SystemResourceFinalizerCallback();
  }
  return;
}



00018004d2c7)
00018004d2d0)
00018004d2da)
00018004d2df)
00018004d2f2)
00018004d30d)
00018004d328)
00018004d343)
00018004d35e)
00018004d379)
00018004d4a0)


/**
 * @brief 处理系统资源分配
 * 
 * 该函数负责处理系统资源的分配和管理操作。
 * 根据传入的参数分配相应的系统资源，并设置资源状态。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 分配参数
 */
void ProcessSystemResourceAllocation(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  byte SystemCharacterValue;
  uint8_t resourceCreationFlags;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  char operationStatusFlag;
  int CalculationFlags;
  uint32_t ThreadContextFlag;
  uint OperationCode;
  long long resourceCounter;
  long long SystemAllocationFlags;
  uint8_t *ThreadLocalStorage;
  char *SystemFunctionPointer;
  uint32_t *SystemDataConfigurationPointer;
  uint8_t *SystemThreadLocalStoragePointer;
  byte *resourceStringPointer;
  uint8_t *SystemResourceStringPointer;
  void* *SystemStringTemplatePointer;
  void* *SystemDataBufferPointer;
  int SystemContextPointer;
  long long SystemThreadIndex;
  ulong long ThreadCreationFlags;
  void* *SystemHashEntryPointer2;
  uint InitializationFlags;
  long long SystemThreadHandle4;
  ulong long SecurityParameter;
  uint NetworkConnectionFlags;
  void* resourceCreationFlags7;
  ulong long resourceCreationFlags8;
  ulong long resourceCreationFlags9;
  uint resourceAllocationContext0;
  bool isSystemResourceMatch;
  uint32_t SystemRegisterValue2;
  uint32_t SystemRegisterValue;
  uint8_t SystemByteArray [32];
  uint8_t SystemByteValue;
  char SystemCharValue1;
  char SystemCharValue2;
  char arrayChar336 [2];
  uint SystemMemoryAllocationSize;
  void* *pointerUnsigned330;
  char *charPointer328;
  uint SystemMemoryBufferSize;
  void* SystemMemoryBufferPointer;
  void* *pointerUnsigned310;
  uint8_t *pointerUnsigned308;
  uint SystemResourceStatusFlag0;
  void* SystemResourceValue;
  ulong long SystemDataIndexCounter;
  void* *pointerUnsigned2e8;
  uint8_t *pointerUnsigned2e0;
  uint SystemAllocationFlag;
  ulong long SystemResourceHandle;
  void* *pointerUnsigned2c8;
  uint8_t *pointerUnsigned2c0;
  uint32_t SystemDataCount;
  ulong long SystemMemoryPoolSize;
  void* *pointerUnsigned2a8;
  void* *pointerUnsigned2a0;
  uint SystemOperationStatus;
  uint32_t SystemProcessFlags;
  uint32_t EncryptionKeyValuec;
  void* *pEncryptionKeyValue8;
  uint32_t *pEncryptionKeyValue0;
  uint32_t SystemMemoryOffset;
  void* SystemMemoryPointer;
  void* SystemDataMemoryContext;
  long long longValue260;
  void* *pointerUnsigned258;
  long long longValue250;
  uint SystemDataBufferOffset;
  uint32_t SystemThreadStackSize;
  uint32_t SystemResourceCounter;
  void* *pointerUnsigned238;
  long long longValue230;
  uint SystemMemoryAlignment;
  uint32_t SystemAllocationSize;
  void* *SystemStringTemplatePtr;
  long long longValue210;
  uint SystemMaxOperationCount8;
  uint32_t StackValue200;
  void* *SystemGlobalDataReferencePtr2;
  long long longValue1f0;
  uint StackValue1e8;
  uint32_t GlobalDataFlags2;
  void* *SystemGlobalDataReferencePtr;
  long long longValue1d0;
  uint SystemThreadStackSize;
  uint32_t GlobalDataFlags;
  void* *pointerUnsigned1b8;
  void* *pointerUnsigned1b0;
  int intValue1a8;
  uint32_t CalculationFlags1A0;
  void* *pSystemStackFlag;
  void* *pointerUnsigned190;
  int intValue188;
  uint32_t ConcatenatedValue440;
  void* *pCalculationFlags178;
  long long longValue170;
  uint32_t encryptionKeySize;
  void* threadLocalStoragePointer;
  ulong long resourceCreationFlagsLength;
  void* *resourceManagerPointer;
  long long SystemOperationStatusOffset;
  uint32_t SystemAllocationFlags;
  void* *memoryAllocatorPointer;
  long long resourceCounter;
  uint32_t systemConfigFlags;
  void* *systemDataPointer;
  long long operationResult;
  uint32_t bufferFlags;
  void* *dataBufferPointer;
  void* *systemDataBuffer;
  void* systemHandle;
  uint32_t memoryPoolFlags;
  void* *systemResourcePointer;
  long long processStatus;
  uint32_t securityFlags;
  void* systemSemaphore;
  void* *stackParameterB;
  uint8_t *pStackParameterC;
  uint32_t systemStateFlags;
  uint8_t systemStateBuffer [72];
  ulong long encryptionKey;
  
  SystemThreadHandle4 = SystemGlobalStatusFlags;
  systemSemaphore = 0xfffffffffffffffe;
  encryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)arrayUnsigned368;
  ThreadLocalStorage = (uint8_t *)0x0;
  SystemMemoryAllocationSize = 0;
  longValue260 = SystemGlobalStatusFlags;
  systemStatusFlag338 = '\0';
  SystemStringTemplatePointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemStringTemplatePointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  SystemThreadIndex = -1;
  do {
    resourceCounter = SystemThreadIndex;
    SystemThreadIndex = resourceCounter + 1;
  } while (SystemStringTemplatePointer[SystemThreadIndex] != '\0');
  ThreadCreationFlags = resourceCounter + 2;
  pointerUnsigned310 = &SystemGlobalDataReference;
  SystemResourceValue = 0;
  pointerUnsigned308 = (uint8_t *)0x0;
  SystemResourceStatusFlag0 = 0;
  SystemDataMemoryContext = SystemStringTemplatePointer;
  resourceCreationFlagsLength = ThreadCreationFlags;
  (**(code **)(*(long long *)(SystemGlobalStatusFlags + 0x2c0) + 0x10))
            ((long long *)(SystemGlobalStatusFlags + 0x2c0),SystemStringTemplatePointer);
  SystemDataIndexCounter = 0;
  SystemThreadLocalStoragePointer = ThreadLocalStorage;
  if (ThreadCreationFlags != 0) {
    do {
      SystemCharacterValue = SystemStringTemplatePointer[SystemDataIndexCounter];
      OperationCode = (uint)SystemThreadLocalStoragePointer;
      if ((SystemCharacterValue & 0xdf) == 0) {
        SystemThreadIndex = SystemThreadHandle4 + 0x2e0;
        resourceCounter = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x40,*(uint8_t *)(SystemThreadHandle4 + 0x308));
        ProcessResourcePointerOperation(resourceCounter + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,&pointerUnsigned310);
        SystemAllocationFlags = SystemResourceAllocator(SystemThreadIndex,&systemStatusFlag337,resourceCounter + 0x20);
        if (systemStatusFlag337 != '\0') {
          if (SystemAllocationFlags == SystemThreadIndex) goto ResourceAllocationCheck;
          if (*(int *)(SystemAllocationFlags + 0x30) == 0) goto AllocationFlagCheck;
          if (*(int *)(resourceCounter + 0x30) == 0) goto ResourceAllocationCheck;
          resourceStringPointer = *(byte **)(SystemAllocationFlags + 0x28);
          SystemThreadHandle4 = *(long long *)(resourceCounter + 0x28) - (long long)resourceStringPointer;
          goto AllocationHandler;
        }
        SystemUtilityHandler(extraout_XMM0_Da,resourceCounter);
        if (OperationCode == 8) {
          CalculationFlags = strcmp(ThreadLocalStorage,&SystemResourceTemplateDenary);
          isSystemResourceMatch = CalculationFlags == 0;
        }
        else {
          isSystemResourceMatch = false;
        }
        if (isSystemResourceMatch) {

/**
 * @brief 更新系统渲染管理器
 * 
 * 该函数负责更新系统渲染管理器的状态和参数。
 * 根据系统资源的信息更新渲染管理器的配置。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void UpdateSystemRenderManager(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  uint32_t resourceCreationFlags;
  int NodeIdentifierComparisonResult;
  bool isTextureUpdateRequired;
  void* currentThreadId;
  bool isSystemInitialized;
  
  SystemIntegerPointer = (int *)(SystemResourceManager + 0x3d0);
  if (((int)*(float *)(SystemRenderManagerPointer + 0x17ec) == *(int *)(SystemResourceManager + 0x3cc)) &&
     ((int)*(float *)(SystemRenderManagerPointer + 0x17f0) == *SystemIntegerPointer)) {
    isTextureUpdateRequired = false;
  }
  else {
    isTextureUpdateRequired = true;
    UpdateRenderManagerSystem(SystemRenderManagerPointer,*(int *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer);
  }
  if (*(int *)(*(long long *)(SystemResourceManager + 8) + 0x38) == 2) {
    if ((*(char *)(SystemResourceManager + 0x3d4) != '\0') || (*(char *)(SystemResourceManager + 0x3d5) != '\0')) {
      resourceCreationFlags = *(uint32_t *)(SystemNodeManagerPointer + 0x1ea0);
      ProcessNodeManagerOperation(SystemNodeManagerPointer,0);
      ProcessSystemResourceData(*(void* *)(SystemResourceManager + 8),*(uint32_t *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer,
                    *(uint8_t *)(SystemResourceManager + 0x3d5));
      UpdateTextureManagerSystem(SystemTextureManagerPointer,*(uint32_t *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer,1);
      ProcessNodeManagerOperation(SystemNodeManagerPointer,resourceCreationFlags);
      ProcessSystemResourceData(*(void* *)(SystemResourceManager + 8),*(uint32_t *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer,
                    *(uint8_t *)(SystemResourceManager + 0x3d5));
      isSystemInitialized = true;
      goto ErrorHandler;
    }
  }
  else {
    if (*(char *)(SystemResourceManager + 0x3d4) != '\0') {
      systemCounter = *(int *)(SystemNodeManagerPointer + 0x1ea0);
      if ((*(char *)(SystemResourceManager + 0x3d5) != '\0') || (isTextureUpdateRequired)) {
        currentThreadId = 1;
      }
      else {
        currentThreadId = 0;
      }
      ProcessSystemResourceData(*(long long *)(SystemResourceManager + 8),*(uint32_t *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer,currentThreadId);
      isSystemInitialized = systemCounter == 2;
      goto ErrorHandler;
    }
    if (!isTextureUpdateRequired) {
      return;
    }
  }
  isSystemInitialized = false;
ErrorHandler:
  UpdateTextureManagerSystem(SystemTextureManagerPointer,*(uint32_t *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer,isSystemInitialized);
  if (!isTextureUpdateRequired) {
    return;
  }
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemResourceTemplateUndenary,*(uint32_t *)(SystemResourceManager + 0x3cc),*SystemIntegerPointer);
}




/**
 * @brief 获取系统资源状态
 * 
 * 该函数负责获取当前系统资源的状态信息。
 * 返回系统资源的当前状态值，用于监控系统运行情况。
 * 
 * @return 系统资源状态值
 */
uint32_t GetSystemResourceStatus(void)

{
  uint8_t SystemOperationStatusArray [16];
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  void* *presourceAddress;
  uint currentThreadId;
  int CalculationFlags;
  void* *systemDataReference;
  long long bufferOffset;
  uint stringBufferPosition;
  ulong long stringBufferCapacity;
  void* *stringBufferPointer;
  long long stringBufferOffset;
  uint stringBufferIndex;
  void* StackParameterC;
  void* systemSemaphore;
  uint8_t systemDataBuffer [32];
  uint8_t threadLocalStorageBuffer [40];
  
  ResourceDataOffset = SystemGlobalStatusFlags;
  systemSemaphore = 0xfffffffffffffffe;
  SystemOperationStatusArray = *(uint8_t (*) [16])
            (*(long long *)(SystemGlobalStatusFlags + 8) + 0xcc +
            (ulong long)(*(uint *)(*(long long *)(SystemGlobalStatusFlags + 8) + 0x13c) & 1) * 0x48);
  if ((SystemOperationStatusArray.TertiaryField != 0) && (SystemOperationStatusArray.SecondaryField != 0)) {
    systemDataReference = &SystemGlobalDataReference;
    SystemStackFlagB0 = 0;
    systemOffsetCounter = 0;
    systemDataBuffer = 0;
    ProcessSystemData(&systemDataReference,SystemOperationStatusArray.PrimaryField);
    currentThreadId = systemDataBuffer + 1;
    ExecuteSystemCommand(&systemDataReference,currentThreadId);
    *(void*2 *)((ulong long)systemDataBuffer + systemOffsetCounter) = 0x2c;
    systemDataBuffer = currentThreadId;
    ProcessSystemData(&systemDataReference,SystemOperationStatusArray.PrimaryExtended >> 0x20);
    currentThreadId = systemDataBuffer + 1;
    ExecuteSystemCommand(&systemDataReference,currentThreadId);
    *(void*2 *)((ulong long)systemDataBuffer + systemOffsetCounter) = 0x2c;
    systemDataBuffer = currentThreadId;
    ProcessSystemData(&systemDataReference,SystemOperationStatusArray.SecondaryExtended & MAX_UNSIGNED_32_BIT);
    CalculationFlags = systemDataBuffer + 1;
    ExecuteSystemCommand(&systemDataReference,CalculationFlags);
    *(void*2 *)((ulong long)systemDataBuffer + systemOffsetCounter) = 0x2c;
    systemDataBuffer = CalculationFlags;
    ProcessSystemData(&systemDataReference,SystemOperationStatusArray.SecondaryExtended >> 0x20);
    presourceAddress = (void* *)CreateSystemObject(SystemCounterBuffer80,&systemDataReference);
    ProcessMemoryManagerOperation(SystemMemoryManagerPointer + 0xe30,presourceAddress);
    *presourceAddress = &SystemGlobalDataReference;
    if (presourceAddress[1] != 0) {
        SystemCleanupFunction();
    }
    presourceAddress[1] = 0;
    *(uint32_t *)(presourceAddress + 3) = 0;
    *presourceAddress = &SystemMemoryAllocatorReference;
    systemDataReference = &SystemGlobalDataReference;
    if (systemOffsetCounter != 0) {
        SystemCleanupFunction();
    }
    systemOffsetCounter = 0;
    UnsignedStackFlagB0 = UnsignedStackFlagB0 & MAX_UNSIGNED_32_BIT00000000;
    pointerUnsignedC8 = &SystemMemoryAllocatorReference;
  }
  SystemThreadHandle = *(long long *)(ResourceDataOffset + 8);
  SystemOperationStatusArray = *(uint8_t (*) [16])(SystemThreadHandle + 0xdc + (ulong long)(*(uint *)(SystemThreadHandle + 0x13c) & 1) * 0x48);
  if ((SystemOperationStatusArray.TertiaryField != 0) && (SystemOperationStatusArray.SecondaryField != 0)) {
    SystemStackFlagA8 = &SystemGlobalDataReference;
    SystemConfigurationValue = 0;
    secondarySystemOffsetCounter = 0;
    systemConfigurationValue = 0;
    ProcessSystemData(&SystemDataBufferPointerA8,SystemOperationStatusArray.PrimaryField);
    currentThreadId = secondarySystemDataBuffer + 1;
    ExecuteSystemCommand(&SystemDataBufferPointerA8,currentThreadId);
    *(void*2 *)((ulong long)secondarySystemDataBuffer + secondarySystemOffsetCounter) = 0x2c;
    secondarySystemDataBuffer = currentThreadId;
    ProcessSystemData(&SystemDataBufferPointerA8,aSystemOperationStatus._0_8_ >> 0x20);
    currentThreadId = secondarySystemDataBuffer + 1;
    ExecuteSystemCommand(&SystemDataBufferPointerA8,currentThreadId);
    *(void*2 *)((ulong long)secondarySystemDataBuffer + secondarySystemOffsetCounter) = 0x2c;
    secondarySystemDataBuffer = currentThreadId;
    ProcessSystemData(&SystemDataBufferPointerA8,aSystemOperationStatus._8_8_ & MAX_UNSIGNED_32_BIT);
    CalculationFlags = secondarySystemDataBuffer + 1;
    ExecuteSystemCommand(&SystemDataBufferPointerA8,CalculationFlags);
    *(void*2 *)((ulong long)secondarySystemDataBuffer + secondarySystemOffsetCounter) = 0x2c;
    secondarySystemDataBuffer = CalculationFlags;
    ProcessSystemData(&SystemDataBufferPointerA8,aSystemOperationStatus._8_8_ >> 0x20);
    presourceAddress = (void* *)CreateSystemObject(ThreadTitleBuffer,&SystemDataBufferPointerA8);
    ProcessMemoryManagerOperation(SystemMemoryManagerPointer + 0xef0,presourceAddress);
    *presourceAddress = &SystemGlobalDataReference;
    if (presourceAddress[1] != 0) {
        SystemCleanupFunction();
    }
    presourceAddress[1] = 0;
    *(uint32_t *)(presourceAddress + 3) = 0;
    *presourceAddress = &SystemMemoryAllocatorReference;
    SystemStackFlagA8 = &SystemGlobalDataReference;
    if (LongStackVariableA0 != 0) {
        SystemCleanupFunction();
    }
  }
  return *(uint32_t *)(*(long long *)(ResourceDataOffset + 8) + 0x13c);
}



00018004ed08)
00018004ed22)
00018004ed36)
00018004ed44)
00018004ed48)
00018004ed5b)
00018004ed5f)
00018004ed72)
00018004ed76)
00018004ed89)
00018004ed8d)
00018004edbc)
00018004edc0)
00018004edd3)
00018004ee38)
00018004ee52)
00018004ee66)
00018004ee74)
00018004ee78)
00018004ee8b)
00018004ee8f)
00018004eea2)
00018004eea6)
00018004eeb6)
00018004eeba)
00018004eeec)
00018004eef0)
00018004ef03)
00018004ebd5)
00018004ebef)
00018004ec03)
00018004ec11)
00018004ec15)
00018004ec28)
00018004ec2c)
00018004ec3f)
00018004ec43)
00018004ec56)
00018004ec5a)
00018004ec88)
00018004ec90)
00018004eca3)


// 函数: void SystemResourceInitializer(void* SystemResourceManager,void* parameter2,void* parameter3,void* parameter4)
/**
 * @brief 系统资源初始化器
 * 
 * 该函数负责初始化系统资源，包括内存分配、缓冲区设置和系统参数配置。
 * 这是系统启动过程中的核心初始化函数。
 * 
 * @param resourceManagerPointer 系统资源指针
 * @param memoryAllocationFlags 内存分配标志
 * @param systemConfiguration 系统配置
 * @param threadParameters 线程参数
 */
void SystemResourceInitializer(void* resourceManagerPointer,void* memoryAllocationFlags,void* systemConfiguration,void* threadParameters)

{
  uint SystemOperationStatus;
  uint resourceCreationFlags;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  void* *pEncryptionValue68;
  long long LocalMemoryBuffer;
  uint SystemProcessFlags58;
  void* ConcatenatedValue44;
  
  ResourceDataOffset = SystemMemoryManagerPointer;
  pEncryptionValue68 = &SystemGlobalDataReference;
  ConcatenatedValue44 = 0;
  LocalMemoryBuffer = 0;
  SystemProcessFlags58 = 0;
  if (*(int *)(SystemNodeManagerPointer + 0x1ea0) == 0) {
    SystemOperationStatus = *(uint *)(SystemMemoryManagerPointer + 0xe40);
    currentThreadId = (ulong long)SystemOperationStatus;
    if (*(long long *)(SystemMemoryManagerPointer + 0xe38) != 0) {
      ExecuteSystemCommand(&pEncryptionValue68,currentThreadId,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    }
    if (SystemOperationStatus != 0) {
        memcpy(systemMemoryOffset,*(void* *)(ResourceDataOffset + 0xe38),currentThreadId);
    }
    if (systemMemoryOffset != 0) {
      *(uint8_t *)(currentThreadId + systemMemoryOffset) = 0;
    }
    ConcatenatedValue44 = ConcatenatedValue44(*(uint32_t *)(ResourceDataOffset + 0xe4c),(uint32_t)ThreadContextFlag);
  }
  ResourceDataOffset = SystemMemoryManagerPointer;
  SystemProcessFlags58 = 0;
  SystemOperationStatus = *(uint *)(SystemMemoryManagerPointer + 0xf00);
  currentThreadId = (ulong long)SystemOperationStatus;
  if (*(long long *)(SystemMemoryManagerPointer + 0xef8) != 0) {
    ExecuteSystemCommand(&pEncryptionValue68,currentThreadId);
  }
  if (SystemOperationStatus != 0) {
      memcpy(systemMemoryOffset,*(void* *)(ResourceDataOffset + 0xef8),currentThreadId);
  }
  if (systemMemoryOffset != 0) {
    *(uint8_t *)(currentThreadId + systemMemoryOffset) = 0;
  }
  SystemBufferAddress = SystemMemoryManagerPointer;
  ConcatenatedValue44 = ConcatenatedValue44(*(uint32_t *)(ResourceDataOffset + 0xf0c),(uint32_t)ThreadContextFlag);
  resourceCreationFlags = *(uint *)(SystemMemoryManagerPointer + 0xfc0);
  currentThreadId = (ulong long)resourceCreationFlags;
  SystemProcessFlags58 = SystemOperationStatus;
  if (*(long long *)(SystemMemoryManagerPointer + 0xfb8) != 0) {
    ExecuteSystemCommand(&pEncryptionValue68,currentThreadId);
  }
  if (resourceCreationFlags != 0) {
      memcpy(systemMemoryOffset,*(void* *)(SystemBufferAddress + 0xfb8),currentThreadId);
  }
  if (systemMemoryOffset != 0) {
    *(uint8_t *)(currentThreadId + systemMemoryOffset) = 0;
  }
  ConcatenatedValue44 = ConcatenatedValue44(*(uint32_t *)(SystemBufferAddress + 0xfcc),(uint32_t)ThreadContextFlag);
  pEncryptionValue68 = &SystemGlobalDataReference;
  if (systemMemoryOffset != 0) {
    SystemProcessFlags58 = resourceCreationFlags;
      SystemCleanupFunction();
  }
  return;
}





/**
 * 系统清理器 - 执行系统清理操作
 * 负责在系统关闭时清理内存和资源
 * 
 */
void SystemCleanupHandler(void)

{
  int SystemOperationStatus;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  int *pointerToInteger5;
  void** SystemRootNode;
  uint32_t *hashTableNode;
  void* *SystemThreadStorage;
  char systemAvailabilityFlag;
  float ScalingFactor;
  uint32_t SystemOperationStatus1;
  float RatioValue;
  uint8_t SystemMaxOperationCount8 [32];
  long long SystemMemoryPoolOffset;
  long long SystemMemoryPoolHandle;
  long long SystemResourcePoolPointer;
  void* *SystemResourceArray [10];
  void* SystemThreadFlag;
  uint8_t SystemStackBuffer [8];
  void* *SystemResourcePointer;
  uint8_t *SystemResourceBuffer;
  uint32_t SystemConfigurationId;
  uint8_t SystemResourceDataBuffer [264];
  ulong long SystemEncryptionKey;
  
  ResourceDataOffset = SystemGlobalStatusFlags;
  SystemThreadFlag = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)SystemMaxOperationCount8;
  if (*(void* **)*SystemMemoryBlockStorage == &SystemMemoryBlockTemplatePrimary) {
    systemAvailabilityFlag = *(int *)(SystemStatusFlags + 0xe0) != 0;
  }
  else {
    systemAvailabilityFlag = (**(code **)(*(void* **)*SystemMemoryBlockStorage + 0x48))();
  }
  if (systemAvailabilityFlag == '\0') {
    SystemRandomSeed = timeGetTime();
  }
  else {
    SystemRandomSeed = 0xb061;
  }
  SystemThreadHandle = SystemNodeManagerPointer;
  SystemRandomSeed = SystemRandomSeed ^ 0x41c64e6d;
  if ((*(long long *)(SystemDataMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemNodeManagerPointer + 0x540) < 1)) {
    if (*(int *)(SystemNodeManagerPointer + 0x2140) == 0) {
      ScalingFactor = *(float *)(SystemNodeManagerPointer + 0x20d0);
    }
    else {
      ScalingFactor = 100.0;
    }
    ScalingFactor = ScalingFactor * 0.01;
  }
  else {
    ScalingFactor = 1.0;
  }
  *(float *)(ResourceDataOffset + 0x234) = ScalingFactor;
  *(uint32_t *)(ResourceDataOffset + 0x238) = 0x3f800000;
  RatioValue = 1.0;
  if (*(int *)(SystemThreadHandle + 0x1ea0) == 1) {
    SystemOperationStatus = *(int *)(SystemThreadHandle + 0x1d50);
    SystemResourcePointer = (int *)GetSystemResourceManager(*(void* *)(SystemGlobalStatusFlags + 8),SystemStackBuffer);
    RatioValue = (float)SystemOperationStatus / (float)*SystemResourcePointer;
    ScalingFactor = RatioValue * *(float *)(ResourceDataOffset + 0x234);
    RatioValue = RatioValue * *(float *)(ResourceDataOffset + 0x238);
  }
  if (0.2 <= ScalingFactor) {
    if (1.0 <= ScalingFactor) {
      ScalingFactor = 1.0;
    }
  }
  else {
    ScalingFactor = 0.2;
  }
  *(float *)(ResourceDataOffset + 0x234) = ScalingFactor;
  ScalingFactor = 0.2;
  if ((0.2 <= RatioValue) && (ScalingFactor = RatioValue, 1.0 <= RatioValue)) {
    ScalingFactor = 1.0;
  }
  *(float *)(ResourceDataOffset + 0x238) = ScalingFactor;
  *(uint8_t *)(ResourceDataOffset + 0x22d) = 0;
  SystemOperationStatus1 = log2f();
  *(uint32_t *)(ResourceDataOffset + 0x230) = SystemOperationStatus1;
  SystemOperationStatus1 = log2f();
  *(uint32_t *)(ResourceDataOffset + 0x240) = SystemOperationStatus1;
  SystemOperationStatus1 = log2f();
  *(uint32_t *)(ResourceDataOffset + 0x244) = SystemOperationStatus1;
  SystemOperationStatus1 = log2f();
  *(uint32_t *)(ResourceDataOffset + 0x248) = SystemOperationStatus1;
  SystemOperationStatus1 = log2f();
  *(uint32_t *)(ResourceDataOffset + 0x24c) = SystemOperationStatus1;
  SystemOperationStatus1 = log2f(*(float *)(SystemNodeManagerPointer + 0x2220) * 0.01);
  *(uint32_t *)(ResourceDataOffset + 0x23c) = SystemOperationStatus1;
  *(void* *)(ResourceDataOffset + 0x254) = 0x3f8000003f800000;
  SystemMemoryPoolHandle = 0x3f8000003f800000;
  *(void* *)(ResourceDataOffset + 0x25c) = 0x3f8000003f800000;
  SystemBufferAddress = SystemDataMemoryContext;
  SystemThreadHandle = SystemAllocationFlagsTemplate;
  SystemResourcePointer = &SystemResourceTemplateSecondary;
  SystemResourceBuffer = SystemResourceDataBuffer;
  SystemResourceDataBuffer[0] = 0;
  SystemConfigurationId = 0xd;
  strcpy_s(SystemResourceDataBuffer,0x10,&SystemVersionString);
  resourceEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  SystemMemoryPoolOffset = SystemThreadHandle + 0x70;
  SystemResourceArray[0] = resourceEntryPointer;
  InitializeSystemDataMemoryContext(resourceEntryPointer,&SystemResourcePointer,3,SystemThreadHandle + 0x2e0);
  *resourceEntryPointer = &SystemValueReference;
  SystemResourceArray[0] = resourceEntryPointer;
  SetupSystemMemoryAllocator(resourceEntryPointer);
  InitializeSystemHandle(SystemThreadHandle + 0x48,SystemResourceArray);
  *(void* **)(SystemBufferAddress + 0x18) = resourceEntryPointer;
  SystemResourcePointer = &SystemMemoryAllocatorReference;
  SystemThreadStorage = &SystemStringTemplate;
  if (*(void* **)(ResourceDataOffset + 0x278) != (void* *)0x0) {
    SystemThreadStorage = *(void* **)(ResourceDataOffset + 0x278);
  }
  (**(code **)(*(long long *)(SystemInputManagerPointer + 0x560) + 0x10))
            ((long long *)(SystemInputManagerPointer + 0x560),SystemThreadStorage);
  ResourceDataOffset = SystemResourceContext;
  SystemMemoryPoolHandle = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,3);
  *(void* *)(SystemMemoryPoolHandle + 0x28) = 3;
  *(uint32_t *)(SystemMemoryPoolHandle + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
  *(void*2 *)(SystemMemoryPoolHandle + 0x1d) = 0;
  *(uint8_t *)(SystemMemoryPoolHandle + 0x1f) = 0;
  *(long long *)SystemMemoryPoolHandle = SystemMemoryPoolHandle;
  *(long long *)(SystemMemoryPoolHandle + 8) = SystemMemoryPoolHandle;
  *(void* *)(SystemMemoryPoolHandle + 0x10) = 0;
  *(uint8_t *)(SystemMemoryPoolHandle + 0x18) = 0;
  *(void* *)(SystemMemoryPoolHandle + 0x20) = 0;
  *(long long *)(ResourceDataOffset + 0xa8) = SystemMemoryPoolHandle;
  SystemResourcePoolPointer = SystemMemoryPoolHandle;
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable1,&SystemCallbackTable1,SystemCallbackHandler1);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable2,&SystemCallbackDataTable2Param,SystemCallbackHandler2);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable3,&SystemCallbackTable3,SystemCallbackHandler3);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable4,&SystemCallbackTable4,SystemCallbackHandler4);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackTable5,&SystemCallbackTable5Data,SystemCallbackHandler5);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable6,&SystemCallbackDataTable6Param,SystemCallbackHandler6);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackDataTable7,&SystemCallbackTable7Data,SystemCallbackHandler7);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackTable8,&SystemCallbackTable8Data,SystemCallbackHandler8);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemCallbackTable9,&SystemCallbackTable9Data,SystemCallbackHandler9);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemEventCallbackDataTable,&SystemEventCallbackTableData,SystemEventCallbackHandler);
  RegisterSystemCallback(*(void* *)(SystemResourceContext + 0xa8),&SystemNetworkCallbackDataTable,&SystemNetworkCallbackTableData,SystemNetworkCallbackHandler);
  hashTableNode = (uint32_t *)CreateSystemNodePointer(ResourceDataOffset + 0xe0,&SystemEventCallbackDataTable);
  *hashTableNode = 1;
  hashTableNode = (uint32_t *)CreateSystemNodePointer(ResourceDataOffset + 0xe0,&SystemCallbackDataTable3);
  *hashTableNode = 1;
  SystemResourcePoolPointer = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x3878,8,3);
    memset(SystemResourcePoolPointer,0,0x3878);
}




// 函数: void SystemMemoryManager(long long SystemResourceManager)
/**
 * @brief 系统内存管理器
 * 
 * 该函数负责管理系统内存资源，包括内存分配、释放和优化。
 * 这是内存管理系统的核心函数。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemMemoryManager(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemMemoryCleanup(long long SystemResourceManager)
/**
 * @brief 系统内存清理器
 * 
 * 该函数负责清理系统内存资源，释放不再使用的内存块。
 * 这是内存管理系统的清理函数。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemMemoryCleanup(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}





/**
 * @brief 系统数据初始化器
 * 
 * 负责初始化系统的基础数据结构和配置信息。
 * 该函数在系统启动早期阶段被调用。
 */
void SystemDataInitializer(void)

{
  void** SystemDataPointer;
  char *SystemStringPointer;
  void* resourceAllocationContext;
  long long SystemBufferAddress;
  char operationStatusFlag;
  int CalculationFlags;
  uint32_t ThreadContextFlag;
  long long SystemMemoryAddress;
  long long *presourceCounter;
  uint32_t *SystemDataPointer0;
  uint8_t SystemEncryptionBufferA8 [32];
  long long *SystemModuleContextPointerA;
  long long **SystemModuleContextPointerB;
  void* *SystemUnsignedFlagPointer;
  uint32_t *SystemProcessFlagsPointer;
  uint32_t EncryptionValue68;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  void* *memoryAllocationEnd;
  uint8_t *pSystemEncryptionKey;
  uint32_t SystemOperationCounter;
  uint8_t SystemEncryptionBufferArray [16];
  ulong long EncryptionKeyValue;
  
  SystemBufferAddress = SystemGlobalStatusFlags;
  SystemProcessFlags58 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aUnsignedStackFlagA8;
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  do {
    resourceAllocationContext = SystemAllocationFlagsTemplate;
    SystemMemoryAddress = AllocateSystemMemory(SystemAllocationFlagsTemplate);
    if (SystemMemoryAddress == 0) break;
    presourceCounter = (long long *)AllocateSystemResourceManager(resourceAllocationContext);
    operationStatusFlag = (**(code **)(*presourceCounter + 0x20))(presourceCounter,1);
  } while (operationStatusFlag != '\0');
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  SystemDataPointer = SystemSystemResourceManager;
  if (*(char *)(SystemSystemResourceManager + 7) != '\0') {
    SystemModuleContextPointerA = (long long *)0x180c91970;
    CalculationFlags = _Mtx_lock(0x180c91970);
    if (CalculationFlags != 0) {
      __Throw_C_error_std__YAXH_Z(CalculationFlags);
    }
    ReleaseSystemResource(*(void* *)*SystemDataPointer);
    ReleaseSystemResource(*(void* *)SystemDataPointer[1]);
    ReleaseSystemResourceHandle(*SystemDataPointer);
    ReleaseSystemResourceHandle(SystemDataPointer[1]);
    *(uint8_t *)(SystemDataPointer + 7) = 0;
    CalculationFlags = _Mtx_unlock(0x180c91970);
    if (CalculationFlags != 0) {
      __Throw_C_error_std__YAXH_Z(CalculationFlags);
    }
  }
  SystemDataPointer = (void* *)*SystemGlobalPointerTable;
  if (SystemDataPointer != (void* *)0x0) {
    *SystemGlobalPointerTable = 0;
    (**(code **)*SystemDataPointer)(SystemDataPointer,1);
  }
  presourceCounter = SystemModuleContextPointer;
  resourceAllocationContext = SystemAllocationFlagsTemplate;
  SystemModuleContextPointerA = SystemModuleContextPointer;
  if (SystemModuleContextPointer != (long long *)0x0) {
    InitializeSystemModule(*SystemModuleContextPointer);
    *presourceCounter = 0;
    SystemModuleContextPointerA = presourceCounter + 1;
    CleanupSystemMemoryAllocation();
      SystemCleanupFunction(presourceCounter);
  }
  SystemCleanupStatusFlag = (long long *)0x0;
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    SystemModuleContextPointerB = &SystemModuleContextPointerA;
    SystemModuleContextPointerA = SystemGlobalControllerPointer;
    (**(code **)(*SystemGlobalControllerPointer + 0x28))();
    InitializeSystemDataMemoryContext(resourceAllocationContext,&SystemModuleContextPointerA,0);
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (*(long long **)(SystemBufferAddress + 0x2b0) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemBufferAddress + 0x2b0) + 0x20))();
  }
  SystemStringPointer = *(char **)(SystemMemoryBlockStorage + 0x10);
  if (*SystemStringPointer != '\0') {
    WSACleanup();
    *pvalidationStatusFlag = '\0';
  }
  resourceAllocationContext = SystemAllocationFlagsTemplate;
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    SystemModuleContextPointerB = &SystemModuleContextPointerA;
    SystemModuleContextPointerA = SystemGlobalControllerPointer;
    (**(code **)(*SystemGlobalControllerPointer + 0x28))();
    InitializeSystemDataMemoryContext(resourceAllocationContext,&SystemModuleContextPointerA,0);
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  resourceAllocationContext = SystemAllocationFlagsTemplate;
  if (SystemGlobalControllerPointer != (long long *)0x0) {
    SystemModuleContextPointerB = &SystemModuleContextPointerA;
    SystemModuleContextPointerA = SystemGlobalControllerPointer;
    (**(code **)(*SystemGlobalControllerPointer + 0x28))();
    InitializeSystemDataMemoryContext(resourceAllocationContext,&SystemModuleContextPointerA,0);
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  memoryAllocationEnd = &SystemResourceTemplateSecondary;
  pSystemEncryptionKey = SystemEncryptionBufferArray;
  SystemEncryptionBufferArray[0] = 0;
  SystemOperationCounter = 3;
  strcpy_s(SystemEncryptionBufferArray,0x10,&SystemVersionString2);
  SystemUnsignedFlagPointer = &SystemGlobalDataReference;
  SystemThreadContext = 0;
  SystemProcessFlagsPointer = (uint32_t *)0x0;
  EncryptionValue68 = 0;
  SystemDataPointer0 = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x14,0x13);
  *(uint8_t *)SystemDataPointer0 = 0;
  SystemProcessFlagsPointer = SystemDataPointer0;
  ThreadContextFlag = StartSystemThread(SystemDataPointer0);
  *SystemDataPointer0 = 0x706d6554;
  SystemDataPointer0[1] = 0x7261726f;
  SystemDataPointer0[2] = 0x73655279;
  SystemDataPointer0[3] = 0x6372756f;
  SystemDataPointer0[4] = 0x2f7365;
  EncryptionValue68 = 0x13;
  SystemThreadContext.PrimaryField = ThreadContextFlag;
  InitializeSystemStack(&SystemUnsignedFlagPointer,&memoryAllocationEnd);
  SystemUnsignedFlagPointer = &SystemGlobalDataReference;
  if (SystemProcessFlagsPointer != (uint32_t *)0x0) {
      SystemCleanupFunction();
  }
  SystemProcessFlagsPointer = (uint32_t *)0x0;
  SystemThreadContext = (ulong long)SystemThreadContext.SecondaryField << 0x20;
  SystemUnsignedFlagPointer = &SystemMemoryAllocatorReference;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
    UpdateContextManagerSystem(SystemContextManagerPointer,&ContextManagerConfigurationData);
}





// 函数: void InitializeSystemCore(void)
/**
 * @brief 初始化系统数据结构
 * 
 * 该函数负责初始化系统的核心数据结构，包括数据表、指针数组等。
 * 它会检查系统状态，设置初始化标志，并准备系统运行所需的基础数据结构。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据结构的正确初始化
 */
void InitializeSystemDataStructures(void)

{
  long long *systemDataPointer;
  void** SystemDataTable;
  code *systemCodePointer;
  uint8_t *systemBytePointer;
  void* systemHandle;
  long long systemMemoryBase;
  int SystemOperationStatusFlag;
  long long systemCounter;
  long long **systemDoublePointer;
  void*2 *systemTypedPointer;
  uint systemIndex;
  ulong long systemTimestamp;
  float systemFloatValue;
  double systemDoubleValue1;
  double systemDoubleValue2;
  long long **stackDoublePointerX8;
  long long *stackPointerX10;
  long long *stackPointerX18;
  long long stackValueX20;
  long long stackValue90;
  long long stackValue88;
  long long stackValue80;
  long long stackValue78;
  long long ***stackTriplePointer70;
  void* stackHandle68;
  long long **stackDoublePointer60;
  void* stackHandle58;
  ulong long loopCounter;
  
  systemCounter = SystemRuntimeCounter;
  systemMemoryBase = SystemGlobalStatusFlags;
  if (SystemInitializationFlag != '\0') {
    ResetSystemMemoryManager();
    return;
  }
  stackHandle68 = 0xfffffffffffffffe;
  *(void* *)(SystemRuntimeCounter + 0x2038) = *(void* *)(SystemRuntimeCounter + 0x2030);
  systemTypedPointer = (void*2 *)(systemCounter + 0x14);
  systemCounter = 0x100;
  loopCounterValue = 0;
  do {
    *systemTypedPointer = 0;
    systemTypedPointer = systemTypedPointer + 0xc;
    systemCounter = systemCounter + -1;
  } while (systemCounter != 0);
  ReleaseGraphicsContext(SystemGraphicsContextPointer + 0x48);
  SystemPerformanceCounter1 = 0;
  SystemPerformanceCounter2 = 0;
  if (SystemDebugFlag != '\0') {
    PrimaryResourcePointer = *(long long **)(SystemThreadFlags + 8);
    ppresourceCounter = (long long **)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x48,8,3);
    *ppresourceCounter = (long long *)&SystemMemoryTemplateA;
    *ppresourceCounter = (long long *)&SystemMemoryTemplateB;
    *(uint32_t *)(ppresourceCounter + 1) = 0;
    *ppresourceCounter = (long long *)&SystemMemoryTemplateC;
    LOCK();
    *(uint8_t *)(ppresourceCounter + 2) = 0;
    UNLOCK();
    ppresourceCounter[3] = (long long *)0xffffffffffffffff;
    *ppresourceCounter = (long long *)&MemoryAllocationPool;
    *(uint32_t *)(ppresourceCounter + 5) = 4;
    ppresourceCounter[4] = PrimaryResourcePointer;
    SystemResourceTriplePointer = (long long ***)ppresourceCounter;
    ppsystemMemoryOffset = ppresourceCounter;
    (*(code *)(*ppresourceCounter)[5])(ppresourceCounter);
    SystemHashEntryPointer = (void* *)PrimaryResourcePointer[0x28];
    pathStringPointer = *(code **)*SystemHashEntryPointer;
    SystemResourceTriplePointer = &SystemResourceDoublePointerX;
    SystemResourceDoublePointerX = ppresourceCounter;
    (*(code *)(*ppresourceCounter)[5])(ppresourceCounter);
    (*pathStringPointer)(SystemHashEntryPointer,&SystemResourceDoublePointerX);
    ProcessSystemCallback(PrimaryResourcePointer[0x28]);
    (*(code *)(*ppresourceCounter)[7])(ppresourceCounter);
  }
  SystemMemoryAddress = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
  SystemOperationStatus3 = SystemSecondaryStatus;
  if (SystemMemoryAddress / 0x1c != 0) {
    do {
      ProcessSystemMemory(SystemMemoryAddress,SystemOperationStatus3 * 0x1c + *(long long *)(SystemRenderManagerPointer + 0x10));
      SystemOperationStatus1 = (int)SystemSecondaryStatus + 1;
      SystemSecondaryStatus = (ulong long)SystemOperationStatus1;
      SystemMemoryAddress = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
      SystemOperationStatus3 = (long long)(int)SystemOperationStatus1;
    } while ((ulong long)(long long)(int)SystemOperationStatus1 < (ulong long)(SystemMemoryAddress / 0x1c));
  }
  *(void* *)(SystemRenderManagerPointer + 0x18) = *(void* *)(SystemRenderManagerPointer + 0x10);
  *(uint8_t *)(*(long long *)(*(long long *)(SystemThreadFlags + 8) + 0x140) + 0x208) = 1;
  if (*(char *)(SystemThreadFlags + 0x3c8) != '\0') {
    UpdateSystemRenderManager(SystemThreadFlags);
    LOCK();
    *(uint8_t *)(SystemThreadFlags + 0x3c8) = 0;
    UNLOCK();
  }
  SystemMemoryAddress = SystemMemoryManagerPointer;
  *(void* *)(SystemMemoryManagerPointer + 4) = 0;
  *(void* *)(SystemMemoryAddress + 0xc) = 0;
  *(void* *)(SystemMemoryAddress + 0x14) = 0;
  InitializeMemoryBlock(SystemMemoryAddress + 0x20);
  InitializeMemoryBlock(SystemMemoryAddress + 0x50);
  LOCK();
  *(uint32_t *)(SystemMemoryAddress + 0x80) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(SystemMemoryAddress + 0x84) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(SystemMemoryAddress + 0x88) = 0;
  UNLOCK();
  SystemMemoryAddress = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&SystemTime20);
    SystemMemoryAddress = SystemTime20;
  }
  *(double *)(SystemThreadFlags + 0x68) = (double)(SystemMemoryAddress - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
  if (SystemMemoryFlag != '\0') {
    SystemProcessFlags58 = 0x180c91288;
    systemOffset = _Mtx_lock(0x180c91288);
    if (systemOffset != 0) {
      __Throw_C_error_std__YAXH_Z(systemOffset);
    }

/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统资源分配器，设置内存分配模板和资源指针。
 * 函数会初始化系统数据表，设置图形上下文，并配置资源分配相关的参数。
 * 
 * @param systemResourcePointer 系统资源指针，用于访问和配置系统资源
 * 
 * @note 这是系统资源管理的重要组成部分，确保资源的正确分配和初始化
 */
void InitializeSystemResourceAllocator(long long systemResourcePointer)

{
  long long *primaryResourcePointer;
  void** SystemDataTable;
  code *programCounter;
  uint8_t *systemDataPointer;
  void* systemValuePointer;
  int SystemOperationStatus;
  long long localDataIndex;
  long long **memoryAllocationPointer;
  void*2 *systemTypedPointer;
  uint systemValue10;
  ulong long systemValue12;
  float TransformValue;
  double doubleValue1;
  double doubleValue2;
  long long **stackPointer8;
  long long *stackPointer10;
  long long *stackPointer18;
  long long stackValue20;
  long long stackValue90;
  long long stackValue88;
  long long stackValue80;
  long long stackValue78;
  long long ***stackPointer70;
  void* stackValue68;
  long long **stackPointer60;
  void* stackValue58;
  ulong long loopCounter;
  
  localDataIndex = SystemRuntimeCounter;
  stackValue68 = 0xfffffffffffffffe;
  *(void* *)(SystemRuntimeCounter + 0x2038) = *(void* *)(SystemRuntimeCounter + 0x2030);
  systemTypedPointer = (void*2 *)(localDataIndex + 0x14);
  localDataIndex = 0x100;
  loopCounterValue = 0;
  do {
    *systemTypedPointer = 0;
    systemTypedPointer = systemTypedPointer + 0xc;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  ReleaseGraphicsContext(SystemGraphicsContextPointer + 0x48);
  SystemPerformanceCounter1 = 0;
  SystemPerformanceCounter2 = 0;
  if (SystemDebugFlag != '\0') {
    primaryResourcePointer = *(long long **)(systemResourcePointer + 8);
    memoryAllocationPointer = (long long **)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x48,8,3);
    *memoryAllocationPointer = (long long *)&SystemMemoryTemplateA;
    *memoryAllocationPointer = (long long *)&SystemMemoryTemplateB;
    *(uint32_t *)(memoryAllocationPointer + 1) = 0;
    *memoryAllocationPointer = (long long *)&SystemMemoryTemplateC;
    LOCK();
    *(uint8_t *)(memoryAllocationPointer + 2) = 0;
    UNLOCK();
    memoryAllocationPointer[3] = (long long *)0xffffffffffffffff;
    *memoryAllocationPointer = (long long *)&MemoryAllocationPool;
    *(uint32_t *)(memoryAllocationPointer + 5) = 4;
    memoryAllocationPointer[4] = primaryResourcePointer;
    stackPointer70 = (long long ***)memoryAllocationPointer;
    stackPointer60 = memoryAllocationPointer;
    (*(code *)(*memoryAllocationPointer)[5])(memoryAllocationPointer);
    SystemHashEntryPointer = (void* *)primaryResourcePointer[0x28];
    programCounter = *(code **)*SystemHashEntryPointer;
    stackPointer70 = &stackPointer8;
    stackPointer8 = memoryAllocationPointer;
    (*(code *)(*memoryAllocationPointer)[5])(memoryAllocationPointer);
    (*programCounter)(SystemHashEntryPointer,&stackPointer8);
    ProcessSystemCallback(primaryResourcePointer[0x28]);
    (*(code *)(*memoryAllocationPointer)[7])(memoryAllocationPointer);
  }
  localDataIndex = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
  systemValue12 = loopCounter;
  if (localDataIndex / 0x1c != 0) {
    do {
      ProcessSystemMemory(localDataIndex,systemValue12 * 0x1c + *(long long *)(SystemRenderManagerPointer + 0x10));
      systemValue10 = (int)loopCounter + 1;
      loopCounterValue = (ulong long)systemValue10;
      localDataIndex = *(long long *)(SystemRenderManagerPointer + 0x18) - *(long long *)(SystemRenderManagerPointer + 0x10);
      systemValue12 = (long long)(int)systemValue10;
    } while ((ulong long)(long long)(int)systemValue10 < (ulong long)(localDataIndex / 0x1c));
  }
  *(void* *)(SystemRenderManagerPointer + 0x18) = *(void* *)(SystemRenderManagerPointer + 0x10);
  *(uint8_t *)(*(long long *)(*(long long *)(systemResourcePointer + 8) + 0x140) + 0x208) = 1;
  if (*(char *)(systemResourcePointer + 0x3c8) != '\0') {
    UpdateSystemRenderManager(systemResourcePointer);
    LOCK();
    *(uint8_t *)(systemResourcePointer + 0x3c8) = 0;
    UNLOCK();
  }
  localDataIndex = SystemMemoryManagerPointer;
  *(void* *)(SystemMemoryManagerPointer + 4) = 0;
  *(void* *)(localDataIndex + 0xc) = 0;
  *(void* *)(localDataIndex + 0x14) = 0;
  InitializeMemoryBlock(localDataIndex + 0x20);
  InitializeMemoryBlock(localDataIndex + 0x50);
  LOCK();
  *(uint32_t *)(localDataIndex + 0x80) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(localDataIndex + 0x84) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(localDataIndex + 0x88) = 0;
  UNLOCK();
  localDataIndex = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&stackValue20);
    localDataIndex = stackValue20;
  }
  *(double *)(systemResourcePointer + 0x68) = (double)(localDataIndex - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
  if (SystemMemoryFlag != '\0') {
    stackValue58 = 0x180c91288;
    SystemOperationStatus = _Mtx_lock(0x180c91288);
    if (SystemOperationStatus != 0) {
      __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
    }

/**
 * @brief 初始化系统数据同步器
 * 
 * 该函数负责初始化系统数据同步器，处理系统数据的同步操作，
 * 包括内存分配、节点遍历和数据同步设置。
 * 
 * @param systemResourcePointer 系统资源指针，用于访问系统资源
 * @param dataSyncPointer 数据同步指针，用于数据同步操作
 * 
 * @note 这是系统数据同步管理的重要组成部分
 */
void InitializeSystemDataSynchronizer(long long systemResourcePointer,void* dataSyncPointer)

{
  long long *primaryResourcePointer;
  char CalculationFlags1;
  char CalculationFlags2;
  int SystemOperationStatus;
  uint32_t systemValue5;
  uint8_t *systemDataPointer;
  void** SystemCurrentNode;
  void** SystemNextNode;
  long long resourceCounter;
  uint systemValue10;
  long long resourceDataIndex2;
  ulong long systemValue13;
  long long *primaryResourcePointer4;
  float TransformValueC;
  void* systemValue16;
  float TransformValueB;
  uint8_t systemBuffer348 [32];
  long long **stackPointer328;
  void* *stackPointer320;
  uint32_t stackValue318;
  void* stackValue308;
  char stackFlag300;
  char SystemSyncBuffer [7];
  long long *stackPointer2f8;
  uint32_t stackValue2f0;
  void* *stackPointer2e8;
  void* *stackPointer2e0;
  uint32_t stackValue2d8;
  void* stackValue2d0;
  uint32_t StackBuffer2c8 [2];
  long long *stackPointer2c0;
  void* stackValue2b8;
  void* StackBuffer2a8 [67];
  long long StackBuffer90 [3];
  uint32_t stackValue78;
  ulong long stackValue68;
  ulong long systemValue11;
  
  stackValue2b8 = 0xfffffffffffffffe;
  stackValue68 = SystemEncryptionKeyTemplate ^ (ulong long)systemBuffer348;
  floatValue = (float)dataSyncPointer;
  SystemPerformanceAccumulator1 = (long long)(floatValue * 100000.0);
  SystemPerformanceAccumulator2 = SystemPerformanceAccumulator2 + SystemPerformanceAccumulator1;
  SystemPerformanceValue = floatValue;
  systemValue16 = GetSystemStatusFlags();
  systemValue16 = SynchronizeSystemData(systemValue16,dataSyncPointer);
  CalculationFlags1 = CheckSystemFlag(systemValue16,0x52);
  CalculationFlags2 = CheckSystemFlag(1,0x51);
  resourceDataIndex2 = 0xe0;
  if (CalculationFlags2 == '\0') {
    if (CalculationFlags1 == '\0') goto SystemValidation;
  }
  else {

/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，处理资源的分配和管理。
 * 函数会设置系统数据表，管理资源偏移量，并配置系统参数。
 * 
 * @param systemResourcePointer 系统资源指针，用于访问和配置系统资源
 * 
 * @note 这是系统资源管理的重要组成部分，确保资源的正确管理和分配
 */
void InitializeSystemResourceManager(long long systemResourcePointer)

{
  int *integerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long SystemMemoryBaseAddress;
  
  SystemHashEntryPointer = *(void* **)(systemResourcePointer + TRANSFORM_CONTEXT_OFFSET_218);
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 系统资源复制器
 * 
 * 该函数负责复制系统资源，包括内存分配、数据复制和资源管理。
 * 它会创建新的系统资源对象，并复制源资源的所有属性和数据。
 * 
 * @param SystemResourceManager 目标资源指针
 * @param ConfigurationDataPointer 源资源指针
 * @return 返回复制后的资源指针
 */
void* * SystemResourceCopier(void* *SystemResourceManager,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  long long SystemThreadFlags;
  uint8_t *hashTableNode;
  long long SystemMemoryAddress;
  ulong long ThreadContextFlag;
  
  hashTableNode = (uint8_t *)((long long)SystemResourceManager + 0xf);
  *SystemResourceManager = *ConfigurationDataPointer;
  *(uint32_t *)(SystemResourceManager + 1) = *(uint32_t *)(ConfigurationDataPointer + 1);
  *(uint8_t *)((long long)SystemResourceManager + 0xc) = *(uint8_t *)((long long)ConfigurationDataPointer + 0xc);
  *(uint8_t *)((long long)SystemResourceManager + 0xd) = *(uint8_t *)((long long)ConfigurationDataPointer + 0xd);
  *(uint8_t *)((long long)SystemResourceManager + 0xe) = *(uint8_t *)((long long)ConfigurationDataPointer + 0xe);
  SystemThreadFlags = 0x100;
  do {
    *hashTableNode = hashTableNode[(long long)ConfigurationDataPointer - (long long)SystemResourceManager];
    hashTableNode[1] = hashTableNode[((long long)ConfigurationDataPointer - (long long)SystemResourceManager) + 1];
    hashTableNode = hashTableNode + 2;
    SystemThreadFlags = SystemThreadFlags + -1;
  } while (SystemThreadFlags != 0);
  *(uint8_t *)((long long)SystemResourceManager + 0x20f) = *(uint8_t *)((long long)ConfigurationDataPointer + 0x20f);
  PrimaryResourcePointer = SystemResourceManager + 0x43;
  *(uint8_t *)(SystemResourceManager + 0x42) = *(uint8_t *)(ConfigurationDataPointer + 0x42);
  *(uint8_t *)((long long)SystemResourceManager + 0x211) = *(uint8_t *)((long long)ConfigurationDataPointer + 0x211);
  if (PrimaryResourcePointer != ConfigurationDataPointer + 0x43) {
    SystemThreadFlags = *PrimaryResourcePointer;
    SystemThreadHandle = ConfigurationDataPointer[0x44];
    ResourceDataOffset = ConfigurationDataPointer[0x43];
    SystemMemoryAddress = SystemThreadHandle - ResourceDataOffset;
    ThreadContextFlag = SystemMemoryAddress >> 2;
    if ((ulong long)(SystemResourceManager[0x45] - SystemThreadFlags >> 2) < ThreadContextFlag) {
      if (ThreadContextFlag == 0) {
        SystemThreadFlags = 0;
      }
      else {
        SystemThreadFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,ThreadContextFlag * 4,*(uint8_t *)(SystemResourceManager + 0x46));
      }
      if (ResourceDataOffset != SystemThreadHandle) {
          memmove(SystemThreadFlags,ResourceDataOffset,SystemMemoryAddress);
      }
      if (*PrimaryResourcePointer != 0) {
          SystemCleanupFunction();
      }
      SystemThreadHandle = SystemThreadFlags + ThreadContextFlag * 4;
      *PrimaryResourcePointer = SystemThreadFlags;
      SystemResourceManager[0x44] = SystemThreadHandle;
      SystemResourceManager[0x45] = SystemThreadHandle;
    }
    else {
      SystemBufferAddress = SystemResourceManager[0x44];
      currentThreadId = SystemBufferAddress - SystemThreadFlags >> 2;
      if (currentThreadId < ThreadContextFlag) {
        SystemMemoryAddress = currentThreadId * 4 + ResourceDataOffset;
        if (ResourceDataOffset != SystemMemoryAddress) {
            memmove(SystemThreadFlags,ResourceDataOffset);
        }
        if (SystemMemoryAddress != SystemThreadHandle) {
            memmove(SystemBufferAddress,SystemMemoryAddress,SystemThreadHandle - SystemMemoryAddress);
        }
        SystemResourceManager[0x44] = SystemBufferAddress;
      }
      else {
        if (ResourceDataOffset != SystemThreadHandle) {
            memmove(SystemThreadFlags,ResourceDataOffset,SystemMemoryAddress);
        }
        SystemResourceManager[0x44] = SystemThreadFlags;
      }
    }
  }
  return SystemResourceManager;
}





// 函数: void SystemResourceManager(long long SystemResourceManager)
/**
 * @brief 系统资源管理器
 * 
 * 该函数负责管理系统资源的分配和释放。
 * 这是资源管理系统的核心函数。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemResourceManager(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long in_RAX;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  long long *threadContextPointer;
  long long *threadDataPointer;
  long long SystemTimeValue;
  ulong long ResourceHash;
  
  resourceDataIndex = StringIteratorPointer[1];
  SystemThreadHandle = *StringIteratorPointer;
  localSystemPointer = resourceDataIndex - SystemThreadHandle;
  ResourceHash = localSystemPointer >> 2;
  if ((ulong long)(in_RAX - SystemResourceManager >> 2) < ResourceHash) {
    if (ResourceHash == 0) {
      ResourceDataOffset = 0;
    }
    else {
      ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHash * 4,(char)systemDataIndexPtr[3]);
    }
    if (SystemThreadHandle != resourceDataIndex) {
        memmove(ResourceDataOffset,SystemThreadHandle,localSystemPointer);
    }
    if (*systemDataIndexPtr != 0) {
        SystemCleanupFunction();
    }
    resourceDataIndex = ResourceDataOffset + ResourceHash * 4;
    *systemDataIndexPtr = ResourceDataOffset;
    systemDataIndexPtr[1] = resourceDataIndex;
    systemDataIndexPtr[2] = resourceDataIndex;
  }
  else {
    ResourceDataOffset = systemDataIndexPtr[1];
    resourceAddress = ResourceDataOffset - SystemResourceManager >> 2;
    if (resourceAddress < ResourceHash) {
      localSystemPointer = resourceAddress * 4 + SystemThreadHandle;
      if (SystemThreadHandle != localSystemPointer) {
          memmove(SystemResourceManager,SystemThreadHandle);
      }
      if (localSystemPointer != resourceDataIndex) {
          memmove(ResourceDataOffset,localSystemPointer,resourceDataIndex - localSystemPointer);
      }
      systemDataIndexPtr[1] = ResourceDataOffset;
    }
    else {
      if (SystemThreadHandle != resourceDataIndex) {
          memmove(SystemResourceManager,SystemThreadHandle,localSystemPointer);
      }
      systemDataIndexPtr[1] = SystemResourceManager;
    }
  }
  return;
}



/**
 * @brief 系统内存配置器
 * 
 * 负责配置系统内存管理相关的参数和设置。
 * 该函数确保内存分配器能够正确工作。
 */
void SystemMemoryConfigurator(void)

{
  long long MemoryBufferPointer;
  long long SystemHandle;
  long long StackBasePointer;
  long long MemorySizePointer;
  long long *ResourceArrayPointer;
  long long AllocationSize;
  
  if (AllocationSize == 0) {
    SystemHandle = 0;
  }
  else {
    SystemHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,AllocationSize * 4,(char)ResourceArrayPointer[3]);
  }
  if (MemorySizePointer != StackBasePointer) {
      memmove(SystemHandle);
  }
  if (*ResourceArrayPointer != 0) {
      SystemCleanupFunction();
  }
  MemoryBufferPointer = SystemHandle + AllocationSize * 4;
  *ResourceArrayPointer = SystemHandle;
  ResourceArrayPointer[1] = MemoryBufferPointer;
  ResourceArrayPointer[2] = MemoryBufferPointer;
  return;
}




// 函数: void SystemResourceHandler(long long SystemResourceManager)
/**
 * @brief 系统资源处理器
 * 
 * 该函数负责处理系统资源的具体操作。
 * 这是资源处理系统的核心函数。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemResourceHandler(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  long long systemStackFramePtr;
  long long StringIteratorPointer;
  long long systemDataIndexPtr;
  ulong long systemResourceCounter;
  
  SystemThreadHandle = *(long long *)(systemDataIndexPtr + 8);
  resourceAllocationContext = SystemThreadHandle - SystemResourceManager >> 2;
  if (resourceAllocationContext < systemResourceCounter) {
    resourceDataIndex = resourceAllocationContext * 4 + StringIteratorPointer;
    if (StringIteratorPointer != resourceDataIndex) {
        memmove();
    }
    if (resourceDataIndex != systemStackFramePtr) {
        memmove(SystemThreadHandle,resourceDataIndex,systemStackFramePtr - resourceDataIndex);
    }
    *(long long *)(systemDataIndexPtr + 8) = SystemThreadHandle;
  }
  else {
    if (StringIteratorPointer != systemStackFramePtr) {
        memmove();
    }
    *(long long *)(systemDataIndexPtr + 8) = SystemResourceManager;
  }
  return;
}




// 函数: void SystemContextInitializer(void)
/**
 * @brief 系统上下文初始化器
 * 
 * 该函数负责初始化系统上下文环境。
 * 这是上下文管理系统的初始化函数。
 */
void SystemContextInitializer(void)

{
  return;
}



/**
 * @brief 系统资源验证器
 * 
 * 该函数验证系统资源的有效性和完整性。
 * 它会检查资源的状态、属性和关联数据，确保资源处于可用状态。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 返回验证结果，true表示资源有效，false表示资源无效
 */
bool SystemResourceValidator(long long SystemResourceManager)

{
  void** SystemDataPointer;
  byte byteValue;
  bool isValidOperation;
  byte *stringPointer;
  uint currentThreadId;
  int CalculationFlags;
  long long localDataIndex;
  void** SystemNextNode;
  void* *SystemHashBucket;
  void* *SystemDataPointer0;
  void* *ThreadLocalStorage;
  void* *pointerUnsigned30;
  byte *SystemByteBuffer28;
  int SystemInteger20;
  
  SystemDataPointer = (void* *)(SystemResourceManager + 0x2e0);
  SetupSystemMemory(&pointerUnsigned30);
  SystemThreadStorage = *(void* **)(SystemResourceManager + 0x2f0);
  ThreadLocalStorage = SystemDataPointer;
  if (SystemThreadStorage != (void* *)0x0) {
    do {
      if (SystemInteger20 == 0) {
        isValidOperation = false;
        SystemHashBucket = (void* *)SystemThreadStorage[1];
      }
      else {
        if (*(int *)(SystemThreadStorage + 6) == 0) {
          isValidOperation = true;
        }
        else {
          stringPointer = SystemByteBuffer28;
          do {
            currentThreadId = (uint)stringPointer[SystemThreadStorage[5] - (long long)SystemByteBuffer28];
            CalculationFlags = *stringPointer - currentThreadId;
            if (*stringPointer != currentThreadId) break;
            stringPointer = stringPointer + 1;
          } while (currentThreadId != 0);
          isValidOperation = 0 < CalculationFlags;
          if (CalculationFlags < 1) {
            SystemHashBucket = (void* *)SystemThreadStorage[1];
            goto SystemValidationCheck;
          }
        }
        SystemHashBucket = (void* *)*SystemThreadStorage;
      }
SystemValidationCheck:
      SystemDataPointer0 = SystemThreadStorage;
      if (isValidOperation) {
        SystemDataPointer0 = ThreadLocalStorage;
      }
      SystemThreadStorage = SystemHashBucket;
      ThreadLocalStorage = SystemDataPointer0;
    } while (SystemHashBucket != (void* *)0x0);
    if (SystemDataPointer0 != SystemDataPointer) {
      if (*(int *)(SystemDataPointer0 + 6) == 0) goto SystemValueValidation;
      if (SystemInteger20 != 0) {
        stringPointer = (byte *)SystemDataPointer0[5];
        localDataIndex = (long long)SystemByteBuffer28 - (long long)stringPointer;
        do {
          byteValue = *stringPointer;
          currentThreadId = (uint)stringPointer[localDataIndex];
          if (byteValue != currentThreadId) break;
          stringPointer = stringPointer + 1;
        } while (currentThreadId != 0);
        if ((int)(byteValue - currentThreadId) < 1) goto SystemValueValidationCheck;
      }
    }
  }
  SystemDataPointer0 = SystemDataPointer;
SystemValueValidationCheck:
  pointerUnsigned30 = &SystemGlobalDataReference;
  if (SystemByteArray28 == (byte *)0x0) {
    return SystemDataPointer0 != SystemDataPointer;
  }
    SystemCleanupFunction();
}




void*
/**
 * @brief 系统状态标志处理器
 * 
 * 该函数处理系统状态标志的操作，包括设置、清除和查询状态标志。
 * 它会调用底层的系统函数来处理状态标志的相关操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递操作目标
 * @param AdditionalParameter 参数3，用于传递操作参数
 * @param ConfigurationFlag 参数4，用于传递操作标志
 * @return 返回处理后的结果指针
 */
void* SystemStatusFlagProcessor(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  CreateSystemObject(ConfigurationDataPointer,SystemGlobalStatusFlags + 0x2c0,AdditionalParameter,ConfigurationFlag,0,InvalidHandleValue);
  return ConfigurationDataPointer;
}





// 函数: void SystemDataProcessor(long long SystemResourceManager)
/**
 * @brief 系统数据处理器
 * 
 * 该函数负责处理系统数据的操作和管理。
 * 这是数据处理系统的核心函数。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemDataProcessor(long long SystemResourceManager)

{
  void** SystemDataPointer;
  int systemResult;
  uint8_t aEncryptionOffset1 [32];
  uint32_t SystemInitializationStatus;
  void* systemDataBuffer;
  long long SystemResourceManagerHandle;
  uint8_t SystemUnsignedStackFlagA8 [128];
  ulong long EncryptionKeyValue;
  
  systemDataBuffer = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aEncryptionOffset1;
  SystemInitializationStatus = 0;
  SystemResourceManagerHandle = SystemResourceManager;
  CreateSystemObject(SystemResourceManager,SystemGlobalStatusFlags + 0x170);
  SystemInitializationStatus = 1;
  systemResult = *(int *)(SystemResourceManager + 0x10) + 8;
  ExecuteSystemCommand(SystemResourceManager,systemResult);
  SystemDataPointer = (void* *)((ulong long)*(uint *)(SystemResourceManager + 0x10) + *(long long *)(SystemResourceManager + 8));
  *SystemDataPointer = 0x2f73656873617263;
  *(uint8_t *)(SystemDataPointer + 1) = 0;
  *(int *)(SystemResourceManager + 0x10) = systemResult;
    memset(aUnsignedStackFlagA8,0,0x80);
}





// 函数: void SystemMemoryAllocator(long long SystemResourceManager,long long parameter2,void* parameter3,void* parameter4)
/**
 * @brief 系统内存分配器
 * 
 * 该函数负责分配系统内存资源。
 * 这是内存分配系统的核心函数。
 * 
 * @param resourceManagerPointer 系统资源指针
 * @param allocationSize 分配大小
 * @param memoryPool 内存池
 * @param SystemAllocationFlags 分配标志
 */
void SystemMemoryAllocator(long long resourceManagerPointer,long long allocationSize,void* memoryPool,void* SystemAllocationFlags)

{
  long long *PrimaryResourcePointer;
  uint32_t resourceCreationFlags;
  int NodeIdentifierComparisonResult;
  void* *presourceAddress;
  ulong long currentThreadId;
  long long SystemThreadFlags;
  void* ThreadContextFlag;
  void* *pStackParameterC;
  void* *pUnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  void* SystemUnsignedFlag78;
  void* *SystemProcessFlagsPointer;
  void* *pEncryptionValue68;
  uint32_t SystemThreadContext;
  void* SystemProcessFlags58;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  PrimaryResourcePointer = (long long *)(SystemResourceManager + 0xd8);
  SystemThreadFlags = 0;
  if ((*(long long *)(SystemResourceManager + 0xe0) - *PrimaryResourcePointer & MAX_UNSIGNED_32_BITffffffe0U) != 0) {
    InitializeConfigurationData(ConfigurationDataPointer);
    currentThreadId = *(long long *)(SystemResourceManager + 0xe0) - *PrimaryResourcePointer >> 5;
    if (0 < (int)currentThreadId) {
      currentThreadId = currentThreadId & MAX_UNSIGNED_32_BIT;
      do {
        if (*(ulong long *)(ConfigurationDataPointer + 8) < *(ulong long *)(ConfigurationDataPointer + 0x10)) {
          *(ulong long *)(ConfigurationDataPointer + 8) = *(ulong long *)(ConfigurationDataPointer + 8) + 0x20;
          InitializeSystemMemoryAllocator();
        }
        else {
          ProcessSystemConfiguration(ConfigurationDataPointer,*PrimaryResourcePointer + SystemThreadFlags);
        }
        SystemThreadFlags = SystemThreadFlags + 0x20;
        currentThreadId = currentThreadId - 1;
      } while (currentThreadId != 0);
    }
    return;
  }
  SystemProcessFlagsPointer = &SystemGlobalDataReference;
  SystemProcessFlags58 = 0;
  pEncryptionValue68 = (void* *)0x0;
  SystemThreadContext = 0;
  presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,ConfigurationFlag,InvalidHandleValue);
  *(uint8_t *)presourceAddress = 0;
  pEncryptionValue68 = presourceAddress;
  resourceCreationFlags = StartSystemThread(presourceAddress);
  SystemProcessFlags58 = ConcatenatedValue44(SystemProcessFlags58.HighPart,resourceCreationFlags);
  *presourceAddress = 0x53454c55444f4d5f;
  *(void*2 *)(presourceAddress + 1) = 0x2a5f;
  *(uint8_t *)((long long)presourceAddress + 10) = 0;
  SystemThreadContext = 10;
  systemCounter = GetSystemCounter(SystemResourceManager + 0x2c0,&SystemProcessFlagsPointer);
  if (-1 < systemCounter) {
    pSystemConfigurationValue = &SystemGlobalDataReference;
    SystemUnsignedFlag78 = 0;
    pUnsignedStackFlag88 = (void* *)0x0;
    UnsignedStackFlag80 = 0;
    presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,ConfigurationFlag,ThreadContextFlag);
    *(uint8_t *)presourceAddress = 0;
    pUnsignedStackFlag88 = presourceAddress;
    resourceCreationFlags = StartSystemThread(presourceAddress);
    SystemUnsignedFlag78 = ConcatenatedValue44(SystemUnsignedFlag78.HighPart,resourceCreationFlags);
    *presourceAddress = 0x454c55444f4d5f2a;
    *(void*2 *)(presourceAddress + 1) = 0x5f53;
    *(uint8_t *)((long long)presourceAddress + 10) = 0;
    UnsignedStackFlag80 = 10;
    GetSystemCounter(SystemResourceManager + 0x2c0,&pStackParameterC);
    pSystemConfigurationValue = &SystemGlobalDataReference;
      SystemCleanupFunction(presourceAddress);
  }
  SystemProcessFlagsPointer = &SystemGlobalDataReference;
    SystemCleanupFunction(presourceAddress);
}




/**
 * @brief 系统资源分配器
 * 
 * 该函数负责分配系统资源，包括内存分配、线程创建和资源初始化。
 * 它会创建必要的系统资源对象，并设置相应的属性和状态。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递分配参数
 * @return 返回分配后的资源指针
 */
void* SystemResourceAllocator(void* SystemResourceManager,void* ConfigurationDataPointer)

{
  long long resourceDataIndex;
  uint32_t resourceCreationFlags;
  int NodeIdentifierComparisonResult;
  void* *presourceAddress;
  void* *pUnsignedStackFlag88;
  void* *SystemStatusFlagPointer;
  uint32_t SystemUnsignedFlag78;
  void* SystemProcessFlags70;
  void* *pEncryptionValue68;
  void* *systemContextPointer;
  uint32_t SystemProcessFlags58;
  void* ConcatenatedValue44;
  
  resourceDataIndex = SystemGlobalStatusFlags;
  if (*(int *)(SystemGlobalStatusFlags + 200) != 0) {
    CreateSystemObject(ConfigurationDataPointer,SystemGlobalStatusFlags + 0xb8);
    return ConfigurationDataPointer;
  }
  pEncryptionValue68 = &SystemGlobalDataReference;
  ConcatenatedValue44 = 0;
  pSystemThreadContext = (void* *)0x0;
  SystemProcessFlags58 = 0;
  presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
  *(uint8_t *)presourceAddress = 0;
  pSystemThreadContext = presourceAddress;
  resourceCreationFlags = StartSystemThread(presourceAddress);
  ConcatenatedValue44 = ConcatenatedValue44(ThreadContextFlag._4_4_,resourceCreationFlags);
  *presourceAddress = 0x53454c55444f4d5f;
  *(void*2 *)(presourceAddress + 1) = 0x2a5f;
  *(uint8_t *)((long long)presourceAddress + 10) = 0;
  SystemProcessFlags58 = 10;
  systemCounter = GetSystemCounter(resourceDataIndex + 0x2c0,&pEncryptionValue68);
  if (-1 < systemCounter) {
    pUnsignedStackFlag88 = &SystemGlobalDataReference;
    SystemProcessFlags70 = 0;
    SystemStatusFlagPointer = (void* *)0x0;
    SystemUnsignedFlag78 = 0;
    presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
    *(uint8_t *)presourceAddress = 0;
    SystemStatusFlagPointer = presourceAddress;
    resourceCreationFlags = StartSystemThread(presourceAddress);
    SystemProcessFlags70 = ConcatenatedValue44(SystemProcessFlags70.HighPart,resourceCreationFlags);
    *presourceAddress = 0x454c55444f4d5f2a;
    *(void*2 *)(presourceAddress + 1) = 0x5f53;
    *(uint8_t *)((long long)presourceAddress + 10) = 0;
    SystemUnsignedFlag78 = 10;
    GetSystemCounter(resourceDataIndex + 0x2c0,&pUnsignedStackFlag88);
    pUnsignedStackFlag88 = &SystemGlobalDataReference;
      SystemCleanupFunction(presourceAddress);
  }
  pEncryptionValue68 = &SystemGlobalDataReference;
    SystemCleanupFunction(presourceAddress);
}





// 函数: void SystemFloatingPointProcessor(long long SystemResourceManager,float parameter2,void* parameter3,void* parameter4)
/**
 * @brief 系统浮点数处理器
 * 
 * 该函数负责处理系统中的浮点数运算。
 * 这是浮点数处理系统的核心函数。
 * 
 * @param resourceManagerPointer 系统资源指针
 * @param floatValue 浮点数值
 * @param processingContext 处理上下文
 * @param operationFlags 操作标志
 */
void SystemFloatingPointProcessor(long long resourceManagerPointer,float floatValue,void* processingContext,void* operationFlags)

{
  ulong long SystemOperationStatus;
  float calculationResult1;
  float calculationResult2;
  ulong long threadContextValue;
  ulong long currentThreadId;
  int CalculationFlags;
  uint renderStatusValue1;
  long long SystemMemoryAddress;
  uint renderStatusValue2;
  void* contextParameter;
  long long SystemAllocationFlags;
  uint renderStatus3;
  uint renderStatus4;
  uint renderStatus5;
  bool isSystemConfigured;
  float scaleFactorX;
  float scaleFactorY;
  float InterpolationFactor1;
  float InterpolationFactor2;
  float InterpolationFactor3;
  float InterpolationFactor4;
  uint32_t ThreadCreationFlags;
  float InterpolationFactor5;
  float scaleResult1;
  float scaleResult2;
  
  SystemMemoryAddress = SystemNodeManagerPointer;
  if ((*(long long *)(SystemDataMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemNodeManagerPointer + 0x540) < 1)) {
    isSystemConfigured = *(int *)(SystemNodeManagerPointer + 0x2140) != 0;
  }
  else {
    isSystemConfigured = false;
  }
  if (isSystemConfigured) {
    scaleFactorX = (float)exp2f(SystemNodeManagerPointer,contextParameter,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    if (*(char *)(SystemResourceManager + 0x22d) == '\0') {
      SystemMemoryAddress = *(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
      if ((*(int *)(SystemMemoryAddress + 0x48) < SystemDataValue1) &&
         (CheckSystemDataAvailability(&SystemDataValue1), SystemDataValue1 == -1)) {
        SystemDataValue2 = ConfigurationDataPointer;
        InitializeSystemDataPointer(&SystemDataValue1);
      }
      calculationResult1 = (float)exp2f();
      InterpolationFactor1 = (float)exp2f();
      InterpolationFactor2 = (float)exp2f();
      InterpolationFactor3 = (float)exp2f();
      InterpolationFactor4 = (float)exp2f();
      SystemDataValue2 = (1.0 - calculationResult1) * SystemDataValue2 + calculationResult1 * ConfigurationDataPointer;
      calculationResult2 = (float)*(int *)(SystemNodeManagerPointer + 0x21b0);
      if (*(float *)(SystemGlobalStatusFlags + 0x1f8) <= (float)*(int *)(SystemNodeManagerPointer + 0x21b0)) {
        calculationResult2 = *(float *)(SystemGlobalStatusFlags + 0x1f8);
      }
      InterpolationFactor5 = *(float *)(SystemNodeManagerPointer + 0x1e30);
      if (0 < *(int *)(SystemNodeManagerPointer + 0x1f80)) {
        InterpolationFactor5 = InterpolationFactor5 / (float)*(int *)(SystemNodeManagerPointer + 0x1f80);
      }
      scaleFactorY = (float)((int)InterpolationFactor5 + -1);
      if (calculationResult2 <= (float)((int)InterpolationFactor5 + -1)) {
        scaleFactorY = calculationResult2;
      }
      if ((*(int *)(SystemMemoryAddress + 0x48) < SystemDataValue3) &&
         (CheckSystemDataAvailability(&SystemDataValue3), SystemDataValue3 == -1)) {
        SystemDataValue4 = scaleFactorY;
        InitializeSystemDataPointer(&SystemDataValue3);
      }
      SystemDataValue4 = (1.0 - calculationResult1) * SystemDataValue4 + scaleFactorY * calculationResult1;
      InterpolationParam2 = ((float)(int)((SystemDataValue2 / SystemDataValue4) / InterpolationParam1) * InterpolationParam1 - 1.0) * InterpolationParam2 *
               InterpolationParam3 + InterpolationParam2;
      if (InterpolationParam2 <= scaleResult1) {
        InterpolationParam2 = scaleResult1;
      }
      if (1.0 <= InterpolationParam2) {
        InterpolationParam2 = 1.0;
      }
      InterpolationParam4 = (float)(int)((InterpolationParam2 + 0.05) / InterpolationParam4) * InterpolationParam4;
      if ((scaleResult1 <= InterpolationParam4) && (scaleResult1 = InterpolationParam4, 1.0 <= InterpolationParam4)) {
        scaleResult1 = 1.0;
      }
      *(float *)(SystemResourceManager + 0x238) = scaleResult1;
      ThreadCreationFlags = log2f();
      *(uint32_t *)(SystemResourceManager + 0x248) = ThreadCreationFlags;
      *(float *)(SystemResourceManager + 0x250) = SystemDataValue2;
      SystemAllocationFlags = SystemRenderManagerPointer;
      *(uint8_t *)(SystemRenderManagerPointer + 0x162b) = 1;
      SystemMemoryAddress = SystemNodeManagerPointer;
    }
    else {
      *(float *)(SystemResourceManager + 0x238) = scaleResult1;
      SystemMemoryAddress = SystemNodeManagerPointer;
      SystemAllocationFlags = SystemRenderManagerPointer;
    }
  }
  else {
    *(uint32_t *)(SystemResourceManager + 0x238) = 0x3f800000;
    SystemAllocationFlags = SystemRenderManagerPointer;
  }
  if ((*(long long *)(SystemDataMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemMemoryAddress + 0x540) < 1)) {
    if (*(int *)(SystemMemoryAddress + 0x2140) == 0) {
      scaleResult1 = *(float *)(SystemMemoryAddress + 0x20d0);
    }
    else {
      scaleResult1 = 100.0;
    }
    scaleResult1 = scaleResult1 * 0.01;
  }
  else {
    scaleResult1 = 1.0;
  }
  *(float *)(SystemResourceManager + 0x234) = scaleResult1;
  renderStatus3 = (uint)*(float *)(SystemAllocationFlags + 0x17ec);
  renderStatus5 = (uint)*(float *)(SystemAllocationFlags + 0x17f0);
  renderStatus4 = renderStatus3;
  renderStatusValue1 = renderStatus5;
  if (1.0 <= scaleResult1) {
    scaleResult1 = 1.0;
    scaleResult2 = 1.0;
  }
  else {
    while (0 < (int)renderStatusValue1) {
      renderStatusValue2 = (int)renderStatus4 % (int)renderStatusValue1;
      renderStatus4 = renderStatusValue1;
      renderStatusValue1 = renderStatusValue2;
    }
    CalculationFlags = (int)renderStatus3 / (int)renderStatus4;
    scaleResult1 = (float)(int)renderStatus3;
    do {
      renderStatus3 = (uint)(scaleResult1 * scaleResult1);
      if (1 < CalculationFlags) {
        renderStatus3 = ((renderStatus3 - 1) - (int)(renderStatus3 - 1) % CalculationFlags) + CalculationFlags;
      }
      SystemOperationStatus = (long long)(int)(((int)renderStatus5 / (int)renderStatus4) * renderStatus3) / (long long)CalculationFlags;
      renderStatusValue1 = (uint)SystemOperationStatus;
      if (((renderStatus3 & 1) == 0) && ((SystemOperationStatus & 1) == 0)) goto SystemFlagHandlerCheck;
      scaleResult1 = scaleResult1 + 0.01;
      *(float *)(SystemResourceManager + 0x234) = scaleResult1;
    } while (scaleResult1 <= 1.0);
    *(uint32_t *)(SystemResourceManager + 0x234) = 0x3f800000;
SystemFlagHandlerCheck:
    scaleResult1 = (float)(int)renderStatus3 / scaleResult1;
    scaleResult2 = (float)(int)renderStatusValue1 / (float)(int)renderStatus5;
    renderStatus5 = renderStatusValue1;
  }
  *(ulong long *)(SystemResourceManager + 0x254) = ConcatenatedValue44(scaleResult2,scaleResult1);
  scaleResult1 = *(float *)(SystemResourceManager + 0x238);
  if (1.0 <= scaleResult1) {
    scaleResult1 = 1.0;
    scaleResult2 = 1.0;
  }
  else {
    currentThreadId = (ulong long)renderStatus5;
    SystemOperationStatus = (ulong long)renderStatus3;
    renderStatus4 = renderStatus3;
    renderStatusValue1 = renderStatus5;
    while (threadContextValue = currentThreadId, 0 < (int)renderStatusValue1) {
      renderStatus4 = (uint)threadContextValue;
      SystemOperationStatus = (long long)(int)SystemOperationStatus % (long long)(int)renderStatus4;
      renderStatusValue1 = (uint)SystemOperationStatus;
      currentThreadId = SystemOperationStatus & MAX_UNSIGNED_32_BIT;
      SystemOperationStatus = threadContextValue;
    }
    CalculationFlags = (int)renderStatus3 / (int)renderStatus4;
    do {
      renderStatusValue1 = (uint)(scaleResult1 * (float)(int)renderStatus3);
      if (1 < CalculationFlags) {
        renderStatusValue1 = ((renderStatusValue1 - 1) - (int)(renderStatusValue1 - 1) % CalculationFlags) + CalculationFlags;
      }
      SystemOperationStatus = (long long)(int)(((int)renderStatus5 / (int)renderStatus4) * renderStatusValue1) / (long long)CalculationFlags;
      if (((renderStatusValue1 & 1) == 0) && ((SystemOperationStatus & 1) == 0)) goto SystemFlagHandler;
      scaleResult1 = scaleResult1 + 0.01;
      *(float *)(SystemResourceManager + 0x238) = scaleResult1;
    } while (scaleResult1 <= 1.0);
    *(uint32_t *)(SystemResourceManager + 0x238) = 0x3f800000;
SystemFlagHandler:
    scaleResult1 = (float)(int)renderStatusValue1 / (float)(int)renderStatus3;
    scaleResult2 = (float)(int)SystemOperationStatus / (float)(int)renderStatus5;
  }
  *(ulong long *)(SystemResourceManager + 0x25c) = ConcatenatedValue44(scaleResult2,scaleResult1);
  return;
}





/**
 * @brief 系统资源和渲染管理处理函数
 * 
 * 该函数负责处理系统资源和渲染管理的复杂逻辑，包括：
 * - 检查系统节点管理器的状态标志
 * - 处理渲染管理器的数据缓冲区
 * - 管理内存分配和资源处理
 * - 计算和调整缩放因子
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ResourceData 资源数据指针
 * @param RenderConfig 渲染配置指针
 * @param OperationFlags 操作标志
 */
void ProcessSystemResourceAndRenderManagement(long long* SystemResourceManager,void* ResourceData,void* RenderConfig,uint8_t OperationFlags)
{
  int SystemOperationStatusValue;
  long long systemHandle;
  long long renderManagerOffset;
  void* memoryAllocationHandle;
  long long *systemResourcePointer;
  int *resourceCountPointer;
  long long dataBufferPointer;
  ulong long loopCounter;
  uint itemCounter;
  ulong long maxItemCount;
  float scaleFactor1;
  float scaleFactor2;
  long long *StackParameter1;
  long long *StackParameter2;
  long long **StackParameter3;
  long long localBuffer1 [2];
  void* *localBuffer2;
  void* *localBuffer3;
  long long localBuffer4 [2];
  void* *localBuffer5;
  void* *localBuffer6;
  
  systemHandle = SystemGlobalStatusFlags;
  SystemResourceHandle = SystemResourceManager;
  if (*(int *)(SystemNodeManagerPointer + 0xd94) != *(int *)(SystemNodeManagerPointer + 0xd90)) {
    ProcessSystemResourceOperation(SystemGlobalStatusFlags,ResourceData,RenderConfig,OperationFlags,InvalidHandleValue);
  }
  renderManagerOffset = SystemRenderManagerPointer;
  if (SystemRenderManagerPointer != 0) {
    loopCounterValue = 0;
    dataBufferPointer = *(long long *)(SystemRenderManagerPointer + 0x1868);
    maxItemCount = loopCounter;
    if (*(long long *)(SystemRenderManagerPointer + 0x1870) - dataBufferPointer >> 3 != 0) {
      do {
        if (*(long long **)(loopCounter + dataBufferPointer) != (long long *)0x0) {
          (**(code **)(**(long long **)(loopCounter + dataBufferPointer) + 0x108))();
        }
        itemCounter = (int)maxItemCount + 1;
        loopCounterValue = loopCounter + 8;
        dataBufferPointer = *(long long *)(renderManagerOffset + 0x1868);
        maxItemCount = (ulong long)itemCounter;
      } while ((ulong long)(long long)(int)itemCounter <
               (ulong long)(*(long long *)(renderManagerOffset + 0x1870) - dataBufferPointer >> 3));
    }
    (**(code **)(SystemCallbackTable + 0x40))();
  }
  (**(code **)(**(long long **)(systemHandle + 0x2b0) + 0xd0))();
  if (((*(int *)(SystemNodeManagerPointer + 0x4d4) != *(int *)(SystemNodeManagerPointer + 0x4d0)) ||
      (*(int *)(SystemNodeManagerPointer + 0x314) != *(int *)(SystemNodeManagerPointer + 0x310))) ||
     (*(int *)(SystemNodeManagerPointer + 0x544) != *(int *)(SystemNodeManagerPointer + 0x540))) {
    SystemResourceHandle = localBuffer1;
    localBuffer2 = &SystemBuffer1;
    localBuffer3 = &SystemBuffer2;
    ProcessSystemResourceData(localBuffer1);
  }
  if ((SystemAllocationFlags != 0) &&
     ((*(int *)(SystemNodeManagerPointer + 900) != *(int *)(SystemNodeManagerPointer + 0x380) ||
      (*(int *)(SystemNodeManagerPointer + 0x3f4) != *(int *)(SystemNodeManagerPointer + 0x3f0))))) {
    memoryAllocationHandle = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x40,8,3);
    SystemResourceHandle = localBuffer4;
    localBuffer5 = &SystemBuffer3;
    localBuffer6 = &SystemBuffer4;
    systemResourcePointer = (long long *)CreateMemoryAllocationHandle(memoryAllocationHandle,localBuffer4);
    StackParameter2 = systemResourcePointer;
    if (systemResourcePointer != (long long *)0x0) {
      (**(code **)(*systemResourcePointer + 0x28))(systemResourcePointer);
    }
    memoryAllocationHandle = SystemAllocationFlagsTemplate;
    SystemOperationFlag = &SystemResourceHandle;
    SystemResourceHandle = systemResourcePointer;
    if (systemResourcePointer != (long long *)0x0) {
      (**(code **)(*systemResourcePointer + 0x28))(systemResourcePointer);
    }
    SetupMemoryAllocationContext(memoryAllocationHandle,&StackParameter1);
    if (systemResourcePointer != (long long *)0x0) {
      (**(code **)(*systemResourcePointer + 0x38))(systemResourcePointer);
    }
  }
  renderManagerOffset = SystemNodeManagerPointer;
  if ((*(long long *)(SystemDataMemoryContext + 0x7ab8) == 0) || (*(int *)(SystemNodeManagerPointer + 0x540) < 1)) {
    if (*(int *)(SystemNodeManagerPointer + 0x2140) == 0) {
      scaleFactor1 = *(float *)(SystemNodeManagerPointer + 0x20d0);
    }
    else {
      scaleFactor1 = 100.0;
    }
    scaleFactor1 = scaleFactor1 * 0.01;
  }
  else {
    scaleFactor1 = 1.0;
  }
  *(float *)(systemHandle + 0x234) = scaleFactor1;
  *(uint32_t *)(systemHandle + 0x238) = 0x3f800000;
  scaleFactor2 = 1.0;
  if (*(int *)(renderManagerOffset + 0x1ea0) == 1) {
    SystemOperationStatusValue = *(int *)(renderManagerOffset + 0x1d50);
    resourceCountPointer = (int *)GetSystemResourceManager(*(void* *)(SystemGlobalStatusFlags + 8),&StackParameter2);
    scaleFactor2 = (float)SystemOperationStatusValue / (float)*resourceCountPointer;
    scaleFactor1 = scaleFactor2 * *(float *)(systemHandle + 0x234);
    scaleFactor2 = scaleFactor2 * *(float *)(systemHandle + 0x238);
  }
  if (0.2 <= scaleFactor1) {
    if (1.0 <= scaleFactor1) {
      scaleFactor1 = 1.0;
    }
  }
  else {
    scaleFactor1 = 0.2;
  }
  *(float *)(systemHandle + 0x234) = scaleFactor1;
  if (0.2 <= scaleFactor2) {
    if (1.0 <= scaleFactor2) {
      scaleFactor2 = 1.0;
    }
    *(float *)(systemHandle + 0x238) = scaleFactor2;
  }
  else {
    *(uint32_t *)(systemHandle + 0x238) = 0x3e4ccccd;
  }
  return;
}





// 函数: void InitializeSystemResource(void* SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串格式化处理器
 * 
 * 该函数负责处理系统字符串的格式化操作，包括字符串前缀添加、
 * 数据复制和内存管理。它主要用于构建特定格式的字符串数据结构。
 * 
 * @param formatData 格式化数据指针
 * @param stringBuffer 字符串缓冲区指针
 * 
 * @note 该函数在系统初始化过程中用于构建特定的字符串格式
 */
void SystemStringFormatter(void* formatData,long long stringBuffer)

{
  uint32_t *SystemDataPointer;
  int systemResult;
  int NodeIdentifierComparisonResult;
  uint8_t aSystemThreadStackSize [32];
  void* **SystemResourceTriplePointerA;
  void* CalculationFlags1A0;
  void* *pSystemStackFlag;
  void* SystemResourcePointer190;
  int intValue188;
  uint8_t SystemStackBufferE8 [16];
  void* *systemDataPointer;
  void* SystemResourcePointerD0;
  int IntegerStackC8;
  ulong long ConcatenatedValue44;
  
  CalculationFlags1A0 = 0xfffffffffffffffe;
  ConcatenatedValue44 = SystemEncryptionKeyTemplate ^ (ulong long)aSystemThreadStackSize;
  CopySystemDataStructure(SystemStackBufferE8,
                (long long)*(int *)(SystemTextureManagerPointer + 0x1d40) * 0xd0 +
                *(long long *)(SystemTextureManagerPointer + 0x1d20));
  InitializeSystemBuffer(&pSystemStackFlag);
  systemResult = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  if (*(uint8_t **)(ConfigurationDataPointer + 8) != (uint8_t *)0x0) {
    **(uint8_t **)(ConfigurationDataPointer + 8) = 0;
    systemResult = *(int *)(ConfigurationDataPointer + 0x10);
  }
  systemCounter = systemResult + 5;
  ExecuteSystemCommand(ConfigurationDataPointer,systemCounter);
  SystemDataPointer = (uint32_t *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8));
  *SystemDataPointer = 0x3a757067;
  *(void*2 *)(SystemDataPointer + 1) = 0x20;
  *(int *)(ConfigurationDataPointer + 0x10) = systemCounter;
  if (0 < IntegerStackC8) {
    ExecuteSystemCommand(ConfigurationDataPointer,systemCounter + IntegerStackC8);
      memcpy((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8),SystemResourcePointerD0,
           (long long)(IntegerStackC8 + 1));
  }
  ExecuteSystemCommand(ConfigurationDataPointer,systemResult + 6);
  *(void*2 *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8)) = 10;
  *(int *)(ConfigurationDataPointer + 0x10) = systemResult + 6;
  systemCounter = systemResult + 0xb;
  ExecuteSystemCommand(ConfigurationDataPointer,systemCounter);
  SystemDataPointer = (uint32_t *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8));
  *SystemDataPointer = 0x3a757063;
  *(void*2 *)(SystemDataPointer + 1) = 0x20;
  *(int *)(ConfigurationDataPointer + 0x10) = systemCounter;
  if (0 < intValue188) {
    ExecuteSystemCommand(ConfigurationDataPointer,systemCounter + intValue188);
      memcpy((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8),SystemResourcePointer190,
           (long long)(intValue188 + 1));
  }
  ExecuteSystemCommand(ConfigurationDataPointer,systemResult + 0xc);
  *(void*2 *)((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8)) = 10;
  *(int *)(ConfigurationDataPointer + 0x10) = systemResult + 0xc;
  pSystemStackFlag = &SystemMemoryAllocatorReference;
  SystemResourceTriplePointerA = &systemDataPointer;
  SystemMemoryAllocatorReferencePointer = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(ConcatenatedValue44 ^ (ulong long)aSystemThreadStackSize);
}



000180053668)
0001800536a5)
0001800536a9)
0001800536b4)
0001800536b7)
0001800536e1)
0001800536e5)
0001800536f3)
0001800536fb)
000180053702)
00018005370c)
00018005373c)
000180053744)
000180053747)
000180053714)
000180053719)
000180053760)
00018005376e)
0001800537b1)
0001800537b5)
0001800537c0)
0001800537c3)
0001800537ed)
0001800537f1)
0001800537ff)
000180053807)
00018005380c)
00018005381c)
00018005384b)
000180053853)
000180053856)
000180053824)
000180053828)
00018005386f)
00018005387d)
0001800538c8)
0001800538cc)
0001800538d7)
0001800538da)
000180053906)
00018005390a)
000180053918)
000180053921)
000180053925)
000180053931)
000180053962)
00018005396a)
00018005396d)
000180053939)
00018005393e)
000180053987)
000180053996)
0001800539f8)
0001800539fc)
000180053a07)
000180053a0a)
000180053a34)
000180053a38)
000180053a46)
000180053a4e)
000180053a53)
000180053ad8)
000180053a61)
000180053aa2)
000180053aab)
000180053aaf)
000180053a69)
000180053a74)
000180053ade)
000180053b28)
000180053b2c)
000180053b32)
000180053b36)
000180053b60)
000180053b64)
000180053b72)
000180053b7a)
000180053b7e)
000180053b8e)
000180053bbe)
000180053bc6)
000180053bc9)
000180053b97)
000180053b9b)
000180053be2)
000180053bf0)
000180053c4c)
000180053c51)
000180053c5d)
000180053c60)
000180053c8e)
000180053c93)
000180053ca1)
000180053caa)
000180053caf)
000180053cbe)
000180053cf1)
000180053cf9)
000180053cfc)
000180053cc6)
000180053cce)
000180053d15)
000180053d23)
000180053d8b)
000180053d8f)
000180053d9a)
000180053d9d)
000180053dcd)
000180053dd1)
000180053ddf)
000180053de8)
000180053ded)
000180053dfc)
000180053e2f)
000180053e37)
000180053e3a)
000180053e03)
000180053e0b)
000180053e54)
000180053e63)
000180053ead)
000180053eb5)
000180053ee6)
000180053ef5)
000180053f18)
000180053f20)
000180053f43)
000180053f4b)
000180053f74)
000180053f79)
000180053f98)
000180053fa0)
000180053fbc)
000180053fc4)
000180053fe5)
000180053fea)
000180054035)
000180054062)
000180054075)
00018005407a)
0001800540b2)
0001800540b7)
0001800540d9)
0001800540e1)


/**
 * @brief 系统线程对象创建和管理函数
 * 
 * 该函数负责创建和管理系统线程对象，包括：
 * - 初始化系统进程ID和内存分配
 * - 创建系统线程对象和缓冲区
 * - 处理线程启动和数据复制
 * - 管理线程参数和配置
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ThreadConfig 线程配置指针
 * @param ThreadParams 线程参数指针
 */
void CreateAndManageSystemThreadObject(void* SystemResourceManager,void* ThreadConfig,long long ThreadParams)

{
  long long memoryBufferPointer;
  long long systemHandle;
  uint32_t processId;
  int bufferSize;
  uint threadId;
  uint dataLength;
  uint8_t *threadBuffer;
  ulong long bufferOffset;
  void* *dataTemplatePointer;
  long long currentThreadId;
  uint threadFlags;
  uint8_t encryptionBuffer [32];
  uint8_t bufferFlags;
  uint32_t operationFlags1;
  uint32_t operationFlags2;
  void* *resourcePointer1;
  uint8_t *threadBufferPointer;
  uint threadStatus;
  void* threadHandle;
  void* *configPointer;
  long long configValue;
  uint configFlags;
  void* dataBuffer1;
  void* dataBuffer2;
  void* *systemGlobalPointer;
  void* dataBuffer3;
  uint32_t dataFlags;
  void* dataBuffer4;
  uint8_t StackBuffer [32];
  void* ThreadParameter1;
  void* ThreadParameter2;
  char processNameBuffer [16];
  ulong long encryptionKey;
  
  ThreadParameter1 = 0xfffffffffffffffe;
  encryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)encryptionBuffer;
  threadBuffer = (uint8_t *)0x0;
  operationFlags1 = 0;
  dataBuffer2 = ThreadConfig;
  ThreadParameter2 = ThreadConfig;
  processId = GetCurrentProcessId();
  configPointer = &SystemGlobalDataReference;
  dataBuffer1 = 0;
  configValue = 0;
  configFlags = 0;
  ExecuteSystemCommand(&configPointer,6);
  memoryBufferPointer = configValue;
  bufferOffset = (ulong long)configFlags;
  *(uint32_t *)(bufferOffset + configValue) = 0x44495020;
  *(void*2 *)(bufferOffset + 4 + configValue) = 0x203a;
  *(uint8_t *)(bufferOffset + 6 + configValue) = 0;
  configFlags = 6;
  InitializeProcessSystem(processNameBuffer,&SystemDataBufferTemplateI,processId);
  systemHandle = -1;
  do {
    currentThreadId = systemHandle;
    systemHandle = currentThreadId + 1;
  } while (processNameBuffer[currentThreadId + 1] != '\0');
  if (0 < (int)(currentThreadId + 1)) {
    ExecuteSystemCommand(&configPointer,(int)currentThreadId + 7);
      memcpy((ulong long)configFlags + configValue,processNameBuffer,(long long)((int)currentThreadId + 2));
  }
  dataTemplatePointer = &SystemResourceTemplate;
  if (SystemGraphicsFlag != '\0') {
    dataTemplatePointer = &DataTemplateReference;
  }
  ProcessSystemQueue(StackBuffer,dataTemplatePointer);
  systemGlobalPointer = &SystemGlobalDataReference;
  dataBuffer4 = 0;
  dataBuffer3 = 0;
  dataFlags = 0;
  resourcePointer1 = &SystemGlobalDataReference;
  threadFlags = 0;
  threadHandle = 0;
  threadBufferPointer = (uint8_t *)0x0;
  threadStatus = 0;
  operationFlags1 = 2;
  dataLength = *(uint *)(ThreadParams + 0x10);
  bufferOffset = (ulong long)dataLength;
  threadId = 0;
  if (*(long long *)(ThreadParams + 8) == 0) {
SystemCompletionCheck:
    threadFlags = threadId;
    if (dataLength != 0) {
        memcpy(threadBuffer,*(void* *)(ThreadParams + 8),bufferOffset);
    }
  }
  else if (dataLength != 0) {
    bufferSize = dataLength + 1;
    if (bufferSize < 0x10) {
      bufferSize = 0x10;
    }
    threadBuffer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)bufferSize,0x13);
    *threadBuffer = 0;
    threadBufferPointer = threadBuffer;
    threadId = StartSystemThread(threadBuffer);
    threadHandle = ConcatenatedValue44(threadHandle.HighPart,threadId);
    goto SystemCompletionCheck;
  }
  if (threadBuffer != (uint8_t *)0x0) {
    threadBuffer[bufferOffset] = 0;
  }
  operationFlags2 = *(uint32_t *)(ThreadParams + 0x1c);
  threadHandle = ConcatenatedValue44(operationFlags2,(uint32_t)threadHandle);
  threadStatus = dataLength;
  if (dataLength != 0xfffffffa) {
    dataLength = dataLength + 7;
    if (threadBuffer == (uint8_t *)0x0) {
      if ((int)dataLength < 0x10) {
        dataLength = 0x10;
      }
      threadBuffer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)dataLength,0x13);
      *threadBuffer = 0;
    }
    else {
      if (dataLength <= threadFlags) goto ThreadSizeCheck;
      bufferFlags = 0x13;
      threadBuffer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadBuffer,dataLength,0x10);
    }
    threadBufferPointer = threadBuffer;
    processId = StartSystemThread(threadBuffer);
    threadHandle = ConcatenatedValue44(threadHandle.HighPart,processId);
  }
ThreadSizeCheck:
    memcpy(threadBuffer + bufferOffset,memoryBufferPointer,7);
}




/**
 * @brief 系统资源节点管理器
 * 
 * 该函数负责管理系统资源节点的创建、初始化和清理。它处理系统命令执行，
 * 管理内存分配，验证系统资源状态，并在必要时进行资源清理。这是系统
 * 资源管理的核心函数，确保资源节点的正确生命周期管理。
 * 
 * @param SystemResourceManager 系统资源指针，指向系统资源数据结构
 * @param ConfigurationDataPointer 系统参数，包含资源操作的配置信息
 * @param AdditionalParameter 操作参数，用于指定具体的操作类型
 * @param ConfigurationFlag 扩展参数，用于传递额外的操作选项
 * @return 操作结果状态码，成功返回0，失败返回非零值
 * @note 这是系统资源管理的关键函数，需要确保参数的正确性和内存安全
 */
void* SystemResourceManagerNodeHandler(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  char SystemNodeFlag;
  char CharacterBuffer;
  void* *ResourceNodePointer;
  void* *ResourceStartPointer;
  void* *ResourceEndPointer;
  long long SystemStatusFlags;
  char *CommandString;
  uint StringIndex;
  int *ParameterPointer;
  ulong long ResourceCount;
  void* OperationResult;
  ulong long LoopCounter;
  ulong long StringLength;
  long long MemoryOffset;
  void* *ComparisonPointer;
  ulong long AllocationSize;
  void* *StackBufferPtr;
  uint8_t *StringBuffer;
  uint BufferSize;
  void* SystemStackHandle;
  void* *ResourcePointer1;
  void* *ResourcePointer2;
  void* StackValue40;
  uint32_t StackValue38;
  ulong long ProcessedCount;
  
  ResourcePointer1 = (void* *)0x0;
  ResourcePointer2 = (void* *)0x0;
  AllocationSize = 0;
  StackValue40 = 0;
  StackValue38 = 3;
  InitializeSystemResourceManager(SystemGlobalStatusFlags,&ResourcePointer1,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  ResourceEndPointer = ResourcePointer2;
  ResourceStartPointer = ResourcePointer1;
  ResourceCount = (long long)ResourcePointer2 - (long long)ResourcePointer1 >> 5;
  ResourceNodePointer = ResourceStartPointer;
  if (ResourceCount == 0) {
ResourceSizeCheck:
    OperationResult = 0;
joined_r0x00018005430b:
    for (; ResourceNodePointer != ResourceEndPointer; ResourceNodePointer = ResourceNodePointer + 4) {
      (**(code **)*ResourceNodePointer)(ResourceNodePointer,0);
    }
    if (ResourceStartPointer != (void* *)0x0) {
        SystemCleanupFunction(ResourceStartPointer);
    }
    return OperationResult;
  }
  ParameterPointer = (int *)(ResourcePointer1 + 2);
  LoopCounter = AllocationSize;
ResourceCountCheck:
  StackBufferPtr = &SystemGlobalDataReference;
  SystemStackHandle = 0;
  StringBuffer = (uint8_t *)0x0;
  BufferSize = 0;
  ExecuteSystemCommand(&StackBufferPtr,*ParameterPointer);
  if (*ParameterPointer != 0) {
      memcpy(StringBuffer,*(void* *)(ParameterPointer + -2),*ParameterPointer + 1);
  }
  if (*(long long *)(ParameterPointer + -2) != 0) {
    BufferSize = 0;
    if (StringBuffer != (uint8_t *)0x0) {
      *StringBuffer = 0;
    }
    SystemStackHandle = SystemStackHandle & MAX_UNSIGNED_32_BIT;
  }
  ProcessedCount = AllocationSize;
  StringLength = AllocationSize;
  if (BufferSize != 0) {
    do {
      if ((byte)(StringBuffer[StringLength] + 0xbf) < 0x1a) {
        StringBuffer[StringLength] = StringBuffer[StringLength] + ' ';
      }
      StringIndex = (int)ProcessedCount + 1;
      ProcessedCount = (ulong long)StringIndex;
      StringLength = StringLength + 1;
    } while (StringIndex < BufferSize);
  }
  SystemStatusFlags = GetSystemStatusFlagsInternal(&StackBufferPtr);
  ComparisonPointer = (void* *)&ComparisonDataReference;
  do {
    CommandString = (char *)*ComparisonPointer;
    MemoryOffset = SystemStatusFlags - (long long)CommandString;
    do {
      CharacterBuffer = *CommandString;
      CharacterBuffer = CommandString[MemoryOffset];
      if (CharacterBuffer != CharacterBuffer) break;
      CommandString = CommandString + 1;
    } while (CharacterBuffer != '\0');
    if (CharacterBuffer == CharacterBuffer) break;
    ComparisonPointer = ComparisonPointer + 1;
    if (0x1809fde87 < (long long)ComparisonPointer) {
      StackBufferPtr = &SystemGlobalDataReference;
      if (StringBuffer != (uint8_t *)0x0) {
          SystemCleanupFunction();
      }
      StringBuffer = (uint8_t *)0x0;
      SystemStackHandle = (ulong long)SystemStackHandle.HighPart << 0x20;
      StackBufferPtr = &SystemMemoryAllocatorReference;
      OperationResult = 1;
      goto joined_r0x00018005430b;
    }
  } while( true );
  StackBufferPtr = &SystemGlobalDataReference;
  if (StringBuffer != (uint8_t *)0x0) {
      SystemCleanupFunction();
  }
  StringBuffer = (uint8_t *)0x0;
  SystemStackHandle = (ulong long)SystemStackHandle.HighPart << 0x20;
  StackBufferPtr = &SystemMemoryAllocatorReference;
  StringIndex = (int)LoopCounter + 1;
  LoopCounter = (ulong long)StringIndex;
  ParameterPointer = ParameterPointer + 8;
  if (ResourceCount <= (ulong long)(long long)(int)StringIndex) goto ResourceSizeCheck;
  goto ResourceCountCheck;
}





// 函数: void ConfigureSystemResource(long long* SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 系统资源数据处理函数
 * 
 * 该函数负责处理系统资源数据的初始化、配置和管理。它分配内存缓冲区，
 * 设置系统参数，处理数据复制和验证操作，确保系统资源的正确初始化。
 * 
 * @param SystemResourceManager 系统资源指针，包含系统配置和状态信息
 * @param ConfigurationDataPointer 处理参数，包含系统资源和处理标志
 * @note 这是系统初始化过程中的核心函数，用于建立系统资源的数据结构
 */
void SystemResourceDataProcessor(long long* SystemResourceManager,long long ConfigurationDataPointer)

{
  uint SystemOperationStatus;
  int systemResult;
  void* resourceAllocationContext;
  long long* SystemMemoryPointer;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  ulong long ThreadContextFlag;
  uint8_t SystemStackBuffer238 [32];
  uint32_t SystemOperationStatus218;
  void* *systemMemoryPointer;
  long long SystemMemoryOffset200;
  uint SystemResourceCount1f8;
  void* SystemResourcePointer1f0;
  uint32_t SystemConfigurationValue1e8;
  void* *pGlobalDataFlags2;
  long long SystemMemoryOffset1d8;
  uint SystemResourceCount1d0;
  void* SystemResourcePointer1c8;
  void* *pGlobalDataFlags;
  long long SystemMemoryOffset1b8;
  uint32_t SystemOperationStatus1b0;
  ulong long SystemResourceHandle1a8;
  uint32_t CalculationFlags1A0;
  uint SystemResourceCount19c;
  uint8_t SystemStackFlag;
  uint32_t SystemOperationStatus194;
  void* *pointerUnsigned190;
  long long SystemMemoryOffset188;
  int SystemThreadCount180;
  uint32_t CalculationFlags178;
  void* **SystemResourceTriplePointer170;
  void* *SystemResourcePointer168;
  long long SystemMemoryOffset160;
  uint32_t SystemResourceSize;
  uint32_t SystemAllocationFlags148;
  uint32_t SystemAllocationFlags144;
  uint32_t SystemAllocationFlags140;
  uint32_t SystemAllocationFlags13c;
  uint32_t SystemAllocationFlags138;
  uint32_t SystemAllocationFlags134;
  uint32_t SystemAllocationFlags130;
  uint32_t SystemAllocationFlags12c;
  uint32_t SystemMemoryOffset;
  uint32_t StackVariable124;
  uint32_t StackVariable120;
  uint32_t StackVariable11c;
  uint32_t UnsignedStackFlag118;
  uint32_t StackVariable114;
  uint32_t UnsignedStackFlag110;
  uint32_t SystemEncryptionOffsetc;
  uint8_t EncryptionOffset1;
  uint32_t SystemEncryptionOffset7;
  uint32_t SystemEncryptionOffset3;
  void* MemoryBufferAddress;
  void* **StackDoublePointerF0;
  void* *pointerUnsignedE8;
  uint8_t *DataBufferPtrE0;
  uint32_t SystemMemoryAllocatorStatus;
  uint8_t DataBufferD0 [136];
  ulong long SystemEncryptionKey;
  
  MemoryBufferAddress = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)StackArray238;
  SystemInitializationFlag = 0;
  StackDoublePointerF0 = &pGlobalDataFlags;
  pGlobalDataFlags = &SystemGlobalDataReference;
  StackVariable1a8 = 0;
  LongStackVariable1b8 = 0;
  StackVariable1b0 = 0;
  StackVariable19c = 0x100;
  SystemStackFlag = 0;
  StackVariable194 = 0;
  SystemThreadContext = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemThreadContext = *(void* **)(ConfigurationDataPointer + 8);
  }
  SetupSystemDataBuffer(&pGlobalDataFlags,SystemThreadContext);
  CalculationFlags1A0 = 0;
  StackVariable19c = StackVariable19c & 0xffffff00;
  resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x60d30,0x10,0x1f);
  SystemCalculatedBufferAddress = (long long *)InitializeSystemMemoryAllocator(resourceAllocationContext,&pGlobalDataFlags);
  StackDoublePointer170 = (void* **)SystemCalculatedBufferAddress;
  if (SystemCalculatedBufferAddress != (long long *)0x0) {
    (**(code **)(*SystemCalculatedBufferAddress + 0x28))(SystemCalculatedBufferAddress);
  }
  StackVariable148 = 0x3f800000;
  StackVariable144 = 0;
  StackVariable140 = 0;
  StackVariable13c = 0;
  StackVariable138 = 0;
  StackVariable134 = 0x3f800000;
  StackVariable130 = 0;
  StackVariable12c = 0;
  SystemMemoryOffset = 0;
  StackVariable124 = 0;
  StackVariable120 = 0x3f800000;
  StackVariable11c = 0;
  UnsignedStackFlag118 = 0;
  StackVariable114 = 0;
  UnsignedStackFlag110 = 0;
  SystemEncryptionOffsetc = 0x3f800000;
  SystemEncryptionOffset7 = 0x1010101;
  SystemEncryptionOffset3 = 1;
  EncryptionOffset1 = 1;
  pointerUnsignedE8 = &SystemResourceTemplatePrimary;
  DataBufferPtrE0 = DataBufferD0;
  DataBufferD0[0] = 0;
  SystemMemoryAllocatorStatus = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemThreadContext = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemThreadContext = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(DataBufferD0,0x80,SystemThreadContext);
  InitializeSystemData(&pointerUnsigned190,&pointerUnsignedE8);
  pointerUnsignedE8 = &SystemMemoryAllocatorReference;
  pGlobalDataFlags2 = &SystemGlobalDataReference;
  SystemDataProcessingFlag = 0;
  LongStackVariable1d8 = 0;
  StackVariable1d0 = 0;
  SystemThreadFlags = *SystemResourceManager;
  SetupSystemMemory(&SystemResourcePointer,ConfigurationDataPointer);
  systemResult = ValidateSystemConfiguration(SystemThreadFlags,&SystemResourcePointer);
  SystemResourcePointer = &SystemGlobalDataReference;
  if (SystemResourceBuffer != 0) {
      SystemCleanupFunction();
  }
  SystemResourceBuffer = 0;
  SystemResourceDataSize = 0;
  SystemResourcePointer = &SystemMemoryAllocatorReference;
  if ((systemResult < 0) ||
     (SystemThreadFlags = *(long long *)(*SystemResourceManager + 0x888),
     (ulong long)(*(long long *)(*SystemResourceManager + 0x890) - SystemThreadFlags >> 5) <= (ulong long)(long long)systemResult)) {
    SystemThreadFlags = GetSystemStatusFlags();
  }
  else {
    SystemThreadFlags = (long long)systemResult * 0x20 + SystemThreadFlags;
  }
  SystemUnsignedValue208 = &SystemGlobalDataReference;
  SystemVariable1f0 = 0;
  SystemVariable200 = 0;
  SystemVariable1f8 = 0;
  StackValue1e8 = 1;
  SystemOperationStatus = *(uint *)(SystemThreadFlags + 0x10);
  ThreadContextFlag = (ulong long)SystemOperationStatus;
  if (*(long long *)(SystemThreadFlags + 8) != 0) {
    ExecuteSystemCommand(&SystemUnsignedValue208,ThreadContextFlag);
  }
  if (SystemOperationStatus != 0) {
      memcpy(SystemVariable200,*(void* *)(SystemThreadFlags + 8),ThreadContextFlag);
  }
  if (SystemVariable200 != 0) {
    *(uint8_t *)(ThreadContextFlag + SystemVariable200) = 0;
  }
  SystemVariable1f0 = ConcatenatedValue44(*(uint *)(SystemThreadFlags + 0x1c),(uint32_t)SystemVariable1f0);
  if (0 < SystemInteger180) {
    SystemVariable1f8 = SystemOperationStatus;
    ExecuteSystemCommand(&SystemUnsignedValue208,SystemInteger180);
      memcpy((ulong long)SystemVariable1f8 + SystemVariable200,SystemVariable188,(long long)(SystemInteger180 + 1));
  }
  LongStackVariable1d8 = SystemVariable200;
  SystemThreadStackSize.PrimaryField = (uint32_t)SystemVariable1f0;
  SystemVariable1f8 = 0;
  SystemInitializationFlag = 0;
  SystemVariable200 = 0;
  SystemVariable1f0 = 0;
  SystemUnsignedValue208 = &SystemMemoryAllocatorReference;
  StackVariable218 = 0xffffffff;
  StackVariable1d0 = SystemOperationStatus;
  SystemThreadStackSize.SecondaryField = *(uint *)(SystemThreadFlags + 0x1c);
  ConfigureSystemData(SystemCalculatedBufferAddress,SystemConfigurationData,&pGlobalDataFlags2,&StackVariable148);
  ReleaseSystemResources(SystemCalculatedBufferAddress);
  (**(code **)(*(long long *)SystemResourceManager[0x56] + 0x138))((long long *)SystemResourceManager[0x56],SystemCalculatedBufferAddress);
  InitializeSystemBuffer(SystemCalculatedBufferAddress,0x3d072b02,1);
  UpdateSystemData(SystemCalculatedBufferAddress);
  (**(code **)(*(long long *)SystemResourceManager[0x56] + 0x140))((long long *)SystemResourceManager[0x56],SystemCalculatedBufferAddress);
  Sleep(1000);
  pGlobalDataFlags2 = &SystemGlobalDataReference;
  if (SystemMemoryPoolHandle != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryPoolHandle = 0;
  SystemThreadStackSize = (ulong long)SystemThreadStackSize.SecondaryField << 0x20;
  pGlobalDataFlags2 = &SystemMemoryAllocatorReference;
  pointerUnsigned190 = &SystemGlobalDataReference;
  if (SystemResourcePoolPointer != 0) {
      SystemCleanupFunction();
  }
  SystemResourcePoolPointer = 0;
  SystemThreadFlag = 0;
  pointerUnsigned190 = &SystemMemoryAllocatorReference;
  if (SystemCalculatedBufferAddress != (long long *)0x0) {
    (**(code **)(*SystemCalculatedBufferAddress + 0x38))(SystemCalculatedBufferAddress);
  }
  StackDoublePointer170 = &pGlobalDataFlags;
  pGlobalDataFlags = &SystemGlobalDataReference;
  if (SystemMemoryOffset200 != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryOffset200 = 0;
  SystemResourceCount1f8 = SystemResourceCount1f8 & MAX_UNSIGNED_32_BIT00000000;
  pGlobalDataFlags = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)SystemStackBuffer238);
}





// 函数: void SetupSystemMemory(void)
/**
 * @brief 系统资源枚举和配置函数
 * 
 * 该函数负责枚举和配置系统资源，包括内存分配、字符串处理、
 * 资源管理和系统初始化。它会遍历系统资源表，为每个资源分配
 * 适当的内存空间，并设置相关的配置参数。
 * 
 * @note 这是系统初始化过程中的重要函数，用于建立和管理系统资源
 */
void SystemResourceEnumerator(void)

{
  uint ResourceIndex;
  long long *resourcePoolPointer;
  void* *ResourceNodePointer;
  char StatusFlag;
  void* *ResourceDataPointer;
  uint8_t *ResourceBufferPointer;
  uint32_t *PreviousSystemNode;
  int OperationCode;
  int SystemIdentifier;
  long long AllocationFlags;
  ulong long ResourceCount;
  void* *ResourceArrayPointer;
  int SystemStatus;
  long long MemoryPointer;
  uint *ResourceFlagPointer;
  void** SystemDataPointer;
  uint32_t SystemResourceID;
  uint8_t LocalBufferArray [32];
  void* *StackResourcePointer158;
  uint8_t *StackBufferPointer150;
  uint StackValue148;
  void* SystemStackHandle140;
  void* *StackResourcePointer138;
  uint8_t *StackBufferPointer130;
  uint StackValue128;
  ulong long StackValue120;
  void* *StackResourcePointer118;
  uint8_t *StackBufferPointer110;
  uint32_t StackValue108;
  ulong long StackValue100;
  int StackCounterF8;
  void* *StackResourcePointerF0;
  uint8_t *StackBufferPointerE8;
  uint32_t StackValueE0;
  ulong long StackValueD8;
  void* *StackResourcePointerD0;
  long long StackMemoryOffsetC8;
  int StackCounterC0;
  uint32_t StackValueB8;
  long long *StackMemoryPointerA8;
  long long StackMemoryOffsetA0;
  void* *ParameterBufferB;
  void* *ParameterBufferC;
  uint32_t StackValue80;
  void* *StackResourcePointer78;
  long long StackMemoryOffset70;
  uint32_t StackValue60;
  void* *StackResourcePointer58;
  void* *StackResourcePointer50;
  void* SystemStackHandle48;
  uint32_t StackValue40;
  void* SystemStackHandle38;
  ulong long StackValue30;
  
  SystemStackHandle38 = 0xfffffffffffffffe;
  StackValue30 = SystemEncryptionKeyTemplate ^ (ulong long)LocalBufferArray;
  StackMemoryPointerA8 = SystemGlobalStatusFlags;
  resourceDataIndex4 = *(long long *)(*SystemGlobalStatusFlags + 0x890) - *(long long *)(*SystemGlobalStatusFlags + 0x888) >> 5;
  SystemIdentifierF8 = 0;
  ResourceCountA0 = resourceDataIndex4;
  if (0 < (int)resourceDataIndex4) {
    do {
      systemId = SystemIdentifierF8;
      SystemOperationStatus3 = 0;
      if (SystemIdentifierF8 < 0) {
StringIterationCheck:
        SystemAllocationFlags = GetSystemStatusFlags();
      }
      else {
        SystemAllocationFlags = *(long long *)(*SystemGlobalStatusFlags + 0x888);
        if ((ulong long)(*(long long *)(*SystemGlobalStatusFlags + 0x890) - SystemAllocationFlags >> 5) <=
            (ulong long)(long long)SystemIdentifierF8) goto StringIterationCheck;
        SystemAllocationFlags = (long long)SystemIdentifierF8 * 0x20 + SystemAllocationFlags;
      }
      SystemMemoryContext = &SystemGlobalDataReference;
      SystemResourceFlags120 = 0;
      ResourceBufferPointer130 = (uint8_t *)0x0;
      SystemMemoryOffset = 0;
      ExecuteSystemCommand(&SystemMemoryContext,*(uint32_t *)(SystemAllocationFlags + 0x10));
      if (*(int *)(SystemAllocationFlags + 0x10) != 0) {
          memcpy(ResourceBufferPointer130,*(void* *)(SystemAllocationFlags + 8),*(int *)(SystemAllocationFlags + 0x10) + 1);
      }
      if (*(long long *)(SystemAllocationFlags + 8) != 0) {
        SystemMemoryOffset = 0;
        if (ResourceBufferPointer130 != (uint8_t *)0x0) {
          *ResourceBufferPointer130 = 0;
        }
        SystemResourceFlags120 = SystemResourceFlags120 & MAX_UNSIGNED_32_BIT;
      }
      if (SystemIdentifierF8 < 0) {
SystemIdCheck:
        SystemAllocationFlags = GetSystemStatusFlags();
      }
      else {
        SystemAllocationFlags = *(long long *)(*SystemGlobalStatusFlags + 0x8a8);
        if ((ulong long)(*(long long *)(*SystemGlobalStatusFlags + 0x8b0) - SystemAllocationFlags >> 5) <
            (ulong long)(long long)systemId) goto SystemIdCheck;
        SystemAllocationFlags = (long long)systemId * 0x20 + SystemAllocationFlags;
      }
      pUnsignedStackFlag118 = &SystemGlobalDataReference;
      EncryptionOffset2 = 0;
      pUnsignedStackFlag110 = (uint8_t *)0x0;
      EncryptionOffset1 = 0;
      ExecuteSystemCommand(&pUnsignedStackFlag118,*(uint32_t *)(SystemAllocationFlags + 0x10));
      if (*(int *)(SystemAllocationFlags + 0x10) != 0) {
          memcpy(pUnsignedStackFlag110,*(void* *)(SystemAllocationFlags + 8),*(int *)(SystemAllocationFlags + 0x10) + 1);
      }
      if (*(long long *)(SystemAllocationFlags + 8) != 0) {
        EncryptionOffset1 = 0;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
          *pUnsignedStackFlag110 = 0;
        }
        EncryptionOffset2 = EncryptionOffset2 & MAX_UNSIGNED_32_BIT;
      }
      systemCode = SystemMemoryOffset + 8;
      ExecuteSystemCommand(&SystemMemoryContext,systemCode);
      *(void* *)(ResourceBufferPointer130 + SystemMemoryOffset) = 0x6a624f656e656353;
      *(uint8_t *)((long long)(ResourceBufferPointer130 + SystemMemoryOffset) + 8) = 0;
      SystemMemoryOffset = systemCode;
      SystemOperationStatusFlag = ValidateSystemMemoryAllocation(&SystemMemoryContext);
      if (SystemOperationStatusFlag == '\0') {
        pUnsignedStackFlag118 = &SystemGlobalDataReference;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
        pUnsignedStackFlag110 = (uint8_t *)0x0;
        EncryptionOffset2 = EncryptionOffset2 & MAX_UNSIGNED_32_BIT00000000;
        pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
        SystemMemoryContext = &SystemGlobalDataReference;
        if (ResourceBufferPointer130 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
      }
      else {
        memoryAllocationBuffer = (void* *)0x0;
        memoryAllocationEnd = (void* *)0x0;
        SystemEncryptionKey = 0;
        SystemOperationCounter = 3;
        AllocateSystemMemoryResources(&SystemMemoryContext,&memoryAllocationBuffer);
        SystemThreadContext = memoryAllocationEnd;
        SystemHashNodeData = memoryAllocationBuffer;
        SystemAllocationFlags = (long long)memoryAllocationEnd - (long long)memoryAllocationBuffer;
        InitializeSystemDataBuffer(&dataBufferContext);
        resourceEntryPointer = &SystemStringTemplate;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
          resourceEntryPointer = pUnsignedStackFlag110;
        }
        ConfigureSystemDataBuffer(&dataBufferContext,&SystemDataBufferConfig,resourceEntryPointer);
        SystemOperationStatusFlag = ValidateSystemMemoryAllocation(&dataBufferContext);
        if (SystemOperationStatusFlag == '\0') {
          ReleaseSystemMemoryAllocation(&dataBufferContext);
        }
        resourcePoolPointer = StackResourcePointerA8;
        systemCode = (int)(SystemAllocationFlags >> 5);
        SystemAllocationFlags = (long long)systemCode;
        if (0 < systemCode) {
          ThreadLocalStorageEntry = (uint *)(SystemHashNodeData + 2);
          do {
            ProcessSystemValidation();
            ValidateSystemComponent();
            pSystemConfigurationId = &SystemGlobalDataReference;
            SystemThreadContext140._0_4_ = 0;
            SystemThreadContext140._4_4_ = 0;
            pSystemResourceSize = (uint8_t *)0x0;
            SystemThreadId148 = 0;
            ExecuteSystemCommand(&pSystemConfigurationId,*ThreadLocalStorageEntry);
            if (*ThreadLocalStorageEntry != 0) {
                memcpy(pSystemResourceSize,*(void* *)(ThreadLocalStorageEntry + -2),*ThreadLocalStorageEntry + 1);
            }
            if (*(long long *)(ThreadLocalStorageEntry + -2) != 0) {
              SystemThreadId148 = 0;
              if (pSystemResourceSize != (uint8_t *)0x0) {
                *pSystemResourceSize = 0;
              }
              SystemThreadContext140._4_4_ = 0;
            }
            systemId = SystemThreadId148 + 0xd;
            ExecuteSystemCommand(&pSystemConfigurationId,systemId);
            SystemThreadContext = (void* *)(pSystemResourceSize + SystemThreadId148);
            *SystemThreadContext = 0x782e656e6563732f;
            *(uint32_t *)(SystemThreadContext + 1) = 0x6e656373;
            *(void*2 *)((long long)SystemThreadContext + 0xc) = 0x65;
            resourceEntryPointer = &SystemStringTemplate;
            if (pSystemResourceSize != (uint8_t *)0x0) {
              resourceEntryPointer = pSystemResourceSize;
            }
            SystemThreadId148 = systemId;
            resourceDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString1);
            if (resourceDataIndex4 == 0) {
              resourceEntryPointer = &SystemStringTemplate;
              if (pSystemResourceSize != (uint8_t *)0x0) {
                resourceEntryPointer = pSystemResourceSize;
              }
              resourceDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString2);
              if (resourceDataIndex4 != 0) goto MemoryPointerCheck;
              resourceEntryPointer = &SystemStringTemplate;
              if (pSystemResourceSize != (uint8_t *)0x0) {
                resourceEntryPointer = pSystemResourceSize;
              }
              resourceDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString3);
              if (resourceDataIndex4 != 0) goto MemoryPointerCheck;
              resourceEntryPointer = &SystemStringTemplate;
              if (pSystemResourceSize != (uint8_t *)0x0) {
                resourceEntryPointer = pSystemResourceSize;
              }
              resourceDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString4);
              if (resourceDataIndex4 != 0) goto MemoryPointerCheck;
              resourceEntryPointer = &SystemStringTemplate;
              if (pSystemResourceSize != (uint8_t *)0x0) {
                resourceEntryPointer = pSystemResourceSize;
              }
              resourceDataIndex4 = strstr(resourceEntryPointer,&SystemSearchString5);
              if (resourceDataIndex4 != 0) goto MemoryPointerCheck;
              SystemOperationStatusFlag = CheckSystemMemoryStatus(&pSystemConfigurationId);
              if (SystemOperationStatusFlag == '\0') {
                SystemThreadId148 = 0;
                if (pSystemResourceSize != (uint8_t *)0x0) {
                  *pSystemResourceSize = 0;
                }
                SystemOperationStatus = *ThreadLocalStorageEntry;
                SystemOperationStatus1 = (ulong long)SystemOperationStatus;
                if (*(long long *)(ThreadLocalStorageEntry + -2) != 0) {
                  ExecuteSystemCommand(&pSystemConfigurationId,SystemOperationStatus1);
                }
                if (SystemOperationStatus != 0) {
                    memcpy(pSystemResourceSize,*(void* *)(ThreadLocalStorageEntry + -2),SystemOperationStatus1);
                }
                if (pSystemResourceSize != (uint8_t *)0x0) {
                  pSystemResourceSize[SystemOperationStatus1] = 0;
                }
                SystemThreadContext140._4_4_ = ThreadLocalStorageEntry[3];
                SystemThreadId148 = SystemOperationStatus;
                ExecuteSystemCommand(&pSystemConfigurationId,0x12);
                hashTableNode = (uint32_t *)(pSystemResourceSize + SystemThreadId148);
                *hashTableNode = 0x6563732f;
                hashTableNode[1] = 0x782e656e;
                hashTableNode[2] = 0x2e6f6373;
                hashTableNode[3] = 0x65637378;
                *(void*2 *)(hashTableNode + 4) = 0x656e;
                *(uint8_t *)((long long)hashTableNode + 0x12) = 0;
                SystemThreadId148 = 0x12;
                SystemOperationStatusFlag = CheckSystemMemoryStatus(&pSystemConfigurationId);
                if (SystemOperationStatusFlag != '\0') goto PathSeparatorCheck;
                pSystemConfigurationId = &SystemGlobalDataReference;
                if (pSystemResourceSize != (uint8_t *)0x0) {
                    SystemCleanupFunction();
                }
                SystemThreadContext140 = (ulong long)SystemThreadContext140._4_4_ << 0x20;
              }
              else {
PathSeparatorCheck:
                systemId = *ThreadLocalStorageEntry - 1;
                if (-1 < systemId) {
                  resourceDataIndex4 = (long long)systemId;
                  do {
                    if (*(char *)(resourceDataIndex4 + *(long long *)(ThreadLocalStorageEntry + -2)) == '/') goto PathSeparatorFound;
                    systemId = systemId + -1;
                    resourceDataIndex4 = resourceDataIndex4 + -1;
                  } while (-1 < resourceDataIndex4);
                }
                systemId = -1;
PathSeparatorFound:
                ExecuteSystemOperation(SystemHashNodeData + (long long)SystemOperationStatus3 * 4,&stackParameterB,systemId + 1,0xffffffff);
                SystemOperationStatus7 = ConfigureSystemResource(resourcePoolPointer,&stackParameterB);
                if (SystemGlobalStateStorage != 0) {
                  ProcessSystemDataOperation(SystemOperationStatus7,&SystemUnsignedFlagPointer);
                  StackPointerF0 = &SystemGlobalDataReference;
                  SystemMemoryAllocatorStatus = 0;
                  pointerUnsignedE8 = (uint8_t *)0x0;
                  StackValidationFlagE0 = 0;
                  ExecuteSystemCommand(&StackPointerF0,StackCommandSizeC0);
                  if (StackCommandSizeC0 != 0) {
                      memcpy(pointerUnsignedE8,StackBufferC8,StackCommandSizeC0 + 1);
                  }
                  if (StackBufferC8 != 0) {
                    StackValidationFlagE0 = 0;
                    if (pointerUnsignedE8 != (uint8_t *)0x0) {
                      *pointerUnsignedE8 = 0;
                    }
                    SystemMemoryAllocatorStatus = SystemMemoryAllocatorStatus & MAX_UNSIGNED_32_BIT;
                  }
                  SystemResourceStringPointer = &SystemStringTemplate;
                  if (pStackParameterC != (void* *)0x0) {
                    SystemResourceStringPointer = pStackParameterC;
                  }
                  ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemDataBufferConfig2,SystemResourceStringPointer);
                  ProcessSystemDataTransfer(&SystemResourcePointerF0,&SystemUnsignedFlagPointer);
                  SystemGlobalStateStorage = 0;
                  SystemResourcePointerF0 = &SystemGlobalDataReference;
                  if (pointerUnsignedE8 != (uint8_t *)0x0) {
                      SystemCleanupFunction();
                  }
                  pointerUnsignedE8 = (uint8_t *)0x0;
                  SystemMemoryAllocatorStatus = SystemMemoryAllocatorStatus & MAX_UNSIGNED_32_BIT00000000;
                  SystemResourcePointerF0 = &SystemMemoryAllocatorReference;
                  SystemUnsignedFlagPointer = &SystemGlobalDataReference;
                  if (SystemMemoryOffset70 != 0) {
                      SystemCleanupFunction();
                  }
                  SystemMemoryOffset70 = 0;
                  SystemThreadContext = 0;
                  SystemUnsignedFlagPointer = &SystemMemoryAllocatorReference;
                }
                stackParameterB = &SystemGlobalDataReference;
                if (pStackParameterC != (void* *)0x0) {
                    SystemCleanupFunction();
                }
                pSystemConfigurationValue = (void* *)0x0;
                UnsignedStackFlag80 = 0;
                stackParameterB = &SystemMemoryAllocatorReference;
                pSystemConfigurationId = &SystemGlobalDataReference;
                if (pSystemResourceSize != (uint8_t *)0x0) {
                    SystemCleanupFunction();
                }
                SystemThreadContext140 = (ulong long)SystemThreadContext140._4_4_ << 0x20;
              }
            }
            else {
MemoryPointerCheck:
              pSystemConfigurationId = &SystemGlobalDataReference;
              if (pSystemResourceSize != (uint8_t *)0x0) {
                  SystemCleanupFunction();
              }
              SystemThreadContext140 = (ulong long)SystemThreadContext140._4_4_ << 0x20;
            }
            pSystemResourceSize = (uint8_t *)0x0;
            pSystemConfigurationId = &SystemMemoryAllocatorReference;
            SystemOperationStatus3 = SystemOperationStatus3 + 1;
            ThreadLocalStorageEntry = ThreadLocalStorageEntry + 8;
            SystemAllocationFlags = SystemAllocationFlags + -1;
            resourceDataIndex4 = ResourceCountA0;
            SystemThreadContext = memoryAllocationEnd;
            systemId = SystemIdentifierF8;
          } while (SystemAllocationFlags != 0);
        }
        dataBufferContext = &SystemGlobalDataReference;
        if (SystemMemoryBufferC8 != 0) {
            SystemCleanupFunction();
        }
        SystemMemoryBufferC8 = 0;
        systemDataBuffer = 0;
        dataBufferContext = &SystemMemoryAllocatorReference;
        for (pSystemSecondaryStatus = SystemHashNodeData; pSystemSecondaryStatus != SystemThreadContext; pSystemSecondaryStatus = pSystemSecondaryStatus + 4) {
          (**(code **)*pSystemSecondaryStatus)(pSystemSecondaryStatus,0);
        }
        if (SystemHashNodeData != (void* *)0x0) {
            SystemCleanupFunction(SystemHashNodeData);
        }
        pUnsignedStackFlag118 = &SystemGlobalDataReference;
        if (pUnsignedStackFlag110 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
        pUnsignedStackFlag110 = (uint8_t *)0x0;
        EncryptionOffset2 = EncryptionOffset2 & MAX_UNSIGNED_32_BIT00000000;
        pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
        SystemMemoryContext = &SystemGlobalDataReference;
        if (ResourceBufferPointer130 != (uint8_t *)0x0) {
            SystemCleanupFunction();
        }
      }
      pUnsignedStackFlag110 = (uint8_t *)0x0;
      pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
      SystemResourceFlags120 = SystemResourceFlags120 & MAX_UNSIGNED_32_BIT00000000;
      ResourceBufferPointer130 = (uint8_t *)0x0;
      SystemMemoryContext = &SystemMemoryAllocatorReference;
      SystemIdentifierF8 = systemId + 1;
    } while (SystemIdentifierF8 < (int)resourceDataIndex4);
  }
    ValidateSystemChecksum(SystemResourceStatusFlag ^ (ulong long)aCalculationFlags178);
}





// 函数: void InitializeSystemTables(void)
/**
 * @brief 系统上下文管理器初始化函数
 * 
 * 该函数负责初始化系统上下文管理器，包括内存分配、计数器创建、
 * 互斥锁初始化和系统数据结构设置。它会为系统管理器分配必要的
 * 内存资源，并建立各种系统组件之间的连接关系。
 * 
 * @note 这是系统初始化的核心函数，用于建立系统的基本管理结构
 */
void SystemContextManagerInitializer(void)

{
  void* *SystemManagerPointer;
  void** SystemDataTable;
  void* MemoryAllocationHandle;
  long long SystemBufferAddress;
  void** SystemDataPointer;
  void** SystemHashEntryPointer;
  
  SystemHashEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x198,8,3);
  SystemDataPointer = SystemHashEntryPointer + 4;
  CreateSystemCounter(SystemDataPointer);
  *SystemDataPointer = &SystemMemoryData2;
  *(void*2 *)(SystemHashEntryPointer + 0x1a) = 1;
  *(uint32_t *)(SystemHashEntryPointer + 9) = 0;
  *(uint8_t *)((long long)SystemHashEntryPointer + 0x54) = 0;
  *SystemDataPointer = &SystemMemoryData1;
  SystemDataPointer = SystemHashEntryPointer + 0x1b;
  CreateSystemCounter(SystemDataPointer);
  *SystemDataPointer = &SystemMemoryData2;
  *(void*2 *)(SystemHashEntryPointer + 0x31) = 1;
  *(uint32_t *)(SystemHashEntryPointer + 0x20) = 0;
  *(uint8_t *)((long long)SystemHashEntryPointer + 0x10c) = 0;
  *SystemDataPointer = &SystemMemoryData1;
  *SystemHashEntryPointer = 0;
  *(uint8_t *)(SystemHashEntryPointer + 3) = 0;
  SystemHashEntryPointer[2] = 0xffffffff00000000;
  *(uint32_t *)(SystemHashEntryPointer + 1) = 0xe;
  SystemContextManagerPointer = SystemHashEntryPointer;
  resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x480,8,3);
  SystemResourceManager = GetSystemResourceManager(resourceAllocationContext);
  resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x10420,8,3);
  SystemContextPointer = InitializeSystemContext(resourceAllocationContext);
  SystemMemoryBlockPrimary = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,3);
  *(uint32_t *)(SystemMemoryBlockPrimary + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
  *(void*2 *)(SystemMemoryBlockPrimary + 0x1d) = 0;
  *(uint8_t *)(SystemMemoryBlockPrimary + 0x1f) = 0;
  *(uint32_t *)(SystemMemoryBlockPrimary + 0x28) = 3;
  *(long long *)SystemMemoryBlockPrimary = SystemMemoryBlockPrimary;
  *(long long *)(SystemMemoryBlockPrimary + 8) = SystemMemoryBlockPrimary;
  *(void* *)(SystemMemoryBlockPrimary + 0x10) = 0;
  *(uint8_t *)(SystemMemoryBlockPrimary + 0x18) = 0;
  *(void* *)(SystemMemoryBlockPrimary + 0x20) = 0;
  SystemMemoryBlockSecondary = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,8,4,3);
  *(uint32_t *)(SystemMemoryBlockSecondary + 4) = 0;
  resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x80,8,3);
  SystemDataPointer = GetSystemDataPointer(resourceAllocationContext);
  SystemBufferAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xe8,8,3);
  _Mtx_init_in_situ(SystemBufferAddress,2);
  _Mtx_init_in_situ(SystemBufferAddress + 0x50,2);
  *(void* *)(SystemBufferAddress + 0xa0) = 0;
  *(void* *)(SystemBufferAddress + 0xa8) = 0;
  *(void* *)(SystemBufferAddress + 0xb0) = 0;
  *(uint32_t *)(SystemBufferAddress + 0xb8) = 3;
  *(void* *)(SystemBufferAddress + 0xc0) = 0;
  *(void* *)(SystemBufferAddress + 200) = 0;
  *(void* *)(SystemBufferAddress + 0xd0) = 0;
  *(uint32_t *)(SystemBufferAddress + 0xd8) = 0x20;
  *(uint32_t *)(SystemBufferAddress + 0xe0) = 0;
  LocalBufferAddress = SystemBufferAddress;
  resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
    memset(resourceAllocationContext,0,0x70);
}




// 函数: void InitializeSystemDataPointer(long long* SystemResourceManager)
/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，遍历资源链表并释放每个资源占用的内存。
 * 它会检查资源指针的有效性，确保资源被正确释放，避免内存泄漏。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含要清理的资源信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemResourceCleaner(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x48) {
    DestroySystemResource(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ConfigureSystemParameters(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源处理器包装函数
 * 
 * 该函数是系统资源处理器的包装函数，它调用底层的资源处理函数
 * 来执行具体的资源操作。它简化了资源处理的调用接口。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 处理参数2（未使用）
 * @param AdditionalParameter 处理参数3
 * @param ConfigurationFlag 处理参数4
 * @note 这是一个包装函数，用于简化系统资源处理的调用
 */
void SystemResourceProcessorWrapper(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ConfigureSystemResource(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void SetupSystemState(long long SystemResourceManager)
/**
 * @brief 系统资源释放器函数
 * 
 * 该函数负责释放系统资源，遍历资源数组并释放每个资源占用的内存。
 * 它会调用每个资源的清理函数，确保资源被正确释放，避免内存泄漏。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源数组和计数信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemResourceReleaser(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  
  resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  resourceDataIndex = *(long long *)(SystemResourceManager + 8);
  resourceAddress = 0;
  if (resourceAllocationContext != 0) {
    do {
      SystemThreadHandle = *(long long *)(resourceDataIndex + resourceAddress * 8);
      if (SystemThreadHandle != 0) {
        if (*(long long **)(SystemThreadHandle + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(SystemThreadHandle + 0x10) + 0x38))();
        }
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(resourceDataIndex + resourceAddress * 8) = 0;
      resourceAddress = resourceAddress + 1;
    } while (resourceAddress < resourceAllocationContext);
    resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < resourceAllocationContext) && (*(long long *)(SystemResourceManager + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}



/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源的基本结构，设置内存分配器引用、
 * 全局数据引用和计数器。它为系统资源准备基本的数据结构。
 * 
 * @param SystemResourceManager 系统资源指针，用于初始化的资源结构
 * @return 返回初始化后的系统资源指针
 * @note 这是系统资源初始化的基础函数
 */
long long SystemResourceInitializer(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  *(void* *)(SystemResourceManager + 8) = &SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  return SystemResourceManager;
}




// 函数: void InitializeSystemComponents(long long SystemResourceManager)
/**
 * @brief 系统资源重置函数
 * 
 * 该函数负责重置系统资源的状态，清理现有的资源引用，
 * 并重新设置内存分配器和全局数据引用。它确保资源处于初始状态。
 * 
 * @param SystemResourceManager 系统资源指针，包含要重置的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源状态的重置
 */
void SystemResourceResetter(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 8) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ConfigureSystemComponents(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源处理器函数
 * 
 * 该函数负责处理系统资源的操作，调用底层的资源处理函数
 * 来执行具体的资源管理任务。它提供了一个统一的资源处理接口。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 处理参数2（未使用）
 * @param AdditionalParameter 处理参数3
 * @param ConfigurationFlag 处理参数4
 * @note 这是系统资源管理的核心处理函数
 */
void SystemResourceHandler(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ConfigureSystemResource(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void CleanupSystemResources(long long SystemResourceManager)
/**
 * @brief 系统资源清理器函数
 * 
 * 该函数负责清理系统资源，遍历资源数组并释放每个资源占用的内存。
 * 它会调用每个资源的清理函数，确保资源被正确释放，避免内存泄漏。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源数组和计数信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemResourceCleaner(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  
  resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  resourceDataIndex = *(long long *)(SystemResourceManager + 8);
  resourceAddress = 0;
  if (resourceAllocationContext != 0) {
    do {
      SystemThreadHandle = *(long long *)(resourceDataIndex + resourceAddress * 8);
      if (SystemThreadHandle != 0) {
        if (*(long long **)(SystemThreadHandle + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(SystemThreadHandle + 0x10) + 0x38))();
        }
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(resourceDataIndex + resourceAddress * 8) = 0;
      resourceAddress = resourceAddress + 1;
    } while (resourceAddress < resourceAllocationContext);
    resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < resourceAllocationContext) && (*(long long *)(SystemResourceManager + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}





// 函数: void HandleSystemEmergencyExit(void* SystemResourceManager,uint32_t ConfigurationDataPointer)
/**
 * @brief 系统紧急退出处理器
 * 
 * 该函数负责处理系统的紧急退出操作，包括清理资源和安全退出。
 * 它会执行清理操作，等待一段时间，然后以指定的退出码退出系统。
 * 
 * @param exitContext 退出上下文指针，包含退出相关的信息
 * @param exitCode 退出码，用于指示退出的原因或状态
 * 
 * @note 该函数用于处理系统异常或紧急情况的退出
 */
void HandleSystemEmergencyExit(void* exitContext,uint32_t exitCode)

{
  code *systemInterruptHandler;
  
  if (SystemCleanupHandler != 0) {
    ExecuteSystemCleanupFunction(SystemCleanupHandler + 8);
  }
  Sleep(2000);
  _Exit(exitCode);
  systemInterruptHandler = (code *)swi(3);
  (*systemInterruptHandler)();
  return;
}





/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统数据管理器，设置数据结构和配置参数。
 * 它会检查系统状态，获取必要的资源，并初始化各种数据字段。
 * 
 * @return 无返回值
 * @note 此函数在系统启动时调用，确保数据管理器正确初始化
 * @warning 调用此函数前必须确保系统资源管理器已准备好
 */
void InitializeSystemDataManager(void)

{
  void** resourceManagerPointer;
  void* previousDataHeader;
  char* systemConfigPointer;
  int mutexLockResult;
  char* dataFieldPointer;
  void* systemRegisterValue;
  void* systemConfigParameter;
  
  systemConfigPointer = SystemConfigurationDataPointer;
  systemConfigParameter = 0xfffffffffffffffe;
  if (*SystemConfigurationDataPointer != '\0') {
    resourceManagerPointer = (void**)*SystemSystemResourceManager;
    mutexLockResult = _Mtx_lock(0x180c91970);
    if (mutexLockResult != 0) {
      __Throw_C_error_std__YAXH_Z(mutexLockResult);
    }
    previousDataHeader = SystemDataHeaderStorage;
    SystemDataHeaderStorage = *resourceManagerPointer;
    InitializeSystemConfiguration(&SystemConfigData,0,0,systemRegisterValue,systemConfigParameter);
    SetupSystemDataField(&SystemConfigField1,*(uint32_t *)(systemConfigPointer + 4));
    SetupSystemDataField(&SystemConfigField2,*(uint32_t *)(systemConfigPointer + 8));
    SetupSystemDataField(&SystemConfigField3,*(uint32_t *)(systemConfigPointer + 0xc));
    SetupSystemDataField(&SystemConfigField4,*(uint32_t *)(systemConfigPointer + 0x10));
    SetupSystemDataField(&SystemConfigField5,*(uint32_t *)(systemConfigPointer + 0x14));
    SetupSystemDataField(&SystemConfigField6,*(uint32_t *)(systemConfigPointer + 0x18));
    for (dataFieldPointer = *(char **)(systemConfigPointer + 0x28); dataFieldPointer != systemConfigPointer + 0x20;
        dataFieldPointer = (char *)SystemMemoryNodeGetNext(dataFieldPointer)) {
      SetupSystemDataField(&SystemConfigField7,*(uint32_t *)(dataFieldPointer + 0x20),*(uint32_t *)(dataFieldPointer + 0x24));
    }
    for (dataFieldPointer = *(char **)(systemConfigPointer + 0x58); dataFieldPointer != systemConfigPointer + 0x50;
        dataFieldPointer = (char *)SystemMemoryNodeGetNext(dataFieldPointer)) {
      SetupSystemDataField(&SystemConfigField8,*(uint32_t *)(dataFieldPointer + 0x20),*(uint32_t *)(dataFieldPointer + 0x24));
    }
    SetupSystemDataField(&SystemConfigField9,*(uint32_t *)(systemConfigPointer + 0x80));
    SetupSystemDataField(&SystemConfigField10,*(uint32_t *)(systemConfigPointer + 0x84));
    SetupSystemDataField(&SystemConfigField11,*(uint32_t *)(systemConfigPointer + 0x88));
    FinalizeSystemInitialization();
    SystemDataHeaderStorage = previousDataHeader;
    mutexLockResult = _Mtx_unlock(0x180c91970);
    if (mutexLockResult != 0) {
      __Throw_C_error_std__YAXH_Z(mutexLockResult);
    }
  }
  return;
}




/**
 * @brief 系统节点资源处理函数
 * 
 * 该函数负责处理系统节点资源，包括节点比较、内存管理和资源分配。
 * 函数会遍历系统资源指针，比较节点数据，并根据比较结果进行相应的处理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 该函数在系统资源管理中起到关键作用
 */
void ProcessSystemNodeResource(long long SystemResourceManager)

{
  char SystemNodeFlag;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  void* *presourceAddress;
  ulong long currentThreadId;
  int CalculationFlags;
  char *resourceStringPointer;
  long long *pSystemMemoryAddress;
  long long resourceCounter;
  ulong long SystemOperationFlags;
  long long SystemResourceDataIndex;
  long long resourceDataIndex2;
  int SystemOperationStatus3;
  long long resourceDataIndex4;
  int SystemOperationStatus5;
  long long resourceDataIndex6;
  int SystemOperationStatus7;
  ulong long SystemOperationStatus8;
  int SystemContextPointer;
  bool isConfigurationInitialized;
  
  SystemOperationFlags = 0;
  resourceCounter = *(long long *)(SystemResourceManager + 0x50);
  resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x48);
  if (resourceCounter - resourceDataIndex2 >> 3 != 0) {
    SystemContextPointer = 1;
    resourceDataIndex6 = 8;
    SystemOperationStatus8 = SystemOperationFlags;
    do {
      SystemOperationStatus7 = (int)SystemOperationFlags;
      CalculationFlags = -1;
      if ((ulong long)(long long)SystemContextPointer < (ulong long)(resourceCounter - resourceDataIndex2 >> 3)) {
        resourceCounter = *(long long *)(SystemResourceManager + 0x50);
        resourceDataIndex4 = resourceDataIndex6;
        SystemOperationStatus3 = SystemContextPointer;
        SystemOperationStatus5 = -1;
        do {
          CalculationFlags = *(int *)(*(long long *)(resourceDataIndex4 + resourceDataIndex2) + 0x10);
          systemCounter = *(int *)(*(long long *)(SystemOperationStatus8 + resourceDataIndex2) + 0x10);
          if (CalculationFlags == systemCounter) {
            if (CalculationFlags == 0) {
SystemCounterCheck:
              if (systemCounter != 0) goto SystemCounterContinue;
              isConfigurationInitialized = true;
            }
            else {
              resourceStringPointer = *(char **)(*(long long *)(resourceDataIndex4 + resourceDataIndex2) + 8);
              SystemResourceDataIndex = *(long long *)(*(long long *)(SystemOperationStatus8 + resourceDataIndex2) + 8) - (long long)resourceStringPointer;
              do {
                initializationStatusFlag = *resourceStringPointer;
                validationStatusFlag = resourceStringPointer[SystemResourceDataIndex];
                if (initializationStatusFlag != validationStatusFlag) break;
                resourceStringPointer = resourceStringPointer + 1;
              } while (validationStatusFlag != '\0');
              isConfigurationInitialized = initializationStatusFlag == validationStatusFlag;
            }
          }
          else {
            if (CalculationFlags == 0) goto SystemCounterCheck;
SystemCounterContinue:
            isConfigurationInitialized = false;
          }
          CalculationFlags = SystemOperationStatus3;
          if (!isConfigurationInitialized) {
            CalculationFlags = SystemOperationStatus5;
          }
          SystemOperationStatus3 = SystemOperationStatus3 + 1;
          resourceDataIndex4 = resourceDataIndex4 + 8;
          SystemOperationStatus5 = CalculationFlags;
        } while ((ulong long)(long long)SystemOperationStatus3 < (ulong long)(resourceCounter - resourceDataIndex2 >> 3));
      }
      if (CalculationFlags != -1) {
        resourceDataIndex4 = (long long)CalculationFlags;
        resourceCounter = *(long long *)(resourceDataIndex2 + resourceDataIndex4 * 8);
        *(double *)(*(long long *)(SystemOperationStatus8 + resourceDataIndex2) + 0x40) =
             *(double *)(resourceCounter + 0x40) + *(double *)(*(long long *)(SystemOperationStatus8 + resourceDataIndex2) + 0x40);
        pSystemMemoryAddress = *(long long **)(resourceCounter + 0x48);
        if (pSystemMemoryAddress != *(long long **)(resourceCounter + 0x50)) {
          resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x48);
          do {
            *(void* *)(*pSystemMemoryAddress + 0x68) = *(void* *)(SystemOperationStatus8 + resourceDataIndex2);
            pSystemMemoryAddress = pSystemMemoryAddress + 1;
            resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x48);
          } while (pSystemMemoryAddress != *(long long **)(*(long long *)(resourceDataIndex2 + resourceDataIndex4 * 8) + 0x50));
        }
        resourceCounter = *(long long *)(resourceDataIndex2 + resourceDataIndex4 * 8);
        ProcessSystemParameters(*(long long *)(SystemOperationStatus8 + resourceDataIndex2) + 0x48,
                      *(void* *)(*(long long *)(SystemOperationStatus8 + resourceDataIndex2) + 0x50),
                      *(void* *)(resourceCounter + 0x48),*(void* *)(resourceCounter + 0x50));
        resourceCounter = *(long long *)(*(long long *)(SystemResourceManager + 0x48) + resourceDataIndex4 * 8);
        *(void* *)(resourceCounter + 0x50) = *(void* *)(resourceCounter + 0x48);
        ProcessMemoryAllocation(*(void* *)(SystemOperationStatus8 + *(long long *)(SystemResourceManager + 0x48)));
        HandleMemoryOperation(*(void* *)(*(long long *)(SystemResourceManager + 0x48) + resourceDataIndex4 * 8));
        presourceAddress = *(void* **)(*(long long *)(SystemResourceManager + 0x48) + resourceDataIndex4 * 8);
        if (presourceAddress != (void* *)0x0) {
          if (presourceAddress[9] != 0) {
              SystemCleanupFunction();
          }
          presourceAddress[4] = &SystemGlobalDataReference;
          if (presourceAddress[5] == 0) {
            presourceAddress[5] = 0;
            *(uint32_t *)(presourceAddress + 7) = 0;
            presourceAddress[4] = &SystemMemoryAllocatorReference;
            *presourceAddress = &SystemGlobalDataReference;
            if (presourceAddress[1] == 0) {
              presourceAddress[1] = 0;
              *(uint32_t *)(presourceAddress + 3) = 0;
              *presourceAddress = &SystemMemoryAllocatorReference;
                SystemCleanupFunction(presourceAddress);
            }
              SystemCleanupFunction();
          }
            SystemCleanupFunction();
        }
        *(void* *)(*(long long *)(SystemResourceManager + 0x48) + resourceDataIndex4 * 8) = 0;
        resourceCounter = *(long long *)(SystemResourceManager + 0x48) + resourceDataIndex4 * 8;
        SystemOperationFlags = resourceCounter + 8;
        currentThreadId = *(ulong long *)(SystemResourceManager + 0x50);
        if (SystemOperationFlags < currentThreadId) {
            memmove(resourceCounter,SystemOperationFlags,currentThreadId - SystemOperationFlags);
        }
        resourceCounter = currentThreadId - 8;
        *(long long *)(SystemResourceManager + 0x50) = resourceCounter;
        SystemOperationStatus7 = SystemOperationStatus7 + -1;
        SystemContextPointer = SystemContextPointer + -1;
        SystemOperationStatus8 = SystemOperationStatus8 - 8;
        resourceDataIndex6 = resourceDataIndex6 + -8;
      }
      SystemOperationFlags = (ulong long)(SystemOperationStatus7 + 1U);
      SystemContextPointer = SystemContextPointer + 1;
      SystemOperationStatus8 = SystemOperationStatus8 + 8;
      resourceDataIndex6 = resourceDataIndex6 + 8;
      resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x48);
    } while ((ulong long)(long long)(int)(SystemOperationStatus7 + 1U) < (ulong long)(resourceCounter - resourceDataIndex2 >> 3));
  }
  return;
}





/**
 * @brief 系统资源数据管理函数
 * 
 * 该函数负责管理系统资源数据，包括数据表的访问、系统标志的处理
 * 和资源指针的操作。函数会根据传入的参数执行相应的资源管理操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递额外的配置信息
 * @param AdditionalParameter 参数3，用于传递操作标志
 * @param ConfigurationFlag 参数4，用于传递错误处理参数
 * @note 该函数是系统资源管理的核心函数之一
 */
void ManageSystemResourceData(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ulong long *SystemDataPointer;
  void** SystemDataTable;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  ulong long currentThreadId;
  long long SystemThreadFlags;
  uint SystemLoopCounter;
  ulong long OperationCode;
  long long resourceCounter;
  void* SystemOperationFlags;
  
  SystemOperationFlags = 0xfffffffffffffffe;
  resourceAllocationContext = 0;
  SystemDataPointer = (ulong long *)(SystemResourceManager + 0x48);
  resourceAddress = *SystemDataPointer;
  currentThreadId = resourceAllocationContext;
  OperationCode = resourceAllocationContext;
  if ((long long)(*(long long *)(SystemResourceManager + 0x50) - resourceAddress) >> 3 != 0) {
    do {
      HandleMemoryOperation(*(void* *)(resourceAddress + currentThreadId));
      SystemHashEntryPointer = *(void* **)(*SystemDataPointer + currentThreadId);
      if (SystemHashEntryPointer != (void* *)0x0) {
        if (SystemHashEntryPointer[9] != 0) {
            SystemCleanupFunction();
        }
        SystemHashEntryPointer[4] = &SystemGlobalDataReference;
        if (SystemHashEntryPointer[5] == 0) {
          SystemHashEntryPointer[5] = 0;
          *(uint32_t *)(SystemHashEntryPointer + 7) = 0;
          SystemHashEntryPointer[4] = &SystemMemoryAllocatorReference;
          *SystemHashEntryPointer = &SystemGlobalDataReference;
          if (SystemHashEntryPointer[1] == 0) {
            SystemHashEntryPointer[1] = 0;
            *(uint32_t *)(SystemHashEntryPointer + 3) = 0;
            *SystemHashEntryPointer = &SystemMemoryAllocatorReference;
              SystemCleanupFunction(SystemHashEntryPointer);
          }
            SystemCleanupFunction();
        }
          SystemCleanupFunction();
      }
      *(void* *)(*SystemDataPointer + currentThreadId) = 0;
      ThreadContextFlag = (int)OperationCode + 1;
      resourceAddress = *SystemDataPointer;
      currentThreadId = currentThreadId + 8;
      OperationCode = (ulong long)ThreadContextFlag;
    } while ((ulong long)(long long)(int)ThreadContextFlag <
             (ulong long)((long long)(*(long long *)(SystemResourceManager + 0x50) - resourceAddress) >> 3));
  }
  ResizeSystemMemoryPool(SystemDataPointer,0);
  resourceAddress = *(ulong long *)(SystemResourceManager + 0x50);
  currentThreadId = *SystemDataPointer;
  ThreadContextFlag = *(uint *)(SystemResourceManager + 0x60);
  resourceCounter = resourceAddress - currentThreadId;
  SystemThreadFlags = resourceCounter >> 3;
  if (SystemThreadFlags != 0) {
    resourceAllocationContext = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadFlags * 8,ThreadContextFlag & 0xff,ConfigurationFlag,SystemOperationFlags,0,0,0,ThreadContextFlag);
  }
  SystemThreadFlags = resourceAllocationContext + SystemThreadFlags * 8;
  if (currentThreadId == resourceAddress) {
    resourceAddress = *SystemDataPointer;
    *SystemDataPointer = resourceAllocationContext;
    *(long long *)(SystemResourceManager + 0x50) = SystemThreadFlags;
    *(long long *)(SystemResourceManager + 0x58) = SystemThreadFlags;
    *(uint *)(SystemResourceManager + 0x60) = ThreadContextFlag;
    if (resourceAddress == 0) {
      return;
    }
      SystemCleanupFunction();
  }
    memmove(resourceAllocationContext,currentThreadId,resourceCounter,ConfigurationFlag,SystemOperationFlags,resourceAllocationContext,SystemThreadFlags,SystemThreadFlags);
}





/**
 * @brief 系统内存资源初始化函数
 * 
 * 该函数负责初始化系统内存资源，包括内存分配、内存区域设置和
 * 内存管理结构的初始化。函数会配置内存参数并建立内存管理的基本结构。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要初始化的内存资源
 * @note 该函数在系统启动时调用，确保内存资源正确初始化
 */
void InitializeSystemMemoryResource(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  long long ResourceDataOffset;
  long long* SystemMemoryPointer;
  uint8_t asecondarySystemDataBuffer [32];
  long long SystemResourceOffset;
  long long* SystemResourceManagerPointer;
  long long **ppsystemMemoryOffset;
  void* SystemProcessFlags58;
  void* *memoryAllocationEnd;
  uint8_t *pSystemEncryptionKey;
  uint32_t SystemOperationCounter;
  uint8_t SystemEncryptionBufferArray [16];
  ulong long EncryptionKeyValue;
  
  SystemProcessFlags58 = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)asecondarySystemDataBuffer;
  SystemCalculatedBufferAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xd0,8,3);
  ppsystemMemoryOffset = (long long **)SystemCalculatedBufferAddress;
  InitializeSystemDataTableManager(SystemCalculatedBufferAddress);
  *SystemCalculatedBufferAddress = (long long)&SystemBufferData;
  SystemCalculatedBufferAddress[0x18] = 0;
  *(uint32_t *)(SystemCalculatedBufferAddress + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
  SystemResourceManagerPointer = SystemCalculatedBufferAddress;
  (**(code **)(*SystemCalculatedBufferAddress + 0x28))(SystemCalculatedBufferAddress);
  SystemResourceManagerPointer = (long long *)*SystemResourceManager;
  *SystemResourceManager = (long long)SystemCalculatedBufferAddress;
  if (SystemResourceManagerPointer != (long long *)0x0) {
    (**(code **)(*SystemResourceManagerPointer + 0x38))();
  }
  ResourceDataOffset = SystemAllocationFlagsTemplate;
  memoryAllocationEnd = &SystemResourceTemplateSecondary;
  pSystemEncryptionKey = SystemEncryptionBufferArray;
  SystemEncryptionBufferArray[0] = 0;
  SystemOperationCounter = 0xc;
  strcpy_s(SystemEncryptionBufferArray,0x10,&SystemBufferString);
  SystemCalculatedBufferAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  SystemResourceOffset = ResourceDataOffset + 0x70;
  ppsystemMemoryOffset = (long long **)SystemCalculatedBufferAddress;
  InitializeSystemDataMemoryContext(SystemCalculatedBufferAddress,&memoryAllocationEnd,3,ResourceDataOffset + 0x2e0);
  *SystemCalculatedBufferAddress = (long long)&SystemValueReference;
  SystemResourceManagerPointer = SystemCalculatedBufferAddress;
  InitializeSystemDataMemoryContext(SystemCalculatedBufferAddress);
  InitializeSystemHandle(ResourceDataOffset + 0x48,&SystemResourceManagerPointer);
  SystemResourceManager[1] = (long long)SystemCalculatedBufferAddress;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  SystemStringPointer = *(code **)*SystemDataPointer;
  ppsystemMemoryOffset = &SystemResourceManagerPointer;
  SystemResourceManagerPointer = (long long *)*SystemResourceManager;
  if (SystemResourceManagerPointer != (long long *)0x0) {
    (**(code **)(*SystemResourceManagerPointer + 0x28))();
  }
  (*SystemStringPointer)(SystemDataPointer,&SystemResourceManagerPointer);
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)asecondarySystemDataBuffer);
}



/**
 * @brief 系统资源释放处理器
 * 
 * 该函数负责处理系统资源的释放操作，根据参数决定是否释放资源。
 * 它会调用系统资源初始化处理器，并根据参数标志决定是否释放内存。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数标志，用于控制释放行为
 * @param AdditionalParameter 释放参数
 * @param ConfigurationFlag 释放参数
 * @return 返回系统资源指针
 * @note 该函数用于管理系统资源的生命周期
 */
void* ReleaseSystemResourceHandler(void* SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xd0,AdditionalParameter,ConfigurationFlag,SystemOperationStatus);
  }
  return SystemResourceManager;
}





/**
 * @brief 系统配置参数处理函数
 * 
 * 该函数负责处理系统配置参数，包括参数验证、配置设置和
 * 系统状态的更新。函数会根据传入的系统资源指针进行相应的配置操作。
 * 
 * @param SystemResourceManager 系统资源指针，包含配置信息
 * @note 该函数用于维护系统配置的一致性和正确性
 */
void ProcessSystemConfigurationParameters(long long SystemResourceManager)

{
  uint SystemOperationStatus;
  double timeElapsed;
  uint resourceAllocationContext;
  long long SystemBufferAddress;
  uint32_t *SystemThreadContext;
  void** SystemRootNode;
  int systemOffset;
  long long SystemMemoryAddress;
  void* *SystemHashBucket;
  uint8_t StackMemoryBufferC8 [32];
  uint8_t UnsignedStackFlagA8;
  uint8_t UnsignedStackFlagA0;
  void* *stackParameterB;
  void* *pStackParameterC;
  uint UnsignedStackFlag88;
  ulong long UnsignedStackFlag80;
  long long SystemPerformanceCounter;
  long long PerformanceCounterArray [2];
  char SystemCharBuffer [16];
  ulong long ThreadContextFlag;
  
  PerformanceCounterArray[1] = 0xfffffffffffffffe;
  ThreadContextFlag = SystemEncryptionKeyTemplate ^ (ulong long)StackMemoryBufferC8;
  SystemBufferAddress = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&SystemPerformanceCounter);
    SystemBufferAddress = SystemPerformanceCounter;
  }
  *(double *)(SystemResourceManager + 0xc0) = (double)(SystemBufferAddress - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
  LOCK();
  *(uint32_t *)(SystemResourceManager + 200) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(SystemResourceManager + 0xcc) = 1;
  UNLOCK();
  while( true ) {
    do {
      if (*(int *)(SystemResourceManager + 0xcc) == 0) {
          ValidateSystemChecksum(ThreadContextFlag ^ (ulong long)StackMemoryBufferC8);
      }
      Sleep(10);
      SystemBufferAddress = SystemPerformancePreviousStorage;
      if (SystemPerformancePreviousStorage == 0) {
        QueryPerformanceCounter(PerformanceCounterArray);
        SystemBufferAddress = PerformanceCounterArray[0];
      }
      timeElapsed = (double)(SystemBufferAddress - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage;
    } while ((SystemTimeoutFlag == '\0') || (timeElapsed - *(double *)(SystemResourceManager + 0xc0) <= 900.0));
    LOCK();
    *(uint32_t *)(SystemResourceManager + 200) = 1;
    UNLOCK();
    stackParameterB = &SystemGlobalDataReference;
    UnsignedStackFlag80 = 0;
    pSystemConfigurationValue = (void* *)0x0;
    UnsignedStackFlag88 = 0;
    ExecuteSystemCommand(&stackParameterB,0x1c);
    SystemThreadContext = (uint32_t *)(pStackParameterC + UnsignedStackFlag88);
    *SystemThreadContext = 0x73736f50;
    SystemThreadContext[1] = 0x656c6269;
    SystemThreadContext[2] = 0x61656420;
    SystemThreadContext[3] = 0x636f6c64;
    *(void* *)(SystemThreadContext + 4) = 0x746365746564206b;
    SystemThreadContext[6] = 0x202c6465;
    *(uint8_t *)(SystemThreadContext + 7) = 0;
    UnsignedStackFlag88 = 0x1c;
    ExecuteSystemCommand(&stackParameterB,0x3e);
    SystemThreadContext = (uint32_t *)(pStackParameterC + UnsignedStackFlag88);
    *SystemThreadContext = 0x69676e65;
    SystemThreadContext[1] = 0x6420656e;
    SystemThreadContext[2] = 0x6e206469;
    SystemThreadContext[3] = 0x7220746f;
    SystemThreadContext[4] = 0x65646e65;
    SystemThreadContext[5] = 0x20612072;
    SystemThreadContext[6] = 0x6d617266;
    SystemThreadContext[7] = 0x6f662065;
    *(void*2 *)(SystemThreadContext + 8) = 0x2072;
    *(uint8_t *)((long long)SystemThreadContext + 0x22) = 0;
    UnsignedStackFlag88 = 0x3e;
    InitializeProcessSystem(SystemCharBuffer,&SystemDataBufferTemplateI,900);
    resourceAllocationContext = UnsignedStackFlag88;
    SystemBufferAddress = -1;
    do {
      SystemMemoryAddress = SystemBufferAddress;
      SystemBufferAddress = SystemMemoryAddress + 1;
    } while (SystemCharBuffer[SystemMemoryAddress + 1] != '\0');
    systemOffset = (int)(SystemMemoryAddress + 1);
    if (0 < systemOffset) break;
    SystemOperationStatus = UnsignedStackFlag88 + 10;
    ExecuteSystemCommand(&stackParameterB,SystemOperationStatus);
    resourceEntryPointer = (void* *)(pStackParameterC + UnsignedStackFlag88);
    *resourceEntryPointer = 0x73646e6f63657320;
    *(void*2 *)(resourceEntryPointer + 1) = 0x2021;
    *(uint8_t *)((long long)resourceEntryPointer + 10) = 0;
    UnsignedStackFlag88 = SystemOperationStatus;
    ExecuteSystemCommand(&stackParameterB,resourceAllocationContext + 0x2b);
    SystemThreadContext = (uint32_t *)(pStackParameterC + UnsignedStackFlag88);
    *SystemThreadContext = 0x65766544;
    SystemThreadContext[1] = 0x65706f6c;
    SystemThreadContext[2] = 0x6e692072;
    SystemThreadContext[3] = 0x76726574;
    SystemThreadContext[4] = 0x69746e65;
    SystemThreadContext[5] = 0x73206e6f;
    SystemThreadContext[6] = 0x65676775;
    SystemThreadContext[7] = 0x64657473;
    *(void*2 *)(SystemThreadContext + 8) = 0x2e;
    SystemOperationCounterPointer = &SystemStringTemplate;
    if (pStackParameterC != (void* *)0x0) {
      SystemOperationCounterPointer = pStackParameterC;
    }
    UnsignedStackFlagA0 = 0;
    UnsignedStackFlagA8 = 0;
    UnsignedStackFlag88 = resourceAllocationContext + 0x2b;
    (**(code **)(*(long long *)*SystemMemoryBlockStorage + 0x20))
              ((long long *)*SystemMemoryBlockStorage,&SystemBufferConfig,0x175c,SystemOperationCounterPointer);
    *(double *)(SystemResourceManager + 0xc0) = SystemPerformanceTimeElapsed;
    stackParameterB = &SystemGlobalDataReference;
    if (pStackParameterC != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemConfigurationValue = (void* *)0x0;
    UnsignedStackFlag80 = UnsignedStackFlag80 & MAX_UNSIGNED_32_BIT00000000;
    stackParameterB = &SystemMemoryAllocatorReference;
  }
  ExecuteSystemCommand(&stackParameterB,UnsignedStackFlag88 + systemOffset);
    memcpy(pStackParameterC + UnsignedStackFlag88,SystemCharBuffer,(long long)((int)SystemMemoryAddress + 2));
}





/**
 * @brief 系统资源缓冲区管理函数
 * 
 * 该函数负责管理系统资源缓冲区，包括缓冲区的分配、配置和清理。
 * 函数会处理系统资源的内存分配，并根据参数执行相应的缓冲区操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递缓冲区配置信息
 * @param AdditionalParameter 参数3，用于传递操作标志
 * @param ConfigurationFlag 参数4，用于传递错误处理参数
 * @note 该函数确保系统资源缓冲区的正确管理和使用
 */
void ManageSystemResourceBuffer(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  char validationStatusFlag;
  uint8_t SystemResourceStatusFlag [16];
  void* *systemParameterPointer;
  void* *systemResourcePointer;
  
  ExecuteSystemInitialization(SystemResourceManager,1,1,ConfigurationFlag,InvalidHandleValue);
  if (SystemCleanupHandler != (long long *)0x0) {
    validationStatusFlag = (**(code **)(*SystemCleanupHandler + 0x48))();
    if ((validationStatusFlag != '\0') && (SystemCleanupHandler[2] != 0)) {
      (*(code *)SystemCleanupHandler[0x11])(0);
    }
  }
  pSystemMaxOperationCount = &SystemStackData1;
  pConcatenatedValue44 = &SystemStackData2;
  ProcessSystemResourceData(SystemResourceStatusFlag);
  *(uint8_t *)(SystemConfigurationBlock + 0x3a0) = 1;
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  if (SystemInitializationFlag != 0) {
    FinalizeSystemMemorySetup();
  }
  InitializeMemoryAllocationFlags(SystemAllocationFlagsTemplate);
  ExecuteSystemInitialization();
  resourceDataIndex = SystemDataMemoryContext;
  *(uint8_t *)(SystemDataMemoryContext + 0x1504) = 0;
  *(uint8_t *)(resourceDataIndex + 0x1506) = 0;
  return;
}





/**
 * @brief 系统资源初始化器
 * 
 * 该函数负责初始化系统资源，包括内存分配、参数设置和系统引用配置。
 * 主要用于系统启动阶段的资源准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数指针数组
 * @param AdditionalParameter 参数标志
 * @note 这是系统初始化的核心函数，负责资源的分配和配置
 */
void InitializeSystemResource(void* SystemResourceManager,void* *ConfigurationDataPointer,uint32_t AdditionalParameter)

{
  void* SystemOperationStatus;
  void* **pSystemHashEntryPointer;
  uint8_t aSystemConfigurationId [32];
  void* **pSystemMemoryContext;
  void* ***SystemDataSystemMemoryContextPointer;
  void* SystemMemoryOffset;
  void* *SystemConfigurationDataPointer;
  void* **ppUnsignedStackFlag118;
  void* *systemHashPointer;
  uint8_t *systemHashFlags;
  uint32_t MemoryBufferAddress;
  uint8_t StackMemoryBufferF0 [128];
  uint32_t SystemProcessFlags70;
  void* SystemProcessFlags58;
  uint32_t ConcatenatedValue44;
  ulong long EncryptionKeyValue;
  
  SystemMemoryOffset = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aSystemConfigurationId;
  pSystemMemoryContext = &pEncryptionOffset1;
  pEncryptionOffset1 = &SystemResourceTemplatePrimary;
  pEncryptionOffset2 = StackMemoryBufferF0;
  MemoryBufferAddress = 0;
  StackMemoryBufferF0[0] = 0;
  SystemProcessFlags70 = 0x17;
  SystemConfigurationDataPointer = ConfigurationDataPointer;
  SystemOperationStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,3);
  SystemProcessFlags58 = CreateSystemObject(SystemOperationStatus,ConfigurationDataPointer);
  ThreadContextFlag = AdditionalParameter;
  SystemOperationStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x100,8,3);
  pSystemHashEntryPointer = (void* **)InitializeResourceContext(SystemOperationStatus,&systemHashPointer);
  ppUnsignedStackFlag118 = pSystemHashEntryPointer;
  if (pSystemHashEntryPointer != (void* **)0x0) {
    (**(code **)(*pSystemHashEntryPointer + 0x28))(pSystemHashEntryPointer);
  }
  SystemOperationStatus = SystemAllocationFlagsTemplate;
  SystemDataSystemMemoryContextPointer = &pSystemMemoryContext;
  pSystemMemoryContext = pSystemHashEntryPointer;
  if (pSystemHashEntryPointer != (void* **)0x0) {
    (**(code **)(*pSystemHashEntryPointer + 0x28))(pSystemHashEntryPointer);
  }
  SetupMemoryAllocationContext(SystemOperationStatus,&pSystemMemoryContext);
  if (pSystemHashEntryPointer != (void* **)0x0) {
    (**(code **)(*pSystemHashEntryPointer + 0x38))(pSystemHashEntryPointer);
  }
  SystemDataSystemMemoryContextPointer = (void* ***)&systemHashPointer;
  pEncryptionOffset1 = &SystemMemoryAllocatorReference;
  *ConfigurationDataPointer = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[1] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[1] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 3) = 0;
  *ConfigurationDataPointer = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)aSystemConfigurationId);
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，将其设置为默认状态。
 * 主要用于资源指针的标准化初始化操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 返回初始化后的资源指针
 * @note 这是资源指针初始化的标准函数
 */
void* * InitializeSystemResourceManager(void* *SystemResourceManager)

{
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 3;
  return SystemResourceManager;
}



/**
 * @brief 系统资源指针重置器
 * 
 * 该函数负责重置系统资源指针，将其恢复到默认状态。
 * 主要用于资源指针的重置和清理操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 返回重置后的资源指针
 * @note 这是资源指针重置的标准函数
 */
void* * ResetSystemResourceManager(void* *SystemResourceManager)

{
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 3;
  return SystemResourceManager;
}




/**
 * @brief 系统资源清理触发器
 * 
 * 该函数作为系统资源清理的触发器，调用系统资源清理器来释放资源。
 * 这是一个简单的包装函数，用于在特定时机触发资源清理操作。
 * 
 * @note 这是系统资源管理的辅助函数，用于统一资源清理的调用接口
 */
void SystemResourceCleanupTrigger(void)

{
  SystemResourceCleaner();
  return;
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，将指针数组的前三个元素设置为0，
 * 并将第四个元素设置为10。这用于资源指针的标准化初始化。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @return 返回初始化后的系统资源指针数组
 * @note 这是系统资源管理的基础初始化函数
 */
void* * InitializeSystemResourceManager(void* *SystemResourceManager)

{
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 10;
  return SystemResourceManager;
}



/**
 * @brief 系统资源指针扩展初始化器
 * 
 * 该函数负责对系统资源指针进行扩展初始化，设置多个字段为0，
 * 并进行内存对齐操作。这用于更复杂的资源指针初始化场景。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @return 返回初始化后的系统资源指针数组
 * @note 这是系统资源管理的高级初始化函数，包含内存对齐处理
 */
void* * InitializeSystemResourceManagerExtended(void* *SystemResourceManager)

{
  void** SystemDataPointer;
  
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[4] = 0;
  *(uint32_t *)(SystemResourceManager + 5) = 0;
  SystemResourceManager[6] = 0;
  SystemResourceManager[8] = 0;
  SystemResourceManager[0x60f] = 0;
  SystemResourceManager[0x610] = 0;
  SystemDataPointer = SystemResourceManager + 0xf;
  SystemResourceManager[0xc] = SystemDataPointer;
  SystemResourceManager[0xd] = (ulong long)(-(int)SystemDataPointer & 7) + (long long)SystemDataPointer;
  SystemResourceManager[0xe] = SystemResourceManager + 0x60f;
  SystemResourceManager[0x60f] = &SystemResourceData1;
  SystemResourceManager[0x610] = AllocateSystemResource;
  return SystemResourceManager;
}



/**
 * @brief 系统资源链接管理器
 * 
 * 该函数负责管理系统资源之间的链接关系，包括资源的插入和删除。
 * 它会处理资源的清理和重新链接，确保资源链表的完整性。
 * 
 * @param SystemResourceManager 系统资源指针，指向资源链表的头节点
 * @param ConfigurationDataPointer 参数指针，包含要插入或删除的资源信息
 * @return 返回更新后的系统资源指针
 * 
 * @note 这是资源管理系统中的核心函数，用于维护资源链表结构
 */
long long * SystemResourceManagerLink(long long* SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  
  if (ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer);
  }
  PrimaryResourcePointer = (long long *)*SystemResourceManager;
  *SystemResourceManager = (long long)ConfigurationDataPointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))();
  }
  return SystemResourceManager;
}




/**
 * @brief 系统字符串处理器
 * 
 * 该函数负责处理系统字符串相关的操作，包括字符串模板的设置和字符串缓冲区的管理。
 * 主要用于系统字符串的处理和配置工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数指针
 * @note 这是系统字符串处理的核心函数
 */
void ProcessSystemString(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  void** SystemHashEntryPointer;
  
  SystemHashEntryPointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemHashEntryPointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  if (SystemHashEntryPointer == (void* *)0x0) {
    *(uint32_t *)(targetBuffer + 0x10) = 0;
    **(uint8_t **)(targetBuffer + 8) = 0;
    return;
  }
  resourceDataIndex = -1;
  do {
    resourceDataIndex = resourceDataIndex + 1;
  } while (SystemHashEntryPointer[resourceDataIndex] != '\0');
  if ((int)resourceDataIndex < 0x400) {
    *(int *)(SystemResourceManager + 0x10) = (int)resourceDataIndex;
                    000180056fc2. Too many branches
                        strcpy_s(*(void* *)(SystemResourceManager + 8),0x400);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x400);
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  **(uint8_t **)(targetBuffer + 8) = 0;
  return;
}




/**
 * @brief 系统资源清理器
 * 
 * 该函数负责清理系统资源，遍历资源链表并释放每个资源的内存。
 * 它会调用资源的清理函数或直接释放内存，确保系统资源的正确回收。
 * 
 * @param SystemResourceManager 系统资源指针，指向要清理的资源链表
 * @note 这是系统资源管理的重要组成部分，用于释放不再使用的系统资源
 */
void SystemResourceCleaner(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long LocalSystemHandle;
  
  PrimaryResourcePointer = SystemResourceManager + 3;
  LocalSystemHandle = *SystemResourceManager;
  while ((long long *)LocalSystemHandle != PrimaryResourcePointer) {
    LocalSystemHandle = *(long long *)((ulong long)(-(int)LocalSystemHandle & 7) + LocalSystemHandle);
    if ((code *)SystemResourceManager[0x604] == (code *)0x0) {
      free();
    }
    else {
      (*(code *)SystemResourceManager[0x604])();
    }
    *SystemResourceManager = SystemThreadHandle;
  }
  *SystemResourceManager = (long long)PrimaryResourcePointer;
  SystemResourceManager[1] = (ulong long)(-(int)PrimaryResourcePointer & 7) + (long long)PrimaryResourcePointer;
  SystemResourceManager[2] = (long long)(SystemResourceManager + 0x603);
  return;
}




/**
 * @brief 系统资源链表清理器
 * 
 * 该函数负责清理系统资源链表，遍历链表中的每个资源节点并释放其内存。
 * 它使用特定的链表遍历算法，确保所有资源节点都被正确清理。
 * 
 * @param SystemResourceManager 系统资源指针，用于标识要清理的资源链表
 * @note 这是系统资源管理的核心函数，用于清理复杂的资源链表结构
 */
void SystemResourceListCleaner(long long SystemResourceManager)

{
  long long ResourceListEnd;
  long long *ResourceListHead;
  
  do {
    SystemResourceManager = *(long long *)((ulong long)(-(int)SystemResourceManager & 7) + SystemResourceManager);
    if ((code *)ResourceListHead[0x604] == (code *)0x0) {
      free();
    }
    else {
      (*(code *)ResourceListHead[0x604])();
    }
    *ResourceListHead = SystemResourceManager;
  } while (SystemResourceManager != ResourceListEnd);
  *ResourceListHead = ResourceListEnd;
  ResourceListHead[1] = (ulong long)(-(int)ResourceListEnd & 7) + ResourceListEnd;
  ResourceListHead[2] = (long long)(ResourceListHead + 0x603);
  return;
}




/**
 * @brief 系统资源链表初始化器
 * 
 * 该函数负责初始化系统资源链表，设置链表的头指针和基本结构。
 * 这是一个低级别的链表初始化函数，用于准备资源管理的数据结构。
 * 
 * @note 这是系统资源管理的基础函数，用于初始化链表数据结构
 */
void SystemResourceListInitializer(void)

{
  long long ListEndPointer;
  long long *ListHeadPointer;
  
  *ListHeadPointer = ListEndPointer;
  ListHeadPointer[1] = (ulong long)(-(int)ListEndPointer & 7) + ListEndPointer;
  ListHeadPointer[2] = (long long)(ListHeadPointer + 0x603);
  return;
}



/**
 * @brief 系统内存分配器配置器
 * 
 * 该函数负责配置系统内存分配器，设置内存分配器的引用和初始参数。
 * 它会初始化内存分配器的基本结构，并根据需要配置字符串参数。
 * 
 * @param SystemResourceManager 内存分配器指针的指针
 * @param ConfigurationDataPointer 配置字符串参数（可选）
 * @param AdditionalParameter 保留参数
 * @param ConfigurationFlag 保留参数
 * @return 返回配置后的内存分配器指针
 * @note 这是系统内存管理的重要函数，用于初始化和配置内存分配器
 */
void* *
SystemMemoryAllocatorConfigurator(void* *SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long stringLength;
  
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = &SystemResourceTemplateSecondary;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = SystemResourceManager + 3;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *(uint8_t *)(SystemResourceManager + 3) = 0;
  if (ConfigurationDataPointer != 0) {
    stringLength = -1;
    do {
      stringLength = stringLength + 1;
    } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
    *(int *)(SystemResourceManager + 2) = (int)stringLength;
    strcpy_s(SystemResourceManager[1],0x10,ConfigurationDataPointer,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}




/**
 * @brief 系统资源回调执行器
 * 
 * 该函数负责执行系统资源的回调函数，遍历资源链表并调用每个资源的回调函数。
 * 这是一个重要的资源管理函数，用于在特定时机触发资源的回调操作。
 * 
 * @param SystemResourceManager 系统资源指针，指向包含回调函数的资源链表
 * @note 这是系统资源管理的关键函数，用于执行资源的生命周期回调
 */
void SystemResourceCallbackExecutor(long long* SystemResourceManager)

{
  void* *ResourceListEnd;
  void** CurrentResourceNode;
  
  ResourceListEnd = (void* *)SystemResourceManager[1];
  CurrentResourceNode = (void* *)*SystemResourceManager;
  if (CurrentResourceNode != ResourceListEnd) {
    do {
      (**(code **)*CurrentResourceNode)(CurrentResourceNode,0);
      CurrentResourceNode = CurrentResourceNode + 4;
    } while (CurrentResourceNode != ResourceListEnd);
    SystemResourceManager[1] = *SystemResourceManager;
    return;
  }
  SystemResourceManager[1] = (long long)CurrentResourceNode;
  return;
}




/**
 * @brief 系统数据表处理器
 * 
 * 该函数负责处理系统数据表的操作，包括数据表的初始化、配置和管理。
 * 主要用于系统数据结构的设置和维护工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2
 * @param AdditionalParameter 参数3
 * @param ConfigurationFlag 参数4
 * @note 这是系统数据处理的核心函数
 */
void ProcessSystemDataTable(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 0xb) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}





/**
 * @brief 系统资源数组扩展器
 * 
 * 该函数负责扩展系统资源数组，当数组空间不足时进行动态扩容。
 * 主要用于系统资源数组的动态管理和内存分配。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数指针
 * @note 这是系统资源管理的核心函数，负责动态扩容
 */
void ExpandSystemResourceArray(long long* SystemResourceManager,uint32_t *ConfigurationDataPointer)

{
  long long resourceDataIndex;
  uint32_t *SystemHashEntryPointer;
  uint32_t *SystemHashNodeData;
  uint32_t *presourceAddress;
  
  presourceAddress = (uint32_t *)SystemResourceManager[1];
  if (presourceAddress < (uint32_t *)SystemResourceManager[2]) {
    SystemResourceManager[1] = (long long)(presourceAddress + 1);
    *presourceAddress = *ConfigurationDataPointer;
    return;
  }
  SystemHashNodeData = (uint32_t *)*SystemResourceManager;
  resourceDataIndex = (long long)presourceAddress - (long long)SystemHashNodeData >> 2;
  if (resourceDataIndex == 0) {
    resourceDataIndex = 1;
  }
  else {
    resourceDataIndex = resourceDataIndex * 2;
    if (resourceDataIndex == 0) {
      SystemHashEntryPointer = (uint32_t *)0x0;
      goto SystemResourceComplete;
    }
  }
  SystemHashEntryPointer = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceDataIndex * 4,(char)SystemResourceManager[3]);
  SystemHashNodeData = (uint32_t *)*SystemResourceManager;
  presourceAddress = (uint32_t *)SystemResourceManager[1];
SystemResourceComplete:
  if (SystemHashNodeData != presourceAddress) {
      memmove(SystemHashEntryPointer,SystemHashNodeData,(long long)presourceAddress - (long long)SystemHashNodeData);
  }
  *SystemHashEntryPointer = *ConfigurationDataPointer;
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = (long long)SystemHashEntryPointer;
  SystemResourceManager[1] = (long long)(SystemHashEntryPointer + 1);
  SystemResourceManager[2] = (long long)(SystemHashEntryPointer + resourceDataIndex);
  return;
}




/**
 * @brief 系统上下文初始化器
 * 
 * 该函数负责初始化系统上下文，设置系统上下文的基本参数和状态。
 * 主要用于系统上下文的创建和配置工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是系统上下文管理的核心函数
 */
void InitializeSystemContext(long long SystemResourceManager)

{
  void** SystemDataPointer;
  
  SystemDataPointer = *(void* **)(SystemResourceManager + 0x10);
  if (SystemDataPointer != (void* *)0x0) {
    InitializeSystemContext(SystemResourceManager,*SystemDataPointer);
      SystemCleanupFunction(SystemDataPointer);
  }
  *(long long *)SystemResourceManager = SystemResourceManager;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint8_t *)(SystemResourceManager + 0x18) = 0;
  *(void* *)(SystemResourceManager + 0x20) = 0;
  *(long long *)(SystemResourceManager + 8) = SystemResourceManager;
  return;
}




// 函数: void SystemCleanupWrapper(void)
/**
 * @brief 系统清理包装函数
 * 
 * 该函数是系统清理操作的包装函数，它调用系统清理函数来释放资源
 * 并执行必要的清理操作。确保系统资源被正确释放。
 * 
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确释放
 */
void SystemCleanupWrapper(void)

{
  InitializeSystemContext();
    SystemCleanupFunction();
}




// 函数: void SystemNodeInitialize(void)
/**
 * @brief 系统节点初始化函数
 * 
 * 该函数负责初始化系统节点的基本结构，设置节点的自引用指针、
 * 数据指针和状态标志。它为系统节点准备基本的数据结构。
 * 
 * @note 这是系统节点管理的基础函数，用于初始化节点结构
 */
void SystemNodeInitializer(void)

{
  long long memoryBlockAddress;
  
  *(long long *)memoryBlockAddress = memoryBlockAddress;
  *(void* *)(memoryBlockAddress + 0x10) = 0;
  *(uint8_t *)(memoryBlockAddress + 0x18) = 0;
  *(void* *)(memoryBlockAddress + 0x20) = 0;
  *(long long *)(memoryBlockAddress + 8) = memoryBlockAddress;
  return;
}





// 函数: void ResizeSystemMemoryPool(long long* SystemResourceManager,ulong long ConfigurationDataPointer)
// 功能: 调整系统内存池大小，处理内存分配和重新分配
void ResizeSystemMemoryPool(long long* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  ulong long resourceCreationFlags;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  
  localSystemPointer = SystemResourceManager[1];
  SystemThreadFlags = *SystemResourceManager;
  resourceCreationFlags = localSystemPointer - SystemThreadFlags >> 3;
  if (ConfigurationDataPointer <= resourceCreationFlags) {
    SystemResourceManager[1] = SystemThreadFlags + ConfigurationDataPointer * 8;
    return;
  }
  resourceAddress = ConfigurationDataPointer - resourceCreationFlags;
  if (resourceAddress <= (ulong long)(SystemResourceManager[2] - localSystemPointer >> 3)) {
    if (resourceAddress != 0) {
        memset(localSystemPointer,0,resourceAddress * 8);
    }
    SystemResourceManager[1] = localSystemPointer;
    return;
  }
  resourceAllocationContext = resourceCreationFlags * 2;
  if (resourceCreationFlags == 0) {
    resourceAllocationContext = 1;
  }
  if (resourceAllocationContext < ConfigurationDataPointer) {
    resourceAllocationContext = ConfigurationDataPointer;
  }
  if (resourceAllocationContext == 0) {
    resourceDataIndex = 0;
  }
  else {
    resourceDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAllocationContext * 8,(char)SystemResourceManager[3]);
    SystemThreadFlags = *SystemResourceManager;
    localSystemPointer = SystemResourceManager[1];
  }
  if (SystemThreadFlags != localSystemPointer) {
      memmove(resourceDataIndex,SystemThreadFlags,localSystemPointer - SystemThreadFlags);
  }
  if (resourceAddress != 0) {
      memset(resourceDataIndex,0,resourceAddress * 8);
  }
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = resourceDataIndex;
  SystemResourceManager[2] = resourceDataIndex + resourceAllocationContext * 8;
  SystemResourceManager[1] = resourceDataIndex;
  return;
}





// 函数: void AllocateSystemMemoryBlock(long long SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)
// 功能: 分配系统内存块，处理内存分配和初始化
void AllocateSystemMemoryBlock(long long SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)

{
  long long in_RAX;
  long long resourceDataIndex;
  long long *memoryBlockAddress;
  ulong long resourceCreationFlags;
  ulong long resourceAllocationContext;
  long long systemDataIndexPtr;
  
  resourceAllocationContext = ConfigurationDataPointer - SystemResourceManager;
  if (resourceAllocationContext <= (ulong long)(in_RAX - systemDataIndexPtr >> 3)) {
    if (resourceAllocationContext != 0) {
        memset();
    }
    memoryBlockAddress[1] = systemDataIndexPtr;
    return;
  }
  resourceCreationFlags = SystemResourceManager * 2;
  if (SystemResourceManager == 0) {
    resourceCreationFlags = 1;
  }
  if (resourceCreationFlags < ConfigurationDataPointer) {
    resourceCreationFlags = ConfigurationDataPointer;
  }
  if (resourceCreationFlags == 0) {
    resourceDataIndex = 0;
  }
  else {
    resourceDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceCreationFlags * 8,(char)memoryBlockAddress[3]);
    ConfigurationFlag = *memoryBlockAddress;
    systemDataIndexPtr = memoryBlockAddress[1];
  }
  if (ConfigurationFlag != systemDataIndexPtr) {
      memmove(resourceDataIndex,ConfigurationFlag,systemDataIndexPtr - ConfigurationFlag);
  }
  if (resourceAllocationContext != 0) {
      memset(resourceDataIndex,0,resourceAllocationContext * 8);
  }
  if (*memoryBlockAddress != 0) {
      SystemCleanupFunction();
  }
  *memoryBlockAddress = resourceDataIndex;
  memoryBlockAddress[2] = resourceDataIndex + resourceCreationFlags * 8;
  memoryBlockAddress[1] = resourceDataIndex;
  return;
}




// 函数: void SystemMemoryPoolInitialize(void)
/**
 * @brief 系统内存清零函数
 * 
 * 该函数负责清零系统内存区域，确保内存处于初始状态。
 * 它会检查内存指针的有效性，然后执行内存清零操作。
 * 
 * @note 这是系统内存管理的重要组成部分，用于内存初始化
 */
void SystemMemoryZeroer(void)

{
  long long memoryBlockAddress;
  long long StringIteratorPointer;
  void* systemDataIndexPtr;
  
  if (StringIteratorPointer != 0) {
      memset();
  }
  *(void* *)(memoryBlockAddress + 8) = systemDataIndexPtr;
  return;
}




// 函数: void UpdateSystemMemoryPointer(void* SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)
// 功能: 更新系统内存指针，计算新的内存地址
void UpdateSystemMemoryPointer(void* SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)

{
  long long memoryBlockAddress;
  
  *(long long *)(memoryBlockAddress + 8) = ConfigurationFlag + ConfigurationDataPointer * 8;
  return;
}




// 函数: void ProcessSystemResourceOperation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
// 功能: 处理系统资源操作，调用相关的系统资源处理函数
void ProcessSystemResourceOperation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ConfigureSystemResource(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void CleanupSystemResources(long long* SystemResourceManager)
// 功能: 清理系统资源，释放分配的内存和资源
void CleanupSystemResources(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x48) {
    DestroySystemResource(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源处理器
 * 
 * 该函数负责处理系统资源，调用系统资源处理函数来执行具体的资源操作。
 * 它会传递系统资源指针和相关参数给处理函数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 处理参数
 * @param AdditionalParameter 处理参数
 * @param ConfigurationFlag 处理参数
 * @note 这是系统资源管理的核心处理函数
 */
void ProcessSystemResource(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemConfiguration(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 系统内存块处理器
 * 
 * 该函数负责处理系统内存块，调用内存块处理函数来执行具体的内存操作。
 * 它会传递系统资源指针和相关参数给内存块处理函数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 处理参数
 * @param AdditionalParameter 处理参数
 * @param ConfigurationFlag 处理参数
 * @note 这是系统内存管理的核心处理函数
 */
void ProcessSystemMemoryBlock(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessMemoryBlock(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void ReleaseSystemMemoryHandles(long long SystemResourceManager)
// 功能: 释放系统内存句柄，清理相关的内存资源
void ReleaseSystemMemoryHandles(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源数组清理器
 * 
 * 该函数负责清理系统资源数组，遍历数组中的每个资源并调用清理函数。
 * 它会确保每个资源都被正确释放，并将数组中的指针设置为0。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源数组信息
 * @note 这是系统资源管理的重要清理函数，用于释放资源数组中的所有资源
 */
void CleanupSystemResourceArray(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemCleanupFunction(void)
/**
 * @brief 系统清理函数
 * 
 * 该函数负责清理系统资源，释放内存和重置系统状态。
 * 用于系统关闭或重启时的资源清理工作。
 */
void SystemCleanupFunction(void)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  long long systemStackFramePtr;
  ulong long StringIteratorPointer;
  ulong long systemDataIndexPtr;
  ulong long resourceAddress;
  long long systemResourceCounter;
  void* systemResourceHandle;
  
  do {
    ResourceDataOffset = *(long long *)(systemResourceCounter + systemDataIndexPtr * 8);
    if (ResourceDataOffset != 0) {
        SystemCleanupFunction(ResourceDataOffset);
    }
    *(void* *)(systemResourceCounter + systemDataIndexPtr * 8) = systemResourceHandle;
    systemDataIndexPtr = systemDataIndexPtr + 1;
  } while (systemDataIndexPtr < StringIteratorPointer);
  *(void* *)(systemStackFramePtr + 0x18) = systemResourceHandle;
  if ((1 < *(ulong long *)(systemStackFramePtr + 0x10)) &&
     (SystemHashEntryPointer = *(void* **)(systemStackFramePtr + 8), SystemHashEntryPointer != (void* *)0x0)) {
    resourceAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
    if (resourceAddress != 0) {
      ResourceDataOffset = resourceAddress + 0x80 + ((long long)SystemHashEntryPointer - resourceAddress >> 0x10) * 0x50;
      ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
      if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
        *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
        *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
        SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                            SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理相关的数据结构和指针。
 * 用于系统资源管理的前期准备工作。
 */
void InitializeSystemResourceManager(void)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  long long systemStackFramePtr;
  ulong long StringIteratorPointer;
  ulong long resourceAddress;
  void* systemResourceHandle;
  
  *(void* *)(systemStackFramePtr + 0x18) = systemResourceHandle;
  if ((1 < StringIteratorPointer) && (SystemHashEntryPointer = *(void* **)(systemStackFramePtr + 8), SystemHashEntryPointer != (void* *)0x0)) {
    resourceAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
    if (resourceAddress != 0) {
      ResourceDataOffset = resourceAddress + 0x80 + ((long long)SystemHashEntryPointer - resourceAddress >> 0x10) * 0x50;
      ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
      if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
        *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
        *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
        SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                            SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void InitializeSystemResourceAllocator(void)
/**
 * @brief 系统资源分配器初始化函数
 * 
 * 该函数负责初始化系统资源分配器，设置资源分配相关的数据结构和参数。
 * 用于系统资源分配的前期准备工作。
 */
void InitializeSystemResourceAllocator(void)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  long long systemStackFramePtr;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = *(void* **)(systemStackFramePtr + 8);
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void SystemResourceHandlerDelegate(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源处理委托函数
 * 
 * 该函数是系统资源处理的委托函数，它调用底层的资源处理函数
 * 来执行具体的资源管理任务。它提供了一个统一的资源处理接口。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 处理参数2（未使用）
 * @param AdditionalParameter 处理参数3
 * @param ConfigurationFlag 处理参数4
 * @note 这是系统资源管理的委托处理函数
 */
void SystemResourceHandlerDelegate(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
 */
void SystemResourceHandlerDelegate(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ReleaseMemoryRegion(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void ProcessResourceArrayCleanup(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 资源数组清理处理函数
 * 
 * 该函数遍历资源指针数组，对每个资源调用其清理函数。
 * 主要用于批量处理资源的清理操作，确保所有资源都被正确释放。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源数组信息
 * @param ConfigurationDataPointer 保留参数，当前未使用
 * @param AdditionalParameter 传递给资源清理函数的参数
 * @param ConfigurationFlag 传递给资源清理函数的参数
 * @note 这是资源批量清理的核心函数
 */
void ProcessResourceArrayCleanup(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 0x69) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void CleanupSystemResourceHandles(long long SystemResourceManager)
/**
 * @brief 系统资源句柄清理器
 * 
 * 该函数负责清理系统资源句柄数组，遍历所有句柄并调用相应的清理函数。
 * 确保所有系统资源都被正确释放，避免资源泄漏。
 * 
 * @param SystemResourceManager 系统资源指针，包含句柄数组信息
 * @note 这是系统资源管理的重要组成部分，用于清理系统句柄
 */
void CleanupSystemResourceHandles(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  
  resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  resourceDataIndex = *(long long *)(SystemResourceManager + 8);
  resourceAddress = 0;
  if (resourceAllocationContext != 0) {
    do {
      SystemThreadHandle = *(long long *)(resourceDataIndex + resourceAddress * 8);
      if (SystemThreadHandle != 0) {
        if (*(long long **)(SystemThreadHandle + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(SystemThreadHandle + 0x10) + 0x38))();
        }
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(resourceDataIndex + resourceAddress * 8) = 0;
      resourceAddress = resourceAddress + 1;
    } while (resourceAddress < resourceAllocationContext);
    resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < resourceAllocationContext) && (*(long long *)(SystemResourceManager + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: void SystemQueueProcessor(long long* SystemResourceManager)
/**
 * @brief 系统队列处理器
 * 
 * 该函数遍历系统资源队列，对每个队列项调用处理函数。
 * 主要用于批量处理系统队列中的项目。
 * 
 * @param SystemResourceManager 系统资源指针，包含队列信息
 * @note 这是系统队列管理的核心函数
 */
void ProcessSystemQueue(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x18) {
    ProcessQueueItem(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void SystemBufferCleaner(long long SystemResourceManager)
/**
 * @brief 系统缓冲区清理器
 * 
 * 该函数负责清理系统缓冲区中的资源，遍历缓冲区并调用清理函数。
 * 主要用于释放缓冲区占用的资源，避免内存泄漏。
 * 
 * @param SystemResourceManager 系统资源指针，包含缓冲区信息
 * @note 这是系统缓冲区管理的重要组成部分
 */
void CleanupSystemBuffer(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void HandleResourceDataProcessing(long long SystemResourceManager)
/**
 * @brief 系统资源深度清理器
 * 
 * 该函数负责深度清理系统资源，遍历资源数组并调用清理函数。
 * 主要用于系统关闭时的资源清理工作。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源数组信息
 * @note 这是系统资源深度清理的核心函数
 */
void DeepCleanupSystemResources(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  
  ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
  currentThreadId = 0;
  if (ResourceHash != 0) {
    do {
      SystemThreadHandle = *(long long *)(SystemBufferAddress + currentThreadId * 8);
      if (SystemThreadHandle != 0) {
          SystemCleanupFunction(SystemThreadHandle);
      }
      *(void* *)(SystemBufferAddress + currentThreadId * 8) = 0;
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < ResourceHash);
    ResourceHash = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < ResourceHash) && (SystemHashNodeData = *(void* **)(SystemResourceManager + 8), SystemHashNodeData != (void* *)0x0)) {
    ResourceHash = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (ResourceHash != 0) {
      SystemBufferAddress = ResourceHash + 0x80 + ((long long)SystemHashNodeData - ResourceHash >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(ResourceHash + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(ResourceHash,CONCAT71(0xff000000,*(void ***)(ResourceHash + 0x70) == &ExceptionList),
                            SystemHashNodeData,ResourceHash,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: 系统内存清理器 - 负责清理系统内存
/**
 * @brief 系统内存清理器
 * 
 * 该函数负责清理系统内存中的无效指针和资源。它会遍历内存块，
 * 检查每个内存块的状态，并清理不再需要的内存资源。
 * 
 * @note 这是系统内存管理的重要组成部分，确保系统内存的有效利用
 */
void SystemMemoryCleanup(void)

{
  int *memoryReferenceCount;
  void** SystemDataTable;
  long long memoryBlockAddress;
  long long memoryBlockBase;
  ulong long memoryBlockCount;
  ulong long memoryBlockIndex;
  ulong long memoryBlockFlags;
  long long memoryBlockPointer;
  void* memoryBlockValue;
  
  do {
    memoryBlockAddress = *(long long *)(memoryBlockPointer + memoryBlockIndex * 8);
    if (memoryBlockAddress != 0) {
        ReleaseMemoryBlock(memoryBlockAddress);
    }
    *(void* *)(memoryBlockPointer + memoryBlockIndex * 8) = memoryBlockValue;
    memoryBlockIndex = memoryBlockIndex + 1;
  } while (memoryBlockIndex < memoryBlockCount);
  *(void* *)(memoryBlockBase + 0x18) = memoryBlockValue;
  if ((1 < *(ulong long *)(memoryBlockBase + 0x10)) &&
     (systemMemoryBlock = *(void* **)(memoryBlockBase + 8), systemMemoryBlock != (void* *)0x0)) {
    memoryBlockFlags = (ulong long)systemMemoryBlock & MAX_UNSIGNED_32_BITffc00000;
    if (memoryBlockFlags != 0) {
      memoryBlockAddress = memoryBlockFlags + 0x80 + ((long long)systemMemoryBlock - memoryBlockFlags >> 0x10) * 0x50;
      memoryBlockAddress = memoryBlockAddress - (ulong long)*(uint *)(memoryBlockAddress + 4);
      if ((*(void ***)(memoryBlockFlags + 0x70) == &ExceptionList) && (*(char *)(memoryBlockAddress + 0xe) == '\0')) {
        *systemMemoryBlock = *(void* *)(memoryBlockAddress + 0x20);
        *(void* **)(memoryBlockAddress + 0x20) = systemMemoryBlock;
        memoryReferenceCount = (int *)(memoryBlockAddress + 0x18);
        *memoryReferenceCount = *memoryReferenceCount + -1;
        if (*memoryReferenceCount == 0) {
          CleanupSystemMemoryManager();
          return;
        }
      }
      else {
        ProcessMemoryBlockException(memoryBlockFlags,CONCAT71(0xff000000,*(void ***)(memoryBlockFlags + 0x70) == &ExceptionList),
                            systemMemoryBlock,memoryBlockFlags,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: 系统资源释放器 - 负责释放系统资源
/**
 * @brief 系统资源释放器
 * 
 * 该函数负责释放系统中的资源，包括内存块、文件句柄、网络连接等。
 * 它会检查资源的使用状态，并安全地释放不再需要的资源。
 * 
 * @note 这是系统资源管理的重要组成部分，确保系统资源的正确释放
 */
void SystemResourceRelease(void)

{
  int *resourceReferenceCount;
  void** SystemDataTable;
  long long resourceAddress;
  long long resourceBase;
  ulong long resourceCount;
  ulong long resourceFlags;
  void* resourceValue;
  
  *(void* *)(resourceBase + 0x18) = resourceValue;
  if ((1 < resourceCount) && (systemResource = *(void* **)(resourceBase + 8), systemResource != (void* *)0x0)) {
    resourceFlags = (ulong long)systemResource & MAX_UNSIGNED_32_BITffc00000;
    if (resourceFlags != 0) {
      resourceAddress = resourceFlags + 0x80 + ((long long)systemResource - resourceFlags >> 0x10) * 0x50;
      resourceAddress = resourceAddress - (ulong long)*(uint *)(resourceAddress + 4);
      if ((*(void ***)(resourceFlags + 0x70) == &ExceptionList) && (*(char *)(resourceAddress + 0xe) == '\0')) {
        *systemResource = *(void* *)(resourceAddress + 0x20);
        *(void* **)(resourceAddress + 0x20) = systemResource;
        resourceReferenceCount = (int *)(resourceAddress + 0x18);
        *resourceReferenceCount = *resourceReferenceCount + -1;
        if (*resourceReferenceCount == 0) {
          CleanupResourceManager();
          return;
        }
      }
      else {
        ProcessResourceException(resourceFlags,CONCAT71(0xff000000,*(void ***)(resourceFlags + 0x70) == &ExceptionList),
                            systemResource,resourceFlags,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void SystemExceptionHandler(void)
/**
 * @brief 系统异常处理函数
 * 
 * 该函数负责处理系统异常，管理异常列表和异常处理逻辑。
 * 用于系统运行时的异常情况处理。
 */
void SystemExceptionHandler(void)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  long long systemStackFramePtr;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = *(void* **)(systemStackFramePtr + 8);
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void ReleaseSystemResources(long long* SystemResourceManager)
/**
 * @brief 系统资源释放函数
 * 
 * 该函数负责释放系统资源，遍历资源指针数组并调用相应的释放函数。
 * 用于系统资源管理和内存清理工作。
 */
void ReleaseSystemResources(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)SystemResourceManager[1];
  for (resourcePoolPointer = (long long *)*SystemResourceManager; resourcePoolPointer != PrimaryResourcePointer; resourcePoolPointer = resourcePoolPointer + 1) {
    if ((long long *)*resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*(long long *)*resourcePoolPointer + 0x38))();
    }
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}





// 函数: void DestroyRenderingSystem(void)
/**
 * @brief 渲染系统销毁函数
 * 
 * 该函数负责销毁渲染系统，清理渲染相关的资源和内存。
 * 用于系统关闭时的渲染资源清理工作。
 */
void DestroyRenderingSystem(void)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = SystemRenderManagerPointer;
  if (SystemRenderManagerPointer == (void* *)0x0) {
    return;
  }
  ReleaseSystemResources();
  if ((long long *)SystemHashEntryPointer[0x30b] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemHashEntryPointer[0x30b] + 0x38))();
  }
  _Mtx_destroy_in_situ();
  if ((long long *)SystemHashEntryPointer[0x300] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemHashEntryPointer[0x300] + 0x38))();
  }
  if ((long long *)SystemHashEntryPointer[0x2d3] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemHashEntryPointer[0x2d3] + 0x38))();
  }
  if ((long long *)SystemHashEntryPointer[0x2c0] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemHashEntryPointer[0x2c0] + 0x38))();
  }
  ExecuteDataOperation(SystemHashEntryPointer + 0x116);
  ProcessDataValidation(SystemHashEntryPointer + 6);
  if (SystemHashEntryPointer[2] != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 处理系统字符串数据
 * 
 * 该函数负责处理系统中的字符串数据，包括字符串的解析、
 * 分配和管理。用于系统字符串操作的核心功能。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递字符串处理的相关数据
 * @param AdditionalParameter 参数3，字符串数据源
 * @param ConfigurationFlag 参数4，字符串处理标志
 * @note 这是字符串处理系统的核心函数
 */
void ProcessSystemStringData(long long SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  char SystemNodeFlag;
  long long SystemThreadHandle;
  char *pathStringPointer;
  char *pSystemOperationStatusFlag;
  void* currentThreadId;
  void* *memoryAllocationEnd;
  long long SystemStatusFlag48;
  uint32_t SystemOperationCounter;
  ulong long SystemContextValue;
  
  currentThreadId = 0xfffffffffffffffe;
  pathStringPointer = *(char **)(SystemResourceManager + 8);
  initializationStatusFlag = *pathStringPointer;
  pSystemOperationStatusFlag = pathStringPointer;
  if (initializationStatusFlag != '\0') {
    do {
      SystemThreadHandle = strchr(AdditionalParameter,(int)initializationStatusFlag);
      if ((SystemThreadHandle != 0) && (pSystemOperationStatusFlag != pathStringPointer)) {
        memoryAllocationEnd = &SystemGlobalDataReference;
        SystemContextValue = 0;
        SystemStatusFlag48 = 0;
        SystemOperationCounter = 0;
        ProcessSystemMemoryAllocation(&memoryAllocationEnd,pSystemOperationStatusFlag,(int)pathStringPointer - (int)pSystemOperationStatusFlag,ConfigurationFlag,currentThreadId);
        pSystemOperationStatusFlag = pathStringPointer + 1;
        if (*(ulong long *)(ConfigurationDataPointer + 8) < *(ulong long *)(ConfigurationDataPointer + 0x10)) {
          *(ulong long *)(ConfigurationDataPointer + 8) = *(ulong long *)(ConfigurationDataPointer + 8) + 0x20;
          InitializeSystemMemoryAllocator();
        }
        else {
          ProcessSystemConfiguration(ConfigurationDataPointer,&memoryAllocationEnd);
        }
        memoryAllocationEnd = &SystemGlobalDataReference;
        if (SystemStatusFlag48 != 0) {
            SystemCleanupFunction();
        }
        SystemStatusFlag48 = 0;
        SystemContextValue = SystemContextValue & MAX_UNSIGNED_32_BIT00000000;
        memoryAllocationEnd = &SystemMemoryAllocatorReference;
      }
      pathStringPointer = pathStringPointer + 1;
      initializationStatusFlag = *pathStringPointer;
    } while (initializationStatusFlag != '\0');
    if (pSystemOperationStatusFlag != pathStringPointer) {
      memoryAllocationEnd = &SystemGlobalDataReference;
      SystemContextValue = 0;
      SystemStatusFlag48 = 0;
      SystemOperationCounter = 0;
      ProcessSystemMemoryAllocation(&memoryAllocationEnd,pSystemOperationStatusFlag,(int)pathStringPointer - (int)pSystemOperationStatusFlag,ConfigurationFlag,currentThreadId);
      if (*(ulong long *)(ConfigurationDataPointer + 8) < *(ulong long *)(ConfigurationDataPointer + 0x10)) {
        *(ulong long *)(ConfigurationDataPointer + 8) = *(ulong long *)(ConfigurationDataPointer + 8) + 0x20;
        InitializeSystemMemoryAllocator();
      }
      else {
        ProcessSystemConfiguration(ConfigurationDataPointer,&memoryAllocationEnd);
      }
      memoryAllocationEnd = &SystemGlobalDataReference;
      if (SystemStatusFlag48 != 0) {
          SystemCleanupFunction();
      }
    }
  }
  return;
}




long long * InitializeSystemModule(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter)

{
  byte isByteValid;
  uint resourceCreationFlags;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  byte *pisMemoryReady;
  long long SystemThreadFlags;
  void* ThreadContextFlag;
  char acStackX_8 [8];
  
  ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x40,*(uint8_t *)(SystemResourceManager + 0x28));
  CreateSystemObject(ResourceDataOffset + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,AdditionalParameter);
  SystemBufferAddress = SystemResourceAllocator(SystemResourceManager,acStackX_8,ResourceDataOffset + 0x20);
  if (acStackX_8[0] == '\0') {
    ProcessExtraOutputResource();
    *ConfigurationDataPointer = SystemBufferAddress;
    *(uint8_t *)(ConfigurationDataPointer + 1) = 0;
    return ConfigurationDataPointer;
  }
  if (SystemBufferAddress != SystemResourceManager) {
    if (*(int *)(SystemBufferAddress + 0x30) == 0) {
SystemMemoryCheck:
      ThreadContextFlag = 1;
      goto SystemMemoryComplete;
    }
    if (*(int *)(ResourceDataOffset + 0x30) != 0) {
      pisMemoryReady = *(byte **)(SystemBufferAddress + 0x28);
      SystemThreadFlags = *(long long *)(ResourceDataOffset + 0x28) - (long long)pisMemoryReady;
      do {
        isByteValid = *pisMemoryReady;
        resourceCreationFlags = (uint)pisMemoryReady[SystemThreadFlags];
        if (isByteValid != resourceCreationFlags) break;
        pisMemoryReady = pisMemoryReady + 1;
      } while (resourceCreationFlags != 0);
      if ((int)(isByteValid - resourceCreationFlags) < 1) goto SystemMemoryCheck;
    }
  }
  ThreadContextFlag = 0;
SystemMemoryComplete:
    ConfigureSystemResourceHandle(ResourceDataOffset,SystemBufferAddress,SystemResourceManager,ThreadContextFlag);
}




/**
 * @brief 清理系统资源处理器
 * 
 * 该函数负责清理系统资源处理器，包括释放内存、
 * 重置指针和清理相关数据结构。当系统资源不再需要时调用。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是资源管理系统的重要组成部分
 */
void CleanupSystemResourceHandler(void* *SystemResourceManager)

{
  if (SystemResourceManager == (void* *)0x0) {
    return;
  }
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[4] = &SystemGlobalDataReference;
  if (SystemResourceManager[5] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 7) = 0;
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(SystemResourceManager);
}




/**
 * @brief 初始化系统资源处理器
 * 
 * 该函数负责初始化系统资源处理器，设置内存分配器、
 * 数据表和相关配置。用于系统资源管理的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，初始化标志
 * @param AdditionalParameter 参数3，初始化数据源
 * @param ConfigurationFlag 参数4，初始化配置
 * @return 返回初始化后的系统资源处理器指针
 * @note 这是资源管理系统的初始化函数
 */
void* * InitializeSystemResourceHandler(void* *SystemResourceManager,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *SystemResourceManager = &SystemResourceData2;
  ReleaseSystemResourceHandle(SystemAllocationFlagsTemplate,SystemResourceManager[0x28],AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  SystemResourceManager[0x28] = 0;
  SystemResourceManager[0x29] = &SystemGlobalDataReference;
  if (SystemResourceManager[0x2a] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x2a] = 0;
  *(uint32_t *)(SystemResourceManager + 0x2c) = 0;
  SystemResourceManager[0x29] = &SystemMemoryAllocatorReference;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x170);
  }
  return SystemResourceManager;
}




// 函数: void ProcessSystemResourceData(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemResourceData(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  ProcessSystemResourceInitialization();
  ProcessSystemResourceInitialization();
  SystemResourceManager[0x123] = (long long)&SystemGlobalDataReference;
  if (SystemResourceManager[0x124] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x124] = 0;
  *(uint32_t *)(SystemResourceManager + 0x126) = 0;
  SystemResourceManager[0x123] = (long long)&SystemMemoryAllocatorReference;
  ProcessMemoryBlock(SystemResourceManager + 0x11d,SystemResourceManager[0x11f],AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  if (SystemResourceManager[0x119] == 0) {
    CleanupSystemMemoryAllocation();
    CleanupSystemMemoryAllocation();
    ProcessSystemResourceExtension(SystemResourceManager + 0x10b,SystemResourceManager[0x10d]);
    SystemResourceManager[0x87] = (long long)&SystemMemoryAllocatorReference;
    SystemResourceManager[4] = (long long)&SystemMemoryAllocatorReference;
    resourceAllocationContext = 0xfffffffffffffffe;
    SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
    for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 4) {
      (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
    }
    if (*SystemResourceManager == 0) {
      return;
    }
      SystemCleanupFunction();
  }
    SystemCleanupFunction();
}




// 函数: void InitializeSystemResource(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源初始化器函数
 * 
 * 该函数负责初始化系统资源，配置资源参数并设置初始化标志。
 * 它会调用资源初始化子函数，确保资源被正确初始化。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含资源的配置信息
 * @param AdditionalParameter 保留参数，用于扩展功能
 * @param ConfigurationFlag 保留参数，用于扩展功能
 * @note 这是系统资源管理的重要组成部分，用于确保资源的正确初始化
 */
void InitializeSystemResource(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceExtension(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void ReleaseSystemResourceManager(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ReleaseSystemResourceManager(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  
  SystemDataPointer = *(void* **)(SystemResourceManager + 0x10);
  if (SystemDataPointer != (void* *)0x0) {
    ConfigureSystemResourceData(SystemResourceManager,*SystemDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    ValidateSystemResourceConfiguration(SystemDataPointer);
      SystemCleanupFunction(SystemDataPointer);
  }
  return;
}




// 函数: void InitializeSystemResourceStream(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemResourceStream(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceExtension(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void CleanupSystemResourceStream(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void CleanupSystemResourceStream(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  
  SystemDataPointer = *(void* **)(SystemResourceManager + 0x10);
  if (SystemDataPointer != (void* *)0x0) {
    ConfigureSystemResourceData(SystemResourceManager,*SystemDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    ValidateSystemResourceConfiguration(SystemDataPointer);
      SystemCleanupFunction(SystemDataPointer);
  }
  return;
}




// 函数: void FinalizeSystemResourceCleanup(long long* SystemResourceManager)
void FinalizeSystemResourceCleanup(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  void* *presourceAddress;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  void** SystemCurrentNode;
  
  InitializeConfigurationData();
  resourceDataIndex = *SystemResourceManager;
  *SystemResourceManager = 0;
  SystemThreadHandle = SystemResourceManager[1];
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  ResourceDataOffset = SystemResourceManager[2];
  SystemResourceManager[2] = 0;
  SystemThreadFlags = SystemResourceManager[3];
  *(int *)(SystemResourceManager + 3) = (int)SystemResourceManager[3];
  presourceAddress = (void* *)*SystemResourceManager;
  *SystemResourceManager = resourceDataIndex;
  SystemThreadContext = (void* *)SystemResourceManager[1];
  SystemResourceManager[1] = SystemThreadHandle;
  SystemResourceManager[2] = ResourceDataOffset;
  *(int *)(SystemResourceManager + 3) = (int)SystemThreadFlags;
  for (hashTableNode = presourceAddress; hashTableNode != SystemThreadContext; hashTableNode = hashTableNode + 4) {
    (**(code **)*hashTableNode)(hashTableNode,0);
  }
  if (presourceAddress != (void* *)0x0) {
      SystemCleanupFunction(presourceAddress);
  }
  return;
}




// 函数: void ProcessSystemMemoryAllocation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemMemoryAllocation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceExtension(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void ReleaseSystemMemoryAllocation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ReleaseSystemMemoryAllocation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  
  SystemDataPointer = *(void* **)(SystemResourceManager + 0x10);
  if (SystemDataPointer != (void* *)0x0) {
    ConfigureSystemResourceData(SystemResourceManager,*SystemDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    ValidateSystemResourceConfiguration(SystemDataPointer);
      SystemCleanupFunction(SystemDataPointer);
  }
  return;
}



/**
 * @brief 系统资源管理器查找函数
 * 
 * 该函数负责在系统资源管理器中查找和配置资源节点。
 * 通过遍历资源链表，根据配置参数查找匹配的资源节点，
 * 并返回相应的配置数据指针。
 * 
 * @param resourcePointer 系统资源指针，指向资源链表的头部
 * @param configDataPointer 配置数据指针，用于存储找到的配置数据
 * @param additionalParameter 额外参数，包含查找条件和配置信息
 * @return 配置数据指针，指向找到的配置数据
 * 
 */
void* * SearchSystemResourceNode(void* *resourcePointer,void* *configDataPointer,long long additionalParameter)

{
  byte comparisonByte;
  bool isMatchFound;
  byte *dataBuffer;
  uint comparisonValue;
  int comparisonResult;
  long long offsetDifference;
  void** currentNode;
  void** nextNode;
  void* *resultNode;
  void* *currentSearchNode;
  
  if ((void* *)resourcePointer[2] != (void* *)0x0) {
    void* *previousNode = (void* *)resourcePointer[2];
    currentSearchNode = resourcePointer;
    do {
      if (*(int *)(additionalParameter + 0x10) == 0) {
        void* *nextNodePointer = (void* *)previousNode[1];
        isMatchFound = false;
      }
      else {
        if (*(int *)(previousNode + 6) == 0) {
          isMatchFound = true;
        }
        else {
          dataBuffer = *(byte **)(additionalParameter + 8);
          offsetDifference = previousNode[5] - (long long)dataBuffer;
          do {
            comparisonValue = (uint)dataBuffer[offsetDifference];
            comparisonResult = *dataBuffer - comparisonValue;
            if (*dataBuffer != comparisonValue) break;
            dataBuffer = dataBuffer + 1;
          } while (comparisonValue != 0);
          isMatchFound = 0 < comparisonResult;
          if (comparisonResult < 1) {
            void* *nextNodePointer = (void* *)previousNode[1];
            goto SystemResourceNodeCheck;
          }
        }
        void* *nextNodePointer = (void* *)*previousNode;
      }
SystemResourceNodeCheck:
      SystemHashBucket = hashTableNode;
      if (isSystemActive) {
        SystemHashBucket = SystemDataPointer0;
      }
      hashTableNode = SystemThreadStorage;
      SystemDataPointer0 = SystemHashBucket;
    } while (SystemThreadStorage != (void* *)0x0);
    if (SystemHashBucket != SystemResourceManager) {
      if (*(int *)(SystemHashBucket + 6) == 0) {
SystemResourceNodeValidation:
        *ConfigurationDataPointer = SystemHashBucket;
        return ConfigurationDataPointer;
      }
      if (*(int *)(AdditionalParameter + 0x10) != 0) {
        operationCompletionFlag = (byte *)SystemHashBucket[5];
        SystemThreadFlags = *(long long *)(AdditionalParameter + 8) - (long long)operationCompletionFlag;
        do {
          isByteValid = *operationCompletionFlag;
          resourceAddress = (uint)operationCompletionFlag[SystemThreadFlags];
          if (isByteValid != resourceAddress) break;
          operationCompletionFlag = operationCompletionFlag + 1;
        } while (resourceAddress != 0);
        if ((int)(isByteValid - resourceAddress) < 1) goto SystemResourceNodeValidation;
      }
    }
  }
  *ConfigurationDataPointer = SystemResourceManager;
  return ConfigurationDataPointer;
}




// 函数: void InitializeSystemResourceManager(ulong long* SystemResourceManager)
void InitializeSystemResourceManager(ulong long* SystemResourceManager)

{
  int *resourceCounter;
  ulong long systemValue1;
  ulong long systemValue2;
  void* *resourcePointer;
  ulong long systemValue3;
  long long CalculationFlagss;
  
  SystemResourceManager[1] = *SystemResourceManager;
  systemValue1 = *SystemResourceManager;
  *SystemResourceManager = 0;
  systemValue2 = SystemResourceManager[1];
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  systemValue3 = SystemResourceManager[2];
  SystemResourceManager[2] = 0;
  CalculationFlagss = SystemResourceManager[3];
  *(int *)(SystemResourceManager + 3) = (int)SystemResourceManager[3];
  resourcePointer = (void* *)*SystemResourceManager;
  *SystemResourceManager = systemValue1;
  SystemResourceManager[1] = systemValue2;
  SystemResourceManager[2] = systemValue3;
  *(int *)(SystemResourceManager + 3) = (int)CalculationFlagss;
  if (resourcePointer == (void* *)0x0) {
    return;
  }
  systemValue1 = (ulong long)resourcePointer & MAX_UNSIGNED_32_BITffc00000;
  if (systemValue1 != 0) {
    CalculationFlagss = systemValue1 + 0x80 + ((long long)resourcePointer - systemValue1 >> 0x10) * 0x50;
    CalculationFlagss = CalculationFlagss - (ulong long)*(uint *)(CalculationFlagss + 4);
    if ((*(void ***)(systemValue1 + 0x70) == &ExceptionList) && (*(char *)(CalculationFlagss + 0xe) == '\0')) {
      *resourcePointer = *(void* *)(CalculationFlagss + 0x20);
      *(void* **)(CalculationFlagss + 0x20) = resourcePointer;
      resourceCounter = (int *)(CalculationFlagss + 0x18);
      *resourceCounter = *resourceCounter + -1;
      if (*resourceCounter == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(systemValue1,CONCAT71(0xff000000,*(void ***)(systemValue1 + 0x70) == &ExceptionList),
                          resourcePointer,systemValue1,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void ProcessSystemResourceDataTransfer(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemResourceDataTransfer(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer != (void* *)0x0) {
    ConfigureSystemResource(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    if ((long long *)ConfigurationDataPointer[0x17] != (long long *)0x0) {
      (**(code **)(*(long long *)ConfigurationDataPointer[0x17] + 0x38))();
    }
    ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}




// 函数: void ProcessSystemConfiguration(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统配置数据处理函数
 * 
 * 该函数负责处理系统配置数据，包括配置验证、数据清理和资源释放。
 * 它会递归处理配置数据，确保所有相关资源都被正确处理。
 * 
 * @param SystemResourceManager 系统资源指针，包含系统资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含系统的配置信息
 * @param AdditionalParameter 保留参数，用于扩展功能
 * @param ConfigurationFlag 保留参数，用于扩展功能
 * @note 这是系统配置管理的重要组成部分，用于确保配置数据的正确处理
 */
void ProcessSystemConfigurationData(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessSystemConfiguration(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  ProcessSystemDataConfiguration(ConfigurationDataPointer + 8);
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




// 函数: void ProcessMemoryBlock(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ProcessMemoryBlock(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessMemoryBlock(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




// 函数: void ReleaseMemoryRegion(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ReleaseMemoryRegion(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ReleaseMemoryRegion(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  if (ConfigurationDataPointer[8] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}





// 函数: void ProcessSystemResourceAllocation(void* *SystemResourceManager,long long ConfigurationDataPointer)
void ProcessSystemResourceAllocation(void* *SystemResourceManager,long long ConfigurationDataPointer)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  void** SystemCurrentNode;
  
  hashTableNode = (void* *)SystemResourceManager[1];
  presourceAddress = (void* *)*SystemResourceManager;
  localSystemPointer = ((long long)hashTableNode - (long long)presourceAddress) / 0x28;
  SystemHashEntryPointer = (void* *)0x0;
  if (localSystemPointer == 0) {
    localSystemPointer = 1;
  }
  else {
    localSystemPointer = localSystemPointer * 2;
    if (localSystemPointer == 0) goto SystemPointerCheck;
  }
  SystemHashEntryPointer = (void* *)
           CreateSystemThreadObject(SystemMemoryPoolTemplate,localSystemPointer * 0x28,*(uint8_t *)(SystemResourceManager + 3),presourceAddress,
                         0xfffffffffffffffe);
  hashTableNode = (void* *)SystemResourceManager[1];
  presourceAddress = (void* *)*SystemResourceManager;
SystemPointerCheck:
  SystemHashNodeData = SystemHashEntryPointer;
  if (presourceAddress != hashTableNode) {
    SystemThreadFlags = (long long)SystemHashEntryPointer - (long long)presourceAddress;
    presourceAddress = presourceAddress + 1;
    do {
      *SystemHashNodeData = &SystemMemoryAllocatorReference;
      *(void* *)(SystemThreadFlags + (long long)presourceAddress) = 0;
      *(uint32_t *)(SystemThreadFlags + 8 + (long long)presourceAddress) = 0;
      *SystemHashNodeData = &SystemGlobalDataReference;
      *(void* *)(SystemThreadFlags + 0x10 + (long long)presourceAddress) = 0;
      *(void* *)(SystemThreadFlags + (long long)presourceAddress) = 0;
      *(uint32_t *)(SystemThreadFlags + 8 + (long long)presourceAddress) = 0;
      *(uint32_t *)(SystemThreadFlags + 8 + (long long)presourceAddress) = *(uint32_t *)(presourceAddress + 1);
      *(void* *)(SystemThreadFlags + (long long)presourceAddress) = *presourceAddress;
      *(uint32_t *)(SystemThreadFlags + 0x14 + (long long)presourceAddress) = *(uint32_t *)((long long)presourceAddress + 0x14);
      *(uint32_t *)(SystemThreadFlags + 0x10 + (long long)presourceAddress) = *(uint32_t *)(presourceAddress + 2);
      *(uint32_t *)(presourceAddress + 1) = 0;
      *presourceAddress = 0;
      presourceAddress[2] = 0;
      *(uint32_t *)(SystemThreadFlags + 0x18 + (long long)presourceAddress) = *(uint32_t *)(presourceAddress + 3);
      SystemHashNodeData = SystemHashNodeData + 5;
      SystemDataPointer = presourceAddress + 4;
      presourceAddress = presourceAddress + 5;
    } while (SystemDataPointer != hashTableNode);
  }
  *SystemHashNodeData = &SystemMemoryAllocatorReference;
  SystemHashNodeData[1] = 0;
  *(uint32_t *)(SystemHashNodeData + 2) = 0;
  *SystemHashNodeData = &SystemGlobalDataReference;
  SystemHashNodeData[3] = 0;
  SystemHashNodeData[1] = 0;
  *(uint32_t *)(SystemHashNodeData + 2) = 0;
  *(uint32_t *)(SystemHashNodeData + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemHashNodeData[1] = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)((long long)SystemHashNodeData + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(SystemHashNodeData + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  *(uint32_t *)(SystemHashNodeData + 4) = *(uint32_t *)(ConfigurationDataPointer + 0x20);
  hashTableNode = (void* *)SystemResourceManager[1];
  presourceAddress = (void* *)*SystemResourceManager;
  if (presourceAddress != hashTableNode) {
    do {
      *presourceAddress = &SystemGlobalDataReference;
      if (presourceAddress[1] != 0) {
          SystemCleanupFunction();
      }
      presourceAddress[1] = 0;
      *(uint32_t *)(presourceAddress + 3) = 0;
      *presourceAddress = &SystemMemoryAllocatorReference;
      presourceAddress = presourceAddress + 5;
    } while (presourceAddress != hashTableNode);
    presourceAddress = (void* *)*SystemResourceManager;
  }
  if (presourceAddress == (void* *)0x0) {
    *SystemResourceManager = SystemHashEntryPointer;
    SystemResourceManager[1] = SystemHashNodeData + 5;
    SystemResourceManager[2] = SystemHashEntryPointer + localSystemPointer * 5;
    return;
  }
    SystemCleanupFunction(presourceAddress);
}




/**
 * @brief 系统资源验证器函数
 * 
 * 该函数负责验证系统资源的完整性和有效性。
 * 它会检查资源指针的有效性，并调用相应的验证函数。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要验证的资源信息
 * @note 这是系统资源管理的重要组成部分，用于确保资源的有效性
 */
void ValidateSystemResource(long long SystemResourceManager)

{
  if (*(long long **)(SystemResourceManager + 0x10) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemResourceManager + 0x10) + 0x38))();
  }
  return;
}




// 函数: void ProcessSystemResourceExtension(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源扩展处理器函数
 * 
 * 该函数负责处理系统资源的扩展操作，包括配置数据处理和资源管理。
 * 它会递归处理配置数据，并确保资源被正确初始化和配置。
 * 
 * @param SystemResourceManager 系统资源指针，包含系统资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @note 这是系统资源管理的重要组成部分，用于处理资源的扩展操作
 */
void ProcessSystemResourceExtension(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessSystemResourceExtension(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  if (ConfigurationDataPointer[8] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




// 函数: void ConfigureSystemResourceData(void* SystemResourceManager,void* *ConfigurationDataPointer)
/**
 * @brief 系统配置数据清理器函数
 * 
 * 该函数负责清理系统配置数据，递归处理配置数据指针数组。
 * 它会释放配置数据占用的内存，确保系统资源被正确清理。
 * 
 * @param SystemResourceManager 系统资源指针，包含系统资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含需要清理的配置信息
 * @note 这是系统配置管理的重要组成部分，用于确保配置数据的正确清理
 */
void CleanupSystemConfigurationData(void* SystemResourceManager,void* *ConfigurationDataPointer)

{
  if (ConfigurationDataPointer != (void* *)0x0) {
    CleanupSystemConfigurationData(SystemResourceManager,*ConfigurationDataPointer);
    ValidateSystemResourceConfiguration(ConfigurationDataPointer);
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}




// 函数: void ReleaseSystemResourceHandle(void* SystemResourceManager)
/**
 * @brief 系统资源最终清理器函数
 * 
 * 该函数负责系统资源的最终清理操作，包括配置数据的清理和内存释放。
 * 它会调用配置数据清理函数，确保所有相关资源都被正确释放。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要清理的资源信息
 * @note 这是系统资源管理的最后清理步骤，用于确保资源的完全释放
 */
void FinalCleanupSystemResource(void* SystemResourceManager)

{
  void* *memoryBlockAddress;
  
  ConfigureSystemResourceData(SystemResourceManager,*memoryBlockAddress);
  ValidateSystemResourceConfiguration();
    SystemCleanupFunction();
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何操作。
 * 主要用于占位或作为默认的空处理函数。
 */
void SystemNullOperation(void)

{
  return;
}




/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，包括设置全局数据引用和内存分配器引用。
 * 在初始化过程中会检查资源状态，如果发现异常则调用清理函数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 资源参数指针
 */
void SystemResourceInitializer(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  if (*(long long *)(ConfigurationDataPointer + 0x40) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(ConfigurationDataPointer + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ConfigurationDataPointer + 0x28) = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0x38) = 0;
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemMemoryAllocatorReference;
  if (ConfigurationDataPointer != 0) {
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}





/**
 * @brief 系统资源数组管理函数
 * 
 * 该函数负责管理系统资源数组，包括创建、扩展和清理资源数组。
 * 它会根据需要分配新的内存空间，并处理现有资源的迁移和清理。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 起始参数
 * @param AdditionalParameter 结束参数
 */
void SystemResourceArrayManager(long long* SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  void* *resourcePointer1;
  long long SystemThreadHandle;
  void* *resourcePointer3;
  void* *resourcePointer4;
  ulong long resourceCapacity;
  ulong long requiredCapacity;
  long long resourceOffset;
  
  requiredCapacity = AdditionalParameter - ConfigurationDataPointer >> 5;
  if ((ulong long)(SystemResourceManager[2] - *SystemResourceManager >> 5) < requiredCapacity) {
    if (requiredCapacity == 0) {
      SystemThreadHandle = 0;
    }
    else {
      SystemThreadHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,requiredCapacity << 5,(char)SystemResourceManager[3]);
    }
    if (ConfigurationDataPointer != AdditionalParameter) {
      resourceOffset = SystemThreadHandle - ConfigurationDataPointer;
      do {
        CreateSystemObject(resourceOffset + ConfigurationDataPointer,ConfigurationDataPointer);
        ConfigurationDataPointer = ConfigurationDataPointer + 0x20;
      } while (ConfigurationDataPointer != AdditionalParameter);
    }
    resourcePointer1 = (void* *)SystemResourceManager[1];
    resourcePointer4 = (void* *)*SystemResourceManager;
    if (resourcePointer4 != resourcePointer1) {
      do {
        (**(code **)*resourcePointer4)(resourcePointer4,0);
        resourcePointer4 = resourcePointer4 + 4;
      } while (resourcePointer4 != resourcePointer1);
      resourcePointer4 = (void* *)*SystemResourceManager;
    }
    if (resourcePointer4 != (void* *)0x0) {
        SystemCleanupFunction(resourcePointer4);
    }
    *SystemResourceManager = SystemThreadHandle;
    SystemThreadHandle = requiredCapacity * 0x20 + SystemThreadHandle;
    SystemResourceManager[2] = SystemThreadHandle;
    SystemResourceManager[1] = SystemThreadHandle;
  }
  else {
    resourceCapacity = SystemResourceManager[1] - *SystemResourceManager >> 5;
    if (resourceCapacity < requiredCapacity) {
      SystemThreadHandle = resourceCapacity * 0x20 + ConfigurationDataPointer;
      SetupSystemDataHandler(ConfigurationDataPointer,SystemThreadHandle);
      SystemThreadHandle = AllocateSystemMemoryBlock(SystemThreadHandle,AdditionalParameter,SystemResourceManager[1]);
      SystemResourceManager[1] = SystemThreadHandle;
    }
    else {
      resourcePointer3 = (void* *)SetupSystemDataHandler(ConfigurationDataPointer,AdditionalParameter);
      resourcePointer1 = (void* *)SystemResourceManager[1];
      for (resourcePointer4 = resourcePointer3; resourcePointer4 != resourcePointer1; resourcePointer4 = resourcePointer4 + 4) {
        (**(code **)*resourcePointer4)(resourcePointer4,0);
      }
      SystemResourceManager[1] = (long long)resourcePointer3;
    }
  }
  return;
}





/**
 * @brief 系统资源数组创建函数
 * 
 * 该函数负责创建系统资源数组，包括分配内存空间和初始化资源对象。
 * 它会根据指定的大小创建系统线程对象，并设置相应的资源指针。
 * 
 * @param SystemResourceManager 系统资源指针
 */
void SystemResourceArrayCreator(long long SystemResourceManager)

{
  void* *resourcePointer1;
  long long SystemThreadHandle;
  long long resourceStartOffset;
  void* *resourcePointer3;
  long long resourceSize;
  long long *resourceArrayPointer;
  long long bufferAddress;
  long long resourceEndOffset;
  
  if (resourceSize == 0) {
    SystemThreadHandle = 0;
  }
  else {
    SystemThreadHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceSize << 5,*(uint8_t *)(SystemResourceManager + 0x18));
  }
  if (resourceStartOffset != resourceEndOffset) {
    bufferAddress = SystemThreadHandle - resourceStartOffset;
    do {
      CreateSystemObject(bufferAddress + resourceStartOffset,resourceStartOffset);
      resourceStartOffset = resourceStartOffset + 0x20;
    } while (resourceStartOffset != resourceEndOffset);
  }
  resourcePointer1 = (void* *)resourceArrayPointer[1];
  resourcePointer3 = (void* *)*resourceArrayPointer;
  if (resourcePointer3 != resourcePointer1) {
    do {
      (**(code **)*resourcePointer3)(resourcePointer3,0);
      resourcePointer3 = resourcePointer3 + 4;
    } while (resourcePointer3 != resourcePointer1);
    resourcePointer3 = (void* *)*resourceArrayPointer;
  }
  if (resourcePointer3 == (void* *)0x0) {
    *resourceArrayPointer = SystemThreadHandle;
    SystemThreadHandle = resourceSize * 0x20 + SystemThreadHandle;
    resourceArrayPointer[2] = SystemThreadHandle;
    resourceArrayPointer[1] = SystemThreadHandle;
    return;
  }
    SystemCleanupFunction(resourcePointer3);
}




// 函数: void InitializeSystemTables(void)
// 功能: 初始化系统表，设置系统数据结构和表
void InitializeSystemTables(void)

{
  void** SystemDataPointer;
  long long memoryBlockAddress;
  void** SystemDataTable;
  long long StringIteratorPointer;
  long long *systemDataIndexPtr;
  long long systemAllocationOffset;
  long long ResourceDataOffset;
  long long systemResourceHandle;
  
  ResourceDataOffset = systemAllocationOffset - memoryBlockAddress;
  do {
    CreateSystemObject(ResourceDataOffset + memoryBlockAddress,memoryBlockAddress);
    memoryBlockAddress = memoryBlockAddress + 0x20;
  } while (memoryBlockAddress != systemResourceHandle);
  SystemDataPointer = (void* *)systemDataIndexPtr[1];
  SystemHashEntryPointer = (void* *)*systemDataIndexPtr;
  if (SystemHashEntryPointer != SystemDataPointer) {
    do {
      (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0);
      SystemHashEntryPointer = SystemHashEntryPointer + 4;
    } while (SystemHashEntryPointer != SystemDataPointer);
    SystemHashEntryPointer = (void* *)*systemDataIndexPtr;
  }
  if (SystemHashEntryPointer != (void* *)0x0) {
      SystemCleanupFunction(SystemHashEntryPointer);
  }
  *systemDataIndexPtr = systemAllocationOffset;
  ResourceDataOffset = StringIteratorPointer * 0x20 + systemAllocationOffset;
  systemDataIndexPtr[2] = ResourceDataOffset;
  systemDataIndexPtr[1] = ResourceDataOffset;
  return;
}




// 函数: void FinalizeSystemInitialization(void)
// 功能: 完成系统初始化，清理临时资源
void FinalizeSystemInitialization(void)

{
  long long resourceDataIndex;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  long long StringIteratorPointer;
  long long *systemDataIndexPtr;
  long long systemAllocationOffset;
  
  SystemHashEntryPointer = (void* *)systemDataIndexPtr[1];
  SystemHashNodeData = (void* *)*systemDataIndexPtr;
  if (SystemHashNodeData != SystemHashEntryPointer) {
    do {
      (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemHashNodeData = SystemHashNodeData + 4;
    } while (SystemHashNodeData != SystemHashEntryPointer);
    SystemHashNodeData = (void* *)*systemDataIndexPtr;
  }
  if (SystemHashNodeData != (void* *)0x0) {
      SystemCleanupFunction(SystemHashNodeData);
  }
  *systemDataIndexPtr = systemAllocationOffset;
  resourceDataIndex = StringIteratorPointer * 0x20 + systemAllocationOffset;
  systemDataIndexPtr[2] = resourceDataIndex;
  systemDataIndexPtr[1] = resourceDataIndex;
  return;
}




/**
 * @brief 系统资源处理器
 * 
 * 该函数负责处理系统资源，包括资源的分配、清理和状态管理。
 * 它会根据资源的状态和容量需求，执行相应的资源操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 处理参数
 * @param AdditionalParameter 资源大小参数
 */
void SystemResourceProcessor(long long SystemResourceManager,void* ConfigurationDataPointer,long long AdditionalParameter)

{
  void* *resourcePointer1;
  void** SystemDataTable;
  void* resourceHandle;
  long long resourceOffset;
  void* *resourcePointer4;
  ulong long resourceCapacity;
  ulong long requiredSize;
  long long resourceArrayPointer;
  
  resourceCapacity = *(long long *)(SystemResourceManager + 8) - AdditionalParameter >> 5;
  if (resourceCapacity < requiredSize) {
    SetupSystemDataHandler();
    resourceHandle = AllocateSystemMemoryBlock(resourceCapacity * 0x20 + resourceOffset);
    *(void* *)(resourceArrayPointer + 8) = resourceHandle;
  }
  else {
    SystemHashEntryPointer = (void* *)SetupSystemDataHandler();
    resourcePointer1 = *(void* **)(resourceArrayPointer + 8);
    for (resourcePointer4 = SystemHashEntryPointer; resourcePointer4 != resourcePointer1; resourcePointer4 = resourcePointer4 + 4) {
      (**(code **)*resourcePointer4)(resourcePointer4,0);
    }
    *(void* **)(resourceArrayPointer + 8) = SystemHashEntryPointer;
  }
  return;
}





// 函数: void ProcessSystemParameters(long long* SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter,long long ConfigurationFlag)
/**
 * @brief 系统资源范围处理器函数
 * 
 * 该函数负责处理指定范围内的系统资源，包括资源验证和配置操作。
 * 它会检查资源范围的有效性，并对范围内的资源进行处理。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于指定处理范围
 * @param ConfigurationFlag 配置标志，用于控制处理行为
 * @note 这是系统资源管理的重要组成部分，用于处理指定范围内的资源
 */
void ProcessSystemResourceRange(long long* SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter,long long ConfigurationFlag)

{
  void* SystemOperationStatus;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  ulong long currentThreadId;
  
  if (AdditionalParameter == ConfigurationFlag) {
    return;
  }
  SystemThreadHandle = SystemResourceManager[1];
  currentThreadId = ConfigurationFlag - AdditionalParameter >> 3;
  if ((ulong long)(SystemResourceManager[2] - SystemThreadHandle >> 3) < currentThreadId) {
    ResourceDataOffset = *SystemResourceManager;
    SystemThreadHandle = SystemThreadHandle - ResourceDataOffset >> 3;
    resourceAddress = SystemThreadHandle * 2;
    if (SystemThreadHandle == 0) {
      resourceAddress = 1;
    }
    if (resourceAddress <= SystemThreadHandle + currentThreadId) {
      resourceAddress = SystemThreadHandle + currentThreadId;
    }
    if (resourceAddress == 0) {
      SystemOperationStatus = 0;
    }
    else {
      SystemOperationStatus = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAddress * 8,(char)SystemResourceManager[3]);
      ResourceDataOffset = *SystemResourceManager;
    }
    if (ResourceDataOffset != ConfigurationDataPointer) {
        memmove(SystemOperationStatus,ResourceDataOffset,ConfigurationDataPointer - ResourceDataOffset);
    }
      memmove(SystemOperationStatus,AdditionalParameter,ConfigurationFlag - AdditionalParameter);
  }
  resourceAddress = SystemThreadHandle - ConfigurationDataPointer >> 3;
  if (currentThreadId < resourceAddress) {
    ResourceDataOffset = SystemThreadHandle + currentThreadId * -8;
    if (ResourceDataOffset != SystemThreadHandle) {
        memmove(SystemThreadHandle,ResourceDataOffset,currentThreadId * 8);
    }
      memmove(SystemThreadHandle - ((SystemThreadHandle + currentThreadId * -8) - ConfigurationDataPointer & MAX_UNSIGNED_32_BITfffffff8),ConfigurationDataPointer);
  }
  ResourceDataOffset = AdditionalParameter + resourceAddress * 8;
  if (ResourceDataOffset != ConfigurationFlag) {
      memmove(SystemThreadHandle,ResourceDataOffset,ConfigurationFlag - ResourceDataOffset);
  }
  if (ConfigurationDataPointer != SystemThreadHandle) {
      memmove(SystemThreadHandle + (currentThreadId - resourceAddress) * 8,ConfigurationDataPointer,SystemThreadHandle - ConfigurationDataPointer);
  }
    memmove(ConfigurationDataPointer + (resourceAddress - (ResourceDataOffset - AdditionalParameter >> 3)) * 8,AdditionalParameter,ResourceDataOffset - AdditionalParameter);
}





/**
 * @brief 系统资源数据复制器函数
 * 
 * 该函数负责复制系统资源数据，包括内存移动和数据重组操作。
 * 它会处理不同区域的数据复制，确保数据被正确移动和重组。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于指定复制操作
 * @param ConfigurationFlag 配置标志，用于控制复制行为
 * @note 这是系统资源管理的重要组成部分，用于处理数据的复制和重组
 */
void CopySystemResourceData(long long* SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter,long long ConfigurationFlag)

{
  void* newMemoryBuffer;
  long long resourceStartAddress;
  long long resourceEndAddress;
  ulong long sourceOffset;
  ulong long targetOffset;
  
  resourceStartAddress = SystemResourceManager[1];
  targetOffset = ConfigurationFlag - AdditionalParameter >> 3;
  if ((ulong long)(SystemResourceManager[2] - resourceStartAddress >> 3) < targetOffset) {
    resourceEndAddress = *SystemResourceManager;
    resourceStartAddress = resourceStartAddress - resourceEndAddress >> 3;
    sourceOffset = resourceStartAddress * 2;
    if (resourceStartAddress == 0) {
      sourceOffset = 1;
    }
    if (sourceOffset <= resourceStartAddress + targetOffset) {
      sourceOffset = resourceStartAddress + targetOffset;
    }
    if (sourceOffset == 0) {
      newMemoryBuffer = 0;
    }
    else {
      newMemoryBuffer = CreateSystemThreadObject(SystemMemoryPoolTemplate,sourceOffset * 8,(char)SystemResourceManager[3]);
      resourceEndAddress = *SystemResourceManager;
    }
    if (resourceEndAddress != ConfigurationDataPointer) {
        memmove(newMemoryBuffer,resourceEndAddress,ConfigurationDataPointer - resourceEndAddress);
    }
      memmove(newMemoryBuffer,AdditionalParameter,ConfigurationFlag - AdditionalParameter);
  }
  sourceOffset = resourceStartAddress - ConfigurationDataPointer >> 3;
  if (targetOffset < sourceOffset) {
    resourceEndAddress = resourceStartAddress + targetOffset * -8;
    if (resourceEndAddress != resourceStartAddress) {
        memmove(resourceStartAddress,resourceEndAddress,targetOffset * 8);
    }
      memmove(resourceStartAddress - ((resourceStartAddress + targetOffset * -8) - ConfigurationDataPointer & MAX_UNSIGNED_32_BITfffffff8),ConfigurationDataPointer);
  }
  resourceEndAddress = AdditionalParameter + sourceOffset * 8;
  if (resourceEndAddress != ConfigurationFlag) {
      memmove(resourceStartAddress,resourceEndAddress,ConfigurationFlag - resourceEndAddress);
  }
  if (ConfigurationDataPointer != resourceStartAddress) {
      memmove(resourceStartAddress + (targetOffset - sourceOffset) * 8,ConfigurationDataPointer,resourceStartAddress - ConfigurationDataPointer);
  }
    memmove(ConfigurationDataPointer + (sourceOffset - (resourceEndAddress - AdditionalParameter >> 3)) * 8,AdditionalParameter,resourceEndAddress - AdditionalParameter);
}





/**
 * @brief 系统资源大小计算器函数
 * 
 * 该函数负责计算系统资源的大小和空间需求。
 * 它会根据资源指针计算所需的内存空间，并进行相应的调整。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @note 这是系统资源管理的重要组成部分，用于计算资源空间需求
 */
void CalculateSystemResourceSize(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  void* memoryBuffer;
  long long additionalOffset;
  long long targetAddress;
  long long *resourceArray;
  ulong long calculatedSize;
  
  SystemResourceManager = SystemResourceManager >> 3;
  calculatedSize = SystemResourceManager * 2;
  if (SystemResourceManager == 0) {
    calculatedSize = 1;
  }
  if (calculatedSize <= (ulong long)(SystemResourceManager + additionalOffset)) {
    calculatedSize = SystemResourceManager + additionalOffset;
  }
  if (calculatedSize == 0) {
    memoryBuffer = 0;
  }
  else {
    memoryBuffer = CreateSystemThreadObject(SystemMemoryPoolTemplate,calculatedSize * 8,(char)resourceArray[3]);
    ConfigurationDataPointer = *resourceArray;
  }
  if (ConfigurationDataPointer != targetAddress) {
      memmove(memoryBuffer,ConfigurationDataPointer,targetAddress - ConfigurationDataPointer);
  }
    memmove(memoryBuffer);
}




// 函数: void ResetSystemState(void)
// 功能: 重置系统状态，清理系统状态
void ResetSystemState(void)

{
  return;
}




// 函数: void ClearSystemCache(void)
// 功能: 清除系统缓存，释放缓存资源
void ClearSystemCache(void)

{
  return;
}




// 函数: void DestroySystemResource(long long SystemResourceManager)
// 功能: 销毁系统资源，释放相关资源
void DestroySystemResource(long long SystemResourceManager)

{
  FreeSystemMemoryPool();
  *(void* *)(SystemResourceManager + 8) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ReleaseSystemResourceManager(void* *SystemResourceManager)
/**
 * @brief 释放系统资源指针
 * 
 * 该函数负责释放系统资源指针，调用相关的清理函数
 * 并将资源指针重置为系统内存分配器引用
 * 
 * @param SystemResourceManager 系统资源指针
 */
void ReleaseSystemResourceManager(void* *SystemResourceManager)
{
  if ((long long *)SystemResourceManager[0x13] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x13] + 0x38))();
  }
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ResetSystemResourceManager(void* *SystemResourceManager)
/**
 * @brief 重置系统资源指针
 * 
 * 该函数负责重置系统资源指针，清理相关资源
 * 并将指针重置为适当的系统引用
 * 
 * @param SystemResourceManager 系统资源指针
 */
void ResetSystemResourceManager(void* *SystemResourceManager)
{
  ProcessSystemDataConfiguration(SystemResourceManager + 4);
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void SetupSystemResourceNode(void* *SystemResourceManager)
/**
 * @brief 清理系统资源指针
 * 
 * 该函数负责清理系统资源指针，处理资源释放
 * 并将指针重置为系统内存分配器引用
 * 
 * @param SystemResourceManager 系统资源指针
 */
void CleanupSystemResourceManager(void* *SystemResourceManager)
{
  if (SystemResourceManager[4] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void ProcessSystemResourceData(long long* SystemResourceManager)
/**
 * @brief 清理系统资源内存区域
 * 
 * 该函数负责清理系统资源的内存区域，遍历内存块并释放资源
 * 
 * @param SystemResourceManager 系统资源指针
 */
void CleanupSystemResourceMemoryRegion(long long* SystemResourceManager)
{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x548) {
    FinalizeSystemMemoryAllocation(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ProcessSystemDataConfiguration(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 销毁系统资源互斥锁
 * 
 * 该函数负责销毁系统资源的互斥锁，清理相关的内存块
 * 并处理系统资源的释放
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 */
void DestroySystemResourceMutex(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
{
  void* cleanupFlag;
  
  cleanupFlag = 0xfffffffffffffffe;
  _Mtx_destroy_in_situ();
  ProcessMemoryBlock(SystemResourceManager + 0xf0,*(void* *)(SystemResourceManager + 0x100),AdditionalParameter,ConfigurationFlag,cleanupFlag);
  ProcessMemoryBlock(SystemResourceManager + 0xc0,*(void* *)(SystemResourceManager + 0xd0));
  ProcessMemoryBlock(SystemResourceManager + 0x90,*(void* *)(SystemResourceManager + 0xa0));
  InitializeSystemConfigurationDataRecursive(SystemResourceManager + 0x60,*(void* )(SystemResourceManager + 0x70));
  ProcessSystemResourceExtension(SystemResourceManager + 0x30,*(void* *)(SystemResourceManager + 0x40));
  InitializeSystemConfigurationDataRecursive(SystemResourceManager,*(void* )(SystemResourceManager + 0x10));
  return;
}




// 函数: void ExecuteSystemConfiguration(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 处理系统资源初始化
 * 
 * 该函数负责处理系统资源的初始化过程
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 */
void ProcessSystemResourceInitialization(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
{
  InitializeSystemConfigurationDataRecursive(SystemResourceManager,*(void* )(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




// 函数: void ConfigureSystemParameters(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 执行系统资源配置
 * 
 * 该函数负责执行系统资源的配置过程
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 */
void ExecuteSystemResourceConfiguration(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
{
  InitializeSystemConfigurationDataRecursive(SystemResourceManager,*(void* )(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 执行配置数据回调函数
 * 
 * 该函数负责执行配置数据指针指向的回调函数，
 * 用于系统配置和初始化过程中的回调处理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针，指向要执行的回调函数
 * 
 */
void ExecuteConfigurationDataCallback(void* SystemResourceManager,void* *ConfigurationDataPointer)

{
  (*(code *)*ConfigurationDataPointer)();
  return;
}



00018017747d)
000180177a18)
000180177a22)
000180177a2e)
000180177a35)
000180177581)
000180177590)
00018017759c)
0001801775a3)
0001801775b3)
0001801775c0)
0001801775cc)
0001801775d3)
000180177263)
000180177296)
00018017726a)
000180177274)
000180177280)
000180177287)
000180177290)
000180177298)
00018017753a)
000180177540)
000180177550)
00018017755c)
000180177563)
0001801772c2)
0001801772d0)
0001801772dc)
0001801772e3)
00018017764c)
00018017749a)
0001801774a8)
0001801774aa)
000180176fc3)
000180177722)
00018017729d)
00018017766b)
000180177677)
000180177679)
00018017739f)
0001801773a6)
0001801773b0)
0001801773bc)
0001801773c3)
00018017731b)
000180177321)
000180177330)
00018017733c)
000180177343)
00018017734b)
000180177356)
000180177360)
00018017736c)
000180177373)
00018017737b)
000180177385)
0001801773cb)
000180177381)
0001801773cd)
0001801773d6)
0001801773da)
0001801773e4)
0001801773eb)
000180177400)
00018017740c)
000180177413)
00018017741e)
000180177417)
000180177420)


/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，包括内存分配、数据结构设置
 * 和系统状态配置。这是一个复杂的系统初始化函数，涉及多层级的
 * 资源管理和内存操作。
 * 
 * @param resourcePointer 系统资源指针，指向需要初始化的资源结构
 * 
 */
void InitializeSystemResourceManager(long long *resourcePointer)

{
  void* *******systemDataHierarchy;
  void** dataTable;
  void* *resourceNode;
  void* *memoryBlock;
  void* *allocationUnit;
  void** rootSystemNode;
  uint32_t SystemOperationStatusFlags;
  int operationCode;
  void* allocatedMemory;
  long long SystemAllocationFlags;
  uint8_t *dataBuffer;
  long long memoryPointer;
  void* *systemHandle;
  void* *******systemDataStructure;
  long long *primaryResourcePointer;
  uint systemValue;
  void* *resultPointer;
  long long secondaryMemoryPointer;
  void* ******systemManagementTable;
  int systemResult;
  uint *statusIndicator;
  ulong long systemData1;
  ulong long systemData2;
  ulong long systemData3;
  ulong long systemData4;
  bool isOperationComplete;
  uint8_t StackBuffer1 [32];
  void* *stackPointer1;
  uint8_t *stackPointer2;
  uint32_t stackValue1;
  ulong long stackValue2;
  uint stackValue3;
  int stackValue4;
  int stackValue5;
  long long stackValue6;
  void* ******stackManagement1;
  void* ******stackManagement2;
  void* ******stackManagement3;
  void* stackPointer3;
  void* stackPointer4;
  uint32_t stackValue7;
  void* *stackPointer5;
  void* *stackPointer6;
  uint32_t stackValue8;
  ulong long stackValue9;
  long long stackValue10;
  void* *stackPointer7;
  void* *stackPointer8;
  void* stackPointer9;
  uint32_t stackValue11;
  void* *stackPointer10;
  long long stackValue12;
  uint32_t stackValue13;
  long long stackValue14;
  ulong long stackValue15;
  long long stackValue16;
  void* *stackPointer11;
  void* *stackPointer12;
  void* *stackPointer13;
  void* stackPointer14;
  void* *stackPointer15;
  uint8_t *stackPointer16;
  uint32_t stackValue17;
  uint8_t StackBuffer2 [16];
  void* stackPointer17;
  void* stackPointer18;
  uint32_t stackValue18;
  uint32_t stackValue19;
  ulong long stackValue20;
  void* stackPointer21;
  
  stackPointer21 = 0x180059023;
  allocatedMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x270,8,3);
  stackPointer21 = 0x18005902b;
  SystemAllocationFlags = InitializeMemoryAllocationFlags(allocatedMemory);
  SystemOperationStatusFlags = *(uint32_t *)(SystemNodeManagerPointer + 0x1dc0);
  SystemAllocationFlags = SystemAllocationFlags;
  *(uint32_t *)(SystemAllocationFlags + 0x1e0) = *(uint32_t *)(SystemNodeManagerPointer + 0x1d50);
  *(uint32_t *)(SystemAllocationFlags + 0x1e4) = SystemOperationStatusFlags;
  stackPointer21 = 0x180059066;
  (**(code **)(**(long long **)(*resourcePointer + 0x2b0) + 0xf8))();
  stackPointer14 = 0xfffffffffffffffe;
  stackValue20 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer1;
  stackValue3 = 0;
  stackValue10 = SystemAllocationFlags;
  *(void* *)(SystemAllocationFlags + 0xf0) = 0;
  stackValue7 = 3;
  stackManagement1 = &stackManagement1;
  stackManagement2 = &stackManagement1;
  stackManagement3 = (void* *******)0x0;
  stackPointer3 = 0;
  stackPointer4 = 0;
  stackValue16 = *SystemGlobalStatusFlags;
  stackValue5 = 0;
  SystemAllocationFlags = *(long long *)(stackValue16 + 0x8a8);
  if (*(long long *)(stackValue16 + 0x8b0) - SystemAllocationFlags >> 5 != 0) {
    stackValue6 = 0;
    do {
      memoryPointer = stackValue6;
      operationCode = stackValue5;
      resultPointer = *(void* **)(stackValue6 * 0x20 + 8 + SystemAllocationFlags);
      systemHandle = &SystemStringTemplate;
      if (resultPointer != (void* *)0x0) {
        systemHandle = resultPointer;
      }
      stackPointer1 = &SystemGlobalDataReference;
      SystemContextValue0 = 0;
      ThreadLocalStoragePointer390 = (uint8_t *)0x0;
      SystemContextValue8 = 0;
      if (SystemDataConfigurationPointer != (void* *)0x0) {
        SystemAllocationFlags = -1;
        do {
          resourceDataIndex8 = SystemAllocationFlags;
          SystemAllocationFlags = resourceDataIndex8 + 1;
        } while (SystemDataConfigurationPointer[SystemAllocationFlags] != '\0');
        if ((int)SystemAllocationFlags != 0) {
          systemResult0 = (int)resourceDataIndex8 + 2;
          systemCode = systemResult0;
          if (systemResult0 < 0x10) {
            systemCode = 0x10;
          }
          ThreadLocalStorage = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,0x13);
          *ThreadLocalStorage = 0;
          ThreadLocalStoragePointer390 = ThreadLocalStorage;
          ThreadContextFlag = StartSystemThread(ThreadLocalStorage);
          SystemContextValue0 = ConcatenatedValue44(SystemContextValue0._4_4_,ThreadContextFlag);
            memcpy(ThreadLocalStorage,SystemDataConfigurationPointer,systemResult0);
        }
      }
      SystemContextValue8 = 0;
      InitializeSystemGlobalData(&SystemGlobalDataReference,&pointerUnsigned2e8,&MemoryAllocatorPointer398);
      ThreadLocalStoragePointer390 = (uint8_t *)0x0;
      SystemContextValue0 = SystemContextValue0 & MAX_UNSIGNED_32_BIT00000000;
      MemoryAllocatorPointer398 = &SystemMemoryAllocatorReference;
      pointerUnsigned308 = (void* *)0x0;
      DataBufferPtr300 = (void* *)0x0;
      SystemResourceValue = 0;
      SystemDataIndexCounter = 3;
      pSystemProcessFlags = &SystemResourceTemplateSecondary;
      pEncryptionKeyValue8 = SystemMemoryOffsetBuffer;
      SystemMemoryOffsetBuffer[0] = 0;
      EncryptionKeyValue0 = 4;
      strcpy_s(SystemMemoryOffsetBuffer,0x10,&SystemResourceString1);
      ProcessSystemResourceQueue(&pointerUnsigned2e8,&pointerUnsigned308,&pSystemProcessFlags);
      pSystemProcessFlags = &SystemMemoryAllocatorReference;
      SystemIterationIndex374 = 0;
      SystemLoopCounter2c8 = 0;
      SystemDataCount2c0 = (long long)DataBufferPtr300 - (long long)pointerUnsigned308 >> 5;
      SystemHashEntryPointer = pointerUnsigned308;
      SystemHashNodeData = pointerUnsigned308;
      presourceAddress = DataBufferPtr300;
      if (SystemDataCount2c0 != 0) {
        do {
          SystemAllocationFlags = SystemLoopCounter2c8;
          SystemHashEntryPointer = pointerUnsigned308;
          systemCode = SystemIterationIndex374;
          SystemStringTemplatePointer = &SystemStringTemplate;
          if ((void* *)pointerUnsigned308[SystemLoopCounter2c8 * 4 + 1] != (void* *)0x0) {
            SystemStringTemplatePointer = (void* *)pointerUnsigned308[SystemLoopCounter2c8 * 4 + 1];
          }
          resourceDataIndex2 = strrchr(SystemStringTemplatePointer,0x2f);
          if (resourceDataIndex2 == 0) {
            SystemStringTemplatePointer = &SystemStringTemplate;
            if ((void* *)SystemHashEntryPointer[SystemAllocationFlags * 4 + 1] != (void* *)0x0) {
              SystemStringTemplatePointer = (void* *)SystemHashEntryPointer[SystemAllocationFlags * 4 + 1];
            }
          }
          else {
            SystemStringTemplatePointer = (void* *)(resourceDataIndex2 + 1);
          }
          SystemDataConfigurationPointer = (void* *)strchr(SystemStringTemplatePointer,0x2e);
          if (SystemDataConfigurationPointer == (void* *)0x0) {
            SystemDataConfigurationPointer = &SystemStringTemplate;
            if ((void* *)SystemHashEntryPointer[SystemAllocationFlags * 4 + 1] != (void* *)0x0) {
              SystemDataConfigurationPointer = (void* *)SystemHashEntryPointer[SystemAllocationFlags * 4 + 1];
            }
            SystemDataConfigurationPointer = SystemDataConfigurationPointer + *(int *)(SystemHashEntryPointer + SystemAllocationFlags * 4 + 2);
          }
          if ((long long)SystemDataConfigurationPointer - (long long)SystemStringTemplatePointer != 0) {
              memcpy(&SystemDataBuffer268,SystemStringTemplatePointer,(long long)SystemDataConfigurationPointer - (long long)SystemStringTemplatePointer);
          }
                              SystemDataBuffer268.BufferFlags = 0;
          SystemOperationStatusFlags = 0;
          ThreadContextFlag = 0;
          pointerUnsigned330 = &SystemGlobalDataReference;
          SystemMemoryBufferPointer = 0;
          SystemThreadObject328 = (void* *)0x0;
          SystemMemoryBufferSize = 0;
          resourceDataIndex2 = -1;
          do {
            resourceDataIndex8 = resourceDataIndex2;
            resourceDataIndex2 = resourceDataIndex8 + 1;
          } while (*(char*)((long long)&SystemDataBuffer268 + resourceDataIndex8 + 1) != '\0');
          if ((int)(resourceDataIndex8 + 1) != 0) {
            systemResult0 = (int)resourceDataIndex8 + 2;
            systemCode = systemResult0;
            if (systemResult0 < 0x10) {
              systemCode = 0x10;
            }
            SystemThreadObject328 = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,0x13);
            *SystemThreadObject328 = 0;
            MemoryAllocationFlags = (ulong long)SystemThreadObject328 & MAX_UNSIGNED_32_BITffc00000;
            if (MemoryAllocationFlags != 0) {
              SystemAllocationFlags = ((long long)SystemThreadObject328 - MemoryAllocationFlags >> 0x10) * 0x50 + 0x80 + MemoryAllocationFlags;
              SystemHashEntryPointer1 = (uint *)(SystemAllocationFlags - (ulong long)*(uint *)(SystemAllocationFlags + 4));
              if ((*(byte *)((long long)SystemHashEntryPointer1 + 0xe) & 2) == 0) {
                SystemOperationStatusFlags = SystemHashEntryPointer1[7];
                if (0x3ffffff < SystemOperationStatusFlags) {
                  SystemOperationStatusFlags = *SystemHashEntryPointer1 << 0x10;
                }
              }
              else {
                SystemOperationStatusFlags = SystemHashEntryPointer1[7];
                if (SystemOperationStatusFlags < 0x4000000) {
                  InitializationFlags = (ulong long)SystemOperationStatusFlags;
                }
                else {
                  InitializationFlags = (ulong long)*SystemHashEntryPointer1 << 0x10;
                }
                if (0x3ffffff < SystemOperationStatusFlags) {
                  SystemOperationStatusFlags = *SystemHashEntryPointer1 << 0x10;
                }
                SystemOperationStatusFlags = SystemOperationStatusFlags - (int)(((long long)SystemThreadObject328 -
                                        (((long long)((long long)SystemHashEntryPointer1 + (-0x80 - MemoryAllocationFlags)) / 0x50) *
                                         0x10000 + MemoryAllocationFlags)) % InitializationFlags);
              }
            }
            SystemMemoryBufferPointer = ConcatenatedValue44(SystemMemoryBufferPointer._4_4_,SystemOperationStatusFlags);
              memcpy(SystemThreadObject328,&SystemDataBuffer268,systemResult0);
          }
          SystemMemoryBufferSize = 0;
          ppppppSystemThreadLocalStoragePointer = &pppppDataBufferPtr360;
          for (ppppSystemDataPointerPointer = (void* *******)SystemDataStructurePointer350;
              ppppSystemDataPointerPointer != (void* *******)0x0;
              ppppSystemDataPointerPointer = (void* *******)ppppSystemDataPointerPointer[1]) {
            ppppppSystemThreadLocalStoragePointer = ppppSystemDataPointerPointer;
          }
          if ((ppppppSystemThreadLocalStoragePointer == &pppppDataBufferPtr360) ||
             (resourceDataIndex2 = SystemAllocationFlags, *(int *)(ppppppSystemThreadLocalStoragePointer + 6) != 0)) {
            if ((ppppppSystemThreadLocalStoragePointer != (void* *******)pppppDataBufferPtr360) &&
               (ppppppSystemThreadLocalStoragePointer != &pppppDataBufferPtr360)) {
              SystemMemoryNodeGetNext(ppppppSystemThreadLocalStoragePointer);
            }
            isSystemActive6 = true;
            ppppppSystemThreadLocalStoragePointer = &pppppDataBufferPtr360;
            ppppSystemDataPointerPointer = (void* *******)SystemDataStructurePointer350;
            while (ppppSystemDataPointerPointer != (void* *******)0x0) {
              isSystemActive6 = *(int *)(ppppSystemDataPointerPointer + 6) != 0;
              ppppppSystemThreadLocalStoragePointer = ppppSystemDataPointerPointer;
              if (isSystemActive6) {
                ppppSystemDataPointerPointer = (void* *******)ppppSystemDataPointerPointer[1];
              }
              else {
                ppppSystemDataPointerPointer = (void* *******)*ppppSystemDataPointerPointer;
              }
            }
            resourceDataIndex2 = SystemLoopCounter2c8;
            systemCode = SystemIterationIndex374;
            if (isSystemActive6) {
              if (ppppppSystemThreadLocalStoragePointer == (void* *******)SystemDataStructurePointer358) {
                if ((ppppppSystemThreadLocalStoragePointer != &pppppDataBufferPtr360) && (*(int *)(ppppppSystemThreadLocalStoragePointer + 6) == 0)) {
                  ThreadContextFlag = 1;
                }
                SystemAllocationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x60,(uint8_t)SystemThreadFlag338);
                pSystemMemoryPoolSize = (void* *)(SystemAllocationFlags + 0x20);
                *pSystemMemoryPoolSize = &SystemMemoryAllocatorReference;
                *(void* *)(SystemAllocationFlags + 0x28) = 0;
                *(uint32_t *)(SystemAllocationFlags + 0x30) = 0;
                *pSystemMemoryPoolSize = &SystemGlobalDataReference;
                *(void* *)(SystemAllocationFlags + 0x38) = 0;
                *(void* *)(SystemAllocationFlags + 0x28) = 0;
                *(uint32_t *)(SystemAllocationFlags + 0x30) = 0;
                pointerUnsigned2a8 = pSystemMemoryPoolSize;
                ExecuteSystemCommand(pSystemMemoryPoolSize,0);
                pointerUnsigned2a0 = (void* *)(SystemAllocationFlags + 0x40);
                *pointerUnsigned2a0 = &SystemMemoryAllocatorReference;
                *(void* *)(SystemAllocationFlags + 0x48) = 0;
                *(uint32_t *)(SystemAllocationFlags + 0x50) = 0;
                *pointerUnsigned2a0 = &SystemGlobalDataReference;
                *(void* *)(SystemAllocationFlags + 0x58) = 0;
                *(void* *)(SystemAllocationFlags + 0x48) = 0;
                *(uint32_t *)(SystemAllocationFlags + 0x50) = 0;
                  ConfigureSystemResourceHandle(SystemAllocationFlags,ppppppSystemThreadLocalStoragePointer,&pppppDataBufferPtr360,ThreadContextFlag);
              }
              ppppppSystemThreadLocalStoragePointer = (void* *******)SystemResourceOffsetGet(ppppppSystemThreadLocalStoragePointer);
              resourceDataIndex2 = SystemLoopCounter2c8;
              systemCode = SystemIterationIndex374;
            }
          }
          SystemOperationStatusFlags = *(uint *)(SystemHashEntryPointer + SystemAllocationFlags * 4 + 2);
          MemoryAllocationFlags = (ulong long)SystemOperationStatusFlags;
          if (SystemHashEntryPointer[SystemAllocationFlags * 4 + 1] != 0) {
            ExecuteSystemCommand(ppppppSystemThreadLocalStoragePointer + 8,MemoryAllocationFlags);
          }
          if (SystemOperationStatusFlags != 0) {
              memcpy(ppppppSystemThreadLocalStoragePointer[9],SystemHashEntryPointer[SystemAllocationFlags * 4 + 1],MemoryAllocationFlags);
          }
          *(uint32_t *)(ppppppSystemThreadLocalStoragePointer + 10) = 0;
          if (ppppppSystemThreadLocalStoragePointer[9] != (void* ******)0x0) {
            *(uint8_t *)(MemoryAllocationFlags + (long long)ppppppSystemThreadLocalStoragePointer[9]) = 0;
          }
          *(uint32_t *)((long long)ppppppSystemThreadLocalStoragePointer + 0x5c) =
               *(uint32_t *)((long long)SystemHashEntryPointer + SystemAllocationFlags * 0x20 + 0x1c);
          SystemThreadObject328 = (void* *)0x0;
          SystemMemoryBufferPointer = SystemMemoryBufferPointer & MAX_UNSIGNED_32_BIT00000000;
          pointerUnsigned330 = &SystemMemoryAllocatorReference;
          SystemIterationIndex374 = systemCode + 1;
          SystemLoopCounter2c8 = resourceDataIndex2 + 1;
          SystemHashEntryPointer = pointerUnsigned308;
          SystemHashNodeData = pointerUnsigned308;
          presourceAddress = DataBufferPtr300;
          systemCode = SystemIterationIndex370;
          resourceDataIndex2 = SystemLoopCounter368;
        } while ((ulong long)(long long)SystemIterationIndex374 < SystemDataCount2c0);
      }
      for (; resourceEntryPointer = DataBufferPtr300, SystemThreadContext = pointerUnsigned308, SystemHashEntryPointer != DataBufferPtr300; SystemHashEntryPointer = SystemHashEntryPointer + 4)
      {
        pointerUnsigned308 = SystemHashNodeData;
        DataBufferPtr300 = presourceAddress;
        (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0);
        SystemHashNodeData = pointerUnsigned308;
        presourceAddress = DataBufferPtr300;
        DataBufferPtr300 = resourceEntryPointer;
        pointerUnsigned308 = SystemThreadContext;
      }
      if (pointerUnsigned308 != (void* *)0x0) {
        pointerUnsigned308 = SystemHashNodeData;
        DataBufferPtr300 = presourceAddress;
          SystemCleanupFunction(SystemThreadContext);
      }
      pointerUnsigned2e8 = &SystemGlobalDataReference;
      if (SystemMemoryOffset2e0 != 0) {
        pointerUnsigned308 = SystemHashNodeData;
        DataBufferPtr300 = presourceAddress;
          SystemCleanupFunction();
      }
      SystemMemoryOffset2e0 = 0;
      SystemResourceHandle = 0;
      pointerUnsigned2e8 = &SystemMemoryAllocatorReference;
      SystemIterationIndex370 = systemCode + 1;
      SystemLoopCounter368 = resourceDataIndex2 + 1;
      SystemAllocationFlags = *(long long *)(SystemMemoryBase2b8 + 0x8a8);
      pointerUnsigned308 = SystemHashNodeData;
      DataBufferPtr300 = presourceAddress;
    } while ((ulong long)(long long)SystemIterationIndex370 <
             (ulong long)(*(long long *)(SystemMemoryBase2b8 + 0x8b0) - SystemAllocationFlags >> 5));
  }
  SystemEncryptionKey = 0x3f8000003f800000;
  SystemOperationCounter = 0x3f000000;
  SystemFlag3c = 0;
  if ((void* *******)SystemDataStructurePointer358 != &pppppDataBufferPtr360) {
    SystemAllocationFlags = SystemMemoryOffset310 + 0x150;
    ppppppSystemThreadLocalStoragePointer = (void* *******)SystemDataStructurePointer358;
    resourceDataIndex2 = SystemMemoryOffset310;
    SystemLoopCounter368 = SystemAllocationFlags;
    do {
      PrimaryResourcePointer5 = (long long *)FindSystemResourceNode(SystemAllocationFlags,&pointerUnsigned2a0,ppppppSystemThreadLocalStoragePointer + 4);
      if (*PrimaryResourcePointer5 != SystemAllocationFlags) {
        isSystemActive6 = false;
        InitializationFlags = 0;
        resourceDataIndex8 = *(long long *)(resourceDataIndex2 + 0xc0);
        MemoryAllocationFlags = InitializationFlags;
        if (*(long long *)(resourceDataIndex2 + 200) - resourceDataIndex8 >> 3 != 0) {
          do {
            SystemAllocationFlags = *(long long *)(resourceDataIndex8 + InitializationFlags);
            MemoryAllocatorPointer398 = &SystemGlobalDataReference;
            SystemContextValue0 = 0;
            ThreadLocalStoragePointer390 = (uint8_t *)0x0;
            SystemContextValue8 = 0;
            if (*(int *)(SystemAllocationFlags + 0xb8) != 0) {
              systemCode = *(int *)(SystemAllocationFlags + 0xb8) + 1;
              if (systemCode < 0x10) {
                systemCode = 0x10;
              }
              ThreadLocalStoragePointer390 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,0x13);
              *ThreadLocalStoragePointer390 = 0;
              ConfigurationData = (ulong long)ThreadLocalStoragePointer390 & MAX_UNSIGNED_32_BITffc00000;
              if (ConfigurationData == 0) {
                SystemOperationStatusFlags = 0;
              }
              else {
                resourceDataIndex2 = ((long long)ThreadLocalStoragePointer390 - ConfigurationData >> 0x10) * 0x50 + 0x80 + ConfigurationData;
                SystemHashEntryPointer1 = (uint *)(resourceDataIndex2 - (ulong long)*(uint *)(resourceDataIndex2 + 4));
                if ((*(byte *)((long long)SystemHashEntryPointer1 + 0xe) & 2) == 0) {
                  SystemOperationStatusFlags = SystemHashEntryPointer1[7];
                  if (0x3ffffff < SystemOperationStatusFlags) {
                    SystemOperationStatusFlags = *SystemHashEntryPointer1 << 0x10;
                  }
                }
                else {
                  SystemOperationStatusFlags = SystemHashEntryPointer1[7];
                  if (SystemOperationStatusFlags < 0x4000000) {
                    SecurityParameter = (ulong long)SystemOperationStatusFlags;
                  }
                  else {
                    SecurityParameter = (ulong long)*SystemHashEntryPointer1 << 0x10;
                  }
                  if (0x3ffffff < SystemOperationStatusFlags) {
                    SystemOperationStatusFlags = *SystemHashEntryPointer1 << 0x10;
                  }
                  SystemOperationStatusFlags = SystemOperationStatusFlags - (int)(((long long)ThreadLocalStoragePointer390 -
                                          (((long long)((long long)SystemHashEntryPointer1 + (-0x80 - ConfigurationData)) / 0x50)
                                           * 0x10000 + ConfigurationData)) % SecurityParameter);
                }
              }
              SystemContextValue0 = ConcatenatedValue44(SystemContextValue0._4_4_,SystemOperationStatusFlags);
              if (*(int *)(SystemAllocationFlags + 0xb8) != 0) {
                  memcpy(ThreadLocalStoragePointer390,*(void* *)(SystemAllocationFlags + 0xb0),*(int *)(SystemAllocationFlags + 0xb8) + 1);
              }
            }
            if (*(long long *)(SystemAllocationFlags + 0xb0) != 0) {
              SystemContextValue8 = 0;
              if (ThreadLocalStoragePointer390 != (uint8_t *)0x0) {
                *ThreadLocalStoragePointer390 = 0;
              }
              SystemContextValue0 = SystemContextValue0 & MAX_UNSIGNED_32_BIT;
            }
            SystemOperationFlag378 = SystemOperationFlag378 & 0xfffffffd;
            MemoryAllocatorPointer398 = &SystemGlobalDataReference;
            if (ThreadLocalStoragePointer390 != (uint8_t *)0x0) {
                SystemCleanupFunction(ThreadLocalStoragePointer390);
            }
            ThreadLocalStoragePointer390 = (uint8_t *)0x0;
            SystemContextValue0 = SystemContextValue0 & MAX_UNSIGNED_32_BIT00000000;
            MemoryAllocatorPointer398 = &SystemMemoryAllocatorReference;
            resourceDataIndex2 = SystemMemoryOffset310;
            SystemAllocationFlags = SystemLoopCounter368;
            if (*(int *)(ppppppSystemThreadLocalStoragePointer + 6) == 0) {
              isSystemActive6 = true;
              break;
            }
            SystemOperationStatusFlags = (int)MemoryAllocationFlags + 1;
            MemoryAllocationFlags = (ulong long)SystemOperationStatusFlags;
            InitializationFlags = InitializationFlags + 8;
            resourceDataIndex8 = *(long long *)(SystemMemoryOffset310 + 0xc0);
          } while ((ulong long)(long long)(int)SystemOperationStatusFlags <
                   (ulong long)(*(long long *)(SystemMemoryOffset310 + 200) - resourceDataIndex8 >> 3));
        }
        if (!isSystemActive6) {
          ThreadContextFlag = CalculateSystemMemorySize(&SystemDataBuffer268,ppppppSystemThreadLocalStoragePointer + 8);
          SetupSystemMemory(&pointerUnsigned330,ThreadContextFlag);
          SystemDataBuffer268 = &SystemMemoryAllocatorReference;
          pppSystemDataPointerPointer9 = (void* ******)&SystemStringTemplate;
          if (ppppppSystemThreadLocalStoragePointer[5] != (void* ******)0x0) {
            pppSystemDataPointerPointer9 = ppppppSystemThreadLocalStoragePointer[5];
          }
          ProcessSystemQueue(&pointerUnsigned308,pppSystemDataPointerPointer9);
          SystemStringTemplatePointer = &SystemStringTemplate;
          if (SystemThreadObject328 != (void* *)0x0) {
            SystemStringTemplatePointer = SystemThreadObject328;
          }
          ProcessSystemQueue(&pointerUnsigned2e8,SystemStringTemplatePointer);
          InitializeSystemDataMemoryContext(resourceDataIndex2,&pointerUnsigned2e8,&pointerUnsigned308,&SystemEncryptionKey);
          pointerUnsigned2e8 = &SystemGlobalDataReference;
          if (SystemMemoryOffset2e0 != 0) {
              SystemCleanupFunction();
          }
          SystemMemoryOffset2e0 = 0;
          SystemResourceHandle = 0;
          pointerUnsigned2e8 = &SystemMemoryAllocatorReference;
          pointerUnsigned308 = (void* *)&SystemGlobalDataReference;
          if (DataBufferPtr300 != (void* *)0x0) {
              SystemCleanupFunction();
          }
          DataBufferPtr300 = (void* *)0x0;
          SystemDataIndexCounter = 0;
          pointerUnsigned308 = (void* *)&SystemMemoryAllocatorReference;
          pointerUnsigned330 = &SystemGlobalDataReference;
          if (SystemThreadObject328 != (void* *)0x0) {
              SystemCleanupFunction();
          }
          SystemThreadObject328 = (void* *)0x0;
          SystemMemoryBufferPointer = SystemMemoryBufferPointer & MAX_UNSIGNED_32_BIT00000000;
          pointerUnsigned330 = &SystemMemoryAllocatorReference;
        }
      }
      ppppppSystemThreadLocalStoragePointer = (void* *******)SystemMemoryNodeGetNext(ppppppSystemThreadLocalStoragePointer);
    } while (ppppppSystemThreadLocalStoragePointer != &pppppDataBufferPtr360);
  }
  ProcessSystemResourceInitialization(&pppppDataBufferPtr360);
    ValidateSystemChecksum(SystemContextValue ^ (ulong long)aconfigurationFlags3b8);
}



/**
 * @brief 系统资源分配器
 * 
 * 该函数负责分配和管理系统资源，包括内存分配、资源引用计数管理
 * 和资源池维护。这是系统资源管理的核心函数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，通常为状态标志
 * @param AdditionalParameter 参数3，通常为资源偏移量
 * @return 返回分配的资源指针
 * @note 这是资源管理系统的核心分配函数
 */
void* * SystemResourceAllocator(void* *SystemResourceManager,uint8_t *ConfigurationDataPointer,long long AdditionalParameter)

{
  byte isByteValid;
  bool isSystemActive;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  uint currentThreadId;
  byte *pisThreadActive;
  long long localDataIndex;
  
  isSystemActive = true;
  presourceAddress = (void* *)SystemResourceManager[2];
  SystemHashNodeData = SystemResourceManager;
  while (presourceAddress != (void* *)0x0) {
    SystemHashNodeData = presourceAddress;
    if (*(int *)(presourceAddress + 6) == 0) {
      isSystemActive = false;
SystemResourceLoop:
      presourceAddress = (void* *)*presourceAddress;
    }
    else {
      if (*(int *)(AdditionalParameter + 0x10) == 0) {
        isSystemActive = true;
      }
      else {
        pisThreadActive = (byte *)presourceAddress[5];
        localDataIndex = *(long long *)(AdditionalParameter + 8) - (long long)pisThreadActive;
        do {
          isByteValid = *pisThreadActive;
          currentThreadId = (uint)pisThreadActive[localDataIndex];
          if (isByteValid != currentThreadId) break;
          pisThreadActive = pisThreadActive + 1;
        } while (currentThreadId != 0);
        isSystemActive = 0 < (int)(isByteValid - currentThreadId);
      }
      if (!isSystemActive) goto SystemResourceLoop;
      presourceAddress = (void* *)presourceAddress[1];
    }
  }
  presourceAddress = SystemHashNodeData;
  if (isSystemActive) {
    if (SystemHashNodeData == (void* *)SystemResourceManager[1]) {
      *ConfigurationDataPointer = 1;
      return SystemHashNodeData;
    }
    presourceAddress = (void* *)SystemResourceOffsetGet(SystemHashNodeData);
  }
  if (*(int *)(AdditionalParameter + 0x10) != 0) {
    if (*(int *)(presourceAddress + 6) != 0) {
      pisThreadActive = *(byte **)(AdditionalParameter + 8);
      localDataIndex = presourceAddress[5] - (long long)pisThreadActive;
      do {
        isByteValid = *pisThreadActive;
        currentThreadId = (uint)pisThreadActive[localDataIndex];
        if (isByteValid != currentThreadId) break;
        pisThreadActive = pisThreadActive + 1;
      } while (currentThreadId != 0);
      if ((int)(isByteValid - currentThreadId) < 1) goto SystemResourceProcess;
    }
    *ConfigurationDataPointer = 1;
    return SystemHashNodeData;
  }
SystemResourceProcess:
  *ConfigurationDataPointer = 0;
  return presourceAddress;
}




// 函数: void FreeSystemMemoryPool(long long* SystemResourceManager)
// 功能: 释放系统内存池，清理内存资源
void FreeSystemMemoryPool(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x548) {
    FinalizeSystemMemoryAllocation(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ConfigureSystemResource(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
// 功能: 配置系统资源，设置资源参数
void ConfigureSystemResource(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  InitializeSystemConfigurationDataRecursive(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}



/**
 * @brief 系统资源数据复制器函数
 * 
 * 该函数负责在系统资源之间复制数据，包括配置数据和资源信息的复制。
 * 它会遍历资源指针数组，并执行相应的复制操作。
 * 
 * @param SystemResourceManager 系统资源指针，包含源资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于控制复制行为
 * @return 返回处理后的额外参数指针
 * 
 *SetupSystemDataHandler：CopySystemResourceData
 */
long long CopySystemResourceData(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  uint SystemOperationStatus;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  ResourceDataOffset = ConfigurationDataPointer - SystemResourceManager >> 5;
  if (0 < ResourceDataOffset) {
    resourcePoolPointer = (long long *)(SystemResourceManager + 8);
    SystemResourceManager = AdditionalParameter - SystemResourceManager;
    do {
      SystemOperationStatus = *(uint *)(resourcePoolPointer + 1);
      resourceAddress = (ulong long)SystemOperationStatus;
      if (*resourcePoolPointer != 0) {
        ExecuteSystemCommand(AdditionalParameter,resourceAddress);
      }
      if (SystemOperationStatus != 0) {
          memcpy(*(void* *)(SystemResourceManager + (long long)resourcePoolPointer),*resourcePoolPointer,resourceAddress);
      }
      *(uint32_t *)(SystemResourceManager + 8 + (long long)resourcePoolPointer) = 0;
      if (*(long long *)(SystemResourceManager + (long long)resourcePoolPointer) != 0) {
        *(uint8_t *)(resourceAddress + *(long long *)(SystemResourceManager + (long long)resourcePoolPointer)) = 0;
      }
      ResourceDataOffset = ResourceDataOffset + -1;
      *(uint32_t *)(SystemResourceManager + 0x14 + (long long)resourcePoolPointer) = *(uint32_t *)((long long)resourcePoolPointer + 0x14);
      AdditionalParameter = AdditionalParameter + 0x20;
      resourcePoolPointer = resourcePoolPointer + 4;
    } while (0 < ResourceDataOffset);
  }
  return AdditionalParameter;
}



/**
 * @brief 系统资源数据处理器函数
 * 
 * 该函数负责处理系统资源数据，包括数据的复制、移动和配置。
 * 它会遍历资源指针数组，并执行相应的数据处理操作。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于控制处理行为
 * @return 返回处理后的额外参数指针
 * 
 * 原始函数名：FUN_18005926c
 */
long long ProcessSystemResourceDataInternal(long long SystemResourceManager,void* ConfigurationDataPointer,long long AdditionalParameter)

{
  uint SystemOperationStatus;
  long long *resourcePoolPointer;
  long long systemStackFramePtr;
  long long StringIteratorPointer;
  ulong long resourceAllocationContext;
  
  resourcePoolPointer = (long long *)(SystemResourceManager + 8);
  AdditionalParameter = AdditionalParameter - SystemResourceManager;
  do {
    SystemOperationStatus = *(uint *)(resourcePoolPointer + 1);
    resourceAllocationContext = (ulong long)SystemOperationStatus;
    if (*resourcePoolPointer != 0) {
      ExecuteSystemCommand(StringIteratorPointer,resourceAllocationContext);
    }
    if (SystemOperationStatus != 0) {
        memcpy(*(void* *)(AdditionalParameter + (long long)resourcePoolPointer),*resourcePoolPointer,resourceAllocationContext);
    }
    *(uint32_t *)(AdditionalParameter + 8 + (long long)resourcePoolPointer) = 0;
    if (*(long long *)(AdditionalParameter + (long long)resourcePoolPointer) != 0) {
      *(uint8_t *)(resourceAllocationContext + *(long long *)(AdditionalParameter + (long long)resourcePoolPointer)) = 0;
    }
    systemStackFramePtr = systemStackFramePtr + -1;
    *(uint32_t *)(AdditionalParameter + 0x14 + (long long)resourcePoolPointer) = *(uint32_t *)((long long)resourcePoolPointer + 0x14);
    StringIteratorPointer = StringIteratorPointer + 0x20;
    resourcePoolPointer = resourcePoolPointer + 4;
  } while (0 < systemStackFramePtr);
  return StringIteratorPointer;
}




// 函数: void SystemNoOperation(void)
/**
 * @brief 系统空操作函数
 * 
 * 这是一个空操作函数，不执行任何操作，直接返回。
 * 主要用于占位或兼容性目的。
 * 
 * @note 这是系统中的空操作函数
 */
void SystemNoOperation(void)

{
  return;
}



long long CreateSystemObjectsBatch(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  if (SystemResourceManager != ConfigurationDataPointer) {
    do {
      CreateSystemObject(AdditionalParameter,SystemResourceManager);
      SystemResourceManager = SystemResourceManager + 0x20;
      AdditionalParameter = AdditionalParameter + 0x20;
    } while (SystemResourceManager != ConfigurationDataPointer);
  }
  return AdditionalParameter;
}




/**
 * @brief 移动系统资源数据
 * 
 * 该函数负责将系统资源数据从源地址移动到目标地址，
 * 用于系统资源的重新分配和数据迁移。
 * 
 * @param SystemResourceManager 源资源指针
 * @param ConfigurationDataPointer 配置数据指针（用作结束地址）
 * @param AdditionalParameter 目标参数指针
 * 
 * 原始函数名：FUN_180059350
 */
void MoveSystemResourceData(long long SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter)

{
  if (SystemResourceManager != ConfigurationDataPointer) {
    memmove(AdditionalParameter,SystemResourceManager,ConfigurationDataPointer - SystemResourceManager);
  }
  return;
}




/**
 * @brief 初始化系统资源指针
 * 
 * 该函数负责初始化系统资源指针，设置全局数据引用和内存分配器引用，
 * 用于系统资源管理的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针数组
 */
void InitializeSystemResourceManager(void* *SystemResourceManager)

{
  if (SystemResourceManager[4] != 0) {
    SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
    SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 递归初始化系统配置数据
 * 
 * 该函数负责递归地初始化系统配置数据，设置全局数据引用和内存分配器引用，
 * 用于系统配置的深度初始化处理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
  */
void InitializeSystemConfigurationDataRecursive(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  InitializeSystemConfigurationDataRecursive(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  StartSystemInitialization();
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
    SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
  SystemCleanupFunction(ConfigurationDataPointer);
}




/**
 * @brief 配置系统资源内存区域
 * 
 * 该函数负责配置系统资源的内存区域，设置内存区域参数和引用，
 * 用于系统内存管理和资源分配。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * 
 *FinalizeSystemMemoryAllocation：ConfigureSystemResourceMemoryRegions
 */
void ConfigureSystemResourceMemoryRegions(void* *SystemResourceManager)

{
  ConfigureSystemMemoryRegion(SystemResourceManager + 0x7d,0x58,4,InitializeDriverSystem,InvalidHandleValue);
  ConfigureSystemMemoryRegion(SystemResourceManager + 0x51,0x58,4,InitializeDriverSystem);
  ConfigureSystemMemoryRegion(SystemResourceManager + 0x11,0x20,0x10,CleanupSystemResources);
  SystemResourceManager[8] = &SystemGlobalDataReference;
  if (SystemResourceManager[9] != 0) {
    SystemCleanupFunction();
  }
  SystemResourceManager[9] = 0;
  *(uint32_t *)(SystemResourceManager + 0xb) = 0;
  SystemResourceManager[8] = &SystemMemoryAllocatorReference;
  SystemResourceManager[4] = &SystemGlobalDataReference;
  if (SystemResourceManager[5] != 0) {
    SystemCleanupFunction();
  }
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 7) = 0;
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
    SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源初始化器函数
 * 
 * 该函数负责初始化系统资源，设置全局数据引用和内存分配器。
 * 它会启动系统初始化过程，并设置系统资源的基本结构。
 * 
 * @param SystemResourceManager 系统资源指针，用于存储系统资源信息
 * 
  */
void InitializeSystemResources(void* *SystemResourceManager)

{
  StartSystemInitialization();
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，遍历系统资源并调用清理函数。
 * 它会遍历系统资源链表，对每个资源调用清理函数，最后进行系统清理。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
  */
void CleanupSystemResources(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x50) {
    ResetSystemResources(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源遍历清理器函数
 * 
 * 该函数负责遍历系统资源并清理每个资源项。
 * 它会遍历资源指针数组，对每个资源调用清理函数。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要清理的资源
 * 
 *FUN_180059640：CleanupSystemResourcesIterator
 */
void CleanupSystemResourcesIterator(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemThreadHandle = *SystemResourceManager; SystemThreadHandle != resourceDataIndex; SystemThreadHandle = SystemThreadHandle + 0x50) {
    ResetSystemResources(SystemThreadHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 系统资源重置器函数
 * 
 * 该函数负责重置系统资源，将资源指针重置为初始状态。
 * 它会重置全局数据引用和内存分配器，并清理资源状态。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要重置的资源信息
 * 
 *FUN_1800596a0：ResetSystemResources
 */
void ResetSystemResources(void* *SystemResourceManager)

{
  SystemResourceManager[4] = &SystemGlobalDataReference;
  if (SystemResourceManager[5] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 7) = 0;
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源清理验证器函数
 * 
 * 该函数负责验证系统资源的清理状态，并在必要时进行清理。
 * 它会检查资源状态，销毁互斥锁，确保资源被正确清理。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要验证的资源信息
 * 
 *FUN_180059730：ValidateSystemResourceCleanup
 */
void ValidateSystemResourceCleanup(long long SystemResourceManager)

{
  if (*(long long *)(SystemResourceManager + 8) != 0) {
      SystemCleanupFunction();
  }
  _Mtx_destroy_in_situ();
  return;
}



/**
 * @brief 系统资源数据复制器函数
 * 
 * 该函数负责在系统资源之间复制数据，包括配置数据和资源信息的复制。
 * 它会遍历资源指针数组，并执行相应的复制操作。
 * 
 * @param SystemResourceManager 系统资源指针，包含源资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于控制复制行为
 * @return 返回处理后的资源指针
 * 
 *FUN_180059780：CopySystemResourceDataExtended
 */
void* * CopySystemResourceDataExtended(void* *SystemResourceManager,void* *ConfigurationDataPointer,void* *AdditionalParameter)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  
  if (SystemResourceManager != ConfigurationDataPointer) {
    ResourceDataOffset = (long long)AdditionalParameter - (long long)SystemResourceManager;
    SystemHashEntryPointer = SystemResourceManager + 1;
    do {
      *AdditionalParameter = &SystemMemoryAllocatorReference;
      *(void* *)(ResourceDataOffset + (long long)SystemHashEntryPointer) = 0;
      *(uint32_t *)(ResourceDataOffset + 8 + (long long)SystemHashEntryPointer) = 0;
      *AdditionalParameter = &SystemGlobalDataReference;
      *(void* *)(ResourceDataOffset + 0x10 + (long long)SystemHashEntryPointer) = 0;
      *(void* *)(ResourceDataOffset + (long long)SystemHashEntryPointer) = 0;
      *(uint32_t *)(ResourceDataOffset + 8 + (long long)SystemHashEntryPointer) = 0;
      *(uint32_t *)(ResourceDataOffset + 8 + (long long)SystemHashEntryPointer) = *(uint32_t *)(SystemHashEntryPointer + 1);
      *(void* *)(ResourceDataOffset + (long long)SystemHashEntryPointer) = *SystemHashEntryPointer;
      *(uint32_t *)(ResourceDataOffset + 0x14 + (long long)SystemHashEntryPointer) = *(uint32_t *)((long long)SystemHashEntryPointer + 0x14);
      *(uint32_t *)(ResourceDataOffset + 0x10 + (long long)SystemHashEntryPointer) = *(uint32_t *)(SystemHashEntryPointer + 2);
      *(uint32_t *)(SystemHashEntryPointer + 1) = 0;
      *SystemHashEntryPointer = 0;
      SystemHashEntryPointer[2] = 0;
      AdditionalParameter = AdditionalParameter + 4;
      SystemDataPointer = SystemHashEntryPointer + 3;
      SystemHashEntryPointer = SystemHashEntryPointer + 4;
    } while (SystemDataPointer != ConfigurationDataPointer);
  }
  return AdditionalParameter;
}





// 函数: void ProcessSystemConfiguration(long long* SystemResourceManager,void* ConfigurationDataPointer)
void ProcessSystemConfiguration(long long* SystemResourceManager,void* ConfigurationDataPointer)

{
  void** SystemDataPointer;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  
  ResourceDataOffset = SystemResourceManager[1];
  SystemBufferAddress = *SystemResourceManager;
  SystemThreadFlags = ResourceDataOffset - SystemBufferAddress >> 5;
  if (SystemThreadFlags == 0) {
    SystemThreadFlags = 1;
  }
  else {
    SystemThreadFlags = SystemThreadFlags * 2;
    if (SystemThreadFlags == 0) {
      SystemThreadHandle = 0;
      goto SystemResourceConfiguration;
    }
  }
  SystemThreadHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadFlags << 5,(char)SystemResourceManager[3]);
  ResourceDataOffset = SystemResourceManager[1];
  SystemBufferAddress = *SystemResourceManager;
SystemResourceConfiguration:
  ResourceDataOffset = CopySystemResourceDataExtended(SystemBufferAddress,ResourceDataOffset,SystemThreadHandle);
  CreateSystemObject(ResourceDataOffset,ConfigurationDataPointer);
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  SystemThreadContext = (void* *)*SystemResourceManager;
  if (SystemThreadContext != SystemDataPointer) {
    do {
      (**(code **)*SystemThreadContext)(SystemThreadContext,0);
      SystemThreadContext = SystemThreadContext + 4;
    } while (SystemThreadContext != SystemDataPointer);
    SystemThreadContext = (void* *)*SystemResourceManager;
  }
  if (SystemThreadContext == (void* *)0x0) {
    *SystemResourceManager = SystemThreadHandle;
    SystemResourceManager[2] = SystemThreadFlags * 0x20 + SystemThreadHandle;
    SystemResourceManager[1] = ResourceDataOffset + 0x20;
    return;
  }
    SystemCleanupFunction(SystemThreadContext);
}



/**
 * @brief 系统内存分配器引用设置函数
 * 
 * 该函数负责设置系统内存分配器的引用，并根据配置数据指针
 * 决定是否释放内存资源。这是内存管理系统的核心函数之一。
 * 
 * @param SystemResourceManager 系统资源指针，用于设置内存分配器引用
 * @param ConfigurationDataPointer 配置数据指针，包含配置标志位
 * @param AdditionalParameter 额外参数，用于内存释放操作
 * @param ConfigurationFlag 配置标志，用于控制释放行为
 * @return 返回更新后的系统资源指针
 * 
 *FUN_180059900：InitializeSystemMemoryAllocatorReference
 */
void* *InitializeSystemMemoryAllocatorReference(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x28,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}




// 函数: void ProcessSystemResourceString(long long SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 系统字符串处理和缓冲区初始化函数
 * 
 * 该函数负责处理系统字符串操作，包括字符串长度计算、
 * 内存缓冲区初始化和字符串复制操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_180059940：ProcessSystemStringAndInitializeBuffer
 */
void ProcessSystemStringAndInitializeBuffer(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  
  if (ConfigurationDataPointer == 0) {
    *(uint32_t *)(SystemResourceManager + 0x10) = 0;
    **(uint8_t **)(SystemResourceManager + 8) = 0;
    return;
  }
  resourceDataIndex = -1;
  do {
    resourceDataIndex = resourceDataIndex + 1;
  } while (*(char *)(ConfigurationDataPointer + resourceDataIndex) != '\0');
  if ((int)resourceDataIndex < 0x10) {
    *(int *)(SystemResourceManager + 0x10) = (int)resourceDataIndex;
                    000180059977. Too many branches
                        strcpy_s(*(void* *)(SystemResourceManager + 8),0x10);
    return;
  }
  InitializeSystemMemoryBuffer(&SystemMemoryTemplateG,0x10,ConfigurationDataPointer);
  *(uint32_t *)(SystemResourceManager + 0x10) = 0;
  **(uint8_t **)(SystemResourceManager + 8) = 0;
  return;
}




/**
 * @brief 系统缓冲区数据复制函数
 * 
 * 该函数负责将配置数据复制到系统缓冲区中，支持不同大小的数据复制。
 * 当数据大小超过缓冲区容量时，会调用系统内存处理函数。
 * 
 * @param SystemResourceManager 系统资源指针，包含目标缓冲区信息
 * @param ConfigurationDataPointer 配置数据指针，包含要复制的数据
 * @param AdditionalParameter 额外参数，指定要复制的数据大小
 * 
 *FUN_1800599c0：CopySystemBufferData
 */
void CopySystemBufferData(long long SystemResourceManager,void* ConfigurationDataPointer,int AdditionalParameter)

{
  if (AdditionalParameter + 1 < 0x10) {
      memcpy(*(uint8_t **)(SystemResourceManager + 8),ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  **(uint8_t **)(targetBuffer + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  return;
}




// 函数: void ClearSystemMemoryBuffer(void)
/**
 * @brief 清除系统内存缓冲区
 * 
 * 该函数负责清除系统内存缓冲区的内容，使用memcpy操作进行内存清理。
 * 这是系统内存管理的重要组成部分，用于重置和清理内存区域。
 * 
 * @note 这是一个不返回的函数，执行后会直接跳转到其他代码位置
 */
void ClearSystemMemoryBuffer(void)

{
    memcpy();
}




// 函数: void ClearSystemResourceFlags(uint8_t *SystemResourceManager)
/**
 * @brief 清除系统资源标志
 * 
 * 该函数负责清除系统资源的标志位，将指定的系统资源指针清零。
 * 主要用于资源重置和清理操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是系统资源管理的清理函数
 */
void ClearSystemResourceFlags(uint8_t *SystemResourceManager)

{
  long long systemDataIndexPtr;
  
  *SystemResourceManager = 0;
  *(uint32_t *)(systemDataIndexPtr + 0x10) = 0;
  return;
}





// 函数: void HandleSystemResourceEncryption(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统资源处理和加密操作函数
 * 
 * 该函数负责处理系统资源，执行加密操作和数据处理。
 * 涉及内存分配、加密模板处理和资源管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 *FUN_180059a20：ProcessSystemResourceWithEncryption
 */
void ProcessSystemResourceWithEncryption(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  uint8_t asecondarySystemDataBuffer [32];
  void* SystemUnsignedFlag78;
  void* *SystemProcessFlagsPointer;
  uint8_t *pEncryptionValue68;
  uint32_t SystemThreadContext;
  uint8_t EncryptionBuffer58 [16];
  ulong long SystemEncryptionKey;
  
  SystemUnsignedFlag78 = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)asecondarySystemDataBuffer;
  SystemProcessFlagsPointer = &SystemResourceTemplateSecondary;
  pEncryptionValue68 = EncryptionBuffer58;
  SystemThreadContext = 0;
  EncryptionBuffer58[0] = 0;
  resourceDataIndex = strstr(*(void* *)(SystemResourceManager + 8));
  if (resourceDataIndex != 0) {
    SystemThreadHandle = -1;
    ResourceDataOffset = -1;
    do {
      ResourceDataOffset = ResourceDataOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + ResourceDataOffset) != '\0');
    do {
      SystemThreadHandle = SystemThreadHandle + 1;
    } while (*(char *)(SystemThreadHandle + AdditionalParameter) != '\0');
      memcpy(pEncryptionValue68,*(long long *)(SystemResourceManager + 8),resourceDataIndex - *(long long *)(SystemResourceManager + 8));
  }
  SystemProcessFlagsPointer = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)asecondarySystemDataBuffer);
}




// 函数: void AllocateSystemResource(void* *SystemResourceManager)
void AllocateSystemResource(void* *SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  
  if (SystemResourceManager == (void* *)0x0) {
    return;
  }
  resourceAllocationContext = (ulong long)SystemResourceManager & MAX_UNSIGNED_32_BITffc00000;
  if (resourceAllocationContext != 0) {
    SystemThreadHandle = resourceAllocationContext + 0x80 + ((long long)SystemResourceManager - resourceAllocationContext >> 0x10) * 0x50;
    SystemThreadHandle = SystemThreadHandle - (ulong long)*(uint *)(SystemThreadHandle + 4);
    if ((*(void ***)(resourceAllocationContext + 0x70) == &ExceptionList) && (*(char *)(SystemThreadHandle + 0xe) == '\0')) {
      *SystemResourceManager = *(void* *)(SystemThreadHandle + 0x20);
      *(void* **)(SystemThreadHandle + 0x20) = SystemResourceManager;
      SystemIntegerPointer = (int *)(SystemThreadHandle + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAllocationContext,CONCAT71(0xff000000,*(void ***)(resourceAllocationContext + 0x70) == &ExceptionList),
                          SystemResourceManager,resourceAllocationContext,InvalidHandleValue);
    }
  }
  return;
}





// 函数: void InitializeSystemThreadStructure(void)
/**
 * @brief 初始化系统线程结构
 * 
 * 该函数负责初始化系统线程的内存结构，分配必要的内存空间
 * 并设置线程对象的初始参数。这是系统线程管理的重要组成部分。
 * 
 * @note 这是系统初始化过程中的关键函数，确保线程管理系统的正常运行
 */
void InitializeSystemThreadStructure(void)

{
  long long resourceDataIndex;
  
  resourceDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x1ae8,10);
  if (resourceDataIndex == 0) {
    return;
  }
  *(void* *)(resourceDataIndex + 0x100) = 0;
  *(void* *)(resourceDataIndex + 0x108) = 0;
  *(uint32_t *)(resourceDataIndex + 0x130) = 0;
  *(void* *)(resourceDataIndex + 0x138) = 0;
  *(void*2 *)(resourceDataIndex + 0x140) = 0x100;
  *(void* *)(resourceDataIndex + 0x248) = 0;
  *(void* *)(resourceDataIndex + 0x250) = 0;
  *(uint32_t *)(resourceDataIndex + 0x278) = 0;
  *(void* *)(resourceDataIndex + 0x280) = 0;
  *(void*2 *)(resourceDataIndex + 0x288) = 0x100;
  *(void* *)(resourceDataIndex + 0x390) = 0;
  *(void* *)(resourceDataIndex + 0x398) = 0;
  *(uint32_t *)(resourceDataIndex + 0x3c0) = 0;
  *(void* *)(resourceDataIndex + 0x3c8) = 0;
  *(void*2 *)(resourceDataIndex + 0x3d0) = 0x100;
  *(void* *)(resourceDataIndex + 0x4d8) = 0;
  *(void* *)(resourceDataIndex + 0x4e0) = 0;
  *(uint32_t *)(resourceDataIndex + 0x508) = 0;
  *(void* *)(resourceDataIndex + 0x510) = 0;
  *(void*2 *)(resourceDataIndex + 0x518) = 0x100;
  *(void* *)(resourceDataIndex + 0x620) = 0;
  *(void* *)(resourceDataIndex + 0x628) = 0;
  *(uint32_t *)(resourceDataIndex + 0x650) = 0;
  *(void* *)(resourceDataIndex + 0x658) = 0;
  *(void*2 *)(resourceDataIndex + 0x660) = 0x100;
  *(void* *)(resourceDataIndex + 0x768) = 0;
  *(void* *)(resourceDataIndex + 0x770) = 0;
  *(uint32_t *)(resourceDataIndex + 0x798) = 0;
  *(void* *)(resourceDataIndex + 0x7a0) = 0;
  *(void*2 *)(resourceDataIndex + 0x7a8) = 0x100;
  *(void* *)(resourceDataIndex + 0x8b0) = 0;
  *(void* *)(resourceDataIndex + 0x8b8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x8e0) = 0;
  *(void* *)(resourceDataIndex + 0x8e8) = 0;
  *(void*2 *)(resourceDataIndex + 0x8f0) = 0x100;
  *(void* *)(resourceDataIndex + 0x9f8) = 0;
  *(void* *)(resourceDataIndex + 0xa00) = 0;
  *(uint32_t *)(resourceDataIndex + 0xa28) = 0;
  *(void* *)(resourceDataIndex + 0xa30) = 0;
  *(void*2 *)(resourceDataIndex + 0xa38) = 0x100;
  *(void* *)(resourceDataIndex + 0xb40) = 0;
  *(void* *)(resourceDataIndex + 0xb48) = 0;
  *(uint32_t *)(resourceDataIndex + 0xb70) = 0;
  *(void* *)(resourceDataIndex + 0xb78) = 0;
  *(void*2 *)(resourceDataIndex + 0xb80) = 0x100;
  *(void* *)(resourceDataIndex + 0xc88) = 0;
  *(void* *)(resourceDataIndex + 0xc90) = 0;
  *(uint32_t *)(resourceDataIndex + 0xcb8) = 0;
  *(void* *)(resourceDataIndex + 0xcc0) = 0;
  *(void*2 *)(resourceDataIndex + 0xcc8) = 0x100;
  *(void* *)(resourceDataIndex + 0xdd0) = 0;
  *(void* *)(resourceDataIndex + 0xdd8) = 0;
  *(uint32_t *)(resourceDataIndex + 0xe00) = 0;
  *(void* *)(resourceDataIndex + 0xe08) = 0;
  *(void*2 *)(resourceDataIndex + 0xe10) = 0x100;
  *(void* *)(resourceDataIndex + 0xf18) = 0;
  *(void* *)(resourceDataIndex + 0xf20) = 0;
  *(uint32_t *)(resourceDataIndex + 0xf48) = 0;
  *(void* *)(resourceDataIndex + 0xf50) = 0;
  *(void*2 *)(resourceDataIndex + 0xf58) = 0x100;
  *(void* *)(resourceDataIndex + 0x1060) = 0;
  *(void* *)(resourceDataIndex + 0x1068) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1090) = 0;
  *(void* *)(resourceDataIndex + 0x1098) = 0;
  *(void*2 *)(resourceDataIndex + 0x10a0) = 0x100;
  *(void* *)(resourceDataIndex + 0x11a8) = 0;
  *(void* *)(resourceDataIndex + 0x11b0) = 0;
  *(uint32_t *)(resourceDataIndex + 0x11d8) = 0;
  *(void* *)(resourceDataIndex + 0x11e0) = 0;
  *(void*2 *)(resourceDataIndex + 0x11e8) = 0x100;
  *(void* *)(resourceDataIndex + 0x12f0) = 0;
  *(void* *)(resourceDataIndex + 0x12f8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1320) = 0;
  *(void* *)(resourceDataIndex + 0x1328) = 0;
  *(void*2 *)(resourceDataIndex + 0x1330) = 0x100;
  *(void* *)(resourceDataIndex + 0x1438) = 0;
  *(void* *)(resourceDataIndex + 0x1440) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1468) = 0;
  *(void* *)(resourceDataIndex + 0x1470) = 0;
  *(void*2 *)(resourceDataIndex + 0x1478) = 0x100;
  *(void* *)(resourceDataIndex + 0x1580) = 0;
  *(void* *)(resourceDataIndex + 0x1588) = 0;
  *(uint32_t *)(resourceDataIndex + 0x15b0) = 0;
  *(void* *)(resourceDataIndex + 0x15b8) = 0;
  *(void*2 *)(resourceDataIndex + 0x15c0) = 0x100;
  *(void* *)(resourceDataIndex + 0x16c8) = 0;
  *(void* *)(resourceDataIndex + 0x16d0) = 0;
  *(uint32_t *)(resourceDataIndex + 0x16f8) = 0;
  *(void* *)(resourceDataIndex + 0x1700) = 0;
  *(void*2 *)(resourceDataIndex + 0x1708) = 0x100;
  *(void* *)(resourceDataIndex + 0x1810) = 0;
  *(void* *)(resourceDataIndex + 0x1818) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1840) = 0;
  *(void* *)(resourceDataIndex + 0x1848) = 0;
  *(void*2 *)(resourceDataIndex + 0x1850) = 0x100;
  *(void* *)(resourceDataIndex + 0x1958) = 0;
  *(void* *)(resourceDataIndex + 0x1960) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1988) = 0;
  *(void* *)(resourceDataIndex + 0x1990) = 0;
  *(void*2 *)(resourceDataIndex + 0x1998) = 0x100;
  *(void* *)(resourceDataIndex + 0x1aa0) = 0;
  *(void* *)(resourceDataIndex + 0x1aa8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1ad0) = 0;
  *(void* *)(resourceDataIndex + 0x1ad8) = 0;
  *(void*2 *)(resourceDataIndex + 0x1ae0) = 0x100;
  return;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，释放内存和关闭文件句柄
 * 用于游戏退出时的资源回收和系统清理
 * 
 * @param ResourceHandle 资源句柄指针
 */
void CleanupSystemResources(long long *ResourceHandle)

{
  int* SystemIntegerPointer;
  char *SystemStringPointer;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  
  SystemHashNodeData = (void* *)*SystemResourceManager;
  if (SystemHashNodeData != (void* *)0x0) {
    if ((void* *)SystemHashNodeData[3] != (void* *)0x0) {
      *(void* *)SystemHashNodeData[3] = 0;
    }
    (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemCleanupFunction(SystemHashNodeData);
  }
  if ((SystemResourceManager[6] != 0) && (*(long long *)(SystemResourceManager[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = SystemResourceManager[5];
  while (SystemBufferAddress != 0) {
    SystemStringPointer = (char *)(SystemBufferAddress + 0x141);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x138);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = (void* *)SystemResourceManager[3];
  if (SystemHashNodeData == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
  if (currentThreadId != 0) {
    SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
    SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
      *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
      *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
      SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          SystemHashNodeData,currentThreadId,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void InitializeSystemDataPointer(long long* SystemResourceManager)
/**
 * @brief 初始化系统数据指针
 * 
 * 该函数负责初始化系统数据指针，设置系统资源的内存布局和数据结构。
 * 这是系统数据管理的重要组成部分，确保数据访问的正确性和效率。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要初始化的系统资源
 * @note 这是系统初始化过程中的关键函数，确保数据管理系统的正常运行
 */
void InitializeSystemDataPointer(long long* SystemResourceManager)

{
  int *systemIntegerPointer;
  char *systemCharacterPointer;
  void* *systemResourcePointer;
  long long systemBufferAddress;
  ulong long systemUnsignedValue;
  
  SystemHashNodeData = (void* *)*SystemResourceManager;
  if (SystemHashNodeData != (void* *)0x0) {
    if ((void* *)SystemHashNodeData[3] != (void* *)0x0) {
      *(void* *)SystemHashNodeData[3] = 0;
    }
    (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemCleanupFunction(SystemHashNodeData);
  }
  if ((SystemResourceManager[6] != 0) && (*(long long *)(SystemResourceManager[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = SystemResourceManager[5];
  while (SystemBufferAddress != 0) {
    SystemStringPointer = (char *)(SystemBufferAddress + 0x141);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x138);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = (void* *)SystemResourceManager[3];
  if (SystemHashNodeData == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
  if (currentThreadId != 0) {
    SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
    SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
      *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
      *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
      SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          SystemHashNodeData,currentThreadId,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void ReleaseSystemResourceReference(void)
/**
 * @brief 释放系统资源引用
 * 
 * 该函数负责释放系统资源的引用，将资源指针清零并调用清理函数。
 * 主要用于资源管理和内存释放操作。
 * 
 * @note 这是系统资源管理的释放函数
 */
void ReleaseSystemResourceReference(void)

{
  void* *memoryBlockAddress;
  
  if ((void* *)memoryBlockAddress[3] != (void* *)0x0) {
    *(void* *)memoryBlockAddress[3] = 0;
  }
  (**(code **)*memoryBlockAddress)();
    SystemCleanupFunction();
}




// 函数: void CleanupSystemBuffers(void)
/**
 * @brief 系统清理和缓冲区处理函数
 * 
 * 该函数负责系统清理操作，处理缓冲区和内存管理。
 * 涉及系统资源的释放和内存区域的清理。
 * 
 *FUN_180059f4f：CleanupSystemAndProcessBuffers
 */
void CleanupSystemAndProcessBuffers(void)

{
  int* SystemIntegerPointer;
  char *SystemStringPointer;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  long long StringIteratorPointer;
  ulong long currentThreadId;
  
  if ((*(long long *)(StringIteratorPointer + 0x30) != 0) &&
     (*(long long *)(*(long long *)(StringIteratorPointer + 0x30) + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = *(long long *)(StringIteratorPointer + 0x28);
  while (SystemBufferAddress != 0) {
    SystemStringPointer = (char *)(SystemBufferAddress + 0x141);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x138);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = *(void* **)(StringIteratorPointer + 0x18);
  if (SystemHashNodeData != (void* *)0x0) {
    currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
    if (currentThreadId != 0) {
      SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
        SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                            SystemHashNodeData,currentThreadId,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




// 函数: void ManageSystemResourceWithException(void* *SystemResourceManager)
/**
 * @brief 系统资源指针管理和异常处理函数
 * 
 * 该函数负责管理系统资源指针，处理异常列表和内存地址计算。
 * 涉及系统资源的分配、释放和异常处理机制。
 * 
 * @param SystemResourceManager 系统资源指针的指针
 * 
 *FUN_180059fb0：ManageSystemResourceManagerWithExceptionHandling
 */
void ManageSystemResourceManagerWithExceptionHandling(void* *SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  
  resourceAllocationContext = (ulong long)SystemResourceManager & MAX_UNSIGNED_32_BITffc00000;
  if (resourceAllocationContext != 0) {
    SystemThreadHandle = resourceAllocationContext + 0x80 + ((long long)SystemResourceManager - resourceAllocationContext >> 0x10) * 0x50;
    SystemThreadHandle = SystemThreadHandle - (ulong long)*(uint *)(SystemThreadHandle + 4);
    if ((*(void ***)(resourceAllocationContext + 0x70) == &ExceptionList) && (*(char *)(SystemThreadHandle + 0xe) == '\0')) {
      *SystemResourceManager = *(void* *)(SystemThreadHandle + 0x20);
      *(void* **)(SystemThreadHandle + 0x20) = SystemResourceManager;
      SystemIntegerPointer = (int *)(SystemThreadHandle + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAllocationContext,CONCAT71(0xff000000,*(void ***)(resourceAllocationContext + 0x70) == &ExceptionList),
                          SystemResourceManager,resourceAllocationContext,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 系统资源清理和销毁函数
 * 
 * 该函数负责清理和销毁系统资源，包括互斥锁、条件变量和内存缓冲区。
 * 它会递归地清理所有关联的资源，确保系统资源的正确释放。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要清理的资源信息
 * 
 *FUN_180059fc0：CleanupAndDestroySystemResources
 */
void CleanupAndDestroySystemResources(long long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  char *SystemStringPointer;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  SystemHashNodeData = (void* *)*SystemResourceManager;
  if (SystemHashNodeData != (void* *)0x0) {
    if ((void* *)SystemHashNodeData[3] != (void* *)0x0) {
      *(void* *)SystemHashNodeData[3] = 0;
    }
    (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemCleanupFunction(SystemHashNodeData);
  }
  if ((SystemResourceManager[6] != 0) && (*(long long *)(SystemResourceManager[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = SystemResourceManager[5];
  while (SystemBufferAddress != 0) {
    SystemStringPointer = (char *)(SystemBufferAddress + 0x141);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x138);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = (void* *)SystemResourceManager[3];
  if (SystemHashNodeData == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
  if (currentThreadId != 0) {
    SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
    SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
      *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
      *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
      SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          SystemHashNodeData,currentThreadId,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void ProcessSystemResourceCleanup(long long SystemResourceManager)
/**
 * @brief 处理系统资源清理
 * 
 * 该函数负责处理系统资源的清理操作，包括资源引用计数的管理和资源释放。
 * 主要用于系统资源的生命周期管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是系统资源管理的清理函数
 */
void ProcessSystemResourceCleanup(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = *(void* **)(SystemResourceManager + 0x18);
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void CleanupSystemResourceArray(long long SystemResourceManager)
/**
 * @brief 清理系统资源数组
 * 
 * 该函数负责清理系统资源数组中的所有资源，遍历数组并释放每个资源。
 * 主要用于系统资源的批量清理和内存管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是系统资源管理的批量清理函数
 */
void CleanupSystemResourceArray(long long SystemResourceManager)

{
  ulong long SystemOperationStatus;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  SystemOperationStatus = *(ulong long *)(SystemResourceManager + 0x10);
  SystemThreadHandle = *(long long *)(SystemResourceManager + 8);
  resourceAddress = 0;
  if (SystemOperationStatus == 0) {
    *(void* *)(SystemResourceManager + 0x18) = 0;
  }
  else {
    do {
      ResourceDataOffset = *(long long *)(SystemThreadHandle + resourceAddress * 8);
      if (ResourceDataOffset != 0) {
        if (*(long long *)(ResourceDataOffset + 0x18) != 0) {
            SystemCleanupFunction();
        }
          SystemCleanupFunction(ResourceDataOffset);
      }
      *(void* *)(SystemThreadHandle + resourceAddress * 8) = 0;
      resourceAddress = resourceAddress + 1;
    } while (resourceAddress < SystemOperationStatus);
    *(void* *)(SystemResourceManager + 0x18) = 0;
  }
  return;
}




// 函数: void ValidateSystemResourceManager(long long SystemResourceManager)
/**
 * @brief 验证系统资源指针
 * 
 * 该函数负责验证系统资源指针的有效性，检查资源指针的完整性和状态。
 * 主要用于系统资源的安全检查和错误预防。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是系统资源管理的验证函数
 */
void ValidateSystemResourceManager(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  CleanupSystemAndProcessBuffers();
  if ((1 < *(ulong long *)(SystemResourceManager + 0x10)) &&
     (SystemHashEntryPointer = *(void* **)(SystemResourceManager + 8), SystemHashEntryPointer != (void* *)0x0)) {
    resourceAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
    if (resourceAddress != 0) {
      ResourceDataOffset = resourceAddress + 0x80 + ((long long)SystemHashEntryPointer - resourceAddress >> 0x10) * 0x50;
      ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
      if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
        *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
        *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
        SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                            SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源表验证和清理函数
 * 
 * 该函数负责验证系统资源表的有效性，并清理无效的资源条目。
 * 它会遍历资源表，检查每个资源的状态，并进行必要的清理操作。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源表信息
 * 
 *FUN_18005a130：ValidateAndCleanupSystemResourceTable
 */
void ValidateAndCleanupSystemResourceTable(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  CleanupSystemAndProcessBuffers();
  if ((1 < *(ulong long *)(SystemResourceManager + 0x10)) &&
     (SystemHashEntryPointer = *(void* **)(SystemResourceManager + 8), SystemHashEntryPointer != (void* *)0x0)) {
    resourceAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
    if (resourceAddress != 0) {
      ResourceDataOffset = resourceAddress + 0x80 + ((long long)SystemHashEntryPointer - resourceAddress >> 0x10) * 0x50;
      ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
      if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
        *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
        *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
        SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                            SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源异常处理函数
 * 
 * 该函数负责处理系统资源的异常情况，包括资源释放和异常检查。
 * 它会检查资源指针的有效性，并在必要时调用系统清理函数。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要处理的资源信息
 * @note 这是系统资源异常处理的重要组成部分
 */
void HandleSystemResourceException(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  CleanupSystemAndProcessBuffers();
  if ((1 < *(ulong long *)(SystemResourceManager + 0x10)) &&
     (SystemHashEntryPointer = *(void* **)(SystemResourceManager + 8), SystemHashEntryPointer != (void* *)0x0)) {
    resourceAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
    if (resourceAddress != 0) {
      ResourceDataOffset = resourceAddress + 0x80 + ((long long)SystemHashEntryPointer - resourceAddress >> 0x10) * 0x50;
      ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
      if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
        *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
        *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
        SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
        *SystemIntegerPointer = *SystemIntegerPointer + -1;
        if (*SystemIntegerPointer == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                            SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}



/**
 * @brief 系统资源释放处理器函数
 * 
 * 该函数负责处理系统资源的释放操作，根据配置标志决定是否释放资源。
 * 它会初始化系统资源处理器，并在条件满足时释放指定的资源。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要释放的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含释放操作的配置信息
 * @param AdditionalParameter 额外参数，用于扩展释放功能
 * @param ConfigurationFlag 配置标志，用于控制释放行为
 * @return 返回处理后的系统资源指针
 * @note 这是系统资源管理的重要组成部分，用于处理资源的释放操作
 */
void* ReleaseSystemResourceHandler(void* SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xc0,AdditionalParameter,ConfigurationFlag,SystemOperationStatus);
  }
  return SystemResourceManager;
}





/**
 * @brief 系统资源初始化和清理函数
 * 
 * 该函数负责初始化系统资源结构，包括内存分配、线程初始化和资源清理。
 * 它会设置各种系统参数，初始化互斥锁和条件变量，并分配必要的内存空间。
 * 
 * @param SystemResourceManager 系统资源指针的指针，包含需要初始化的资源信息
 * @note 这是系统资源初始化的重要组成部分，用于设置系统资源的基础结构
 */
void InitializeAndCleanupSystemResource(void* *systemResourceManager)

{
  ulong long systemOperationStatus;
  void* resourceCreationFlags;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  void* systemThreadContext;
  long long systemThreadFlags;
  void** systemCurrentNode;
  long long systemMemoryAddress;
  
  resourceAllocationContext = 0;
  *systemResourceManager = 0;
  *(uint32_t *)(systemResourceManager + 1) = 0;
  systemResourceManager[2] = 0;
  systemResourceManager[5] = 0;
  systemThreadContext = systemResourceManager + 0xb;
  systemMemoryAddress = 0x20;
  systemThreadFlags = 0x20;
  hashTableNode = systemThreadContext;
  do {
    SystemResourceCleanup(hashTableNode);
    hashTableNode = hashTableNode + 2;
    systemThreadFlags = systemThreadFlags + -1;
  } while (systemThreadFlags != 0);
  *(void* *)((long long)systemResourceManager + 0x25c) = 0;
  *(uint32_t *)(systemResourceManager + 0x4b) = 0;
  systemResourceManager[7] = 0;
  systemResourceManager[8] = 0x20;
  systemResourceManager[9] = systemThreadContext;
  do {
    *(uint32_t *)systemThreadContext = 0;
    systemThreadContext = systemThreadContext + 2;
    systemMemoryAddress = systemMemoryAddress + -1;
  } while (systemMemoryAddress != 0);
  systemResourceManager[10] = 0;
  systemResourceManager[6] = systemResourceManager + 8;
  systemResourceManager[4] = 0x15;
  systemThreadFlags = InitializeSystemThreadStructure();
  systemResourceManager[3] = systemThreadFlags;
  if (systemThreadFlags == 0) {
    systemResourceManager[4] = 0;
    systemOperationStatus = resourceAllocationContext;
  }
  else {
    systemOperationStatus = systemResourceManager[4];
  }
  resourceAddress = resourceAllocationContext;
  if (systemOperationStatus != 0) {
    do {
      *(uint8_t *)(resourceAddress + 0x141 + systemResourceManager[3]) = 0;
      resourceAllocationContext = resourceAllocationContext + 1;
      resourceAddress = resourceAddress + 0x148;
    } while (resourceAllocationContext < (ulong long)systemResourceManager[4]);
  }
  _Cnd_init_in_situ();
  _Mtx_init_in_situ(systemResourceManager + 0x56,2);
  systemResourceManager[0x60] = 0;
  systemResourceManager[0x61] = 0;
  systemResourceManager[0x62] = 0;
  *(uint32_t *)(systemResourceManager + 99) = 3;
  systemResourceManager[0x65] = 0;
  *(uint32_t *)(systemResourceManager + 0x6a) = 0x3f800000;
  *(void* *)((long long)systemResourceManager + 0x354) = 0x40000000;
  *(uint32_t *)((long long)systemResourceManager + 0x35c) = 3;
  systemResourceManager[0x68] = 1;
  systemResourceManager[0x67] = &SystemNullPointer;
  systemResourceManager[0x69] = 0;
  *(uint32_t *)(systemResourceManager + 0x6b) = 0;
  resourceCreationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,4);
    memset(resourceCreationFlags,0,0xc0);
}



/**
 * @brief 系统资源多重清理和释放函数
 * 
 * 该函数负责对系统资源进行多重清理操作，包括调用多个清理函数。
 * 它会按顺序清理不同偏移量的资源，并在条件满足时释放整个资源。
 * 
 * @param SystemResourceManager 系统资源指针的指针，包含需要清理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含清理操作的配置信息
 * @return 返回清理后的系统资源指针
 * @note 这是系统资源清理的重要组成部分，用于处理复杂的多重清理操作
 */
void* * CleanupAndReleaseMultipleSystemResources(void* *systemResourceManager,ulong long configurationDataPointer)

{
  *systemResourceManager = &SystemMemoryData3;
  ExecuteSystemResourceOperation(systemResourceManager + 0xa4);
  InitializeSystemResourceManager(systemResourceManager + 0x8c);
  ExecuteSystemResourceOperation(systemResourceManager + 0x7e);
  ExecuteSystemResourceOperation(systemResourceManager + 0x70);
  ExecuteSystemResourceOperation(systemResourceManager + 0x62);
  ExecuteSystemResourceOperation(systemResourceManager + 0x54);
  ExecuteSystemResourceOperation(systemResourceManager + 0x46);
  ExecuteSystemResourceOperation(systemResourceManager + 0x38);
  ExecuteSystemResourceOperation(systemResourceManager + 0x2a);
  ExecuteSystemResourceOperation(systemResourceManager + 0x1c);
  FinalizeSystemResourceCleanup(systemResourceManager);
  if ((configurationDataPointer & 1) != 0) {
    free(systemResourceManager,0x590);
  }
  return systemResourceManager;
}





/**
 * @brief 系统线程创建和初始化函数
 * 
 * 该函数负责创建和初始化系统线程，设置线程参数和标志。
 * 它会创建线程对象，启动线程，并设置线程的标识信息。
 * 
 * @param SystemResourceManager 系统资源指针，包含线程所需的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含线程的配置信息
 * @param AdditionalParameter 额外参数，用于扩展线程功能
 * @param ConfigurationFlag 配置标志，用于控制线程行为
 * @note 这是系统线程管理的重要组成部分，用于创建和初始化系统线程
 */
void CreateAndInitializeSystemThread(void* systemResourceManager,void* configurationDataPointer,void* additionalParameter,void* configurationFlag)

{
  uint32_t systemOperationStatus;
  void** systemDataTable;
  void* *memoryAllocationEnd;
  void* *systemEncryptionKey;
  uint32_t systemOperationCounter;
  void* systemContextValue;
  
  memoryAllocationEnd = &SystemGlobalDataReference;
  systemContextValue = 0;
  systemEncryptionKey = (void* *)0x0;
  systemOperationCounter = 0;
  systemHashEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13,configurationFlag,InvalidHandleValue);
  *(uint8_t *)systemHashEntryPointer = 0;
  systemEncryptionKey = systemHashEntryPointer;
  systemOperationStatus = StartSystemThread(systemHashEntryPointer);
  systemContextValue = ConcatenatedValue44(systemContextValue._4_4_,systemOperationStatus);
  *systemHashEntryPointer = 0x6320726f74696445;
  *(uint32_t *)(systemHashEntryPointer + 1) = 0x69666e6f;
  *(void*2 *)((long long)systemHashEntryPointer + 0xc) = 0x67;
  systemOperationCounter = 0xd;
  ManageSystemResource(systemResourceManager,&memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
    SystemCleanupFunction(systemHashEntryPointer);
}



/**
 * @brief 系统资源处理和释放函数
 * 
 * 该函数负责处理系统资源并根据配置标志决定是否释放资源。
 * 它会调用资源处理函数，并在条件满足时释放指定的资源。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要处理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含处理操作的配置信息
 * @return 返回处理后的系统资源指针
 * @note 这是系统资源管理的重要组成部分，用于处理和释放资源
 */
void* ProcessAndReleaseSystemResource(void* systemResourceManager,ulong long configurationDataPointer)

{
  InitializeSystemResourceProcessor();
  if ((configurationDataPointer & 1) != 0) {
    free(systemResourceManager,0xa90);
  }
  return systemResourceManager;
}




/**
 * @brief 系统资源批量处理和清理函数
 * 
 * 该函数负责对系统资源进行批量处理和清理操作，包括多个偏移量的资源处理。
 * 它会按顺序处理不同位置的资源，并进行必要的清理和检查。
 * 
 * @param SystemResourceManager 系统资源指针的指针，包含需要处理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含处理操作的配置信息
 * @param AdditionalParameter 额外参数，用于扩展处理功能
 * @param ConfigurationFlag 配置标志，用于控制处理行为
 * @note 这是系统资源批量处理的重要组成部分，用于处理复杂的资源清理操作
 */
void ProcessAndCleanupBatchSystemResources(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *SystemResourceManager = &SystemConfigDataTemplateA;
  InitializeSystemResourceA(SystemResourceManager + 0x143);
  InitializeSystemResourceA(SystemResourceManager + 0x134);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x126);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x118);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x10a);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xfc);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xee);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xe0);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xd2);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xc4);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xb6);
  ExecuteSystemResourceOperation(SystemResourceManager + 0xa8);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x9a);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x8c);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x7e);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x70);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x62);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x54);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x46);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x38);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x2a);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x1c);
  *SystemResourceManager = &SystemMemoryPoolTemplateA;
  SystemResourceManager[0x18] = &SystemGlobalDataReference;
  if (SystemResourceManager[0x19] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x19] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1b) = 0;
  SystemResourceManager[0x18] = &SystemMemoryAllocatorReference;
  ProcessSystemResourceConfiguration(SystemResourceManager + 0x12,SystemResourceManager[0x14],AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  if (SystemResourceManager[0xd] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[5] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * @brief 系统资源指针配置函数
 * 
 * 该函数负责配置系统资源指针，设置资源参数和属性
 * 用于系统资源的前期配置和准备工作
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 *FUN_18005aaf0：ConfigureSystemResourceManager
 */
void ConfigureSystemResourceManager(long long systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)
{
  if (*(code **)(systemResourcePointer + 0x10) != (code *)0x0) {
    (**(code **)(systemResourcePointer + 0x10))(systemResourcePointer, 0, 0, configurationFlag, 0xfffffffffffffffe);
  }
  return;
}




/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理参数
 * 用于系统资源管理的前期准备工作
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 *FUN_18005ab20：InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(long long systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)
{
  if (*(code **)(systemResourcePointer + 0x10) != (code *)0x0) {
    (**(code **)(systemResourcePointer + 0x10))(systemResourcePointer, 0, 0, configurationFlag, 0xfffffffffffffffe);
  }
  return;
}




/**
 * @brief 系统资源初始化函数A
 * 
 * 该函数负责初始化系统资源，设置系统全局数据引用和内存分配器
 * 用于系统资源管理的前期准备工作
 * 
 * @param SystemResourceManager 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * 
 *FUN_18005ab50：InitializeSystemResourceA
 */
void InitializeSystemResourceA(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(SystemResourceManager + 0x68) != (code *)0x0) {
    (**(code **)(SystemResourceManager + 0x68))(SystemResourceManager + 0x58,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  *(void* *)(SystemResourceManager + 0x30) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x38) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x38) = 0;
  *(uint32_t *)(SystemResourceManager + 0x48) = 0;
  *(void* *)(SystemResourceManager + 0x30) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x10) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x18) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  *(uint32_t *)(SystemResourceManager + 0x28) = 0;
  *(void* *)(SystemResourceManager + 0x10) = &SystemMemoryAllocatorReference;
  return;
}





/**
 * @brief 系统资源初始化函数B
 * 
 * 该函数负责初始化系统资源，创建系统线程并设置线程相关的数据结构
 * 用于系统资源管理中的线程初始化工作
 * 
 * @param SystemResourceManager 系统资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * 
 *FUN_18005ac00：InitializeSystemResourceB
 */
void InitializeSystemResourceB(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t SystemOperationStatus;
  uint32_t *SystemHashEntryPointer;
  void* *memoryAllocationEnd;
  uint32_t *pSystemEncryptionKey;
  uint32_t SystemOperationCounter;
  void* SystemContextValue;
  
  memoryAllocationEnd = &SystemGlobalDataReference;
  SystemContextValue = 0;
  pSystemEncryptionKey = (uint32_t *)0x0;
  SystemOperationCounter = 0;
  SystemHashEntryPointer = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x13,0x13,ConfigurationFlag,InvalidHandleValue);
  *(uint8_t *)SystemHashEntryPointer = 0;
  pSystemEncryptionKey = SystemHashEntryPointer;
  SystemOperationStatus = StartSystemThread(SystemHashEntryPointer);
  SystemContextValue = ConcatenatedValue44(SystemContextValue._4_4_,SystemOperationStatus);
  *SystemHashEntryPointer = 0x65766544;
  SystemHashEntryPointer[1] = 0x6d706f6c;
  SystemHashEntryPointer[2] = 0x20746e65;
  SystemHashEntryPointer[3] = 0x666e6f63;
  *(void*2 *)(SystemHashEntryPointer + 4) = 0x6769;
  *(uint8_t *)((long long)SystemHashEntryPointer + 0x12) = 0;
  SystemOperationCounter = 0x12;
  ManageSystemResource(SystemResourceManager,&memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
    SystemCleanupFunction(SystemHashEntryPointer);
}



/**
 * @brief 系统资源管理器函数
 * 
 * 该函数负责管理系统资源的生命周期，包括资源的创建、使用和释放。
 * 它会根据配置数据标志决定是否释放资源内存。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @return 返回系统资源指针
 * 
 *FUN_18005b520：ManageSystemResource
 */
void* ManageSystemResource(void* systemResourcePointer, unsigned long long configurationDataPointer)

{
  CleanupSystemResource();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x13c0);
  }
  return SystemResourceManager;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，调用系统内存分配器清理函数
 * 并对资源指针进行重置和初始化操作。
 * 
 * @param systemResourcePointer 系统资源指针的指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 *FUN_18005b560：CleanupSystemResource
 */
void CleanupSystemResource(void** systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)

{
  *systemResourcePointer = &SystemMemoryManagerTemplateA;
  CleanupSystemMemoryAllocation();
  CleanupSystemMemoryAllocation();
  ExecuteSystemResourceOperation((long long)*systemResourcePointer + 0x262, configurationDataPointer, additionalParameter, configurationFlag);
  ExecuteSystemResourceOperation((long long)*systemResourcePointer + 0x254, configurationDataPointer, additionalParameter, configurationFlag);
  ExecuteSystemResourceOperation((long long)*systemResourcePointer + 0x246, configurationDataPointer, additionalParameter, configurationFlag);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x238);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x22a);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x21c);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x20e);
  InitializeSystemResourceManager(SystemResourceManager + 0x1f6);
  InitializeSystemResourceManager(SystemResourceManager + 0x1de);
  InitializeSystemResourceManager(SystemResourceManager + 0x1c6);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x1b8);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x1aa);
  ExecuteSystemResourceOperation(SystemResourceManager + 0x19c);
  InitializeSystemResourceManager(SystemResourceManager + 0x184);
  InitializeSystemResourceManager(SystemResourceManager + 0x16c);
  InitializeSystemResourceManager(SystemResourceManager + 0x154);
  InitializeSystemResourceManager(SystemResourceManager + 0x13c);
  InitializeSystemResourceManager(SystemResourceManager + 0x124);
  InitializeSystemResourceManager(SystemResourceManager + 0x10c);
  InitializeSystemResourceManager(SystemResourceManager + 0xf4);
  InitializeSystemResourceManager(SystemResourceManager + 0xdc);
  InitializeSystemResourceManager(SystemResourceManager + 0xc4);
  InitializeSystemResourceManager(SystemResourceManager + 0xac);
  InitializeSystemResourceManager(SystemResourceManager + 0x94);
  InitializeSystemResourceManager(SystemResourceManager + 0x7c);
  InitializeSystemResourceManager(SystemResourceManager + 100);
  InitializeSystemResourceManager(SystemResourceManager + 0x4c);
  InitializeSystemResourceManager(SystemResourceManager + 0x34);
  InitializeSystemResourceManager(SystemResourceManager + 0x1c);
  *SystemResourceManager = &SystemMemoryPoolTemplateA;
  SystemResourceManager[0x18] = &SystemGlobalDataReference;
  if (SystemResourceManager[0x19] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x19] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1b) = 0;
  SystemResourceManager[0x18] = &SystemMemoryAllocatorReference;
  ProcessSystemResourceConfiguration(SystemResourceManager + 0x12,SystemResourceManager[0x14],AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  if (SystemResourceManager[0xd] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[5] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  return;
}



/**
 * @brief 初始化系统资源指针结构
 * 
 * 该函数负责初始化系统资源指针结构，设置内存分配器引用和全局数据引用。
 * 它会配置资源结构的各个字段，包括内存分配器、全局数据和防护检查。
 * 
 * @param SystemResourceManager 系统资源指针，需要初始化的资源结构
 * @return 返回初始化后的系统资源指针
 */
long long InitializeSystemResourceManagerStructure(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  *(void* *)(SystemResourceManager + 8) = &SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  *(void* *)(SystemResourceManager + 0x28) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x30) = 0;
  *(uint32_t *)(SystemResourceManager + 0x38) = 0;
  *(void* *)(SystemResourceManager + 0x28) = &SystemGlobalDataReference;
  *(void* *)(SystemResourceManager + 0x40) = 0;
  *(void* *)(SystemResourceManager + 0x30) = 0;
  *(uint32_t *)(SystemResourceManager + 0x38) = 0;
  *(void* *)(SystemResourceManager + 0x60) = 0;
  *(code **)(SystemResourceManager + 0x68) = _guard_check_icall;
  return SystemResourceManager;
}




/**
 * @brief 系统资源执行器函数
 * 
 * 该函数负责执行系统资源操作，调用资源指针中的函数指针
 * 并设置系统全局数据引用和内存分配器引用。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param configurationDataPointer 配置数据指针
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * 
 *FUN_18005b7c0：ExecuteSystemResourceOperation
 */
void ExecuteSystemResourceOperation(long long systemResourcePointer, void* configurationDataPointer, void* additionalParameter, void* configurationFlag)

{
  if (*(code **)(SystemResourceManager + 0x60) != (code *)0x0) {
    (**(code **)(SystemResourceManager + 0x60))(SystemResourceManager + 0x50,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  *(void* *)(SystemResourceManager + 0x28) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x30) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x30) = 0;
  *(uint32_t *)(SystemResourceManager + 0x40) = 0;
  *(void* *)(SystemResourceManager + 0x28) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 8) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  return;
}



/**
 * @brief 系统资源指针初始化函数
 * 
 * 该函数负责初始化系统资源指针，设置内存分配器引用和全局数据引用。
 * 它会重置资源指针的各种状态和标志位。
 * 
 * @param systemResourcePointer 系统资源指针的指针
 * @return 返回系统资源指针的指针
 * 
 *FUN_18005b870：InitializeSystemResourceManager
 */
void** InitializeSystemResourceManager(void** systemResourcePointer)

{
  *systemResourcePointer = &SystemMemoryAllocatorReference;
  systemResourcePointer[1] = 0;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  *systemResourcePointer = &SystemGlobalDataReference;
  systemResourcePointer[3] = 0;
  systemResourcePointer[1] = 0;
  *(uint32_t *)(systemResourcePointer + 2) = 0;
  systemResourcePointer[4] = &SystemMemoryAllocatorReference;
  systemResourcePointer[5] = 0;
  *(uint32_t *)(systemResourcePointer + 6) = 0;
  systemResourcePointer[4] = &SystemGlobalDataReference;
  systemResourcePointer[7] = 0;
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 6) = 0;
  SystemResourceManager[8] = &SystemMemoryAllocatorReference;
  SystemResourceManager[9] = 0;
  *(uint32_t *)(SystemResourceManager + 10) = 0;
  SystemResourceManager[8] = &SystemGlobalDataReference;
  SystemResourceManager[0xb] = 0;
  SystemResourceManager[9] = 0;
  *(uint32_t *)(SystemResourceManager + 10) = 0;
  SystemResourceManager[0xc] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0xd] = 0;
  *(uint32_t *)(SystemResourceManager + 0xe) = 0;
  SystemResourceManager[0xc] = &SystemGlobalDataReference;
  SystemResourceManager[0xf] = 0;
  SystemResourceManager[0xd] = 0;
  *(uint32_t *)(SystemResourceManager + 0xe) = 0;
  SystemResourceManager[0x10] = &SystemMemoryAllocatorReference;
  SystemResourceManager[0x11] = 0;
  *(uint32_t *)(SystemResourceManager + 0x12) = 0;
  SystemResourceManager[0x10] = &SystemGlobalDataReference;
  SystemResourceManager[0x13] = 0;
  SystemResourceManager[0x11] = 0;
  *(uint32_t *)(SystemResourceManager + 0x12) = 0;
  SystemResourceManager[0x16] = 0;
  SystemResourceManager[0x17] = _guard_check_icall;
  return SystemResourceManager;
}




/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置系统资源指针和内存分配器。
 * 用于系统资源管理的前期准备工作，确保资源分配的正确性。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18005b960：InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  // 初始化第四组系统资源
  if ((code *)SystemResourceManager[0x16] != (code *)0x0) {
    (*(code *)SystemResourceManager[0x16])(SystemResourceManager + 0x14, 0, 0, ConfigurationFlag, 0xfffffffffffffffe);
  }
  
  // 设置全局数据引用和内存分配器
  SystemResourceManager[0x10] = &SystemGlobalDataReference;
  if (SystemResourceManager[0x11] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x11] = 0;
  *(uint32_t *)(SystemResourceManager + 0x13) = 0;
  SystemResourceManager[0x10] = &SystemMemoryAllocatorReference;
  
  // 初始化第三组系统资源
  SystemResourceManager[0xc] = &SystemGlobalDataReference;
  if (SystemResourceManager[0xd] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0xd] = 0;
  *(uint32_t *)(SystemResourceManager + 0xf) = 0;
  SystemResourceManager[0xc] = &SystemMemoryAllocatorReference;
  
  // 初始化第二组系统资源
  SystemResourceManager[8] = &SystemGlobalDataReference;
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[9] = 0;
  *(uint32_t *)(SystemResourceManager + 0xb) = 0;
  SystemResourceManager[8] = &SystemMemoryAllocatorReference;
  
  // 初始化第一组系统资源
  SystemResourceManager[4] = &SystemGlobalDataReference;
  if (SystemResourceManager[5] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 7) = 0;
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  
  // 初始化主系统资源
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  
  return;
}





/**
 * @brief 系统线程初始化函数
 * 
 * 该函数负责初始化系统线程，创建线程对象并启动线程执行。
 * 用于系统并发处理和多任务管理的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18005ba80：InitializeSystemThread
 */
void InitializeSystemThread(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t threadStatus;
  void** SystemDataTable;
  void* *memoryAllocationEnd;
  void* *threadContextPointer;
  uint32_t threadConfiguration;
  void* threadHandle;
  
  // 初始化内存分配和线程上下文
  memoryAllocationEnd = &SystemGlobalDataReference;
  threadHandle = 0;
  threadContextPointer = (void* *)0x0;
  threadConfiguration = 0;
  
  // 创建系统线程对象
  void* *threadObject = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate, 0x10, 0x13, ConfigurationFlag, 0xfffffffffffffffe);
  *(uint8_t *)threadObject = 0;
  threadContextPointer = threadObject;
  
  // 启动系统线程
  threadStatus = StartSystemThread(threadObject);
  threadHandle = ConcatenatedValue44(threadHandle.HighPart, threadStatus);
  
  // 设置线程标识符
  *threadObject = 0x6e6f632072657355;
  *(uint32_t *)(threadObject + 1) = 0x676966;
  threadConfiguration = 0xb;
  
  // 调用系统线程处理函数
  ManageSystemResource(SystemResourceManager, &memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
  
  SystemCleanupFunction(threadObject);
}



/**
 * @brief 系统资源指针初始化器
 * 
 * 该函数负责初始化系统资源指针，设置指针的基本结构和初始值。
 * 它会将资源指针的所有字段重置为零，并设置标准大小标识符。
 * 
 * @param SystemResourceManager 系统资源指针，需要被初始化的资源指针
 * @return 初始化后的系统资源指针
 * 
 *FUN_18005c060：InitializeSystemResourceManager
 */
void* * InitializeSystemResourceManager(void* *SystemResourceManager)

{
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0x24;
  return SystemResourceManager;
}



long long InitializeSystemContext(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  InitializeSystemMemoryBlock(SystemResourceManager,0x20,0x400,InitializeSystemDataBlock,ReleaseSystemMemoryBlock);
  InitializeSystemMemoryBlock(SystemResourceManager + 0x8000,0x20,0x400,InitializeSystemDataBlock,ReleaseSystemMemoryBlock);
  *(void* *)(SystemResourceManager + 0x10400) = 0;
  *(void* *)(SystemResourceManager + 0x10408) = 0;
  *(void* *)(SystemResourceManager + 0x10410) = 0;
  *(uint32_t *)(SystemResourceManager + 0x10418) = 0x24;
  resourceDataIndex = SystemResourceManager + 0x10002;
  SystemThreadHandle = 8;
  do {
    *(void* *)(resourceDataIndex + -2) = 0;
    *(void* *)(resourceDataIndex + 6) = 0;
    *(void* *)(resourceDataIndex + 0xe) = 0;
    *(void* *)(resourceDataIndex + 0x16) = 0;
    *(void* *)(resourceDataIndex + 0x1e) = 0;
    *(void* *)(resourceDataIndex + 0x26) = 0;
    *(void* *)(resourceDataIndex + 0x2e) = 0;
    *(void* *)(resourceDataIndex + 0x36) = 0;
    *(void* *)(resourceDataIndex + 0x3e) = 0;
    *(void* *)(resourceDataIndex + 0x46) = 0;
    *(void* *)(resourceDataIndex + 0x4e) = 0;
    *(void* *)(resourceDataIndex + 0x56) = 0;
    *(void* *)(resourceDataIndex + 0x5e) = 0;
    *(void* *)(resourceDataIndex + 0x66) = 0;
    *(void* *)(resourceDataIndex + 0x6e) = 0;
    *(void* *)(resourceDataIndex + 0x76) = 0;
    resourceDataIndex = resourceDataIndex + 0x80;
    SystemThreadHandle = SystemThreadHandle + -1;
  } while (SystemThreadHandle != 0);
  return SystemResourceManager;
}




void*
ProcessSystemDataOperation(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  CreateSystemObject(ConfigurationDataPointer,SystemContextManagerPointer + 0xe0,AdditionalParameter,ConfigurationFlag,0,InvalidHandleValue);
  return ConfigurationDataPointer;
}



/**
 * @brief 系统资源内存模板配置器
 * 
 * 该函数负责配置系统资源的内存模板，设置内存模板的引用和初始化参数。
 * 它会根据配置标志决定是否释放资源内存，并设置标准的内存模板引用。
 * 
 * @param SystemResourceManager 系统资源指针，需要配置的资源
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于扩展配置
 * @param ConfigurationFlag 配置标志，控制配置行为
 * @return 配置后的系统资源指针
 * 
 *FUN_18005c210：ConfigureSystemResourceMemoryTemplate
 */
void* * ConfigureSystemResourceMemoryTemplate(void* *SystemResourceManager,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if ((code *)SystemResourceManager[6] != (code *)0x0) {
    (*(code *)SystemResourceManager[6])(SystemResourceManager + 4,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  *SystemResourceManager = &SystemMemoryTemplateC;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x40);
  }
  return SystemResourceManager;
}



void* *
CreateMemoryAllocationHandle(void* *SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  
  *SystemResourceManager = &SystemMemoryTemplateA;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *SystemResourceManager = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(SystemResourceManager + 2) = 0;
  UNLOCK();
  SystemResourceManager[3] = 0xffffffffffffffff;
  *SystemResourceManager = &SystemDataStructureTemplateA;
  SystemDataPointer = SystemResourceManager + 4;
  SystemResourceManager[6] = 0;
  SystemResourceManager[7] = _guard_check_icall;
  if (SystemDataPointer != ConfigurationDataPointer) {
    if ((code *)SystemResourceManager[6] != (code *)0x0) {
      (*(code *)SystemResourceManager[6])(SystemDataPointer,0,0,ConfigurationFlag,InvalidHandleValue);
    }
    SystemStringPointer = (code *)ConfigurationDataPointer[2];
    if (SystemStringPointer != (code *)0x0) {
      (*SystemStringPointer)(SystemDataPointer,ConfigurationDataPointer,1);
      SystemStringPointer = (code *)ConfigurationDataPointer[2];
    }
    SystemResourceManager[6] = SystemStringPointer;
    SystemResourceManager[7] = ConfigurationDataPointer[3];
  }
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  return SystemResourceManager;
}




/**
 * @brief 初始化系统数据引用
 * 
 * 该函数负责初始化系统数据的引用，设置系统数据指针和内存分配器引用。
 * 主要用于系统数据结构的初始化和配置。
 * 
 * @param SystemResourceManager 系统资源指针，指向系统资源数据结构
 * 
 *FUN_18005c380：InitializeSystemDataReference
 */
void InitializeSystemDataReference(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 0x18) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x20) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x20) = 0;
  *(uint32_t *)(SystemResourceManager + 0x30) = 0;
  *(void* *)(SystemResourceManager + 0x18) = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 清理系统资源指针
 * 
 * 该函数负责清理系统资源指针，重置系统数据引用和内存分配器引用。
 * 主要用于系统资源的清理和释放工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源数据结构
 * 
 *FUN_18005c3d0：CleanupSystemResourceManager
 */
void CleanupSystemResourceManager(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  
  resourceDataIndex = SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  SystemThreadHandle = *SystemResourceManager;
  if (SystemThreadHandle == resourceDataIndex) {
    SystemResourceManager[1] = SystemThreadHandle;
  }
  else {
    do {
      *(void* *)(SystemThreadHandle + 0x18) = &SystemGlobalDataReference;
      if (*(long long *)(SystemThreadHandle + 0x20) != 0) {
          SystemCleanupFunction();
      }
      *(void* *)(SystemThreadHandle + 0x20) = 0;
      *(uint32_t *)(SystemThreadHandle + 0x30) = 0;
      *(void* *)(SystemThreadHandle + 0x18) = &SystemMemoryAllocatorReference;
      SystemThreadHandle = SystemThreadHandle + 0x50;
    } while (SystemThreadHandle != resourceDataIndex);
    SystemResourceManager[1] = *SystemResourceManager;
  }
  return;
}



/**
 * @brief 释放系统资源配置
 * 
 * 该函数负责释放系统资源配置，包括清理内存和调用资源释放函数。
 * 它会根据配置标志决定是否完全释放资源内存。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 返回系统资源指针
 */
long long ReleaseSystemResourceConfiguration(long long SystemResourceManager,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(SystemResourceManager + 0xd0) != (code *)0x0) {
    (**(code **)(SystemResourceManager + 0xd0))(SystemResourceManager + 0xc0,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  ReleaseSystemResources(SystemResourceManager);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xe8);
  }
  return SystemResourceManager;
}




// 函数: void ProcessSystemResourceDataA(long long SystemResourceManager)
/**
 * @brief 系统资源锁定管理器函数
 * 
 * 该函数负责管理系统资源的锁定和解锁操作，包括线程同步和条件变量广播。
 * 它会确保资源在多线程环境下的安全访问，并正确处理同步状态。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源的基本信息和同步对象
 * @note 这是系统资源管理的重要组成部分，用于处理线程同步和资源锁定
 */
void ManageSystemResourceLock(long long SystemResourceManager)

{
  long long synchronizationObject;
  int lockResult;
  
  // 调用系统资源清理回调函数
  (**(code **)(SystemResourceManager + 0xd8))(SystemResourceManager + 0xc0);
  
  // 获取同步对象指针
  synchronizationObject = *(long long *)(SystemResourceManager + 0xe0);
  
  // 锁定互斥量
  lockResult = _Mtx_lock(synchronizationObject + 0x48);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  
  // 设置同步状态标志
  *(uint8_t *)(synchronizationObject + 0x98) = 1;
  
  // 广播条件变量通知等待的线程
  lockResult = _Cnd_broadcast(synchronizationObject);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  
  // 解锁互斥量
  lockResult = _Mtx_unlock(synchronizationObject + 0x48);
  if (lockResult != 0) {
    __Throw_C_error_std__YAXH_Z(lockResult);
  }
  
  return;
}



// 函数: void* *InitializeSystemDataTableManager(void* *SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统数据表管理器函数
 * 
 * 该函数负责初始化系统数据表管理器，设置系统资源指针和配置数据。
 * 它会处理数据表的初始化、配置和回调函数的设置。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针数组，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @return 系统资源指针数组
 * @note 这是系统数据管理的重要组成部分，用于初始化数据表管理器
 */
void* *
InitializeSystemDataTableManager(void* *SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *dataTablePointer;
  code *configurationCallback;
  void* recursiveFlag;
  
  // 设置递归调用标志
  recursiveFlag = 0xfffffffffffffffe;
  
  // 初始化系统数据表管理器（递归调用保护）
  InitializeSystemDataTableManager();
  
  // 设置系统资源指针到默认数据表
  *SystemResourceManager = &SystemGlobalDataTableReference;
  
  // 获取数据表指针
  dataTablePointer = SystemResourceManager + 0x18;
  
  // 初始化回调函数指针和完整性检查
  SystemResourceManager[0x1a] = 0;
  SystemResourceManager[0x1b] = _guard_check_icall;
  
  // 如果数据表指针与配置数据指针不同，则进行配置
  if (dataTablePointer != ConfigurationDataPointer) {
    // 调用现有的回调函数（如果存在）
    if ((code *)SystemResourceManager[0x1a] != (code *)0x0) {
      (*(code *)SystemResourceManager[0x1a])(dataTablePointer,0,0,ConfigurationFlag,recursiveFlag);
    }
    
    // 获取配置回调函数
    configurationCallback = (code *)ConfigurationDataPointer[2];
    if (configurationCallback != (code *)0x0) {
      (*configurationCallback)(dataTablePointer,ConfigurationDataPointer,1);
      configurationCallback = (code *)ConfigurationDataPointer[2];
    }
    
    // 设置回调函数和完整性检查函数
    SystemResourceManager[0x1a] = configurationCallback;
    SystemResourceManager[0x1b] = ConfigurationDataPointer[3];
  }
  
  // 设置额外参数
  SystemResourceManager[0x1c] = AdditionalParameter;
  
  // 调用配置完成回调函数（如果存在）
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  
  return SystemResourceManager;
}





/**
 * 处理系统资源数据
 * 
 * 该函数负责处理系统资源数据，包括数据分配、加密和配置。
 * 主要用于系统资源的管理和处理操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18005c650：ProcessSystemResourceData
 */
void ProcessSystemResourceData(long long* SystemResourceManager)

{
  int SystemOperationStatus;
  long long SystemThreadHandle;
  int NodeIdentifierComparisonResult;
  void* resourceAddress;
  long long *SystemLocalContextPointer;
  code *configurationStringPointer;
  uint8_t SystemMemoryOffset [32];
  long long *SystemMemoryPointer108;
  long long **SystemMemoryManagerPointer100;
  long long SystemStackDataArray [2];
  code *SystemFunctionPointerE8;
  code *SystemFunctionPointerE0;
  void* SystemMemoryAllocatorStatus;
  long long *SystemStackPointer;
  long long *SystemContextPointer;
  long long SystemConditionVariableArray [9];
  long long SystemMutexArray [10];
  uint8_t SystemMaxOperationCount;
  ulong long ConcatenatedValue44;
  
  SystemMemoryAllocatorStatus = 0xfffffffffffffffe;
  ConcatenatedValue44 = SystemEncryptionKeyTemplate ^ (ulong long)SystemMemoryOffset;
  SystemOperationStatus = *(int *)(*(long long *)(*(long long *)(SystemAllocationFlagsTemplate + 8) + 8) + 0x48);
  SystemStackPointer = SystemResourceManager;
  systemCounter = _Thrd_id();
  if (systemCounter == SystemOperationStatus) {
    (*(code *)SystemResourceManager[3])(SystemResourceManager);
  }
  else {
    SystemMemoryPointer108 = SystemConditionVariableArray;
    _Cnd_init_in_situ(SystemConditionVariableArray);
    SystemMemoryPointer108 = SystemMutexArray;
    _Mtx_init_in_situ(SystemMutexArray,2);
    SystemMaxOperationCount = 0;
    resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xe8,8,3);
    SystemMemoryPointer108 = SystemStackDataArray;
    SystemFunctionPointerE8 = (code *)0x0;
    SystemFunctionPointerE0 = _guard_check_icall;
    if (SystemStackDataArray != SystemResourceManager) {
      configurationStringPointer = (code *)SystemResourceManager[2];
      if (configurationStringPointer != (code *)0x0) {
        (*configurationStringPointer)(SystemStackDataArray,SystemResourceManager,1);
        configurationStringPointer = (code *)SystemResourceManager[2];
      }
      SystemFunctionPointerE0 = (code *)SystemResourceManager[3];
      SystemFunctionPointerE8 = configurationStringPointer;
    }
    SystemLocalContextPointer = (long long *)ProcessSystemResourceData(resourceAddress,SystemStackDataArray,SystemConditionVariableArray);
    SystemContextPointer = SystemLocalContextPointer;
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
    }
    SystemThreadHandle = SystemAllocationFlagsTemplate;
    SystemMemoryManagerPointer100 = &SystemMemoryPointer108;
    SystemMemoryPointer108 = SystemLocalContextPointer;
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
    }
    SetupMemoryAllocationContext(SystemThreadHandle,&SystemMemoryPointer108);
    ConfigureSystemResources(SystemConditionVariableArray);
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x38))(SystemLocalContextPointer);
    }
    SystemMemoryManagerPointer100 = (long long **)SystemMutexArray;
    _Mtx_destroy_in_situ(SystemMutexArray);
    SystemMemoryManagerPointer100 = (long long **)SystemConditionVariableArray;
    _Cnd_destroy_in_situ(SystemConditionVariableArray);
  }
  if ((code *)SystemResourceManager[2] != (code *)0x0) {
    (*(code *)SystemResourceManager[2])(SystemResourceManager,0,0);
  }
    ValidateSystemChecksum(ConcatenatedValue44 ^ (ulong long)SystemMemoryOffset);
}





/**
 * @brief 系统资源时间戳生成器函数
 * 
 * 该函数负责生成系统资源的时间戳，用于标识资源的创建时间。
 * 它会检查系统内存块的状态，并根据不同的状态生成不同的时间戳。
 * 
 * @param ResourcePointer 资源指针，用于存储生成的时间戳
 * @note 这是系统资源管理的重要组成部分，用于时间戳生成和资源标识
 */
void GenerateSystemResourceTimestamp(uint *ResourcePointer)

{
  uint currentTimeStamp;
  char SystemOperationStatusFlag;
  
  if (*(void* **)*SystemMemoryBlockStorage == &SystemMemoryBlockTemplatePrimary) {
    SystemOperationStatusFlag = *(int *)(SystemStatusFlags + 0xe0) != 0;
  }
  else {
    SystemOperationStatusFlag = (**(code **)(*(void* **)*SystemMemoryBlockStorage + 0x48))();
  }
  if (SystemOperationStatusFlag != '\0') {
    *ResourcePointer = 0x41c6fe0c;
    return;
  }
  currentTimeStamp = timeGetTime();
  *ResourcePointer = currentTimeStamp ^ 0x41c64e6d;
  return;
}



void* ProcessMemoryManagerOperation(long long SystemResourceManager,void* ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void** SystemHashEntryPointer;
  
  if (*(long long *)(SystemResourceManager + 0xb0) != 0) {
    initializationStatusFlag = (**(code **)(SystemResourceManager + 0xb8))(ConfigurationDataPointer);
    if (initializationStatusFlag == '\0') {
      if (SystemInitializationFlag == '\0') {
        SystemHashEntryPointer = &SystemStringTemplate;
        if (*(void* **)(SystemResourceManager + 0x48) != (void* *)0x0) {
          SystemHashEntryPointer = *(void* **)(SystemResourceManager + 0x48);
        }
        InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,SystemHashEntryPointer);
      }
      ProcessDataManager(SystemResourceManager,SystemResourceManager + 0x80);
      return 0;
    }
  }
  ProcessDataManager(SystemResourceManager,ConfigurationDataPointer);
  return 1;
}





/**
 * @brief 系统资源状态管理器函数
 * 
 * 该函数负责管理系统资源的状态，包括状态的检查、比较和更新。
 * 它会创建系统线程对象，并根据状态值进行相应的资源管理操作。
 * 
 * @param ResourcePointer 资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param StatusPointer 状态指针，指向需要管理的状态值
 * @note 这是系统资源管理的重要组成部分，用于状态管理和资源控制
 */
void ManageSystemResourceStatus(void* *ResourcePointer,void* ConfigurationDataPointer,int *StatusPointer)

{
  int resourceStatus;
  bool statusComparisonResult;
  void* *currentResourceNode;
  long long threadObjectAddress;
  void* *nextResourceNode;
  void* insertionPosition;
  
  threadObjectAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x28,*(uint8_t *)(ResourcePointer + 5));
  resourceStatus = *StatusPointer;
  statusComparisonResult = true;
  *(int *)(threadObjectAddress + 0x20) = resourceStatus;
  nextResourceNode = (void* *)ResourcePointer[2];
  currentResourceNode = ResourcePointer;
  while (nextResourceNode != (void* *)0x0) {
    statusComparisonResult = resourceStatus < *(int *)(nextResourceNode + 4);
    currentResourceNode = nextResourceNode;
    if (resourceStatus < *(int *)(nextResourceNode + 4)) {
      nextResourceNode = (void* *)nextResourceNode[1];
    }
    else {
      nextResourceNode = (void* *)*nextResourceNode;
    }
  }
  nextResourceNode = currentResourceNode;
  if (statusComparisonResult) {
    if (currentResourceNode == (void* *)ResourcePointer[1]) goto ResourceNodeComparison;
    nextResourceNode = (void* *)SystemResourceOffsetGet(currentResourceNode);
  }
  if (*(int *)(threadObjectAddress + 0x20) <= *(int *)(nextResourceNode + 4)) {
      SystemCleanupFunction(threadObjectAddress);
  }
ResourceNodeComparison:
  if ((currentResourceNode == ResourcePointer) || (*(int *)(threadObjectAddress + 0x20) < *(int *)(currentResourceNode + 4))) {
    insertionPosition = 0;
  }
  else {
    insertionPosition = 1;
  }
    ConfigureSystemResourceHandle(threadObjectAddress,currentResourceNode,ResourcePointer,insertionPosition);
}




// 函数: void ProcessNodeManagerOperation(long long SystemResourceManager,uint32_t ConfigurationDataPointer)
void ProcessNodeManagerOperation(long long SystemResourceManager,uint32_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void** SystemHashEntryPointer;
  uint32_t SystemStackParameters [6];
  
  if ((*(long long *)(SystemResourceManager + 0x1f00) != 0) &&
     (SystemStackParameters[0] = ConfigurationDataPointer, initializationStatusFlag = (**(code **)(SystemResourceManager + 0x1f08))(SystemStackParameters),
     ConfigurationDataPointer = SystemStackParameters[0], initializationStatusFlag == '\0')) {
    if (SystemInitializationFlag == '\0') {
      SystemHashEntryPointer = &SystemStringTemplate;
      if (*(void* **)(SystemResourceManager + 0x1eb0) != (void* *)0x0) {
        SystemHashEntryPointer = *(void* **)(SystemResourceManager + 0x1eb0);
      }
      InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,SystemHashEntryPointer);
    }
    *(uint32_t *)(SystemResourceManager + 0x1ea0) = *(uint32_t *)(SystemResourceManager + 0x1ee8);
    return;
  }
  *(uint32_t *)(SystemResourceManager + 0x1ea0) = ConfigurationDataPointer;
  return;
}



/**
 * @brief 系统资源配置器
 * 
 * 该函数负责配置系统资源，设置内存分配器引用和全局数据引用。
 * 它会从配置数据中提取参数并应用到系统资源结构中，同时清理配置数据。
 * 
 * @param SystemResourceManager 系统资源指针，需要配置的资源
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @return 配置后的系统资源指针
 * 
 *FUN_18005caa0：ConfigureSystemResources
 */
void* * ConfigureSystemResources(void* *SystemResourceManager,long long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = &SystemGlobalDataReference;
  SystemResourceManager[3] = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *(uint32_t *)(SystemResourceManager + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemResourceManager[1] = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)((long long)SystemResourceManager + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(SystemResourceManager + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 6) = 0;
  SystemResourceManager[4] = &SystemGlobalDataReference;
  SystemResourceManager[7] = 0;
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 6) = 0;
  *(uint32_t *)(SystemResourceManager + 6) = *(uint32_t *)(ConfigurationDataPointer + 0x30);
  SystemResourceManager[5] = *(void* *)(ConfigurationDataPointer + 0x28);
  *(uint32_t *)((long long)SystemResourceManager + 0x3c) = *(uint32_t *)(ConfigurationDataPointer + 0x3c);
  *(uint32_t *)(SystemResourceManager + 7) = *(uint32_t *)(ConfigurationDataPointer + 0x38);
  *(uint32_t *)(ConfigurationDataPointer + 0x30) = 0;
  *(void* *)(ConfigurationDataPointer + 0x28) = 0;
  *(void* *)(ConfigurationDataPointer + 0x38) = 0;
  return SystemResourceManager;
}



/**
 * @brief 重置系统资源数据结构
 * 
 * 该函数负责重置系统资源数据结构，清理全局数据引用并重置相关字段。
 * 它会检查系统资源状态，并在必要时调用清理函数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 返回重置后的系统资源指针
 */
long long ResetSystemResourceDataStructure(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 0x40) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x48) = 0;
  *(uint32_t *)(SystemResourceManager + 0x58) = 0;
  *(void* *)(SystemResourceManager + 0x40) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x28) = 0;
  *(uint32_t *)(SystemResourceManager + 0x38) = 0;
  *(void* *)(SystemResourceManager + 0x20) = &SystemMemoryAllocatorReference;
  return SystemResourceManager;
}





/**
 * @brief 系统资源分配配置器函数
 * 
 * 该函数负责配置系统资源的分配，包括资源的创建、分配和配置。
 * 它会处理系统数据管理器指针，并根据配置标志进行相应的资源分配操作。
 * 
 * @param ResourcePointer 资源指针，包含资源的基本信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统的配置信息
 * @param AdditionalParameter 额外参数，用于指定分配操作
 * @param ConfigurationFlag 配置标志，用于控制分配行为
 * @note 这是系统资源管理的重要组成部分，用于资源分配和配置
 */
void ConfigureSystemResourceAllocation(void* **ResourcePointer,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  byte comparisonByte1;
  uint comparisonValue2;
  long long dataManagerOffset;
  void* **allocatedResourcePointer;
  byte *resourceDataPointer;
  void* **systemDataManagerPointer;
  long long dataOffset;
  void* allocationResult;
  void* **resourceReference;
  char configurationFlagBuffer [8];
  uint32_t SystemAllocationFlags;
  void* *configurationDataObject;
  long long stackOffset60;
  void* *additionalParameterObject;
  long long stackOffset40;
  uint32_t stackOffset30;
  
  dataManagerOffset = SystemDataManagerPointer;
  configurationFlagBuffer[0] = (char)ConfigurationFlag;
  allocationResult = 0;
  systemDataManagerPointer = (void* **)(SystemDataManagerPointer + 0x70);
  resourceReference = ResourcePointer;
  FindSystemResourceNode(systemDataManagerPointer,&resourceReference,ConfigurationDataPointer,ConfigurationFlag,0,InvalidHandleValue);
  if (resourceReference != systemDataManagerPointer) {
    ProcessDataManager(resourceReference + 8,AdditionalParameter);
    return;
  }
  CreateSystemObject(&configurationDataObject,ConfigurationDataPointer);
  CreateSystemObject(&additionalParameterObject,AdditionalParameter);
  SystemAllocationFlags = 1;
  dataManagerOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x60,*(uint8_t *)(dataManagerOffset + 0x98));
  ConfigureSystemResourceMemoryAllocator(dataManagerOffset + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,&configurationDataObject);
  allocatedResourcePointer = (void* **)SystemResourceAllocator(systemDataManagerPointer,configurationFlagBuffer,dataManagerOffset + 0x20);
  if (configurationFlagBuffer[0] == '\0') {
    ValidateSystemResourceConfiguration(dataManagerOffset);
    if (dataManagerOffset != 0) {
        SystemCleanupFunction(dataManagerOffset);
    }
    resourceReference = &additionalParameterObject;
    additionalParameterObject = &SystemGlobalDataReference;
    if (stackOffset40 == 0) {
      stackOffset40 = 0;
      stackOffset30 = 0;
      additionalParameterObject = &SystemMemoryAllocatorReference;
      resourceReference = &configurationDataObject;
      configurationDataObject = &SystemGlobalDataReference;
      if (stackOffset60 == 0) {
        return;
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  if (allocatedResourcePointer == systemDataManagerPointer) goto DataManagerCheck;
  if (*(int *)(allocatedResourcePointer + 6) != 0) {
    if (*(int *)(dataManagerOffset + 0x30) == 0) goto DataManagerCheck;
    resourceDataPointer = allocatedResourcePointer[5];
    dataOffset = *(long long *)(dataManagerOffset + 0x28) - (long long)resourceDataPointer;
    do {
      comparisonByte1 = *resourceDataPointer;
      comparisonValue2 = (uint)resourceDataPointer[dataOffset];
      if (comparisonByte1 != comparisonValue2) break;
      resourceDataPointer = resourceDataPointer + 1;
    } while (comparisonValue2 != 0);
    if (0 < (int)(comparisonByte1 - comparisonValue2)) goto DataManagerCheck;
  }
  allocationResult = 1;
DataManagerCheck:
    ConfigureSystemResourceHandle(dataManagerOffset,allocatedResourcePointer,systemDataManagerPointer,allocationResult,SystemAllocationFlags);
}



/**
 * @brief 系统资源内存分配器配置器
 * 
 * 该函数负责配置系统资源的内存分配器，设置内存模板引用和分配器引用。
 * 它会根据配置标志决定是否释放资源内存，并设置标准的内存模板。
 * 
 * @param SystemResourceManager 系统资源指针，需要配置的资源
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，用于扩展配置
 * @param ConfigurationFlag 配置标志，控制配置行为
 * @return 配置后的系统资源指针
 * 
 *FUN_18005cdb0：ConfigureSystemResourceMemoryAllocator
 */
void* *
ConfigureSystemResourceMemoryAllocator(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  SystemResourceManager[4] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemMemoryTemplateC;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x100,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}



void* * InitializeResourceContext(void* *SystemResourceManager,void* *ConfigurationDataPointer)

{
  void** SystemDataPointer;
  void* resourceCreationFlags;
  
  *SystemResourceManager = &SystemMemoryTemplateA;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *SystemResourceManager = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(SystemResourceManager + 2) = 0;
  UNLOCK();
  SystemResourceManager[3] = 0xffffffffffffffff;
  *SystemResourceManager = &SystemFunctionPointerTableA;
  SystemDataPointer = SystemResourceManager + 4;
  *SystemDataPointer = &SystemMemoryAllocatorReference;
  SystemResourceManager[5] = 0;
  *(uint32_t *)(SystemResourceManager + 6) = 0;
  *SystemDataPointer = &SystemResourceTemplatePrimary;
  SystemResourceManager[5] = SystemResourceManager + 7;
  *(uint32_t *)(SystemResourceManager + 6) = 0;
  *(uint8_t *)(SystemResourceManager + 7) = 0;
  resourceCreationFlags = ConfigurationDataPointer[1];
  *SystemDataPointer = *ConfigurationDataPointer;
  SystemResourceManager[5] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[3];
  SystemResourceManager[6] = ConfigurationDataPointer[2];
  SystemResourceManager[7] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[5];
  SystemResourceManager[8] = ConfigurationDataPointer[4];
  SystemResourceManager[9] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[7];
  SystemResourceManager[10] = ConfigurationDataPointer[6];
  SystemResourceManager[0xb] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[9];
  SystemResourceManager[0xc] = ConfigurationDataPointer[8];
  SystemResourceManager[0xd] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0xb];
  SystemResourceManager[0xe] = ConfigurationDataPointer[10];
  SystemResourceManager[0xf] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0xd];
  SystemResourceManager[0x10] = ConfigurationDataPointer[0xc];
  SystemResourceManager[0x11] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0xf];
  SystemResourceManager[0x12] = ConfigurationDataPointer[0xe];
  SystemResourceManager[0x13] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0x11];
  SystemResourceManager[0x14] = ConfigurationDataPointer[0x10];
  SystemResourceManager[0x15] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0x13];
  SystemResourceManager[0x16] = ConfigurationDataPointer[0x12];
  SystemResourceManager[0x17] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0x15];
  SystemResourceManager[0x18] = ConfigurationDataPointer[0x14];
  SystemResourceManager[0x19] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0x17];
  SystemResourceManager[0x1a] = ConfigurationDataPointer[0x16];
  SystemResourceManager[0x1b] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0x19];
  SystemResourceManager[0x1c] = ConfigurationDataPointer[0x18];
  SystemResourceManager[0x1d] = resourceCreationFlags;
  resourceCreationFlags = ConfigurationDataPointer[0x1b];
  SystemResourceManager[0x1e] = ConfigurationDataPointer[0x1a];
  SystemResourceManager[0x1f] = resourceCreationFlags;
  *(uint32_t *)(SystemResourceManager + 0x17) = *(uint32_t *)(ConfigurationDataPointer + 0x13);
  return SystemResourceManager;
}



/**
 * @brief 系统资源状态获取器
 * 
 * 该函数负责获取系统资源的状态信息，使用互斥锁确保线程安全。
 * 它会锁定系统资源，获取状态值，然后解锁资源，确保操作的原子性。
 * 
 * @param SystemResourceManager 系统资源指针，包含互斥锁和状态信息
 * @return 系统资源状态值
 * 
 *FUN_18005cf50：GetSystemResourceStatus
 */
uint32_t GetSystemResourceStatus(long long SystemResourceManager)

{
  int SystemOperationStatus;
  uint32_t resourceCreationFlags;
  
  SystemOperationStatus = _Mtx_lock(SystemResourceManager + 0x9f0);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  resourceCreationFlags = CheckSystemInputManagerStatus();
  SystemOperationStatus = _Mtx_unlock(SystemResourceManager + 0x9f0);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  return resourceCreationFlags;
}




/**
 * @brief 系统输入管理器状态检查器
 * 
 * 该函数负责检查系统输入管理器的状态，通过多个互斥锁确保线程安全。
 * 它会检查输入管理器的不同部分，获取各个状态值并返回综合结果。
 * 
 * @return 系统输入管理器的综合状态值
 * 
 *FUN_18005cfc0：CheckSystemInputManagerStatus
 */
int CheckSystemInputManagerStatus(void)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  int NodeIdentifierComparisonResult;
  int systemIndex;
  int systemValue;
  int CalculationFlags;
  int systemOffset;
  
  SystemThreadHandle = SystemInputManagerPointer;
  resourceDataIndex = SystemInputManagerPointer + 0x770;
  systemCounter = _Mtx_lock(resourceDataIndex);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  systemCounter = CheckSystemInputManagerStatus();
  systemIndex = _Mtx_unlock(resourceDataIndex);
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  systemIndex = _Mtx_lock(SystemThreadHandle + 0x7c0);
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  systemIndex = CheckSystemInputManagerStatus();
  systemValue = _Mtx_unlock(SystemThreadHandle + 0x7c0);
  if (systemValue != 0) {
    __Throw_C_error_std__YAXH_Z(systemValue);
  }
  systemValue = GetSystemResourceStatus(SystemThreadHandle);
  CalculationFlags = _Mtx_lock(SystemThreadHandle + 0x950);
  if (CalculationFlags != 0) {
    __Throw_C_error_std__YAXH_Z(CalculationFlags);
  }
  CalculationFlags = CheckSystemInputManagerStatus();
  systemOffset = _Mtx_unlock(SystemThreadHandle + 0x950);
  if (systemOffset != 0) {
    __Throw_C_error_std__YAXH_Z(systemOffset);
  }
  return CalculationFlags + systemIndex + systemCounter + systemValue;
}





/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，设置资源参数和配置选项
 * 用于系统资源管理的前期准备工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_18005d0e0：InitializeSystemResources
 */
void InitializeSystemResources(ulong long SystemResourceManager,long long ConfigurationDataPointer)

{
  char SystemNodeStatusFlag;
  uint SystemConfigurationValue;
  ulong long SystemResourceHandle;
  ulong long *SystemResourceHandlePointer;
  long long SystemTimestamp;
  long long LocalSystemFlags;
  int SystemMemoryOffset;
  int SystemErrorCode;
  float SystemFloatValue1;
  float SystemFloatValue2;
  double SystemDoubleValue;
  ulong long SystemUlongValue;
  uint8_t SystemBuffer1 [32];
  void* SystemPointer1;
  double *SystemDoublePointer;
  char SystemMainBuffer [1024];
  ulong long SystemContextValue;
  void* SystemResourceStatusFlag;
  void* LocalSystemPointer;
  
  SystemMemoryOffset = -1;
  SystemErrorCode = -1;
  SystemConfigurationValue = (uint)SystemResourceManager;
  SystemResourceHandle = SystemResourceManager & MAX_UNSIGNED_32_BIT;
  while (SystemConfigurationValue != 0) {
    SystemErrorCode = SystemErrorCode + 1;
    SystemConfigurationValue = (uint)SystemResourceHandle >> 1;
    SystemResourceHandle = (ulong long)SystemConfigurationValue;
  }
  SystemConfigurationValue = 0x400;
  do {
    SystemMemoryOffset = SystemMemoryOffset + 1;
    SystemConfigurationValue = SystemConfigurationValue >> 1;
  } while (SystemConfigurationValue != 0);
  SystemNodeStatusFlag = (&SystemFormatDataArray)[SystemErrorCode / SystemMemoryOffset];
  SystemPointer1 = 0x18005d147;
  SystemFloatValue1 = (float)powf(0x44800000);
  SystemFloatValue2 = (float)(long long)SystemResourceManager;
  if ((long long)SystemResourceManager < 0) {
    SystemFloatValue2 = SystemFloatValue2 + 1.8446744e+19;
  }
  SystemUlongValue = (ulong long)(uint)(int)SystemNodeStatusFlag;
  SystemDoubleValue = (double)(SystemFloatValue1 * SystemFloatValue2);
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)SystemBuffer1;
  SystemResourceHandlePointer = (ulong long *)SystemGlobalDataAllocate();
  LocalSystemPointer = 0;
  SystemPointer1 = 0;
  SystemDoublePointer = &SystemDoubleValue;
  SystemErrorCode = __stdio_common_vsprintf(*SystemResourceHandlePointer | 1,0,0,&SystemFormatString);
  if (SystemErrorCode < 0) {
    SystemErrorCode = -1;
  }
  if (SystemErrorCode < 0x400) {
    SystemPointer1 = 0;
    SystemDoublePointer = &SystemDoubleValue;
    __stdio_common_vsprintf(*SystemResourceHandlePointer | 1,SystemMainBuffer,0x400,&SystemFormatString);
    LocalSystemPointer = -1;
    do {
      LocalSystemFlags = LocalSystemPointer;
      LocalSystemPointer = LocalSystemFlags + 1;
    } while (SystemMainBuffer[LocalSystemFlags + 1] != '\0');
    SystemErrorCode = (int)(LocalSystemFlags + 1);
    if (0 < SystemErrorCode) {
      ExecuteSystemCommand(ConfigurationDataPointer,*(int *)(ConfigurationDataPointer + 0x10) + SystemErrorCode);
        memcpy((ulong long)*(uint *)(ConfigurationDataPointer + 0x10) + *(long long *)(ComparisonDataPointer + 8),SystemMainBuffer,
             (long long)((int)LocalSystemFlags + 2));
    }
  }
  else {
    systemCode = systemCode + 1;
    if (systemCode != 0) {
      localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCode,3);
    }
    FormatSystemResourceOutput(localSystemPointer,(long long)systemCode,&SystemFormatString,&dStackX_18);
    SearchSystemResourceString(ConfigurationDataPointer,localSystemPointer);
    if (localSystemPointer != 0) {
        SystemCleanupFunction(localSystemPointer);
    }
  }
    ValidateSystemChecksum(SystemContextValue ^ (ulong long)aconfigurationFlags478);
}



/**
 * @brief 传输系统资源配置数据
 * 
 * 该函数负责传输系统资源配置数据，将配置数据从一个资源复制到另一个资源。
 * 它会清理源资源配置，并将目标配置数据复制到源资源中。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 返回系统资源指针
 */
long long TransferSystemResourceConfigurationData(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  if (*(long long *)(SystemResourceManager + 8) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  *(void* *)(SystemResourceManager + 8) = 0;
  *(uint32_t *)(targetBuffer + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x10) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  *(void* *)(SystemResourceManager + 8) = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)(SystemResourceManager + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(SystemResourceManager + 0x18) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  return SystemResourceManager;
}




/**
 * @brief 处理额外输出资源
 * 
 * 该函数负责处理系统中的额外输出资源，包括资源初始化、
 * 内存分配和状态设置。用于系统资源管理的辅助操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，通常为缓冲区指针
 * @note 这是资源管理系统的辅助处理函数
 */
void ProcessExtraOutputResource(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(ConfigurationDataPointer + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(ConfigurationDataPointer + 0x28) = 0;
  *(uint32_t *)(ConfigurationDataPointer + 0x38) = 0;
  *(void* *)(ConfigurationDataPointer + 0x20) = &SystemMemoryAllocatorReference;
  if (ConfigurationDataPointer != 0) {
      SystemCleanupFunction(ConfigurationDataPointer);
  }
  return;
}




/**
 * @brief 处理系统资源配置
 * 
 * 该函数负责处理系统资源的配置操作，包括递归处理配置数据、
 * 设置全局数据引用和内存分配器引用。这是系统资源管理的核心函数。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数会递归调用自身处理配置数据
 * @warning 此函数包含不返回的子程序调用，可能导致程序终止
 * 
 *FUN_18005d260：ProcessSystemResourceConfiguration
 */
void ProcessSystemResourceConfiguration(void* SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (ConfigurationDataPointer == (void* *)0x0) {
    return;
  }
  ProcessSystemResourceConfiguration(SystemResourceManager,*ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  ConfigurationDataPointer[4] = &SystemGlobalDataReference;
  if (ConfigurationDataPointer[5] != 0) {
      SystemCleanupFunction();
  }
  ConfigurationDataPointer[5] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 7) = 0;
  ConfigurationDataPointer[4] = &SystemMemoryAllocatorReference;
    SystemCleanupFunction(ConfigurationDataPointer);
}




/**
 * @brief 处理系统资源配置包装函数
 * 
 * 该函数是ProcessSystemResourceConfiguration的包装函数，用于处理系统资源指针
 * 偏移位置的配置数据。简化了配置数据的访问和传递。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数内部调用ProcessSystemResourceConfiguration处理配置数据
 * 
 *FUN_18005d310：ProcessSystemResourceConfigurationWrapper
 */
void ProcessSystemResourceConfigurationWrapper(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceConfiguration(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 处理系统资源配置包装函数B
 * 
 * 该函数是ProcessSystemResourceConfiguration的第二个包装函数，功能与第一个包装函数相同，
 * 用于处理系统资源指针偏移位置的配置数据。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数内部调用ProcessSystemResourceConfiguration处理配置数据
 * 
 *FUN_18005d330：ProcessSystemResourceConfigurationWrapperB
 */
void ProcessSystemResourceConfigurationWrapperB(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceConfiguration(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 处理系统资源配置包装函数C
 * 
 * 该函数是ProcessSystemResourceConfiguration的第三个包装函数，功能与前两个包装函数相同，
 * 用于处理系统资源指针偏移位置的配置数据。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @note 此函数内部调用ProcessSystemResourceConfiguration处理配置数据
 * 
 *FUN_18005d360：ProcessSystemResourceConfigurationWrapperC
 */
void ProcessSystemResourceConfigurationWrapperC(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ProcessSystemResourceConfiguration(SystemResourceManager,*(void* *)(SystemResourceManager + 0x10),AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  return;
}




/**
 * @brief 系统资源格式化输出函数
 * 
 * 该函数负责格式化输出系统资源信息，使用标准输出流打印资源相关的调试信息。
 * 它会分配全局数据缓冲区，并通过格式化字符串输出系统状态。
 * 
 * @param SystemResourceManager 系统资源指针，包含格式化字符串
 * @param ConfigurationDataPointer 配置数据指针，用于格式化参数
 * @param AdditionalParameter 额外参数，用于格式化参数
 * @param ConfigurationFlag 配置标志，用于格式化参数
 * @note 此函数使用标准输出流进行格式化输出
 * 
 *FUN_18005d3a0：FormatSystemResourceOutput
 */
void FormatSystemResourceOutput(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* standardOutputHandle;
  void** globalDataBuffer;
  void* formatParameter1;
  uint64_t SystemInitializationFlag;
  void* formatParameter3;
  
  formatParameter1 = ConfigurationDataPointer;
  formatParameter2 = AdditionalParameter;
  formatParameter3 = ConfigurationFlag;
  standardOutputHandle = __acrt_iob_func(1);
  globalDataBuffer = (void* *)SystemGlobalDataAllocate();
  __stdio_common_vfprintf(*globalDataBuffer,standardOutputHandle,SystemResourceManager,0,&formatParameter1);
  return;
}



/**
 * @brief 系统资源字符串搜索函数
 * 
 * 该函数负责在系统资源中搜索指定的字符串。它会遍历资源表，
 * 比较字符串长度和内容，返回匹配的资源指针。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源表信息
 * @param ConfigurationDataPointer 要搜索的字符串指针
 * @return 匹配的资源指针，如果未找到则返回NULL
 * @note 此函数使用字符串长度和内容比较进行精确匹配
 * 
 *FUN_18005d400：SearchSystemResourceString
 */
void* * SearchSystemResourceString(long long SystemResourceManager,char *ConfigurationDataPointer)

{
  char *stringEndPointer;
  char currentChar;
  void* *resourceTablePointer;
  char *resourceString;
  long long stringLength;
  char *searchString;
  
  if (ConfigurationDataPointer == (char *)0x0) {
    return *(void* **)(SystemResourceManager + 0x58);
  }
  currentChar = *ConfigurationDataPointer;
  searchString = ConfigurationDataPointer;
  while (currentChar != '\0') {
    searchString = searchString + 1;
    currentChar = *searchString;
  }
  resourceTablePointer = *(void* **)(SystemResourceManager + 0x58);
  do {
    if (resourceTablePointer == (void* *)0x0) {
      return (void* *)0x0;
    }
    resourceString = (char *)*resourceTablePointer;
    if (resourceString == (char *)0x0) {
      stringLength = 0;
      resourceString = (char *)0x180d48d24;
    }
    else {
      stringLength = resourceTablePointer[2];
    }
    if (stringLength == (long long)searchString - (long long)ConfigurationDataPointer) {
      stringEndPointer = resourceString + stringLength;
      if (stringEndPointer <= resourceString) {
        return resourceTablePointer;
      }
      stringLength = (long long)ConfigurationDataPointer - (long long)resourceString;
      while (*resourceString == resourceString[stringLength]) {
        resourceString = resourceString + 1;
        if (stringEndPointer <= resourceString) {
          return resourceTablePointer;
        }
      }
    }
    resourceTablePointer = (void* *)resourceTablePointer[0xb];
  } while( true );
}



/**
 * @brief 系统资源字符串比较搜索函数
 * 
 * 该函数负责在系统资源中搜索并比较字符串。它会遍历配置数据指针链表，
 * 比较字符串长度和内容，返回匹配的配置数据指针。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针链表
 * @return 匹配的配置数据指针，如果未找到则返回NULL
 * @note 此函数使用字符串长度和内容比较进行精确匹配
 * 
 *FUN_18005d430：SearchAndCompareSystemResourceString
 */
void* * SearchAndCompareSystemResourceString(void* SystemResourceManager,void* *ConfigurationDataPointer)

{
  char *stringEndPointer;
  char *resourceString;
  long long stringLength;
  long long searchStringLength;
  long long stringOffset;
  
  if (ConfigurationDataPointer != (void* *)0x0) {
    do {
      resourceString = (char *)*ConfigurationDataPointer;
      if (resourceString == (char *)0x0) {
        stringLength = 0;
        resourceString = (char *)0x180d48d24;
      }
      else {
        stringLength = ConfigurationDataPointer[2];
      }
      if (stringLength == searchStringLength) {
        stringEndPointer = resourceString + stringLength;
        if (stringEndPointer <= resourceString) {
          return ConfigurationDataPointer;
        }
        stringOffset = stringOffset - (long long)resourceString;
        while (*resourceString == resourceString[stringOffset]) {
          resourceString = resourceString + 1;
          if (stringEndPointer <= resourceString) {
            return ConfigurationDataPointer;
          }
        }
      }
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
    } while (ConfigurationDataPointer != (void* *)0x0);
  }
  return (void* *)0x0;
}



/**
 * @brief 系统资源数据指针查找函数
 * 
 * 该函数负责在系统资源中查找和匹配数据指针，通过遍历配置数据指针
 * 来定位所需的资源数据。该函数包含内存块操作和指针比较逻辑。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 匹配的数据指针，如果未找到则返回NULL
 * 
 *FUN_18005d484：FindSystemResourceDataPointer
 */
void* * FindSystemResourceDataPointer(void* SystemResourceManager,void* *ConfigurationDataPointer)

{
  char *memoryBlockPointer1;
  char *memoryBlockPointer2;
  char *memoryBlockAddress;
  long long ResourceDataOffset;
  long long targetOffset;
  long long comparisonOffset;
  
  while( true ) {
    do {
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
      if (ConfigurationDataPointer == (void* *)0x0) {
        return (void* *)0x0;
      }
      if ((char *)*ConfigurationDataPointer == (char *)0x0) {
        ResourceDataOffset = 0;
        memoryBlockPointer2 = memoryBlockAddress;
      }
      else {
        ResourceDataOffset = ConfigurationDataPointer[2];
        memoryBlockPointer2 = (char *)*ConfigurationDataPointer;
      }
    } while (ResourceDataOffset != targetOffset);
    memoryBlockPointer1 = memoryBlockPointer2 + ResourceDataOffset;
    if (memoryBlockPointer1 <= memoryBlockPointer2) break;
    ResourceDataOffset = comparisonOffset - (long long)memoryBlockPointer2;
    while (*memoryBlockPointer2 == memoryBlockPointer2[ResourceDataOffset]) {
      memoryBlockPointer2 = memoryBlockPointer2 + 1;
      if (memoryBlockPointer1 <= memoryBlockPointer2) {
        return ConfigurationDataPointer;
      }
    }
  }
  return ConfigurationDataPointer;
}



/**
 * @brief 获取系统资源数据指针
 * 
 * 该函数从系统资源指针的指定偏移量处获取数据指针
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 数据指针
 * 
 *FUN_18005d498：GetSystemResourceDataPointer
 */
void* GetSystemResourceDataPointer(long long SystemResourceManager)

{
  return *(void* *)(SystemResourceManager + 0x58);
}



/**
 * @brief 查找系统资源字符串匹配
 * 
 * 该函数在系统资源中查找与指定配置数据字符串匹配的资源
 * 支持字符串长度计算和比较操作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据字符串指针
 * @param AdditionalParameter 额外参数（字符串长度）
 * @return 匹配的资源指针，未找到返回NULL
 * 
 *FUN_18005d4b0：FindSystemResourceStringMatch
 */
void* * FindSystemResourceStringMatch(long long SystemResourceManager,char *ConfigurationDataPointer,long long AdditionalParameter)

{
  char *stringEndPointer;
  char currentChar;
  void* *resourcePointer;
  char *resourceString;
  long long stringLength;
  
  if (ConfigurationDataPointer == (char *)0x0) {
    return *(void* **)(SystemResourceManager + 0x30);
  }
  if (AdditionalParameter == 0) {
    currentChar = *ConfigurationDataPointer;
    resourceString = ConfigurationDataPointer;
    while (currentChar != '\0') {
      resourceString = resourceString + 1;
      currentChar = *resourceString;
    }
    AdditionalParameter = (long long)resourceString - (long long)ConfigurationDataPointer;
  }
  resourcePointer = *(void* **)(SystemResourceManager + 0x30);
  do {
    if (resourcePointer == (void* *)0x0) {
      return (void* *)0x0;
    }
    resourceString = (char *)*resourcePointer;
    if (resourceString == (char *)0x0) {
      stringLength = 0;
      resourceString = (char *)0x180d48d24;
    }
    else {
      stringLength = resourcePointer[2];
    }
    if (stringLength == AdditionalParameter) {
      stringEndPointer = resourceString + stringLength;
      if (stringEndPointer <= resourceString) {
        return resourcePointer;
      }
      stringLength = (long long)ConfigurationDataPointer - (long long)resourceString;
      while (*resourceString == resourceString[stringLength]) {
        resourceString = resourceString + 1;
        if (stringEndPointer <= resourceString) {
          return resourcePointer;
        }
      }
    }
    resourcePointer = (void* *)resourcePointer[0xb];
  } while( true );
}



/**
 * @brief 在配置数据中查找匹配的资源
 * 
 * 该函数在配置数据指针链表中查找与指定参数匹配的资源
 * 支持字符串比较和资源匹配操作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（用于匹配）
 * @return 匹配的配置数据指针，未找到返回NULL
 * 
 *FUN_18005d4e0：FindMatchingConfigurationResource
 */
void* * FindMatchingConfigurationResource(void* SystemResourceManager,void* *ConfigurationDataPointer,long long AdditionalParameter)

{
  char *stringEndPointer;
  char *configString;
  long long configLength;
  long long systemResourceValue;
  
  if (ConfigurationDataPointer != (void* *)0x0) {
    do {
      configString = (char *)*ConfigurationDataPointer;
      if (configString == (char *)0x0) {
        configLength = 0;
        configString = (char *)0x180d48d24;
      }
      else {
        configLength = ConfigurationDataPointer[2];
      }
      if (configLength == AdditionalParameter) {
        stringEndPointer = configString + configLength;
        if (stringEndPointer <= configString) {
          return ConfigurationDataPointer;
        }
        configLength = systemResourceValue - (long long)configString;
        while (*configString == configString[configLength]) {
          configString = configString + 1;
          if (stringEndPointer <= configString) {
            return ConfigurationDataPointer;
          }
        }
      }
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
    } while (ConfigurationDataPointer != (void* *)0x0);
  }
  return (void* *)0x0;
}



/**
 * @brief 查找配置数据中的匹配资源
 * 
 * 该函数在配置数据指针链表中查找与指定参数匹配的资源
 * 通过遍历链表和字符串比较来实现资源匹配
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（用于匹配）
 * @return 匹配的配置数据指针，未找到返回NULL
 * 
 *FUN_18005d534：FindMatchingConfigurationDataResource
 */
void* * FindMatchingConfigurationDataResource(void* SystemResourceManager,void* *ConfigurationDataPointer,long long AdditionalParameter)

{
  char *stringEndPointer;
  char *configString;
  char *memoryBlockAddress;
  long long configLength;
  long long systemResourceValue;
  
  while( true ) {
    do {
      ConfigurationDataPointer = (void* *)ConfigurationDataPointer[0xb];
      if (ConfigurationDataPointer == (void* *)0x0) {
        return (void* *)0x0;
      }
      if ((char *)*ConfigurationDataPointer == (char *)0x0) {
        configLength = 0;
        configString = memoryBlockAddress;
      }
      else {
        configLength = ConfigurationDataPointer[2];
        configString = (char *)*ConfigurationDataPointer;
      }
    } while (configLength != AdditionalParameter);
    stringEndPointer = configString + configLength;
    if (stringEndPointer <= configString) break;
    configLength = systemResourceValue - (long long)configString;
    while (*configString == configString[configLength]) {
      configString = configString + 1;
      if (stringEndPointer <= configString) {
        return ConfigurationDataPointer;
      }
    }
  }
  return ConfigurationDataPointer;
}



/**
 * @brief 获取系统资源配置指针
 * 
 * 该函数从系统资源指针的指定偏移量处获取配置指针
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 配置指针
 * 
 *FUN_18005d548：GetSystemResourceConfigurationPointer
 */
void* GetSystemResourceConfigurationPointer(long long SystemResourceManager)

{
  return *(void* *)(SystemResourceManager + 0x30);
}




/**
 * @brief 执行系统资源迭代器操作
 * 
 * 该函数负责遍历系统资源数组，对每个资源执行指定的操作
 * 通过迭代器模式处理系统资源集合中的每个元素
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * @note 此函数会遍历整个资源数组并执行操作
 * @warning 如果系统资源指针为空，函数会直接返回
 */
void ExecuteSystemResourceIterator(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *resourceIteratorEnd;
  void** systemDataTable;
  void* operationFlags;
  
  operationFlags = 0xfffffffffffffffe;
  resourceIteratorEnd = (void* *)SystemResourceManager[1];
  for (resourceIterator = (void* *)*SystemResourceManager; resourceIterator != resourceIteratorEnd; resourceIterator = resourceIterator + 4) {
    (**(code **)*resourceIterator)(resourceIterator,0,AdditionalParameter,ConfigurationFlag,operationFlags);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void CleanupSystemMemoryAllocation(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void CleanupSystemMemoryAllocation(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 4) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}



/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置虚拟表和处理器
 * 根据配置标志决定是否释放系统资源
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return void* 返回系统资源指针
 * @note 此函数会设置系统虚拟表并初始化资源处理器
 * @warning 如果配置标志第一位为1，会释放系统资源
 */
void* *
InitializeSystemResourceManager(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* operationFlags;
  
  operationFlags = 0xfffffffffffffffe;
  *SystemResourceManager = &SystemVirtualTableTemplateB;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xc0,AdditionalParameter,ConfigurationFlag,operationFlags);
  }
  return SystemResourceManager;
}



/**
 * @brief 初始化系统同步对象
 * 
 * 该函数负责初始化系统同步对象，包括信号量和各种句柄
 * 设置系统资源的基本配置和同步机制
 * 
 * @param SystemResourceManager 系统资源指针
 * @return uint8_t* 返回系统资源指针
 * @note 此函数会创建信号量并初始化系统同步机制
 * @warning 函数会关闭现有的系统句柄并重新初始化
 */
uint8_t * InitializeSystemSynchronizationObjects(uint8_t *SystemResourceManager)

{
  void* semaphoreHandle;
  
  *(void* *)(SystemResourceManager + 8) = 0;
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(void* *)(SystemResourceManager + 0x18) = 0;
  *(uint32_t *)(SystemResourceManager + 0x20) = 3;
  *(void* *)(SystemResourceManager + 0x28) = 0;
  *(void* *)(SystemResourceManager + 0x30) = 0;
  *(void* *)(SystemResourceManager + 0x38) = 0;
  *(uint32_t *)(SystemResourceManager + 0x40) = 3;
  *(void* *)(SystemResourceManager + 0x48) = 0;
  *(void* *)(SystemResourceManager + 0x50) = 0;
  *(void* *)(SystemResourceManager + 0x58) = 0;
  *(uint32_t *)(SystemResourceManager + 0x60) = 3;
  semaphoreHandle = CreateSemaphoreW(0,0,0x7fffffff,0,InvalidHandleValue);
  *(void* *)(SystemResourceManager + 0x68) = semaphoreHandle;
  semaphoreHandle = CreateSemaphoreW(0,0,0x7fffffff,0);
  *(void* *)(SystemResourceManager + 0x70) = semaphoreHandle;
  CloseSystemHandle(SystemResourceManager + 0x78);
  CloseSystemHandle(SystemResourceManager + 0x2e0);
  CloseSystemHandle(SystemResourceManager + 0x548);
  *(uint32_t *)(SystemResourceManager + 0x7b0) = 0;
  *(uint32_t *)(SystemResourceManager + 0x7b4) = 0x1000;
  *SystemResourceManager = 0;
  return SystemResourceManager;
}




/**
 * @brief 关闭系统句柄
 * 
 * 该函数负责关闭系统句柄，释放相关资源
 * 确保系统资源被正确清理
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 无返回值
 * @note 此函数会调用系统API关闭句柄
 * @warning 关闭后的句柄将不再有效
 */
void CloseSystemHandle(void* *SystemResourceManager)

{
  CloseHandle(*SystemResourceManager);
  return;
}





// 函数: void InitializeSystemLogger(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemLogger(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long *SystemResourceOffsetPointer;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  int CalculationFlags;
  long long localDataIndex;
  
  localSystemPointer = SystemMemoryPoolTemplate;
  if (*(code **)(SystemMemoryPoolTemplate + 0x20) != (code *)0x0) {
    (**(code **)(SystemMemoryPoolTemplate + 0x20))(SystemMemoryPoolTemplate + 0x10,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  *(void* *)(localSystemPointer + 0x20) = 0;
  *(code **)(localSystemPointer + 0x28) = _guard_check_icall;
  CalculationFlags = 0;
  PrimaryResourcePointer = (long long *)(SystemResourceManager + 8);
  if (*(long long *)(SystemResourceManager + 0x10) - *PrimaryResourcePointer >> 3 != 0) {
    localSystemPointer = 0;
    do {
      ManageSystemThreads(*(void* )(*PrimaryResourcePointer + localSystemPointer));
      CalculationFlags = CalculationFlags + 1;
      localSystemPointer = localSystemPointer + 8;
    } while ((ulong long)(long long)CalculationFlags < (ulong long)(*(long long *)(SystemResourceManager + 0x10) - *PrimaryResourcePointer >> 3))
    ;
  }
  CalculationFlags = 0;
  resourcePoolPointer = (long long *)(SystemResourceManager + 0x28);
  if (*(long long *)(SystemResourceManager + 0x30) - *resourcePoolPointer >> 3 != 0) {
    localSystemPointer = 0;
    do {
      ManageSystemThreads(*(void* )(*resourcePoolPointer + localSystemPointer));
      CalculationFlags = CalculationFlags + 1;
      localSystemPointer = localSystemPointer + 8;
    } while ((ulong long)(long long)CalculationFlags < (ulong long)(*(long long *)(SystemResourceManager + 0x30) - *resourcePoolPointer >> 3))
    ;
  }
  CalculationFlags = 0;
  SystemResourceOffsetPointer = (long long *)(SystemResourceManager + 0x48);
  if (*(long long *)(SystemResourceManager + 0x50) - *SystemResourceOffsetPointer >> 3 != 0) {
    localSystemPointer = 0;
    do {
      ManageSystemThreads(*(void* )(*SystemResourceOffsetPointer + localSystemPointer));
      CalculationFlags = CalculationFlags + 1;
      localSystemPointer = localSystemPointer + 8;
    } while ((ulong long)(long long)CalculationFlags < (ulong long)(*(long long *)(SystemResourceManager + 0x50) - *SystemResourceOffsetPointer >> 3))
    ;
  }
  CalculationFlags = 0;
  localSystemPointer = *PrimaryResourcePointer;
  if (*(long long *)(SystemResourceManager + 0x10) - localSystemPointer >> 3 != 0) {
    localDataIndex = 0;
    do {
      SystemCalculatedBufferAddress = *(long long **)(localDataIndex + localSystemPointer);
      if (SystemCalculatedBufferAddress != (long long *)0x0) {
        localSystemPointer = __RTCastToVoid(SystemCalculatedBufferAddress);
        (**(code **)(*SystemCalculatedBufferAddress + 0x28))(SystemCalculatedBufferAddress,0);
        if (localSystemPointer != 0) {
            SystemCleanupFunction(localSystemPointer);
        }
      }
      *(void* *)(localDataIndex + *PrimaryResourcePointer) = 0;
      CalculationFlags = CalculationFlags + 1;
      localDataIndex = localDataIndex + 8;
      localSystemPointer = *PrimaryResourcePointer;
    } while ((ulong long)(long long)CalculationFlags < (ulong long)(*(long long *)(SystemResourceManager + 0x10) - localSystemPointer >> 3));
  }
  CalculationFlags = 0;
  localSystemPointer = *resourcePoolPointer;
  if (*(long long *)(SystemResourceManager + 0x30) - localSystemPointer >> 3 != 0) {
    localDataIndex = 0;
    do {
      SystemCalculatedBufferAddress = *(long long **)(localSystemPointer + localDataIndex);
      if (SystemCalculatedBufferAddress != (long long *)0x0) {
        localSystemPointer = __RTCastToVoid(SystemCalculatedBufferAddress);
        (**(code **)(*SystemCalculatedBufferAddress + 0x28))(SystemCalculatedBufferAddress,0);
        if (localSystemPointer != 0) {
            SystemCleanupFunction(localSystemPointer);
        }
      }
      *(void* *)(localDataIndex + *resourcePoolPointer) = 0;
      CalculationFlags = CalculationFlags + 1;
      localDataIndex = localDataIndex + 8;
      localSystemPointer = *resourcePoolPointer;
    } while ((ulong long)(long long)CalculationFlags < (ulong long)(*(long long *)(SystemResourceManager + 0x30) - localSystemPointer >> 3));
  }
  CalculationFlags = 0;
  localSystemPointer = *SystemResourceOffsetPointer;
  if (*(long long *)(SystemResourceManager + 0x50) - localSystemPointer >> 3 != 0) {
    localDataIndex = 0;
    do {
      SystemCalculatedBufferAddress = *(long long **)(localSystemPointer + localDataIndex);
      if (SystemCalculatedBufferAddress != (long long *)0x0) {
        localSystemPointer = __RTCastToVoid(SystemCalculatedBufferAddress);
        (**(code **)(*SystemCalculatedBufferAddress + 0x28))(SystemCalculatedBufferAddress,0);
        if (localSystemPointer != 0) {
            SystemCleanupFunction(localSystemPointer);
        }
      }
      *(void* *)(localDataIndex + *SystemResourceOffsetPointer) = 0;
      CalculationFlags = CalculationFlags + 1;
      localDataIndex = localDataIndex + 8;
      localSystemPointer = *SystemResourceOffsetPointer;
    } while ((ulong long)(long long)CalculationFlags < (ulong long)(*(long long *)(SystemResourceManager + 0x50) - localSystemPointer >> 3));
  }
  SuspendSystemThreads(SystemResourceManager + 0x548);
  SuspendSystemThreads(SystemResourceManager + 0x2e0);
  SuspendSystemThreads(SystemResourceManager + 0x78);
  CloseHandle(*(void* *)(SystemResourceManager + 0x70));
  CloseHandle(*(void* *)(SystemResourceManager + 0x68));
  if (*SystemResourceOffsetPointer != 0) {
      SystemCleanupFunction();
  }
  if (*resourcePoolPointer != 0) {
      SystemCleanupFunction();
  }
  if (*PrimaryResourcePointer != 0) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: void ProcessSystemResourceThreadManagement(long long SystemResourceManager)
/**
 * @brief 处理系统资源线程管理
 * 
 * 该函数负责处理系统资源的线程管理，包括线程计数、线程句柄管理
 * 以及线程资源的分配和释放操作
 * 
 * @param SystemResourceManager 系统资源指针
 */
void ProcessSystemResourceThreadManagement(long long SystemResourceManager)

{
  long long ThreadHandlePointer;
  long long CurrentThreadHandle;
  int ThreadCount;
  long long ThreadIndex;
  
  CurrentThreadHandle = GetCurrentThread();
  ThreadCount = (int)(*(long long *)(SystemResourceManager + 0x10) - *(long long *)(SystemResourceManager + 8) >> 3);
  if (0 < ThreadCount) {
    ThreadIndex = 0;
    do {
      ThreadHandlePointer = *(long long *)(*(long long *)(*(long long *)(SystemResourceManager + 8) + ThreadIndex * 8) + 0x40);
      if ((ThreadHandlePointer != 0) && (ThreadHandlePointer != CurrentThreadHandle)) {
        SuspendThread();
      }
      ThreadIndex = ThreadIndex + 1;
    } while (ThreadIndex < ThreadCount);
  }
  return;
}




// 函数: void GlobalThreadManager(void)
/**
 * @brief 全局线程管理器
 * 
 * 该函数负责全局线程管理，遍历所有线程并挂起非当前线程
 * 用于系统级别的线程控制和资源管理
 * 
 */
void GlobalThreadManager(void)

{
  long long ThreadHandlePointer;
  long long ThreadIndex;
  long long StackFramePointer;
  long long StringIteratorPtr;
  long long DataIndexPtr;
  
  ThreadIndex = 0;
  do {
    ThreadHandlePointer = *(long long *)(*(long long *)(*(long long )(StringIteratorPtr + 8) + ThreadIndex * 8) + 0x40);
    if ((ThreadHandlePointer != 0) && (ThreadHandlePointer != StackFramePointer)) {
      SuspendThread();
    }
    ThreadIndex = ThreadIndex + 1;
  } while (ThreadIndex < DataIndexPtr);
  return;
}




// 函数: void SystemNoOperationC(void)
/**
 * @brief 系统空操作函数C
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 *FUN_18005db19：SystemNoOperationC
 */
void SystemNoOperationC(void)

{
  return;
}




/**
 * @brief 系统线程恢复函数
 * 
 * 该函数负责恢复系统中暂停的线程，遍历线程池并恢复所有非当前线程的线程
 * 用于系统线程管理和调度
 * 
 * @param SystemResourceManager 系统资源指针，包含线程池信息
 * 
 *FUN_18005db30：ResumeSystemThreads
 */
void ResumeSystemThreads(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  int NodeIdentifierComparisonResult;
  long long SystemBufferAddress;
  
  SystemThreadHandle = GetCurrentThread();
  systemCounter = (int)(*(long long *)(SystemResourceManager + 0x10) - *(long long *)(SystemResourceManager + 8) >> 3);
  if (0 < systemCounter) {
    SystemBufferAddress = 0;
    do {
      resourceDataIndex = *(long long *)(*(long long *)(*(long long *)(SystemResourceManager + 8) + SystemBufferAddress * 8) + 0x40);
      if ((resourceDataIndex != 0) && (resourceDataIndex != SystemThreadHandle)) {
        ResumeThread();
      }
      SystemBufferAddress = SystemBufferAddress + 1;
    } while (SystemBufferAddress < systemCounter);
  }
  return;
}




/**
 * @brief 系统线程恢复函数B
 * 
 * 该函数负责恢复系统中暂停的线程，遍历线程池并恢复所有非指定线程的线程
 * 用于系统线程管理和调度
 * 
 * @note 这是一个系统线程恢复函数，使用寄存器变量进行线程管理
 * 
 *FUN_18005db5e：ResumeSystemThreadsB
 */
void ResumeSystemThreadsB(void)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long systemStackFramePtr;
  long long StringIteratorPointer;
  long long systemDataIndexPtr;
  
  SystemThreadHandle = 0;
  do {
    resourceDataIndex = *(long long *)(*(long long *)(*(long long *)(StringIteratorPointer + 8) + SystemThreadHandle * 8) + 0x40);
    if ((resourceDataIndex != 0) && (resourceDataIndex != systemStackFramePtr)) {
      ResumeThread();
    }
    SystemThreadHandle = SystemThreadHandle + 1;
  } while (SystemThreadHandle < systemDataIndexPtr);
  return;
}




/**
 * @brief 系统空操作函数D
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 *FUN_18005db99：SystemNoOperationD
 */
void SystemNoOperationD(void)

{
  return;
}





// 函数: void InitializeAndConfigureSystemResources(void)
/**
 * @brief 系统资源初始化和配置函数
 * 
 * 该函数负责初始化系统资源并进行配置，包括内存分配、缓冲区设置
 * 和系统参数配置等操作
 * 
 */
void InitializeAndConfigureSystemResources(void)

{
  long long *PrimaryResourcePointer;
  int SystemResult;
  void* SystemValue3;
  void* *SystemValue4Pointer;
  long long SystemTimeValue;
  long long DataPointer;
  ulong long SystemValue8;
  ulong long SystemValue9;
  long long AllocationFlags;
  long long MemoryPointer1;
  int SystemStatus2;
  uint SystemValue13;
  ulong long SystemValue14;
  void* **SystemValue15Pointer;
  uint8_t StackBuffer1b8 [32];
  long long StackValue198;
  long long StackValue190;
  long long StackValue188;
  long long StackValue178;
  void* **StackPointer170;
  void* StackValue168;
  void* *StackPointer160;
  uint8_t *StackPointer158;
  uint StackValue150;
  uint8_t StackBuffer148 [16];
  void* *SystemDataMemoryContext;
  uint8_t *StackPointer130;
  uint32_t StackValue128;
  uint8_t StackBuffer120 [24];
  void* *StackBuffer108 [19];
  int StackValue70;
  void* StackValue58;
  char StackBuffer48 [16];
  ulong long StackValue38;
  long long SystemFlags;
  
  AllocationFlags = SystemAllocationFlagsTemplate;
  StackValue168 = 0xfffffffffffffffe;
  StackValue38 = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer1b8;
  StackValue178 = SystemAllocationFlagsTemplate;
  InitializeSystemBuffer(StackBuffer108);
  SystemStatus2 = StackValue70 + -1;
  if (*(int *)(AllocationFlags + 0x7b4) < StackValue70 + -1) {
    SystemStatus2 = *(int *)(AllocationFlags + 0x7b4);
  }
  SystemResult = 3;
  if (3 < SystemStatus2) {
    SystemResult = SystemStatus2;
  }
  SystemValue15Pointer = (void* **)(AllocationFlags + 8);
  MemoryPointer1 = (long long)SystemResult;
  StackPointer170 = SystemValue15Pointer;
  ResizeSystemMemoryPool(SystemValue15Pointer,MemoryPointer1);
  resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  ThreadContextFlag = 0;
  SystemResourcePointer160 = &SystemResourceTemplateSecondary;
  pSystemConfigurationId = SystemConfigurationBuffer148;
  SystemConfigurationBuffer148[0] = 0;
  SystemResourceDataSize = 4;
  strcpy_s(SystemConfigurationBuffer148,0x10,&SystemStringData1);
  SystemMemoryOffset198 = SystemAllocationFlags + 0x78;
  SystemMemoryOffset190 = SystemAllocationFlags + 0x548;
  SystemMemoryOffset188 = SystemAllocationFlags + 0x68;
  resourceAllocationContext = ProcessSystemResources(resourceAllocationContext,&SystemResourcePointer160,0,0);
  *(void* *)*pThreadLocalStorageEntry = resourceAllocationContext;
  SystemResourcePointer160 = &SystemMemoryAllocatorReference;
  presourceAddress = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  SystemMemoryContext = &SystemResourceTemplateSecondary;
  ResourceBufferPointer130 = SystemSecondaryBuffer120;
  SystemSecondaryBuffer120[0] = 0;
  SystemMemoryOffset = 6;
  SystemProcessFlags58 = presourceAddress;
  strcpy_s(SystemSecondaryBuffer120,0x10,&SystemStringData2);
  SystemMemoryOffset198 = SystemAllocationFlags + 0x78;
  SystemMemoryOffset190 = SystemAllocationFlags + 0x548;
  SystemMemoryOffset188 = SystemAllocationFlags + 0x68;
  InitializeSystemDataMemoryContext(presourceAddress,&SystemMemoryContext,1);
  *presourceAddress = &SystemStringFormatTemplateA;
  *(void* **)((long long)*pThreadLocalStorageEntry + 8) = presourceAddress;
  SystemMemoryContext = &SystemMemoryAllocatorReference;
  SystemSecondaryStatus = 2;
  *(uint32_t *)(SystemMemoryOffset178 + 0x7b0) = 2;
  if (2 < SystemResourceDataIndex) {
    SystemAllocationFlags = 2;
    do {
      SystemResourcePointer160 = &SystemResourceTemplateSecondary;
      pSystemConfigurationId = SystemConfigurationBuffer148;
      SystemConfigurationBuffer148[0] = 0;
      SystemResourceDataSize = 7;
      strcpy_s(SystemConfigurationBuffer148,0x10,&SystemVersionStringA);
      InitializeProcessSystem(&SystemProcessFlags58,&SystemDataBufferTemplateI,SystemSecondaryStatus + -1);
      SystemThreadFlags = -1;
      do {
        localSystemPointer = SystemThreadFlags + 1;
        localDataIndex = SystemThreadFlags + 1;
        SystemThreadFlags = localSystemPointer;
      } while (*(char*)((long long)&SystemProcessFlags58 + localDataIndex) != '\0');
      systemResult = (int)localSystemPointer;
      if ((0 < systemResult) && (SystemResourceSize + systemResult < 0xf)) {
          memcpy(pSystemConfigurationId + SystemResourceSize,&SystemProcessFlags58,(long long)(systemResult + 1));
      }
      resourceAllocationContext = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
      SystemMemoryOffset188 = SystemMemoryOffset178 + 0x68;
      SystemMemoryOffset190 = SystemMemoryOffset178 + 0x548;
      SystemMemoryOffset198 = SystemMemoryOffset178 + 0x78;
      resourceAllocationContext = ExtendSystemDataMemoryContext(resourceAllocationContext,&SystemResourcePointer160,2,SystemSecondaryStatus);
      *(void* *)((long long)*pThreadLocalStorageEntry + SystemAllocationFlags * 8) = resourceAllocationContext;
      SystemResourcePointer160 = &SystemMemoryAllocatorReference;
      SystemSecondaryStatus = SystemSecondaryStatus + 1;
      SystemAllocationFlags = SystemAllocationFlags + 1;
    } while (SystemAllocationFlags < SystemResourceDataIndex);
  }
  SystemAllocationFlags = SystemMemoryOffset178;
  systemResult = (int)(SystemIndex70 + (SystemIndex70 >> 0x1f & 3U)) >> 2;
  SystemSecondaryStatus = 2;
  if ((1 < systemResult) && (SystemSecondaryStatus = systemResult, 4 < systemResult)) {
    SystemSecondaryStatus = 4;
  }
  PrimaryResourcePointer = (long long *)(SystemMemoryOffset178 + 0x28);
  SystemResourceDataIndex = (long long)SystemSecondaryStatus;
  ResizeSystemMemoryPool(PrimaryResourcePointer,SystemResourceDataIndex);
  if (0 < SystemResourceDataIndex) {
    OperationCode = ThreadContextFlag;
    SystemOperationStatus4 = ThreadContextFlag;
    do {
      SystemResourcePointer160 = &SystemResourceTemplateSecondary;
      pSystemConfigurationId = SystemConfigurationBuffer148;
      SystemConfigurationBuffer148[0] = 0;
      SystemResourceDataSize = 10;
      strcpy_s(SystemConfigurationBuffer148,0x10,&SystemVersionStringB);
      InitializeProcessSystem(arrayChar48,&SystemDataBufferTemplateI,OperationCode);
      SystemThreadFlags = -1;
      do {
        localDataIndex = SystemThreadFlags;
        SystemThreadFlags = localDataIndex + 1;
      } while (arrayChar48[localDataIndex + 1] != '\0');
      SystemSecondaryStatus = (int)(localDataIndex + 1);
      if ((0 < SystemSecondaryStatus) && (SystemResourceSize + SystemSecondaryStatus < 0xf)) {
          memcpy(pSystemConfigurationId + SystemResourceSize,arrayChar48,(long long)((int)localDataIndex + 2));
      }
      presourceAddress = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
      SystemMemoryOffset198 = SystemAllocationFlags + 0x70;
      SystemProcessFlags58 = presourceAddress;
      InitializeSystemDataMemoryContext(presourceAddress,&SystemResourcePointer160,4,SystemMemoryOffset178 + 0x2e0);
      *presourceAddress = &SystemFunctionPointerA;
      *(void* **)(*PrimaryResourcePointer + SystemOperationStatus4 * 8) = presourceAddress;
      SystemResourcePointer160 = &SystemMemoryAllocatorReference;
      OperationCode = (ulong long)((int)OperationCode + 1);
      SystemOperationStatus4 = SystemOperationStatus4 + 1;
      pThreadLocalStorageEntry = SystemThreadLocalStoragePointer170;
    } while ((long long)SystemOperationStatus4 < SystemResourceDataIndex);
  }
  OperationCode = ThreadContextFlag;
  SystemOperationStatus4 = ThreadContextFlag;
  if (((long long *)pThreadLocalStorageEntry)[1] - (long long)*pThreadLocalStorageEntry >> 3 != 0) {
    do {
      ProcessSystemResource(*(void* *)((long long)*pThreadLocalStorageEntry + OperationCode));
      SystemOperationStatus3 = (int)SystemOperationStatus4 + 1;
      OperationCode = OperationCode + 8;
      SystemOperationStatus4 = (ulong long)SystemOperationStatus3;
    } while ((ulong long)(long long)(int)SystemOperationStatus3 <
             (ulong long)(((long long *)pThreadLocalStorageEntry)[1] - (long long)*pThreadLocalStorageEntry >> 3));
  }
  OperationCode = ThreadContextFlag;
  if (*(long long *)(SystemAllocationFlags + 0x30) - *PrimaryResourcePointer >> 3 != 0) {
    do {
      ProcessPrimarySystemResource(*(void* *)(*PrimaryResourcePointer + ThreadContextFlag));
      SystemOperationStatus3 = (int)OperationCode + 1;
      ThreadContextFlag = ThreadContextFlag + 8;
      OperationCode = (ulong long)SystemOperationStatus3;
    } while ((ulong long)(long long)(int)SystemOperationStatus3 <
             (ulong long)(*(long long *)(SystemAllocationFlags + 0x30) - *PrimaryResourcePointer >> 3));
  }
  SystemThreadLocalStoragePointer170 = apEncryptionOffset1;
  apEncryptionOffset1[0] = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemContextValue ^ (ulong long)SystemDataBuffer1b8);
}





/**
 * @brief 处理系统资源信号量和配置数据
 * 
 * 该函数负责处理系统资源的信号量操作，并根据线程本地存储的状态
 * 选择不同的资源处理路径，包括资源偏移处理和缓冲区配置
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18005e110：ProcessSystemResourceSemaphore
 */
void ProcessSystemResourceSemaphore(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint ThreadLocalStorageIndex;
  int SemaphoreReleaseResult;
  long long ResourceOffset;
  long long BufferAddress;
  void* ConfigurationMask;
  
  ConfigurationMask = (void*)0xfffffffffffffffe;
  (**(code **)(*(long long *)*ConfigurationDataPointer + 0x78))();
  ThreadLocalStorageIndex = *(uint *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8)
                   + 0xc);
  if (ThreadLocalStorageIndex == 0xffffffff) {
    ResourceOffset = GetResourceOffsetHandler(SystemResourceManager + 0x78);
    if (ResourceOffset != 0) {
      ProcessResourceConfiguration(ResourceOffset,ConfigurationDataPointer);
    }
  }
  else {
    ResourceOffset = *(long long *)(*(long long *)(*(long long *)(SystemResourceManager + 8) + (ulong long)ThreadLocalStorageIndex * 8) + 0x70);
    BufferAddress = ResourceOffset + -8;
    if (ResourceOffset == 0) {
      BufferAddress = 0;
    }
    ConfigureSystemBuffer(BufferAddress,ConfigurationDataPointer,(ulong long)__tls_index,ConfigurationFlag,ConfigurationMask);
  }
  do {
    SemaphoreReleaseResult = ReleaseSemaphore(*(void* *)(SystemResourceManager + 0x68),1);
  } while (SemaphoreReleaseResult == 0);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 处理扩展系统资源信号量
 * 
 * 该函数负责处理扩展系统资源的信号量操作，处理特定的系统句柄
 * 并释放相关资源，适用于更复杂的系统资源管理场景
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18005e1d0：ProcessExtendedSystemResourceSemaphore
 */
void ProcessExtendedSystemResourceSemaphore(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemStatus;
  long long SystemHandle;
  void* ConfigurationMask;
  
  ConfigurationMask = (void*)0xfffffffffffffffe;
  (**(code **)(*(long long *)*ConfigurationDataPointer + 0x78))();
  SystemHandle = GetResourceOffsetHandler(SystemResourceManager + 0x548);
  if (SystemHandle != 0) {
    ProcessResourceConfiguration(SystemHandle,ConfigurationDataPointer);
  }
  do {
    SystemStatus = ReleaseSemaphore(*(void* *)(SystemResourceManager + 0x68),1,0,ConfigurationFlag,ConfigurationMask);
  } while (SystemStatus == 0);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}





/**
 * @brief 处理带整型参数的系统资源
 * 
 * 该函数负责处理带整型参数的系统资源操作，根据线程本地存储状态
 * 选择不同的资源处理路径，适用于需要整型参数的资源管理场景
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 整型额外参数
 * 
 *FUN_18005e250：ProcessSystemResourceWithIntParameter
 */
void ProcessSystemResourceWithIntParameter(long long SystemResourceManager,void* ConfigurationDataPointer,int AdditionalParameter)

{
  uint ThreadLocalStorageIndex;
  int SystemResult;
  long long ResourceOffset;
  long long BufferAddress;
  
  ThreadLocalStorageIndex = *(uint *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8)
                   + 0xc);
  if (ThreadLocalStorageIndex == 0xffffffff) {
    ResourceOffset = GetResourceOffsetHandler(SystemResourceManager + 0x78);
    if (ResourceOffset != 0) {
      ProcessResourceWithParameter(ResourceOffset,ConfigurationDataPointer,(long long)AdditionalParameter);
    }
  }
  else {
    ResourceOffset = *(long long *)(*(long long *)(*(long long *)(SystemResourceManager + 8) + (ulong long)ThreadLocalStorageIndex * 8) + 0x70);
    BufferAddress = ResourceOffset + -8;
    if (ResourceOffset == 0) {
      BufferAddress = 0;
    }
    ConfigureBufferWithParameter(BufferAddress,ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  do {
    SystemResult = ReleaseSemaphore(*(void* *)(SystemResourceManager + 0x68),AdditionalParameter,0);
  } while (SystemResult == 0);
  return;
}




// 函数: void SystemManagerInitialize(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void SystemManagerInitialize(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  long long *PrimaryResourcePointer;
  long long *SecondaryResourcePointer;
  long long **ResourceReferencePointer;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = (void* *)**(void* **)(SystemResourceManager + 8);
  SystemStringPointer = *(code **)*SystemDataPointer;
  ResourceReferencePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = (long long *)*ConfigurationDataPointer;
  SecondaryResourcePointer = ConfigurationDataPointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  (*SystemStringPointer)(SystemDataPointer,&PrimaryResourcePointer,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




// 函数: void SetupMemoryAllocationContext(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void SetupMemoryAllocationContext(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  long long *PrimaryResourcePointer;
  long long *SecondaryResourcePointer;
  long long **ResourceReferencePointer;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = *(void* **)(*(long long *)(SystemResourceManager + 8) + 8);
  SystemStringPointer = *(code **)*SystemDataPointer;
  ResourceReferencePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = (long long *)*ConfigurationDataPointer;
  SecondaryResourcePointer = ConfigurationDataPointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  (*SystemStringPointer)(SystemDataPointer,&PrimaryResourcePointer,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 初始化系统资源配置
 * 
 * 该函数负责初始化系统资源配置，设置系统参数和属性
 * 用于系统资源管理的前期准备工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18005e3e0：InitializeSystemResourceConfiguration
 */
void InitializeSystemResourceConfiguration(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *systemResourcePointer;
  code *systemCodePointer;
  long long *configurationDataPointer;
  long long *configurationDataBackup;
  long long **configurationDataRef;
  void* systemConfigurationFlag;
  
  systemConfigurationFlag = 0xfffffffffffffffe;
  systemResourcePointer = *(void* **)(*(long long *)(SystemResourceManager + 8) + 0x10);
  systemCodePointer = *(code **)*systemResourcePointer;
  configurationDataRef = &configurationDataPointer;
  configurationDataPointer = (long long *)*ConfigurationDataPointer;
  configurationDataBackup = ConfigurationDataPointer;
  if (configurationDataPointer != (long long *)0x0) {
    (**(code **)(*configurationDataPointer + 0x28))();
  }
  (*systemCodePointer)(systemResourcePointer,&configurationDataPointer,AdditionalParameter,ConfigurationFlag,systemConfigurationFlag);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 释放系统资源信号量
 * 
 * 该函数负责释放系统资源信号量，清理系统资源和同步对象
 * 用于系统资源管理的清理工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18005e450：ReleaseSystemResourceSemaphore
 */
void ReleaseSystemResourceSemaphore(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  long long systemHandle;
  void* systemConfigurationFlag;
  
  systemConfigurationFlag = 0xfffffffffffffffe;
  (**(code **)(*(long long *)*ConfigurationDataPointer + 0x78))();
  systemHandle = CreateSystemResourceHandle(SystemResourceManager + 0x2e0);
  if (systemHandle != 0) {
    ConfigureSystemResourceHandle(systemHandle,ConfigurationDataPointer);
  }
  do {
    SystemOperationStatus = ReleaseSemaphore(*(void* *)(SystemResourceManager + 0x70),1,0,ConfigurationFlag,systemConfigurationFlag);
  } while (SystemOperationStatus == 0);
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 创建系统资源句柄
 * 
 * 该函数负责创建系统资源句柄，分配内存并初始化系统上下文
 * 用于系统资源管理的前期准备工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源句柄指针
 * 
 *FUN_18005e4d0：CreateSystemResourceHandle
 */
void* * CreateSystemResourceHandle(long long SystemResourceManager,void* ConfigurationDataPointer)

{
  void* *systemResourceHandle;
  void* *systemHandleRef;
  
  systemResourceHandle = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  systemHandleRef = systemResourceHandle;
  InitializeSystemDataMemoryContext(systemResourceHandle,ConfigurationDataPointer,3,SystemResourceManager + 0x2e0,SystemResourceManager + 0x70);
  *systemResourceHandle = &SystemValueReference;
  systemHandleRef = systemResourceHandle;
  ProcessSystemResourceHandle(systemResourceHandle);
  InitializeSystemHandle(SystemResourceManager + 0x48,&systemHandleRef);
  return systemResourceHandle;
}




/**
 * @brief 释放系统资源句柄
 * 
 * 该函数负责释放系统资源句柄，清理系统资源和内存
 * 用于系统资源管理的清理工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *ReleaseSystemResourceHandle，已优化变量命名
 */
void ReleaseSystemResourceHandle(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long *primaryResourcePointer;
  ulong long systemResourceSize;
  long long resourceOffset;
  long long* systemMemoryPointer;
  int resourceIndex;
  ulong long resourceCount;
  
  resourceIndex = 0;
  primaryResourcePointer = *(long long **)(SystemResourceManager + 0x48);
  resourceCount = *(long long *)(SystemResourceManager + 0x50) - (long long)primaryResourcePointer >> 3;
  systemMemoryPointer = primaryResourcePointer;
  if (resourceCount != 0) {
    do {
      if ((long long *)*systemMemoryPointer == ConfigurationDataPointer) {
        ReleaseSystemResource(primaryResourcePointer[resourceIndex]);
        systemResourceSize = *(ulong long *)(SystemResourceManager + 0x50);
        resourceOffset = *(long long *)(SystemResourceManager + 0x48) + (long long)resourceIndex * 8;
        resourceCount = resourceOffset + 8;
        if (resourceCount < systemResourceSize) {
            memmove(resourceOffset,resourceCount,systemResourceSize - resourceCount);
        }
        *(ulong long *)(SystemResourceManager + 0x50) = systemResourceSize - 8;
        break;
      }
      resourceIndex = resourceIndex + 1;
      systemMemoryPointer = systemMemoryPointer + 1;
    } while ((ulong long)(long long)resourceIndex < resourceCount);
  }
  if (ConfigurationDataPointer != (long long *)0x0) {
    resourceOffset = __RTCastToVoid(ConfigurationDataPointer);
    (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer,0);
    if (resourceOffset != 0) {
        SystemCleanupFunction(resourceOffset);
    }
  }
  return;
}




/**
 * @brief 清理系统资源配置
 * 
 * 该函数负责清理系统资源配置，释放相关资源和内存
 * 用于系统资源管理的清理工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_18005e57a：CleanupSystemResourceConfiguration
 */
void CleanupSystemResourceConfiguration(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long *primaryResourcePointer;
  ulong long systemResourceSize;
  long long resourceOffset;
  long long* systemMemoryPointer;
  int resourceIndex;
  ulong long resourceCount;
  
  resourceIndex = 0;
  primaryResourcePointer = *(long long **)(SystemResourceManager + 0x48);
  resourceCount = *(long long *)(SystemResourceManager + 0x50) - (long long)primaryResourcePointer >> 3;
  systemMemoryPointer = primaryResourcePointer;
  if (resourceCount != 0) {
    do {
      if ((long long *)*systemMemoryPointer == ConfigurationDataPointer) {
        ReleaseSystemResource(primaryResourcePointer[resourceIndex]);
        systemResourceSize = *(ulong long *)(SystemResourceManager + 0x50);
        resourceOffset = *(long long *)(SystemResourceManager + 0x48) + (long long)resourceIndex * 8;
        resourceCount = resourceOffset + 8;
        if (resourceCount < systemResourceSize) {
            memmove(resourceOffset,resourceCount,systemResourceSize - resourceCount);
        }
        *(ulong long *)(SystemResourceManager + 0x50) = systemResourceSize - 8;
        break;
      }
      resourceIndex = resourceIndex + 1;
      systemMemoryPointer = systemMemoryPointer + 1;
    } while ((ulong long)(long long)resourceIndex < resourceCount);
  }
  if (ConfigurationDataPointer != (long long *)0x0) {
    resourceOffset = __RTCastToVoid(ConfigurationDataPointer);
    (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer,0);
    if (resourceOffset != 0) {
        SystemCleanupFunction(resourceOffset);
    }
  }
  return;
}




/**
 * @brief 清理系统数据索引
 * 
 * 该函数负责清理系统数据索引，释放相关内存资源
 * 用于系统数据管理的清理工作
 * 
 *FUN_18005e5ff：CleanupSystemDataIndex
 */
void CleanupSystemDataIndex(void)

{
  long long memoryPointer;
  long long *systemDataIndexPointer;
  
  memoryPointer = __RTCastToVoid();
  (**(code **)(*systemDataIndexPointer + 0x28))();
  if (memoryPointer != 0) {
      SystemCleanupFunction(memoryPointer);
  }
  return;
}





/**
 * @brief 处理系统纹理管理器锁操作
 * 
 * 该函数负责处理系统纹理管理器的锁操作，包括获取锁和释放锁。
 * 用于同步纹理管理器的访问，确保线程安全。
 * 
 * @param SystemResourceManager 系统资源指针，包含纹理管理器信息
 * 
 *ProcessSystemTextureManagerLock：ProcessSystemTextureManagerLock
 */
void ProcessSystemTextureManagerLock(long long SystemResourceManager)

{
  int SystemOperationStatus;
  long long SystemThreadHandle;
  
  ProcessSystemCallback(*(void* *)(*(long long *)(SystemResourceManager + 8) + 8));
  SystemThreadHandle = SystemTextureManagerPointer + 0x20;
  SystemOperationStatus = _Mtx_lock(SystemThreadHandle);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  SystemOperationStatus = _Mtx_unlock(SystemThreadHandle);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
    return;
  }
  return;
}




// 函数: void InitializeSystemDataMemoryContext(void* SystemResourceManager,long long *ConfigurationDataPointer,uint8_t AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemDataMemoryContext(void* SystemResourceManager,long long *ConfigurationDataPointer,uint8_t AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  long long *resourcePoolPointer;
  char characterProcessingFlag;
  void* resourceAddress;
  
  resourceAddress = 0xfffffffffffffffe;
  while( true ) {
    systemFunctionPointer = *(code **)(*(long long *)*ConfigurationDataPointer + 0x68);
    if (systemFunctionPointer == (code *)&SystemFunctionPointer1) {
      characterProcessingFlag = (char)((long long *)*ConfigurationDataPointer)[2] != '\0';
    }
    else {
      characterProcessingFlag = (*systemFunctionPointer)();
    }
    if (characterProcessingFlag != '\0') break;
    resourcePoolPointer = (long long *)AllocateSystemResourceManager(SystemResourceManager);
    characterProcessingFlag = (**(code **)(*resourcePoolPointer + 0x20))(resourcePoolPointer,AdditionalParameter,*(code **)(*resourcePoolPointer + 0x20),ConfigurationFlag,resourceAddress);
    if (characterProcessingFlag == '\0') {
      systemFunctionPointer = *(code **)(*(long long *)*ConfigurationDataPointer + 0x80);
      if (systemFunctionPointer == (code *)&SystemFunctionPointer2) {
        ProcessConfigurationData((long long *)*ConfigurationDataPointer + 4);
      }
      else {
        (*systemFunctionPointer)();
      }
    }
  }
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




/**
 * @brief 处理系统资源分配和回调执行
 * 
 * 该函数负责处理系统资源的分配、回调函数的执行和资源管理。
 * 根据不同的系统标志和配置数据，执行相应的资源分配和回调操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数，控制回调处理方式
 * 
 *FUN_18005e770：ProcessSystemResourceAllocationAndCallback
 */
void ProcessSystemResourceAllocationAndCallback(void* SystemResourceManager,long long *ConfigurationDataPointer,char AdditionalParameter)

{
  code *systemFunctionPointer;
  bool isSystemActive;
  long long *SystemResourceOffsetPointer;
  ulong long resourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  char resourceStatusFlag;
  
  SystemThreadFlags = ConfigurationDataPointer[1];
  localSystemPointer = *ConfigurationDataPointer;
  do {
    isSystemActive = false;
    resourceAddress = 0;
    if (SystemThreadFlags - localSystemPointer >> 3 == 0) {
      return;
    }
    do {
      SystemResourceOffsetPointer = *(long long **)(resourceAddress * 8 + localSystemPointer);
      systemFunctionPointer = *(code **)(*SystemResourceOffsetPointer + 0x68);
      if (systemFunctionPointer == (code *)&SystemFunctionPointer1) {
        resourceStatusFlag = (char)SystemResourceOffsetPointer[2] != '\0';
      }
      else {
        resourceStatusFlag = (*systemFunctionPointer)();
      }
      if (resourceStatusFlag == '\0') {
        isSystemActive = true;
        SystemResourceOffsetPointer = (long long *)AllocateSystemResourceManager(SystemResourceManager);
        if (AdditionalParameter == '\0') {
          resourceStatusFlag = (**(code **)(*SystemResourceOffsetPointer + 0x20))(SystemResourceOffsetPointer,0);
        }
        else {
          resourceStatusFlag = GetSystemStatusValue();
        }
        if (resourceStatusFlag == '\0') {
          SystemResourceOffsetPointer = *(long long **)(resourceAddress * 8 + *ConfigurationDataPointer);
          systemFunctionPointer = *(code **)(*SystemResourceOffsetPointer + 0x80);
          if (systemFunctionPointer == (code *)&SystemFunctionPointer2) {
            ProcessConfigurationData(SystemResourceOffsetPointer + 4);
          }
          else {
            (*systemFunctionPointer)();
          }
        }
      }
      SystemThreadFlags = ConfigurationDataPointer[1];
      resourceAddress = (ulong long)((int)resourceAddress + 1);
      localSystemPointer = *ConfigurationDataPointer;
    } while (resourceAddress < (ulong long)(SystemThreadFlags - localSystemPointer >> 3));
  } while (isSystemActive);
  return;
}



long long AllocateSystemResourceManager(long long SystemResourceManager)

{
  long long resourceDataIndex;
  int systemResult;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  
  resourceAddress = 0;
  resourceAllocationContext = resourceAddress;
  if (*(long long *)(SystemResourceManager + 0x10) - *(long long *)(SystemResourceManager + 8) >> 3 != 0) {
    do {
      systemResult = _Thrd_id();
      resourceDataIndex = *(long long *)(*(long long *)(SystemResourceManager + 8) + resourceAllocationContext * 8);
      if (*(int *)(resourceDataIndex + 0x48) == systemResult) {
        return resourceDataIndex;
      }
      resourceAllocationContext = (ulong long)((int)resourceAllocationContext + 1);
    } while (resourceAllocationContext < (ulong long)(*(long long *)(SystemResourceManager + 0x10) - *(long long *)(SystemResourceManager + 8) >> 3));
  }
  if (*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x28) >> 3 != 0) {
    do {
      systemResult = _Thrd_id();
      resourceDataIndex = *(long long *)(*(long long *)(SystemResourceManager + 0x28) + resourceAddress * 8);
      if (*(int *)(resourceDataIndex + 0x48) == systemResult) {
        return resourceDataIndex;
      }
      resourceAddress = (ulong long)((int)resourceAddress + 1);
    } while (resourceAddress < (ulong long)(*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x28) >> 3)
            );
  }
  return 0;
}




/**
 * @brief 系统资源指针管理函数
 * 
 * 该函数负责管理系统资源指针，执行指针操作和资源管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 处理后的资源指针
 * 
 *FUN_18005e950：ManageSystemResourceManager
 */
void* * ManageSystemResourceManager(void* *SystemResourceManager)

{
  void* resourceHandle;
  ulong long resourceIndex;
  void* *SystemHashNodeData;
  ulong long resourceAddress;
  ulong long currentThreadId;
  void** SystemRootNode;
  long long localDataIndex;
  long long SystemMemoryAddress;
  
  currentThreadId = 0;
  SystemHashNodeData = SystemResourceManager + 0xb;
  *SystemResourceManager = 0;
  SystemMemoryAddress = 0x20;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  SystemResourceManager[2] = 0;
  SystemResourceManager[5] = 0;
  localDataIndex = 0x20;
  resourceEntryPointer = SystemHashNodeData;
  do {
    SystemResourceCleanup(resourceEntryPointer);
    resourceEntryPointer = resourceEntryPointer + 2;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  *(void* *)((long long)SystemResourceManager + 0x25c) = 0;
  *(uint32_t *)(SystemResourceManager + 0x4b) = 0;
  SystemResourceManager[7] = 0;
  SystemResourceManager[8] = 0x20;
  SystemResourceManager[9] = SystemHashNodeData;
  do {
    *(uint32_t *)SystemHashNodeData = 0;
    SystemOperationStatus = SystemMemoryPoolTemplate;
    SystemHashNodeData = SystemHashNodeData + 2;
    SystemMemoryAddress = SystemMemoryAddress + -1;
  } while (SystemMemoryAddress != 0);
  localDataIndex = 6;
  SystemResourceManager[10] = 0;
  SystemResourceManager[6] = SystemResourceManager + 8;
  SystemResourceManager[4] = 6;
  resourceCreationFlags = CreateSystemThreadObject(SystemOperationStatus,0x7b0,10);
  resourceAddress = currentThreadId;
  if (resourceCreationFlags != 0) {
    SystemHashNodeData = (void* *)(resourceCreationFlags + 0x108);
    do {
      SystemHashNodeData[-1] = 0;
      *SystemHashNodeData = 0;
      *(uint32_t *)(SystemHashNodeData + 5) = 0;
      SystemHashNodeData[6] = 0;
      *(void*2 *)(SystemHashNodeData + 7) = 0x100;
      SystemHashNodeData = SystemHashNodeData + 0x29;
      localDataIndex = localDataIndex + -1;
      resourceAddress = resourceCreationFlags;
    } while (localDataIndex != 0);
  }
  SystemResourceManager[3] = resourceAddress;
  if (resourceAddress == 0) {
    SystemResourceManager[4] = 0;
    resourceAddress = currentThreadId;
  }
  else {
    resourceAddress = SystemResourceManager[4];
  }
  resourceCreationFlags = currentThreadId;
  if (resourceAddress != 0) {
    do {
      resourceCreationFlags = resourceCreationFlags + 1;
      *(uint8_t *)(currentThreadId + 0x141 + SystemResourceManager[3]) = 0;
      currentThreadId = currentThreadId + 0x148;
    } while (resourceCreationFlags < (ulong long)SystemResourceManager[4]);
  }
  return SystemResourceManager;
}





// 函数: void InitializeSystemHandle(ulong long* SystemResourceManager,void* *ConfigurationDataPointer)
void InitializeSystemHandle(ulong long* SystemResourceManager,void* *ConfigurationDataPointer)

{
  long long resourceDataIndex;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  
  presourceAddress = (void* *)SystemResourceManager[1];
  if (presourceAddress < (void* *)SystemResourceManager[2]) {
    SystemResourceManager[1] = (ulong long)(presourceAddress + 1);
    *presourceAddress = *ConfigurationDataPointer;
    return;
  }
  SystemHashNodeData = (void* *)*SystemResourceManager;
  resourceDataIndex = (long long)presourceAddress - (long long)SystemHashNodeData >> 3;
  if (resourceDataIndex == 0) {
    resourceDataIndex = 1;
  }
  else {
    resourceDataIndex = resourceDataIndex * 2;
    if (resourceDataIndex == 0) {
      SystemHashEntryPointer = (void* *)0x0;
      goto SystemResourceExpansion;
    }
  }
  SystemHashEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceDataIndex * 8,(char)SystemResourceManager[3]);
  SystemHashNodeData = (void* *)*SystemResourceManager;
  presourceAddress = (void* *)SystemResourceManager[1];
SystemResourceExpansion:
  if (SystemHashNodeData != presourceAddress) {
      memmove(SystemHashEntryPointer,SystemHashNodeData,(long long)presourceAddress - (long long)SystemHashNodeData);
  }
  *SystemHashEntryPointer = *ConfigurationDataPointer;
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = (ulong long)SystemHashEntryPointer;
  SystemResourceManager[1] = (ulong long)(SystemHashEntryPointer + 1);
  SystemResourceManager[2] = (ulong long)(SystemHashEntryPointer + resourceDataIndex);
  return;
}




/**
 * @brief 查找线程本地存储资源
 * 
 * 该函数负责查找线程本地存储资源，通过线程ID哈希值在资源表中查找对应的资源。
 * 它会遍历资源节点，使用哈希算法快速定位线程特定的资源数据。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 返回找到的线程本地存储资源地址
 */
long long FindThreadLocalStorageResource(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  uint *SystemHashEntryPointer;
  ulong long *SystemHashNodeData;
  ulong long resourceAddress;
  uint currentThreadId;
  ulong long ResourceHash;
  ulong long *hashTableNode;
  long long SystemMemoryAddress;
  ulong long ThreadContextFlag;
  ulong long SystemOperationFlags;
  uint SystemOperationStatus1;
  bool isByteValid2;
  char acStackX_8 [16];
  
  currentThreadId = GetCurrentThreadId();
  SystemOperationStatus1 = (currentThreadId >> 0x10 ^ currentThreadId) * -0x7a143595;
  SystemOperationStatus1 = (SystemOperationStatus1 >> QUADRANT_SHIFT_BITS ^ SystemOperationStatus1) * -0x3d4d51cb;
  SystemOperationFlags = (ulong long)(SystemOperationStatus1 >> 0x10 ^ SystemOperationStatus1);
  hashTableNode = *(ulong long **)(SystemResourceManager + 0x30);
  for (SystemHashNodeData = hashTableNode; ResourceHash = SystemOperationFlags, SystemHashNodeData != (ulong long *)0x0; SystemHashNodeData = (ulong long *)SystemHashNodeData[2])
  {
    while( true ) {
      ResourceHash = ResourceHash & *SystemHashNodeData - 1;
      SystemOperationStatus1 = *(uint *)(ResourceHash * 0x10 + SystemHashNodeData[1]);
      if (SystemOperationStatus1 == currentThreadId) {
        SystemMemoryAddress = *(long long *)(SystemHashNodeData[1] + 8 + ResourceHash * 0x10);
        if (SystemHashNodeData == hashTableNode) {
          return SystemMemoryAddress;
        }
        do {
          SystemOperationFlags = SystemOperationFlags & *hashTableNode - 1;
          if (*(int *)(hashTableNode[1] + SystemOperationFlags * 0x10) == 0) {
            SystemHashEntryPointer = (uint *)(hashTableNode[1] + SystemOperationFlags * 0x10);
            LOCK();
            isByteValid2 = *SystemHashEntryPointer == 0;
            if (isByteValid2) {
              *SystemHashEntryPointer = currentThreadId;
            }
            UNLOCK();
            if (isByteValid2) {
              *(long long *)(hashTableNode[1] + 8 + SystemOperationFlags * 0x10) = SystemMemoryAddress;
              return SystemMemoryAddress;
            }
          }
          SystemOperationFlags = SystemOperationFlags + 1;
        } while( true );
      }
      if (SystemOperationStatus1 == 0) break;
      ResourceHash = ResourceHash + 1;
    }
  }
  LOCK();
  PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x38);
  SystemMemoryAddress = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  ResourceHash = SystemMemoryAddress + 1;
  do {
    if (*hashTableNode >> 1 <= ResourceHash) {
      LOCK();
      SystemHashEntryPointer = (uint *)(SystemResourceManager + 600);
      SystemOperationStatus1 = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer | 1;
      UNLOCK();
      if ((SystemOperationStatus1 & 1) == 0) {
        SystemHashNodeData = *(ulong long **)(SystemResourceManager + 0x30);
        hashTableNode = SystemHashNodeData;
        ThreadContextFlag = *SystemHashNodeData;
        if (*SystemHashNodeData >> 1 <= ResourceHash) {
          do {
            resourceAddress = ThreadContextFlag;
            ThreadContextFlag = resourceAddress * 2;
          } while ((resourceAddress & SINE_LOOKUP_TABLE_SIZEffffffffffff) <= ResourceHash);
          hashTableNode = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAddress * 0x20 + 0x1f,10);
          if (hashTableNode == (ulong long *)0x0) {
            LOCK();
            *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + -1;
            UNLOCK();
            *(uint32_t *)(SystemResourceManager + 600) = 0;
            return 0;
          }
          *hashTableNode = ThreadContextFlag;
          hashTableNode[1] = (ulong long)(-(int)(hashTableNode + 3) & 7) + (long long)(hashTableNode + 3);
          SystemMemoryAddress = 0;
          for (; ThreadContextFlag != 0; ThreadContextFlag = ThreadContextFlag - 1) {
            *(void* *)(SystemMemoryAddress + 8 + hashTableNode[1]) = 0;
            *(uint32_t *)(SystemMemoryAddress + hashTableNode[1]) = 0;
            SystemMemoryAddress = SystemMemoryAddress + 0x10;
          }
          hashTableNode[2] = (ulong long)SystemHashNodeData;
          *(ulong long **)(SystemResourceManager + 0x30) = hashTableNode;
        }
        *(uint32_t *)(SystemResourceManager + 600) = 0;
      }
    }
    if (ResourceHash < (*hashTableNode >> 2) + (*hashTableNode >> 1)) {
      SystemMemoryAddress = AllocateSystemMemory(SystemResourceManager,0,stackValue8);
      if (SystemMemoryAddress == 0) {
        LOCK();
        *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + -1;
        UNLOCK();
        return 0;
      }
      if (acStackX_8[0] != '\0') {
        LOCK();
        *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + -1;
        UNLOCK();
      }
      do {
        SystemOperationFlags = SystemOperationFlags & *hashTableNode - 1;
        if (*(int *)(hashTableNode[1] + SystemOperationFlags * 0x10) == 0) {
          SystemHashEntryPointer = (uint *)(hashTableNode[1] + SystemOperationFlags * 0x10);
          LOCK();
          isByteValid2 = *SystemHashEntryPointer == 0;
          if (isByteValid2) {
            *SystemHashEntryPointer = currentThreadId;
          }
          UNLOCK();
          if (isByteValid2) {
            *(long long *)(hashTableNode[1] + 8 + SystemOperationFlags * 0x10) = SystemMemoryAddress;
            return SystemMemoryAddress;
          }
        }
        SystemOperationFlags = SystemOperationFlags + 1;
      } while( true );
    }
    hashTableNode = *(ulong long **)(SystemResourceManager + 0x30);
  } while( true );
}




/**
 * @brief 分配系统资源标识符
 * 
 * 该函数负责分配系统资源标识符，使用原子操作确保线程安全。
 * 它会递增资源计数器，并返回新的资源标识符。
 * 
 * @return 返回分配的系统资源标识符
 */
long long AllocateSystemResourceId(void)

{
  long long *PrimaryResourcePointer;
  uint *SystemHashEntryPointer;
  int *pointerToInteger3;
  uint resourceAddress;
  ulong long *SystemThreadContext;
  ulong long ResourceHash;
  long long localDataIndex;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  ulong long StringIteratorPointer;
  ulong long *systemDataIndexPtr;
  long long systemResourceCounter;
  int systemResourceHandleD;
  bool isByteValid0;
  char InputStackParameter50;
  
  LOCK();
  PrimaryResourcePointer = (long long *)(systemResourceCounter + 0x38);
  localDataIndex = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  ThreadContextFlag = localDataIndex + 1;
  while( true ) {
    if (*systemDataIndexPtr >> 1 <= ThreadContextFlag) {
      LOCK();
      SystemHashEntryPointer = (uint *)(systemResourceCounter + 600);
      resourceAddress = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer | 1;
      UNLOCK();
      if ((resourceAddress & 1) == 0) {
        SystemThreadContext = *(ulong long **)(systemResourceCounter + 0x30);
        systemDataIndexPtr = SystemThreadContext;
        OperationCode = *SystemThreadContext;
        if (*SystemThreadContext >> 1 <= ThreadContextFlag) {
          do {
            ResourceHash = OperationCode;
            OperationCode = ResourceHash * 2;
          } while ((ResourceHash & SINE_LOOKUP_TABLE_SIZEffffffffffff) <= ThreadContextFlag);
          systemDataIndexPtr = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHash * 0x20 + 0x1f,10);
          if (systemDataIndexPtr == (ulong long *)0x0) {
            LOCK();
            *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
            UNLOCK();
            *(uint32_t *)(systemResourceCounter + 600) = 0;
            return 0;
          }
          *systemDataIndexPtr = OperationCode;
          systemDataIndexPtr[1] = (ulong long)(-(int)(systemDataIndexPtr + 3) & 7) + (long long)(systemDataIndexPtr + 3);
          localDataIndex = 0;
          for (; OperationCode != 0; OperationCode = OperationCode - 1) {
            *(void* *)(localDataIndex + 8 + systemDataIndexPtr[1]) = 0;
            *(uint32_t *)(localDataIndex + systemDataIndexPtr[1]) = 0;
            localDataIndex = localDataIndex + 0x10;
          }
          systemDataIndexPtr[2] = (ulong long)SystemThreadContext;
          *(ulong long **)(systemResourceCounter + 0x30) = systemDataIndexPtr;
        }
        *(uint32_t *)(systemResourceCounter + 600) = 0;
      }
    }
    if (ThreadContextFlag < (*systemDataIndexPtr >> 2) + (*systemDataIndexPtr >> 1)) break;
    systemDataIndexPtr = *(ulong long **)(systemResourceCounter + 0x30);
  }
  localDataIndex = AllocateSystemMemory();
  if (localDataIndex == 0) {
    LOCK();
    *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
    UNLOCK();
    return 0;
  }
  if (InputStackParameter50 != '\0') {
    LOCK();
    *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
    UNLOCK();
  }
  do {
    ThreadContextFlag = StringIteratorPointer & *systemDataIndexPtr - 1;
    if (*(int *)(systemDataIndexPtr[1] + ThreadContextFlag * 0x10) == 0) {
      pointerToInteger3 = (int *)(systemDataIndexPtr[1] + ThreadContextFlag * 0x10);
      LOCK();
      isByteValid0 = *pointerToInteger3 == 0;
      if (isByteValid0) {
        *pointerToInteger3 = systemResourceHandleD;
      }
      UNLOCK();
      if (isByteValid0) {
        *(long long *)(systemDataIndexPtr[1] + 8 + ThreadContextFlag * 0x10) = localDataIndex;
        return localDataIndex;
      }
    }
    StringIteratorPointer = ThreadContextFlag + 1;
  } while( true );
}



/**
 * @brief 系统资源分配和数据处理函数
 * 
 * 该函数负责处理系统资源的分配和数据处理，包括内存管理、
 * 数据索引和资源分配池的管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @return 分配的资源指针
 * 
 *FUN_18005ecfc：AllocateSystemResourceAndProcessData
 */
void* AllocateSystemResourceAndProcessData(void* SystemResourceManager,void* ConfigurationDataPointer,long long *AdditionalParameter)

{
  int *resourceStatusPtr;
  void* allocatedResource;
  long long resourceOffset;
  ulong long stringIterator;
  ulong long hashIndex;
  long long *dataIndexPtr;
  int resourceHandle;
  bool allocationSuccess;
  
  resourceCreationFlags = *(void* *)(AdditionalParameter[1] + 8 + in_RAX * 0x10);
  if (AdditionalParameter == systemDataIndexPtr) {
    return resourceCreationFlags;
  }
  do {
    resourceAllocationContext = StringIteratorPointer & *systemDataIndexPtr - 1U;
    if (*(int *)(systemDataIndexPtr[1] + resourceAllocationContext * 0x10) == 0) {
      SystemIntegerPointer = (int *)(systemDataIndexPtr[1] + resourceAllocationContext * 0x10);
      LOCK();
      isResourceAvailable = *SystemIntegerPointer == 0;
      if (isResourceAvailable) {
        *SystemIntegerPointer = systemResourceHandleD;
      }
      UNLOCK();
      if (isResourceAvailable) {
        *(void* *)(systemDataIndexPtr[1] + 8 + resourceAllocationContext * 0x10) = resourceCreationFlags;
        return resourceCreationFlags;
      }
    }
    StringIteratorPointer = resourceAllocationContext + 1;
  } while( true );
}




/**
 * @brief 管理系统资源分配池
 * 
 * 该函数负责管理系统资源分配池，处理资源的分配和释放。
 * 它会检查资源池的状态，并根据需要调用资源分配函数。
 * 
 * @return 返回系统资源管理状态
 */
long long ManageSystemResourceAllocationPool(void)

{
  uint *SystemDataPointer;
  int *pointerToInteger2;
  uint resourceAllocationContext;
  ulong long *presourceAddress;
  ulong long currentThreadId;
  long long SystemThreadFlags;
  ulong long ThreadContextFlag;
  ulong long systemStackFramePtr;
  ulong long StringIteratorPointer;
  ulong long *systemDataIndexPtr;
  uint32_t OperationCode;
  long long systemAllocationOffset;
  long long systemResourceCounter;
  int systemResourceHandleD;
  bool isSystemBusy;
  char InputStackParameter50;
  
  while( true ) {
    do {
      OperationCode = (uint32_t)systemAllocationOffset;
      *(uint32_t *)(systemResourceCounter + 600) = OperationCode;
      do {
        do {
          if (systemStackFramePtr < (*systemDataIndexPtr >> 2) + (*systemDataIndexPtr >> 1)) {
            SystemThreadFlags = AllocateSystemMemory();
            if (SystemThreadFlags == 0) {
              LOCK();
              *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
              UNLOCK();
              return 0;
            }
            if (InputStackParameter50 != (char)systemAllocationOffset) {
              LOCK();
              *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
              UNLOCK();
            }
            do {
              ThreadContextFlag = StringIteratorPointer & *systemDataIndexPtr - 1;
              if (*(int *)(systemDataIndexPtr[1] + ThreadContextFlag * 0x10) == 0) {
                pointerToInteger2 = (int *)(systemDataIndexPtr[1] + ThreadContextFlag * 0x10);
                LOCK();
                isSystemBusy = *pointerToInteger2 == 0;
                if (isSystemBusy) {
                  *pointerToInteger2 = systemResourceHandleD;
                }
                UNLOCK();
                if (isSystemBusy) {
                  *(long long *)(systemDataIndexPtr[1] + 8 + ThreadContextFlag * 0x10) = SystemThreadFlags;
                  return SystemThreadFlags;
                }
              }
              StringIteratorPointer = ThreadContextFlag + 1;
            } while( true );
          }
          systemDataIndexPtr = *(ulong long **)(systemResourceCounter + 0x30);
        } while (systemStackFramePtr < *systemDataIndexPtr >> 1);
        LOCK();
        SystemDataPointer = (uint *)(systemResourceCounter + 600);
        resourceAllocationContext = *SystemDataPointer;
        *SystemDataPointer = *SystemDataPointer | 1;
        UNLOCK();
      } while ((resourceAllocationContext & 1) != 0);
      presourceAddress = *(ulong long **)(systemResourceCounter + 0x30);
      systemDataIndexPtr = presourceAddress;
      ThreadContextFlag = *presourceAddress;
    } while (systemStackFramePtr < *presourceAddress >> 1);
    do {
      currentThreadId = ThreadContextFlag;
      ThreadContextFlag = currentThreadId * 2;
    } while ((currentThreadId & SINE_LOOKUP_TABLE_SIZEffffffffffff) <= systemStackFramePtr);
    systemDataIndexPtr = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId * 0x20 + 0x1f,10);
    if (systemDataIndexPtr == (ulong long *)0x0) break;
    *systemDataIndexPtr = ThreadContextFlag;
    systemDataIndexPtr[1] = (ulong long)(-(int)(systemDataIndexPtr + 3) & 7) + (long long)(systemDataIndexPtr + 3);
    SystemThreadFlags = systemAllocationOffset;
    for (; ThreadContextFlag != 0; ThreadContextFlag = ThreadContextFlag - 1) {
      *(long long *)(SystemThreadFlags + 8 + systemDataIndexPtr[1]) = systemAllocationOffset;
      *(uint32_t *)(SystemThreadFlags + systemDataIndexPtr[1]) = OperationCode;
      SystemThreadFlags = SystemThreadFlags + 0x10;
    }
    systemDataIndexPtr[2] = (ulong long)presourceAddress;
    *(ulong long **)(systemResourceCounter + 0x30) = systemDataIndexPtr;
  }
  LOCK();
  *(long long *)(systemResourceCounter + 0x38) = *(long long *)(systemResourceCounter + 0x38) + -1;
  UNLOCK();
  *(uint32_t *)(systemResourceCounter + 600) = OperationCode;
  return 0;
}




/**
 * @brief 创建和初始化系统线程对象
 * 
 * 该函数负责创建和初始化系统线程对象，根据不同的配置数据
 * 创建不同类型的线程对象，并进行相应的初始化设置。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针，决定创建的线程对象类型
 * @param AdditionalParameter 附加参数指针，用于返回创建状态
 * @return 创建的线程对象指针，创建失败时返回NULL
 * 
 *FUN_18005ee30：CreateAndInitializeSystemThreadObject
 */
void* * CreateAndInitializeSystemThreadObject(long long* SystemResourceManager,char ConfigurationDataPointer,uint8_t *AdditionalParameter)

{
  long long *PrimaryResourcePointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  ulong long ThreadContextFlag;
  ulong long OperationCode;
  bool isSystemBusy;
  
  resourceEntryPointer = (void* *)0x0;
  SystemHashEntryPointer = (void* *)*SystemResourceManager;
  do {
    if (SystemHashEntryPointer == (void* *)0x0) {
      *AdditionalParameter = 0;
      if (ConfigurationDataPointer == '\0') {
        SystemHashEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,10,0,InvalidHandleValue);
        if (SystemHashEntryPointer == (void* *)0x0) {
          return (void* *)0x0;
        }
        SystemHashEntryPointer[1] = 0;
        *(uint8_t *)(SystemHashEntryPointer + 2) = 0;
        SystemHashEntryPointer[3] = 0;
        *SystemHashEntryPointer = &SystemFunctionPointerB;
        SystemHashEntryPointer[4] = 0;
        SystemHashEntryPointer[5] = 0;
        SystemHashEntryPointer[6] = 0;
        SystemHashEntryPointer[7] = 0;
        SystemHashEntryPointer[8] = 0;
        *(uint8_t *)(SystemHashEntryPointer + 9) = 0;
        SystemHashEntryPointer[10] = SystemResourceManager;
        *SystemHashEntryPointer = &SystemFunctionPointerC;
        SystemHashEntryPointer[0xb] = 0x20;
        SystemHashEntryPointer[0xc] = 0;
        ExpandSystemResourceAllocator(SystemHashEntryPointer);
      }
      else {
        SystemHashEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x88,10,0,InvalidHandleValue);
        if (SystemHashEntryPointer == (void* *)0x0) {
          return (void* *)0x0;
        }
        SystemHashEntryPointer[1] = 0;
        *(uint8_t *)(SystemHashEntryPointer + 2) = 0;
        SystemHashEntryPointer[3] = 0;
        *SystemHashEntryPointer = &SystemFunctionPointerB;
        SystemHashEntryPointer[4] = 0;
        SystemHashEntryPointer[5] = 0;
        SystemHashEntryPointer[6] = 0;
        SystemHashEntryPointer[7] = 0;
        SystemHashEntryPointer[8] = 0;
        *(uint8_t *)(SystemHashEntryPointer + 9) = 1;
        SystemHashEntryPointer[10] = SystemResourceManager;
        *SystemHashEntryPointer = &SystemFunctionPointerD;
        SystemHashEntryPointer[0xb] = 0;
        SystemHashEntryPointer[0xc] = 0;
        SystemHashEntryPointer[0xd] = 0x10;
        SystemHashEntryPointer[0xe] = 0;
        SystemHashEntryPointer[0xf] = 0;
        SystemHashEntryPointer[0x10] = 0;
        ThreadContextFlag = SystemResourceManager[4] - 1U | SystemResourceManager[4] - 1U >> 1;
        ThreadContextFlag = ThreadContextFlag | ThreadContextFlag >> 2;
        ThreadContextFlag = ThreadContextFlag | ThreadContextFlag >> 4;
        OperationCode = 1;
        do {
          ThreadContextFlag = ThreadContextFlag | ThreadContextFlag >> (((byte)OperationCode & 7) << 3);
          OperationCode = OperationCode * 2;
        } while (OperationCode < 8);
        OperationCode = ThreadContextFlag + 1 >> 1;
        if ((ulong long)SystemHashEntryPointer[0xd] < OperationCode) {
          SystemHashEntryPointer[0xd] = OperationCode;
        }
        InitializeSystemComponent(SystemHashEntryPointer,0);
      }
      SystemThreadContext = resourceEntryPointer;
      if (SystemHashEntryPointer != (void* *)0x0) {
        LOCK();
        *(int *)(SystemResourceManager + 1) = (int)SystemResourceManager[1] + 1;
        UNLOCK();
        ResourceDataOffset = *SystemResourceManager;
        do {
          SystemThreadContext = (void* *)(ResourceDataOffset + 8);
          if (ResourceDataOffset == 0) {
            SystemThreadContext = resourceEntryPointer;
          }
          SystemHashEntryPointer[1] = SystemThreadContext;
          LOCK();
          SystemBufferAddress = *SystemResourceManager;
          isSystemBusy = ResourceDataOffset == SystemBufferAddress;
          if (isSystemBusy) {
            *SystemResourceManager = (long long)SystemHashEntryPointer;
            SystemBufferAddress = ResourceDataOffset;
          }
          UNLOCK();
          ResourceDataOffset = SystemBufferAddress;
          SystemThreadContext = SystemHashEntryPointer;
        } while (!isSystemBusy);
      }
      return SystemThreadContext;
    }
    if ((*(char *)(SystemHashEntryPointer + 2) != '\0') && (*(char *)(SystemHashEntryPointer + 9) == ConfigurationDataPointer)) {
      LOCK();
      isSystemBusy = *(char *)(SystemHashEntryPointer + 2) == '\x01';
      if (isSystemBusy) {
        *(char *)(SystemHashEntryPointer + 2) = '\0';
      }
      UNLOCK();
      if (isSystemBusy) {
        *AdditionalParameter = 1;
        return SystemHashEntryPointer;
      }
    }
    PrimaryResourcePointer = SystemHashEntryPointer + 1;
    SystemHashEntryPointer = (void* *)(*PrimaryResourcePointer + -8);
    if (*PrimaryResourcePointer == 0) {
      SystemHashEntryPointer = resourceEntryPointer;
    }
  } while( true );
}



/**
 * @brief 执行系统资源配置操作
 * 
 * 该函数负责执行系统资源的配置操作，包括资源状态检查、
 * 配置标志处理和资源分配操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 操作结果指针
 * 
 *FUN_18005f040：ExecuteSystemResourceConfigurationOperation
 */
void* ExecuteSystemResourceConfigurationOperation(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ulong long SystemOperationStatus;
  char validationStatusFlag;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  ulong long *SystemThreadContext;
  ulong long ResourceHash;
  ulong long ThreadContextFlag;
  
  SystemOperationStatus = *(ulong long *)(SystemResourceManager + 0x20);
  ThreadContextFlag = (ulong long)((uint)SystemOperationStatus & BIT_MASK_32_BIT);
  if ((SystemOperationStatus & BIT_MASK_32_BIT) == 0) {
    ResourceHash = 0;
    if (*(long long *)(SystemResourceManager + 0x40) == 0) {
ResourceOperationLoop:
      if ((((*(long long *)(SystemResourceManager + 0x28) - SystemOperationStatus) - 0x20 < 0x8000000000000001) ||
          (((*(long long *)(SystemResourceManager + 0x80) == 0 ||
            (*(long long *)(SystemResourceManager + 0x60) == *(long long *)(SystemResourceManager + 0x68))) &&
           (SystemOperationResult = InitializeSystemComponent(SystemResourceManager,*(void* *)(SystemResourceManager + 0x60),ThreadContextFlag,ConfigurationFlag,
                                  0xfffffffffffffffe), SystemOperationResult == '\0')))) ||
         (ResourceDataOffset = GetSystemResourceOffset(*(void* *)(SystemResourceManager + 0x50)), ResourceDataOffset == 0)) {
        return 0;
      }
      do {
        *(uint8_t *)(ResourceDataOffset + 0x110 + ResourceHash) = 0;
        ResourceHash = ResourceHash + 1;
      } while (ResourceHash != 0x20);
      if (*(long long *)(SystemResourceManager + 0x40) == 0) {
        *(long long *)(ResourceDataOffset + 0x100) = ResourceDataOffset;
      }
      else {
        *(void* *)(ResourceDataOffset + 0x100) = *(void* *)(*(long long *)(SystemResourceManager + 0x40) + 0x100);
        *(long long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100) = ResourceDataOffset;
      }
      *(long long *)(SystemResourceManager + 0x40) = ResourceDataOffset;
      *(long long *)(SystemResourceManager + 0x60) = *(long long *)(SystemResourceManager + 0x60) + 1;
    }
    else {
      resourceAddress = ResourceHash;
      do {
        if (*(char *)(*(long long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100) + 0x110 + resourceAddress) == '\0')
        goto ResourceOperationLoop;
        resourceAddress = resourceAddress + 1;
      } while (resourceAddress < 0x20);
      ResourceDataOffset = *(long long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100);
      *(long long *)(SystemResourceManager + 0x40) = ResourceDataOffset;
      do {
        *(uint8_t *)(ResourceDataOffset + 0x110 + ResourceHash) = 0;
        ResourceHash = ResourceHash + 1;
      } while (ResourceHash != 0x20);
    }
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    **(long long **)(SystemResourceManager + 0x40) = (long long)ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
    SystemThreadContext = (ulong long *)
             (*(long long *)(SystemResourceManager + 0x70) * 0x10 +
             *(long long *)(*(long long *)(SystemResourceManager + 0x58) + 0x10));
    *SystemThreadContext = SystemOperationStatus;
    SystemThreadContext[1] = *(ulong long *)(SystemResourceManager + 0x40);
    *(void* *)(*(long long *)(SystemResourceManager + 0x58) + 8) = *(void* *)(SystemResourceManager + 0x70);
    *(ulong long *)(SystemResourceManager + 0x70) =
         *(long long *)(SystemResourceManager + 0x68) - 1U & *(long long *)(SystemResourceManager + 0x70) + 1U;
  }
  else {
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    *(long long **)(*(long long *)(SystemResourceManager + 0x40) + ThreadContextFlag * 8) = ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
  }
  *(ulong long *)(SystemResourceManager + 0x20) = SystemOperationStatus + 1;
  return 1;
}



/**
 * @brief 处理系统资源句柄操作
 * 
 * 该函数负责处理系统资源句柄的操作，包括句柄的创建、配置和管理。
 * 主要用于系统资源句柄的生命周期管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 操作结果指针
 * 
 *FUN_18005f220：ProcessSystemResourceHandleOperation
 */
void* ProcessSystemResourceHandleOperation(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  ulong long SystemOperationStatus;
  char validationStatusFlag;
  long long *SystemResourceOffsetPointer;
  ulong long resourceAddress;
  ulong long SystemParameterPointer;
  long long *pStackValue1;
  
  SystemOperationStatus = *(ulong long *)(SystemResourceManager + 0x20);
  resourceAddress = (ulong long)((uint)SystemOperationStatus & BIT_MASK_32_BIT);
  if ((SystemOperationStatus & BIT_MASK_32_BIT) != 0) {
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    *(long long **)(*(long long *)(SystemResourceManager + 0x40) + resourceAddress * 8) = ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
ResourceProcessingLoop:
    *(ulong long *)(SystemResourceManager + 0x20) = SystemOperationStatus + 1;
    return 1;
  }
  if (0x8000000000000000 < (*(long long *)(SystemResourceManager + 0x28) - SystemOperationStatus) - 0x20) {
    SystemOperationResult = ConfigureSystemSettings(SystemResourceManager,&stackValue18,SystemOperationStatus,resourceAddress,InvalidHandleValue);
    if (validationStatusFlag != '\0') {
      SystemResourceOffsetPointer = (long long *)GetResourceOffsetPointer(*(void* *)(SystemResourceManager + 0x50));
      if (SystemResourceOffsetPointer != (long long *)0x0) {
        SystemResourceOffsetPointer[0x21] = 0;
        ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
        *SystemResourceOffsetPointer = (long long)ConfigurationDataPointer;
        if (ConfigurationDataPointer != (long long *)0x0) {
          pStackValue1 = SystemResourceOffsetPointer;
          (**(code **)(*ConfigurationDataPointer + 0x28))();
        }
        *(long long **)(SystemParameterPointer + 8) = SystemResourceOffsetPointer;
        *(long long **)(SystemResourceManager + 0x40) = SystemResourceOffsetPointer;
        goto ResourceProcessingLoop;
      }
      SystemResourceOffsetPointer = *(long long **)(SystemResourceManager + 0x60);
      SystemResourceOffsetPointer[1] = *SystemResourceOffsetPointer - 1U & SystemResourceOffsetPointer[1] - 1U;
      *(void* *)(SystemParameterPointer + 8) = 0;
    }
  }
  return 0;
}




/**
 * @brief 扩展系统资源分配器
 * 
 * 该函数负责扩展系统资源分配器，增加资源容量和处理能力。
 * 主要用于系统资源的动态扩展和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 扩展后的资源指针
 * 
 *FUN_18005f340：ExpandSystemResourceAllocator
 */
void* ExpandSystemResourceAllocator(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  void** SystemDataPointer;
  long long SystemThreadHandle;
  void* resourceAllocationContext;
  void* *presourceAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  void** SystemCurrentNode;
  void** SystemNextNode;
  long long resourceCounter;
  
  SystemThreadHandle = *(long long *)(SystemResourceManager + 0x68);
  *(long long *)(SystemResourceManager + 0x68) = SystemThreadHandle * 2;
  presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadHandle * 0x20 + 0x27,10);
  if (presourceAddress == (void* *)0x0) {
    *(ulong long *)(SystemResourceManager + 0x68) = *(ulong long *)(SystemResourceManager + 0x68) >> 1;
    return 0;
  }
  resourceCounter = 0;
  hashTableNode = (void* *)((ulong long)(-(int)(presourceAddress + 4) & 7) + (long long)(presourceAddress + 4));
  if (*(long long *)(SystemResourceManager + 0x60) != 0) {
    currentThreadId = *(long long *)(SystemResourceManager + 0x70) - *(long long *)(SystemResourceManager + 0x60) & SystemThreadHandle - 1U;
    SystemThreadStorage = hashTableNode;
    do {
      resourceCounter = resourceCounter + 1;
      ResourceHash = currentThreadId + 1 & SystemThreadHandle - 1U;
      SystemDataPointer = (void* *)(*(long long *)(SystemResourceManager + 0x78) + currentThreadId * 0x10);
      resourceAllocationContext = SystemDataPointer[1];
      *SystemThreadStorage = *SystemDataPointer;
      SystemThreadStorage[1] = resourceAllocationContext;
      currentThreadId = ResourceHash;
      SystemThreadStorage = SystemThreadStorage + 2;
    } while (ResourceHash != *(ulong long *)(SystemResourceManager + 0x70));
  }
  *presourceAddress = *(void* *)(SystemResourceManager + 0x68);
  presourceAddress[1] = ConfigurationDataPointer + -1;
  presourceAddress[2] = hashTableNode;
  resourceAllocationContext = *(void* *)(SystemResourceManager + 0x80);
  presourceAddress[3] = resourceAllocationContext;
  *(long long *)(SystemResourceManager + 0x70) = resourceCounter;
  *(void* **)(SystemResourceManager + 0x78) = hashTableNode;
  *(void* **)(SystemResourceManager + 0x80) = presourceAddress;
  *(void* **)(SystemResourceManager + 0x58) = presourceAddress;
  return CONCAT71((int7)((ulong long)resourceAllocationContext >> 8),1);
}




/**
 * @brief 系统资源分配器扩展函数
 * 
 * 该函数负责扩展系统资源分配器的容量，创建新的线程对象并重新分配资源
 * 用于系统资源管理中的动态扩容操作
 * 
 * @param SystemResourceManager 系统资源指针，包含当前资源分配器状态
 * @return 扩展后的资源指针，失败时返回0
 * 
 *FUN_18005f430：ExpandSystemResourceAllocator
 */
void* * ExpandSystemResourceAllocator(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  ulong long resourceCreationFlags;
  long long ResourceDataOffset;
  void* *presourceAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  ulong long ThreadContextFlag;
  long long SystemMemoryAddress;
  long long resourceCounter;
  void* *SystemDataPointer0;
  void* *ThreadLocalStorage;
  
  PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x60);
  if (PrimaryResourcePointer == (long long *)0x0) {
    ResourceDataOffset = *(long long *)(SystemResourceManager + 0x58);
    SystemMemoryAddress = ResourceDataOffset;
    resourceCounter = 0;
  }
  else {
    SystemMemoryAddress = *PrimaryResourcePointer;
    ResourceDataOffset = *(long long *)(SystemResourceManager + 0x58);
    resourceCounter = SystemMemoryAddress;
  }
  presourceAddress = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(ResourceDataOffset + SystemMemoryAddress * 2) * 8 + 0x36,10);
  SystemDataPointer0 = presourceAddress;
  if (presourceAddress != (void* *)0x0) {
    ThreadLocalStorage = (void* *)((ulong long)(-(int)(presourceAddress + 5) & 7) + (long long)(presourceAddress + 5));
    SystemDataPointer0 = (void* *)
              ((ulong long)(-(int)(ThreadLocalStorage + SystemMemoryAddress * 2) & 7) + (long long)(ThreadLocalStorage + SystemMemoryAddress * 2));
    if (PrimaryResourcePointer != (long long *)0x0) {
      resourceCreationFlags = PrimaryResourcePointer[1];
      ThreadContextFlag = resourceCreationFlags;
      resourceEntryPointer = SystemDataPointer0;
      do {
        ThreadContextFlag = *PrimaryResourcePointer - 1U & ThreadContextFlag + 1;
        *resourceEntryPointer = *(void* *)(PrimaryResourcePointer[3] + ThreadContextFlag * 8);
        resourceEntryPointer = resourceEntryPointer + 1;
      } while (ThreadContextFlag != resourceCreationFlags);
    }
    if (SystemMemoryAddress != 0) {
      resourceEntryPointer = SystemDataPointer0 + resourceCounter;
      SystemThreadContext = ThreadLocalStorage;
      do {
        *SystemThreadContext = 1;
        *resourceEntryPointer = SystemThreadContext;
        resourceEntryPointer = resourceEntryPointer + 1;
        SystemThreadContext = SystemThreadContext + 2;
        SystemMemoryAddress = SystemMemoryAddress + -1;
      } while (SystemMemoryAddress != 0);
    }
    presourceAddress[4] = PrimaryResourcePointer;
    presourceAddress[2] = ThreadLocalStorage;
    presourceAddress[3] = SystemDataPointer0;
    *presourceAddress = *(void* *)(SystemResourceManager + 0x58);
    presourceAddress[1] = *(long long *)(SystemResourceManager + 0x58) - 1U & resourceCounter - 1U;
    SystemDataPointer0 = (void* *)CONCAT71((int7)(resourceCounter - 1U >> 8),1);
    *(void* **)(SystemResourceManager + 0x60) = presourceAddress;
    *(long long *)(SystemResourceManager + 0x58) = *(long long *)(SystemResourceManager + 0x58) << 1;
  }
  return SystemDataPointer0;
}



/**
 * @brief 系统资源分配器扩展函数B
 * 
 * 该函数负责扩展系统资源分配器的容量，使用寄存器变量进行高效的资源分配
 * 用于系统资源管理中的动态扩容操作
 * 
 * @note 这是一个系统资源分配器扩展函数，使用寄存器变量进行优化
 * 
 *FUN_18005f490：ExpandSystemResourceAllocatorB
 */
void* ExpandSystemResourceAllocatorB(void)

{
  ulong long SystemOperationStatus;
  long long in_RAX;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  ulong long resourceAddress;
  long long memoryBlockAddress;
  long long systemStackFramePtr;
  long long StringIteratorPointer;
  long long *systemDataIndexPtr;
  void* *in_R9;
  void* SystemThreadContext;
  void** SystemRootNode;
  
  resourceEntryPointer = (void* *)((ulong long)(-(int)in_RAX & 7) + in_RAX);
  SystemThreadContext = (void* *)
           ((ulong long)(-(int)(resourceEntryPointer + memoryBlockAddress * 2) & 7) + (long long)(resourceEntryPointer + memoryBlockAddress * 2));
  if (systemDataIndexPtr != (long long *)0x0) {
    SystemOperationStatus = systemDataIndexPtr[1];
    resourceAddress = SystemOperationStatus;
    SystemHashNodeData = SystemThreadContext;
    do {
      resourceAddress = *systemDataIndexPtr - 1U & resourceAddress + 1;
      *SystemHashNodeData = *(void* *)(systemDataIndexPtr[3] + resourceAddress * 8);
      SystemHashNodeData = SystemHashNodeData + 1;
    } while (resourceAddress != SystemOperationStatus);
  }
  if (memoryBlockAddress != 0) {
    SystemHashNodeData = SystemThreadContext + systemStackFramePtr;
    SystemHashEntryPointer = resourceEntryPointer;
    do {
      *SystemHashEntryPointer = 1;
      *SystemHashNodeData = SystemHashEntryPointer;
      SystemHashNodeData = SystemHashNodeData + 1;
      SystemHashEntryPointer = SystemHashEntryPointer + 2;
      memoryBlockAddress = memoryBlockAddress + -1;
    } while (memoryBlockAddress != 0);
  }
  in_R9[4] = systemDataIndexPtr;
  in_R9[2] = resourceEntryPointer;
  in_R9[3] = SystemThreadContext;
  *in_R9 = *(void* *)(StringIteratorPointer + 0x58);
  in_R9[1] = *(long long *)(StringIteratorPointer + 0x58) - 1U & systemStackFramePtr - 1U;
  *(void* **)(StringIteratorPointer + 0x60) = in_R9;
  *(long long *)(StringIteratorPointer + 0x58) = *(long long *)(StringIteratorPointer + 0x58) << 1;
  return CONCAT71((int7)(systemStackFramePtr - 1U >> 8),1);
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 *FUN_18005f54c：SystemNoOperation
 */
void SystemNoOperation(void)

{
  return;
}




/**
 * @brief 系统资源数据处理函数
 * 
 * 该函数负责处理系统资源数据，包括内存分配、数据操作和资源管理。
 * 该函数包含复杂的内存操作和数据处理逻辑。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 处理结果状态码
 * 
 *FUN_18005f570：ProcessSystemResourceData
 */
ulong long ProcessSystemResourceData(long long SystemResourceManager,long long *ConfigurationDataPointer,long long AdditionalParameter)

{
  uint *systemDataPointer1;
  uint32_t *systemDataPointer2;
  uint SystemOperationStatusValue1;
  uint SystemOperationStatusValue2;
  long long *localSystemMemoryPointer;
  uint32_t systemMemoryOffset1;
  uint32_t systemMemoryOffset2;
  uint32_t systemMemoryOffset3;
  long long *localResourceDataPointer;
  ulong long systemResourceValue1;
  long long SystemMemoryAddress1;
  ulong long systemResourceValue2;
  ulong long systemResourceValue3;
  ulong long systemResourceValue4;
  ulong long systemResourceValue5;
  ulong long *systemResourcePointer1;
  ulong long systemResourceValue6;
  ulong long systemResourceValue7;
  ulong long systemResourceValue8;
  uint32_t *systemDataPointer3;
  uint32_t *systemDataPointer4;
  long long systemHandle1;
  long long systemHandle2;
  ulong long systemResourceValue9;
  bool operationStatus;
  ulong long stackParameter1;
  ulong long stackParameter2;
  
  SecurityParameter = *(ulong long *)(SystemResourceManager + 0x20);
  SystemOperationStatus3 = *(ulong long *)(SystemResourceManager + 0x40);
  SystemOperationStatusFlags = *(ulong long *)(SystemResourceManager + 0x70);
  SystemSecondaryStatus = *(ulong long *)(SystemResourceManager + 0x60);
  SystemOperationStatus8 = 0;
  SystemContextPointer = AdditionalParameter + SecurityParameter;
  SystemUnsignedFlag78 = SecurityParameter - 1 & MAX_UNSIGNED_32_BITffffffe0;
  SystemThreadHandle4 = (SystemContextPointer - 1 & MAX_UNSIGNED_32_BITffffffe0) - SystemUnsignedFlag78;
  SystemOperationFlags = SystemOperationStatus8;
  ResourceCreationFlags = SystemOperationStatus8;
  SystemOperationStatus5 = SystemOperationStatus3;
  if (SystemThreadHandle4 != 0) {
    do {
      EncryptionValue68 = SystemOperationStatusFlags;
      ResourceCreationFlags = SystemOperationFlags;
      if ((*(long long *)(SystemResourceManager + 0x40) == 0) ||
         (SystemOperationStatus5 = *(ulong long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100), SystemOperationStatus4 = SystemOperationStatus8,
         SystemOperationStatus5 == SystemOperationFlags)) goto joined_r0x00018005f6ef;
      do {
        if (*(char *)(SystemOperationStatus5 + 0x110 + SystemOperationStatus4) == '\0') goto joined_r0x00018005f6ef;
        SystemOperationStatus4 = SystemOperationStatus4 + 1;
      } while (SystemOperationStatus4 < 0x20);
      SystemUnsignedFlag78 = SystemUnsignedFlag78 + 0x20;
      ResourceCreationFlags = *(ulong long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100);
      *(ulong long *)(SystemResourceManager + 0x40) = ResourceCreationFlags;
      SystemStringTemplatePointer = (ulong long *)
                (*(long long *)(*(long long *)(SystemResourceManager + 0x58) + 0x10) +
                *(long long *)(SystemResourceManager + 0x70) * 0x10);
      *SystemStringTemplatePointer = SystemUnsignedFlag78;
      SystemStringTemplatePointer[1] = *(ulong long *)(SystemResourceManager + 0x40);
      *(ulong long *)(SystemResourceManager + 0x70) =
           *(long long *)(SystemResourceManager + 0x68) - 1U & *(long long *)(SystemResourceManager + 0x70) + 1U;
      if (SystemOperationFlags != 0) {
        ResourceCreationFlags = SystemOperationFlags;
      }
      SystemThreadHandle4 = SystemThreadHandle4 + -0x20;
      SystemOperationFlags = ResourceCreationFlags;
    } while (SystemThreadHandle4 != 0);
SystemHandleCheck:
    SystemThreadHandle4 = 0;
    SystemOperationStatusFlags = ResourceCreationFlags;
    while( true ) {
      do {
        *(uint8_t *)(SystemOperationStatusFlags + 0x110 + SystemThreadHandle4) = 0;
        SystemThreadHandle4 = SystemThreadHandle4 + 1;
      } while (SystemThreadHandle4 != 0x20);
      SystemOperationStatus5 = *(ulong long *)(SystemResourceManager + 0x40);
      if (SystemOperationStatusFlags == SystemOperationStatus5) break;
      SystemOperationStatusFlags = *(ulong long *)(SystemOperationStatusFlags + 0x100);
      SystemThreadHandle4 = 0;
    }
  }
  *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus3;
  if ((SecurityParameter & BIT_MASK_32_BIT) == 0) {
    if (ResourceCreationFlags != 0) {
      SystemOperationStatus3 = ResourceCreationFlags;
    }
    *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus3;
  }
  while( true ) {
    SystemOperationStatusFlags = (SecurityParameter & MAX_UNSIGNED_32_BITffffffe0) + 0x20;
    SystemOperationStatus3 = SystemContextPointer;
    if (SystemContextPointer - SystemOperationStatusFlags < 0x8000000000000001) {
      SystemOperationStatus3 = SystemOperationStatusFlags;
    }
    for (; SecurityParameter != SystemOperationStatus3; SecurityParameter = SecurityParameter + 1) {
      SystemLocalContextPointer = (long long *)*ConfigurationDataPointer;
      *(long long **)(*(long long *)(SystemResourceManager + 0x40) + (ulong long)((uint)SecurityParameter & BIT_MASK_32_BIT) * 8) = SystemLocalContextPointer;
      if (SystemLocalContextPointer != (long long *)0x0) {
        (**(code **)(*SystemLocalContextPointer + 0x28))();
      }
      ConfigurationDataPointer = ConfigurationDataPointer + 1;
    }
    SystemOperationStatus3 = *(ulong long *)(SystemResourceManager + 0x40);
    if (SystemOperationStatus3 == SystemOperationStatus5) break;
    *(void* *)(SystemResourceManager + 0x40) = *(void* *)(SystemOperationStatus3 + 0x100);
  }
  if (ResourceCreationFlags != 0) {
    SystemOperationStatus3 = *(long long *)(SystemResourceManager + 0x68) - 1;
    *(ulong long *)(*(long long *)(SystemResourceManager + 0x58) + 8) = *(long long *)(SystemResourceManager + 0x70) - 1U & SystemOperationStatus3;
  }
  *(ulong long *)(SystemResourceManager + 0x20) = SystemContextPointer;
  return CONCAT71((int7)(SystemOperationStatus3 >> 8),1);
joined_r0x00018005f6ef:
  if (SystemThreadHandle4 == 0) goto SystemHandleCheck;
  SystemThreadHandle4 = SystemThreadHandle4 + -0x20;
  SystemUnsignedFlag78 = SystemUnsignedFlag78 + 0x20;
  SystemOperationStatus5 = (*(long long *)(SystemResourceManager + 0x28) - SystemUnsignedFlag78) - 0x20;
  SystemLocalContextPointer = (long long *)(SystemResourceManager + 0x68);
  if ((*(long long *)(SystemResourceManager + 0x80) == 0) || (*(long long *)(SystemResourceManager + 0x60) == *SystemLocalContextPointer)) {
    if (0x8000000000000000 < SystemOperationStatus5) {
      SystemResourceDataIndex = *SystemLocalContextPointer;
      *SystemLocalContextPointer = SystemResourceDataIndex * 2;
      presourceCounter = (long long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemResourceDataIndex * 0x20 + 0x27,10);
      if (presourceCounter != (long long *)0x0) {
        SystemHashEntryPointer2 = (uint32_t *)((ulong long)(-(int)(presourceCounter + 4) & 7) + (long long)(presourceCounter + 4));
        SystemThreadHandle3 = 0;
        if (*(long long *)(SystemResourceManager + 0x60) != 0) {
          SystemOperationStatusFlags = *(long long *)(SystemResourceManager + 0x70) - *(long long *)(SystemResourceManager + 0x60) & SystemResourceDataIndex - 1U;
          SystemHashEntryPointer1 = SystemHashEntryPointer2;
          do {
            SystemHashEntryPointer = (uint32_t *)(*(long long *)(SystemResourceManager + 0x78) + SystemOperationStatusFlags * 0x10);
            ResourceHash = SystemHashEntryPointer[1];
            ThreadContextFlag = SystemHashEntryPointer[2];
            OperationCode = SystemHashEntryPointer[3];
            *SystemHashEntryPointer1 = *SystemHashEntryPointer;
            SystemHashEntryPointer1[1] = ResourceHash;
            SystemHashEntryPointer1[2] = ThreadContextFlag;
            SystemHashEntryPointer1[3] = OperationCode;
            SystemThreadHandle3 = SystemThreadHandle3 + 1;
            SystemHashEntryPointer1 = SystemHashEntryPointer1 + 4;
            SystemOperationStatusFlags = SystemOperationStatusFlags + 1 & SystemResourceDataIndex - 1U;
          } while (SystemOperationStatusFlags != *(ulong long *)(SystemResourceManager + 0x70));
        }
        *presourceCounter = *SystemLocalContextPointer;
        presourceCounter[1] = SystemSecondaryStatus - 1;
        presourceCounter[2] = (long long)SystemHashEntryPointer2;
        presourceCounter[3] = *(long long *)(SystemResourceManager + 0x80);
        *(long long *)(SystemResourceManager + 0x70) = SystemThreadHandle3;
        *(uint32_t **)(SystemResourceManager + 0x78) = SystemHashEntryPointer2;
        *(long long **)(SystemResourceManager + 0x80) = presourceCounter;
        *(long long **)(SystemResourceManager + 0x58) = presourceCounter;
        SystemOperationStatusFlags = SystemSecondaryStatus;
        EncryptionValue68 = SystemSecondaryStatus;
        goto SystemValueProcessing;
      }
      *(ulong long *)(SystemResourceManager + 0x68) = *(ulong long *)(SystemResourceManager + 0x68) >> 1;
      SystemOperationStatusFlags = EncryptionValue68;
    }
SystemValueValidation:
    *(ulong long *)(SystemResourceManager + 0x70) = SystemOperationStatusFlags;
    *(ulong long *)(SystemResourceManager + 0x60) = SystemSecondaryStatus;
    if (SystemOperationStatus3 == 0) {
      SystemOperationStatus3 = ResourceCreationFlags;
    }
    *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus3;
SystemValueCheck:
    return SystemSecondaryStatus & MAX_UNSIGNED_32_BITffffff00;
  }
  if (SystemOperationStatus5 < 0x8000000000000001) goto SystemValueValidation;
SystemValueProcessing:
  SystemResourceDataIndex = *(long long *)(SystemResourceManager + 0x50);
  if (*(ulong long *)(SystemResourceDataIndex + 0x20) <= *(ulong long *)(SystemResourceDataIndex + 0x10)) {
ResourceAllocationLoop:
    SystemOperationFlags = *(ulong long *)(SystemResourceDataIndex + 0x28);
ResourceOperationCheck:
    SystemOperationStatus5 = SystemOperationFlags;
    if (SystemOperationStatus5 != 0) {
      SystemDataPointer = (uint *)(SystemOperationStatus5 + 0x130);
      resourceAddress = *SystemDataPointer;
      if ((resourceAddress & SINE_LOOKUP_TABLE_SIZEffff) == 0) {
ResourceAllocationRetry:
        SystemOperationFlags = *(ulong long *)(SystemResourceDataIndex + 0x28);
      }
      else {
        LOCK();
        resourceAllocationContext = *SystemDataPointer;
        if (resourceAddress == resourceAllocationContext) {
          *SystemDataPointer = resourceAddress + 1;
        }
        UNLOCK();
        if (resourceAddress != resourceAllocationContext) goto ResourceAllocationRetry;
        LOCK();
        SystemOperationFlags = *(ulong long *)(SystemResourceDataIndex + 0x28);
        isSystemActive6 = SystemOperationStatus5 == SystemOperationFlags;
        if (isSystemActive6) {
          *(ulong long *)(SystemResourceDataIndex + 0x28) = *(ulong long *)(SystemOperationStatus5 + 0x138);
          SystemOperationFlags = SystemOperationStatus5;
        }
        UNLOCK();
        if (isSystemActive6) {
          LOCK();
          *SystemDataPointer = *SystemDataPointer - 2;
          UNLOCK();
          if (SystemOperationStatus5 != 0) goto ResourceInitializationComplete;
          goto ResourceCleanupComplete;
        }
        LOCK();
        resourceAddress = *SystemDataPointer;
        *SystemDataPointer = *SystemDataPointer - 1;
        UNLOCK();
        if (resourceAddress == 0x80000001) {
          SystemOperationStatus8 = *(ulong long *)(SystemResourceDataIndex + 0x28);
          do {
            *(ulong long *)(SystemOperationStatus5 + 0x138) = SystemOperationStatus8;
            *SystemDataPointer = 1;
            LOCK();
            SystemOperationStatus4 = *(ulong long *)(SystemResourceDataIndex + 0x28);
            isSystemActive6 = SystemOperationStatus8 == SystemOperationStatus4;
            if (isSystemActive6) {
              *(ulong long *)(SystemResourceDataIndex + 0x28) = SystemOperationStatus5;
              SystemOperationStatus4 = SystemOperationStatus8;
            }
            UNLOCK();
            if (isSystemActive6) break;
            LOCK();
            resourceAddress = *SystemDataPointer;
            *SystemDataPointer = *SystemDataPointer + 0x7fffffff;
            UNLOCK();
            SystemOperationStatus8 = SystemOperationStatus4;
          } while (resourceAddress == 1);
        }
      }
      goto ResourceOperationCheck;
    }
ResourceCleanupComplete:
    SystemOperationStatus5 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x148,CONCAT71((int7)(SystemOperationStatus5 >> 8),10));
    if (SystemOperationStatus5 != 0) {
      *(void* *)(SystemOperationStatus5 + 0x100) = 0;
      *(void* *)(SystemOperationStatus5 + 0x108) = 0;
      *(uint32_t *)(SystemOperationStatus5 + 0x130) = 0;
      *(void* *)(SystemOperationStatus5 + 0x138) = 0;
      *(void*2 *)(SystemOperationStatus5 + 0x140) = 0x100;
      goto ResourceInitializationComplete;
    }
ResourceConfigurationComplete:
    *(ulong long *)(SystemResourceManager + 0x70) = SystemOperationStatusFlags;
    *(ulong long *)(SystemResourceManager + 0x60) = SystemSecondaryStatus;
    SystemSecondaryStatus = SystemOperationStatus3;
    if (SystemOperationStatus3 == 0) {
      SystemSecondaryStatus = ResourceCreationFlags;
    }
    *(ulong long *)(SystemResourceManager + 0x40) = SystemSecondaryStatus;
    goto SystemValueCheck;
  }
  LOCK();
  SystemStringTemplatePointer = (ulong long *)(SystemResourceDataIndex + 0x10);
  SystemOperationStatus5 = *SystemStringTemplatePointer;
  *SystemStringTemplatePointer = *SystemStringTemplatePointer + 1;
  UNLOCK();
  if ((*(ulong long *)(SystemResourceDataIndex + 0x20) <= SystemOperationStatus5) ||
     (SystemOperationStatus5 = SystemOperationStatus5 * 0x148 + *(long long *)(SystemResourceDataIndex + 0x18), SystemOperationStatus5 == 0)) goto ResourceAllocationLoop;
ResourceInitializationComplete:
  SystemResourceDataIndex = 0;
  if (SystemOperationStatus5 == 0) goto ResourceConfigurationComplete;
  do {
    *(uint8_t *)(SystemOperationStatus5 + 0x110 + SystemResourceDataIndex) = 1;
    SystemResourceDataIndex = SystemResourceDataIndex + 1;
  } while (SystemResourceDataIndex != 0x20);
  if (*(long long *)(SystemResourceManager + 0x40) == 0) {
    *(ulong long *)(SystemOperationStatus5 + 0x100) = SystemOperationStatus5;
  }
  else {
    *(void* *)(SystemOperationStatus5 + 0x100) = *(void* *)(*(long long *)(SystemResourceManager + 0x40) + 0x100);
    *(ulong long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100) = SystemOperationStatus5;
  }
  *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus5;
  if (ResourceCreationFlags != 0) {
    SystemOperationStatus5 = ResourceCreationFlags;
  }
  *(long long *)(SystemResourceManager + 0x60) = *(long long *)(SystemResourceManager + 0x60) + 1;
  SystemStringTemplatePointer = (ulong long *)
            (*(long long *)(*(long long *)(SystemResourceManager + 0x58) + 0x10) +
            *(long long *)(SystemResourceManager + 0x70) * 0x10);
  *SystemStringTemplatePointer = SystemUnsignedFlag78;
  SystemStringTemplatePointer[1] = *(ulong long *)(SystemResourceManager + 0x40);
  *(ulong long *)(SystemResourceManager + 0x70) = *(long long *)(SystemResourceManager + 0x70) + 1U & *SystemLocalContextPointer - 1U;
  ResourceCreationFlags = SystemOperationStatus5;
  goto joined_r0x00018005f6ef;
}




/**
 * @brief 系统资源数据扩展处理函数
 * 
 * 该函数负责扩展处理系统资源数据，包括更多的内存操作和数据管理功能。
 * 该函数是对ProcessSystemResourceData函数的扩展和补充。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 处理结果状态码
 * 
 *FUN_18005fb30：ProcessSystemResourceDataExtended
 */
ulong long ProcessSystemResourceDataExtended(long long SystemResourceManager,long long *ConfigurationDataPointer,long long AdditionalParameter)

{
  ulong long *systemResourcePointer1;
  uint *systemDataPointer1;
  uint SystemOperationStatusValue1;
  uint SystemOperationStatusValue2;
  long long *localSystemMemoryPointer;
  long long SystemOperationFlags;
  ulong long systemResourceValue1;
  ulong long OperationCode;
  char systemAvailabilityFlag;
  ulong long SystemOperationFlags;
  ulong long SystemOperationStatus1;
  ulong long SystemSecondaryStatus;
  ulong long SystemOperationStatus3;
  ulong long SystemOperationStatus4;
  ulong long SystemOperationStatus5;
  ulong long SystemOperationStatusFlags;
  ulong long SystemOperationStatus7;
  ulong long SystemOperationStatus8;
  long long resourceDataIndex9;
  ulong long *SystemHashEntryPointer0;
  bool isSystemActive1;
  
  SystemOperationStatusFlags = *(ulong long *)(SystemResourceManager + 0x20);
  SystemOperationStatus7 = *(ulong long *)(SystemResourceManager + 0x40);
  SystemOperationStatus3 = SystemOperationStatusFlags + AdditionalParameter;
  SystemOperationStatus8 = SystemOperationStatusFlags - 1 & MAX_UNSIGNED_32_BITffffffe0;
  resourceDataIndex9 = (SystemOperationStatus3 - 1 & MAX_UNSIGNED_32_BITffffffe0) - SystemOperationStatus8;
  SystemOperationStatus4 = SystemOperationStatus7;
  SystemOperationFlags = SystemOperationStatus8;
  ThreadContextFlag = 0;
  while( true ) {
    if (resourceDataIndex9 == 0) {
      *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus7;
      if ((SystemOperationStatusFlags & BIT_MASK_32_BIT) == 0) {
        if (ThreadContextFlag != 0) {
          SystemOperationStatus7 = ThreadContextFlag;
        }
        *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus7;
      }
      while( true ) {
        SystemOperationFlags = (SystemOperationStatusFlags & MAX_UNSIGNED_32_BITffffffe0) + 0x20;
        SystemOperationStatus7 = SystemOperationStatus3;
        if (SystemOperationStatus3 - SystemOperationFlags < 0x8000000000000001) {
          SystemOperationStatus7 = SystemOperationFlags;
        }
        for (; SystemOperationStatusFlags != SystemOperationStatus7; SystemOperationStatusFlags = SystemOperationStatusFlags + 1) {
          SystemLocalContextPointer = (long long *)*ConfigurationDataPointer;
          *(long long **)(*(long long *)(SystemResourceManager + 0x40) + (ulong long)((uint)SystemOperationStatusFlags & BIT_MASK_32_BIT) * 8) =
               SystemLocalContextPointer;
          if (SystemLocalContextPointer != (long long *)0x0) {
            (**(code **)(*SystemLocalContextPointer + 0x28))();
          }
          ConfigurationDataPointer = ConfigurationDataPointer + 1;
        }
        SystemOperationStatus7 = *(ulong long *)(SystemResourceManager + 0x40);
        if (SystemOperationStatus7 == SystemOperationStatus4) break;
        *(void* *)(SystemResourceManager + 0x40) = *(void* *)(SystemOperationStatus7 + 0x100);
      }
      *(ulong long *)(SystemResourceManager + 0x20) = SystemOperationStatus3;
      return CONCAT71((int7)(SystemOperationStatus7 >> 8),1);
    }
    resourceDataIndex9 = resourceDataIndex9 + -0x20;
    SystemOperationFlags = SystemOperationFlags + 0x20;
    OperationCode = ThreadContextFlag;
    if (((*(long long *)(SystemResourceManager + 0x28) - SystemOperationFlags) - 0x20 < 0x8000000000000001) ||
       (SystemLocalContextPointer = *(long long **)(SystemResourceManager + 0x60), SystemLocalContextPointer == (long long *)0x0))
    goto joined_r0x00018005fdcd;
    SystemOperationStatus4 = *SystemLocalContextPointer - 1U & SystemLocalContextPointer[1] + 1U;
    SystemHashEntryPointer0 = *(ulong long **)(SystemLocalContextPointer[3] + SystemOperationStatus4 * 8);
    if ((*SystemHashEntryPointer0 == 1) || (SystemHashEntryPointer0[1] == 0)) {
      *SystemHashEntryPointer0 = SystemOperationFlags;
      SystemLocalContextPointer[1] = SystemOperationStatus4;
    }
    else {
      charOutput = ExpandSystemResourceAllocator(SystemResourceManager);
      if (charOutput == '\0') goto joined_r0x00018005fdcd;
      SystemLocalContextPointer = *(long long **)(SystemResourceManager + 0x60);
      SystemOperationStatus4 = *SystemLocalContextPointer - 1U & SystemLocalContextPointer[1] + 1U;
      SystemHashEntryPointer0 = *(ulong long **)(SystemLocalContextPointer[3] + SystemOperationStatus4 * 8);
      *SystemHashEntryPointer0 = SystemOperationFlags;
      SystemLocalContextPointer[1] = SystemOperationStatus4;
    }
    SystemThreadFlags = *(long long *)(SystemResourceManager + 0x50);
    if (*(ulong long *)(SystemThreadFlags + 0x20) <= *(ulong long *)(SystemThreadFlags + 0x10)) break;
    LOCK();
    SystemDataPointer = (ulong long *)(SystemThreadFlags + 0x10);
    SystemOperationStatus4 = *SystemDataPointer;
    *SystemDataPointer = *SystemDataPointer + 1;
    UNLOCK();
    if ((*(ulong long *)(SystemThreadFlags + 0x20) <= SystemOperationStatus4) ||
       (SystemOperationStatus4 = SystemOperationStatus4 * 0x148 + *(long long *)(SystemThreadFlags + 0x18), SystemOperationStatus4 == 0)) break;
ResourceValidationComplete:
    if (SystemOperationStatus4 == 0) goto ResourceMemoryCheck;
ResourceDataInitialization:
    *(void* *)(SystemOperationStatus4 + 0x108) = 0;
    *(void* *)(SystemOperationStatus4 + 0x100) = 0;
    SystemHashEntryPointer0[1] = SystemOperationStatus4;
    if (((SystemOperationStatusFlags & BIT_MASK_32_BIT) != 0) || (ThreadContextFlag != 0)) {
      *(ulong long *)(*(long long *)(SystemResourceManager + 0x40) + 0x100) = SystemOperationStatus4;
    }
    *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus4;
    if (ThreadContextFlag == 0) {
      ThreadContextFlag = SystemOperationStatus4;
    }
  }
  SystemOperationStatus1 = *(ulong long *)(SystemThreadFlags + 0x28);
ResourceOperationValidation:
  SystemOperationStatus4 = SystemOperationStatus1;
  if (SystemOperationStatus4 != 0) {
    SystemHashEntryPointer = (uint *)(SystemOperationStatus4 + 0x130);
    resourceAddress = *SystemHashEntryPointer;
    if ((resourceAddress & SINE_LOOKUP_TABLE_SIZEffff) == 0) {
ResourceOperationRetry:
      SystemOperationStatus1 = *(ulong long *)(SystemThreadFlags + 0x28);
    }
    else {
      LOCK();
      resourceAllocationContext = *SystemHashEntryPointer;
      if (resourceAddress == resourceAllocationContext) {
        *SystemHashEntryPointer = resourceAddress + 1;
      }
      UNLOCK();
      if (resourceAddress != resourceAllocationContext) goto ResourceOperationRetry;
      LOCK();
      SystemOperationStatus1 = *(ulong long *)(SystemThreadFlags + 0x28);
      isSystemActive1 = SystemOperationStatus4 == SystemOperationStatus1;
      if (isSystemActive1) {
        *(ulong long *)(SystemThreadFlags + 0x28) = *(ulong long *)(SystemOperationStatus4 + 0x138);
        SystemOperationStatus1 = SystemOperationStatus4;
      }
      UNLOCK();
      if (isSystemActive1) {
        LOCK();
        *SystemHashEntryPointer = *SystemHashEntryPointer - 2;
        UNLOCK();
        if (SystemOperationStatus4 != 0) goto ResourceDataInitialization;
        goto ResourceThreadCreation;
      }
      LOCK();
      resourceAddress = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer - 1;
      UNLOCK();
      if (resourceAddress == 0x80000001) {
        SystemOperationStatus5 = *(ulong long *)(SystemThreadFlags + 0x28);
        do {
          *(ulong long *)(SystemOperationStatus4 + 0x138) = SystemOperationStatus5;
          *SystemHashEntryPointer = 1;
          LOCK();
          SystemSecondaryStatus = *(ulong long *)(SystemThreadFlags + 0x28);
          isSystemActive1 = SystemOperationStatus5 == SystemSecondaryStatus;
          if (isSystemActive1) {
            *(ulong long *)(SystemThreadFlags + 0x28) = SystemOperationStatus4;
            SystemSecondaryStatus = SystemOperationStatus5;
          }
          UNLOCK();
          if (isSystemActive1) break;
          LOCK();
          resourceAddress = *SystemHashEntryPointer;
          *SystemHashEntryPointer = *SystemHashEntryPointer + 0x7fffffff;
          UNLOCK();
          SystemOperationStatus5 = SystemSecondaryStatus;
        } while (resourceAddress == 1);
      }
    }
    goto ResourceOperationValidation;
  }
ResourceThreadCreation:
  SystemOperationStatus4 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x148,CONCAT71((int7)((ulong long)SystemThreadFlags >> 8),10));
  if (SystemOperationStatus4 != 0) {
    *(void* *)(SystemOperationStatus4 + 0x100) = 0;
    *(void* *)(SystemOperationStatus4 + 0x108) = 0;
    *(uint32_t *)(SystemOperationStatus4 + 0x130) = 0;
    *(void* *)(SystemOperationStatus4 + 0x138) = 0;
    *(void*2 *)(SystemOperationStatus4 + 0x140) = 0x100;
    goto ResourceValidationComplete;
  }
ResourceMemoryCheck:
  SystemLocalContextPointer = *(long long **)(SystemResourceManager + 0x60);
  SystemLocalContextPointer[1] = SystemLocalContextPointer[1] - 1U & *SystemLocalContextPointer - 1U;
  SystemHashEntryPointer0[1] = 0;
joined_r0x00018005fdcd:
  for (; OperationCode != 0; OperationCode = *(ulong long *)(OperationCode + 0x100)) {
    SystemOperationStatus8 = SystemOperationStatus8 + 0x20;
    SystemLocalContextPointer = *(long long **)(SystemResourceManager + 0x60);
    *(void* *)
     (*(long long *)
       (SystemLocalContextPointer[3] +
       ((SystemOperationStatus8 - **(long long **)(SystemLocalContextPointer[3] + SystemLocalContextPointer[1] * 8) >> 5) + SystemLocalContextPointer[1] & *SystemLocalContextPointer - 1U) * 8)
     + 8) = 0;
    SystemLocalContextPointer = *(long long **)(SystemResourceManager + 0x60);
    SystemLocalContextPointer[1] = SystemLocalContextPointer[1] - 1U & *SystemLocalContextPointer - 1U;
  }
  SystemOperationStatus3 = InitializeSystemResourceHandle(*(void* *)(SystemResourceManager + 0x50),ThreadContextFlag);
  *(ulong long *)(SystemResourceManager + 0x40) = SystemOperationStatus7;
  return SystemOperationStatus3 & MAX_UNSIGNED_32_BITffffff00;
}




/**
 * @brief 从资源池分配资源
 * 
 * 该函数负责从资源池中分配资源，使用原子操作确保线程安全。
 * 它会检查资源池的容量，并返回可用的资源地址。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 返回分配的资源地址，如果没有可用资源则返回0
 */
long long AllocateFromResourcePool(long long SystemResourceManager)

{
  ulong long *SystemDataPointer;
  uint *SystemHashEntryPointer;
  uint resourceAllocationContext;
  ulong long resourceAddress;
  uint currentThreadId;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  long long resourceCounter;
  bool isByteValid0;
  
  if (*(ulong long *)(SystemResourceManager + 0x10) < *(ulong long *)(SystemResourceManager + 0x20)) {
    LOCK();
    SystemDataPointer = (ulong long *)(SystemResourceManager + 0x10);
    resourceAddress = *SystemDataPointer;
    *SystemDataPointer = *SystemDataPointer + 1;
    UNLOCK();
    if ((resourceAddress < *(ulong long *)(SystemResourceManager + 0x20)) &&
       (SystemThreadFlags = resourceAddress * 0x148 + *(long long *)(SystemResourceManager + 0x18), SystemThreadFlags != 0)) {
      return SystemThreadFlags;
    }
  }
  SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28);
ResourcePoolAllocation:
  do {
    resourceCounter = SystemThreadFlags;
    if (resourceCounter == 0) {
ResourceCreation:
      SystemThreadFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x148,10);
      if (SystemThreadFlags == 0) {
        return 0;
      }
      *(void* *)(SystemThreadFlags + 0x100) = 0;
      *(void* *)(SystemThreadFlags + 0x108) = 0;
      *(uint32_t *)(SystemThreadFlags + 0x130) = 0;
      *(void* *)(SystemThreadFlags + 0x138) = 0;
      *(void*2 *)(SystemThreadFlags + 0x140) = 0x100;
      return SystemThreadFlags;
    }
    SystemHashEntryPointer = (uint *)(resourceCounter + 0x130);
    currentThreadId = *SystemHashEntryPointer;
    if ((currentThreadId & SINE_LOOKUP_TABLE_SIZEffff) == 0) {
ResourceAllocationCheck:
      SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28);
      goto ResourcePoolAllocation;
    }
    LOCK();
    resourceAllocationContext = *SystemHashEntryPointer;
    if (currentThreadId == resourceAllocationContext) {
      *SystemHashEntryPointer = currentThreadId + 1;
    }
    UNLOCK();
    if (currentThreadId != resourceAllocationContext) goto ResourceAllocationCheck;
    LOCK();
    SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28);
    isByteValid0 = resourceCounter == SystemThreadFlags;
    if (isByteValid0) {
      *(long long *)(SystemResourceManager + 0x28) = *(long long *)(resourceCounter + 0x138);
      SystemThreadFlags = resourceCounter;
    }
    UNLOCK();
    if (isByteValid0) {
      LOCK();
      *SystemHashEntryPointer = *SystemHashEntryPointer - 2;
      UNLOCK();
      if (resourceCounter != 0) {
        return resourceCounter;
      }
      goto ResourceCreation;
    }
    LOCK();
    currentThreadId = *SystemHashEntryPointer;
    *SystemHashEntryPointer = *SystemHashEntryPointer - 1;
    UNLOCK();
    if (currentThreadId == 0x80000001) {
      SystemMemoryAddress = *(long long *)(SystemResourceManager + 0x28);
      do {
        *(long long *)(resourceCounter + 0x138) = SystemMemoryAddress;
        *SystemHashEntryPointer = 1;
        LOCK();
        localDataIndex = *(long long *)(SystemResourceManager + 0x28);
        isByteValid0 = SystemMemoryAddress == localDataIndex;
        if (isByteValid0) {
          *(long long *)(SystemResourceManager + 0x28) = resourceCounter;
          localDataIndex = SystemMemoryAddress;
        }
        UNLOCK();
        if (isByteValid0) break;
        LOCK();
        currentThreadId = *SystemHashEntryPointer;
        *SystemHashEntryPointer = *SystemHashEntryPointer + 0x7fffffff;
        UNLOCK();
        SystemMemoryAddress = localDataIndex;
      } while (currentThreadId == 1);
    }
  } while( true );
}



/**
 * @brief 系统资源内存处理函数
 * 
 * 该函数负责处理系统资源的内存分配和管理，包括主资源指针和辅助资源指针的操作。
 * 该函数包含复杂的内存管理和指针操作逻辑。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 处理结果状态码
 * 
 *FUN_180060080：ProcessSystemResourceMemory
 */
ulong long ProcessSystemResourceMemory(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter)

{
  long long *primaryResourcePointer;
  long long *secondaryResourcePointer;
  long long ResourceDataOffset;
  void* *systemDataPointer;
  ulong long systemResourceValue;
  ulong long SystemOperationStatusValue;
  
  primaryResourcePointer = *(long long **)(SystemResourceManager + 0x60);
  if (primaryResourcePointer != (long long *)0x0) {
    SystemOperationStatusValue = *primaryResourcePointer - 1U & primaryResourcePointer[1] + 1U;
    secondaryResourcePointer = *(long long **)(primaryResourcePointer[3] + SystemOperationStatusValue * 8);
    *ConfigurationDataPointer = (long long)secondaryResourcePointer;
    if ((*secondaryResourcePointer == 1) || (*(long long *)(*ConfigurationDataPointer + 8) == 0)) {
      systemDataPointer = (void* *)*ConfigurationDataPointer;
      *systemDataPointer = AdditionalParameter;
      primaryResourcePointer[1] = SystemOperationStatusValue;
      return CONCAT71((int7)((ulong long)systemDataPointer >> 8),1);
    }
    systemResourceValue = GetSystemResourceStatus();
    if ((char)systemResourceValue != '\0') {
      primaryResourcePointer = *(long long **)(SystemResourceManager + 0x60);
      SystemOperationStatusValue = *primaryResourcePointer - 1U & primaryResourcePointer[1] + 1U;
      ResourceDataOffset = primaryResourcePointer[3];
      systemDataPointer = *(void* **)(ResourceDataOffset + SystemOperationStatusValue * 8);
      *ConfigurationDataPointer = (long long)systemDataPointer;
      *systemDataPointer = AdditionalParameter;
      primaryResourcePointer[1] = SystemOperationStatusValue;
      return CONCAT71((int7)((ulong long)ResourceDataOffset >> 8),1);
    }
  }
  return systemResourceValue & MAX_UNSIGNED_32_BITffffff00;
}



/**
 * @brief 初始化系统资源上下文
 * 
 * 该函数负责初始化系统资源上下文，设置资源的环境和状态。
 * 主要用于系统资源的上下文管理和初始化。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 初始化后的上下文指针
 * 
 *FUN_1800601c0：InitializeSystemResourceContext
 */
void* InitializeSystemResourceContext(void* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x88);
  }
  return SystemResourceManager;
}




/**
 * @brief 系统资源清理器函数
 * 
 * 该函数负责清理系统资源，包括内存释放和资源回收操作。
 * 它会遍历资源链表，释放不再使用的资源，并更新系统状态。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要清理的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的生命周期管理
 */
void CleanupSystemResources(void* *SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  int *ResourceCounterPointer;
  int NodeIdentifierComparisonResult;
  uint ResourceIndex;
  ulong long ResourceHashValue;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  long long resourceCounter;
  ulong long ResourceTableSize;
  long long NextResourcePointer;
  bool IsResourceMatch;
  
  *SystemResourceManager = &SystemResourceTableA;
  if (SystemResourceManager[8] != 0) {
    SystemResourceDataIndex = 0;
    if ((SystemResourceManager[5] & BIT_MASK_32_BIT) != 0) {
      SystemOperationFlags = SystemResourceManager[0xe] - SystemResourceManager[0xc];
      currentThreadId = SystemResourceManager[0xd] - 1;
      while( true ) {
        SystemOperationFlags = SystemOperationFlags & currentThreadId;
        if ((ulong long)((*(long long *)(SystemResourceManager[0xf] + SystemOperationFlags * 0x10) + 0x20) - SystemResourceManager[5]) <
            0x8000000000000001) break;
        currentThreadId = SystemOperationFlags + 1;
        SystemOperationFlags = SystemResourceManager[0xd] - 1;
      }
      SystemResourceDataIndex = *(long long *)(SystemResourceManager[0xf] + 8 + SystemOperationFlags * 0x10);
    }
    resourceCounter = SystemResourceManager[8];
ResourceProcessingLoop:
    resourceCounter = *(long long *)(resourceCounter + 0x100);
    currentThreadId = 0;
    do {
      if (*(char *)(resourceCounter + 0x110 + currentThreadId) == '\0') {
        currentThreadId = 0;
        if (resourceCounter == SystemResourceDataIndex) {
          currentThreadId = (ulong long)((uint)SystemResourceManager[5] & BIT_MASK_32_BIT);
        }
        if ((SystemResourceManager[4] & BIT_MASK_32_BIT) == 0) {
          SystemOperationFlags = 0x20;
        }
        else {
          SystemOperationFlags = (ulong long)((uint)SystemResourceManager[4] & BIT_MASK_32_BIT);
        }
        goto ThreadProcessingLoop;
      }
      currentThreadId = currentThreadId + 1;
    } while (currentThreadId < 0x20);
    goto ResourceValidationCheck;
  }
ResourceCleanupHandler:
  if (SystemResourceManager[0x10] == 0) {
    *SystemResourceManager = &SystemResourceTableB;
    return;
  }
    SystemCleanupFunction();
  while( true ) {
    resourceAddress = (uint)currentThreadId;
    currentThreadId = currentThreadId + 1;
    PrimaryResourcePointer = *(long long **)(resourceCounter + (ulong long)(resourceAddress & BIT_MASK_32_BIT) * 8);
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
    if (currentThreadId == 0x20) break;
ThreadProcessingLoop:
    if ((resourceCounter == SystemResourceManager[8]) && (currentThreadId == SystemOperationFlags)) break;
  }
ResourceValidationCheck:
  localDataIndex = SystemResourceManager[8];
  if (resourceCounter == localDataIndex) goto code_r0x000180060327;
  goto ResourceProcessingLoop;
code_r0x000180060327:
  if (localDataIndex != 0) {
    do {
      SystemResourceDataIndex = *(long long *)(localDataIndex + 0x100);
      if (*(char *)(localDataIndex + 0x141) != '\0') {
          SystemCleanupFunction();
      }
      resourceCounter = SystemResourceManager[10];
      LOCK();
      pointerToInteger2 = (int *)(localDataIndex + 0x130);
      systemCounter = *pointerToInteger2;
      *pointerToInteger2 = *pointerToInteger2 + -0x80000000;
      UNLOCK();
      if (systemCounter == 0) {
        SystemMemoryAddress = *(long long *)(resourceCounter + 0x28);
        do {
          *(long long *)(localDataIndex + 0x138) = SystemMemoryAddress;
          *(uint32_t *)(localDataIndex + 0x130) = 1;
          PrimaryResourcePointer = (long long *)(resourceCounter + 0x28);
          LOCK();
          SystemThreadFlags = *PrimaryResourcePointer;
          isByteValid2 = SystemMemoryAddress == SystemThreadFlags;
          if (isByteValid2) {
            *PrimaryResourcePointer = localDataIndex;
            SystemThreadFlags = SystemMemoryAddress;
          }
          UNLOCK();
          if (isByteValid2) break;
          LOCK();
          pointerToInteger2 = (int *)(localDataIndex + 0x130);
          systemCounter = *pointerToInteger2;
          *pointerToInteger2 = *pointerToInteger2 + 0x7fffffff;
          UNLOCK();
          SystemMemoryAddress = SystemThreadFlags;
        } while (systemCounter == 1);
      }
      localDataIndex = SystemResourceDataIndex;
    } while (SystemResourceDataIndex != SystemResourceManager[8]);
  }
  goto SystemCleanupCheckpoint;
}



/**
 * @brief 初始化系统资源上下文函数
 * 
 * 该函数负责初始化系统资源上下文，包括资源分配和配置。
 * 该函数会根据配置数据指针的标志来决定是否释放资源。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源指针
 * 
 *FUN_1800603e0：InitializeSystemResourceContext
 */
void* InitializeSystemResourceContext(void* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  ValidateSystemResourceContext();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x68);
  }
  return SystemResourceManager;
}




// 函数: void AllocateSystemResources(void* *SystemResourceManager)
/**
 * @brief 系统资源分配器函数
 * 
 * 该函数负责分配系统资源，包括内存分配和资源初始化操作。
 * 它会处理资源表的分配，并设置相应的资源参数。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要分配的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的分配和初始化
 */
void AllocateSystemResources(void* *SystemResourceManager)

{
  int* SystemIntegerPointer;
  int systemResult;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  long long *SystemLocalContextPointer;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  long long resourceCounter;
  ulong long SystemOperationFlags;
  bool isByteValid1;
  
  *SystemResourceManager = &SystemResourceTableC;
  resourceAllocationContext = SystemResourceManager[4];
  resourceCounter = 0;
  resourceAddress = SystemResourceManager[5];
  for (SystemOperationFlags = resourceAddress; SystemOperationFlags != resourceAllocationContext; SystemOperationFlags = SystemOperationFlags + 1) {
    if ((SystemOperationFlags & BIT_MASK_32_BIT) == 0) {
      if (resourceCounter != 0) {
        SystemThreadFlags = SystemResourceManager[10];
        LOCK();
        SystemIntegerPointer = (int *)(resourceCounter + 0x130);
        systemResult = *SystemIntegerPointer;
        *SystemIntegerPointer = *SystemIntegerPointer + -0x80000000;
        UNLOCK();
        if (systemResult == 0) {
          SystemMemoryAddress = *(long long *)(SystemThreadFlags + 0x28);
          do {
            *(long long *)(resourceCounter + 0x138) = SystemMemoryAddress;
            *(uint32_t *)(resourceCounter + 0x130) = 1;
            SystemLocalContextPointer = (long long *)(SystemThreadFlags + 0x28);
            LOCK();
            localDataIndex = *SystemLocalContextPointer;
            isByteValid1 = SystemMemoryAddress == localDataIndex;
            if (isByteValid1) {
              *SystemLocalContextPointer = resourceCounter;
              localDataIndex = SystemMemoryAddress;
            }
            UNLOCK();
            if (isByteValid1) break;
            LOCK();
            SystemIntegerPointer = (int *)(resourceCounter + 0x130);
            systemResult = *SystemIntegerPointer;
            *SystemIntegerPointer = *SystemIntegerPointer + 0x7fffffff;
            UNLOCK();
            SystemMemoryAddress = localDataIndex;
          } while (systemResult == 1);
        }
      }
ResourceAccessValidation:
      SystemLocalContextPointer = (long long *)SystemResourceManager[0xc];
      resourceCounter = *(long long *)
               (*(long long *)
                 (SystemLocalContextPointer[3] +
                 (((SystemOperationFlags & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(SystemLocalContextPointer[3] + SystemLocalContextPointer[1] * 8) >> 5)
                  + SystemLocalContextPointer[1] & *SystemLocalContextPointer - 1U) * 8) + 8);
    }
    else if (resourceCounter == 0) goto ResourceAccessValidation;
    SystemLocalContextPointer = *(long long **)(resourceCounter + (ulong long)((uint)SystemOperationFlags & BIT_MASK_32_BIT) * 8);
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x38))();
    }
  }
  resourceCounter = SystemResourceManager[8];
  if ((resourceCounter != 0) && ((resourceAddress != resourceAllocationContext || ((resourceAllocationContext & BIT_MASK_32_BIT) != 0)))) {
    SystemThreadFlags = SystemResourceManager[10];
    LOCK();
    SystemIntegerPointer = (int *)(resourceCounter + 0x130);
    systemResult = *SystemIntegerPointer;
    *SystemIntegerPointer = *SystemIntegerPointer + -0x80000000;
    UNLOCK();
    if (systemResult == 0) {
      SystemMemoryAddress = *(long long *)(SystemThreadFlags + 0x28);
      do {
        *(long long *)(resourceCounter + 0x138) = SystemMemoryAddress;
        *(uint32_t *)(resourceCounter + 0x130) = 1;
        SystemLocalContextPointer = (long long *)(SystemThreadFlags + 0x28);
        LOCK();
        localDataIndex = *SystemLocalContextPointer;
        isByteValid1 = SystemMemoryAddress == localDataIndex;
        if (isByteValid1) {
          *SystemLocalContextPointer = resourceCounter;
          localDataIndex = SystemMemoryAddress;
        }
        UNLOCK();
        if (isByteValid1) break;
        LOCK();
        SystemIntegerPointer = (int *)(resourceCounter + 0x130);
        systemResult = *SystemIntegerPointer;
        *SystemIntegerPointer = *SystemIntegerPointer + 0x7fffffff;
        UNLOCK();
        SystemMemoryAddress = localDataIndex;
      } while (systemResult == 1);
    }
  }
  if (SystemResourceManager[0xc] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemResourceTableB;
  return;
}



/**
 * @brief 配置系统资源数据函数
 * 
 * 该函数负责配置系统资源数据，设置资源表和配置参数。
 * 该函数会根据配置数据指针的标志来决定是否释放资源。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源指针
 * 
 *FUN_1800605d0：ConfigureSystemResourceData
 */
void* * ConfigureSystemResourceData(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemResourceTableB;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x58);
  }
  return SystemResourceManager;
}




// 函数: void ConfigureSystemResources(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源配置器函数
 * 
 * 该函数负责配置系统资源，设置资源参数和属性。
 * 它会处理资源的初始化配置，并设置相应的标志位。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要配置的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置参数
 * @param AdditionalParameter 额外参数，用于特殊配置
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @note 这是系统资源管理的重要组成部分，用于资源的配置和初始化
 */
void ConfigureSystemResources(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  char SystemNodeFlag;
  void* ConfigurationMask;
  
  ConfigurationMask = 0xfffffffffffffffe;
  *SystemResourceManager = &SystemResourcePrimaryTemplate;
  charStatus = ConfigureSystemResourceContext(SystemResourceManager,1,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  while (charStatus != '\0') {
    charStatus = ConfigureSystemResourceContext(SystemResourceManager,1,AdditionalParameter,ConfigurationFlag,ConfigurationMask);
  }
  if (SystemResourceManager[1] == 0) {
    SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
    _Mtx_destroy_in_situ();
    _Cnd_destroy_in_situ(SystemResourceManager + 0x2a);
    _Mtx_destroy_in_situ();
    FinalizeSystemResourceConfiguration();
    if (SystemResourceManager[0xe] != 0) {
      *(void* *)(SystemResourceManager[0xe] + 0x10) = 0;
      *(uint8_t *)(SystemResourceManager[0xe] + 8) = 1;
    }
    SystemResourceManager[2] = &SystemMemoryAllocatorReference;
    return;
  }
  if (*(int *)(SystemResourceManager[1] + 8) == 0) {
      SystemCleanupFunction();
  }
    terminate();
}



/**
 * @brief 释放系统资源内存
 * 
 * 该函数负责释放系统资源的内存，根据配置标志决定是否执行释放操作。
 * 主要用于系统资源的内存管理和清理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 释放后的资源指针
 * 
 *FUN_180060630：ReleaseSystemResourceMemory
 */
void* ReleaseSystemResourceMemory(void* SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  CleanupSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x208,AdditionalParameter,ConfigurationFlag,SystemOperationStatus);
  }
  return SystemResourceManager;
}



int InitializeProcessSystem(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  ulong long *SystemHashEntryPointer;
  uint64_t SystemInitializationFlag;
  void* SystemConfigurationPointer;
  
  SystemParameterPointer = AdditionalParameter;
  SystemConfigurationPointer = ConfigurationFlag;
  SystemHashEntryPointer = (ulong long *)SystemGlobalDataAllocate();
  SystemOperationStatus = __stdio_common_vsprintf(*SystemHashEntryPointer | 1,SystemResourceManager,0xffffffffffffffff,ConfigurationDataPointer,0,&SystemParameterPointer);
  if (SystemOperationStatus < 0) {
    SystemOperationStatus = -1;
  }
  return SystemOperationStatus;
}





// 函数: void InitializeSystemResource(long long* SystemResourceManager)
/**
 * @brief 系统资源初始化器函数
 * 
 * 该函数负责初始化系统资源，设置资源的基本参数和状态。
 * 它会处理资源的预初始化工作，为后续的资源分配做准备。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要初始化的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的初始化和准备
 */
void InitializeSystemResource(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  void* SystemContextValue;
  long long* SystemResourceManager20;
  char SystemFlag18;
  
  if ((char)SystemResourceManager[0xb] != '\0') {
    PrimaryResourcePointer = (long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
    do {
      SystemOperationResult = (**(code **)(*SystemResourceManager + 0x20))(SystemResourceManager,1);
      if (validationStatusFlag == '\0') {
        ReleaseSystemResourceHandle(*(void* *)(*PrimaryResourcePointer + 0x10),0);
        SystemResourceManager20 = SystemResourceManager + 0x33;
        SystemFlag18 = 0;
        systemCounter = _Mtx_lock();
        if (systemCounter != 0) {
          __Throw_C_error_std__YAXH_Z(systemCounter);
        }
        SystemFlag18 = '\x01';
        if ((char)SystemResourceManager[0x3d] == '\x01') {
          *(uint8_t *)(SystemResourceManager + 0x3d) = 0;
        }
        else {
          SystemContextValue = 0x32;
          ProcessSystemTimestampHandler(SystemResourceManager + 0x2a,&SystemResourceManager20,&SystemContextValue);
          *(uint8_t *)(SystemResourceManager + 0x3d) = 0;
          if (SystemFlag18 == '\0') goto SystemFlagCheckComplete;
        }
        systemCounter = _Mtx_unlock(SystemResourceManager20);
        if (systemCounter != 0) {
          __Throw_C_error_std__YAXH_Z(systemCounter);
        }
      }
SystemFlagCheckComplete:
    } while ((char)SystemResourceManager[0xb] != '\0');
  }
  return;
}



/**
 * @brief 处理系统资源分配请求
 * 
 * 该函数负责处理系统资源的分配请求，根据配置数据决定资源的分配策略。
 * 主要用于系统资源的动态分配和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的资源指针
 * 
 *FUN_1800607f0：ProcessSystemResourceAllocationRequest
 */
void* ProcessSystemResourceAllocationRequest(long long SystemResourceManager,char ConfigurationDataPointer)

{
  long long resourceDataIndex;
  int systemResult;
  long long *SystemResourceOffsetPointer;
  void* resourceAddress;
  long long *SystemResourceHandle;
  
  SystemResourceHandle = (long long *)0x0;
  SystemResourceOffsetPointer = (long long *)0x0;
  if (ConfigurationDataPointer != '\0') {
    if (*(int *)(SystemResourceManager + 0x140) < 1) {
      SystemResourceOffsetPointer = (long long *)0x0;
    }
    else {
      systemResult = _Mtx_lock(SystemResourceManager + 0xf0);
      if (systemResult != 0) {
        __Throw_C_error_std__YAXH_Z(systemResult);
      }
      if ((*(long long *)(SystemResourceManager + 200) - *(long long *)(SystemResourceManager + 0xd0) >> 3) +
          ((*(long long *)(SystemResourceManager + 0xe0) - *(long long *)(SystemResourceManager + 0xc0) >> 3) + -1) * 0x20 +
          (*(long long *)(SystemResourceManager + 0xb8) - (long long)*(long long **)(SystemResourceManager + 0xa8) >> 3) != 0) {
        SystemResourceHandle = (long long *)**(long long **)(SystemResourceManager + 0xa8);
        if (SystemResourceHandle != (long long *)0x0) {
          (**(code **)(*SystemResourceHandle + 0x28))(SystemResourceHandle);
        }
        SystemResourceOffsetPointer = *(long long **)(SystemResourceManager + 0xa8);
        if (SystemResourceOffsetPointer + 1 == *(long long **)(SystemResourceManager + 0xb8)) {
          if ((long long *)*SystemResourceOffsetPointer != (long long *)0x0) {
            (**(code **)(*(long long *)*SystemResourceOffsetPointer + 0x38))();
          }
          if (*(long long *)(SystemResourceManager + 0xb0) != 0) {
              SystemCleanupFunction();
          }
          SystemResourceOffsetPointer = (long long *)(*(long long *)(SystemResourceManager + 0xc0) + 8);
          *(long long **)(SystemResourceManager + 0xc0) = SystemResourceOffsetPointer;
          resourceDataIndex = *SystemResourceOffsetPointer;
          *(long long *)(SystemResourceManager + 0xb0) = resourceDataIndex;
          *(long long *)(SystemResourceManager + 0xb8) = resourceDataIndex + 0x100;
          *(void* *)(SystemResourceManager + 0xa8) = *(void* *)(SystemResourceManager + 0xb0);
        }
        else {
          *(long long **)(SystemResourceManager + 0xa8) = SystemResourceOffsetPointer + 1;
          if ((long long *)*SystemResourceOffsetPointer != (long long *)0x0) {
            (**(code **)(*(long long *)*SystemResourceOffsetPointer + 0x38))();
          }
        }
      }
      systemResult = _Mtx_unlock(SystemResourceManager + 0xf0);
      if (systemResult != 0) {
        __Throw_C_error_std__YAXH_Z(systemResult);
      }
      SystemResourceOffsetPointer = SystemResourceHandle;
      if (SystemResourceHandle != (long long *)0x0) {
        (**(code **)(*SystemResourceHandle + 0x60))(SystemResourceHandle);
        (**(code **)(*SystemResourceHandle + 0x70))(SystemResourceHandle);
        LOCK();
        *(int *)(SystemResourceManager + 0x140) = *(int *)(SystemResourceManager + 0x140) + -1;
        UNLOCK();
        resourceAddress = 1;
        goto ResourceCleanupComplete;
      }
    }
  }
  SystemResourceHandle = SystemResourceOffsetPointer;
  resourceAddress = 0;
ResourceCleanupComplete:
  if (SystemResourceHandle != (long long *)0x0) {
    (**(code **)(*SystemResourceHandle + 0x38))(SystemResourceHandle);
  }
  return resourceAddress;
}



/**
 * @brief 初始化系统资源并执行同步操作
 * 
 * 该函数负责初始化系统资源，等待同步对象，并执行相关的回调函数。
 * 主要用于系统资源的初始化和同步处理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 初始化结果状态码，true表示成功，false表示失败
 * 
 *FUN_1800609c0：InitializeSystemResourceAndSynchronize
 */
bool InitializeSystemResourceAndSynchronize(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  long long *PrimaryResourcePointer;
  
  PrimaryResourcePointer = (long long *)0x0;
  WaitForSingleObject(**(void* **)(SystemResourceManager + 0x1f0),1,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  SystemOperationResult = ProcessSystemResourceData(*(void* *)(SystemResourceManager + 0x60),SystemResourceManager + 0x78,&PrimaryResourcePointer);
  PrimaryResourcePointer = PrimaryResourcePointer;
  if (validationStatusFlag != '\0') {
    (**(code **)(*PrimaryResourcePointer + 0x60))(PrimaryResourcePointer);
    (**(code **)(*PrimaryResourcePointer + 0x70))(PrimaryResourcePointer);
  }
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer);
  }
  return SystemOperationResult != '\0';
}



/**
 * @brief 获取系统资源状态值
 * 
 * 该函数负责获取系统资源的状态值，用于资源管理和状态监控。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源状态值
 * 
 *FUN_180060a50：GetSystemResourceStatusValue
 */
ulong long GetSystemResourceStatusValue(long long* SystemResourceManager,uint *ConfigurationDataPointer)

{
  uint SystemOperationStatus;
  uint resourceCreationFlags;
  long long ResourceDataOffset;
  ulong long in_RAX;
  ulong long *presourceAddress;
  ulong long *SystemThreadContext;
  ulong long *resourceEntryPointer;
  ulong long ThreadContextFlag;
  ulong long *SystemThreadStorage;
  uint SystemOperationCounter;
  ulong long SystemOperationFlags;
  
  ResourceDataOffset = *SystemResourceManager;
  if ((*(long long *)(ConfigurationDataPointer + 6) == 0) && (ResourceDataOffset == 0)) {
    return in_RAX & MAX_UNSIGNED_32_BITffffff00;
  }
  SystemOperationStatus = *(uint *)(SystemResourceManager + 1);
  resourceCreationFlags = *(uint *)(SystemResourceManager + 0x4c);
  SystemThreadStorage = (ulong long *)0x0;
  presourceAddress = *(ulong long **)(ConfigurationDataPointer + 6);
  if (*(ulong long **)(ConfigurationDataPointer + 6) == (ulong long *)0x0) {
    SystemThreadContext = (ulong long *)(ResourceDataOffset + 8);
    if (ResourceDataOffset == 0) {
      SystemThreadContext = SystemThreadStorage;
    }
    *(ulong long **)(ConfigurationDataPointer + 6) = SystemThreadContext;
    ThreadContextFlag = (SystemOperationStatus - *ConfigurationDataPointer % SystemOperationStatus) - 1;
    SystemOperationFlags = (ulong long)SystemOperationCounter;
    presourceAddress = SystemThreadContext;
    if (ThreadContextFlag != 0) {
      do {
        if (presourceAddress == (ulong long *)0x0) {
          presourceAddress = (ulong long *)&SystemDataBufferPtr;
        }
        resourceEntryPointer = (ulong long *)(*presourceAddress - 8);
        if (*presourceAddress == 0) {
          SystemCurrentNode = SystemNextNode;
        }
        presourceAddress = resourceEntryPointer + 1;
        if (resourceEntryPointer == (ulong long *)0x0) {
          presourceAddress = SystemThreadStorage;
        }
        *(ulong long **)(ConfigurationDataPointer + 6) = presourceAddress;
        if (presourceAddress == (ulong long *)0x0) {
          *(ulong long **)(ConfigurationDataPointer + 6) = SystemThreadContext;
          presourceAddress = SystemThreadContext;
        }
        SystemOperationFlags = SystemOperationFlags - 1;
      } while (SystemOperationFlags != 0);
    }
  }
  ThreadContextFlag = resourceCreationFlags - ConfigurationDataPointer[1];
  SystemOperationFlags = (ulong long)SystemOperationCounter;
  if (SystemOperationStatus <= ThreadContextFlag) {
    SystemOperationFlags = (ulong long)ThreadContextFlag % (ulong long)SystemOperationStatus;
  }
  ThreadContextFlag = SystemOperationFlags;
  if ((int)SystemOperationFlags != 0) {
    do {
      if (presourceAddress == (ulong long *)0x0) {
        presourceAddress = (ulong long *)&SystemDataBufferPtr;
      }
      SystemOperationFlags = *presourceAddress;
      SystemThreadContext = (ulong long *)(SystemOperationFlags - 8);
      if (SystemOperationFlags == 0) {
        SystemThreadContext = SystemThreadStorage;
      }
      presourceAddress = SystemThreadStorage;
      if (SystemThreadContext != (ulong long *)0x0) {
        presourceAddress = SystemThreadContext + 1;
      }
      *(ulong long **)(ConfigurationDataPointer + 6) = presourceAddress;
      if (presourceAddress == (ulong long *)0x0) {
        presourceAddress = (ulong long *)(ResourceDataOffset + 8);
        if (ResourceDataOffset == 0) {
          presourceAddress = SystemThreadStorage;
        }
        *(ulong long **)(ConfigurationDataPointer + 6) = presourceAddress;
      }
      ThreadContextFlag = ThreadContextFlag - 1;
    } while (ThreadContextFlag != 0);
  }
  ConfigurationDataPointer[1] = resourceCreationFlags;
  ConfigurationDataPointer[2] = 0;
  *(ulong long **)(ConfigurationDataPointer + 4) = presourceAddress;
  return CONCAT71((int7)(SystemOperationFlags >> 8),1);
}



/**
 * @brief 处理系统资源数据交换
 * 
 * 该函数负责处理系统资源数据的交换操作，包括内存指针的重新分配
 * 和资源的清理释放。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 处理后的系统资源指针
 * 
 *FUN_180060b80：ProcessSystemResourceDataExchange
 */
long long * ProcessSystemResourceDataExchange(long long* SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long resourceDataIndex;
  long long *resourcePoolPointer;
  
  resourceDataIndex = *ConfigurationDataPointer;
  *ConfigurationDataPointer = 0;
  resourcePoolPointer = (long long *)*SystemResourceManager;
  *SystemResourceManager = resourceDataIndex;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  return SystemResourceManager;
}



/**
 * @brief 释放系统资源并返回指针
 * 
 * 该函数负责释放系统资源，并返回资源指针。
 * 主要用于系统资源的清理和释放操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 系统资源指针
 * 
 *FUN_180060bd0：ReleaseSystemResourceAndReturnPointer
 */
long long * ReleaseSystemResourceAndReturnPointer(long long* SystemResourceManager)

{
  if ((long long *)*SystemResourceManager != (long long *)0x0) {
    (**(code **)(*(long long *)*SystemResourceManager + 0x38))();
  }
  return SystemResourceManager;
}



/**
 * @brief 分配系统资源内存
 * 
 * 该函数负责分配系统资源的内存，包括内存块的分配和管理。
 * 主要用于系统资源的内存分配操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的内存指针，失败时返回0
 * 
 *FUN_180060c60：AllocateSystemResourceMemory
 */
void* AllocateSystemResourceMemory(long long SystemResourceManager,void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *SystemHashEntryPointer;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  ulong long ThreadContextFlag;
  
  if (*(char *)(SystemResourceManager + 0x48) == '\0') {
    if ((ulong long)
        ((*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x38)) -
        *(long long *)(SystemResourceManager + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x30);
    ResourceDataOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((ResourceDataOffset - *(long long *)(SystemResourceManager + 0x20)) - *(long long *)(SystemResourceManager + 0x38))) {
      LOCK();
      SystemHashEntryPointer = (ulong long *)(SystemResourceManager + 0x28);
      resourceAddress = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x60);
      ResourceDataOffset = *(long long *)
               (PrimaryResourcePointer[3] +
               (((resourceAddress & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 8);
      SystemThreadFlags = *(long long *)(ResourceDataOffset + 8);
      PrimaryResourcePointer = (long long *)(SystemThreadFlags + (ulong long)((uint)resourceAddress & BIT_MASK_32_BIT) * 8);
      ConfigureSystemDataBuffer(ConfigurationDataPointer,PrimaryResourcePointer);
      PrimaryResourcePointer = (long long *)*PrimaryResourcePointer;
      if (PrimaryResourcePointer != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer + 0x38))();
      }
      LOCK();
      PrimaryResourcePointer = (long long *)(SystemThreadFlags + 0x108);
      localSystemPointer = *PrimaryResourcePointer;
      *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
      UNLOCK();
      if (localSystemPointer == 0x1f) {
        *(void* *)(ResourceDataOffset + 8) = 0;
        ReleaseSystemResourceHandle(*(void* *)(SystemResourceManager + 0x50),SystemThreadFlags);
      }
      return 1;
    }
  }
  else {
    if ((ulong long)
        ((*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x38)) -
        *(long long *)(SystemResourceManager + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x30);
    ResourceDataOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((ResourceDataOffset - *(long long *)(SystemResourceManager + 0x20)) - *(long long *)(SystemResourceManager + 0x38))) {
      LOCK();
      SystemHashEntryPointer = (ulong long *)(SystemResourceManager + 0x28);
      resourceAddress = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x58);
      ThreadContextFlag = (ulong long)((uint)resourceAddress & BIT_MASK_32_BIT);
      ResourceDataOffset = *(long long *)
               (PrimaryResourcePointer[2] + 8 +
               (((resourceAddress & MAX_UNSIGNED_32_BITffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
      PrimaryResourcePointer = (long long *)(ResourceDataOffset + ThreadContextFlag * 8);
      ConfigureSystemDataBuffer(ConfigurationDataPointer,PrimaryResourcePointer);
      PrimaryResourcePointer = (long long *)*PrimaryResourcePointer;
      if (PrimaryResourcePointer != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer + 0x38))();
      }
      *(uint8_t *)((ResourceDataOffset - ThreadContextFlag) + 0x12f) = 1;
      return 1;
    }
  }
  LOCK();
  *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + 1;
  UNLOCK();
  return 0;
}



/**
 * @brief 获取系统数据索引指针
 * 
 * 该函数负责获取系统数据索引指针，处理字符串迭代器和数据索引
 * 用于系统数据管理和索引操作
 * 
 * @return 系统数据索引指针
 * 
 *FUN_180060d76：GetSystemDataIndexPointer
 */
void* GetSystemDataIndexPointer(void)

{
  ulong long *SystemDataPointer;
  ulong long resourceCreationFlags;
  long long ResourceDataOffset;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  ulong long StringIteratorPointer;
  long long systemDataIndexPtr;
  
  LOCK();
  SystemDataPointer = (ulong long *)(systemDataIndexPtr + 0x28);
  resourceCreationFlags = *SystemDataPointer;
  *SystemDataPointer = *SystemDataPointer + (StringIteratorPointer & MAX_UNSIGNED_32_BIT);
  UNLOCK();
  SystemCalculatedBufferAddress = *(long long **)(systemDataIndexPtr + 0x60);
  localSystemPointer = *(long long *)
           (SystemCalculatedBufferAddress[3] +
           (((resourceCreationFlags & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(SystemCalculatedBufferAddress[3] + SystemCalculatedBufferAddress[1] * 8) >> 5) +
            SystemCalculatedBufferAddress[1] & *SystemCalculatedBufferAddress - 1U) * 8);
  SystemThreadFlags = *(long long *)(localSystemPointer + 8);
  InitializeSystemDataBuffer();
  SystemCalculatedBufferAddress = *(long long **)(SystemThreadFlags + (ulong long)((uint)resourceCreationFlags & BIT_MASK_32_BIT) * 8);
  if (SystemCalculatedBufferAddress != (long long *)0x0) {
    (**(code **)(*SystemCalculatedBufferAddress + 0x38))();
  }
  LOCK();
  SystemCalculatedBufferAddress = (long long *)(SystemThreadFlags + 0x108);
  ResourceDataOffset = *SystemCalculatedBufferAddress;
  *SystemCalculatedBufferAddress = *SystemCalculatedBufferAddress + StringIteratorPointer;
  UNLOCK();
  if (ResourceDataOffset == 0x1f) {
    *(void* *)(localSystemPointer + 8) = 0;
    ReleaseSystemResourceHandle(*(void* *)(systemDataIndexPtr + 0x50),SystemThreadFlags);
  }
  return 1;
}



/**
 * @brief 更新系统字符串索引
 * 
 * 该函数负责更新系统字符串的索引，通过加法操作来维护字符串数据的索引状态。
 * 主要用于系统字符串管理的数据同步。
 * 
 * @return 更新状态码，0表示成功
 * 
 *FUN_180060e22：UpdateSystemStringIndex
 */
uint8_t UpdateSystemStringIndex(void)

{
  long long StringIteratorPointer;
  long long systemDataIndexPtr;
  
  LOCK();
  *(long long *)(systemDataIndexPtr + 0x38) = *(long long *)(systemDataIndexPtr + 0x38) + StringIteratorPointer;
  UNLOCK();
  return 0;
}



/**
 * @brief 系统资源分配和同步函数
 * 
 * 该函数负责分配系统资源并进行同步操作，包括内存分配、资源验证
 * 和状态同步。用于系统资源的动态分配和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @return 分配的资源指针或错误代码
 * 
 *FUN_180060e40：AllocateAndSynchronizeSystemResource
 */
void* AllocateAndSynchronizeSystemResource(void* *SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter)

{
  char SystemNodeFlag;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  long long* SystemMemoryPointer;
  long long *SystemLocalContextPointer;
  long long *pSystemThreadFlags;
  
  if (((*(long long *)(ConfigurationDataPointer + 0x18) == 0) || (*(int *)(ConfigurationDataPointer + 4) != *(int *)(SystemResourceManager + 0x4c)))
     && (charStatus = ValidateSystemResourceStatus(), charStatus == '\0')) {
    return 0;
  }
  pSystemThreadFlags = (long long *)0x0;
  SystemCalculatedBufferAddress = (long long *)(*(long long *)(ConfigurationDataPointer + 0x10) + -8);
  if (*(long long *)(ConfigurationDataPointer + 0x10) == 0) {
    SystemCalculatedBufferAddress = pSystemThreadFlags;
  }
  charStatus = ProcessSystemBufferAllocation(SystemCalculatedBufferAddress,AdditionalParameter);
  if (initializationStatusFlag == '\0') {
    SystemCalculatedBufferAddress = (long long *)*SystemResourceManager;
    resourcePoolPointer = *(long long **)(ConfigurationDataPointer + 0x10);
    if (resourcePoolPointer == (long long *)0x0) {
      resourcePoolPointer = (long long *)&SystemDataBufferPtr;
    }
    ResourceDataOffset = *resourcePoolPointer;
    while( true ) {
      resourcePoolPointer = (long long *)(ResourceDataOffset + -8);
      if (ResourceDataOffset == 0) {
        resourcePoolPointer = pSystemThreadFlags;
      }
      SystemLocalContextPointer = SystemCalculatedBufferAddress;
      if (resourcePoolPointer != (long long *)0x0) {
        SystemLocalContextPointer = resourcePoolPointer;
      }
      resourcePoolPointer = (long long *)(*(long long *)(ConfigurationDataPointer + 0x10) + -8);
      if (*(long long *)(ConfigurationDataPointer + 0x10) == 0) {
        resourcePoolPointer = pSystemThreadFlags;
      }
      if (SystemLocalContextPointer == resourcePoolPointer) {
        return 0;
      }
      charStatus = ProcessSystemBufferAllocation(SystemLocalContextPointer,AdditionalParameter);
      if (charStatus != '\0') break;
      ResourceDataOffset = SystemLocalContextPointer[1];
    }
    *(uint32_t *)(ConfigurationDataPointer + 8) = 1;
    SystemCalculatedBufferAddress = SystemLocalContextPointer + 1;
    if (SystemLocalContextPointer == (long long *)0x0) {
      SystemCalculatedBufferAddress = pSystemThreadFlags;
    }
    *(long long **)(ConfigurationDataPointer + 0x10) = SystemCalculatedBufferAddress;
  }
  else {
    *(int *)(ConfigurationDataPointer + 8) = *(int *)(ConfigurationDataPointer + 8) + 1;
    if (*(int *)(ConfigurationDataPointer + 8) == 0x100) {
      LOCK();
      *(int *)(SystemResourceManager + 0x4c) = *(int *)(SystemResourceManager + 0x4c) + 1;
      UNLOCK();
    }
  }
  return 1;
}



/**
 * @brief 执行系统资源操作并返回状态
 * 
 * 该函数负责执行系统资源的操作，包括资源初始化、配置和状态检查。
 * 主要用于系统资源的管理和控制。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 操作状态，true表示成功，false表示失败
 * 
 *FUN_180060f50：ExecuteSystemResourceOperation
 */
bool ExecuteSystemResourceOperation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  char validationStatusFlag;
  long long *PrimaryResourcePointer;
  
  PrimaryResourcePointer = (long long *)0x0;
  SystemOperationResult = ProcessSystemResourceData(*(void* *)(SystemResourceManager + 0x60),SystemResourceManager + 0x78,&PrimaryResourcePointer,ConfigurationFlag,
                        0xfffffffffffffffe);
  PrimaryResourcePointer = PrimaryResourcePointer;
  if (validationStatusFlag != '\0') {
    (**(code **)(*PrimaryResourcePointer + 0x60))(PrimaryResourcePointer);
    (**(code **)(*PrimaryResourcePointer + 0x70))(PrimaryResourcePointer);
  }
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer);
  }
  return SystemOperationResult != '\0';
}





// 函数: void SynchronizeSystemResources(long long* SystemResourceManager,long long *ConfigurationDataPointer)
/**
 * @brief 系统资源同步器函数
 * 
 * 该函数负责同步系统资源，确保资源状态的一致性。
 * 它会处理资源数据的同步操作，保持资源的最新状态。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要同步的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含同步所需的配置信息
 * @note 这是系统资源管理的重要组成部分，用于资源的同步和状态管理
 */
void SynchronizeSystemResources(long long* SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long SystemThreadHandle;
  long long *SystemResourceOffsetPointer;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  ulong long ThreadContextFlag;
  void* SystemOperationFlags;
  
  SystemOperationFlags = 0xfffffffffffffffe;
  SystemResourceOffsetPointer = (long long *)SystemResourceManager[6];
  PrimaryResourcePointer = SystemResourceOffsetPointer + 1;
  if (PrimaryResourcePointer == (long long *)SystemResourceManager[8]) {
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer);
    }
    localDataIndex = *SystemResourceManager;
    SystemBufferAddress = SystemResourceManager[1];
    if (SystemBufferAddress <= (SystemResourceManager[9] - localDataIndex >> 3) + 1) {
      SystemThreadFlags = SystemResourceManager[5];
      ThreadContextFlag = SystemThreadFlags - localDataIndex >> 3;
      SystemMemoryAddress = SystemResourceManager[9] - SystemThreadFlags >> 3;
      SystemThreadHandle = SystemMemoryAddress * 8 + 8;
      if (ThreadContextFlag != 0) {
        currentThreadId = ThreadContextFlag >> 1;
        if (currentThreadId < 2) {
          currentThreadId = 1;
        }
          memmove(localDataIndex + (ThreadContextFlag - currentThreadId) * 8,SystemThreadFlags,SystemThreadHandle);
      }
      SystemThreadFlags = SystemBufferAddress;
      if (SystemBufferAddress == 0) {
        SystemThreadFlags = 1;
      }
      SystemThreadFlags = SystemBufferAddress + 2 + SystemThreadFlags;
      localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadFlags * 8,(char)SystemResourceManager[10],localDataIndex,SystemOperationFlags);
      PrimaryResourcePointer = (long long *)(localDataIndex + (SystemResourceManager[5] - *SystemResourceManager >> 3) * 8);
      if (*SystemResourceManager != 0) {
          memcpy(PrimaryResourcePointer,SystemResourceManager[5],SystemThreadHandle);
      }
      *SystemResourceManager = localDataIndex;
      SystemResourceManager[1] = SystemThreadFlags;
      SystemResourceManager[5] = (long long)PrimaryResourcePointer;
      localDataIndex = *PrimaryResourcePointer;
      SystemResourceManager[3] = localDataIndex;
      SystemResourceManager[4] = localDataIndex + 0x100;
      SystemResourceManager[9] = (long long)(PrimaryResourcePointer + SystemMemoryAddress);
      localDataIndex = PrimaryResourcePointer[SystemMemoryAddress];
      SystemResourceManager[7] = localDataIndex;
      SystemResourceManager[8] = localDataIndex + 0x100;
    }
    SystemOperationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x100,(char)SystemResourceManager[10]);
    *(void* *)(SystemResourceManager[9] + 8) = SystemOperationFlags;
    *(long long **)SystemResourceManager[6] = ConfigurationDataPointer;
    localDataIndex = SystemResourceManager[9];
    SystemResourceManager[9] = localDataIndex + 8;
    localDataIndex = *(long long *)(localDataIndex + 8);
    SystemResourceManager[7] = localDataIndex;
    SystemResourceManager[8] = localDataIndex + 0x100;
    SystemResourceManager[6] = localDataIndex;
  }
  else {
    SystemResourceManager[6] = (long long)PrimaryResourcePointer;
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    *SystemResourceOffsetPointer = (long long)ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))();
    }
  }
  return;
}





// 函数: void ValidateSystemResourceEx(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源验证器函数
 * 
 * 该函数负责验证系统资源的有效性和完整性。
 * 它会检查资源的状态和配置，确保资源可用。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要验证的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含验证所需的配置信息
 * @param AdditionalParameter 额外参数，用于特殊验证
 * @param ConfigurationFlag 配置标志，用于控制验证行为
 * @note 这是系统资源管理的重要组成部分，用于资源的验证和检查
 */
void ValidateSystemResourceEx(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  int systemIndex;
  long long SystemTimeValue;
  void* ResourceHash;
  uint8_t ThreadContextFlag;
  
  ResourceHash = 0xfffffffffffffffe;
  localSystemPointer = SystemResourceManager + 0xf0;
  systemIndex = _Mtx_lock();
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  ThreadContextFlag = 1;
  InitializeSystemResourcePool(SystemResourceManager + 0x98,ConfigurationDataPointer);
  LOCK();
  *(int *)(SystemResourceManager + 0x140) = *(int *)(SystemResourceManager + 0x140) + 1;
  UNLOCK();
  SystemDataPointer = *(void* **)(SystemResourceManager + 0x1f0);
  SystemThreadHandle = *(long long *)(SystemAllocationFlagsTemplate + 0x10);
  ResourceDataOffset = *(long long *)(SystemAllocationFlagsTemplate + 8);
  do {
    systemIndex = ReleaseSemaphore(*SystemDataPointer,SystemThreadHandle - ResourceDataOffset >> 3 & MAX_UNSIGNED_32_BIT,0,ConfigurationFlag,ResourceHash,localSystemPointer,ThreadContextFlag);
  } while (systemIndex == 0);
  SystemThreadSyncBroadcast(SystemResourceManager + 0x150);
  systemIndex = _Mtx_unlock(localSystemPointer);
  if (systemIndex != 0) {
    __Throw_C_error_std__YAXH_Z(systemIndex);
  }
  if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationDataPointer + 0x38))();
  }
  return;
}




// 函数: void ReleaseSystemResourceEx(void* *SystemResourceManager)
/**
 * @brief 系统资源释放器函数
 * 
 * 该函数负责释放系统资源，清理内存和句柄。
 * 它会处理资源的释放操作，确保资源被正确清理。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要释放的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的释放和清理
 */
void ReleaseSystemResourceEx(void* *SystemResourceManager)

{
  CloseHandle(*SystemResourceManager);
  return;
}




// 函数: void ResetSystemResource(void* *SystemResourceManager)
/**
 * @brief 系统资源重置器函数
 * 
 * 该函数负责重置系统资源，恢复资源到初始状态。
 * 它会处理资源的重置操作，确保资源可以重新使用。
 * 
 * @param SystemResourceManager 系统资源指针数组，包含需要重置的资源信息
 * @note 这是系统资源管理的重要组成部分，用于资源的重置和恢复
 */
void ResetSystemResource(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemMemoryData2;
  if (*(char*)((long long)SystemResourceManager + 0xb1) != '\0') {
    ValidateSystemMemoryStatus();
  }
  _Mtx_destroy_in_situ();
  *SystemResourceManager = &SystemResourceSecondaryTemplate;
  SystemResourceManager[7] = &SystemGlobalDataReference;
  if (SystemResourceManager[8] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[8] = 0;
  *(uint32_t *)(SystemResourceManager + 10) = 0;
  SystemResourceManager[7] = &SystemMemoryAllocatorReference;
  SystemResourceManager[1] = &SystemGlobalDataReference;
  if (SystemResourceManager[2] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[2] = 0;
  *(uint32_t *)(SystemResourceManager + 4) = 0;
  SystemResourceManager[1] = &SystemMemoryAllocatorReference;
  return;
}



/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统内存管理器，设置系统资源指针和内存数据。
 * 主要用于系统内存管理的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 *FUN_180061300：InitializeSystemMemoryManager
 */
void* *
InitializeSystemMemoryManager(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  *SystemResourceManager = &SystemMemoryData2;
  if (*(char*)((long long)SystemResourceManager + 0xb1) != '\0') {
    ValidateSystemMemoryStatus();
  }
  _Mtx_destroy_in_situ();
  ReleaseSystemResourceManager(SystemResourceManager);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xb8,AdditionalParameter,ConfigurationFlag,SystemOperationStatus);
  }
  return SystemResourceManager;
}





// 函数: void StartInputSystem(void* SystemResourceManager,long long ConfigurationDataPointer)
void StartInputSystem(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  uint8_t SystemEncryptionBuffer [32];
  long long SystemMemoryOffset248;
  void* *SystemHashNodePointer;
  uint8_t SystemConfigBuffer [8];
  long long SystemMemoryOffset228;
  uint SystemAllocationSize;
  long long SystemTempValue;
  uint8_t SystemOperationBuffer [80];
  void* SystemOperationFlags;
  void* *SystemResourcePointer;
  uint8_t *SystemCalculationFlags;
  uint32_t SystemStackFlag;
  uint8_t SystemPathBuffer [88];
  uint8_t SystemStackBuffer [256];
  ulong long SystemContextValue;
  
  SystemThreadHandle = SystemContextManagerPointer;
  resourceDataIndex = SystemAllocationFlagsTemplate;
  SystemOperationFlag1b8 = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)SystemEncryptionBuffer;
  SystemTempValue = SystemContextManagerPointer;
  SystemResourcePointer = &SystemResourceTemplateSecondary;
  SystemCalculationFlags = SystemPathBuffer;
  SystemPathBuffer[0] = 0;
  SystemStackFlag = 6;
  strcpy_s(SystemPathBuffer,0x10,&SystemStringPathTemplate);
  SystemHashNodeData = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x208,8,3);
  SystemMemoryOffset248 = resourceDataIndex + 0x70;
  SystemHashNodePointer = SystemHashNodeData;
  InitializeSystemDataMemoryContext(SystemHashNodeData,&SystemResourcePointer,3,resourceDataIndex + 0x2e0);
  *SystemHashNodeData = &SystemValueReference;
  SystemHashNodePointer = SystemHashNodeData;
  ProcessSystemHashNodeData(SystemHashNodeData);
  InitializeSystemHandle(resourceDataIndex + 0x48,&SystemHashNodePointer);
  *(void* **)(SystemThreadHandle + 400) = SystemHashNodeData;
  SystemResourcePointer = &SystemMemoryAllocatorReference;
  ExecuteSystemConfigurationUpdate(SystemGlobalStatusFlags + 0x170,SystemConfigBuffer,&SystemConfigurationData);
  if (0 < *(int *)(ConfigurationDataPointer + 0x10)) {
    ExecuteSystemCommand(SystemConfigBuffer,SystemAllocationSize + *(int *)(ConfigurationDataPointer + 0x10));
      memcpy((ulong long)SystemAllocationSize + SystemMemoryOffset228,*(void* *)(ConfigurationDataPointer + 8),
           (long long)(*(int *)(ConfigurationDataPointer + 0x10) + 1));
  }
  InitializeSystemMemoryPool(aSystemMaxOperationCount8,SystemConfigBuffer);
  ConfigureSystemMemoryPool(aSystemMaxOperationCount8,1);
    memset(SystemStackBuffer,0,0x100);
}





// 函数: void ValidateSystemComponent(long long* SystemResourceManager)
void ValidateSystemComponent(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  long long ResourceDataOffset;
  void* resourceAddress;
  long long *SystemLocalContextPointer;
  long long *pSystemThreadFlags;
  long long *plocalDataIndex;
  long long *PrimaryResourcePointer;
  long long **pSecondaryResourcePointer;
  long long *SystemResourceHandle;
  long long *pStackValue1;
  
  ResourceDataOffset = SystemContextManagerPointer;
  PrimaryResourcePointer = SystemResourceManager;
  resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,InvalidHandleValue);
  SystemLocalContextPointer = (long long *)AllocateSystemMemory(resourceAddress,0,ResourceDataOffset);
  SystemResourceHandle = SystemLocalContextPointer;
  if (SystemLocalContextPointer != (long long *)0x0) {
    (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
  }
  SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
  SystemStringPointer = *(code **)*SystemDataPointer;
  pSecondaryResourcePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = SystemLocalContextPointer;
  if (SystemLocalContextPointer != (long long *)0x0) {
    (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
  }
  (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
  resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  pSystemThreadFlags = (long long *)AllocateSystemMemory(resourceAddress,4,ResourceDataOffset);
  pStackValue1 = pSystemThreadFlags;
  if (pSystemThreadFlags != (long long *)0x0) {
    (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
  }
  SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
  SystemStringPointer = *(code **)*SystemDataPointer;
  pSecondaryResourcePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = pSystemThreadFlags;
  if (pSystemThreadFlags != (long long *)0x0) {
    (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
  }
  (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
  resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  plocalDataIndex = (long long *)AllocateSystemMemory(resourceAddress,0,ResourceDataOffset);
  if (plocalDataIndex != (long long *)0x0) {
    pSecondaryResourcePointer = (long long **)plocalDataIndex;
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  SystemResourceHandle = plocalDataIndex;
  if (SystemLocalContextPointer != (long long *)0x0) {
    pSecondaryResourcePointer = (long long **)SystemLocalContextPointer;
    (**(code **)(*SystemLocalContextPointer + 0x38))(SystemLocalContextPointer);
  }
  SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
  SystemStringPointer = *(code **)*SystemDataPointer;
  pSecondaryResourcePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = plocalDataIndex;
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
  ProcessSystemCallback(*(void* *)(ResourceDataOffset + 400));
  if (pSystemThreadFlags != (long long *)0x0) {
    (**(code **)(*pSystemThreadFlags + 0x38))(pSystemThreadFlags);
  }
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x38))(plocalDataIndex);
  }
  return;
}





/**
 * @brief 初始化系统上下文管理器
 * 
 * 该函数负责初始化系统上下文管理器，分配系统内存并设置上下文管理所需的资源。
 * 主要用于系统上下文的创建和管理工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向系统资源数据结构
 * 
 *ProcessSystemValidation：InitializeSystemContextManager
 */
void InitializeSystemContextManager(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  long long ResourceDataOffset;
  void* resourceAddress;
  long long *SystemLocalContextPointer;
  long long *pSystemThreadFlags;
  long long *plocalDataIndex;
  long long *PrimaryResourcePointer;
  long long **pSecondaryResourcePointer;
  long long *SystemResourceHandle;
  long long *pStackValue1;
  
  ResourceDataOffset = SystemContextManagerPointer;
  PrimaryResourcePointer = SystemResourceManager;
  resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,InvalidHandleValue);
  SystemLocalContextPointer = (long long *)AllocateSystemMemory(resourceAddress,0,ResourceDataOffset);
  SystemResourceHandle = SystemLocalContextPointer;
  if (SystemLocalContextPointer != (long long *)0x0) {
    (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
  }
  SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
  SystemStringPointer = *(code **)*SystemDataPointer;
  pSecondaryResourcePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = SystemLocalContextPointer;
  if (SystemLocalContextPointer != (long long *)0x0) {
    (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
  }
  (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
  resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  pSystemThreadFlags = (long long *)AllocateSystemMemory(resourceAddress,3,ResourceDataOffset);
  pStackValue1 = pSystemThreadFlags;
  if (pSystemThreadFlags != (long long *)0x0) {
    (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
  }
  SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
  SystemStringPointer = *(code **)*SystemDataPointer;
  pSecondaryResourcePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = pSystemThreadFlags;
  if (pSystemThreadFlags != (long long *)0x0) {
    (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
  }
  (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
  resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3);
  plocalDataIndex = (long long *)AllocateSystemMemory(resourceAddress,0,ResourceDataOffset);
  if (plocalDataIndex != (long long *)0x0) {
    pSecondaryResourcePointer = (long long **)plocalDataIndex;
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  SystemResourceHandle = plocalDataIndex;
  if (SystemLocalContextPointer != (long long *)0x0) {
    pSecondaryResourcePointer = (long long **)SystemLocalContextPointer;
    (**(code **)(*SystemLocalContextPointer + 0x38))(SystemLocalContextPointer);
  }
  SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
  SystemStringPointer = *(code **)*SystemDataPointer;
  pSecondaryResourcePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = plocalDataIndex;
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x28))(plocalDataIndex);
  }
  (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
  ProcessSystemCallback(*(void* *)(ResourceDataOffset + 400));
  if (pSystemThreadFlags != (long long *)0x0) {
    (**(code **)(*pSystemThreadFlags + 0x38))(pSystemThreadFlags);
  }
  if (plocalDataIndex != (long long *)0x0) {
    (**(code **)(*plocalDataIndex + 0x38))(plocalDataIndex);
  }
  return;
}




/**
 * @brief 执行系统数据操作
 * 
 * 该函数负责执行系统数据操作，处理系统级别的数据操作
 * 用于系统数据的管理和执行
 * 
 * @note 这是一个系统数据操作函数，用于系统数据管理的执行工作
 */
void ExecuteSystemDataOperation(void)

{
    SystemDataOperation();
}




/**
 * @brief 处理系统资源配置操作
 * 
 * 该函数负责处理系统资源配置操作，执行系统级别的资源配置
 * 用于系统资源的管理和配置
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_1800622d0：ProcessSystemResourceConfigurationOperation
 */
void ProcessSystemResourceConfigurationOperation(void* SystemResourceManager,void* ConfigurationDataPointer,uint32_t AdditionalParameter,void* ConfigurationFlag)

{
  ExecuteSystemDataOperation(SystemResourceManager,ConfigurationDataPointer,0xffffffff00000000,AdditionalParameter,ConfigurationFlag,&stackParameterBuffer);
  return;
}




// 函数: void UpdateContextManagerSystem(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void UpdateContextManagerSystem(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint64_t SystemInitializationFlag;
  void* configurationStackParameter;
  
  SystemParameterPointer = AdditionalParameter;
  configurationStackParameter = ConfigurationFlag;
  ConfigureSystemResourceManager(SystemResourceManager,0,0xffffffff00000000,0xd,ConfigurationDataPointer,&SystemParameterPointer);
  return;
}




/**
 * @brief 系统资源管理器更新函数
 * 
 * 该函数负责更新系统资源管理器，处理资源分配和配置
 * 用于系统资源管理器的动态更新
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_180062340：UpdateSystemResourceManager
 */
void UpdateSystemResourceManager(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemConfigurationPointer;
  
  SystemConfigurationPointer = ConfigurationFlag;
  ExecuteSystemDataOperation(SystemResourceManager,ConfigurationDataPointer,0xffffffff00000000,0xd,AdditionalParameter,&SystemConfigurationPointer);
  return;
}




/**
 * @brief 系统管理器设置函数
 * 
 * 该函数负责设置系统管理器的状态和标志
 * 用于系统管理器的初始化和配置
 * 
 * @note 这是一个简单的系统管理器设置函数
 * 
 *ConfigureSystemManager：ConfigureSystemManager
 */
void ConfigureSystemManager(void)

{
  ExecuteSystemDataOperation();
  return;
}




// 函数: void SystemManagerSetFlags(void)
void SystemManagerSetFlags(void)

{
  InitializeSystemResourceManager();
  return;
}





// 函数: void InitializeSystemManager(long long* SystemResourceManager)
void InitializeSystemManager(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  long long ResourceDataOffset;
  void* resourceAddress;
  long long *SystemLocalContextPointer;
  long long *PrimaryResourcePointer;
  long long *SecondaryResourcePointer;
  long long **ResourceReferencePointer;
  
  ResourceDataOffset = SystemContextManagerPointer;
  if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
    PrimaryResourcePointer = SystemResourceManager;
    resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x70,8,3,InvalidHandleValue);
    SystemLocalContextPointer = (long long *)AllocateSystemMemory(resourceAddress,6,ResourceDataOffset);
    SecondaryResourcePointer = SystemLocalContextPointer;
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
    }
    SystemDataPointer = *(void* **)(ResourceDataOffset + 400);
    SystemStringPointer = *(code **)*SystemDataPointer;
    ResourceReferencePointer = &PrimaryResourcePointer;
    PrimaryResourcePointer = SystemLocalContextPointer;
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x28))(SystemLocalContextPointer);
    }
    (*pSystemOperationResult)(SystemDataPointer,&PrimaryResourcePointer);
    ProcessSystemCallback(*(void* *)(ResourceDataOffset + 400));
    if (SystemLocalContextPointer != (long long *)0x0) {
      (**(code **)(*SystemLocalContextPointer + 0x38))(SystemLocalContextPointer);
    }
  }
  return;
}





// 函数: void ConfigureInputSystem(void)
void ConfigureInputSystem(void)

{
  uint8_t SystemMaxOperationCount8Compact [48];
  uint32_t SystemTimeFlag1d8;
  void* SystemOperationFlag190;
  void* ConcatenatedValue448;
  void* ConcatenatedValue440;
  void* CalculationFlags178;
  uint8_t StackBuffer2 [256];
  ulong long SystemContextValue;
  
  CalculationFlags178 = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)aSystemMaxOperationCount8;
  SystemTimeFlag1d8 = 0;
  ConcatenatedValue440 = SystemContextManagerPointer;
  SystemOperationFlag190 = _time64(0);
  ConcatenatedValue448 = _localtime64(&SystemOperationFlag190);
    memset(StackBuffer2,0,0xff);
}





/**
 * @brief 处理系统资源计数器
 * 
 * 该函数负责处理系统资源的计数器操作，包括资源计数器的递增、
 * 校验和验证以及系统对象的创建。用于系统资源的统计和管理。
 * 
 * @param SystemResourceManager 系统资源指针，用于管理资源计数器
 * 
 *FUN_180062920：ProcessSystemResourceCounter
 */
void ProcessSystemResourceCounter(int *SystemResourceManager)

{
  char SystemNodeFlag;
  char validationStatusFlag;
  uint32_t resourceAllocationContext;
  long long SystemBufferAddress;
  uint32_t *SystemThreadContext;
  char *pcharSignal;
  void** SystemCurrentNode;
  int systemCode;
  ulong long ThreadContextFlag;
  uint8_t SystemDataBuffer1f8 [64];
  void*2 SystemDataBuffer1b8 [4];
  void* *pointerUnsigned1b0;
  uint32_t *SystemResourcePointer1a8;
  uint32_t CalculationFlags1A0;
  void* SystemStackFlag;
  uint32_t SystemOperationFlag190;
  void* *SystemMemoryTemplatePtr;
  long long SystemMemoryOffset180;
  uint32_t SystemOperationFlag170;
  long long SystemMemoryOffset168;
  long long SystemMemoryOffset160;
  void* SystemConfigurationId;
  uint32_t SystemResourceSize;
  void* SystemThreadId148;
  ulong long SystemContextValue;
  
  SystemThreadId148 = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)SystemDataBuffer1f8;
  systemCode = 0;
  SystemOperationFlag190 = 0;
  *SystemResourceManager = *SystemResourceManager + 1;
  if ((*(long long *)(SystemResourceManager + 4) != 0) && (*(long long *)(SystemResourceManager + 2) != 0)) {
      ValidateSystemChecksum(SystemContextValue ^ (ulong long)SystemDataBuffer1f8);
  }
  SystemMemoryOffset168 = 0;
  SystemMemoryOffset160 = 0;
  SystemConfigurationId = 0;
  SystemResourceSize = 3;
  SystemBufferAddress = CreateSystemObject(&SystemMemoryTemplatePtr,SystemGlobalStatusFlags + 0x2c0);
  SystemOperationFlag190 = 1;
  SystemDataBuffer1b8[0] = 0x20;
  if (*(long long *)(SystemBufferAddress + 8) != 0) {
    ProcessSystemBufferData(SystemBufferAddress,&SystemMemoryOffset168,SystemDataBuffer1b8);
  }
  SystemOperationFlag190 = 0;
  SystemMemoryTemplatePtr = &SystemGlobalDataReference;
  if (SystemMemoryOffset180 != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryOffset180 = 0;
  SystemOperationFlag170 = 0;
  SystemMemoryTemplatePtr = &SystemMemoryAllocatorReference;
  pointerUnsigned1b0 = &SystemGlobalDataReference;
  SystemStackFlag = 0;
  SystemResourcePointer1a8 = (uint32_t *)0x0;
  CalculationFlags1A0 = 0;
  SystemThreadContext = (uint32_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x13,0x13);
  *(uint8_t *)SystemThreadContext = 0;
  SystemResourcePointer1a8 = SystemThreadContext;
  resourceAllocationContext = StartSystemThread(SystemThreadContext);
  SystemStackFlag = ConcatenatedValue44(SystemStackFlag._4_4_,resourceAllocationContext);
  *SystemThreadContext = 0x5f657375;
  SystemThreadContext[1] = 0x65726170;
  SystemThreadContext[2] = 0x635f746e;
  SystemThreadContext[3] = 0x6f736e6f;
  *(void*2 *)(SystemThreadContext + 4) = 0x656c;
  *(uint8_t *)((long long)SystemThreadContext + 0x12) = 0;
  CalculationFlags1A0 = 0x12;
  ThreadContextFlag = SystemMemoryOffset160 - SystemMemoryOffset168 >> 5;
  if (ThreadContextFlag != 0) {
    hashTableNode = (void* *)(SystemMemoryOffset168 + 8);
    do {
      if (*(int *)(hashTableNode + 1) == 0x12) {
        pcharSignal = (char *)*hashTableNode;
        SystemBufferAddress = (long long)SystemThreadContext - (long long)pcharSignal;
        do {
          charStatus = *pcharSignal;
          SystemOperationResult = pcharSignal[SystemBufferAddress];
          if (initializationStatusFlag != validationStatusFlag) break;
          pcharSignal = pcharSignal + 1;
        } while (validationStatusFlag != '\0');
        if (charStatus == SystemOperationResult) break;
      }
      systemCode = systemCode + 1;
      hashTableNode = hashTableNode + 4;
    } while ((ulong long)(long long)systemCode < ThreadContextFlag);
  }
  pointerUnsigned1b0 = &SystemGlobalDataReference;
    SystemCleanupFunction(SystemThreadContext);
}




/**
 * @brief 系统控制台文本属性设置函数
 * 
 * 该函数根据配置数据指针的值来设置控制台文本属性，包括颜色和样式。
 * 用于系统输出和用户界面的显示控制。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针（用于选择文本属性）
 * @return 设置结果（成功返回1，失败返回0）
 * 
 *FUN_180062ee0：SetSystemConsoleTextAttribute
 */
void* SetSystemConsoleTextAttribute(void* SystemResourceManager,uint32_t ConfigurationDataPointer)

{
  void*2 SystemOperationStatus;
  int systemResult;
  
  switch(ConfigurationDataPointer) {
  case 0:
    SystemOperationStatus = 4;
    break;
  case 1:
    SystemOperationStatus = 2;
    break;
  case 2:
    SystemOperationStatus = 1;
    break;
  case 3:
    SystemOperationStatus = 0xc;
    break;
  case 4:
    SystemOperationStatus = 10;
    break;
  case 5:
    SystemOperationStatus = 9;
    break;
  case 6:
    SystemOperationStatus = 3;
    break;
  case 7:
    SystemOperationStatus = 0xb;
    break;
  case 8:
    SystemOperationStatus = 6;
    break;
  case 9:
    SystemOperationStatus = 0xe;
    break;
  case 10:
    SystemOperationStatus = 5;
    break;
  case 0xb:
    SystemOperationStatus = 0xd;
    break;
  case 0xc:
    SystemOperationStatus = 7;
    break;
  default:
    SystemOperationStatus = 0xf;
  }
  systemResult = SetConsoleTextAttribute(ConsoleHandle,SystemOperationStatus);
  if (systemResult == 0) {
    InitializeSystemConfigurationData(&SystemConfigurationData);
    return 0;
  }
  return 1;
}





/**
 * @brief 分发系统资源和创建线程
 * 
 * 该函数负责分发系统资源，根据不同的系统状态创建相应的线程。
 * 处理系统资源的分配、线程创建和初始化工作。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源状态和配置信息
 * 
 *FUN_180062fd0：DispatchSystemResourcesAndCreateThreads
 */
void DispatchSystemResourcesAndCreateThreads(long long SystemResourceManager)

{
  uint SystemOperationStatus;
  uint resourceCreationFlags;
  uint32_t resourceAllocationContext;
  int systemIndex;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  long long *plocalDataIndex;
  int systemCode;
  void* *SystemHashBucket;
  void* *SystemDataPointer0;
  uint StackBuffer1 [4];
  uint8_t aSystemParameterPointer [8];
  uint aSystemConfigurationPointer [2];
  void* *SystemProcessFlagsPointer;
  void* *pEncryptionValue68;
  uint32_t SystemThreadContext;
  void* SystemProcessFlags58;
  
  SystemOperationStatus = *(uint *)(SystemResourceManager + 0x28);
  if (SystemOperationStatus < 9) {
    switch(SystemOperationStatus) {
    case 1:
      StackBuffer1[0] = StackBuffer1[0] & 0xffffff00;
      SystemOperationCounterPointer = &SystemStringTemplate;
      if (*(void* **)(SystemResourceManager + 0x38) != (void* *)0x0) {
        SystemOperationCounterPointer = *(void* **)(SystemResourceManager + 0x38);
      }
      ProcessSystemMemoryOperation(*(long long *)(SystemResourceManager + 0x20) + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,SystemOperationCounterPointer,StackBuffer1);
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0x20);
      (**(code **)(*plocalDataIndex + 0x108))(plocalDataIndex,1);
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0x20);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam1);
      SystemProcessFlagsPointer = &SystemGlobalDataReference;
      SystemProcessFlags58 = 0;
      pEncryptionValue68 = (void* *)0x0;
      SystemThreadContext = 0;
      SystemThreadContext = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
      *(uint8_t *)SystemThreadContext = 0;
      pEncryptionValue68 = SystemThreadContext;
      resourceAllocationContext = StartSystemThread(SystemThreadContext);
      SystemProcessFlags58 = ConcatenatedValue44(SystemProcessFlags58.HighPart,resourceAllocationContext);
      *SystemThreadContext = 0x73726f7272655f;
      SystemThreadContext = 7;
      systemCode = *(int *)(SystemResourceManager + 0x40) + -1;
      if (-1 < systemCode) {
        SystemThreadFlags = (long long)systemCode;
        do {
          if (*(char *)(SystemThreadFlags + *(long long *)(SystemResourceManager + 0x38)) == '_') goto code_r0x0001800630e9;
          systemCode = systemCode + -1;
          SystemThreadFlags = SystemThreadFlags + -1;
        } while (-1 < SystemThreadFlags);
      }
      systemCode = -1;
code_r0x0001800630e9:
      ExecuteSystemCodeOperation(SystemResourceManager + 0x30,systemCode,&SystemProcessFlagsPointer);
      SystemProcessFlagsPointer = &SystemGlobalDataReference;
        SystemCleanupFunction(SystemThreadContext);
    case 2:
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam2);
      ValidateSystemMemoryStatus(*(long long *)(SystemResourceManager + 0x20) + 0xd8);
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0x20);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam2);
      ValidateSystemMemoryStatus(*(long long *)(SystemResourceManager + 0x20) + 0x20);
      if (((*(byte *)(*(long long *)(SystemResourceManager + 0x20) + 8) & 2) != 0) &&
         (iRam0000000180c912e0 = iRam0000000180c912e0 + -1, iRam0000000180c912e0 == 0)) {
        ConsoleHandle = 0;
        lRam0000000180c912e8 = 0;
        LOCK();
        SystemGlobalCounter = 0;
        UNLOCK();
        FreeConsole();
      }
      *(uint32_t *)(*(long long *)(SystemResourceManager + 0x20) + 8) = 0xe;
      *(void* *)(*(long long *)(SystemResourceManager + 0x20) + 0x10) = 0xffffffff00000000;
      *(uint8_t *)(*(long long *)(SystemResourceManager + 0x20) + 0x18) = 0;
      **(void* **)(SystemResourceManager + 0x20) = 0;
      break;
    case 3:
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam2);
      ValidateSystemMemoryStatus(*(long long *)(SystemResourceManager + 0x20) + 0xd8);
      CleanupSystemMemoryResources(*(long long *)(SystemResourceManager + 0x20) + 0xe0);
      break;
    case 4:
      aSystemParameterPointer[0] = 0;
      SystemOperationCounterPointer = *(void* **)(*(long long *)(SystemResourceManager + 0x20) + 0xe8);
      SystemDataPointer0 = &SystemStringTemplate;
      if (SystemOperationCounterPointer != (void* *)0x0) {
        SystemDataPointer0 = SystemOperationCounterPointer;
      }
      ProcessSystemMemoryOperation(*(long long *)(SystemResourceManager + 0x20) + 0xd8,SystemDataPointer0,aSystemParameterPointer);
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x108))(plocalDataIndex,1);
      plocalDataIndex = (long long *)(*(long long *)(SystemResourceManager + 0x20) + 0xd8);
      (**(code **)(*plocalDataIndex + 0x70))(plocalDataIndex,&SystemConfigurationParam1);
      break;
    case 5:
      systemCode = *(int *)(SystemResourceManager + 0x58);
      if ((*(int *)(SystemStatusFlags + 0x150) <= systemCode) &&
         (SystemThreadContext = *(void* **)(SystemResourceManager + 0x20),
         (*(ulong long *)(SystemResourceManager + 0x60) & SystemThreadContext[2]) != 0)) {
        resourceCreationFlags = *(uint *)(SystemResourceManager + 0x40);
        SystemOperationCounterPointer = &SystemStringTemplate;
        if (*(void* **)(SystemResourceManager + 0x38) != (void* *)0x0) {
          SystemOperationCounterPointer = *(void* **)(SystemResourceManager + 0x38);
        }
        if ((*(byte *)(SystemThreadContext + 1) & 2) != 0) {
          ExecuteSystemFunctionCall((ulong long)*(uint *)(&SystemFunctionTablePtr + (long long)(int)SystemOperationStatus * 4) +
                        0x180000000,*(uint32_t *)(SystemResourceManager + 0x50));
          systemIndex = WriteConsoleA(ConsoleHandle,SystemOperationCounterPointer,resourceCreationFlags,aSystemConfigurationPointer,0);
          if ((systemIndex == 0) || (aSystemConfigurationPointer[0] < resourceCreationFlags)) {
            InitializeSystemConfigurationData(&SystemDataBufferTemplateA,SystemOperationCounterPointer);
          }
          systemIndex = SetConsoleTextAttribute(ConsoleHandle,0xf);
          if (systemIndex == 0) {
            InitializeSystemConfigurationData(&SystemConfigurationData);
          }
        }
        if ((*(byte *)(SystemThreadContext + 1) & 8) != 0) {
          (**(code **)(SystemThreadContext[4] + 0x70))(SystemThreadContext + 4,SystemOperationCounterPointer);
          if (1 < systemCode) {
            (**(code **)(SystemThreadContext[0x1b] + 0x70))(SystemThreadContext + 0x1b,SystemOperationCounterPointer);
          }
        }
        if ((code *)*SystemThreadContext != (code *)0x0) {
          (*(code *)*SystemThreadContext)(SystemOperationCounterPointer);
        }
      }
      break;
    case 6:
      if ((*(byte *)(*(long long *)(SystemResourceManager + 0x20) + 8) & 8) != 0) {
        (**(code **)(*(long long *)(*(long long *)(SystemResourceManager + 0x20) + 0x20) + 0x118))();
        (**(code **)(*(long long *)(*(long long *)(SystemResourceManager + 0x20) + 0xd8) + 0x118))();
      }
      break;
    case 7:
      *(void* *)(*(long long *)(SystemResourceManager + 0x20) + 0x10) = *(void* *)(SystemResourceManager + 0x60);
      break;
    case 8:
      if ((ConsoleHandle != 0) && (lRam0000000180c912e8 != 0)) {
        StackBuffer1[0] = *(uint *)(SystemResourceManager + 0x68);
        SetConsoleScreenBufferSize(ConsoleHandle,StackBuffer1[0]);
      }
    }
  }
  else {
    ConfigureSystemParameters(&SystemConfigurationParam3);
  }
  return;
}



/**
 * @brief 格式化系统资源字符串
 * 
 * 该函数负责格式化系统资源的字符串，使用类似printf的格式化功能。
 * 主要用于系统资源字符串的格式化和输出。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 格式化结果状态码，-1表示失败
 * 
 *FormatSystemResourceString：FormatSystemResourceString
 */
int FormatSystemResourceString(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  void** SystemDataTable;
  void* SystemConfigurationPointer;
  
  SystemConfigurationPointer = ConfigurationFlag;
  SystemHashEntryPointer = (void* *)SystemGlobalDataAllocate();
  SystemOperationStatus = __stdio_common_vsprintf_s(*SystemHashEntryPointer,SystemResourceManager,ConfigurationDataPointer,AdditionalParameter,0,&SystemConfigurationPointer);
  if (SystemOperationStatus < 0) {
    SystemOperationStatus = -1;
  }
  return SystemOperationStatus;
}



/**
 * @brief 搜索系统资源
 * 
 * 该函数负责在系统资源中搜索匹配的配置数据，通过遍历资源表
 * 和比较配置参数来查找符合条件的系统资源。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源表信息
 * @param ConfigurationDataPointer 配置数据指针，包含搜索条件
 * @return 找到的资源索引或相关状态信息
 * 
 *SearchSystemResource：SearchSystemResource
 */
ulong long SearchSystemResource(long long* SystemResourceManager,long long ConfigurationDataPointer)

{
  byte *pisByteValid;
  uint resourceCreationFlags;
  uint resourceAllocationContext;
  long long SystemBufferAddress;
  ulong long in_RAX;
  byte *pisMemoryReady;
  uint ResourceHash;
  ulong long ThreadContextFlag;
  long long SystemMemoryAddress;
  int systemId;
  long long SystemAllocationFlags;
  
  SystemBufferAddress = *SystemResourceManager;
  systemId = 0;
  ThreadContextFlag = SystemResourceManager[1] - SystemBufferAddress >> 5;
  if (ThreadContextFlag != 0) {
    resourceCreationFlags = *(uint *)(ConfigurationDataPointer + 0x10);
    SystemAllocationFlags = 0;
    do {
      resourceAllocationContext = *(uint *)(SystemAllocationFlags + 0x10 + SystemBufferAddress);
      pisMemoryReady = (byte *)(ulong long)resourceAllocationContext;
      ResourceHash = resourceCreationFlags;
      if (resourceAllocationContext == resourceCreationFlags) {
        if (resourceAllocationContext != 0) {
          pisMemoryReady = *(byte **)(SystemAllocationFlags + 8 + SystemBufferAddress);
          SystemMemoryAddress = *(long long *)(ComparisonDataPointer + 8) - (long long)pisMemoryReady;
          do {
            pisByteValid = pisMemoryReady + SystemMemoryAddress;
            ResourceHash = (uint)*pisMemoryReady - (uint)*pisByteValid;
            if (ResourceHash != 0) break;
            pisMemoryReady = pisMemoryReady + 1;
          } while (*pisByteValid != 0);
        }
MemoryAllocationLoop:
        if (ResourceHash == 0) {
          return CONCAT71((int7)((ulong long)pisMemoryReady >> 8),1);
        }
      }
      else if (resourceAllocationContext == 0) goto MemoryAllocationLoop;
      systemId = systemId + 1;
      SystemAllocationFlags = SystemAllocationFlags + 0x20;
      in_RAX = (ulong long)systemId;
    } while (in_RAX < ThreadContextFlag);
  }
  return in_RAX & MAX_UNSIGNED_32_BITffffff00;
}




/**
 * @brief 初始化系统字符串格式化
 * 
 * 该函数负责初始化系统字符串格式化功能，调用相应的
 * 格式化初始化函数来设置字符串处理环境。
 * 
 *FUN_1800635c0：InitializeSystemStringFormatting
 */
void InitializeSystemStringFormatting(void)

{
  FinalizeSystemInitialization();
  return;
}



/**
 * @brief 格式化系统资源字符串（扩展版本）
 * 
 * 该函数负责格式化系统资源的字符串，使用扩展的格式化功能。
 * 主要用于系统资源字符串的格式化和输出，支持额外的格式化选项。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 格式化结果状态码，-1表示失败
 * 
 *FUN_1800635e0：FormatSystemResourceStringExtended
 */
int FormatSystemResourceStringExtended(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  ulong long *SystemHashEntryPointer;
  
  SystemHashEntryPointer = (ulong long *)SystemGlobalDataAllocate();
  SystemOperationStatus = __stdio_common_vsprintf(*SystemHashEntryPointer | 2,SystemResourceManager,ConfigurationDataPointer,AdditionalParameter,0,ConfigurationFlag);
  if (SystemOperationStatus < 0) {
    SystemOperationStatus = -1;
  }
  return SystemOperationStatus;
}



/**
 * @brief 配置系统资源
 * 
 * 该函数负责配置系统资源，设置系统全局数据引用和内存分配器引用。
 * 主要用于系统资源的配置和初始化。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 *FUN_180063650：ConfigureSystemResources
 */
void* *
ConfigureSystemResources(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  SystemResourceManager[6] = &SystemGlobalDataReference;
  if (SystemResourceManager[7] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[7] = 0;
  *(uint32_t *)(SystemResourceManager + 9) = 0;
  SystemResourceManager[6] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemMemoryTemplateC;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x70,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}



void* *
AllocateSystemMemory(void* *SystemResourceManager,uint32_t ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  
  *SystemResourceManager = &SystemMemoryTemplateA;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *SystemResourceManager = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(SystemResourceManager + 2) = 0;
  UNLOCK();
  SystemResourceManager[3] = 0xffffffffffffffff;
  *SystemResourceManager = &SystemMemoryBufferTemplate;
  PrimaryResourcePointer = SystemResourceManager + 6;
  *PrimaryResourcePointer = (long long)&SystemMemoryAllocatorReference;
  SystemResourceManager[7] = 0;
  *(uint32_t *)(SystemResourceManager + 8) = 0;
  *PrimaryResourcePointer = (long long)&SystemGlobalDataReference;
  SystemResourceManager[9] = 0;
  SystemResourceManager[7] = 0;
  *(uint32_t *)(SystemResourceManager + 8) = 0;
  *(uint32_t *)(SystemResourceManager + 5) = ConfigurationDataPointer;
  SystemResourceManager[4] = AdditionalParameter;
  (**(code **)(*PrimaryResourcePointer + 0x10))(PrimaryResourcePointer,&SystemStringTemplate,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  *(uint32_t *)(SystemResourceManager + 10) = 0xd;
  *(void* *)((long long)SystemResourceManager + 0x54) = 0xe;
  SystemResourceManager[0xc] = 0xffffffff00000000;
  *(uint32_t *)(SystemResourceManager + 0xd) = 0;
  return SystemResourceManager;
}



/**
 * InitializeSecurityCallbackStructure - 初始化安全回调结构
 * @param SystemResourceManager 系统资源指针
 * @return 返回初始化后的系统资源指针
 * 
 *FUN_1800637c0：InitializeSecurityCallbackStructure
 */
long long InitializeSecurityCallbackStructure(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(code **)(SystemResourceManager + 0x18) = SystemSecurityValidationCallback;
  return SystemResourceManager;
}



/**
 * InitializeGuardCallbackStructure - 初始化保护回调结构
 * @param SystemResourceManager 系统资源指针
 * @return 返回初始化后的系统资源指针
 * 
 *FUN_1800637f0：InitializeGuardCallbackStructure
 */
long long InitializeGuardCallbackStructure(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(code **)(SystemResourceManager + 0x18) = _guard_check_icall;
  return SystemResourceManager;
}





/**
 * InitializeSecurityContext - 初始化安全上下文
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_180063820：InitializeSecurityContext
 */
void InitializeSecurityContext(void* SystemResourceManager)

{
  uint8_t securityBuffer [96];
  uint8_t configurationBuffer [64];
  void* stackValue1;
  void* contextValue;
  uint8_t memoryBuffer [512];
  ulong long securityKey;
  
  stackValue1 = 0xfffffffffffffffe;
  securityKey = SystemEncryptionKeyTemplate ^ (ulong long)securityBuffer;
  contextValue = SystemResourceManager;
  CreateSystemObject(configurationBuffer,SystemContextManagerPointer + 0x28);
    memset(memoryBuffer,0,0x200);
}





/**
 * ConfigureSecurityParameters - 配置安全参数
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_180063b30：ConfigureSecurityParameters
 */
void ConfigureSecurityParameters(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  char *stringPointer;
  void* *dataPointer;
  long long stringLength;
  long long loopCounter1;
  long long SystemTimeValue;
  long long fileHandle;
  void* stackValue1;
  long long outputStream;
  void* *stackPointer1;
  void* *stackPointer2;
  uint32_t stackValue2;
  
  stackValue1 = 0;
  outputStream = 0;
  AllocateSystemStackMemory(SystemResourceManager,&stackPointer1,&SystemStackAllocationTemplate);
  dataPointer = &SystemStringTemplate;
  if (stackPointer2 != (void* *)0x0) {
    dataPointer = stackPointer2;
  }
  ProcessSystemResourceData(&stackValue1,dataPointer,&SystemEventTemplate);
  fileHandle = outputStream;
  SystemTimeValue = -1;
  stringLength = SystemTimeValue;
  loopCounter1 = SystemTimeValue;
  if (ConfigurationDataPointer != 0) {
    do {
      stringLength = stringLength + 1;
    } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
    if (stringLength != 0) {
      fwrite(ConfigurationDataPointer,stringLength,1,outputStream);
    }
  }
  do {
    stringLength = loopCounter1 + 1;
    stringPointer = (char *)(loopCounter1 + 0x180c84871);
    loopCounter1 = stringLength;
  } while (*stringPointer != '\0');
  if (stringLength != 0) {
    fwrite(&SystemFileTemplateBuffer,0x30,1,fileHandle);
    fwrite(&SystemStringBuffer,stringLength,1,fileHandle);

/**
 * @brief 系统资源清理和验证函数
 * 
 * 该函数负责清理系统资源，包括：
 * 1. 遍历和清理系统资源表
 * 2. 验证系统内存完整性
 * 3. 执行系统清理回调函数
 * 4. 释放系统资源并重置状态
 * 
 * 主要用于系统关闭或重置时的资源清理工作
 * 
 * @note 此函数包含复杂的资源管理逻辑和内存验证机制
 * @warning 调用此函数会释放所有系统资源，可能导致系统状态重置
 * 
 *FUN_180063cf0：CleanupAndValidateSystemResources
 */
void CleanupAndValidateSystemResources(void)

{
  void** SystemDataPointer;
  bool isSystemActive;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  void* SystemThreadContext;
  int CalculationFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  void* *SystemHashBucket;
  uint SystemOperationFlags;
  void* *pSystemSecondaryStatus;
  ulong long SystemOperationResultCode;
  int SystemOperationStatusCode;
  long long ResourceDataIndex;
  uint SystemOperationStatusFlag;
  uint8_t SystemResourceValueArray [32];
  void* *SecondarySystemStatusPointer;
  void* *PrimarySystemStatusPointer;
  void* SystemOperationContext;
  uint32_t SystemDataItemCount;
  void* *SystemDataBufferPointer;
  void* *SystemHashTablePointer;
  void* SystemOperationContext;
  uint32_t SystemOperationStatus;
  void* *pSystemProcessFlags;
  long long SystemMemoryOffset288;
  uint32_t SystemMemoryOffset;
  void* SystemMemoryPointer;
  uint8_t aSystemDataBuffer268 [32];
  long long SystemMemoryOffset248;
  uint8_t SystemDataBuffer238 [512];
  ulong long SystemContextValue;
  ulong long SystemOperationStatus1;
  
  SystemMemoryPointer = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)aSystemResourceValue;
  SystemOperationStatus1 = 0;
  InitializeSystemStackPointer(&pSystemProcessFlags);
  pSystemAllocationFlag = (void* *)0x0;
  pSystemResourceHandle = (void* *)0x0;
  SystemOperationFlag = 0;
  SystemDataCount2c0 = 3;
  pSystemMemoryPoolSize = (void* *)0x0;
  pointerUnsigned2a8 = (void* *)0x0;
  SystemOperationContext = 0;
  SystemOperationStatus = 3;
  ConfigureSystemStackAllocation(&pSystemProcessFlags,&pSystemAllocationFlag,&pSystemMemoryPoolSize);
  SystemOperationStatus4 = -1;
  resourceDataIndex5 = -0x8000000000000000;
  SystemOperationStatusFlags = (uint)((long long)pSystemResourceHandle - (long long)pSystemAllocationFlag >> 5);
  SystemOperationStatus3 = SystemOperationStatus1;
  SystemHashNodeData = pSystemResourceHandle;
  pSystemSecondaryStatus = pSystemMemoryPoolSize;
  presourceAddress = pointerUnsigned2a8;
  if (SystemOperationStatusFlags != 0) {
    do {
      CalculationFlags = *(int *)((long long)pSystemAllocationFlag + SystemOperationStatus3 + 0x10);
      if (CalculationFlags < 4) {
SystemActivityCheck:
        isSystemActive = false;
      }
      else {
        localDataIndex = 0;
        do {
          SystemMemoryAddress = localDataIndex + 1;
          if (*(char *)(*(long long *)((long long)pSystemAllocationFlag + SystemOperationStatus3 + 8) + (long long)(CalculationFlags + -4) +
                       localDataIndex) != (&SystemMemoryOffsetTable)[localDataIndex]) goto SystemActivityCheck;
          localDataIndex = SystemMemoryAddress;
        } while (SystemMemoryAddress != 5);
        isSystemActive = true;
      }
      if (isSystemActive) {
        SystemDataPointer = *(void* **)((long long)pSystemAllocationFlag + SystemOperationStatus3 + 8);
        SystemOperationCounterPointer = &SystemStringTemplate;
        if (SystemDataPointer != (void* *)0x0) {
          SystemOperationCounterPointer = SystemDataPointer;
        }
        CalculationFlags = _stat64i32(SystemOperationCounterPointer,aSystemDataBuffer268);
        if ((CalculationFlags != -1) && (resourceDataIndex5 < SystemMemoryOffset248)) {
          resourceDataIndex5 = SystemMemoryOffset248;
          SystemOperationStatus4 = (int)SystemOperationStatus1;
        }
      }
      SystemOperationFlags = (int)SystemOperationStatus1 + 1;
      SystemOperationStatus1 = (ulong long)SystemOperationFlags;
      SystemOperationStatus3 = SystemOperationStatus3 + 0x20;
    } while (SystemOperationFlags < SystemOperationStatusFlags);
    SystemHashNodeData = pSystemResourceHandle;
    pSystemSecondaryStatus = pSystemMemoryPoolSize;
    presourceAddress = pointerUnsigned2a8;
    if (-1 < SystemOperationStatus4) {
        memset(SystemDataBuffer238,0,0x200);
    }
  }
  for (; SystemThreadContext = pointerUnsigned2a8, pSystemResourceHandle = SystemHashNodeData, pSystemSecondaryStatus != pointerUnsigned2a8; pSystemSecondaryStatus = pSystemSecondaryStatus + 4)
  {
    pointerUnsigned2a8 = presourceAddress;
    (**(code **)*pSystemSecondaryStatus)(pSystemSecondaryStatus,0);
    SystemHashNodeData = pSystemResourceHandle;
    presourceAddress = pointerUnsigned2a8;
    pointerUnsigned2a8 = SystemThreadContext;
  }
  if (pSystemMemoryPoolSize == (void* *)0x0) {
    pSystemMemoryPoolSize = (void* *)0x0;
    pointerUnsigned2a8 = presourceAddress;
    for (pSystemSecondaryStatus = pSystemAllocationFlag; pSystemSecondaryStatus != SystemHashNodeData; pSystemSecondaryStatus = pSystemSecondaryStatus + 4) {
      (**(code **)*pSystemSecondaryStatus)(pSystemSecondaryStatus,0);
    }
    if (pSystemAllocationFlag != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemProcessFlags = &SystemGlobalDataReference;
    if (SystemMemoryOffset288 != 0) {
        SystemCleanupFunction();
    }
    SystemMemoryOffset288 = 0;
    SystemMemoryOffset = 0;
    pSystemProcessFlags = &SystemMemoryAllocatorReference;
      ValidateSystemChecksum(SystemContextValue ^ (ulong long)aSystemResourceValue);
  }
  pointerUnsigned2a8 = presourceAddress;
    SystemCleanupFunction();
}





/**
 * @brief 系统资源初始化和配置函数
 * 
 * 该函数负责初始化和配置系统资源，包括：
 * 1. 设置系统配置参数
 * 2. 初始化系统数据表和缓冲区
 * 3. 处理系统资源数据
 * 4. 初始化主要资源组件
 * 5. 管理文件句柄和引用计数
 * 
 * 主要用于系统资源的初始化和配置工作
 * 
 * @param SystemResourceManager 系统资源指针，用于标识和访问系统资源
 * 
 * @note 此函数包含复杂的资源初始化逻辑和文件句柄管理
 * @warning 调用此函数会修改系统状态，需要在合适的上下文中调用
 * 
 *FUN_180064010：InitializeAndConfigureSystemResources
 */
void InitializeAndConfigureSystemResources(void* SystemResourceManager)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  uint8_t SystemDataBuffer358 [64];
  void* *pSystemMemoryBufferPointer;
  void* *pointerUnsigned310;
  void* SystemResourceStatusFlag8;
  uint32_t SystemResourceStatusFlag0;
  void* SystemResourceValue;
  long long SystemMemoryOffset2f0;
  void* SystemOperationFlag2e0;
  long long SystemMemoryOffset2d8;
  void* *pointerUnsigned2c0;
  void* *pSystemDataCount;
  void* SystemMemoryPoolSize;
  uint32_t SystemOperationFlag2a8;
  void* *pointerUnsigned2a0;
  long long SystemMemoryOffset298;
  uint32_t EncryptionKeyValue8;
  void* *pEncryptionKeyValue0;
  void* *pSystemMemoryOffset;
  uint32_t SystemDataBuffer268;
  void* SystemResourceHandle;
  void* *pointerUnsigned258;
  uint32_t SystemDataBufferOffset;
  void* SystemThreadStackSize;
  uint8_t SystemDataBuffer238 [512];
  ulong long SystemContextValue;
  
  SystemThreadStackSize = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)SystemDataBuffer358;
  SetupSystemConfiguration(&pointerUnsigned2a0);
  pSystemMemoryBufferPointer = (void* *)0x0;
  pointerUnsigned310 = (void* *)0x0;
  SystemResourceStatusFlag8 = 0;
  SystemResourceStatusFlag0 = 3;
  pointerUnsigned2c0 = (void* *)0x0;
  pSystemDataCount = (void* *)0x0;
  SystemMemoryPoolSize = 0;
  SystemOperationFlag2a8 = 3;
  ConfigureSystemStackAllocation(&pointerUnsigned2a0,&pSystemMemoryBufferPointer,&pointerUnsigned2c0);
  SystemHashEntryPointer = pSystemDataCount;
  SystemDataPointer = pointerUnsigned310;
  presourceAddress = pointerUnsigned2c0;
  if ((int)((long long)pointerUnsigned310 - (long long)pSystemMemoryBufferPointer >> 5) != 0) {
      memset(SystemDataBuffer238,0,0x200);
  }
  for (; pointerUnsigned310 = SystemDataPointer, presourceAddress != SystemHashEntryPointer; presourceAddress = presourceAddress + 4) {
    (**(code **)*presourceAddress)(presourceAddress,0);
    SystemDataPointer = pointerUnsigned310;
  }
  if (pointerUnsigned2c0 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned2c0 = (void* *)0x0;
  for (presourceAddress = pSystemMemoryBufferPointer; presourceAddress != SystemDataPointer; presourceAddress = presourceAddress + 4) {
    (**(code **)*presourceAddress)(presourceAddress,0);
  }
  if (pSystemMemoryBufferPointer != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned2a0 = &SystemGlobalDataReference;
  if (SystemMemoryOffset298 != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryOffset298 = 0;
  EncryptionKeyValue8 = 0;
  pointerUnsigned2a0 = &SystemMemoryAllocatorReference;
  SystemResourceValue = 0;
  SystemMemoryOffset2f0 = 0;
  AllocateSystemStackMemory(SystemResourceManager,&pEncryptionKeyValue0,&SystemDataBufferTemplate1);
  SystemHashNodeData = &SystemStringTemplate;
  if (pSystemMemoryOffset != (void* *)0x0) {
    SystemHashNodeData = pSystemMemoryOffset;
  }
  ProcessSystemResourceData(&SystemResourceValue,SystemHashNodeData,&SystemEventTemplate);
  InitializePrimaryResource(SystemNodeManagerPointer,&SystemResourceValue);
  if (SystemMemoryOffset2f0 != 0) {
    fclose();
    SystemMemoryOffset2f0 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  pEncryptionKeyValue0 = &SystemGlobalDataReference;
  if (pSystemMemoryOffset != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pSystemMemoryOffset = (void* *)0x0;
  SystemDataBuffer268 = 0;
  pEncryptionKeyValue0 = &SystemMemoryAllocatorReference;
  if (SystemMemoryOffset2f0 != 0) {
    fclose();
    SystemMemoryOffset2f0 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  SystemOperationFlag2e0 = 0;
  SystemMemoryOffset2d8 = 0;
  ConfigureSystemResources(SystemResourceManager,&SystemResourceHandle,&SystemDataBufferTemplate2);
  SystemHashNodeData = &SystemStringTemplate;
  if (pointerUnsigned258 != (void* *)0x0) {
    SystemHashNodeData = pointerUnsigned258;
  }
  ProcessSystemResourceData(&SystemOperationFlag2e0,SystemHashNodeData,&SystemEventTemplate);
  InitializePrimaryResource(SystemMemoryManagerPointer,&SystemOperationFlag2e0);
  if (SystemMemoryOffset2d8 != 0) {
    fclose();
    SystemMemoryOffset2d8 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  SystemResourceHandle = &SystemGlobalDataReference;
  if (pointerUnsigned258 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned258 = (void* *)0x0;
  SystemDataBufferOffset = 0;
  SystemResourceHandle = &SystemMemoryAllocatorReference;
  if (SystemMemoryOffset2d8 != 0) {
    fclose();
    SystemMemoryOffset2d8 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
    ValidateSystemChecksum(SystemContextValue ^ (ulong long)SystemDataBuffer358);
}




/**
 * @brief 系统数据操作执行函数
 * 
 * 该函数负责执行系统数据操作，调用核心的数据处理功能
 * 用于系统运行时的数据处理和管理
 * 
 * @note 这是一个简化的系统操作函数，主要用于触发数据操作
 * @warning 调用此函数会执行系统数据操作，可能影响系统状态
 * 
 *FUN_180064400：ExecuteSystemDataOperation
 */
void ExecuteSystemDataOperation(void)

{
    SystemDataOperation();
}




/**
 * @brief 系统资源处理和数据管理函数
 * 
 * 该函数负责处理系统资源并管理相关数据，包括：
 * 1. 执行系统数据操作
 * 2. 初始化系统管理器
 * 3. 处理内存分配和缓冲区
 * 4. 配置系统数据缓冲区
 * 5. 管理文件操作和引用计数
 * 6. 清理系统资源
 * 
 * 主要用于系统资源的综合处理和管理
 * 
 * @param SystemResourceManager 系统资源指针，用于标识和访问系统资源
 * @return 处理结果状态码，表示操作的成功或失败状态
 * 
 * @note 此函数包含复杂的资源管理和数据处理逻辑
 * @warning 调用此函数会执行系统资源处理，可能影响系统状态
 * 
 *FUN_1800649d0：ProcessAndManageSystemResources
 */
ulong long ProcessAndManageSystemResources(void* SystemResourceManager)

{
  char SystemNodeFlag;
  ulong long resourceCreationFlags;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  long long SystemTimeValue;
  void** SystemRootNode;
  void** SystemCurrentNode;
  void* *systemGlobalDataPtrB8;
  long long LocalSystemBufferOffset;
  int stackVariableA8;
  ulong long UnsignedStackFlagA0;
  void* *stackParameterB;
  void* *pStackParameterC;
  void* UnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  void* SystemUnsignedFlag78;
  long long SystemMemoryOffset70;
  void* *memoryAllocationBuffer;
  void* *memoryAllocationEnd;
  uint32_t SystemOperationCounter;
  void* SystemContextValue;
  
  SystemContextValue = 0xfffffffffffffffe;
  stackParameterB = (void* *)0x0;
  pSystemConfigurationValue = (void* *)0x0;
  UnsignedStackFlag88 = 0;
  UnsignedStackFlag80 = 3;
  SystemConfigurationResult = ConfigureSystemResourceManager(&stackParameterB);
  hashTableNode = pStackParameterC;
  resourceEntryPointer = stackParameterB;
  if ((SystemConfigurationResult == '\0') || (stackParameterB == pStackParameterC)) {
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemDataBufferTemplate3);
    resourceCreationFlags = InitializeSystemManager();
    presourceAddress = resourceEntryPointer;
  }
  else {
    SystemMemoryAllocationFlag = 0;
    SystemMemoryAllocationHandle = 0;
    InitializeSystemMemoryAllocation(SystemResourceManager,&memoryAllocationBuffer,&SystemDataBufferTemplate4);
    SystemHashNodeData = &SystemStringTemplate;
    if (memoryAllocationEnd != (void* *)0x0) {
      SystemHashNodeData = memoryAllocationEnd;
    }
    ProcessSystemResourceData(&SystemMemoryAllocationFlag,SystemHashNodeData,&SystemEventTemplate);
    resourceCreationFlags = (long long)hashTableNode - (long long)resourceEntryPointer >> 5;
    systemGlobalDataPtrB8 = &SystemGlobalDataReference;
    SystemMemoryAllocationOffset = 0;
    SystemMemoryAllocationSize = 0;
    SystemMemoryAllocationCount = 0;
    if ((int)resourceCreationFlags != 0) {
      presourceAddress = resourceEntryPointer + 1;
      resourceCreationFlags = resourceCreationFlags & MAX_UNSIGNED_32_BIT;
      do {
        SystemHashNodeData = &SystemStringTemplate;
        if ((void* *)*presourceAddress != (void* *)0x0) {
          SystemHashNodeData = (void* *)*presourceAddress;
        }
        ConfigureSystemDataBuffer(&systemGlobalDataPtrB8,&SystemDataBufferTemplateA,SystemHashNodeData);
        presourceAddress = presourceAddress + 4;
        resourceCreationFlags = resourceCreationFlags - 1;
      } while (resourceCreationFlags != 0);
    }
    localSystemPointer = SystemMemoryAllocationHandle;
    resourceCreationFlags = fwrite(SystemMemoryAllocationSize,1,(long long)SystemMemoryAllocationCount,SystemMemoryAllocationHandle);
    if (localSystemPointer != 0) {
      fclose(localSystemPointer);
      SystemMemoryAllocationHandle = 0;
      LOCK();
      resourceCreationFlags = (ulong long)SystemReferenceCounterStorage;
      UNLOCK();
      localSystemPointer = 0;
      resourceEntryPointer = stackParameterB;
      hashTableNode = pStackParameterC;
      SystemReferenceCounterStorage = SystemReferenceCounterStorage - 1;
    }
    systemGlobalDataPtrB8 = &SystemGlobalDataReference;
    if (LocalSystemBufferOffset != 0) {
        SystemCleanupFunction();
    }
    LocalSystemBufferOffset = 0;
    UnsignedStackFlagA0 = UnsignedStackFlagA0 & MAX_UNSIGNED_32_BIT00000000;
    systemGlobalDataPtrB8 = &SystemMemoryAllocatorReference;
    memoryAllocationBuffer = &SystemGlobalDataReference;
    if (memoryAllocationEnd != (void* *)0x0) {
        SystemCleanupFunction();
    }
    memoryAllocationEnd = (void* *)0x0;
    SystemOperationCounter = 0;
    memoryAllocationBuffer = &SystemMemoryAllocatorReference;
    presourceAddress = resourceEntryPointer;
    if (localSystemPointer != 0) {
      resourceCreationFlags = fclose(localSystemPointer);
      SystemMemoryOffset70 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage - 1;
      UNLOCK();
      resourceEntryPointer = stackParameterB;
      hashTableNode = pStackParameterC;
      presourceAddress = stackParameterB;
    }
  }
  for (; resourceEntryPointer != hashTableNode; resourceEntryPointer = SystemCurrentNode + 4) {
    resourceCreationFlags = (**(code **)*resourceEntryPointer)(resourceEntryPointer,0);
  }
  if (presourceAddress != (void* *)0x0) {
      SystemCleanupFunction(presourceAddress);
  }
  return resourceCreationFlags;
}





/**
 * @brief 系统资源数据配置和管理函数
 * 
 * 该函数负责配置和管理系统资源数据，包括：
 * 1. 初始化配置数据
 * 2. 处理字符串和缓冲区数据
 * 3. 执行内存分配和管理
 * 4. 配置系统资源指针
 * 5. 管理数据缓冲区和线程对象
 * 
 * 主要用于系统资源数据的配置和管理工作
 * 
 * @param SystemResourceManager 系统资源指针数组，用于存储和管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含系统配置信息
 * @param AdditionalParameter 额外参数，用于传递额外的配置信息
 * 
 * @note 此函数包含复杂的数据配置和内存管理逻辑
 * @warning 调用此函数会修改系统资源配置，可能影响系统状态
 * 
 *FUN_180064c00：ConfigureAndManageSystemResourceData
 */
void ConfigureAndManageSystemResourceData(long long* SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  uint SystemOperationStatus;
  int systemResult;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  uint8_t *SystemThreadContext;
  void* *resourceEntryPointer;
  uint *hashTableNode;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  long long SystemAllocationFlags;
  long long SystemResourceDataIndex;
  long long resourceDataIndex2;
  ulong long SystemOperationStatus3;
  void* *SystemThreadLocalStoragePointer;
  uint8_t encryptionBuffer [32];
  long long hashNodeOffset;
  void* *systemHashPointer;
  uint8_t *systemHashFlags;
  uint32_t MemoryBufferAddress;
  void* StackPointerF0;
  uint32_t StackUnsignedValueE8;
  void* *dataBufferPointer;
  void* SystemMemoryAllocatorStatus;
  void* *dataBufferContext;
  uint8_t StackValueC8;
  void* StackPointerC7;
  void* *systemGlobalDataPtrB8;
  ulong long threadBufferSize;
  uint UnsignedStackFlagA8;
  uint32_t StackUnsignedValueA4;
  uint32_t StackUnsignedValueA0;
  uint32_t StackUnsignedValue9C;
  ulong long systemConfigurationValue;
  ulong long StackParameterC;
  uint8_t StackFlag88;
  void* StackPointer87;
  long long dataBufferLength;
  ulong long SystemProcessFlags70;
  uint EncryptionValue68;
  uint32_t StackUnsignedValue64;
  uint32_t SystemThreadContext;
  uint32_t StackUnsignedValue5C;
  ulong long SystemProcessFlags58;
  ulong long ThreadContextFlag;
  ulong long SystemEncryptionKey;
  
  SystemMemoryAllocatorStatus = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)encryptionBuffer;
  SystemInitializationStatus = 0;
  InitializeConfigurationData();
  resourceEntryPointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    resourceEntryPointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  systemGlobalDataPtrB8 = (void* *)0x0;
  UnsignedStackFlagB0 = 0xf;
  StackValueC8 = 0;
  SystemAllocationFlags = -1;
  resourceDataIndex2 = -1;
  do {
    resourceDataIndex2 = resourceDataIndex2 + 1;
  } while (resourceEntryPointer[resourceDataIndex2] != '\0');
  ReallocateSystemDataBuffer(&StackValueC8);
  resourceEntryPointer = &SystemStringTemplate;
  if (*(void* **)(AdditionalParameter + 8) != (void* *)0x0) {
    resourceEntryPointer = *(void* **)(AdditionalParameter + 8);
  }
  StackInteger78 = 0;
  SystemProcessFlags70 = 0xf;
  UnsignedStackFlag88 = 0;
  do {
    SystemAllocationFlags = SystemAllocationFlags + 1;
  } while (resourceEntryPointer[SystemAllocationFlags] != '\0');
  ReallocateSystemDataBuffer(&UnsignedStackFlag88,resourceEntryPointer,SystemAllocationFlags);
  resourceDataIndex2 = StackInteger78;
  SystemOperationStatus = UnsignedStackFlagA8;
  systemConfigurationValue = 0;
  SystemConfigurationValue = 0xf;
  UnsignedStackFlagA8 = UnsignedStackFlagA8 & 0xffffff00;
  SystemAllocationFlags = CONCAT71(UnsignedStackOffset87,UnsignedStackFlag88);
  ThreadContextFlag = ConcatenatedValue44(UnsignedStackOffsetA4,SystemOperationStatus) & MAX_UNSIGNED_32_BITffffff00;
  SystemThreadContext = &StackValueC8;
  if (0xf < threadBufferSize) {
    SystemThreadContext = (uint8_t *)CONCAT71(StackPointerC7,StackValueC8);
  }
  hashNodeOffset = dataBufferLength;
  SystemHashNodeData = (void* *)InitializeSystemResource(SystemThreadContext,systemGlobalDataPtrB8);
  dataBufferPointer = SystemHashNodeData;
  if (SystemHashNodeData == (void* *)0xffffffffffffffff) {
    if (0xf < StackParameterC) {
      OperationCode = StackParameterC + 1;
      SystemOperationStatus3 = ThreadContextFlag;
      if (0xfff < OperationCode) {
        OperationCode = StackParameterC + 0x28;
        SystemOperationStatus3 = *(ulong long *)(ThreadContextFlag - 8);
        if (0x1f < (ThreadContextFlag - SystemOperationStatus3) - 8) {
            _invalid_parameter_noinfo_noreturn();
        }
      }
      free(SystemOperationStatus3,OperationCode);
    }
    systemConfigurationValue = 0;
    SystemConfigurationValue = 0xf;
    UnsignedStackFlagA8 = UnsignedStackFlagA8 & 0xffffff00;
    if (0xf < SystemProcessFlags70) {
      ThreadContextFlag = SystemProcessFlags70 + 1;
      resourceDataIndex2 = SystemAllocationFlags;
      if (0xfff < ThreadContextFlag) {
        ThreadContextFlag = SystemProcessFlags70 + 0x28;
        resourceDataIndex2 = *(long long *)(SystemAllocationFlags + -8);
        if (0x1f < (SystemAllocationFlags - resourceDataIndex2) - 8U) {
            _invalid_parameter_noinfo_noreturn();
        }
      }
      free(resourceDataIndex2,ThreadContextFlag);
    }
    StackInteger78 = 0;
    SystemProcessFlags70 = 0xf;
    UnsignedStackFlag88 = 0;
    if (0xf < threadBufferSize) {
      ThreadContextFlag = UnsignedStackFlagB0 + 1;
      resourceDataIndex2 = CONCAT71(StackPointerC7,StackValueC8);
      SystemAllocationFlags = resourceDataIndex2;
      if (0xfff < ThreadContextFlag) {
        ThreadContextFlag = UnsignedStackFlagB0 + 0x28;
        SystemAllocationFlags = *(long long *)(resourceDataIndex2 + -8);
        if (0x1f < (resourceDataIndex2 - SystemAllocationFlags) - 8U) {
            _invalid_parameter_noinfo_noreturn();
        }
      }
      free(SystemAllocationFlags,ThreadContextFlag);
    }
    systemGlobalDataPtrB8 = (void* *)0x0;
    UnsignedStackFlagB0 = 0xf;
    StackValueC8 = 0;
      ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)encryptionBuffer);
  }
  SystemProcessFlags58 = 0;
  ThreadContextFlag = 0xf;
  EncryptionValue68 = EncryptionValue68 & 0xffffff00;
  presourceAddress = SystemHashNodeData;
  if (systemGlobalDataPtrB8 < SystemHashNodeData) {
    presourceAddress = systemGlobalDataPtrB8;
  }
  SystemThreadContext = &StackValueC8;
  if (0xf < threadBufferSize) {
    SystemThreadContext = (uint8_t *)CONCAT71(StackPointerC7,StackValueC8);
  }
  ReallocateSystemDataBuffer(&EncryptionValue68,SystemThreadContext,presourceAddress);
  SystemInitializationStatus = 1;
  FreeSystemResourceMemory(&UnsignedStackFlagA8);
  ThreadContextFlag = SystemProcessFlags58;
  SystemOperationStatus = EncryptionValue68;
  UnsignedStackFlagA8 = EncryptionValue68;
  StackUnsignedValueA4 = StackUnsignedValue64;
  UnsignedStackFlagA0 = SystemThreadContext;
  StackUnsignedValue9C = StackUnsignedValue5C;
  SystemConfigurationValue = ThreadContextFlag;
  SystemInitializationStatus = 0;
  SystemProcessFlags58 = 0;
  ThreadContextFlag = 0xf;
  EncryptionValue68 = EncryptionValue68 & 0xffffff00;
  systemConfigurationValue = ThreadContextFlag;
  if (ThreadContextFlag == 0) goto SystemValueCheckComplete;
  SystemAllocationFlags = 0;
  pEncryptionOffset1 = &SystemGlobalDataReference;
  StackPointerF0 = 0;
  pEncryptionOffset2 = (uint8_t *)0x0;
  MemoryBufferAddress = 0;
  systemConfigurationValue._0_4_ = (int)ThreadContextFlag;
  systemResult = (int)systemConfigurationValue;
  systemConfigurationValue = ThreadContextFlag;
  ExecuteSystemCommand(&pEncryptionOffset1,ThreadContextFlag & MAX_UNSIGNED_32_BIT);
  if (systemResult != 0) {
    hashTableNode = &UnsignedStackFlagA8;
    if (0xf < StackParameterC) {
      hashTableNode = (uint *)ConcatenatedValue44(UnsignedStackOffset64,SystemOperationStatus);
    }
      memcpy(pEncryptionOffset2,hashTableNode,ThreadContextFlag & MAX_UNSIGNED_32_BIT);
  }
  MemoryBufferAddress = 0;
  if (pEncryptionOffset2 != (uint8_t *)0x0) {
    *pEncryptionOffset2 = 0;
  }
  presourceAddress = (void* *)SystemResourceManager[1];
  if (presourceAddress < (void* *)SystemResourceManager[2]) {
    SystemResourceManager[1] = (long long)(presourceAddress + 4);
    *presourceAddress = &SystemMemoryAllocatorReference;
    presourceAddress[1] = 0;
    *(uint32_t *)(presourceAddress + 2) = 0;
    *presourceAddress = &SystemGlobalDataReference;
    presourceAddress[3] = 0;
    presourceAddress[1] = 0;
    *(uint32_t *)(presourceAddress + 2) = 0;
    *(uint32_t *)(presourceAddress + 2) = 0;
    presourceAddress[1] = pEncryptionOffset2;
    *(uint32_t *)((long long)presourceAddress + 0x1c) = UnsignedStackOffsetF0._4_4_;
    *(uint32_t *)(presourceAddress + 3) = (uint32_t)UnsignedStackOffsetF0;
    MemoryBufferAddress = 0;
    pEncryptionOffset2 = (uint8_t *)0x0;
    StackPointerF0 = 0;
    dataBufferPointer = presourceAddress;
  }
  else {
    resourceDataIndex2 = *SystemResourceManager;
    SystemResourceDataIndex = (long long)presourceAddress - resourceDataIndex2 >> 5;
    if (SystemResourceDataIndex == 0) {
      SystemResourceDataIndex = 1;
ResourceDataIndexCheckLoop:
      SystemAllocationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemResourceDataIndex << 5,(char)SystemResourceManager[3]);
      presourceAddress = (void* *)SystemResourceManager[1];
      resourceDataIndex2 = *SystemResourceManager;
    }
    else {
      SystemResourceDataIndex = SystemResourceDataIndex * 2;
      if (SystemResourceDataIndex != 0) goto ResourceDataIndexCheckLoop;
    }
    dataBufferContext = (void* *)CopySystemResourceDataExtended(resourceDataIndex2,presourceAddress,SystemAllocationFlags);
    *dataBufferContext = &SystemMemoryAllocatorReference;
    dataBufferContext[1] = 0;
    *(uint32_t *)(dataBufferContext + 2) = 0;
    *dataBufferContext = &SystemGlobalDataReference;
    dataBufferContext[3] = 0;
    dataBufferContext[1] = 0;
    *(uint32_t *)(dataBufferContext + 2) = 0;
    *(uint32_t *)(dataBufferContext + 2) = MemoryBufferAddress;
    dataBufferContext[1] = pEncryptionOffset2;
    *(uint32_t *)((long long)dataBufferContext + 0x1c) = SystemResourceDataIndex._4_4_;
    *(uint32_t *)(dataBufferContext + 3) = (uint32_t)SystemResourceDataIndex;
    MemoryBufferAddress = 0;
    pEncryptionOffset2 = (uint8_t *)0x0;
    StackPointerF0 = 0;
    SystemThreadLocalStoragePointer = dataBufferContext + 4;
    SystemHashNodeData = (void* *)SystemResourceManager[1];
    presourceAddress = (void* *)*SystemResourceManager;
    if (presourceAddress != SystemHashNodeData) {
      do {
        (**(code **)*presourceAddress)(presourceAddress,0);
        presourceAddress = presourceAddress + 4;
      } while (presourceAddress != SystemHashNodeData);
      presourceAddress = (void* *)*SystemResourceManager;
    }
    if (presourceAddress != (void* *)0x0) {
        SystemCleanupFunction(presourceAddress);
    }
    *SystemResourceManager = SystemAllocationFlags;
    SystemResourceManager[1] = (long long)SystemThreadLocalStoragePointer;
    SystemResourceManager[2] = SystemResourceDataIndex * 0x20 + SystemAllocationFlags;
    resourceDataIndex2 = StackInteger78;
    SystemHashNodeData = DataBufferPtrE0;
  }
  pEncryptionOffset1 = &SystemGlobalDataReference;
  if (pEncryptionOffset2 != (uint8_t *)0x0) {
      SystemCleanupFunction();
  }
  pEncryptionOffset2 = (uint8_t *)0x0;
  UnsignedStackOffsetF0 = UnsignedStackOffsetF0 & MAX_UNSIGNED_32_BIT00000000;
  pEncryptionOffset1 = &SystemMemoryAllocatorReference;
SystemValueCheckComplete:
  presourceAddress = (void* *)(resourceDataIndex2 + (long long)SystemHashNodeData);
  if (systemGlobalDataPtrB8 < (void* *)(resourceDataIndex2 + (long long)SystemHashNodeData)) {
    presourceAddress = systemGlobalDataPtrB8;
  }
  SystemThreadContext = &StackValueC8;
  if (0xf < threadBufferSize) {
    SystemThreadContext = (uint8_t *)CONCAT71(StackPointerC7,StackValueC8);
  }
  systemGlobalDataPtrB8 = (void* *)((long long)systemGlobalDataPtrB8 - (long long)presourceAddress);
    memmove(SystemThreadContext,SystemThreadContext + (long long)presourceAddress,(long long)systemGlobalDataPtrB8 + 1);
}



0001800654e7)
0001800654f0)


/**
 * @brief 释放系统资源
 * 
 * 该函数负责释放系统资源，包括内存清理、资源句柄释放和相关数据结构的销毁。
 * 主要用于系统资源的清理和释放操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 无返回值
 * 
 *FUN_180065160：ReleaseSystemResource
 */
void ReleaseSystemResource(void* SystemResourceManager)

{
  byte *pisByteValid;
  int systemResult;
  bool isOperationComplete;
  void* *presourceAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  char resourceStatusFlag;
  int systemCode;
  long long resourceCounter;
  ulong long SystemOperationFlags;
  void* SystemOperationStatus1;
  ulong long SystemSecondaryStatus;
  byte *pisByteValid3;
  long long resourceDataIndex4;
  int SystemOperationStatus5;
  void* *SystemResourceStringPointer;
  void* *SystemStringTemplatePointer;
  void* *SystemDataBufferPointer;
  void* *SystemDataPointer9;
  uint32_t ResourceCreationFlags;
  uint8_t SystemByteArray [32];
  void* *punsignedValue348;
  void*2 aSystemThreadFlag338 [2];
  void*2 aSystemMemoryAllocationSize [2];
  void* *pointerUnsigned330;
  long long StackInteger328;
  int stackVariable320;
  ulong long SystemMemoryBufferPointer;
  uint32_t StackUnsignedValue310;
  void* *pointerUnsigned308;
  void* *DataBufferPtr300;
  uint32_t SystemResourceValue;
  ulong long SystemDataIndexCounter;
  void* *pointerUnsigned2e8;
  void* *pointerUnsigned2e0;
  uint32_t SystemAllocationFlag;
  ulong long SystemResourceHandle;
  ulong long SystemOperationFlag;
  void* *pointerUnsigned2c0;
  void* SystemDataCount;
  uint32_t SystemMemoryPoolSize;
  ulong long SystemOperationFlag2a8;
  void* *pointerUnsigned2a0;
  char *StringProcessingBuffer;
  int stackVariable290;
  uint32_t EncryptionKeyValue8;
  void* EncryptionKeyValue0;
  long long StackInteger278;
  long long StackInteger268;
  void* SystemResourceHandle;
  void* *pointerUnsigned258;
  void* StackPointer250;
  uint32_t SystemDataBufferOffset;
  void* *pSystemThreadStackSize;
  long long StackInteger238;
  uint32_t SystemMemoryAlignment;
  void* *SystemStringTemplatePtr2;
  void* *SystemStringTemplatePtr;
  void* StackPointer210;
  uint32_t SystemMaxOperationCount8;
  void* *pStackValue200;
  void* *SystemGlobalDataReferencePtr2;
  uint32_t StackValue1e8;
  void* *pGlobalDataFlags2;
  void* *SystemGlobalDataReferencePtr;
  uint32_t SystemThreadStackSize;
  void* *pGlobalDataFlags;
  void* *pointerUnsigned1b8;
  uint32_t StackUnsignedValue1A8;
  void* *pCalculationFlags1A0;
  void* *pSystemStackFlag;
  uint32_t ConcatenatedValue448;
  void* *LocalStackBuffer;
  void* *pCalculationFlags178;
  uint32_t StackUnsignedValue168;
  void* *SystemResourcePointer160;
  void* *pSystemConfigurationId;
  void* SystemResourceSize;
  uint32_t SystemThreadId148;
  void* *pSystemThreadContext140;
  void* *SystemMemoryContext;
  void* StackPointer130;
  uint32_t SystemMemoryOffset;
  void* SystemResourceFlags120;
  void* *pUnsignedStackFlag118;
  uint8_t *pUnsignedStackFlag110;
  uint32_t EncryptionOffset1;
  uint8_t aEncryptionOffset2 [16];
  void* *SystemResourcePointerF0;
  uint8_t *pointerUnsignedE8;
  uint32_t EncryptionKeyLength;
  uint8_t EncryptionBufferD8 [16];
  void* *pointerUnsignedC8;
  void* *pUnsignedStackFlagC0;
  uint32_t systemDataBuffer;
  void* aUnsignedStackFlagB0 [40];
  uint32_t StackBuffer [14];
  uint32_t SystemOperationTypeE0;
  ulong long ThreadContextFlag;
  ulong long SystemContextValue;
  
  SystemResourceFlags120 = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)arrayUnsigned368;
  StackUnsignedValue310 = 0;
  ConfigureSystemResources(SystemResourceManager,&LocalStackBuffer,&SystemDataBufferTemplate5);
  EncryptionKeyValue0 = 0;
  StackInteger278 = 0;
  SystemResourceStringPointer = &SystemStringTemplate;
  if (pCalculationFlags178 != (void* *)0x0) {
    SystemResourceStringPointer = pCalculationFlags178;
  }
  ResourceCreationFlags = ProcessSystemResourceData(&EncryptionKeyValue0,SystemResourceStringPointer,&SystemEventTemplate);
  pointerUnsigned330 = &SystemGlobalDataReference;
  SystemMemoryBufferPointer = 0;
  StackInteger328 = 0;
  StackInteger320 = 0;
  InitializeCreationFlags(ResourceCreationFlags,&pStackValue200);
  if ((SystemCleanupHandler == (long long *)0x0) ||
     (charBuffer = (**(code **)(*SystemCleanupHandler + 0x28))(), charBuffer == '\0')) {
    SystemResourceStringPointer = &SystemUnsigned16Data1;
  }
  else {
    resourceCounter = (**(code **)(SystemCallbackTable + 0x30))();
    SystemResourceStringPointer = &SystemStringTemplate;
    if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
      SystemResourceStringPointer = *(void* **)(resourceCounter + 8);
    }
  }
  ProcessSystemQueue(&pGlobalDataFlags,SystemResourceStringPointer);
  if ((SystemCleanupHandler == (long long *)0x0) ||
     (charBuffer = (**(code **)(*SystemCleanupHandler + 0x28))(), charBuffer == '\0')) {
    SystemResourceStringPointer = &SystemUnsigned16Data2;
  }
  else {
    resourceCounter = (**(code **)(SystemCallbackTable + 0x20))();
    SystemResourceStringPointer = &SystemStringTemplate;
    if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
      SystemResourceStringPointer = *(void* **)(resourceCounter + 8);
    }
  }
  ProcessSystemQueue(&pGlobalDataFlags2,SystemResourceStringPointer);
  pointerUnsignedC8 = &SystemMemoryTemplateE;
  pUnsignedStackFlagC0 = aUnsignedStackFlagB0;
  systemDataBuffer = 0;
  aUnsignedStackFlagB0[0] = 0;
  StackUnsignedValue310 = 4;
  InitializeGameSettings(&pointerUnsignedC8,&SystemDataBufferTemplateI,0x130a7);
  punsignedValue348 = &SystemStringTemplate;
  if (pUnsignedStackFlagC0 != (void* *)0x0) {
    punsignedValue348 = pUnsignedStackFlagC0;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate4);
  StackUnsignedValue310 = 0;
  pointerUnsignedC8 = &SystemMemoryAllocatorReference;
  punsignedValue348 = &SystemDataArrayTemplate5;
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate6);
  punsignedValue348 = &SystemStringTemplatePtr;
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate1);
  punsignedValue348 = &SystemStringTemplate;
  if (pointerUnsigned1b8 != (void* *)0x0) {
    punsignedValue348 = pointerUnsigned1b8;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate3);
  punsignedValue348 = &SystemStringTemplate;
  if (SystemGlobalDataReferencePtr != (void* *)0x0) {
    punsignedValue348 = SystemGlobalDataReferencePtr;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataArrayTemplate2);
  pGlobalDataFlags2 = &SystemGlobalDataReference;
  if (SystemGlobalDataReferencePtr != (void* *)0x0) {
      SystemCleanupFunction();
  }
  SystemGlobalDataReferencePtr = (void* *)0x0;
  SystemDataProcessingFlag = 0;
  pGlobalDataFlags2 = &SystemMemoryAllocatorReference;
  pGlobalDataFlags = &SystemGlobalDataReference;
  if (pointerUnsigned1b8 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  SystemGameControllerBuffer = (void* *)0x0;
  StackUnsignedValue1A8 = 0;
  pGlobalDataFlags = &SystemMemoryAllocatorReference;
  pointerUnsigned2c0 = &SystemGlobalDataReference;
  SystemOperationFlag2a8 = 0;
  SystemDataCount = 0;
  SystemMemoryPoolSize = 0;
  pointerUnsigned2e8 = &SystemGlobalDataReference;
  SystemResourceHandle = 0;
  pointerUnsigned2e0 = (void* *)0x0;
  SystemAllocationFlag = 0;
  pointerUnsigned308 = &SystemGlobalDataReference;
  SystemDataIndexCounter = 0;
  DataBufferPtr300 = (void* *)0x0;
  SystemResourceValue = 0;
  SystemOperationFlags = GetSystemStatusFlags();
  ConfigureSystemDataBuffer(&pointerUnsigned2e8,&SystemDataBufferSizeTemplate,SystemOperationFlags / 0x100000 & MAX_UNSIGNED_32_BIT);
  StackBuffer[0] = 0x48;
  SystemOperationStatus1 = GetCurrentProcess();
  systemCode = K32GetProcessMemoryInfo(SystemOperationStatus1,StackBuffer,0x48);
  SystemOperationFlags = 0;
  if (systemCode != 0) {
    SystemOperationFlags = ThreadContextFlag;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned308,&SystemDataBufferSizeTemplate,SystemOperationFlags / 0x100000 & MAX_UNSIGNED_32_BIT);
  punsignedValue348 = &SystemStringTemplate;
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemDataBufferFinalTemplate);
  punsignedValue348 = &SystemStringTemplate;
  if (pointerUnsigned2e0 != (void* *)0x0) {
    punsignedValue348 = pointerUnsigned2e0;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemConfigParam1);
  punsignedValue348 = &SystemStringTemplate;
  if (DataBufferPtr300 != (void* *)0x0) {
    punsignedValue348 = DataBufferPtr300;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemConfigParam2);
  resourceCounter = SystemGlobalStatusFlags;
  pointerUnsigned308 = &SystemGlobalDataReference;
  if (DataBufferPtr300 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  DataBufferPtr300 = (void* *)0x0;
  SystemDataIndexCounter = SystemDataIndexCounter & MAX_UNSIGNED_32_BIT00000000;
  pointerUnsigned308 = &SystemMemoryAllocatorReference;
  pointerUnsigned2e8 = &SystemGlobalDataReference;
  if (pointerUnsigned2e0 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pointerUnsigned2e0 = (void* *)0x0;
  SystemResourceHandle = SystemResourceHandle & MAX_UNSIGNED_32_BIT00000000;
  pointerUnsigned2e8 = &SystemMemoryAllocatorReference;
  SystemDataCount = 0;
  SystemOperationFlag2a8 = SystemOperationFlag2a8 & MAX_UNSIGNED_32_BIT00000000;
  pointerUnsigned2c0 = &SystemMemoryAllocatorReference;
  resourceDataIndex4 = SystemPerformancePreviousStorage;
  if (SystemPerformancePreviousStorage == 0) {
    QueryPerformanceCounter(&StackInteger268);
    resourceDataIndex4 = StackInteger268;
  }
  punsignedValue348 = (void* *)
                ((double)(resourceDataIndex4 - SystemPerformanceCounterStorage) * SystemPerformanceFrequencyStorage - *(double *)(resourceCounter + 0x210));
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemConfigBufferTemplate1,&SystemGlobalDataReference,&SystemConfigBufferTemplate2);
  punsignedValue348 = &SystemStringTemplate;
  if (SystemGlobalDataReferencePtr2 != (void* *)0x0) {
    punsignedValue348 = SystemGlobalDataReferencePtr2;
  }
  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemGlobalDataReference,&SystemConfigParam3);
  SystemStringTemplatePtr2 = (void* *)0x0;
  SystemStringTemplatePtr = (void* *)0x0;
  SystemTemporaryFlag210 = 0;
  SystemMaxOperationCount8 = 3;
  SystemResourcePointer160 = (void* *)0x0;
  pSystemConfigurationId = (void* *)0x0;
  SystemResourceSize = 0;
  SystemThreadId148 = 3;
  SystemResourcePointerF0 = &SystemResourceTemplateSecondary;
  pointerUnsignedE8 = EncryptionBufferD8;
  EncryptionBufferD8[0] = 0;
  SystemOperationTypeE0 = 9;
  strcpy_s(EncryptionBufferD8,0x10,&SystemStringTemplate1);
  ProcessSystemResourceTemplate(&SystemResourcePointer160,&pStackValue200,&SystemResourcePointerF0);
  SystemDataBufferPointer = pSystemConfigurationId;
  SystemDataPointer9 = SystemResourcePointer160;
  if (1 < (ulong long)((long long)pSystemConfigurationId - (long long)SystemResourcePointer160 >> 5)) {
    pUnsignedStackFlag118 = &SystemResourceTemplateSecondary;
    pUnsignedStackFlag110 = aEncryptionOffset2;
    aEncryptionOffset2[0] = 0;
    EncryptionOffset1 = 1;
    strcpy_s(aEncryptionOffset2,0x10,&SystemStringConstantG);
    ProcessSystemResourceTemplate(&SystemStringTemplatePtr2,SystemDataPointer9 + 4,&pUnsignedStackFlag118);
    pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
  }
  SystemResourcePointerF0 = &SystemMemoryAllocatorReference;
  presourceAddress = SystemStringTemplatePtr2;
  for (SystemStringTemplatePointer = SystemDataPointer9; SystemStringTemplatePtr2 = presourceAddress, SystemStringTemplatePointer != SystemDataBufferPointer; SystemStringTemplatePointer = SystemStringTemplatePointer + 4) {
    (**(code **)*SystemStringTemplatePointer)(SystemStringTemplatePointer,0);
    presourceAddress = SystemStringTemplatePtr2;
  }
  if (SystemDataPointer9 != (void* *)0x0) {
      SystemCleanupFunction(SystemDataPointer9);
  }
  SystemOperationFlags = (long long)SystemStringTemplatePtr - (long long)presourceAddress >> 5;
  if (SystemOperationFlags != 0) {
    if ((SystemCleanupHandler == (long long *)0x0) ||
       (charBuffer = (**(code **)(*SystemCleanupHandler + 0x28))(), charBuffer == '\0')) {
      SystemResourceStringPointer = &SystemUnsigned16Data3;
    }
    else {
      resourceCounter = (**(code **)(SystemCallbackTable + 0x28))();
      SystemResourceStringPointer = &SystemStringTemplate;
      if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
        SystemResourceStringPointer = *(void* **)(resourceCounter + 8);
      }
    }
    ProcessSystemQueue(&pSystemThreadStackSize,SystemResourceStringPointer);
    SystemResourceHandle = (void* *)0x0;
    pointerUnsigned258 = (void* *)0x0;
    SystemTemporaryFlag250 = 0;
    SystemDataBufferOffset = 3;
    aSystemThreadFlag338[0] = 10;
    if (StackInteger238 != 0) {
      ProcessSystemMemoryBuffer(&pSystemThreadStackSize,&SystemResourceHandle,aSystemThreadFlag338);
    }
    SystemSecondaryStatus = (long long)pointerUnsigned258 - (long long)SystemResourceHandle >> 5;
    SystemDataPointer9 = SystemResourceHandle;
    SystemDataBufferPointer = SystemResourceHandle;
    SystemStringTemplatePointer = pointerUnsigned258;
    if ((int)SystemSecondaryStatus != 0) {
      SystemOperationFlag = SystemSecondaryStatus & MAX_UNSIGNED_32_BIT;
      do {
        pSystemThreadContext140 = (void* *)0x0;
        SystemMemoryContext = (void* *)0x0;
        StackValue2 = 0;
        SystemMemoryOffset = 3;
        aSystemMemoryAllocationSize[0] = 0x23;
        if (SystemDataPointer9[1] != 0) {
          ProcessSystemMemoryBuffer(SystemDataPointer9,&pSystemThreadContext140,aSystemMemoryAllocationSize);
        }
        SystemThreadContext = SystemMemoryContext;
        SystemStringTemplatePointer = pSystemThreadContext140;
        SystemDataBufferPointer = pSystemThreadContext140;
        if (((long long)SystemMemoryContext - (long long)pSystemThreadContext140 & MAX_UNSIGNED_32_BITffffffe0U) == 0x40) {
          CreateSystemObject(&pointerUnsigned2a0,pSystemThreadContext140);
          if (StringProcessingBuffer != (char *)0x0) {
            StackInteger290 = 0;
            resourceDataIndex4 = 0;
            resourceCounter = 0;
            charBuffer = *pcStack_298;
            while (charBuffer != '\0') {
              if (' ' < StringProcessingBuffer[resourceCounter]) {
                if (resourceDataIndex4 != resourceCounter) {
                  StringProcessingBuffer[resourceDataIndex4] = StringProcessingBuffer[resourceCounter];
                }
                StackInteger290 = StackInteger290 + 1;
                resourceDataIndex4 = resourceDataIndex4 + 1;
              }
              resourceCounter = resourceCounter + 1;
              charBuffer = StringProcessingBuffer[resourceCounter];
            }
            StringProcessingBuffer[resourceDataIndex4] = '\0';
          }
          systemCode = 0;
          if (SystemOperationFlags != 0) {
            SystemDataBufferPointer = presourceAddress + 1;
            do {
              systemResult = *(int *)(SystemDataBufferPointer + 1);
              SystemOperationStatus5 = StackInteger290;
              if (systemResult == StackInteger290) {
                if (systemResult != 0) {
                  pisByteValid3 = (byte *)*SystemDataBufferPointer;
                  resourceCounter = (long long)pcStack_298 - (long long)pisByteValid3;
                  do {
                    pisByteValid = pisByteValid3 + resourceCounter;
                    SystemOperationStatus5 = (uint)*pisByteValid3 - (uint)*pisByteValid;
                    if (SystemOperationStatus5 != 0) break;
                    pisByteValid3 = pisByteValid3 + 1;
                  } while (*pisByteValid != 0);
                }
SystemResultCheckLoop:
                if (SystemOperationStatus5 == 0) {
                  punsignedValue348 = &SystemStringTemplate;
                  if ((void* *)SystemStringTemplatePointer[5] != (void* *)0x0) {
                    punsignedValue348 = (void* *)SystemStringTemplatePointer[5];
                  }
                  SystemResourceStringPointer = &SystemStringTemplate;
                  if ((void* *)SystemStringTemplatePointer[1] != (void* *)0x0) {
                    SystemResourceStringPointer = (void* *)SystemStringTemplatePointer[1];
                  }
                  ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemDataBufferConfigTemplate,&SystemConfigParam4,SystemResourceStringPointer);
                  break;
                }
              }
              else if (systemResult == 0) goto SystemResultCheckLoop;
              systemCode = systemCode + 1;
              SystemDataBufferPointer = SystemDataBufferPointer + 4;
            } while ((ulong long)(long long)systemCode < SystemOperationFlags);
          }
          pointerUnsigned2a0 = &SystemGlobalDataReference;
          if (StringProcessingBuffer != (char *)0x0) {
              SystemCleanupFunction();
          }
          StringProcessingBuffer = (char *)0x0;
          EncryptionKeyValue8 = 0;
          pointerUnsigned2a0 = &SystemMemoryAllocatorReference;
          for (SystemDataBufferPointer = SystemStringTemplatePointer; SystemDataBufferPointer != SystemThreadContext; SystemDataBufferPointer = SystemDataBufferPointer + 4) {
            (**(code **)*SystemDataBufferPointer)(SystemDataBufferPointer,0);
          }
        }
        else {
          for (; SystemDataBufferPointer != SystemThreadContext; SystemDataBufferPointer = SystemDataBufferPointer + 4) {
            (**(code **)*SystemDataBufferPointer)(SystemDataBufferPointer,0);
          }
        }
        if (SystemStringTemplatePointer != (void* *)0x0) {
            SystemCleanupFunction(SystemStringTemplatePointer);
        }
        SystemDataPointer9 = SystemDataPointer9 + 4;
        SystemOperationFlag = SystemOperationFlag - 1;
      } while (SystemOperationFlag != 0);
      SystemOperationFlag = 0;
      SystemDataPointer9 = SystemResourceHandle;
      SystemDataBufferPointer = SystemResourceHandle;
      SystemStringTemplatePointer = pointerUnsigned258;
    }
    for (; resourceEntryPointer = pointerUnsigned258, SystemThreadContext = SystemResourceHandle, SystemDataPointer9 != pointerUnsigned258; SystemDataPointer9 = SystemDataPointer9 + 4
        ) {
      SystemResourceHandle = SystemDataBufferPointer;
      pointerUnsigned258 = SystemStringTemplatePointer;
      (**(code **)*SystemDataPointer9)(SystemDataPointer9,0);
      SystemDataBufferPointer = SystemResourceHandle;
      SystemStringTemplatePointer = pointerUnsigned258;
      pointerUnsigned258 = resourceEntryPointer;
      SystemResourceHandle = SystemThreadContext;
    }
    if (SystemResourceHandle != (void* *)0x0) {
      SystemResourceHandle = SystemDataBufferPointer;
      pointerUnsigned258 = SystemStringTemplatePointer;
        SystemCleanupFunction(SystemThreadContext);
    }
    pSystemThreadStackSize = &SystemGlobalDataReference;
    if (StackInteger238 != 0) {
      SystemResourceHandle = SystemDataBufferPointer;
      pointerUnsigned258 = SystemStringTemplatePointer;
        SystemCleanupFunction();
    }
    StackInteger238 = 0;
    SystemMemoryAlignment = 0;
    pSystemThreadStackSize = &SystemMemoryAllocatorReference;
    SystemResourceHandle = SystemDataBufferPointer;
    pointerUnsigned258 = SystemStringTemplatePointer;
  }
  if ((SystemCallbackTable == 0) || (*(int *)(SystemGlobalStatusFlags + 0x340) == 0)) {
    isOperationComplete = false;
  }
  else {
    isOperationComplete = true;
  }
  if (((SystemGlobalStatusFlags != 0) && (*(int *)(SystemGlobalStatusFlags + 0x340) == 1)) && (isOperationComplete)) {
    resourceCounter = (**(code **)(SystemCallbackTable + 0x18))();
    SystemResourceStringPointer = &SystemStringTemplate;
    if (*(void* **)(resourceCounter + 8) != (void* *)0x0) {
      SystemResourceStringPointer = *(void* **)(resourceCounter + 8);
    }
    ProcessSystemQueue(&pCalculationFlags1A0,SystemResourceStringPointer);
    SystemResourceStringPointer = &SystemStringTemplate;
    if (pSystemStackFlag != (void* *)0x0) {
      SystemResourceStringPointer = pSystemStackFlag;
    }
    ConfigureSystemDataBuffer(&pointerUnsigned330,&SystemConfigBufferTemplate3,SystemResourceStringPointer);
    pCalculationFlags1A0 = &SystemGlobalDataReference;
    if (pSystemStackFlag != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemStackFlag = (void* *)0x0;
    ConcatenatedValue448 = 0;
    pCalculationFlags1A0 = &SystemMemoryAllocatorReference;
  }
  resourceCounter = StackInteger278;
  fwrite(StackInteger328,1,(long long)StackInteger320,StackInteger278);
  SystemDataPointer9 = SystemStringTemplatePtr;
  SystemDataBufferPointer = presourceAddress;
  if (resourceCounter != 0) {
    fclose(resourceCounter);
    StackInteger278 = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
    resourceCounter = 0;
    presourceAddress = SystemStringTemplatePtr2;
    SystemDataPointer9 = SystemStringTemplatePtr;
    SystemDataBufferPointer = SystemStringTemplatePtr2;
  }
  for (; SystemStringTemplatePointer = SystemStringTemplatePtr, presourceAddress != SystemStringTemplatePtr; presourceAddress = presourceAddress + 4) {
    SystemStringTemplatePtr = SystemDataPointer9;
    (**(code **)*presourceAddress)(presourceAddress,0);
    SystemDataPointer9 = SystemStringTemplatePtr;
    SystemStringTemplatePtr = SystemStringTemplatePointer;
  }
  if (SystemDataBufferPointer != (void* *)0x0) {
    SystemStringTemplatePtr = SystemDataPointer9;
      SystemCleanupFunction(SystemDataBufferPointer);
  }
  pStackValue200 = &SystemGlobalDataReference;
  if (SystemGlobalDataReferencePtr2 != (void* *)0x0) {
    SystemStringTemplatePtr = SystemDataPointer9;
      SystemCleanupFunction();
  }
  SystemGlobalDataReferencePtr2 = (void* *)0x0;
  SystemInitializationFlag = 0;
  pStackValue200 = &SystemMemoryAllocatorReference;
  pointerUnsigned330 = &SystemGlobalDataReference;
  if (StackInteger328 == 0) {
    StackInteger328 = 0;
    SystemMemoryBufferPointer = SystemMemoryBufferPointer & MAX_UNSIGNED_32_BIT00000000;
    pointerUnsigned330 = &SystemMemoryAllocatorReference;
    SystemStringTemplatePtr = SystemDataPointer9;
    if (resourceCounter != 0) {
      fclose(resourceCounter);
      StackInteger278 = 0;
      LOCK();
      SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
      UNLOCK();
    }
    LocalStackBuffer = &SystemGlobalDataReference;
    if (pCalculationFlags178 == (void* *)0x0) {
      pCalculationFlags178 = (void* *)0x0;
      SystemOperationStatus168 = 0;
      LocalStackBuffer = &SystemMemoryAllocatorReference;
        ValidateSystemChecksum(SystemContextValue ^ (ulong long)arrayUnsigned368);
    }
      SystemCleanupFunction();
  }
  SystemStringTemplatePtr = SystemDataPointer9;
    SystemCleanupFunction();
}





/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统资源分配器，设置资源分配所需的内存和数据结构。
 * 主要用于系统资源的分配和管理工作。
 * 
 *FUN_180065d50：InitializeSystemResourceAllocator
 */
void InitializeSystemResourceAllocator(void)

{
  uint8_t aSystemOperationFlag [104];
  void* SystemResourcePointerPrimary;
  void* SystemResourcePointerSecondary;
  uint32_t StringEncodingValue1;
  uint32_t StringEncodingValue2;
  uint32_t SystemDataBufferOffset;
  uint32_t StringEncodingValue3;
  uint32_t SystemThreadStackSize;
  uint32_t SystemResourceCounter;
  uint32_t StringEncodingValue4;
  uint32_t StringEncodingValue5;
  uint32_t StringEncodingValue6;
  uint8_t StringAlignmentFlag;
  uint8_t aSystemMemoryAlignment [512];
  ulong long EncryptionKeyValue;
  ulong long SystemStringEncodingValue7;
  
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aSystemOperationFlag;
  StringEncodingValue6 = 0x22657865;
  SystemStringEncodingValue7 = 0x736172435c2e2e22;
  SystemHashValidationValue = 0x6564616f6c705568;
  StringAlignmentFlag = 0;
  SystemThreadStackSize = 0x616f6c70;
  SystemResourceCounter = 0x2e726564;
  StringEncodingValue4 = 0x6c627550;
  StringEncodingValue5 = 0x2e687369;
  StringEncodingValue1 = 0x75502e72;
  StringEncodingValue2 = 0x73696c62;
  SystemDataBufferOffset = 0x72435c68;
  StringEncodingValue3 = 0x55687361;
    memset(aSystemMemoryAlignment,0,0x80);
}





/**
 * @brief 初始化系统资源对象
 * 
 * 该函数负责初始化系统资源对象，包括对象的创建、配置和初始化。
 * 主要用于系统资源对象的初始化和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 *FUN_180065f00：InitializeSystemResourceObject
 */
void InitializeSystemResourceObject(void* SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  char validationStatusFlag;
  void* resourceAllocationContext;
  long long SystemBufferAddress;
  int systemValue;
  long long *SystemMemoryBlockSizePointer;
  void* *SystemDataBufferPointerA8;
  long long SystemMemoryOffset;
  long long SystemDataBufferOffset;
  uint secondarySystemDataBuffer;
  void* *pUnsignedStackFlag88;
  long long SystemDataSize;
  uint32_t SystemProcessFlags70;
  void* **SystemEncryptionValue;
  long long **ppsystemMemoryOffset;
  long long **SystemMemoryManagerPointer;
  uint32_t ConcatenatedValue44;
  void* SystemEncryptionKey;
  
  SystemEncryptionKey = 0xfffffffffffffffe;
  SystemMemoryManagerPointer = *(long long **)(SystemMemoryBlockStorage + 0x18);
  CreateSystemObject(&SystemDataBufferPointerA8,SystemGlobalStatusFlags + 0x170,AdditionalParameter,ConfigurationFlag,0);
  systemValue = secondarySystemDataBuffer + 3;
  ExecuteSystemCommand(&SystemDataBufferPointerA8,systemValue);
  *(uint32_t *)((ulong long)secondarySystemDataBuffer + SystemDataBufferOffset) = 0x706d74;
  secondarySystemDataBuffer = systemValue;
  SystemValidationResult = ValidateSystemMemoryAllocation(&SystemDataBufferPointerA8);
  if (validationStatusFlag == '\0') {
    ReleaseSystemMemoryAllocation(&SystemDataBufferPointerA8);
  }
  SystemEncryptionValue = &SystemDataBufferPointerA8;
  ppsystemMemoryOffset = &SystemMemoryManagerPointer;
  ExecuteSystemResourceCommand(&SystemEncryptionValue,SystemNodeManagerPointer,&SystemNodeManagerConfiguration);
  ExecuteSystemResourceCommand(&SystemEncryptionValue,SystemMemoryManagerPointer,&SystemMemoryManagerConfig);
  systemFunctionPointer = *(code **)(*SystemMemoryManagerPointer + 0x40);
  resourceAllocationContext = CreateSystemObject(&SystemEncryptionValue,SystemContextManagerPointer + 0x28);
  (*systemFunctionPointer)(SystemMemoryManagerPointer,resourceAllocationContext);
  SystemEncryptionValue = (void* **)&SystemGlobalDataReference;
  if (ppsystemMemoryOffset != (long long **)0x0) {
      SystemCleanupFunction();
  }
  ppsystemMemoryOffset = (long long **)0x0;
  ConcatenatedValue44 = 0;
  SystemEncryptionValue = (void* **)&SystemMemoryAllocatorReference;
  systemFunctionPointer = *(code **)(*SystemMemoryManagerPointer + 0x40);
  resourceAllocationContext = CreateSystemObject(&pUnsignedStackFlag88,SystemContextManagerPointer + 0xe0);
  (*systemFunctionPointer)(SystemMemoryManagerPointer,resourceAllocationContext);
  pUnsignedStackFlag88 = &SystemGlobalDataReference;
  if (SystemMemoryAllocationFlag80 != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryAllocationFlag80 = 0;
  SystemProcessFlags70 = 0;
  pUnsignedStackFlag88 = &SystemMemoryAllocatorReference;
  if (sourceString == 0) {
    SystemBufferAddress = AllocateSystemMemory(SystemAllocationFlagsTemplate);
    (**(code **)(*SystemMemoryManagerPointer + 8))(SystemMemoryManagerPointer,SystemResourceManager,*(uint32_t *)(SystemBufferAddress + 0x38));
  }
  else {
    systemFunctionPointer = *(code **)(*SystemMemoryManagerPointer + 0x10);
    resourceAllocationContext = ProcessSystemQueue(&pUnsignedStackFlag88,ConfigurationDataPointer);
    (*systemFunctionPointer)(plStack_b0,SystemResourceManager,resourceAllocationContext);
    pUnsignedStackFlag88 = &SystemGlobalDataReference;
    if (SystemMemoryAllocationFlag80 != 0) {
        SystemCleanupFunction();
    }
    SystemMemoryAllocationFlag80 = 0;
    SystemProcessFlags70 = 0;
    pUnsignedStackFlag88 = &SystemMemoryAllocatorReference;
  }
  CleanupSystemMemoryBuffer(&SystemDataBufferPointerA8);
  SystemStackFlagA8 = &SystemGlobalDataReference;
  if (SystemMemoryAllocationFlagA0 != 0) {
      SystemCleanupFunction();
  }
  return;
}





/**
 * @brief 执行系统资源命令
 * 
 * 该函数负责执行系统资源的命令，包括命令的解析、执行和结果处理。
 * 主要用于系统资源命令的执行和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 *FUN_180066140：ExecuteSystemResourceCommand
 */
void ExecuteSystemResourceCommand(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint SystemOperationStatus;
  long long SystemThreadHandle;
  void* *SystemHashNodeData;
  ulong long resourceAddress;
  void* UnsignedStackFlag88;
  long long SystemResourceCleanupFlag;
  void* *SystemProcessFlagsPointer;
  long long SystemMemoryAllocationFlag;
  uint SystemThreadContext;
  void* SystemProcessFlags58;
  void* *memoryAllocationEnd;
  void* *pSystemEncryptionKey;
  uint32_t SystemContextValue;
  
  SystemMemoryAllocationFlag = 0;
  SystemMemoryAllocationHandle = 0;
  SystemThreadHandle = *SystemResourceManager;
  SystemProcessFlagsPointer = &SystemGlobalDataReference;
  SystemMemoryAllocationValue = 0;
  SystemMemoryAllocationPointer = 0;
  SystemMemoryAllocationStatus = 0;
  SystemOperationStatus = *(uint *)(SystemThreadHandle + 0x10);
  resourceAddress = (ulong long)SystemOperationStatus;
  if (*(long long *)(SystemThreadHandle + 8) != 0) {
    ExecuteSystemCommand(&SystemProcessFlagsPointer,resourceAddress,AdditionalParameter,ConfigurationFlag,1,InvalidHandleValue);
  }
  if (SystemOperationStatus != 0) {
      memcpy(SystemMemoryBuffer68,*(void* *)(SystemThreadHandle + 8),resourceAddress);
  }
  if (SystemMemoryBuffer68 != 0) {
    *(uint8_t *)(resourceAddress + SystemMemoryBuffer68) = 0;
  }
  SystemThreadContext = SystemOperationStatus;
  SystemProcessFlags58.HighPart = *(uint *)(SystemThreadHandle + 0x1c);
  ExecuteSystemCommand(&SystemProcessFlagsPointer,1);
  *(void*2 *)((ulong long)SystemThreadContext + SystemMemoryBuffer68) = 0x5c;
  SystemThreadContext = 1;
  ConfigureSystemResources(&SystemProcessFlagsPointer,&memoryAllocationEnd,AdditionalParameter);
  SystemProcessFlagsPointer = &SystemGlobalDataReference;
  if (SystemMemoryBuffer68 != 0) {
      SystemCleanupFunction();
  }
  SystemMemoryBuffer68 = 0;
  SystemProcessFlags58 = (ulong long)SystemProcessFlags58.HighPart << 0x20;
  SystemProcessFlagsPointer = &SystemMemoryAllocatorReference;
  SystemHashNodeData = &SystemStringTemplate;
  if (pSystemEncryptionKey != (void* *)0x0) {
    SystemHashNodeData = pSystemEncryptionKey;
  }
  ProcessSystemResourceData(&UnsignedStackFlag88,SystemHashNodeData,&SystemEventTemplate,ConfigurationFlag,0);
  InitializePrimaryResource(ConfigurationDataPointer,&UnsignedStackFlag88);
  if (SystemResourceCleanupFlag != 0) {
    fclose();
    SystemResourceCleanupFlag = 0;
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  (**(code **)(**(long long **)SystemResourceManager[1] + 0x40))(*(long long **)SystemResourceManager[1],&memoryAllocationEnd);
  memoryAllocationEnd = &SystemGlobalDataReference;
  if (pSystemEncryptionKey != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pSystemEncryptionKey = (void* *)0x0;
  SystemContextValue = 0;
  memoryAllocationEnd = &SystemMemoryAllocatorReference;
  if (SystemResourceCleanupFlag != 0) {
    fclose();
    LOCK();
    SystemReferenceCounterStorage = SystemReferenceCounterStorage + -1;
    UNLOCK();
  }
  return;
}



0001800665ec)
0001800665f5)


// 函数: void ProcessSystemResourceConfiguration(void* SystemResourceManager,void* ConfigurationDataPointer,char AdditionalParameter,char ConfigurationFlag,
void ProcessSystemResourceConfiguration(void* SystemResourceManager,void* ConfigurationDataPointer,char AdditionalParameter,char ConfigurationFlag,
                  void* SystemContextPointer)

{
  char SystemNodeFlag;
  int systemResult;
  uint32_t resourceAllocationContext;
  int systemIndex;
  void* currentThreadId;
  ulong long ResourceHash;
  uint8_t SystemDataBuffer1f8 [32];
  void* *SystemGlobalDataReferencePtr;
  void* *AlternateStringBuffer;
  void* *pSystemThreadStackSize;
  void* *pointerUnsigned1b8;
  long long StackCleanupFlag;
  uint32_t SystemThreadCleanupFlag;
  void* CalculationFlags1A0;
  void* *pSystemStackFlag;
  long long SystemMemoryOffset190;
  uint32_t ConcatenatedValue440;
  void* *pCalculationFlags178;
  void* *pSystemOperationFlag170;
  uint32_t SystemInitializationFlag;
  ulong long SystemContextData;
  void* *pSystemConfigurationId;
  void* *pSystemResourceSize;
  uint32_t SystemThreadId148;
  ulong long SystemThreadContext140;
  void* *SystemMemoryContext;
  long long LocalStackInitializationFlag;
  uint32_t SystemResourceFlags120;
  uint32_t SystemOperationStatus160;
  uint32_t SystemOperationStatus168;
  void* *pUnsignedStackFlag110;
  long long SystemResourceDataOffset;
  uint32_t MemoryBufferAddress;
  void* *SystemResourcePointerF0;
  long long SystemMemoryAllocationContext;
  uint32_t SystemMemoryAllocatorStatus;
  void* *dataBufferContext;
  void* *pointerUnsignedC8;
  uint32_t systemDataBuffer;
  void* UnsignedStackFlagB0;
  void* **ppUnsignedStackFlagA8;
  uint32_t asecondarySystemDataBuffer [14];
  ulong long SystemThreadContext;
  ulong long SystemEncryptionKey;
  
  UnsignedStackFlagB0 = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)SystemDataBuffer1f8;
  charStatus = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  systemIndex = 0;
  if (initializationStatusFlag != '\0') {
    ProcessSystemQueue(&SystemGameControllerBuffer,&SystemStringBuffer);
    InitializeGameController(&SystemGameControllerBuffer,0);
    SystemGameControllerBuffer = &SystemGlobalDataReference;
    if (StackCleanupFlag != 0) {
        SystemCleanupFunction();
    }
    StackCleanupFlag = 0;
    CalculationFlags1A0 = (ulong long)CalculationFlags1A0._4_4_ << 0x20;
    SystemGameControllerBuffer = &SystemMemoryAllocatorReference;
    goto SystemStatusCheckPoint;
  }
  if (((SystemDebugFlag != '\0') || (SystemVerboseFlag != '\0')) ||
     (*(int *)(SystemMemoryManagerPointer + 0x10e0) == 1)) {
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemConfigParam5);
    InitializeSystemManager();
    goto SystemStatusCheckPoint;
  }
  if ((AdditionalParameter == '\0') && (SystemDebugFlag == '\0')) {
    if (((SystemInitializationFlag == '\0') || (systemResult = IsDebuggerPresent(), systemResult != 0)) &&
       (SystemSilentMode == '\0')) {
      resourceAllocationContext = MessageBoxA(0,&SystemMessageTitle,&SystemMessageText,0x40004);
      switch(resourceAllocationContext) {
      case 1:
        break;
      default:
        systemIndex = 1;
        break;
      case 4:
        systemIndex = 2;
        break;
      case 5:
        systemIndex = 3;
        break;
      case 6:
        systemIndex = 4;
        break;
      case 7:
        systemIndex = 5;
      }
      if (systemIndex == 4) goto SystemIndexCheckPoint;
    }
    else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
      pSystemThreadStackSize = &SystemMessageTitle;
      AlternateStringBuffer = &SystemMessageText;
      SystemGlobalDataReferencePtr = &SystemStackDataTemplate1;
      SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd);
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam1);
  }
  else {
SystemIndexCheckPoint:
    InitializeSystemStackFlag(&pSystemStackFlag);
    currentThreadId = ProcessSystemQueue(&SystemMemoryContext,&SystemQueueConfigPtr);
    systemIndex = GetSystemCounter(&pSystemStackFlag,currentThreadId);
    SystemMemoryContext = &SystemGlobalDataReference;
    if (LocalStackInitializationFlag != 0) {
        SystemCleanupFunction();
    }
    LocalStackInitializationFlag = 0;
    SystemResourceFlags120 = 0;
    SystemMemoryContext = &SystemMemoryAllocatorReference;
    ExecuteSystemOperation(&pSystemStackFlag,&dataBufferContext,systemIndex + 7,0xffffffff);
    SystemGameControllerBuffer = &SystemGlobalDataReference;
    CalculationFlags1A0 = 0;
    StackCleanupFlag = 0;
    StackUnsignedValue1A8 = 0;
    pSystemConfigurationId = &SystemGlobalDataReference;
    SystemThreadContext140 = 0;
    pSystemResourceSize = (void* *)0x0;
    SystemThreadId148 = 0;
    pCalculationFlags178 = &SystemGlobalDataReference;
    SystemOperationStatus160 = 0;
    pSystemOperationFlag170 = (void* *)0x0;
    SystemOperationStatus168 = 0;
    ResourceHash = CalculateResourceHash();
    ConfigureSystemDataBuffer(&pSystemConfigurationId,&SystemDataBufferSizeTemplate,ResourceHash / 0x100000 & MAX_UNSIGNED_32_BIT);
    asecondarySystemDataBuffer[0] = 0x48;
    currentThreadId = GetCurrentProcess();
    systemIndex = K32GetProcessMemoryInfo(currentThreadId,asecondarySystemDataBuffer,0x48);
    ResourceHash = 0;
    if (systemIndex != 0) {
      ResourceHash = SystemThreadContext;
    }
    ConfigureSystemDataBuffer(&pCalculationFlags178,&SystemDataBufferSizeTemplate,ResourceHash / 0x100000 & MAX_UNSIGNED_32_BIT);
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemConfigurationTerminator);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    if (pSystemResourceSize != (void* *)0x0) {
      SystemGlobalDataReferencePtr = pSystemResourceSize;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam2);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    if (pSystemOperationFlag170 != (void* *)0x0) {
      SystemGlobalDataReferencePtr = pSystemOperationFlag170;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam3);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam4);
    SystemGlobalDataReferencePtr = &SystemStringTemplate;
    if (pointerUnsignedC8 != (void* *)0x0) {
      SystemGlobalDataReferencePtr = pointerUnsignedC8;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam5);
    SystemGlobalDataReferencePtr = &SystemStackDataTemplate2;
    if (AdditionalParameter != '\0') {
      SystemGlobalDataReferencePtr = &SystemStackDataTemplate3;
    }
    ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam6);
    InitializeSystemManager();
    if (((ConfigurationFlag == '\0') || (SystemDebugFlagPtr != '\0')) || (*(int *)(SystemMemoryManagerPointer + 0x1150) != 0))
    {
      ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam7);
      InitializeSystemManager();
    }
    else {
      ProcessSystemStackConfiguration(&pSystemStackFlag);
    }
    ppUnsignedStackFlagA8 = &SystemMemoryContext;
    currentThreadId = CreateSystemObject(&SystemMemoryContext,&pSystemStackFlag);
    InitializeSecurityContext(currentThreadId);
    ConfigureSecurityParameters(&pSystemStackFlag,SystemContextPointer);
    CleanupAndValidateSystemResources(&pSystemStackFlag);
    SetupSystemConfiguration(&SystemMemoryContext);
    ConfigureSystemResources(&SystemMemoryContext,&SystemResourcePointerF0,&SystemMemoryBufferTemplate1);
    ConfigureSystemResources(&pSystemStackFlag,&pUnsignedStackFlag110,&SystemMemoryBufferTemplate1);
    ProcessSystemDataTransfer(&pUnsignedStackFlag110,&SystemResourcePointerF0);
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    if (SystemResourceDataOffset != 0) {
        SystemCleanupFunction();
    }
    SystemResourceDataOffset = 0;
    MemoryBufferAddress = 0;
    pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
    SystemResourcePointerF0 = &SystemGlobalDataReference;
    if (SystemMemoryAllocationContext != 0) {
        SystemCleanupFunction();
    }
    SystemMemoryAllocationContext = 0;
    SystemMemoryAllocatorStatus = 0;
    SystemResourcePointerF0 = &SystemMemoryAllocatorReference;
    SystemMemoryContext = &SystemGlobalDataReference;
    if (LocalStackInitializationFlag != 0) {
        SystemCleanupFunction();
    }
    LocalStackInitializationFlag = 0;
    SystemResourceFlags120 = 0;
    SystemMemoryContext = &SystemMemoryAllocatorReference;
    InitializeAndConfigureSystemResources(&pSystemStackFlag);
    ProcessAndManageSystemResources(&pSystemStackFlag);
    ReleaseSystemResource(&pSystemStackFlag);
    InitializeSystemResourceAllocator(&pSystemStackFlag,ConfigurationDataPointer,AdditionalParameter,0);
    pCalculationFlags178 = &SystemGlobalDataReference;
    if (pSystemOperationFlag170 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemOperationFlag170 = (void* *)0x0;
    SystemOperationStatus160 = SystemOperationStatus160 & MAX_UNSIGNED_32_BIT00000000;
    pCalculationFlags178 = &SystemMemoryAllocatorReference;
    pSystemConfigurationId = &SystemGlobalDataReference;
    if (pSystemResourceSize != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pSystemResourceSize = (void* *)0x0;
    SystemThreadContext140 = SystemThreadContext140 & MAX_UNSIGNED_32_BIT00000000;
    pSystemConfigurationId = &SystemMemoryAllocatorReference;
    StackCleanupFlag = 0;
    CalculationFlags1A0 = CalculationFlags1A0 & MAX_UNSIGNED_32_BIT00000000;
    SystemGameControllerBuffer = &SystemMemoryAllocatorReference;
    dataBufferContext = &SystemGlobalDataReference;
    if (pointerUnsignedC8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pointerUnsignedC8 = (void* *)0x0;
    systemDataBuffer = 0;
    dataBufferContext = &SystemMemoryAllocatorReference;
    pSystemStackFlag = &SystemGlobalDataReference;
    if (SystemMemoryOffset190 != 0) {
        SystemCleanupFunction();
    }
    SystemMemoryOffset190 = 0;
    ConcatenatedValue440 = 0;
    pSystemStackFlag = &SystemMemoryAllocatorReference;
  }
SystemStatusCheckPoint:
    ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)SystemDataBuffer1f8);
}





// 函数: void ConfigureSystemDataProcessing(void* SystemResourceManager,void* ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag,
void ConfigureSystemDataProcessing(void* SystemResourceManager,void* ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag,
                  void* SystemProcessingContext)

{
  long long resourceDataIndex;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  uint32_t resourceAddress;
  void* SystemThreadContext;
  int CalculationFlags;
  long long localDataIndex;
  void** SystemDataPointer;
  void* *stackParameterB;
  uint32_t SystemConfigurationValue;
  void* UnsignedStackFlag88;
  uint8_t SystemCounterBuffer80 [72];
  
  SystemOperationResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if (validationStatusFlag == '\0') {
    if ((SystemVerboseFlagPtr == '\0') && (*(int *)(SystemMemoryManagerPointer + 0x10e0) != 1)) {
      systemCounter = 0;
      if ((AdditionalParameter != '\0') || (SystemDebugFlag != '\0')) {
SystemCounterCheckPoint:
        InitializeSystemCounter(SystemCounterBuffer80);
        stackParameterA = &SystemGlobalDataReference;
        UnsignedStackFlag88 = 0;
        stackParameterB = (void* *)0x0;
        SystemConfigurationValue = 0;
        SystemThreadContext = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
        *(uint8_t *)SystemThreadContext = 0;
        stackParameterB = SystemThreadContext;
        resourceAddress = StartSystemThread(SystemThreadContext);
        UnsignedStackFlag88 = ConcatenatedValue44(UnsignedStackFlag88._4_4_,resourceAddress);
        *SystemThreadContext = 0x73656873617263;
        SystemConfigurationValue = 7;
        GetSystemCounter(SystemCounterBuffer80,&SystemParameterPointerA);
        stackParameterA = &SystemGlobalDataReference;
          SystemCleanupFunction(SystemThreadContext);
      }
      if (((SystemInitializationFlag == '\0') || (CalculationFlags = IsDebuggerPresent(), CalculationFlags != 0)) &&
         (SystemSilentMode == '\0')) {
        resourceAddress = MessageBoxA(0,&SystemMessageTitle,&SystemMessageText,0x40004);
        switch(resourceAddress) {
        case 1:
          break;
        default:
          systemCounter = 1;
          break;
        case 4:
          systemCounter = 2;
          break;
        case 5:
          systemCounter = 3;
          break;
        case 6:
          systemCounter = 4;
          break;
        case 7:
          systemCounter = 5;
        }
        if (systemCounter == 4) goto SystemCounterCheckPoint;
      }
      else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
        SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,&SystemMessageText,
                      &SystemMessageTitle);
      }
      ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemContextParam1);
    }
    else {
      ProcessSystemResourceConfigurationOperation(SystemContextManagerPointer,5,3,&SystemConfigParam5);
      InitializeSystemManager();
    }
  }
  else {
    stackParameterA = &SystemGlobalDataReference;
    UnsignedStackFlag88 = 0;
    stackParameterB = (void* *)0x0;
    SystemConfigurationValue = 0;
    resourceDataIndex = -1;
    do {
      localDataIndex = resourceDataIndex;
      resourceDataIndex = localDataIndex + 1;
    } while (*(char *)(localDataIndex + 0x180c84871) != '\0');
    if ((int)(localDataIndex + 1) != 0) {
      CalculationFlags = (int)localDataIndex + 2;
      systemCounter = CalculationFlags;
      if (CalculationFlags < 0x10) {
        systemCounter = 0x10;
      }
      stackParameterB = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCounter,0x13);
      *(uint8_t *)stackParameterB = 0;
      resourceAddress = StartSystemThread(stackParameterB);
      UnsignedStackFlag88 = ConcatenatedValue44(UnsignedStackFlag88._4_4_,resourceAddress);
        memcpy(stackParameterB,&SystemStringBuffer,CalculationFlags);
    }
    SystemConfigurationValue = 0;
    InitializeSystemResourceObject(&SystemParameterPointerA,SystemParameter);
    stackParameterA = &SystemGlobalDataReference;
    if (stackParameterB != (void* *)0x0) {
        SystemCleanupFunction();
    }
  }
  return;
}




/**
 * @brief 空操作函数
 * 
 * 该函数是一个空操作函数，什么都不做，直接返回。
 * 主要用于占位或作为默认的处理函数。
 * 
 * @return 无返回值
 * 
 *FUN_180066dd0：EmptyOperation
 */
void EmptyOperation(void)

{
  return;
}





/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括内存分配器、数据表和资源偏移的设置。
 * 主要用于系统资源管理器的初始化和配置。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 *FUN_180066df0：InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(long long* SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  void** SystemDataTable;
  long long ResourceDataOffset;
  void* *presourceAddress;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  
  presourceAddress = (void* *)SystemResourceManager[1];
  resourceDataIndex = 0;
  if (presourceAddress < (void* *)SystemResourceManager[2]) {
    SystemResourceManager[1] = (long long)(presourceAddress + 4);
    *presourceAddress = &SystemMemoryAllocatorReference;
    presourceAddress[1] = 0;
    *(uint32_t *)(presourceAddress + 2) = 0;
    *presourceAddress = &SystemGlobalDataReference;
    presourceAddress[3] = 0;
    presourceAddress[1] = 0;
    *(uint32_t *)(presourceAddress + 2) = 0;
    *(uint32_t *)(presourceAddress + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
    presourceAddress[1] = *(void* *)(ConfigurationDataPointer + 8);
    *(uint32_t *)((long long)presourceAddress + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
    *(uint32_t *)(presourceAddress + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
    *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
    *(void* *)(ConfigurationDataPointer + 8) = 0;
    *(void* *)(ConfigurationDataPointer + 0x18) = 0;
    return;
  }
  ResourceDataOffset = *SystemResourceManager;
  SystemThreadFlags = (long long)presourceAddress - ResourceDataOffset >> 5;
  if (SystemThreadFlags == 0) {
    SystemThreadFlags = 1;
  }
  else {
    SystemThreadFlags = SystemThreadFlags * 2;
    if (SystemThreadFlags == 0) goto SystemFlagsCheckPoint;
  }
  resourceDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadFlags << 5,(char)SystemResourceManager[3],ConfigurationFlag,InvalidHandleValue);
  presourceAddress = (void* *)SystemResourceManager[1];
  ResourceDataOffset = *SystemResourceManager;
SystemFlagsCheckPoint:
  SystemHashEntryPointer = (void* *)CopySystemResourceDataExtended(ResourceDataOffset,presourceAddress,resourceDataIndex);
  *SystemHashEntryPointer = &SystemMemoryAllocatorReference;
  SystemHashEntryPointer[1] = 0;
  *(uint32_t *)(SystemHashEntryPointer + 2) = 0;
  *SystemHashEntryPointer = &SystemGlobalDataReference;
  SystemHashEntryPointer[3] = 0;
  SystemHashEntryPointer[1] = 0;
  *(uint32_t *)(SystemHashEntryPointer + 2) = 0;
  *(uint32_t *)(SystemHashEntryPointer + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemHashEntryPointer[1] = *(void* *)(ConfigurationDataPointer + 8);
  *(uint32_t *)((long long)SystemHashEntryPointer + 0x1c) = *(uint32_t *)(ConfigurationDataPointer + 0x1c);
  *(uint32_t *)(SystemHashEntryPointer + 3) = *(uint32_t *)(ConfigurationDataPointer + 0x18);
  *(uint32_t *)(ConfigurationDataPointer + 0x10) = 0;
  *(void* *)(ConfigurationDataPointer + 8) = 0;
  *(void* *)(ConfigurationDataPointer + 0x18) = 0;
  presourceAddress = (void* *)SystemResourceManager[1];
  SystemThreadContext = (void* *)*SystemResourceManager;
  if (SystemThreadContext != presourceAddress) {
    do {
      (**(code **)*SystemThreadContext)(SystemThreadContext,0);
      SystemThreadContext = SystemThreadContext + 4;
    } while (SystemThreadContext != presourceAddress);
    SystemThreadContext = (void* *)*SystemResourceManager;
  }
  if (SystemThreadContext == (void* *)0x0) {
    *SystemResourceManager = resourceDataIndex;
    SystemResourceManager[1] = (long long)(SystemHashEntryPointer + 4);
    SystemResourceManager[2] = SystemThreadFlags * 0x20 + resourceDataIndex;
    return;
  }
    SystemCleanupFunction(SystemThreadContext);
}



/**
 * @brief 在内存中搜索数据模式
 * 
 * 该函数负责在指定的内存区域中搜索特定的数据模式。
 * 它会使用memchr和memcmp函数来查找匹配的数据模式。
 * 
 * @param SystemResourceManager 系统资源指针（搜索起始地址）
 * @param ConfigurationDataPointer 配置数据指针（搜索区域大小）
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志（搜索模式）
 * @param DataSize 数据大小
 * @return 返回找到的数据偏移量，如果没有找到则返回-1
 */
long long SearchDataPatternInMemory(long long SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,char *ConfigurationFlag,
                      ulong long DataSize)

{
  char SystemNodeFlag;
  int systemResult;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  
  if (DataSize <= ConfigurationDataPointer) {
    if (DataSize == 0) {
      return 0;
    }
    charStatus = *ConfigurationFlag;
    SystemBufferAddress = (SystemResourceManager - DataSize) + ConfigurationDataPointer;
    for (ResourceDataOffset = memchr(SystemResourceManager,(int)charStatus,(SystemBufferAddress + 1) - SystemResourceManager); ResourceDataOffset != 0;
        ResourceDataOffset = memchr(ResourceDataOffset + 1,(int)charStatus,(SystemBufferAddress + 1) - (ResourceDataOffset + 1))) {
      systemResult = memcmp(ResourceDataOffset,ConfigurationFlag,DataSize);
      if (systemResult == 0) {
        return ResourceDataOffset - SystemResourceManager;
      }
    }
  }
  return -1;
}




/**
 * @brief 处理系统越界异常
 * 
 * 该函数负责处理系统越界异常，包括异常报告和异常处理。
 * 主要用于系统异常的处理和恢复。
 * 
 * @return 无返回值
 * 
 *FUN_180067050：HandleSystemOutOfRangeException
 */
void HandleSystemOutOfRangeException(void)

{
  code *systemFunctionPointer;
  
  __Xout_of_range_std__YAXPEBD_Z(&SystemErrorMessageOutOfRange);
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}




// 函数: void FreeSystemResourceMemory(long long* SystemResourceManager)
/**
 * @brief 释放系统资源内存
 * 
 * 该函数负责释放系统资源内存，处理内存分配和释放操作
 * 用于系统资源管理和内存清理
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_180067070：FreeSystemResourceMemory
 */
void FreeSystemResourceMemory(long long* SystemResourceManager)

{
  ulong long SystemOperationStatus;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  
  SystemOperationStatus = SystemResourceManager[3];
  if (0xf < SystemOperationStatus) {
    SystemThreadHandle = *SystemResourceManager;
    ResourceDataOffset = SystemThreadHandle;
    if (0xfff < SystemOperationStatus + 1) {
      ResourceDataOffset = *(long long *)(SystemThreadHandle + -8);
      if (0x1f < (SystemThreadHandle - ResourceDataOffset) - 8U) {
          _invalid_parameter_noinfo_noreturn(SystemThreadHandle - ResourceDataOffset,SystemOperationStatus + 0x28);
      }
    }
    free(ResourceDataOffset);
  }
  SystemResourceManager[2] = 0;
  SystemResourceManager[3] = 0xf;
  *(uint8_t *)SystemResourceManager = 0;
  return;
}




// 函数: void ExecuteSystemResourceMemoryFree(void)
/**
 * @brief 执行系统资源内存释放
 * 
 * 该函数负责执行系统资源内存释放操作，调用内存释放函数
 * 用于系统资源清理和内存管理
 * 
 *FUN_1800670d0：ExecuteSystemResourceMemoryFree
 */
void ExecuteSystemResourceMemoryFree(void)

{
  FreeSystemResourceMemory();
  return;
}




/**
 * @brief 处理长度错误异常
 * 
 * 该函数负责处理系统中的长度错误异常，调用标准库的长度错误处理函数，
 * 然后通过软件中断执行错误处理程序。
 * 
 *FUN_1800670f0：HandleLengthError
 */
void HandleLengthError(void)

{
  code *systemFunctionPointer;
  
  __Xlength_error_std__YAXPEBD_Z(&SystemErrorMessageLengthError);
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}




/**
 * @brief 系统内存分配器
 * 
 * 该函数负责分配系统内存，根据请求的大小进行内存分配。
 * 对于小内存请求使用标准malloc，对于大内存请求使用系统级别的内存分配。
 * 
 * @param MemoryAllocationSize 内存分配大小
 * @return 返回分配的内存地址
 * 
 *FUN_180067110：AllocateSystemMemory
 */
void* AllocateSystemMemory(ulong long MemoryAllocationSize)

{
  code *systemExceptionHandler;
  int memoryAllocationResult;
  long long allocatedMemoryAddress;
  ulong long adjustedMemorySize;
  
  if (0xfff < MemoryAllocationSize) {
    adjustedMemorySize = MemoryAllocationSize + 0x27;
    if (adjustedMemorySize <= MemoryAllocationSize) {
      adjustedMemorySize = 0xffffffffffffffff;
    }
    allocatedMemoryAddress = SystemLevelMemoryAllocation(adjustedMemorySize);
    if (allocatedMemoryAddress == 0) {
        _invalid_parameter_noinfo_noreturn();
    }
    *(long long *)((allocatedMemoryAddress + 0x27U & MAX_UNSIGNED_32_BITffffffe0) - 8) = allocatedMemoryAddress;
    return;
  }
  if (MemoryAllocationSize == 0) {
    return;
  }
  do {
    allocatedMemoryAddress = malloc(MemoryAllocationSize);
    if (allocatedMemoryAddress != 0) {
      return;
    }
    memoryAllocationResult = _callnewh(MemoryAllocationSize);
  } while (memoryAllocationResult != 0);
  if (MemoryAllocationSize == 0xffffffffffffffff) {
    SystemExceptionHandler();
    systemExceptionHandler = (code *)swi(3);
    (*systemExceptionHandler)();
    return;
  }
  SystemCleanupHandler();
  systemExceptionHandler = (code *)swi(3);
  (*systemExceptionHandler)();
  return;
}




/**
 * @brief 系统内存释放器
 * 
 * 该函数负责释放系统内存，根据内存地址和大小进行内存释放。
 * 对于大内存块使用特殊的释放机制，对于小内存块使用标准free。
 * 
 * @param MemoryAddress 内存地址
 * @param MemorySize 内存大小
 * 
 *FUN_180067170：FreeSystemMemory
 */
void FreeSystemMemory(long long MemoryAddress,ulong long MemorySize)

{
  long long memoryBlockPointer;
  
  memoryBlockPointer = MemoryAddress;
  if (0xfff < MemorySize) {
    memoryBlockPointer = *(long long *)(MemoryAddress + -8);
    if (0x1f < (MemoryAddress - memoryBlockPointer) - 8U) {
        _invalid_parameter_noinfo_noreturn(MemoryAddress - memoryBlockPointer,MemorySize + 0x27);
    }
  }
  free(memoryBlockPointer);
  return;
}




/**
 * @brief 系统数据缓冲区重新分配器
 * 
 * 该函数负责重新分配系统数据缓冲区，根据新的参数调整缓冲区大小。
 * 主要用于系统数据缓冲区的动态调整和优化。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数，指定新的缓冲区大小
 * 
 *FUN_1800671b0：ReallocateSystemDataBuffer
 */
void ReallocateSystemDataBuffer(void* *SystemResourceManager,void* ConfigurationDataPointer,ulong long AdditionalParameter)

{
  ulong long currentBufferSize;
  code *systemExceptionHandler;
  void* allocatedMemoryBuffer;
  ulong long adjustedBufferSize;
  void* *bufferDataPointer;
  ulong long maximumBufferSize;
  
  currentBufferSize = SystemResourceManager[3];
  if (AdditionalParameter <= currentBufferSize) {
    bufferDataPointer = SystemResourceManager;
    if (0xf < currentBufferSize) {
      bufferDataPointer = (void* *)*SystemResourceManager;
    }
    SystemResourceManager[2] = AdditionalParameter;
      memmove(bufferDataPointer);
  }
  if (AdditionalParameter < 0x8000000000000000) {
    adjustedBufferSize = AdditionalParameter | 0xf;
    maximumBufferSize = 0x7fffffffffffffff;
    if (((adjustedBufferSize < 0x8000000000000000) && (currentBufferSize <= 0x7fffffffffffffff - (currentBufferSize >> 1))) &&
       (currentBufferSize = (currentBufferSize >> 1) + currentBufferSize, maximumBufferSize = adjustedBufferSize, adjustedBufferSize < currentBufferSize)) {
      maximumBufferSize = currentBufferSize;
    }
    allocatedMemoryBuffer = AllocateSystemMemory(maximumBufferSize + 1);
    SystemResourceManager[2] = AdditionalParameter;
    SystemResourceManager[3] = maximumBufferSize;
      memcpy(allocatedMemoryBuffer,ConfigurationDataPointer,AdditionalParameter);
  }
  HandleLengthError();
  systemExceptionHandler = (code *)swi(3);
  (*systemExceptionHandler)();
  return;
}




/**
 * @brief 系统字符串缓冲区分配器
 * 
 * 该函数负责分配系统字符串缓冲区，根据请求的大小进行内存分配和设置。
 * 主要用于系统字符串处理的内存分配和初始化。
 * 
 * @param StringBufferSize 字符串缓冲区大小
 * 
 *FUN_18006720b：AllocateStringBuffer
 */
void AllocateStringBuffer(ulong long StringBufferSize)

{
  ulong long calculatedBufferSize;
  void* allocatedStringBuffer;
  long long stringMemoryBlockPtr;
  ulong long stringStackFrameSize;
  void* stringIteratorPtr;
  ulong long stringDataIndex;
  
  StringBufferSize = StringBufferSize | 0xf;
  if (((StringBufferSize <= stringDataIndex) && (stringStackFrameSize <= stringDataIndex - (stringStackFrameSize >> 1))) &&
     (calculatedBufferSize = (stringStackFrameSize >> 1) + stringStackFrameSize, stringDataIndex = StringBufferSize, StringBufferSize < calculatedBufferSize)) {
    stringDataIndex = calculatedBufferSize;
  }
  allocatedStringBuffer = AllocateSystemMemory(stringDataIndex + 1);
  *(void* *)(stringMemoryBlockPtr + 0x10) = stringIteratorPtr;
  *(ulong long *)(stringMemoryBlockPtr + 0x18) = stringDataIndex;
    memcpy(allocatedStringBuffer);
}




/**
 * @brief 系统空操作函数B
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 用于系统初始化过程中的占位符或默认处理
 * 
 * @note 这是一个空操作函数，仅用于系统初始化的完整性
 * 
 *FUN_18006729a：SystemNoOperationB
 */
void SystemNoOperationB(void)

{
  return;
}




/**
 * @brief 系统参数错误处理器
 * 
 * 该函数负责处理系统参数错误，当参数无效时调用错误处理函数。
 * 主要用于系统参数验证和错误处理。
 * 
 *FUN_1800672b0：HandleSystemParameterError
 */
void HandleSystemParameterError(void)

{
    _invalid_parameter_noinfo_noreturn();
}




/**
 * @brief 处理系统长度错误和软件中断
 * 
 * 该函数负责处理系统长度错误，并通过软件中断执行错误处理程序
 * 用于系统错误处理和异常管理
 * 
 *FUN_1800672b7：HandleSystemLengthErrorAndSWI
 */
void HandleSystemLengthErrorAndSWI(void)

{
  code *systemFunctionPointer;
  
  HandleLengthError();
  systemFunctionPointer = (code *)swi(3);
  (*systemFunctionPointer)();
  return;
}





/**
 * @brief 处理系统资源队列和完成状态
 * 
 * 该函数负责处理系统资源队列，获取完成状态并处理线程优先级
 * 用于系统资源管理和队列处理
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_1800672c0：ProcessSystemResourceQueueAndCompletion
 */
void ProcessSystemResourceQueueAndCompletion(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  int NodeIdentifierComparisonResult;
  void* resourceAddress;
  void* currentThreadId;
  long long *pSystemThreadFlags;
  uint StackBuffer1 [2];
  long long LocalCounterValue;
  long long LocalSystemFlags;
  long long *pStackValue1;
  uint32_t SystemProcessFlags70;
  uint32_t ResourceAddressHigh32;
  uint32_t EncryptionValue68;
  uint32_t ThreadHandleHigh32;
  uint32_t SystemThreadContext;
  uint32_t ResourceAddressHigh32Copy;
  uint32_t SystemProcessFlags58;
  uint32_t ThreadHandleHigh32Copy;
  void* *memoryAllocationEnd;
  void* *pSystemEncryptionKey;
  
  resourceAddress = GetCurrentThread();
  SetThreadPriority(resourceAddress,0);
  StackBuffer1[0] = 0;
  LocalSystemFlags = 0;
  LocalCounterValue = 0;
  while( true ) {
    while( true ) {
      systemCounter = GetQueuedCompletionStatus
                        (*(void* *)(SystemResourceManager + 0x28),StackBuffer1,&LocalSystemFlags,&LocalCounterValue,
                         0xffffffff);
      SystemThreadHandle = LocalCounterValue;
      if (systemCounter == 0) break;
      if (LocalSystemFlags == -1) {
        return;
      }
      *(long long *)(LocalCounterValue + 0x1c8) =
           *(long long *)(LocalCounterValue + 0x1c8) - (ulong long)StackBuffer1[0];
      resourceAddress = SystemManagerPointerStorage;
      if (*(long long *)(LocalCounterValue + 0x1c8) < 1) {
        resourceDataIndex = *(long long *)(SystemResourceManager + 0x20);
        currentThreadId = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x40,8,10);
        pStackValue1 = (long long *)&SystemThreadContext;
        memoryAllocationEnd = &SystemMemoryAllocationEndMarker;
        pSystemEncryptionKey = &SystemMemoryAllocationStartMarker;
        SystemProcessFlags70 = (uint32_t)resourceAddress;
        ResourceAddressHigh32 = (uint32_t)((ulong long)resourceAddress >> 0x20);
        EncryptionValue68 = (uint32_t)SystemThreadHandle;
        ThreadHandleHigh32 = (uint32_t)((ulong long)SystemThreadHandle >> 0x20);
        SystemThreadContext = SystemProcessFlags70;
        ResourceAddressHigh32Copy = ResourceAddressHigh32;
        SystemProcessFlags58 = EncryptionValue68;
        ThreadHandleHigh32Copy = ThreadHandleHigh32;
        pSystemThreadFlags = (long long *)InitializeSystemResource(currentThreadId,&SystemThreadContext);
        if (pSystemThreadFlags != (long long *)0x0) {
          (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
        }
        resourceAddress = SystemAllocationFlagsTemplate;
        pStackValue1 = pSystemThreadFlags;
        if (*(char *)(resourceDataIndex + 0x368) == '\0') {
          pSystemThreadFlags[3] = -4;
          (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
          ProcessSystemResourceSemaphore(resourceAddress,&pStackValue1);
        }
        else {
          if (pSystemThreadFlags != (long long *)0x0) {
            (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
          }
          ReleaseSystemResourceSemaphore(resourceAddress,&pStackValue1);
        }
        if (pSystemThreadFlags != (long long *)0x0) {
          (**(code **)(*pSystemThreadFlags + 0x38))(pSystemThreadFlags);
        }
      }
    }
    systemCounter = GetLastError();
    if (systemCounter == 0x2df) {
      return;
    }
    if (LocalCounterValue == 0) break;
    UpdateSystemResourceContextManager(*(void* )(SystemResourceManager + 0x20));
  }
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemContextUpdateData,systemCounter);
}





/**
 * @brief 更新系统资源上下文管理器
 * 
 * 该函数负责更新系统资源上下文管理器，处理字符串模板和配置数据
 * 用于系统资源管理和上下文更新
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_180067480：UpdateSystemResourceContextManager
 */
void UpdateSystemResourceContextManager(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  void** SystemDataPointer;
  void** SystemHashEntryPointer;
  
  SystemDataPointer = *(void* **)(*(long long *)(ConfigurationDataPointer + 0x1f8) + 0x10);
  SystemHashEntryPointer = &SystemStringTemplate;
  if (SystemDataPointer != (void* *)0x0) {
    SystemHashEntryPointer = SystemDataPointer;
  }
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemErrorMessageContextManager,SystemHashEntryPointer);
}




/**
 * @brief 执行系统资源操作
 * 
 * 该函数负责执行系统资源操作，调用系统资源指针中的代码函数
 * 用于系统资源管理和操作执行
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_180067810：ExecuteSystemResourceOperation
 */
void ExecuteSystemResourceOperation(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(SystemResourceManager + 0x10) != (code *)0x0) {
    (**(code **)(SystemResourceManager + 0x10))(SystemResourceManager,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  return;
}





// 函数: void FreeSystemResourceMemoryEx(long long* SystemResourceManager)
/**
 * @brief 处理系统资源内存分配和缓冲区管理
 * 
 * 该函数负责处理系统资源的内存分配操作，包括缓冲区管理、
 * 内存模板配置和系统资源的状态更新
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_180067840：ProcessSystemResourceMemoryAllocation
 */
void ProcessSystemResourceMemoryAllocation(long long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  void* currentThreadId;
  void* ResourceHash;
  void** SystemCurrentNode;
  long long *pSystemMemoryAddress;
  int systemId;
  long long SystemResourceIndex;
  void** hashTableNode;
  long long SystemResourceContextPointer;
  long long SystemResourceContextValue;
  void* systemDataBuffer;
  void*2 UnsignedStackFlagB0;
  uint8_t SystemOperationType;
  uint8_t SystemAllocationMode;
  uint8_t StackBuffer [64];
  void* SystemEncryptionKey;
  void* SystemOperationCounter;
  
  SystemEncryptionKey = 0xfffffffffffffffe;
  ResourceDataOffset = SystemResourceManager[1];
  systemId = *(int *)(ResourceDataOffset + 0x138) - *(int *)(ResourceDataOffset + 0x1d8);
  SystemBufferAddress = *(long long *)(ResourceDataOffset + 0x150);
  pSystemMemoryAddress = (long long *)0x0;
  if (SystemBufferAddress != 0) {
    currentThreadId = *(void* *)(ResourceDataOffset + 0x158);
    ResourceHash = *(void* *)(ResourceDataOffset + 0x1e0);
    SystemResourceIndex = *(long long *)(ResourceDataOffset + 0x140);
    ResourceDataOffset = *(long long *)(ResourceDataOffset + 0x1f0);
    if (SystemBufferAddress - 2U < 2) {
      pSystemMemoryAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x10,8,3);
      *pSystemMemoryAddress = (long long)&SystemMemoryPoolTemplate;
      *(bool *)(pSystemMemoryAddress + 1) = SystemBufferAddress == 3;
    }
    (**(code **)(*pSystemMemoryAddress + 0x18))(pSystemMemoryAddress,StackBuffer,systemId + ResourceDataOffset,SystemResourceIndex,ResourceHash,currentThreadId);
      SystemCleanupFunction(pSystemMemoryAddress);
  }
  SystemAllocationMode = 3;
  ResourceDataOffset = SystemResourceManager[1];
  systemDataBuffer = *(void* *)(ResourceDataOffset + 0x140);
  SystemResourceContextPointer = (long long)systemId + *(long long *)(ResourceDataOffset + 0x1f0);
  UnsignedStackFlagB0 = 1;
  SystemResourceContextValue = SystemResourceContextPointer;
  (**(code **)(ResourceDataOffset + 0x180))(&SystemResourceContextPointer,*(long long *)(ResourceDataOffset + 0x1f8) + 8);
  if (((char)UnsignedStackFlagB0 == '\0') && (SystemResourceContextPointer != 0)) {
      SystemCleanupFunction();
  }
  LOCK();
  SystemIntegerPointer = (int *)(*(long long *)(SystemResourceManager[1] + 0x1f8) + 0x120);
  *SystemIntegerPointer = *SystemIntegerPointer + -1;
  UNLOCK();
  LocalMemoryOffset = *(long long *)(SystemResourceManager[1] + 0x1a8);
  ResourceDataOffset = *SystemResourceManager;
  AllocateSystemResource(ResourceDataOffset + 0x10,&LocalMemoryOffset);
  systemId = _Cnd_signal(ResourceDataOffset + 0x278);
  if (systemId != 0) {
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  StackPointer1 = *(void* **)(SystemResourceManager[1] + 0x1b0);
  ResourceDataOffset = *SystemResourceManager;
  AllocateSystemResource(ResourceDataOffset + 0x10,&StackPointer1);
  systemId = _Cnd_signal(ResourceDataOffset + 0x278);
  if (systemId != 0) {
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  ResourceDataOffset = *(long long *)(SystemResourceManager[1] + 0x1c0);
  if (*(long long *)(SystemResourceManager[1] + 0x1b8) != 0) {
      SystemCleanupFunction();
  }
  if (ResourceDataOffset != 0) {
      SystemCleanupFunction(ResourceDataOffset);
  }
  ResourceDataOffset = SystemResourceManager[1];
  if (*(long long *)(ResourceDataOffset + 0x150) == 0) {
    if (*(long long *)(ResourceDataOffset + 0x148) == 0) {
      pSystemMemoryAddress = *(long long **)(ResourceDataOffset + 0x140);
    }
  }
  else {
    pSystemMemoryAddress = *(long long **)(ResourceDataOffset + 0x140);
    if (*(long long *)(ResourceDataOffset + 0x148) == 0) {
      pSystemMemoryAddress = (long long *)((long long)pSystemMemoryAddress + *(long long *)(ResourceDataOffset + 0x158));
    }
  }
  LOCK();
  resourcePoolPointer = (long long *)(*(long long *)(*SystemResourceManager + 8) + 0x3f0);
  *resourcePoolPointer = *resourcePoolPointer - (long long)pSystemMemoryAddress;
  UNLOCK();
  LOCK();
  SystemIntegerPointer = (int *)(*(long long *)(*SystemResourceManager + 8) + 0x3f8);
  *SystemIntegerPointer = *SystemIntegerPointer + -1;
  UNLOCK();
  SystemBufferAddress = *SystemResourceManager;
  hashTableNode = (void* *)SystemResourceManager[1];
  ResourceDataOffset = SystemBufferAddress + 0x200380;
  SystemOperationCounter = 0x180068808;
  LocalMemoryOffset = ResourceDataOffset;
  StackPointer1 = hashTableNode;
  systemId = _Mtx_lock(ResourceDataOffset);
  if (systemId != 0) {
    SystemOperationCounter = 0x180068815;
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  SystemOperationCounter = 0x18006881f;
  ReleaseSystemResource(hashTableNode + 4);
  *hashTableNode = *(void* *)(SystemBufferAddress + 0x200378);
  *(void* **)(SystemBufferAddress + 0x200378) = hashTableNode;
  SystemOperationCounter = 0x18006883a;
  systemId = _Mtx_unlock(ResourceDataOffset);
  if (systemId != 0) {
    SystemOperationCounter = 0x180068847;
    __Throw_C_error_std__YAXH_Z(systemId);
  }
  return;
}





// 函数: void CleanupAndInitializeSystemResource(void* *SystemResourceManager)
/**
 * @brief 系统资源清理和初始化函数
 * 
 * 该函数负责系统资源的清理操作，包括内存释放、
 * 资源重置和状态初始化
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_180067bc0：CleanupAndInitializeSystemResource
 */
void CleanupAndInitializeSystemResource(void* *SystemResourceManager)

{
  uint8_t asystemDataBuffer [48];
  void* *pUnsignedStackFlag88;
  void* SystemProcessFlags70;
  void* *pEncryptionValue68;
  ulong long SystemResourceStatusFlag;
  
  SystemProcessFlags70 = 0xfffffffffffffffe;
  SystemResourceStatusFlag = SystemEncryptionKeyTemplate ^ (ulong long)asystemDataBuffer;
  pEncryptionValue68 = SystemResourceManager;
  DestroySystemResourceManager();
  *SystemResourceManager = &SystemResourceEncryptionKeyTemplate;
  pUnsignedStackFlag88 = SystemResourceManager + 0x6e;
    memset(pUnsignedStackFlag88,0,0x200000);
}




// 函数: void DestroySystemMutex(void)
/**
 * @brief 系统互斥锁销毁函数
 * 
 * 该函数负责销毁系统互斥锁，清理线程同步资源
 * 
 *FUN_180067f00：DestroySystemMutex
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: void DestroySystemMutexB(void)
/**
 * @brief 系统互斥锁销毁函数B
 * 
 * 该函数负责销毁系统互斥锁，清理线程同步资源
 * 这是DestroySystemMutex的另一个版本
 * 
 *FUN_180067f30：DestroySystemMutexB
 */
void DestroySystemMutexB(void)

{
  _Mtx_destroy_in_situ();
  return;
}





// 函数: void CreateSystemIoCompletionPort(long long SystemResourceManager,long long ConfigurationDataPointer)
void CreateSystemIoCompletionPort(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  int SystemOperationStatus;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  void* *presourceAddress;
  void* SystemThreadContext;
  ulong long ResourceHash;
  uint SystemLoopCounter;
  uint8_t EncryptionValidationBuffer2E8 [32];
  ulong long SystemOperationFlag;
  uint32_t SystemDataCount2c0;
  void* SystemDataCount;
  long long SystemMutexAddress;
  void* SystemOperationContext;
  long long SystemMemoryOffset[4];
  void* SystemDataMemoryContext;
  void* SystemResourceHandle;
  ulong long SystemEncryptionKey;
  ulong long OperationCode;
  
  SystemOperationContext = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)StackMemoryEncryptionKey2e8;
  InitializeSystemDataMemoryContext(&SystemDataMemoryContext);
  presourceAddress = &SystemStringTemplate;
  if (SystemResourceHandle != (void* *)0x0) {
    presourceAddress = SystemResourceHandle;
  }
  ResourceHash = 0;
  SystemDataCount = 0;
  SystemDataCount2c0 = 0x60000001;
  SystemOperationFlag = ConcatenatedValue44(SystemOperationFlag._4_4_,3);
  SystemThreadHandle = CreateFileA(presourceAddress,0x80000000,1,0);
  if (SystemThreadHandle == -1) {
    presourceAddress = &SystemStringTemplate;
    if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
      presourceAddress = *(void* **)(ConfigurationDataPointer + 8);
    }
      UpdateContextManagerSystem(SystemContextManagerPointer,&SystemErrorMessageFileCreation,presourceAddress);
  }
  ResourceDataOffset = CreateIoCompletionPort(SystemThreadHandle,*(void* *)(SystemResourceManager + 0x213430),0,0);
  if (ResourceDataOffset != *(long long *)(SystemResourceManager + 0x213430)) {
    presourceAddress = &SystemStringTemplate;
    if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
      presourceAddress = *(void* **)(ConfigurationDataPointer + 8);
    }
      UpdateContextManagerSystem(SystemContextManagerPointer,&SystemConfigurationUpdateData,presourceAddress);
  }
  ResourceDataOffset = SystemResourceManager + 0x2133e0;
  SystemMutexAddress = ResourceDataOffset;
  SystemOperationStatus = _Mtx_lock(ResourceDataOffset);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  SystemThreadContext = *(void* **)(SystemResourceManager + 0x2133d8);
  if (SystemThreadContext == (void* *)0x0) {
    OperationCode = *(ulong long *)(SystemResourceManager + 0x2133d0);
    if (0xff < OperationCode) {
      SystemOperationStatus = _Mtx_unlock(ResourceDataOffset);
      if (SystemOperationStatus != 0) {
        __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
      }
      _SystemConfigSizePtr = *(uint32_t *)(ConfigurationDataPointer + 0x10);
      presourceAddress = &SystemStringTemplate;
      if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
        presourceAddress = *(void* **)(ConfigurationDataPointer + 8);
      }
      strcpy_s(_SystemStringBufferPtr,0x100,presourceAddress);
      OperationCode = ResourceHash;
      if (0 < *(int *)(ConfigurationDataPointer + 0x10)) {
        do {
          ResourceHash = ResourceHash * 0x1f + (long long)*(char *)(OperationCode + *(long long *)(ComparisonDataPointer + 8));
          ThreadContextFlag = (int)OperationCode + 1;
          OperationCode = (ulong long)ThreadContextFlag;
        } while ((int)ThreadContextFlag < *(int *)(ConfigurationDataPointer + 0x10));
      }
      lRam0000000000000128 = SystemThreadHandle;
      SystemOperationFlag = ResourceHash;
      ConfigureSystemResourceAllocation(SystemResourceManager + 0x330,SystemMemoryOffset,OperationCode,ConfigurationDataPointer);
      *(void* *)(SystemMemoryOffset[0] + 0x118) = 0;
      SystemDataMemoryContext = &SystemMemoryAllocatorReference;
        ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)EncryptionValidationBuffer2E8);
    }
    SystemThreadContext = (void* *)(OperationCode * 0x130 + SystemResourceManager + 0x2003d0);
    *(ulong long *)(SystemResourceManager + 0x2133d0) = OperationCode + 1;
  }
  else {
    *(void* *)(SystemResourceManager + 0x2133d8) = *SystemThreadContext;
  }
    memset(SystemThreadContext + 1,0,0x128);
}




/**
 * @brief 系统内存分配和互斥锁管理函数
 * 
 * 该函数负责管理系统内存分配，包括内存对齐、互斥锁操作和内存页面管理。
 * 用于系统内存资源的动态分配和同步控制。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数（包含内存分配信息）
 * @return 分配结果或错误代码
 * 
 *FUN_180068250：AllocateSystemMemoryWithMutex
 */
void* AllocateSystemMemoryWithMutex(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  ulong long SystemOperationStatus;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  void* resourceAddress;
  ulong long currentThreadId;
  void** SystemRootNode;
  ulong long ThreadContextFlag;
  ulong long OperationCode;
  
  OperationCode = *(ulong long *)(AdditionalParameter + 0x118) & MAX_UNSIGNED_32_BITfffff000;
  currentThreadId = (*(long long *)(AdditionalParameter + 0x120) - OperationCode) + *(ulong long *)(AdditionalParameter + 0x118);
  ThreadContextFlag = (ulong long)(-(uint)((currentThreadId & 0xfff) != 0) & 0x1000) + (currentThreadId & MAX_UNSIGNED_32_BITfffff000);
  systemCounter = _Mtx_lock(SystemResourceManager + 0x200380);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  resourceEntryPointer = *(void* **)(SystemResourceManager + 0x200378);
  if (resourceEntryPointer == (void* *)0x0) {
    SystemOperationStatus = *(ulong long *)(SystemResourceManager + 0x200370);
    if (0xfff < SystemOperationStatus) {
      systemCounter = _Mtx_unlock(SystemResourceManager + 0x200380);
      if (systemCounter != 0) {
        __Throw_C_error_std__YAXH_Z(systemCounter);
      }
      ConfigureSystemResourceAllocation(0x20,AdditionalParameter);
      uRam00000000000001f0 = 0;
      uRam00000000000001e8 = 0;
      uRam00000000000001e0 = 0;
      SystemOperationResult = ConfigureResourceManager(SystemResourceManager,0x20,0x1e0,0x1e8,0x1f0);
      if (validationStatusFlag == '\0') {
        ProcessSystemResourceData(SystemResourceManager + 0x370,0);
        resourceAddress = 0;
      }
      else {
        _SystemDataNullPtr = 0;
        _SystemDataBufferPtr = 0;
        _SystemConfigSizePtr = 0;
        LOCK();
        _SystemStringBufferPtr = OperationCode;
        uRam00000000000001c8 = currentThreadId;
        uRam00000000000001d0 = ThreadContextFlag;
        uRam00000000000001d8 = OperationCode;
        lRam00000000000001f8 = ConfigurationDataPointer;
        *(int *)(ConfigurationDataPointer + 0x120) = *(int *)(ConfigurationDataPointer + 0x120) + 1;
        UNLOCK();
        systemCounter = ReadFile(*(void* *)(ConfigurationDataPointer + 0x128),uRam00000000000001f0,ThreadContextFlag & MAX_UNSIGNED_32_BIT,0,
                         0);
        if (systemCounter != 0) {
            UpdateContextManagerSystem(SystemContextManagerPointer,&SystemStateUpdateData);
        }
        systemCounter = GetLastError();
        if (systemCounter != 0x3e5) {
            UpdateContextManagerSystem(SystemContextManagerPointer,&SystemStatusUpdateData,systemCounter);
        }
        resourceAddress = 1;
      }
      return resourceAddress;
    }
    resourceEntryPointer = (void* *)(SystemOperationStatus * 0x200 + SystemResourceManager + 0x370);
    *(ulong long *)(SystemResourceManager + 0x200370) = SystemOperationStatus + 1;
  }
  else {
    *(void* *)(SystemResourceManager + 0x200378) = *resourceEntryPointer;
    *resourceEntryPointer = 0;
  }
    memset(resourceEntryPointer,0,0x200);
}



/**
 * @brief 复制系统配置数据
 * 
 * 该函数负责复制系统配置数据，将配置数据从一个资源复制到另一个资源。
 * 它会复制字符串模板、指针和各个配置字段，并调用相应的回调函数。
 * 
 * @param SystemResourceManager 目标系统资源指针
 * @param ConfigurationDataPointer 源配置数据指针
 * @return 返回目标系统资源指针
 */
long long CopySystemConfigurationData(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  code *SystemStringPointer;
  void* *SystemHashNodeData;
  
  *(uint32_t *)(SystemResourceManager + 0x10) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemHashNodeData = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemHashNodeData = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(*(void* *)(SystemResourceManager + 8),0x100,SystemHashNodeData);
  *(void* *)(SystemResourceManager + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
  resourceDataIndex = SystemResourceManager + 0x148;
  *(void* *)(SystemResourceManager + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
  *(void* *)(SystemResourceManager + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
  *(void* *)(SystemResourceManager + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
  *(void* *)(SystemResourceManager + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
  *(uint8_t *)(SystemResourceManager + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
  if (resourceDataIndex != ConfigurationDataPointer + 0x148) {
    if (*(code **)(SystemResourceManager + 0x158) != (code *)0x0) {
      (**(code **)(SystemResourceManager + 0x158))(resourceDataIndex,0,0);
    }
    pSystemOperationResult = *(code **)(ConfigurationDataPointer + 0x158);
    if (SystemStringPointer != (code *)0x0) {
      (*pSystemOperationResult)(resourceDataIndex,ConfigurationDataPointer + 0x148,1);
      pSystemOperationResult = *(code **)(ConfigurationDataPointer + 0x158);
    }
    *(code **)(SystemResourceManager + 0x158) = pSystemOperationResult;
    *(void* *)(SystemResourceManager + 0x160) = *(void* *)(ConfigurationDataPointer + 0x160);
  }
  resourceDataIndex = SystemResourceManager + 0x168;
  if (resourceDataIndex != ConfigurationDataPointer + 0x168) {
    if (*(code **)(SystemResourceManager + 0x178) != (code *)0x0) {
      (**(code **)(SystemResourceManager + 0x178))(resourceDataIndex,0,0);
    }
    pSystemOperationResult = *(code **)(ConfigurationDataPointer + 0x178);
    if (SystemStringPointer != (code *)0x0) {
      (*pSystemOperationResult)(resourceDataIndex,ConfigurationDataPointer + 0x168,1);
      pSystemOperationResult = *(code **)(ConfigurationDataPointer + 0x178);
    }
    *(code **)(SystemResourceManager + 0x178) = pSystemOperationResult;
    *(void* *)(SystemResourceManager + 0x180) = *(void* *)(ConfigurationDataPointer + 0x180);
  }
  *(void* *)(SystemResourceManager + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
  *(void* *)(SystemResourceManager + 400) = *(void* *)(ConfigurationDataPointer + 400);
  *(void* *)(SystemResourceManager + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
  *(void* *)(SystemResourceManager + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
  return SystemResourceManager;
}




// 函数: void ConfigureSystemResourceWithMutex(long long SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void ConfigureSystemResourceWithMutex(long long SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  void* resourceCreationFlags;
  
  resourceCreationFlags = 0xfffffffffffffffe;
  CloseHandle(ConfigurationDataPointer[0x25]);
  SystemOperationStatus = _Mtx_lock(SystemResourceManager + 0x2133e0);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  (**(code **)*ConfigurationDataPointer)(ConfigurationDataPointer,0,AdditionalParameter,ConfigurationFlag,resourceCreationFlags);
  *ConfigurationDataPointer = *(void* *)(SystemResourceManager + 0x2133d8);
  *(void* **)(SystemResourceManager + 0x2133d8) = ConfigurationDataPointer;
  SystemOperationStatus = _Mtx_unlock(SystemResourceManager + 0x2133e0);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  return;
}




// 函数: void CleanupSystemResourceData(long long SystemResourceManager)
void CleanupSystemResourceData(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  char SystemOperationStatusFlag;
  long long *SystemLocalContextPointer;
  long long *pSystemThreadFlags;
  long long *plocalDataIndex;
  long long *PrimaryResourcePointer;
  
  SystemOperationStatusFlag = FindSystemResourceManagerMapping(SystemResourceManager + 0x10,&PrimaryResourcePointer);
  do {
    if (SystemOperationStatusFlag == '\0') {
      return;
    }
    resourcePoolPointer = *(long long **)(SystemResourceManager + 0x318);
    if (PrimaryResourcePointer != (long long *)0x0) {
      *(uint8_t *)(PrimaryResourcePointer + 4) = 0;
      *resourcePoolPointer = *resourcePoolPointer - PrimaryResourcePointer[1];
      resourcePoolPointer[2] = resourcePoolPointer[2] + PrimaryResourcePointer[1];
      plocalDataIndex = (long long *)PrimaryResourcePointer[3];
      pSystemThreadFlags = (long long *)resourcePoolPointer[3];
      SystemLocalContextPointer = PrimaryResourcePointer;
      if (plocalDataIndex != pSystemThreadFlags) {
        do {
          if ((plocalDataIndex == (long long *)0x0) || ((char)plocalDataIndex[4] != '\0')) break;
          ResourceDataOffset = SystemLocalContextPointer[2];
          plocalDataIndex[2] = ResourceDataOffset;
          if (ResourceDataOffset != 0) {
            *(long long **)(ResourceDataOffset + 0x18) = plocalDataIndex;
          }
          plocalDataIndex[1] = plocalDataIndex[1] + SystemLocalContextPointer[1];
          *SystemLocalContextPointer = resourcePoolPointer[0x28005];
          resourcePoolPointer[0x28005] = (long long)SystemLocalContextPointer;
          pSystemThreadFlags = (long long *)resourcePoolPointer[3];
          PrimaryResourcePointer = plocalDataIndex + 3;
          SystemLocalContextPointer = plocalDataIndex;
          plocalDataIndex = (long long *)*PrimaryResourcePointer;
        } while ((long long *)*PrimaryResourcePointer != pSystemThreadFlags);
      }
      plocalDataIndex = (long long *)SystemLocalContextPointer[2];
      while (((SystemLocalContextPointer != pSystemThreadFlags && (plocalDataIndex != (long long *)0x0)) && ((char)plocalDataIndex[4] == '\0'))) {
        ResourceDataOffset = plocalDataIndex[2];
        SystemLocalContextPointer[2] = ResourceDataOffset;
        if (ResourceDataOffset != 0) {
          *(long long **)(ResourceDataOffset + 0x18) = SystemLocalContextPointer;
        }
        SystemLocalContextPointer[1] = SystemLocalContextPointer[1] + plocalDataIndex[1];
        *plocalDataIndex = resourcePoolPointer[0x28005];
        resourcePoolPointer[0x28005] = (long long)plocalDataIndex;
        pSystemThreadFlags = (long long *)resourcePoolPointer[3];
        plocalDataIndex = (long long *)SystemLocalContextPointer[2];
      }
    }
    SystemOperationStatusFlag = FindSystemResourceManagerMapping(SystemResourceManager + 0x10,&PrimaryResourcePointer);
  } while( true );
}




// 函数: void ConfigureSystemResourceWithLock(long long SystemResourceManager,void* *ConfigurationDataPointer)
void ConfigureSystemResourceWithLock(long long SystemResourceManager,void* *ConfigurationDataPointer)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = _Mtx_lock(SystemResourceManager + 0x200010);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  ReleaseSystemResource(ConfigurationDataPointer + 4);
  *ConfigurationDataPointer = *(void* *)(SystemResourceManager + 0x200008);
  *(void* **)(SystemResourceManager + 0x200008) = ConfigurationDataPointer;
  SystemOperationStatus = _Mtx_unlock(SystemResourceManager + 0x200010);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  return;
}




/**
 * @brief 系统资源配置和初始化函数
 * 
 * 该函数负责系统资源的配置、内存分配和初始化工作
 * 根据资源管理器指针和数组大小来分配内存块，并设置相关配置
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @param ArraySize 数组大小
 * @return 配置数据指针
 * 
 *FUN_180068860：ConfigureSystemResourceAllocation
 */
long long *
ConfigureSystemResourceAllocation(long long SystemResourceManager,long long *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag,
             ulong long ArraySize)

{
  long long resourceDataIndex;
  ulong long resourceCreationFlags;
  long long ResourceDataOffset;
  void* resourceAddress;
  
  resourceCreationFlags = ArraySize % (ulong long)*(uint *)(SystemResourceManager + 0x10);
  ResourceDataOffset = AllocateSystemMemoryBlock(SystemResourceManager,*(void* *)(*(long long *)(SystemResourceManager + 8) + resourceCreationFlags * 8),
                              ConfigurationFlag);
  if (ResourceDataOffset == 0) {
    HandleSystemResourceAllocationFailure(SystemResourceManager + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,&ArraySize,*(uint32_t *)(SystemResourceManager + 0x10),
                  *(uint32_t *)(SystemResourceManager + 0x18),1);
    ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x128,*(uint8_t *)(SystemResourceManager + 0x2c));
    InitializeSystemResourceStringTemplate(ResourceDataOffset,ConfigurationFlag);
    *(void* *)(ResourceDataOffset + 0x118) = 0;
    *(void* *)(ResourceDataOffset + 0x120) = 0;
    if ((char)ArraySize != '\0') {
      resourceAddress = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(ulong long)ArraySize._4_4_ * 8 + 8,8,
                            *(uint8_t *)(SystemResourceManager + 0x2c));
        memset(resourceAddress,0,(ulong long)ArraySize._4_4_ * 8);
    }
    *(void* *)(ResourceDataOffset + 0x120) = *(void* *)(*(long long *)(SystemResourceManager + 8) + resourceCreationFlags * 8);
    *(long long *)(*(long long *)(SystemResourceManager + 8) + resourceCreationFlags * 8) = ResourceDataOffset;
    *(long long *)(SystemResourceManager + 0x18) = *(long long *)(SystemResourceManager + 0x18) + 1;
    resourceDataIndex = *(long long *)(SystemResourceManager + 8);
    *ConfigurationDataPointer = ResourceDataOffset;
    ConfigurationDataPointer[1] = resourceDataIndex + resourceCreationFlags * 8;
    *(uint8_t *)(ConfigurationDataPointer + 2) = 1;
  }
  else {
    resourceDataIndex = *(long long *)(SystemResourceManager + 8);
    *ConfigurationDataPointer = ResourceDataOffset;
    ConfigurationDataPointer[1] = resourceDataIndex + resourceCreationFlags * 8;
    *(uint8_t *)(ConfigurationDataPointer + 2) = 0;
  }
  return ConfigurationDataPointer;
}



/**
 * @brief 系统资源指针映射和查找函数
 * 
 * 该函数负责在系统资源指针和配置数据指针之间进行映射和查找操作，
 * 包括资源地址计算、偏移量处理和数据验证。用于系统资源的管理和访问。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针数组
 * @return 找到的资源指针或空指针
 * 
 *FUN_180068a90：FindSystemResourceManagerMapping
 */
void* FindSystemResourceManagerMapping(ulong long* SystemResourceManager,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *SystemHashEntryPointer;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  char operationStatusFlag;
  bool isThreadActive;
  ulong long ThreadContextFlag;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  ulong long SystemOperationFlags;
  ulong long SystemOperationStatus1;
  ulong long SystemSecondaryStatus;
  ulong long SystemOperationStatus3;
  ulong long SystemOperationStatus4;
  
  SystemOperationStatus1 = *SystemResourceManager;
  SystemOperationFlags = 0;
  OperationCode = SystemOperationFlags;
  SystemSecondaryStatus = SystemOperationFlags;
  SystemOperationStatus4 = SystemOperationFlags;
  do {
    ThreadContextFlag = OperationCode;
    if (SystemOperationStatus1 == 0) break;
    ThreadContextFlag = *(long long *)(SystemOperationStatus1 + 0x20) - *(long long *)(SystemOperationStatus1 + 0x28);
    if ((ulong long)(*(long long *)(SystemOperationStatus1 + 0x28) - *(long long *)(SystemOperationStatus1 + 0x20)) <
        0x8000000000000001) {
      ThreadContextFlag = SystemOperationFlags;
    }
    SystemOperationStatus3 = SystemSecondaryStatus;
    if ((ThreadContextFlag != 0) && (SystemOperationStatus4 = SystemOperationStatus4 + 1, ThreadContextFlag = SystemOperationStatus1, SystemOperationStatus3 = ThreadContextFlag, ThreadContextFlag <= SystemSecondaryStatus)) {
      ThreadContextFlag = OperationCode;
      SystemOperationStatus3 = SystemSecondaryStatus;
    }
    PrimaryResourcePointer = (long long *)(SystemOperationStatus1 + 8);
    SystemOperationStatus1 = *PrimaryResourcePointer - 8;
    if (*PrimaryResourcePointer == 0) {
      SystemOperationStatus1 = SystemOperationFlags;
    }
    OperationCode = ThreadContextFlag;
    SystemSecondaryStatus = SystemOperationStatus3;
  } while (SystemOperationStatus4 < 3);
  if (SystemOperationStatus4 != 0) {
    systemStatusFlag = ValidateSystemConfiguration(ThreadContextFlag,ConfigurationDataPointer);
    if (systemStatusFlag != '\0') {
      return 1;
    }
    SystemOperationStatus1 = *SystemResourceManager;
    while (SystemOperationStatus1 != 0) {
      if (SystemOperationStatus1 != ThreadContextFlag) {
        SystemBufferAddress = *(long long *)(SystemOperationStatus1 + 0x38);
        if (*(char *)(SystemOperationStatus1 + 0x48) == '\0') {
          if ((ulong long)((*(long long *)(SystemOperationStatus1 + 0x30) - SystemBufferAddress) - *(long long *)(SystemOperationStatus1 + 0x20)) <
              0x8000000000000001) goto SystemMemoryCheckPoint;
          LOCK();
          PrimaryResourcePointer = (long long *)(SystemOperationStatus1 + 0x30);
          ResourceDataOffset = *PrimaryResourcePointer;
          *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
          UNLOCK();
          if ((ulong long)((ResourceDataOffset - *(long long *)(SystemOperationStatus1 + 0x20)) - SystemBufferAddress) < 0x8000000000000001)
          goto SystemMemoryCheckPointStart;
          LOCK();
          SystemHashEntryPointer = (ulong long *)(SystemOperationStatus1 + 0x28);
          OperationCode = *SystemHashEntryPointer;
          *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
          UNLOCK();
          PrimaryResourcePointer = *(long long **)(SystemOperationStatus1 + 0x60);
          ResourceDataOffset = *(long long *)
                   (PrimaryResourcePointer[3] +
                   (((OperationCode & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5)
                    + PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 8);
          SystemBufferAddress = *(long long *)(ResourceDataOffset + 8);
          *ConfigurationDataPointer = *(void* *)(SystemBufferAddress + (ulong long)((uint)OperationCode & BIT_MASK_32_BIT) * 8);
          LOCK();
          PrimaryResourcePointer = (long long *)(SystemBufferAddress + 0x108);
          SystemBufferAddress = *PrimaryResourcePointer;
          *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
          UNLOCK();
          if (SystemBufferAddress == 0x1f) {
            *(void* *)(ResourceDataOffset + 8) = 0;
            ReleaseSystemResourceHandle(*(void* *)(SystemOperationStatus1 + 0x50));
          }
          isThreadActive = true;
        }
        else {
          if (0x8000000000000000 <
              (ulong long)((*(long long *)(SystemOperationStatus1 + 0x30) - SystemBufferAddress) - *(long long *)(SystemOperationStatus1 + 0x20))) {
            LOCK();
            PrimaryResourcePointer = (long long *)(SystemOperationStatus1 + 0x30);
            ResourceDataOffset = *PrimaryResourcePointer;
            *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
            UNLOCK();
            if (0x8000000000000000 < (ulong long)((ResourceDataOffset - *(long long *)(SystemOperationStatus1 + 0x20)) - SystemBufferAddress)) {
              LOCK();
              SystemHashEntryPointer = (ulong long *)(SystemOperationStatus1 + 0x28);
              OperationCode = *SystemHashEntryPointer;
              *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
              UNLOCK();
              PrimaryResourcePointer = *(long long **)(SystemOperationStatus1 + 0x58);
              SystemSecondaryStatus = (ulong long)((uint)OperationCode & BIT_MASK_32_BIT);
              SystemBufferAddress = *(long long *)
                       (PrimaryResourcePointer[2] + 8 +
                       (((OperationCode & MAX_UNSIGNED_32_BITffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10)
                        >> 5) + PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
              *ConfigurationDataPointer = *(void* *)(SystemBufferAddress + SystemSecondaryStatus * 8);
              *(uint8_t *)((SystemBufferAddress - SystemSecondaryStatus) + 0x12f) = 1;
              isThreadActive = true;
              goto SystemMemoryCheckPointEnd;
            }
SystemMemoryCheckPointStart:
            LOCK();
            *(long long *)(SystemOperationStatus1 + 0x38) = *(long long *)(SystemOperationStatus1 + 0x38) + 1;
            UNLOCK();
          }
SystemMemoryCheckPoint:
          isThreadActive = false;
        }
SystemMemoryCheckPointEnd:
        if (isThreadActive) {
          return 1;
        }
      }
      PrimaryResourcePointer = (long long *)(SystemOperationStatus1 + 8);
      SystemOperationStatus1 = *PrimaryResourcePointer - 8;
      if (*PrimaryResourcePointer == 0) {
        SystemOperationStatus1 = SystemOperationFlags;
      }
    }
  }
  return 0;
}



/**
 * @brief 系统资源分配和锁定管理函数
 * 
 * 该函数负责管理系统资源的分配和锁定操作，包括资源计数、
 * 锁定机制和时间戳处理。用于系统资源的动态分配和同步控制。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的资源指针或错误代码
 * 
 *FUN_180068ce0：AllocateAndLockSystemResource
 */
void* AllocateAndLockSystemResource(long long SystemResourceManager,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *SystemHashEntryPointer;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  long long SystemTimeValue;
  ulong long ResourceHash;
  
  if (*(char *)(SystemResourceManager + 0x48) == '\0') {
    if ((ulong long)
        ((*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x38)) -
        *(long long *)(SystemResourceManager + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x30);
    ResourceDataOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((ResourceDataOffset - *(long long *)(SystemResourceManager + 0x20)) - *(long long *)(SystemResourceManager + 0x38))) {
      LOCK();
      SystemHashEntryPointer = (ulong long *)(SystemResourceManager + 0x28);
      resourceAddress = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x60);
      localSystemPointer = *(long long *)
               (PrimaryResourcePointer[3] +
               (((resourceAddress & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 8);
      ResourceDataOffset = *(long long *)(localSystemPointer + 8);
      *ConfigurationDataPointer = *(void* *)(ResourceDataOffset + (ulong long)((uint)resourceAddress & BIT_MASK_32_BIT) * 8);
      LOCK();
      PrimaryResourcePointer = (long long *)(ResourceDataOffset + 0x108);
      ResourceDataOffset = *PrimaryResourcePointer;
      *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
      UNLOCK();
      if (ResourceDataOffset == 0x1f) {
        *(void* *)(localSystemPointer + 8) = 0;
        ReleaseSystemResourceHandle(*(void* *)(SystemResourceManager + 0x50));
      }
      return 1;
    }
  }
  else {
    if ((ulong long)
        ((*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x38)) -
        *(long long *)(SystemResourceManager + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x30);
    ResourceDataOffset = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((ResourceDataOffset - *(long long *)(SystemResourceManager + 0x20)) - *(long long *)(SystemResourceManager + 0x38))) {
      LOCK();
      SystemHashEntryPointer = (ulong long *)(SystemResourceManager + 0x28);
      resourceAddress = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x58);
      ResourceHash = (ulong long)((uint)resourceAddress & BIT_MASK_32_BIT);
      ResourceDataOffset = *(long long *)
               (PrimaryResourcePointer[2] + 8 +
               (((resourceAddress & MAX_UNSIGNED_32_BITffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10) >> 5) +
                PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
      *ConfigurationDataPointer = *(void* *)(ResourceDataOffset + ResourceHash * 8);
      *(uint8_t *)((ResourceDataOffset - ResourceHash) + 0x12f) = 1;
      return 1;
    }
  }
  LOCK();
  *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + 1;
  UNLOCK();
  return 0;
}




/**
 * @brief 系统资源管理器处理函数
 * 
 * 该函数负责管理系统资源的不同操作，包括资源清理、内存分配和资源转移。
 * 根据不同的AdditionalParameter值执行不同的操作：
 * - 0: 清理系统资源
 * - 1: 分配系统内存并复制资源数据
 * - 2: 转移系统资源所有权
 * - 3: 使用默认系统句柄
 * - 4: 使用指定系统句柄
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数，指定操作类型
 * @param ConfigurationFlag 配置标志
 * @return 操作结果或系统句柄
 * 
 *FUN_180068ec0：ProcessSystemResourceManager
 */
long long ProcessSystemResourceManager(long long* SystemResourceManager,long long *ConfigurationDataPointer,int AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  code *pcharFlag;
  
  if (AdditionalParameter == 3) {
    SystemThreadHandle = 0x180bfd400;
  }
  else if (AdditionalParameter == 4) {
    SystemThreadHandle = *SystemResourceManager;
  }
  else {
    if (AdditionalParameter == 0) {
      SystemThreadHandle = *SystemResourceManager;
      if (SystemThreadHandle != 0) {
        if (*(code **)(SystemThreadHandle + 0x10) != (code *)0x0) {
          (**(code **)(SystemThreadHandle + 0x10))(SystemThreadHandle,0,0,ConfigurationFlag,InvalidHandleValue);
        }
          SystemCleanupFunction(SystemThreadHandle);
      }
    }
    else {
      if (AdditionalParameter == 1) {
        resourceDataIndex = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag);
        SystemThreadHandle = *ConfigurationDataPointer;
        *(void* *)(resourceDataIndex + 0x10) = 0;
        *(code **)(resourceDataIndex + 0x18) = _guard_check_icall;
        if (resourceDataIndex != SystemThreadHandle) {
          pcharFlag = *(code **)(SystemThreadHandle + 0x10);
          if (pcharFlag != (code *)0x0) {
            (*pcharFlag)(resourceDataIndex,SystemThreadHandle,1);
            pcharFlag = *(code **)(SystemThreadHandle + 0x10);
          }
          *(code **)(resourceDataIndex + 0x10) = pcharFlag;
          *(void* *)(resourceDataIndex + 0x18) = *(void* *)(SystemThreadHandle + 0x18);
        }
        *SystemResourceManager = resourceDataIndex;
        return 0;
      }
      if (AdditionalParameter == 2) {
        *SystemResourceManager = *ConfigurationDataPointer;
        *ConfigurationDataPointer = 0;
        return 0;
      }
    }
    SystemThreadHandle = 0;
  }
  return SystemThreadHandle;
}



/**
 * @brief 初始化系统资源字符串模板
 * 
 * 该函数负责初始化系统资源的字符串模板，设置内存分配器引用和字符串数据。
 * 用于系统资源字符串管理的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 初始化后的系统资源指针
 * 
 *FUN_180068ff0：InitializeSystemResourceStringTemplate
 */
void* *
InitializeSystemResourceStringTemplate(void* *SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorTemplate;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = SystemResourceManager + 3;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *(uint8_t *)(SystemResourceManager + 3) = 0;
  *(uint32_t *)(SystemResourceManager + 2) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemDataPointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemDataPointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(SystemResourceManager[1],0x100,SystemDataPointer,ConfigurationFlag,InvalidHandleValue);
  return SystemResourceManager;
}



/**
 * @brief 初始化系统内存分配器模板
 * 
 * 该函数负责初始化系统内存分配器模板，设置内存分配器引用和相关参数。
 * 用于系统内存管理的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 初始化后的系统资源指针
 * 
 *FUN_180069070：InitializeSystemMemoryAllocatorTemplate
 */
void* * InitializeSystemMemoryAllocatorTemplate(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorTemplate;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = SystemResourceManager + 3;
  *(uint32_t *)(SystemResourceManager + 2) = 0;
  *(uint8_t *)(SystemResourceManager + 3) = 0;
  SystemResourceManager[0x2b] = 0;
  SystemResourceManager[0x2c] = _guard_check_icall;
  SystemResourceManager[0x2f] = 0;
  SystemResourceManager[0x30] = _guard_check_icall;
  SystemResourceManager[0x27] = 0xffffffffffffffff;
  SystemResourceManager[0x24] = 0xffffffffffffffff;
  SystemResourceManager[0x23] = 0xffffffffffffffff;
  SystemResourceManager[0x25] = 0;
  SystemResourceManager[0x26] = 0;
  *(uint8_t *)(SystemResourceManager + 0x28) = 0;
  return SystemResourceManager;
}




// 函数: void ConfigureSystemResourceCallbacks(long long SystemResourceManager,long long ConfigurationDataPointer)
void ConfigureSystemResourceCallbacks(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  code *systemFunctionPointer;
  
  systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x10);
  if (systemFunctionPointer != (code *)0x0) {
    (*systemFunctionPointer)(SystemResourceManager,ConfigurationDataPointer,2);
    systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x10);
  }
  *(code **)(SystemResourceManager + 0x10) = systemFunctionPointer;
  *(void* *)(SystemResourceManager + 0x18) = *(void* *)(ConfigurationDataPointer + 0x18);
  *(code **)(ConfigurationDataPointer + 0x18) = _guard_check_icall;
  *(void* *)(ConfigurationDataPointer + 0x10) = 0;
  return;
}



/**
 * @brief 释放系统资源内存
 * 
 * 该函数负责释放系统资源内存，根据配置数据指针的标志决定是否执行释放操作。
 * 用于系统内存管理的清理工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 *FUN_180069190：ReleaseSystemResourceMemory
 */
long long ReleaseSystemResourceMemory(long long SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *(void* **)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x128,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}



/**
 * @brief 释放系统资源指针内存
 * 
 * 该函数负责释放系统资源指针的内存，根据配置数据指针的标志决定是否执行释放操作。
 * 用于系统资源指针管理的清理工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源指针
 * 
 *FUN_1800691e0：ReleaseSystemResourceManagerMemory
 */
void* *
ReleaseSystemResourceManagerMemory(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x118,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}




// 函数: void CopySystemDataToBuffer(long long SystemResourceManager,void* ConfigurationDataPointer,int AdditionalParameter)
/**
 * @brief 系统数据拷贝函数
 * 
 * 该函数负责将配置数据拷贝到系统资源中，并重置目标缓冲区
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（数据大小）
 * 
 *FUN_180069220：CopySystemDataToBuffer
 */
void CopySystemDataToBuffer(long long SystemResourceManager,void* ConfigurationDataPointer,int AdditionalParameter)

{
  if (AdditionalParameter + 1 < 0x100) {
      memcpy(*(uint8_t **)(SystemResourceManager + 8),ConfigurationDataPointer,(long long)AdditionalParameter);
  }
  **(uint8_t **)(SystemResourceManager + 8) = 0;
  *(uint32_t *)(SystemResourceManager + 0x10) = 0;
  return;
}




// 函数: void SystemMemoryCopy(void)
/**
 * @brief 系统内存拷贝函数
 * 
 * 该函数负责系统内存的拷贝操作
 * 
 *FUN_180069241：SystemMemoryCopy
 */
void SystemMemoryCopy(void)

{
    memcpy();
}




// 函数: void ResetSystemResourceData(uint8_t *SystemResourceManager)
/**
 * @brief 重置系统资源数据
 * 
 * 该函数负责重置系统资源数据，清零相关字段
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_180069266：ResetSystemResourceData
 */
void ResetSystemResourceData(uint8_t *SystemResourceManager)

{
  *SystemResourceManager = 0;
  *(uint32_t *)(SystemResourceManager + 0x10) = 0;
  return;
}





// 函数: void ConfigureSystemResourceAndProcessData(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 系统资源配置和数据处理函数
 * 
 * 该函数负责系统资源的配置和数据处理操作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 *FUN_180069280：ConfigureSystemResourceAndProcessData
 */
void ConfigureSystemResourceAndProcessData(long long SystemResourceManager,long long ConfigurationDataPointer,long long AdditionalParameter)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long ResourceDataOffset;
  uint8_t aSystemStackFlag [32];
  void* CalculationFlags178;
  void* *SystemMemoryAllocatorPointer;
  uint8_t *SystemResourcePointer160;
  uint32_t SystemConfigurationId;
  uint8_t aSystemResourceSize [264];
  ulong long SystemEncryptionKey;
  
  CalculationFlags178 = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)aSystemStackFlag;
  SystemMemoryAllocatorPointer = &SystemMemoryAllocatorTemplate;
  SystemResourcePointer160 = aSystemResourceSize;
  SystemConfigurationId = 0;
  aSystemResourceSize[0] = 0;
  resourceDataIndex = strstr(*(void* *)(SystemResourceManager + 8));
  if (resourceDataIndex != 0) {
    SystemThreadHandle = -1;
    ResourceDataOffset = -1;
    do {
      ResourceDataOffset = ResourceDataOffset + 1;
    } while (*(char *)(ConfigurationDataPointer + ResourceDataOffset) != '\0');
    do {
      SystemThreadHandle = SystemThreadHandle + 1;
    } while (*(char *)(SystemThreadHandle + AdditionalParameter) != '\0');
      memcpy(SystemResourcePointer160,*(long long *)(SystemResourceManager + 8),resourceDataIndex - *(long long *)(SystemResourceManager + 8));
  }
  SystemMemoryAllocatorPointer = &SystemMemoryAllocatorReference;
    ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)aSystemStackFlag);
}




/**
 * @brief 复制字符串到系统缓冲区
 * 
 * 该函数负责将源字符串复制到目标系统缓冲区中，处理字符串长度检查
 * 和内存分配。当字符串长度超过限制时，会使用系统内存模板进行处理。
 * 
 * @param SystemResourceManager 目标系统资源指针
 * @param ConfigurationDataPointer 源字符串数据指针
 * @note 这是字符串处理和内存管理的重要组成部分
 */
void CopyStringToSystemBuffer(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long stringLength;
  
  if (ConfigurationDataPointer == 0) {
    *(uint32_t *)(SystemResourceManager + 0x10) = 0;
    **(uint8_t **)(SystemResourceManager + 8) = 0;
    return;
  }
  stringLength = -1;
  do {
    stringLength = stringLength + 1;
  } while (*(char *)(ConfigurationDataPointer + stringLength) != '\0');
  if ((int)stringLength < 0x100) {
    *(int *)(SystemResourceManager + 0x10) = (int)stringLength;
    strcpy_s(*(void* *)(SystemResourceManager + 8),0x100,ConfigurationDataPointer);
    return;
  }
  AllocateSystemMemory(&SystemMemoryTemplateG,0x100,ConfigurationDataPointer);
  *(uint32_t *)(SystemResourceManager + 0x10) = 0;
  **(uint8_t **)(SystemResourceManager + 8) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统内存分配器的引用，设置内存分配器的指针。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 返回系统资源指针
 * @note 这是内存管理系统的初始化函数
 */
long long InitializeSystemMemoryAllocatorReference(long long SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *(void* **)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x130,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}




/**
 * @brief 执行系统资源回调函数
 * 
 * 该函数负责执行系统资源的回调函数，包括配置回调和其他回调函数。
 * 在执行完回调函数后，会将系统资源指针设置为内存分配器引用。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @note 这是系统资源回调管理的重要组成部分
 */
void ExecuteSystemResourceCallbacks(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if ((code *)SystemResourceManager[0x2f] != (code *)0x0) {
    (*(code *)SystemResourceManager[0x2f])(SystemResourceManager + 0x2d,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  if ((code *)SystemResourceManager[0x2b] != (code *)0x0) {
    (*(code *)SystemResourceManager[0x2b])(SystemResourceManager + 0x29,0,0);
  }
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 设置系统内存分配器引用
 * 
 * 该函数负责设置系统内存分配器的引用，将内存分配器指针
 * 存储到系统资源结构的指定位置。
 * 
 * @param SystemResourceManager 系统资源指针
 * @note 这是内存管理系统的初始化函数
 */
void SetSystemMemoryAllocatorReference(long long SystemResourceManager)

{
  *(void* **)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  return;
}



/**
 * @brief 初始化系统内存模板
 * 
 * 该函数负责初始化系统内存模板，设置多个内存模板的引用。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 返回系统资源指针数组
 * @note 这是内存管理系统的初始化函数
 */
void* *
InitializeSystemMemoryTemplates(void* *SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  *SystemResourceManager = &SystemMemoryTemplateC;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x30,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  }
  return SystemResourceManager;
}



/**
 * @brief 初始化系统数据引用
 * 
 * 该函数负责初始化系统数据引用，设置系统数据模板的引用。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param SystemResourceManager 系统资源指针数组
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @return 返回系统资源指针数组
 * @note 这是数据管理系统的初始化函数
 */
void* * InitializeSystemDataReference(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemDataTemplateUnknown;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x58);
  }
  return SystemResourceManager;
}



/**
 * @brief 初始化系统资源数据
 * 
 * 该函数负责初始化系统资源数据，调用系统资源初始化函数。
 * 当配置标志指示需要释放内存时，会执行相应的内存释放操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针（包含释放标志）
 * @return 返回系统资源指针
 * @note 这是系统资源初始化的重要组成部分
 */
void* InitializeSystemResourceData(void* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  InitializeSystemResourceAllocator();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x68);
  }
  return SystemResourceManager;
}




/**
 * @brief 系统资源状态更新函数
 * 
 * 该函数负责更新系统资源的状态信息，包括状态标志、数据指针和资源计数。
 * 用于系统资源的动态状态管理和监控。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_1800697a0：UpdateSystemResourceStatus
 */
void UpdateSystemResourceStatus(void* *SystemResourceManager)

{
  int* SystemIntegerPointer;
  int systemResult;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  long long *SystemLocalContextPointer;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  long long resourceCounter;
  ulong long SystemOperationFlags;
  bool isByteValid1;
  
  *SystemResourceManager = &SystemThreadLocalStoragePrimary;
  resourceAllocationContext = SystemResourceManager[4];
  resourceCounter = 0;
  resourceAddress = SystemResourceManager[5];
  for (SystemOperationFlags = resourceAddress; SystemOperationFlags != resourceAllocationContext; SystemOperationFlags = SystemOperationFlags + 1) {
    if ((SystemOperationFlags & BIT_MASK_32_BIT) == 0) {
      if (resourceCounter != 0) {
        SystemThreadFlags = SystemResourceManager[10];
        LOCK();
        SystemIntegerPointer = (int *)(resourceCounter + 0x130);
        systemResult = *SystemIntegerPointer;
        *SystemIntegerPointer = *SystemIntegerPointer + -0x80000000;
        UNLOCK();
        if (systemResult == 0) {
          SystemMemoryAddress = *(long long *)(SystemThreadFlags + 0x28);
          do {
            *(long long *)(resourceCounter + 0x138) = SystemMemoryAddress;
            *(uint32_t *)(resourceCounter + 0x130) = 1;
            SystemLocalContextPointer = (long long *)(SystemThreadFlags + 0x28);
            LOCK();
            localDataIndex = *SystemLocalContextPointer;
            isByteValid1 = SystemMemoryAddress == localDataIndex;
            if (isByteValid1) {
              *SystemLocalContextPointer = resourceCounter;
              localDataIndex = SystemMemoryAddress;
            }
            UNLOCK();
            if (isByteValid1) break;
            LOCK();
            SystemIntegerPointer = (int *)(resourceCounter + 0x130);
            systemResult = *SystemIntegerPointer;
            *SystemIntegerPointer = *SystemIntegerPointer + 0x7fffffff;
            UNLOCK();
            SystemMemoryAddress = localDataIndex;
          } while (systemResult == 1);
        }
      }
SystemResourceLoopCheck:
      SystemLocalContextPointer = (long long *)SystemResourceManager[0xc];
      resourceCounter = *(long long *)
               (*(long long *)
                 (SystemLocalContextPointer[3] +
                 (SystemLocalContextPointer[1] +
                  ((SystemOperationFlags & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(SystemLocalContextPointer[3] + SystemLocalContextPointer[1] * 8) >> 5)
                 & *SystemLocalContextPointer - 1U) * 8) + 8);
    }
    else if (resourceCounter == 0) goto SystemResourceLoopCheck;
  }
  resourceCounter = SystemResourceManager[8];
  if ((resourceCounter != 0) && ((resourceAddress != resourceAllocationContext || ((resourceAllocationContext & BIT_MASK_32_BIT) != 0)))) {
    SystemThreadFlags = SystemResourceManager[10];
    LOCK();
    SystemIntegerPointer = (int *)(resourceCounter + 0x130);
    systemResult = *SystemIntegerPointer;
    *SystemIntegerPointer = *SystemIntegerPointer + -0x80000000;
    UNLOCK();
    if (systemResult == 0) {
      SystemMemoryAddress = *(long long *)(SystemThreadFlags + 0x28);
      do {
        *(long long *)(resourceCounter + 0x138) = SystemMemoryAddress;
        *(uint32_t *)(resourceCounter + 0x130) = 1;
        SystemLocalContextPointer = (long long *)(SystemThreadFlags + 0x28);
        LOCK();
        localDataIndex = *SystemLocalContextPointer;
        isByteValid1 = SystemMemoryAddress == localDataIndex;
        if (isByteValid1) {
          *SystemLocalContextPointer = resourceCounter;
          localDataIndex = SystemMemoryAddress;
        }
        UNLOCK();
        if (isByteValid1) break;
        LOCK();
        SystemIntegerPointer = (int *)(resourceCounter + 0x130);
        systemResult = *SystemIntegerPointer;
        *SystemIntegerPointer = *SystemIntegerPointer + 0x7fffffff;
        UNLOCK();
        SystemMemoryAddress = localDataIndex;
      } while (systemResult == 1);
    }
  }
  if (SystemResourceManager[0xc] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemThreadLocalStorageSecondary;
  return;
}




/**
 * @brief 系统线程本地存储分配函数
 * 
 * 该函数负责分配和管理线程本地存储资源，包括资源查找、创建和初始化。
 * 使用哈希表来管理资源，支持并发访问和线程安全。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @return 分配的资源指针，失败时返回NULL
 * 
 *AllocateThreadLocalStorage：AllocateThreadLocalStorage
 */
void* * AllocateThreadLocalStorage(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  uint *SystemHashEntryPointer;
  ulong long *SystemHashNodeData;
  ulong long threadIdHash;
  uint currentThreadId;
  ulong long ResourceHash;
  ulong long *hashTableNode;
  void** HashNextNode;
  long long resourceCounter;
  long long SystemAllocationFlags;
  void* *ThreadLocalStorage;
  ulong long SystemSecondaryStatus;
  ulong long SystemOperationStatus3;
  uint SystemOperationStatus4;
  void* *ThreadLocalStorageEntry;
  bool isEntryAvailable;
  bool isSlotEmpty;
  
  currentThreadId = GetCurrentThreadId();
  SystemOperationStatus4 = (currentThreadId >> 0x10 ^ currentThreadId) * -0x7a143595;
  SystemOperationStatus4 = (SystemOperationStatus4 >> QUADRANT_SHIFT_BITS ^ SystemOperationStatus4) * -0x3d4d51cb;
  SystemOperationStatus3 = (ulong long)(SystemOperationStatus4 >> 0x10 ^ SystemOperationStatus4);
  hashTableNode = (ulong long *)SystemResourceManager[6];
  for (SystemHashNodeData = hashTableNode; ResourceHash = SystemOperationStatus3, SystemHashNodeData != (ulong long *)0x0; SystemHashNodeData = (ulong long *)SystemHashNodeData[2])
  {
    while( true ) {
      ResourceHash = ResourceHash & *SystemHashNodeData - 1;
      SystemOperationStatus4 = *(uint *)(ResourceHash * 0x10 + SystemHashNodeData[1]);
      if (SystemOperationStatus4 == currentThreadId) {
        ThreadLocalStorageEntry = *(void* **)(SystemHashNodeData[1] + 8 + ResourceHash * 0x10);
        if (SystemHashNodeData == hashTableNode) {
          return ThreadLocalStorageEntry;
        }
        do {
          SystemOperationStatus3 = SystemOperationStatus3 & *hashTableNode - 1;
          if (*(int *)(hashTableNode[1] + SystemOperationStatus3 * 0x10) == 0) {
            SystemHashEntryPointer = (uint *)(hashTableNode[1] + SystemOperationStatus3 * 0x10);
            LOCK();
            isSlotEmpty = *SystemHashEntryPointer == 0;
            if (isSlotEmpty) {
              *SystemHashEntryPointer = currentThreadId;
            }
            UNLOCK();
            if (isSlotEmpty) {
              *(void* **)(hashTableNode[1] + 8 + SystemOperationStatus3 * 0x10) = ThreadLocalStorageEntry;
              return ThreadLocalStorageEntry;
            }
          }
          SystemOperationStatus3 = SystemOperationStatus3 + 1;
        } while( true );
      }
      if (SystemOperationStatus4 == 0) break;
      ResourceHash = ResourceHash + 1;
    }
  }
  LOCK();
  PrimaryResourcePointer = SystemResourceManager + 7;
  resourceCounter = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  ResourceHash = resourceCounter + 1;
  ThreadLocalStorageEntry = (void* *)0x0;
  while( true ) {
    if (*hashTableNode >> 1 <= ResourceHash) {
      LOCK();
      SystemHashEntryPointer = (uint *)(SystemResourceManager + 0x4b);
      SystemOperationStatus4 = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer | 1;
      UNLOCK();
      if ((SystemOperationStatus4 & 1) == 0) {
        SystemHashNodeData = (ulong long *)SystemResourceManager[6];
        hashTableNode = SystemHashNodeData;
        SystemSecondaryStatus = *SystemHashNodeData;
        if (*SystemHashNodeData >> 1 <= ResourceHash) {
          do {
            resourceAddress = SystemSecondaryStatus;
            SystemSecondaryStatus = resourceAddress * 2;
          } while ((resourceAddress & SINE_LOOKUP_TABLE_SIZEffffffffffff) <= ResourceHash);
          hashTableNode = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAddress * 0x20 + 0x1f,10);
          if (hashTableNode == (ulong long *)0x0) {
            LOCK();
            SystemResourceManager[7] = SystemResourceManager[7] + -1;
            UNLOCK();
            *(uint32_t *)(SystemResourceManager + 0x4b) = 0;
            return (void* *)0x0;
          }
          *hashTableNode = SystemSecondaryStatus;
          hashTableNode[1] = (ulong long)(-(int)(hashTableNode + 3) & 7) + (long long)(hashTableNode + 3);
          ThreadLocalStorage = ThreadLocalStorageEntry;
          for (; SystemSecondaryStatus != 0; SystemSecondaryStatus = SystemSecondaryStatus - 1) {
            *(void* *)((long long)ThreadLocalStorage + hashTableNode[1] + 8) = 0;
            *(uint32_t *)((long long)ThreadLocalStorage + hashTableNode[1]) = 0;
            ThreadLocalStorage = ThreadLocalStorage + 2;
          }
          hashTableNode[2] = (ulong long)SystemHashNodeData;
          SystemResourceManager[6] = (long long)hashTableNode;
        }
        *(uint32_t *)(SystemResourceManager + 0x4b) = 0;
      }
    }
    if (ResourceHash < (*hashTableNode >> 2) + (*hashTableNode >> 1)) break;
    hashTableNode = (ulong long *)SystemResourceManager[6];
  }
  ThreadLocalStorage = (void* *)*SystemResourceManager;
  while (ThreadLocalStorage != (void* *)0x0) {
    if ((*(char *)(ThreadLocalStorage + 2) != '\0') && (*(char *)(ThreadLocalStorage + 9) == '\0')) {
      isSlotEmpty = true;
      LOCK();
      isEntryAvailable = *(char *)(ThreadLocalStorage + 2) == '\x01';
      if (isEntryAvailable) {
        *(char *)(ThreadLocalStorage + 2) = '\0';
      }
      UNLOCK();
      if (isEntryAvailable) goto SystemEntryCheckPoint;
    }
    PrimaryResourcePointer = ThreadLocalStorage + 1;
    ThreadLocalStorage = (void* *)(*PrimaryResourcePointer + -8);
    if (*PrimaryResourcePointer == 0) {
      ThreadLocalStorage = ThreadLocalStorageEntry;
    }
  }
  isSlotEmpty = false;
  SystemThreadStorage = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,10);
  ThreadLocalStorage = ThreadLocalStorageEntry;
  if (SystemThreadStorage != (void* *)0x0) {
    SystemThreadStorage[1] = 0;
    *(uint8_t *)(SystemThreadStorage + 2) = 0;
    SystemThreadStorage[3] = 0;
    *SystemThreadStorage = &SystemThreadLocalStorageSecondary;
    SystemThreadStorage[4] = 0;
    SystemThreadStorage[5] = 0;
    SystemThreadStorage[6] = 0;
    SystemThreadStorage[7] = 0;
    SystemThreadStorage[8] = 0;
    *(uint8_t *)(SystemThreadStorage + 9) = 0;
    SystemThreadStorage[10] = SystemResourceManager;
    *SystemThreadStorage = &SystemThreadLocalStoragePrimary;
    SystemThreadStorage[0xb] = 0x20;
    SystemThreadStorage[0xc] = 0;
    ExpandSystemResourceAllocator(SystemThreadStorage);
    LOCK();
    *(int *)(SystemResourceManager + 1) = (int)SystemResourceManager[1] + 1;
    UNLOCK();
    resourceCounter = *SystemResourceManager;
    do {
      ThreadLocalStorage = (void* *)(resourceCounter + 8);
      if (resourceCounter == 0) {
        ThreadLocalStorage = ThreadLocalStorageEntry;
      }
      SystemThreadStorage[1] = ThreadLocalStorage;
      LOCK();
      SystemAllocationFlags = *SystemResourceManager;
      isEntryAvailable = resourceCounter == SystemAllocationFlags;
      if (isEntryAvailable) {
        *SystemResourceManager = (long long)SystemThreadStorage;
        SystemAllocationFlags = resourceCounter;
      }
      UNLOCK();
      resourceCounter = SystemAllocationFlags;
      ThreadLocalStorage = SystemThreadStorage;
    } while (!isEntryAvailable);
  }
SystemEntryCheckPoint:
  if (ThreadLocalStorage == (void* *)0x0) {
    LOCK();
    SystemResourceManager[7] = SystemResourceManager[7] + -1;
    UNLOCK();
    return (void* *)0x0;
  }
  if (isSlotEmpty) {
    LOCK();
    SystemResourceManager[7] = SystemResourceManager[7] + -1;
    UNLOCK();
  }
  do {
    SystemOperationStatus3 = SystemOperationStatus3 & *hashTableNode - 1;
    if (*(int *)(hashTableNode[1] + SystemOperationStatus3 * 0x10) == 0) {
      SystemHashEntryPointer = (uint *)(hashTableNode[1] + SystemOperationStatus3 * 0x10);
      LOCK();
      isSlotEmpty = *SystemHashEntryPointer == 0;
      if (isSlotEmpty) {
        *SystemHashEntryPointer = currentThreadId;
      }
      UNLOCK();
      if (isSlotEmpty) {
        *(void* **)(hashTableNode[1] + 8 + SystemOperationStatus3 * 0x10) = ThreadLocalStorage;
        return ThreadLocalStorage;
      }
    }
    SystemOperationStatus3 = SystemOperationStatus3 + 1;
  } while( true );
}



/**
 * @brief 系统资源配置分配函数
 * 
 * 该函数负责配置系统资源分配，管理内存资源分配策略
 * 用于系统资源的动态分配和管理
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配结果状态码
 * 
 *FUN_180069cc0：AllocateSystemResource
 */
ulong long AllocateSystemResource(void* SystemResourceManager,void* *ConfigurationDataPointer)

{
  ulong long SystemOperationStatus;
  long long *resourcePoolPointer;
  void* resourceAllocationContext;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  ulong long *resourceEntryPointer;
  
  SystemBufferAddress = AllocateThreadLocalStorage();
  if (SystemBufferAddress == 0) {
    return 0;
  }
  SystemOperationStatus = *(ulong long *)(SystemBufferAddress + 0x20);
  if ((SystemOperationStatus & BIT_MASK_32_BIT) == 0) {
    currentThreadId = (*(long long *)(SystemBufferAddress + 0x28) - SystemOperationStatus) - 0x20;
    if ((0x8000000000000000 < currentThreadId) &&
       (resourcePoolPointer = *(long long **)(SystemBufferAddress + 0x60), resourcePoolPointer != (long long *)0x0)) {
      currentThreadId = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
      resourceEntryPointer = *(ulong long **)(resourcePoolPointer[3] + currentThreadId * 8);
      if ((*resourceEntryPointer == 1) || (resourceEntryPointer[1] == 0)) {
        *resourceEntryPointer = SystemOperationStatus;
        resourcePoolPointer[1] = currentThreadId;
      }
      else {
        currentThreadId = GetSystemResourceStatus(SystemBufferAddress);
        if ((char)currentThreadId == '\0') goto ThreadIdCheckPoint;
        resourcePoolPointer = *(long long **)(SystemBufferAddress + 0x60);
        currentThreadId = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
        resourceEntryPointer = *(ulong long **)(resourcePoolPointer[3] + currentThreadId * 8);
        *resourceEntryPointer = SystemOperationStatus;
        resourcePoolPointer[1] = currentThreadId;
      }
      currentThreadId = GetResourceOffsetPointer(*(void* *)(SystemBufferAddress + 0x50));
      if (currentThreadId != 0) {
        *(void* *)(currentThreadId + 0x108) = 0;
        resourceEntryPointer[1] = currentThreadId;
        *(ulong long *)(SystemBufferAddress + 0x40) = currentThreadId;
        goto ThreadIdCheckPointEnd;
      }
      resourcePoolPointer = *(long long **)(SystemBufferAddress + 0x60);
      currentThreadId = resourcePoolPointer[1] - 1;
      resourcePoolPointer[1] = *resourcePoolPointer - 1U & currentThreadId;
      resourceEntryPointer[1] = 0;
    }
ThreadIdCheckPoint:
    currentThreadId = currentThreadId & MAX_UNSIGNED_32_BITffffff00;
  }
  else {
ThreadIdCheckPointEnd:
    resourceAllocationContext = *ConfigurationDataPointer;
    *(void* *)(*(long long *)(SystemBufferAddress + 0x40) + (ulong long)((uint)SystemOperationStatus & BIT_MASK_32_BIT) * 8) = resourceAllocationContext;
    *(ulong long *)(SystemBufferAddress + 0x20) = SystemOperationStatus + 1;
    currentThreadId = CONCAT71((int7)((ulong long)resourceAllocationContext >> 8),1);
  }
  return currentThreadId;
}



/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，设置内存模板和配置参数
 * 用于系统资源的前期准备工作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 初始化后的系统资源指针
 * 
 *FUN_180069e10：InitializeSystemResource
 */
void* *
InitializeSystemResource(void* *SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  
  *SystemResourceManager = &SystemMemoryTemplateA;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *SystemResourceManager = &SystemMemoryTemplateC;
  LOCK();
  *(uint8_t *)(SystemResourceManager + 2) = 0;
  UNLOCK();
  SystemResourceManager[3] = 0xffffffffffffffff;
  *SystemResourceManager = &SystemMemoryPoolTemplate;
  SystemResourceManager[6] = 0;
  SystemResourceManager[7] = _guard_check_icall;
  if (SystemResourceManager + 4 != ConfigurationDataPointer) {
    systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(SystemResourceManager + 4,ConfigurationDataPointer,1,ConfigurationFlag,InvalidHandleValue);
      systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    }
    SystemResourceManager[6] = systemFunctionPointer;
    SystemResourceManager[7] = ConfigurationDataPointer[3];
  }
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  return SystemResourceManager;
}



/**
 * @brief 系统对象创建函数
 * 
 * 该函数负责创建系统对象，设置对象参数和属性
 * 用于系统对象的创建和初始化
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 创建后的配置数据指针
 * 
 *FUN_180069f00：CreateSystemObject
 */
void*
CreateSystemObject(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  uint32_t resourceCreationFlags;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  resourceCreationFlags = 0;
  SystemOperationStatus = GetSystemStatusFlags();
  CreateSystemObject(ConfigurationDataPointer,SystemOperationStatus,AdditionalParameter,ConfigurationFlag,resourceCreationFlags,resourceAllocationContext);
  return ConfigurationDataPointer;
}



// Function: void** InitializeSystemResourcePointerArray(void* SystemResourceManager,void** ConfigurationDataPointer)
/**
 * @brief 初始化系统资源指针数组
 * 
 * 该函数负责初始化系统资源指针数组，将所有指针设置为初始状态。
 * 它会清空指针数组的所有元素，并设置初始标志值。
 * 
 * @param SystemResourceManager 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 配置数据指针数组
 * @return void** 返回初始化后的配置数据指针数组
 * 
 *FUN_180069f60：InitializeSystemResourcePointerArray
 */
void** InitializeSystemResourcePointerArray(void* SystemResourceManager,void** ConfigurationDataPointer)

{
  *ConfigurationDataPointer = 0;
  ConfigurationDataPointer[1] = 0;
  ConfigurationDataPointer[2] = 0;
  *(uint32_t *)(ConfigurationDataPointer + 3) = 3;
  return ConfigurationDataPointer;
}



// Function: void** ResetSystemResourcePointerArray(void* SystemResourceManager,void** ConfigurationDataPointer)
/**
 * @brief 重置系统资源指针数组
 * 
 * 该函数负责重置系统资源指针数组，将第一个指针设置为空值。
 * 这是一个简单的重置操作，确保资源指针数组处于干净状态。
 * 
 * @param SystemResourceManager 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 配置数据指针数组
 * @return void** 返回重置后的配置数据指针数组
 * 
 *FUN_180069fb0：ResetSystemResourcePointerArray
 */
void** ResetSystemResourcePointerArray(void* SystemResourceManager,void** ConfigurationDataPointer)

{
  *ConfigurationDataPointer = 0;
  return ConfigurationDataPointer;
}



/**
 * @brief 释放系统资源处理器
 * 
 * 该函数负责释放系统资源处理器，根据配置数据决定是否释放资源。
 * 主要用于系统资源的清理和释放操作。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 释放后的资源管理器指针
 * 
 *FUN_180069fe0：ReleaseSystemResourceHandler
 */
void* ReleaseSystemResourceHandler(void* SystemResourceManager,ulong long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  InitializeSystemResourceHandler();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x260,AdditionalParameter,ConfigurationFlag,SystemOperationStatus);
  }
  return SystemResourceManager;
}




/**
 * @brief 系统资源管理器指针验证函数
 * 
 * 该函数验证资源管理器指针的有效性，检查其是否为特定的保留值。
 * 主要用于系统初始化时的参数验证。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @return 返回验证结果，有效返回1，无效返回0
 * 
 *FUN_18006a050：ValidateSystemResourceManager
 */
void* ValidateSystemResourceManager(int SystemResourceManager)

{
  if ((SystemResourceManager != -0x3fffff03) && (SystemResourceManager != -0x3ffffffb)) {
    return 0;
  }
  (**(code **)(*(long long *)*SystemMemoryBlockStorage + 0x68))();
  return 1;
}



/**
 * @brief 系统资源管理器指针初始化函数
 * 
 * 该函数初始化资源管理器指针，设置系统线程模板和全局数据引用。
 * 主要用于系统资源的初始化和配置。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 返回初始化后的资源管理器指针
 * 
 *FUN_18006a090：InitializeSystemResourceManager
 */
void* * InitializeSystemResourceManager(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemThreadTemplate;
  SystemResourceManager[0x18] = &SystemGlobalDataReference;
  if (SystemResourceManager[0x19] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x19] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1b) = 0;
  SystemResourceManager[0x18] = &SystemMemoryAllocatorReference;
  ReleaseSystemResources(SystemResourceManager);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xe8);
  }
  return SystemResourceManager;
}





/**
 * @brief 系统资源初始化函数
 * 
 * 该函数负责初始化系统资源，包括内存分配、系统表初始化、
 * 状态标志设置和异常处理配置。这是系统启动过程的核心初始化函数。
 * 
 * @param SystemResourceManager 系统资源指针，用于访问系统资源数据
 * 
 *FUN_18006a130：InitializeSystemResources
 */
void InitializeSystemResources(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  char SystemStatusFlag;
  void* MemoryAllocationResult;
  void* *SystemTablePointer;
  void* *StringTemplatePointer;
  uint8_t SystemConfigurationBuffer [40];
  long long *ResourceDataPointer;
  int SystemLogLevel;
  char GraphicsStatusFlag;
  void* ErrorModeValue;
  
  ErrorModeValue = 0xfffffffffffffffe;
  SetErrorMode(1);
  SystemStatusFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if (SystemStatusFlag == '\0') {
    SetUnhandledExceptionFilter(&SystemExceptionHandler);
  }
  MemoryAllocationResult = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x170,8,3);
  SystemInitializationFlag = InitializeSystemResourceManagerWithMutex(MemoryAllocationResult);
  InitializeSystemConfigurationBuffer(SystemConfigurationBuffer);
  MemoryAllocationResult = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,1000,8,3);
  SystemGlobalStatusFlags = GetSystemStatusFlags(MemoryAllocationResult);
  InitializeSystemTables();
  ProcessSystemResourceAllocation();
  if ((*(char *)(SystemDataManagerPointer + 0x20) == '\0') && (*(char *)(SystemDataManagerPointer + 0x21) == '\0')) {
    MemoryAllocationResult = SystemLevelMemoryAllocation(0x428);
    ResourceDataPointer = (long long *)SystemResourceDataInitialization(MemoryAllocationResult);
  }
  else {
    ResourceDataPointer = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,3);
    *ResourceDataPointer = (long long)&SystemResourceDataTablePrimary;
    *ResourceDataPointer = (long long)&SystemResourceDataTableSecondary;
    ResourceDataPointer[4] = 0;
    *(uint8_t *)(ResourceDataPointer + 1) = 0;
    ResourceDataPointer[2] = 0;
    *(uint8_t *)(ResourceDataPointer + 3) = 0;
    PrimaryResourcePointer = (long long *)ResourceDataPointer[4];
    ResourceDataPointer[4] = 0;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
  }
  StringTemplatePointer = &SystemStringTemplate;
  if (*(void* **)(SystemResourceManager + 200) != (void* *)0x0) {
    StringTemplatePointer = *(void* **)(SystemResourceManager + 200);
  }
  (**(code **)(*ResourceDataPointer + 0x50))(ResourceDataPointer,StringTemplatePointer);
  (**(code **)(*ResourceDataPointer + 0x60))(ResourceDataPointer,SystemConfigurationBuffer);
  if (GraphicsStatusFlag == '\0') {
    SystemLogLevel = 0;
  }
  else if (SystemGraphicsFlag == '\0') {
    SystemLogLevel = (SystemLogLevelPtr != '\0') + 2;
  }
  else {
    SystemLogLevel = 1;
  }
  SystemMemoryBlockTertiary = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,3);
  *(void* *)(SystemMemoryBlockTertiary + 8) = 0;
  *(void* *)(SystemMemoryBlockTertiary + 0x10) = 0;
  *(void* *)(SystemMemoryBlockTertiary + 0x18) = 0;
  *(uint32_t *)(SystemMemoryBlockTertiary + 0x20) = 3;
  ConfigureSystemMemoryAllocator();
  SystemTablePointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x478,8,3);
  *SystemTablePointer = 0;
  SystemTablePointer[1] = 0;
  SystemTablePointer[2] = 0;
  *(uint32_t *)(SystemTablePointer + 3) = 3;
  SystemTablePointer[4] = 0;
  SystemTablePointer[5] = 0;
  SystemTablePointer[6] = 0;
  *(uint32_t *)(SystemTablePointer + 7) = 3;
  SystemTablePointer[8] = 0;
  SystemTablePointer[9] = 0;
  SystemTablePointer[10] = 0;
  *(uint32_t *)(SystemTablePointer + 0xb) = 3;
  *(uint8_t *)(SystemTablePointer + 0xc) = 0;
  *(void* *)((long long)SystemTablePointer + 100) = 0xffffffffffffffff;
  *(uint32_t *)((long long)SystemTablePointer + 0x6c) = 0;
  *(void*2 *)(SystemTablePointer + 0xe) = 0;
  *(uint8_t *)((long long)SystemTablePointer + 0x72) = 0;
    memset((long long)SystemTablePointer + 0x74,0,0x400);
}




/**
 * @brief 系统资源配置函数
 * 
 * 该函数负责配置系统资源，设置全局数据引用和系统参数。
 * 用于系统资源的初始化配置和参数设置。
 * 
 * @param SystemResourceManager 系统资源指针，用于访问系统资源数据
 * 
 *FUN_18006b220：ConfigureSystemResources
 */
void ConfigureSystemResources(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 0xa0) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0xa8) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0xa8) = 0;
  *(uint32_t *)(SystemResourceManager + 0xb8) = 0;
  *(void* *)(SystemResourceManager + 0xa0) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x80) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x88) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x88) = 0;
  *(uint32_t *)(SystemResourceManager + 0x98) = 0;
  *(void* *)(SystemResourceManager + 0x80) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x58) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x60) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x60) = 0;
  *(uint32_t *)(SystemResourceManager + 0x70) = 0;
  *(void* *)(SystemResourceManager + 0x58) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 0x38) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x40) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x40) = 0;
  *(uint32_t *)(SystemResourceManager + 0x50) = 0;
  *(void* *)(SystemResourceManager + 0x38) = &SystemMemoryAllocatorReference;
  *(void* *)(SystemResourceManager + 8) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x10) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x10) = 0;
  *(uint32_t *)(SystemResourceManager + 0x20) = 0;
  *(void* *)(SystemResourceManager + 8) = &SystemMemoryAllocatorReference;
  return;
}




long long ManageSystemResourceHandler(long long* SystemResourceManager,long long *ConfigurationDataPointer,int OperationParameter)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  
  if (AdditionalParameter == 3) {
    return 0x180bfd730;
  }
  if (AdditionalParameter == 4) {
    return *SystemResourceManager;
  }
  if (AdditionalParameter == 0) {
    if (*SystemResourceManager != 0) {
        SystemCleanupFunction();
    }
  }
  else {
    if (AdditionalParameter == 1) {
      SystemHashEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag,InvalidHandleValue);
      SystemDataPointer = (void* *)*ConfigurationDataPointer;
      *SystemHashEntryPointer = *SystemDataPointer;
      *(uint32_t *)(SystemHashEntryPointer + 1) = *(uint32_t *)(SystemDataPointer + 1);
      SystemHashEntryPointer[2] = SystemDataPointer[2];
      SystemHashEntryPointer[3] = SystemDataPointer[3];
      *SystemResourceManager = (long long)SystemHashEntryPointer;
      return 0;
    }
    if (AdditionalParameter == 2) {
      *SystemResourceManager = *ConfigurationDataPointer;
      *ConfigurationDataPointer = 0;
      return 0;
    }
  }
  return 0;
}




/**
 * @brief 系统数据缓冲区初始化函数
 * 
 * 该函数负责初始化系统数据缓冲区，设置缓冲区参数和配置数据。
 * 用于系统数据缓冲区的初始化和配置。
 * 
 * @param SystemResourceManager 系统资源指针，用于访问系统资源数据
 * @param ConfigurationDataPointer 配置数据指针，包含缓冲区配置参数
 * 
 *FUN_18006b440：InitializeSystemDataBuffer
 */
void InitializeSystemDataBuffer(long long SystemResourceManager,uint32_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void** SystemHashEntryPointer;
  uint32_t SystemStackParameters [6];
  
  if ((*(long long *)(SystemResourceManager + 0x1e20) != 0) &&
     (SystemStackParameters[0] = ConfigurationDataPointer, charStatus = (**(code **)(SystemResourceManager + 0x1e28))(SystemStackParameters),
     ConfigurationDataPointer = SystemStackParameters[0], initializationStatusFlag == '\0')) {
    if (SystemInitializationFlag == '\0') {
      SystemHashEntryPointer = &SystemStringTemplate;
      if (*(void* **)(SystemResourceManager + 0x1dd0) != (void* *)0x0) {
        SystemHashEntryPointer = *(void* **)(SystemResourceManager + 0x1dd0);
      }
      InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,SystemHashEntryPointer);
    }
    *(uint32_t *)(SystemResourceManager + 0x1dc0) = *(uint32_t *)(SystemResourceManager + 0x1e08);
    return;
  }
  *(uint32_t *)(SystemResourceManager + 0x1dc0) = ConfigurationDataPointer;
  return;
}




/**
 * @brief 系统状态标志设置函数
 * 
 * 该函数负责设置系统状态标志，更新系统运行时状态。
 * 用于系统状态管理和监控。
 * 
 * @param SystemResourceManager 系统资源指针，用于访问系统资源数据
 * @param ConfigurationDataPointer 配置数据指针，包含状态标志配置参数
 * 
 *FUN_18006b4c0：SetSystemStatusFlags
 */
void SetSystemStatusFlags(long long SystemResourceManager,uint32_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  void** SystemHashEntryPointer;
  uint32_t SystemStackParameters [6];
  
  if ((*(long long *)(SystemResourceManager + 0x1db0) != 0) &&
     (SystemStackParameters[0] = ConfigurationDataPointer, charStatus = (**(code **)(SystemResourceManager + 0x1db8))(SystemStackParameters),
     ConfigurationDataPointer = SystemStackParameters[0], initializationStatusFlag == '\0')) {
    if (SystemInitializationFlag == '\0') {
      SystemHashEntryPointer = &SystemStringTemplate;
      if (*(void* **)(SystemResourceManager + 0x1d60) != (void* *)0x0) {
        SystemHashEntryPointer = *(void* **)(SystemResourceManager + 0x1d60);
      }
      InitializeSystemMemoryBuffer(&SystemMemoryPoolTemplate,SystemHashEntryPointer);
    }
    *(uint32_t *)(SystemResourceManager + 0x1d50) = *(uint32_t *)(SystemResourceManager + 0x1d98);
    return;
  }
  *(uint32_t *)(SystemResourceManager + 0x1d50) = ConfigurationDataPointer;
  return;
}





// 函数: void ProcessSystemResourceConfiguration(void* SystemResourceManager,uint32_t ConfigurationDataPointer)
/**
 * @brief 处理系统资源配置
 * 
 * 该函数负责处理系统资源的配置操作，包括初始化检查、配置数据设置
 * 和系统状态更新。它会根据系统初始化状态执行不同的配置操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_18006b540：ProcessSystemResourceConfiguration
 */
void ProcessSystemResourceConfiguration(void* SystemResourceManager,uint32_t ConfigurationDataPointer)

{
  long long resourceDataIndex;
  char validationStatusFlag;
  void* *SystemHashNodeData;
  uint32_t SystemStackParameters [6];
  
  resourceDataIndex = SystemNodeManagerPointer;
  if ((*(long long *)(SystemNodeManagerPointer + 0x1870) != 0) &&
     (SystemStackParameters[0] = ConfigurationDataPointer, SystemOperationResult = (**(code **)(SystemNodeManagerPointer + 0x1878))(SystemStackParameters),
     ConfigurationDataPointer = SystemStackParameters[0], SystemOperationResult == '\0')) {
    if (SystemInitializationFlag == '\0') {
      SystemHashNodeData = &SystemStringTemplate;
      if (*(void* **)(resourceDataIndex + 0x1820) != (void* *)0x0) {
        SystemHashNodeData = *(void* **)(resourceDataIndex + 0x1820);
      }
      ProcessGlobalDataHashTable(&SystemGlobalDataTable,SystemHashNodeData);
    }
    *(uint32_t *)(resourceDataIndex + 0x1810) = *(uint32_t *)(resourceDataIndex + 0x1858);
    return;
  }
  *(uint32_t *)(resourceDataIndex + 0x1810) = ConfigurationDataPointer;
  return;
}



/**
 * @brief 清理系统资源句柄
 * 
 * 该函数负责清理系统资源句柄，释放相关的内存和资源。
 * 主要用于系统资源的清理和释放工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源数据结构
 * @param ConfigurationDataPointer 清理选项参数，控制清理行为
 * @param AdditionalParameter 清理回调函数指针
 * @param ConfigurationFlag 清理标志参数，指定清理操作的标志位
 * @return 返回清理后的系统资源指针
 * 
 *FUN_18006b5c0：CleanupSystemResourceHandle
 */
long long CleanupSystemResourceHandle(long long SystemResourceManager,uint ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (*(code **)(SystemResourceManager + 0xd0) != (code *)0x0) {
    (**(code **)(SystemResourceManager + 0xd0))(SystemResourceManager + 0xc0,0,0,ConfigurationFlag,InvalidHandleValue);
  }
  ReleaseSystemResources(SystemResourceManager);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xe0);
  }
  return SystemResourceManager;
}



/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理所需的数据结构和回调函数。
 * 主要用于系统资源的创建和管理工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 初始化参数，包含初始化所需的配置信息
 * @param AdditionalParameter 初始化回调函数指针
 * @param ConfigurationFlag 初始化标志参数，指定初始化操作的标志位
 * @return 返回初始化后的系统资源指针
 * 
 *InitializeSystemResourceManager：InitializeSystemResourceManager
 */
void* *
InitializeSystemResourceManager(void* *SystemResourceManager,void* *ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  void* resourceCreationFlags;
  
  resourceCreationFlags = 0xfffffffffffffffe;
  InitializeSystemDataTableManager();
  *SystemResourceManager = &SystemEventTemplate;
  SystemResourceManager[0x1a] = 0;
  SystemResourceManager[0x1b] = _guard_check_icall;
  if (SystemResourceManager + 0x18 != ConfigurationDataPointer) {
    systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(SystemResourceManager + 0x18,ConfigurationDataPointer,1,ConfigurationFlag,resourceCreationFlags);
      systemFunctionPointer = (code *)ConfigurationDataPointer[2];
    }
    SystemResourceManager[0x1a] = systemFunctionPointer;
    SystemResourceManager[0x1b] = ConfigurationDataPointer[3];
  }
  if ((code *)ConfigurationDataPointer[2] != (code *)0x0) {
    (*(code *)ConfigurationDataPointer[2])(ConfigurationDataPointer,0,0);
  }
  return SystemResourceManager;
}




// 函数: void InitializeSystemResourceConfiguration(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统资源配置
 * 
 * 该函数负责初始化系统资源配置，遍历资源表并执行初始化操作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18006b6f0：InitializeSystemResourceConfiguration
 */
void InitializeSystemResourceConfiguration(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 0x13) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ProcessSystemResourceConfigurationData(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 处理系统资源配置数据
 * 
 * 该函数负责处理系统资源配置数据，遍历资源表并执行数据处理操作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18006b760：ProcessSystemResourceConfigurationData
 */
void ProcessSystemResourceConfigurationData(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 0x13) {
    (**(code **)*SystemHashEntryPointer)(SystemHashEntryPointer,0,AdditionalParameter,ConfigurationFlag,resourceAllocationContext);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}





// 函数: void CleanupSystemResourceConfiguration(void)
/**
 * @brief 清理系统资源配置
 * 
 * 该函数负责清理系统资源配置，执行系统清理操作
 * 
 *FUN_18006b780：CleanupSystemResourceConfiguration
 */
void CleanupSystemResourceConfiguration(void)

{
  long long *PrimaryResourcePointer;
  long long SystemThreadHandle;
  char characterProcessingFlag;
  
  if (SystemCleanupHandler != 0) {
    (**(code **)(SystemCleanupHandler + 0x88))(1);
  }

// 函数: void ReleaseSystemResourceHandle(long long SystemResourceManager)
/**
 * @brief 释放系统资源句柄
 * 
 * 该函数负责释放系统资源句柄，清理相关内存和资源
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006b8f0：ReleaseSystemResourceHandle
 */
void ReleaseSystemResourceHandle(long long SystemResourceManager)

{
  *(void* *)(SystemResourceManager + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(SystemResourceManager + 0x28) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(SystemResourceManager + 0x28) = 0;
  *(uint32_t *)(SystemResourceManager + 0x38) = 0;
  *(void* *)(SystemResourceManager + 0x20) = &SystemMemoryAllocatorReference;
  return;
}





// 函数: void DestroySystemResourceManager(void* *SystemResourceManager)
/**
 * @brief 销毁系统资源指针
 * 
 * 该函数负责销毁系统资源指针，释放相关资源
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006b940：DestroySystemResourceManager
 */
void DestroySystemResourceManager(void* *SystemResourceManager)

{
  ulong long SystemOperationStatus;
  ulong long resourceCreationFlags;
  ulong long resourceAllocationContext;
  void* *presourceAddress;
  void* SystemThreadContext;
  long long SystemThreadFlags;
  long long localDataIndex;
  uint8_t asystemDataBuffer [48];
  void* *pUnsignedStackFlag88;
  void* *SystemStatusFlagPointer;
  void* EncryptionValue68;
  void* *systemContextPointer;
  ulong long SystemResourceStatusFlag;
  
  EncryptionValue68 = 0xfffffffffffffffe;
  SystemResourceStatusFlag = SystemEncryptionKeyTemplate ^ (ulong long)asystemDataBuffer;
  *SystemResourceManager = &SystemCriticalSectionTemplate;
  resourceCreationFlags = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemStatusFlagPointer = SystemResourceManager + 2;
  *SystemStatusFlagPointer = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  SystemResourceManager[4] = 0;
  SystemResourceManager[7] = 0;
  SystemThreadContext = SystemResourceManager + 0xd;
  localDataIndex = 0x20;
  SystemThreadFlags = 0x20;
  presourceAddress = SystemThreadContext;
  pSystemThreadContext = SystemResourceManager;
  do {
    SystemResourceCleanup(presourceAddress);
    presourceAddress = presourceAddress + 2;
    SystemThreadFlags = SystemThreadFlags + -1;
  } while (SystemThreadFlags != 0);
  *(void* *)((long long)SystemResourceManager + 0x26c) = 0;
  *(uint32_t *)(SystemResourceManager + 0x4d) = 0;
  SystemResourceManager[9] = 0;
  SystemResourceManager[10] = 0x20;
  SystemResourceManager[0xb] = SystemThreadContext;
  do {
    *(uint32_t *)SystemThreadContext = 0;
    SystemThreadContext = SystemThreadContext + 2;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  SystemResourceManager[0xc] = 0;
  SystemResourceManager[8] = SystemResourceManager + 10;
  SystemResourceManager[6] = 0x15;
  SystemThreadFlags = InitializeSystemThreadStructure();
  SystemResourceManager[5] = SystemThreadFlags;
  if (SystemThreadFlags == 0) {
    SystemResourceManager[6] = 0;
    SystemOperationStatus = resourceCreationFlags;
  }
  else {
    SystemOperationStatus = SystemResourceManager[6];
  }
  resourceAllocationContext = resourceCreationFlags;
  if (SystemOperationStatus != 0) {
    do {
      *(uint8_t *)(resourceCreationFlags + 0x141 + SystemResourceManager[5]) = 0;
      resourceAllocationContext = resourceAllocationContext + 1;
      resourceCreationFlags = resourceCreationFlags + 0x148;
    } while (resourceAllocationContext < (ulong long)SystemResourceManager[6]);
  }
  pUnsignedStackFlag88 = SystemResourceManager + 0x4f;
  _Cnd_init_in_situ();
  pUnsignedStackFlag88 = SystemResourceManager + 0x58;
  _Mtx_init_in_situ(pUnsignedStackFlag88,2);
  *(uint32_t *)(SystemResourceManager + 0x65) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x32c) = 0x80;
  SystemStatusFlagPointer = SystemResourceManager + 0x66;
  *(uint32_t *)(SystemResourceManager + 0x6a) = 0x3f800000;
  *(void* *)((long long)SystemResourceManager + 0x354) = 0x40000000;
  *(uint32_t *)((long long)SystemResourceManager + 0x35c) = 3;
  SystemResourceManager[0x68] = 1;
  SystemResourceManager[0x67] = &SystemNullPointer;
  SystemResourceManager[0x69] = 0;
  *(uint32_t *)(SystemResourceManager + 0x6b) = 0;
  *(uint8_t *)(SystemResourceManager + 0x6d) = 1;
  SystemThreadFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x140038,8,3);
    memset(SystemThreadFlags + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,0,0x140000);
}



/**
 * @brief 系统资源管理器配置函数
 * 
 * 该函数配置系统资源管理器，包括配置系统缓冲区和根据配置标志
 * 决定是否释放资源管理器内存。用于系统资源管理的配置和清理。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针（包含清理标志）
 * @return 配置后的资源管理器指针
 * 
 *FUN_18006bd20：ConfigureResourceManager
 */
void* ConfigureResourceManager(void* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  ConfigureSystemBuffer();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x370);
  }
  return SystemResourceManager;
}




/**
 * @brief 清理系统资源指针数组
 * 
 * 该函数负责清理系统资源指针数组，将所有指针重置为系统内存分配器引用，
 * 并执行必要的清理操作。主要用于系统资源的释放和重置。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源数据结构
 * 
 *FUN_18006bd60：CleanupSystemResourceManagerArray
 */
void CleanupSystemResourceManagerArray(long long SystemResourceManager)

{
  long long arrayIndex;
  void** systemDataTable;
  ulong long arraySize;
  ulong long currentIndex;
  
  arraySize = *(ulong long *)(SystemResourceManager + 0x10);
  arrayIndex = *(long long *)(SystemResourceManager + 8);
  currentIndex = 0;
  if (arraySize != 0) {
    do {
      resourcePointer = *(void* **)(arrayIndex + currentIndex * 8);
      if (resourcePointer != (void* *)0x0) {
        *resourcePointer = &SystemMemoryAllocatorReference;
          SystemCleanupFunction();
      }
      *(void* *)(arrayIndex + currentIndex * 8) = 0;
      currentIndex = currentIndex + 1;
    } while (currentIndex < arraySize);
    arraySize = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < arraySize) && (*(long long *)(SystemResourceManager + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * @brief 重置系统资源指针数组
 * 
 * 该函数负责重置系统资源指针数组，将所有指针重置为系统内存分配器引用，
 * 并执行必要的清理操作。主要用于系统资源的重置和初始化。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要重置的资源数据结构
 * 
 *FUN_18006bd80：ResetSystemResourceManagerArray
 */
void ResetSystemResourceManagerArray(long long SystemResourceManager)

{
  long long arrayIndex;
  void** systemDataTable;
  ulong long arraySize;
  ulong long currentIndex;
  
  arraySize = *(ulong long *)(SystemResourceManager + 0x10);
  arrayIndex = *(long long *)(SystemResourceManager + 8);
  currentIndex = 0;
  if (arraySize != 0) {
    do {
      resourcePointer = *(void* **)(arrayIndex + currentIndex * 8);
      if (resourcePointer != (void* *)0x0) {
        *resourcePointer = &SystemMemoryAllocatorReference;
          SystemCleanupFunction();
      }
      *(void* *)(arrayIndex + currentIndex * 8) = 0;
      currentIndex = currentIndex + 1;
    } while (currentIndex < arraySize);
    arraySize = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* )(SystemResourceManager + 0x18) = 0;
  if ((1 < arraySize) && (*(long long *)(SystemResourceManager + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




/**
 * @brief 系统资源分配和配置函数
 * 
 * 该函数负责系统资源的分配、配置和初始化
 * 包括内存池管理、哈希表操作和资源索引分配
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志指针
 * @param OutputResult 输出结果指针
 * 
 *FUN_18006bda0：AllocateAndConfigureSystemResource
 */
void AllocateAndConfigureSystemResource(long long SystemResourceManager,long long ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag,
             long long *OutputResult)

{
  long long resourceDataIndex;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  ulong long currentThreadId;
  ulong long ResourceHash;
  void*7 ThreadContextFlag;
  
  ResourceDataOffset = *(long long *)(ConfigurationDataPointer + 0x128);
  if (ResourceDataOffset != 0) {
    *AdditionalParameter = ResourceDataOffset;
    ResourceDataOffset = *(long long *)(ConfigurationDataPointer + 0x128);
  }
  resourceDataIndex = *(long long *)(ConfigurationDataPointer + 0x130);
  resourceAddress = 0;
  if (resourceDataIndex == 0) {
    if (ResourceDataOffset == 0) {
      resourceAddress = *(ulong long *)(ConfigurationDataPointer + 0x120);
    }
  }
  else {
    resourceAddress = *(ulong long *)(ConfigurationDataPointer + 0x120);
    if (ResourceDataOffset == 0) {
      resourceAddress = resourceAddress + *(long long *)(ConfigurationDataPointer + 0x138);
    }
  }
  *(void* *)(ConfigurationDataPointer + 0x1a0) = 0;
  *(void* *)(ConfigurationDataPointer + 0x198) = 0;
  *(void* *)(ConfigurationDataPointer + 400) = 0;
  *(void* *)(ConfigurationDataPointer + 0x188) = 0;
  currentThreadId = (*(long long *)(ConfigurationDataPointer + 0x120) - (*(ulong long *)(ConfigurationDataPointer + 0x118) & MAX_UNSIGNED_32_BITfffff000))
          + *(ulong long *)(ConfigurationDataPointer + 0x118);
  ResourceHash = currentThreadId & MAX_UNSIGNED_32_BITfffff000;
  ResourceDataOffset = (-(uint)((currentThreadId & 0xfff) != 0) & 0x1000) + ResourceHash;
  if (*(ulong long *)(SystemResourceManager + 0x360) < resourceAddress) {
    ThreadContextFlag = (void*7)(ResourceHash >> 8);
    if (resourceDataIndex == 0) {
      if (*AdditionalParameter == 0) {
        ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceDataOffset,CONCAT71(ThreadContextFlag,3));
        *AdditionalParameter = ResourceDataOffset;
        *(long long *)(ConfigurationDataPointer + 0x198) = ResourceDataOffset;
        *OutputResult = *AdditionalParameter;
      }
    }
    else {
      ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceDataOffset,CONCAT71(ThreadContextFlag,3));
      *ConfigurationFlag = ResourceDataOffset;
      *(long long *)(ConfigurationDataPointer + 0x198) = ResourceDataOffset;
      *OutputResult = *ConfigurationFlag;
      if (*AdditionalParameter == 0) {
        ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,*(void* *)(ConfigurationDataPointer + 0x138),3);
        *AdditionalParameter = ResourceDataOffset;
        *(long long *)(ConfigurationDataPointer + 0x1a0) = ResourceDataOffset;
      }
    }
  }
  else if (resourceDataIndex == 0) {
    if (*AdditionalParameter == 0) {
      resourcePoolPointer = (long long *)CreateSystemResourcePool(SystemResourceManager,ResourceDataOffset);
      *(long long **)(ConfigurationDataPointer + 400) = resourcePoolPointer;
      if (resourcePoolPointer == (long long *)0x0) goto ResourcePoolCheckPoint;
      ResourceDataOffset = *(long long *)(SystemResourceManager + 800) + *resourcePoolPointer;
      *AdditionalParameter = ResourceDataOffset;
      *OutputResult = ResourceDataOffset;
    }
  }
  else {
    resourcePoolPointer = (long long *)CreateSystemResourcePool(SystemResourceManager,ResourceDataOffset);
    *(long long **)(ConfigurationDataPointer + 0x188) = resourcePoolPointer;
    if (resourcePoolPointer == (long long *)0x0) {
ResourcePoolCheckPoint:
      ConfigureSystemMemoryBlock(SystemResourceManager,*(void* *)(ConfigurationDataPointer + 0x188));
      ConfigureSystemMemoryBlock(SystemResourceManager,*(void* *)(ConfigurationDataPointer + 400));
      return 0;
    }
    ResourceDataOffset = *resourcePoolPointer + *(long long *)(SystemResourceManager + 800);
    *ConfigurationFlag = ResourceDataOffset;
    *OutputResult = ResourceDataOffset;
    if (*AdditionalParameter == 0) {
      resourcePoolPointer = (long long *)CreateSystemResourcePool(SystemResourceManager,*(void* *)(ConfigurationDataPointer + 0x138));
      *(long long **)(ConfigurationDataPointer + 400) = resourcePoolPointer;
      if (resourcePoolPointer == (long long *)0x0) goto ResourcePoolCheckPoint;
      *AdditionalParameter = *resourcePoolPointer + *(long long *)(SystemResourceManager + 800);
    }
  }
  return 1;
}




// 函数: void ConfigureSystemBuffer(void* *SystemResourceManager)
void ConfigureSystemBuffer(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemCriticalSectionTemplate;
  CleanupSystemResourceDataTable();
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  SuspendSystemThreads(SystemResourceManager + 2);
  if ((long long *)SystemResourceManager[1] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[1] + 0x38))();
  }
  return;
}





// 函数: void ProcessSystemResourceNodeQueue(long long SystemResourceManager)
/**
 * @brief 处理系统资源节点队列
 * 
 * 该函数负责处理系统资源节点队列，包括节点的创建、销毁和状态管理。
 * 主要用于系统资源的动态管理和内存分配。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006c070：ProcessSystemResourceNodeQueue
 */
void ProcessSystemResourceNodeQueue(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  byte *pisOperationComplete;
  void* resourceAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  bool isDataValid;
  long long SystemMemoryAddress;
  char systemAvailabilityFlag;
  long long SystemAllocationFlags;
  long long *PrimaryResourcePointer1;
  byte *pisByteValid2;
  long long resourceDataIndex3;
  long long resourceDataIndex4;
  long long *PrimaryResourcePointer5;
  uint SystemOperationStatusFlags;
  int SystemOperationStatus7;
  long long *PrimaryResourcePointer8;
  void* *SystemHashEntryPointer0;
  long long SystemThreadHandle1;
  code *pSystemOperationResult2;
  long long *resourcePoolPointer3;
  void* *SystemHashEntryPointer4;
  ulong long SecurityParameter;
  uint8_t SystemMemoryOffsetBuffer [32];
  ulong long SystemHashValidationValue;
  void* **ppSystemDataBufferOffset;
  long long *SystemResourcePointer;
  long long SystemMemorySize;
  long long longValue230;
  uint8_t SystemMemoryAlignment;
  void* StackPointer218;
  int stackVariable210;
  uint32_t SystemMaxOperationCountc;
  void* SystemMaxOperationCount8;
  void* *SystemGlobalDataReferencePtr2;
  byte *pbStack_1f0;
  int stackVariable1E8;
  byte abStack_1e0 [256];
  void* StackPointerE0;
  ulong long SystemMemoryAllocatorStatus;
  long long lStack_d0;
  long long lStack_c8;
  long long lStack_c0;
  uint8_t systemDataBuffer;
  uint8_t aUnsignedStackFlagB0 [16];
  code *charPointerA0;
  code *SystemFunctionPointer98;
  uint8_t SystemStackParameterC [16];
  code *charPointer80;
  code *SystemFunctionPointer78;
  void* SystemProcessFlags70;
  void* EncryptionValue68;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  int stackVariable48;
  uint32_t StackUnsignedValue44;
  int StackInteger40;
  uint32_t SystemFlag3c;
  ulong long SystemContextValue;
  ulong long SystemContextPointer;
  
  SystemMaxOperationCount8 = 0xfffffffffffffffe;
  SystemContextValue = SystemEncryptionKeyTemplate ^ (ulong long)SystemMemoryOffsetBuffer;
  charOutput = *(char *)(*(long long *)(SystemResourceManager + 1000) + 0x58);
  do {
    if ((charOutput == '\0') || (SystemContextPointer = 0, *(char *)(SystemResourceManager + 0x400) != '\0')) {
        ValidateSystemChecksum(SystemContextValue ^ (ulong long)SystemMemoryOffsetBuffer);
    }
    SystemGlobalDataReferencePtr2 = &SystemMemoryAllocatorTemplate;
    pbStack_1f0 = abStack_1e0;
    StackInteger1E8 = 0;
    abStack_1e0[0] = 0;
    charPointerA0 = (code *)0x0;
    SystemFunctionPointer98 = _guard_check_icall;
    ppSystemDataBufferOffset = (void* **)SystemStackParameterC;
    charPointer80 = (code *)0x0;
    SystemFunctionPointer78 = _guard_check_icall;
    lStack_c0 = -1;
    SystemMemoryAllocatorStatus = 0xffffffffffffffff;
    SystemMemoryManagerHandle = 0xffffffffffffffff;
    SystemMemoryOffset = 0;
    SystemMemoryAllocationCounter = 0;
    systemDataBuffer = 0;
    resourceDataIndex3 = *(long long *)(SystemResourceManager + 0x3c8);
    resourceDataIndex4 = *(long long *)(SystemResourceManager + 0x3d0) - resourceDataIndex3;
    SystemAllocationFlags = resourceDataIndex4 >> 0x3f;
    if (resourceDataIndex4 / 0x1a8 + SystemAllocationFlags == SystemAllocationFlags) {
      charOutput = FindMatchingConfigurationResource(SystemResourceManager + 200,&SystemGlobalDataReferencePtr2);
      if (systemAvailabilityFlag == '\0') {
        resourceDataIndex3 = SystemResourceManager + 0x378;
        SystemMemoryAlignment = 0;
        longValue230 = resourceDataIndex3;
        SystemOperationStatus7 = _Mtx_lock(resourceDataIndex3);
        if (SystemOperationStatus7 != 0) {
          __Throw_C_error_std__YAXH_Z(SystemOperationStatus7);
        }
        SystemMemoryAlignment = 1;
        SystemAllocationFlags = _Xtime_get_ticks();
        resourceDataIndex4 = (SystemAllocationFlags + 50000) * 100;
        SystemAllocationFlags = resourceDataIndex4 / 1000000000;
        StackInteger48 = (int)SystemAllocationFlags;
        StackInteger210 = (int)resourceDataIndex4 + StackInteger48 * -1000000000;
        SystemAllocationFlags._4_4_ = (uint32_t)((ulong long)SystemAllocationFlags >> 0x20);
        SystemFlagComponent = SystemAllocationFlags._4_4_;
        SystemFlag3c = SystemMaxOperationCountc;
        SystemAllocationFlags = SystemAllocationFlags;
        StackInteger40 = StackInteger210;
        SystemOperationStatus7 = _Mtx_current_owns(resourceDataIndex3);
        if (SystemOperationStatus7 == 0) {
          __Throw_Cpp_error_std__YAXH_Z(4);
        }
        SystemOperationStatusFlags = _Cnd_timedwait(SystemResourceManager + 0x330,resourceDataIndex3,&StackInteger48);
        if ((SystemOperationStatusFlags & 0xfffffffd) != 0) {
          __Throw_C_error_std__YAXH_Z(SystemOperationStatusFlags);
        }
        charOutput = FindMatchingConfigurationResource(SystemResourceManager + 200,&SystemGlobalDataReferencePtr2);
        if (systemAvailabilityFlag == '\0') {
          SystemOperationStatus7 = _Mtx_unlock(resourceDataIndex3);
          if (SystemOperationStatus7 != 0) {
            __Throw_C_error_std__YAXH_Z(SystemOperationStatus7);
          }
          isDataValid = false;
        }
        else {
          SystemOperationStatus7 = _Mtx_unlock();
          if (SystemOperationStatus7 != 0) {
            __Throw_C_error_std__YAXH_Z(SystemOperationStatus7);
          }
          isDataValid = true;
        }
      }
      else {
        isDataValid = true;
      }
    }
    else {
      iStack_1e8 = *(int *)(resourceDataIndex3 + 0x10);
      SystemHashEntryPointer4 = &SystemStringTemplate;
      if (*(void* **)(resourceDataIndex3 + 8) != (void* *)0x0) {
        SystemHashEntryPointer4 = *(void* **)(resourceDataIndex3 + 8);
      }
      strcpy_s(pbStack_1f0,0x100,SystemHashEntryPointer4);
      SystemMemoryManagerHandle = *(void* *)(resourceDataIndex3 + 0x118);
      SystemMemoryAllocatorStatus = *(ulong long *)(resourceDataIndex3 + 0x120);
      SystemMemoryOffset = *(long long *)(resourceDataIndex3 + 0x128);
      SystemMemoryAllocationCounter = *(long long *)(resourceDataIndex3 + 0x130);
      SystemMemoryBufferSize = *(long long *)(resourceDataIndex3 + 0x138);
      systemDataBuffer = *(uint8_t *)(resourceDataIndex3 + 0x140);
      if (aUnsignedStackFlagB0 != (uint8_t *)(resourceDataIndex3 + 0x148)) {
        if (charPointerA0 != (code *)0x0) {
          (*charPointerA0)(aUnsignedStackFlagB0,0,0);
        }
        pSystemOperationResult2 = *(code **)(resourceDataIndex3 + 0x158);
        if (pSystemOperationResult2 != (code *)0x0) {
          (*pSystemOperationResult2)(aUnsignedStackFlagB0,(uint8_t *)(resourceDataIndex3 + 0x148),1);
          pSystemOperationResult2 = *(code **)(resourceDataIndex3 + 0x158);
        }
        SystemFunctionPointer98 = *(code **)(resourceDataIndex3 + 0x160);
        charPointerA0 = pSystemOperationResult2;
      }
      if (SystemStackParameterC != (uint8_t *)(resourceDataIndex3 + 0x168)) {
        if (charPointer80 != (code *)0x0) {
          (*charPointer80)(SystemStackParameterC,0,0);
        }
        pSystemOperationResult2 = *(code **)(resourceDataIndex3 + 0x178);
        if (pSystemOperationResult2 != (code *)0x0) {
          (*pSystemOperationResult2)(SystemStackParameterC,(uint8_t *)(resourceDataIndex3 + 0x168),1);
          pSystemOperationResult2 = *(code **)(resourceDataIndex3 + 0x178);
        }
        SystemFunctionPointer78 = *(code **)(resourceDataIndex3 + 0x180);
        charPointer80 = pSystemOperationResult2;
      }
      SystemProcessFlags70 = *(void* *)(resourceDataIndex3 + 0x188);
      EncryptionValue68 = *(void* *)(resourceDataIndex3 + 400);
      SystemThreadContext = *(void* *)(resourceDataIndex3 + 0x198);
      SystemProcessFlags58 = *(void* *)(resourceDataIndex3 + 0x1a0);
      *(long long *)(SystemResourceManager + 0x3d0) = *(long long *)(SystemResourceManager + 0x3d0) + -0x1a8;
      ReleaseSystemResource();
      isDataValid = true;
    }
    SystemHashEntryPointer0 = *(void* **)(SystemResourceManager + 0xc0);
    if ((void* *)*SystemHashEntryPointer0 == &SystemMemoryManagerTemplate) {
      charOutput = FindSystemResourceManagerMapping(SystemHashEntryPointer0 + 2,&SystemResourcePointer);
      while (charOutput != '\0') {
        resourcePoolPointer3 = (long long *)SystemHashEntryPointer0[99];
        if (SystemResourcePointer != (long long *)0x0) {
          *(uint8_t *)(SystemResourcePointer + 4) = 0;
          *resourcePoolPointer3 = *resourcePoolPointer3 - SystemResourcePointer[1];
          resourcePoolPointer3[2] = resourcePoolPointer3[2] + SystemResourcePointer[1];
          PrimaryResourcePointer8 = (long long *)SystemResourcePointer[3];
          PrimaryResourcePointer5 = (long long *)resourcePoolPointer3[3];
          PrimaryResourcePointer1 = SystemResourcePointer;
          if (PrimaryResourcePointer8 != PrimaryResourcePointer5) {
            do {
              if ((PrimaryResourcePointer8 == (long long *)0x0) || ((char)PrimaryResourcePointer8[4] != '\0')) break;
              resourceDataIndex3 = PrimaryResourcePointer1[2];
              PrimaryResourcePointer8[2] = resourceDataIndex3;
              if (resourceDataIndex3 != 0) {
                *(long long **)(resourceDataIndex3 + 0x18) = PrimaryResourcePointer8;
              }
              PrimaryResourcePointer8[1] = PrimaryResourcePointer8[1] + PrimaryResourcePointer1[1];
              *PrimaryResourcePointer1 = resourcePoolPointer3[0x28005];
              resourcePoolPointer3[0x28005] = (long long)PrimaryResourcePointer1;
              PrimaryResourcePointer = PrimaryResourcePointer8 + 3;
              PrimaryResourcePointer5 = (long long *)resourcePoolPointer3[3];
              PrimaryResourcePointer1 = PrimaryResourcePointer8;
              PrimaryResourcePointer8 = (long long *)*PrimaryResourcePointer;
            } while ((long long *)*PrimaryResourcePointer != PrimaryResourcePointer5);
          }
          PrimaryResourcePointer8 = (long long *)PrimaryResourcePointer1[2];
          while (((PrimaryResourcePointer1 != PrimaryResourcePointer5 && (PrimaryResourcePointer8 != (long long *)0x0)) && ((char)PrimaryResourcePointer8[4] == '\0')
                 )) {
            resourceDataIndex3 = PrimaryResourcePointer8[2];
            PrimaryResourcePointer1[2] = resourceDataIndex3;
            if (resourceDataIndex3 != 0) {
              *(long long **)(resourceDataIndex3 + 0x18) = PrimaryResourcePointer1;
            }
            PrimaryResourcePointer1[1] = PrimaryResourcePointer1[1] + PrimaryResourcePointer8[1];
            *PrimaryResourcePointer8 = resourcePoolPointer3[0x28005];
            resourcePoolPointer3[0x28005] = (long long)PrimaryResourcePointer8;
            PrimaryResourcePointer5 = (long long *)resourcePoolPointer3[3];
            PrimaryResourcePointer8 = (long long *)PrimaryResourcePointer1[2];
          }
        }
        charOutput = FindSystemResourceManagerMapping(SystemHashEntryPointer0 + 2,&SystemResourcePointer);
      }
    }
    else {
      (**(code **)((void* *)*SystemHashEntryPointer0 + 0x18))(SystemHashEntryPointer0);
    }
    if (isDataValid) {
      resourcePoolPointer3 = *(long long **)(SystemResourceManager + 0xc0);
      SecurityParameter = SystemContextPointer;
      if (0 < iStack_1e8) {
        do {
          SecurityParameter = SecurityParameter * 0x1f + (long long)(char)pbStack_1f0[SystemContextPointer];
          SystemOperationStatusFlags = (int)SystemContextPointer + 1;
          SystemContextPointer = (ulong long)SystemOperationStatusFlags;
        } while ((int)SystemOperationStatusFlags < iStack_1e8);
      }
      PrimaryResourcePointer8 = (long long *)resourcePoolPointer3[0x67];
      for (resourceDataIndex3 = PrimaryResourcePointer8[SecurityParameter % (ulong long)*(uint *)(resourcePoolPointer3 + 0x68)]; resourceDataIndex3 != 0;
          resourceDataIndex3 = *(long long *)(resourceDataIndex3 + 0x120)) {
        SystemOperationStatus7 = *(int *)(resourceDataIndex3 + 0x10);
        if (iStack_1e8 == SystemOperationStatus7) {
          if (iStack_1e8 != 0) {
            pisByteValid2 = pbStack_1f0;
            do {
              pisOperationComplete = pisByteValid2 + (*(long long *)(resourceDataIndex3 + 8) - (long long)pbStack_1f0);
              SystemOperationStatus7 = (uint)*pisByteValid2 - (uint)*pisOperationComplete;
              if (SystemOperationStatus7 != 0) break;
              pisByteValid2 = pisByteValid2 + 1;
            } while (*pisOperationComplete != 0);
          }
StackCheckPoint1:
          if (SystemOperationStatus7 == 0) {
            if (resourceDataIndex3 != 0) {
              SystemAllocationFlags = resourcePoolPointer3[0x68];
              goto StackCheckPoint2;
            }
            break;
          }
        }
        else if (iStack_1e8 == 0) goto StackCheckPoint1;
      }
      SystemAllocationFlags = resourcePoolPointer3[0x68];
      resourceDataIndex3 = PrimaryResourcePointer8[SystemAllocationFlags];
StackCheckPoint2:
      if ((resourceDataIndex3 != PrimaryResourcePointer8[SystemAllocationFlags]) && (resourceDataIndex3 = *(long long *)(resourceDataIndex3 + 0x118), resourceDataIndex3 != 0)) {
StackCheckPoint3:
        if (lStack_c8 == 0) {
          SystemContextPointer = 0;
          if (lStack_d0 == 0) {
            SystemContextPointer = SystemMemoryAllocatorStatus;
          }
        }
        else {
          SystemContextPointer = SystemMemoryAllocatorStatus;
          if (lStack_d0 == 0) {
            SystemContextPointer = SystemMemoryAllocatorStatus + lStack_c0;
          }
        }
        LOCK();
        resourcePoolPointer3 = (long long *)(SystemResourceManager + 0x3f0);
        SystemAllocationFlags = *resourcePoolPointer3;
        *resourcePoolPointer3 = *resourcePoolPointer3 + SystemContextPointer;
        UNLOCK();
        LOCK();
        pointerToInteger2 = (int *)(SystemResourceManager + 0x3f8);
        SystemOperationStatus7 = *pointerToInteger2;
        *pointerToInteger2 = *pointerToInteger2 + 1;
        UNLOCK();
        SystemHashEntryPointer0 = *(void* **)(SystemResourceManager + 0xc0);
        SystemHashEntryValue = SystemHashEntryPointer0[0x6c];
        if (SystemHashEntryValue < SystemContextPointer) {
          pisByteValid2 = &SystemStringTemplate;
          if (pbStack_1f0 != (byte *)0x0) {
            pisByteValid2 = pbStack_1f0;
          }
            UpdateContextManagerSystem(SystemContextManagerPointer,&SystemSecurityUpdateData,SystemContextPointer,pisByteValid2);
        }
        if (((SystemHashEntryValue < SystemAllocationFlags + SystemContextPointer) ||
            ((ulong long)(long long)*(int *)(SystemResourceManager + 0x3fc) < (long long)SystemOperationStatus7 + 1U)) ||
           (charOutput = (**(code **)*SystemHashEntryPointer0)(SystemHashEntryPointer0,resourceDataIndex3,&SystemGlobalDataReferencePtr2), charOutput == '\0')) {
          LOCK();
          *(long long *)(SystemResourceManager + 0x3f0) = *(long long *)(SystemResourceManager + 0x3f0) - SystemContextPointer;
          UNLOCK();
          LOCK();
          *(int *)(SystemResourceManager + 0x3f8) = *(int *)(SystemResourceManager + 0x3f8) + -1;
          UNLOCK();
          AllocateSystemResourceNode(SystemResourceManager + 0x3c8,&SystemGlobalDataReferencePtr2);
StackCheckPoint4:
          pSystemOperationResult2 = *(code **)(**(long long **)(SystemResourceManager + 0xc0) + 0x28);
          if (pSystemOperationResult2 != _guard_check_icall) {
            (*pSystemOperationResult2)();
          }
          Sleep(1);
        }
        pSystemOperationResult2 = *(code **)(**(long long **)(SystemResourceManager + 0xc0) + 0x20);
        if (pSystemOperationResult2 != _guard_check_icall) {
          (*pSystemOperationResult2)();
        }
        goto StackCheckPoint5;
      }
      if (*(int *)((long long)resourcePoolPointer3 + 0x32c) < (int)resourcePoolPointer3[0x65]) {
        SystemHashEntryPointer0 = (void* *)*PrimaryResourcePointer8;
        PrimaryResourcePointer5 = PrimaryResourcePointer8;
        if (SystemHashEntryPointer0 == (void* *)0x0) {
          PrimaryResourcePointer5 = PrimaryResourcePointer8 + 1;
          SystemHashEntryPointer0 = (void* *)*PrimaryResourcePointer5;
          if (SystemHashEntryPointer0 == (void* *)0x0) {
            do {
              PrimaryResourcePointer5 = PrimaryResourcePointer5 + 1;
              SystemHashEntryPointer0 = (void* *)*PrimaryResourcePointer5;
            } while (SystemHashEntryPointer0 == (void* *)0x0);
            SystemAllocationFlags = resourcePoolPointer3[0x68];
          }
        }
        if (SystemHashEntryPointer0 != (void* *)PrimaryResourcePointer8[SystemAllocationFlags]) {
          do {
            if (*(int *)(SystemHashEntryPointer0[0x23] + 0x120) == 0) {
              resourceAddress = SystemHashEntryPointer0[0x23];
              *(int *)(resourcePoolPointer3 + 0x65) = (int)resourcePoolPointer3[0x65] + -1;
              (**(code **)(*resourcePoolPointer3 + 0x10))(resourcePoolPointer3,resourceAddress);
              resourceDataIndex3 = SystemHashEntryPointer0[0x24];
              resourcePoolPointer3 = PrimaryResourcePointer5;
              while (resourceDataIndex3 == 0) {
                resourcePoolPointer3 = resourcePoolPointer3 + 1;
                resourceDataIndex3 = *resourcePoolPointer3;
              }
              SystemThreadContext = (void* *)*PrimaryResourcePointer5;
              resourceEntryPointer = (void* *)SystemThreadContext[0x24];
              if (SystemThreadContext == SystemHashEntryPointer0) {
                *PrimaryResourcePointer5 = (long long)resourceEntryPointer;
              }
              else {
                for (; resourceEntryPointer != SystemHashEntryPointer0; resourceEntryPointer = (void* *)resourceEntryPointer[0x24]) {
                  SystemThreadContext = resourceEntryPointer;
                }
                SystemThreadContext[0x24] = resourceEntryPointer[0x24];
              }
              *SystemHashEntryPointer0 = &SystemMemoryAllocatorReference;
              ppSystemDataBufferOffset = (void* **)SystemHashEntryPointer0;
                SystemCleanupFunction(SystemHashEntryPointer0);
            }
            SystemHashEntryPointer0 = (void* *)SystemHashEntryPointer0[0x24];
            while (SystemHashEntryPointer0 == (void* *)0x0) {
              PrimaryResourcePointer5 = PrimaryResourcePointer5 + 1;
              SystemHashEntryPointer0 = (void* *)*PrimaryResourcePointer5;
            }
          } while (SystemHashEntryPointer0 != *(void* **)(resourcePoolPointer3[0x67] + resourcePoolPointer3[0x68] * 8));
        }
      }
      PrimaryResourcePointer8 = (long long *)(SystemResourceManager + 0x3c8);
      resourceDataIndex3 = 0;
      resourcePoolPointer3 = *(long long **)(SystemResourceManager + 0xc0);
      if (*(int *)((long long)resourcePoolPointer3 + 0x32c) < (int)resourcePoolPointer3[0x65]) {
        SystemContextPointer = *(ulong long *)(SystemResourceManager + 0x3d0);
        if (SystemContextPointer < *(ulong long *)(SystemResourceManager + 0x3d8)) {
          *(ulong long *)(SystemResourceManager + 0x3d0) = SystemContextPointer + 0x1a8;
          ProcessSystemResourceData(SystemContextPointer,&SystemGlobalDataReferencePtr2);
          goto StackCheckPoint4;
        }
        SystemAllocationFlags = *PrimaryResourcePointer8;
        resourceDataIndex4 = (long long)(SystemContextPointer - SystemAllocationFlags) / 0x1a8;
        if (resourceDataIndex4 == 0) {
          resourceDataIndex4 = 1;
StackCheckPoint6:
          resourceDataIndex3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceDataIndex4 * 0x1a8,*(uint8_t *)(SystemResourceManager + 0x3e0));
          SystemContextPointer = *(ulong long *)(SystemResourceManager + 0x3d0);
          SystemAllocationFlags = *PrimaryResourcePointer8;
        }
        else {
          resourceDataIndex4 = resourceDataIndex4 * 2;
          if (resourceDataIndex4 != 0) goto StackCheckPoint6;
        }
        InitializeSystemMemoryAllocatorWithHashNodes(&SystemMemorySize,SystemAllocationFlags,SystemContextPointer,resourceDataIndex3);
        SystemMemoryAddress = SystemMemorySize;
        ProcessSystemResourceData(SystemMemorySize,&SystemGlobalDataReferencePtr2);
        SystemAllocationFlags = *(long long *)(SystemResourceManager + 0x3d0);
        SystemThreadHandle1 = *PrimaryResourcePointer8;
        if (SystemThreadHandle1 != SystemAllocationFlags) {
          do {
            ReleaseSystemResource(SystemThreadHandle1);
            SystemThreadHandle1 = SystemThreadHandle1 + 0x1a8;
          } while (SystemThreadHandle1 != SystemAllocationFlags);
          SystemThreadHandle1 = *PrimaryResourcePointer8;
        }
        if (SystemThreadHandle1 != 0) {
            SystemCleanupFunction(SystemThreadHandle1);
        }
        *PrimaryResourcePointer8 = resourceDataIndex3;
        *(long long *)(SystemResourceManager + 0x3d0) = SystemMemoryAddress + 0x1a8;
        *(long long *)(SystemResourceManager + 0x3d8) = resourceDataIndex4 * 0x1a8 + resourceDataIndex3;
        goto StackCheckPoint4;
      }
      *(int *)(resourcePoolPointer3 + 0x65) = (int)resourcePoolPointer3[0x65] + 1;
      resourceDataIndex3 = (**(code **)(*resourcePoolPointer3 + 8))(resourcePoolPointer3,&SystemGlobalDataReferencePtr2);
      if (resourceDataIndex3 != 0) goto StackCheckPoint3;
      (*SystemFunctionPointer78)(SystemStackParameterC);
      ppSystemDataBufferOffset = (void* **)SystemStackParameterC;
      if (charPointer80 != (code *)0x0) {
        (*charPointer80)(SystemStackParameterC,0,0);
      }
      ppSystemDataBufferOffset = (void* **)aUnsignedStackFlagB0;
      if (charPointerA0 != (code *)0x0) {
        (*charPointerA0)(aUnsignedStackFlagB0,0,0);
      }
    }
    else {
      pSystemOperationResult2 = *(code **)(**(long long **)(SystemResourceManager + 0xc0) + 0x28);
      if (pSystemOperationResult2 != _guard_check_icall) {
        (*pSystemOperationResult2)();
      }
StackCheckPoint5:
      ppSystemDataBufferOffset = (void* **)SystemStackParameterC;
      if (charPointer80 != (code *)0x0) {
        (*charPointer80)(SystemStackParameterC,0,0);
      }
      ppSystemDataBufferOffset = (void* **)aUnsignedStackFlagB0;
      if (charPointerA0 != (code *)0x0) {
        (*charPointerA0)(aUnsignedStackFlagB0,0,0);
      }
    }
    ppSystemDataBufferOffset = &SystemGlobalDataReferencePtr2;
    SystemGlobalDataReferencePtr2 = &SystemMemoryAllocatorReference;
    charOutput = *(char *)(*(long long *)(SystemResourceManager + 1000) + 0x58);
  } while( true );
}




// 函数: void CleanupSystemResourceDataTable(long long SystemResourceManager)
/**
 * @brief 清理系统资源数据表
 * 
 * 该函数负责清理系统资源数据表，释放资源并重置数据表状态。
 * 主要用于系统资源的清理和内存回收。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006cb90：CleanupSystemResourceDataTable
 */
void CleanupSystemResourceDataTable(long long SystemResourceManager)

{
  long long resourceDataIndex;
  void** SystemDataTable;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  
  resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  resourceDataIndex = *(long long *)(SystemResourceManager + 8);
  resourceAddress = 0;
  if (resourceAllocationContext != 0) {
    do {
      SystemHashEntryPointer = *(void* **)(resourceDataIndex + resourceAddress * 8);
      if (SystemHashEntryPointer != (void* *)0x0) {
        *SystemHashEntryPointer = &SystemMemoryAllocatorReference;
          SystemCleanupFunction();
      }
      *(void* *)(resourceDataIndex + resourceAddress * 8) = 0;
      resourceAddress = resourceAddress + 1;
    } while (resourceAddress < resourceAllocationContext);
    resourceAllocationContext = *(ulong long *)(SystemResourceManager + 0x10);
  }
  *(void* *)(SystemResourceManager + 0x18) = 0;
  if ((1 < resourceAllocationContext) && (*(long long *)(SystemResourceManager + 8) != 0)) {
      SystemCleanupFunction();
  }
  return;
}




// 函数: ulong long AllocateSystemResourceNode(long long* SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 分配系统资源节点
 * 
 * 该函数负责分配系统资源节点，包括内存分配和节点初始化。
 * 主要用于系统资源的动态分配和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 分配的资源节点地址
 * 
 *FUN_18006cc50：AllocateSystemResourceNode
 */
ulong long AllocateSystemResourceNode(long long* SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  ulong long resourceCreationFlags;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  code *psystemStatusFlag;
  long long SystemThreadFlags;
  ulong long SystemContextValue;
  
  resourceCreationFlags = SystemResourceManager[1];
  if (resourceCreationFlags < (ulong long)SystemResourceManager[2]) {
    SystemResourceManager[1] = resourceCreationFlags + 0x1a8;
    SystemContextValue = resourceCreationFlags;
    InitializeSystemResourceStringTemplate();
    *(void* *)(resourceCreationFlags + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
    *(void* *)(resourceCreationFlags + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
    *(void* *)(resourceCreationFlags + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
    *(void* *)(resourceCreationFlags + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
    *(void* *)(resourceCreationFlags + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
    *(uint8_t *)(resourceCreationFlags + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
    *(void* *)(resourceCreationFlags + 0x158) = 0;
    *(code **)(resourceCreationFlags + 0x160) = _guard_check_icall;
    if (resourceCreationFlags + 0x148 != ConfigurationDataPointer + 0x148) {
      psystemStatusFlag = *(code **)(ConfigurationDataPointer + 0x158);
      if (psystemStatusFlag != (code *)0x0) {
        (*psystemStatusFlag)(resourceCreationFlags + 0x148,ConfigurationDataPointer + 0x148,1);
        psystemStatusFlag = *(code **)(ConfigurationDataPointer + 0x158);
      }
      *(code **)(resourceCreationFlags + 0x158) = psystemStatusFlag;
      *(void* *)(resourceCreationFlags + 0x160) = *(void* *)(ConfigurationDataPointer + 0x160);
    }
    *(void* *)(resourceCreationFlags + 0x178) = 0;
    *(code **)(resourceCreationFlags + 0x180) = _guard_check_icall;
    if (resourceCreationFlags + 0x168 != ConfigurationDataPointer + 0x168) {
      psystemStatusFlag = *(code **)(ConfigurationDataPointer + 0x178);
      if (psystemStatusFlag != (code *)0x0) {
        (*psystemStatusFlag)(resourceCreationFlags + 0x168,ConfigurationDataPointer + 0x168,1);
        psystemStatusFlag = *(code **)(ConfigurationDataPointer + 0x178);
      }
      *(code **)(resourceCreationFlags + 0x178) = psystemStatusFlag;
      *(void* *)(resourceCreationFlags + 0x180) = *(void* *)(ConfigurationDataPointer + 0x180);
    }
    *(void* *)(resourceCreationFlags + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
    *(void* *)(resourceCreationFlags + 400) = *(void* *)(ConfigurationDataPointer + 400);
    *(void* *)(resourceCreationFlags + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
    *(void* *)(resourceCreationFlags + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
    return resourceCreationFlags;
  }
  SystemThreadFlags = *SystemResourceManager;
  SystemBufferAddress = (long long)(resourceCreationFlags - SystemThreadFlags) / 0x1a8;
  if (SystemBufferAddress == 0) {
    SystemBufferAddress = 1;
  }
  else {
    SystemBufferAddress = SystemBufferAddress * 2;
    if (SystemBufferAddress == 0) {
      resourceDataIndex = 0;
      goto ResourceCreationComplete;
    }
  }
  resourceDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemBufferAddress * 0x1a8,(char)SystemResourceManager[3]);
  resourceCreationFlags = SystemResourceManager[1];
  SystemThreadFlags = *SystemResourceManager;
ResourceCreationComplete:
  InitializeSystemMemoryAllocatorWithHashNodes(&SystemContextValue,SystemThreadFlags,resourceCreationFlags,resourceDataIndex);
  ProcessSystemResourceData(SystemContextValue,ConfigurationDataPointer);
  SystemThreadFlags = SystemResourceManager[1];
  ResourceDataOffset = *SystemResourceManager;
  if (ResourceDataOffset != SystemThreadFlags) {
    do {
      ReleaseSystemResource(ResourceDataOffset);
      ResourceDataOffset = ResourceDataOffset + 0x1a8;
    } while (ResourceDataOffset != SystemThreadFlags);
    ResourceDataOffset = *SystemResourceManager;
  }
  if (ResourceDataOffset != 0) {
      SystemCleanupFunction(ResourceDataOffset);
  }
  resourceCreationFlags = SystemBufferAddress * 0x1a8 + resourceDataIndex;
  *SystemResourceManager = resourceDataIndex;
  SystemResourceManager[1] = SystemContextValue + 0x1a8;
  SystemResourceManager[2] = resourceCreationFlags;
  return resourceCreationFlags;
}





// 函数: void ConfigureSystemResourceNode(void* SystemResourceManager,void* ConfigurationDataPointer,long long AdditionalParameter)
/**
 * @brief 配置系统资源节点
 * 
 * 该函数负责配置系统资源节点，包括内存分配和节点初始化。
 * 主要用于系统资源的动态配置和管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 *FUN_18006cc8d：ConfigureSystemResourceNode
 */
void ConfigureSystemResourceNode(void* SystemResourceManager,void* ConfigurationDataPointer,long long AdditionalParameter)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  long long in_RAX;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  long long SystemTimeValue;
  long long *systemDataIndexPtr;
  long long in_R10;
  long long InputStackParameter50;
  
  SystemBufferAddress = SUB168(SEXT816(in_RAX) * SEXT816(AdditionalParameter - in_R10),8);
  SystemBufferAddress = (SystemBufferAddress >> 7) - (SystemBufferAddress >> 0x3f);
  if (SystemBufferAddress == 0) {
    SystemBufferAddress = 1;
  }
  else {
    SystemBufferAddress = SystemBufferAddress * 2;
    if (SystemBufferAddress == 0) {
      ResourceDataOffset = 0;
      goto ResourceCreationComplete;
    }
  }
  ResourceDataOffset = CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemBufferAddress * 0x1a8,(char)systemDataIndexPtr[3]);
  AdditionalParameter = systemDataIndexPtr[1];
  in_R10 = *systemDataIndexPtr;
ResourceCreationComplete:
  InitializeSystemMemoryAllocatorWithHashNodes(&stackBuffer50,in_R10,AdditionalParameter,ResourceDataOffset);
  SystemThreadHandle = InputStackParameter50;
  ProcessSystemResourceData(InputStackParameter50);
  resourceDataIndex = systemDataIndexPtr[1];
  localSystemPointer = *systemDataIndexPtr;
  if (localSystemPointer != resourceDataIndex) {
    do {
      ReleaseSystemResource(localSystemPointer);
      localSystemPointer = localSystemPointer + 0x1a8;
    } while (localSystemPointer != resourceDataIndex);
    localSystemPointer = *systemDataIndexPtr;
  }
  if (localSystemPointer != 0) {
      SystemCleanupFunction(localSystemPointer);
  }
  *systemDataIndexPtr = ResourceDataOffset;
  systemDataIndexPtr[1] = SystemThreadHandle + 0x1a8;
  systemDataIndexPtr[2] = SystemBufferAddress * 0x1a8 + ResourceDataOffset;
  return;
}




// 函数: void SystemCleanupFunctionB(void)
/**
 * @brief 系统清理函数
 * 
 * 该函数负责执行系统清理操作，释放资源和重置系统状态。
 * 主要用于系统资源的统一清理。
 * 
 *FUN_18006cd43：SystemCleanupFunctionB
 */
void SystemCleanupFunctionB(void)

{
    SystemCleanupFunction();
}



// 函数: long long ProcessSystemResourceData(long long SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 处理系统资源数据
 * 
 * 该函数负责处理系统资源数据，包括数据的配置和管理。
 * 主要用于系统资源的动态处理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 处理结果
 * 
 *FUN_18006cd80：ProcessSystemResourceDataB
 */
long long ProcessSystemResourceDataB(long long SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  code *systemFunctionPointer;
  void* resourceCreationFlags;
  
  resourceCreationFlags = 0xfffffffffffffffe;
  InitializeSystemResourceStringTemplate();
  *(void* *)(SystemResourceManager + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
  *(void* *)(SystemResourceManager + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
  *(void* *)(SystemResourceManager + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
  *(void* *)(SystemResourceManager + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
  *(void* *)(SystemResourceManager + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
  *(uint8_t *)(SystemResourceManager + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
  *(void* *)(SystemResourceManager + 0x158) = 0;
  *(code **)(SystemResourceManager + 0x160) = _guard_check_icall;
  if (SystemResourceManager + 0x148 != ConfigurationDataPointer + 0x148) {
    systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x158);
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(SystemResourceManager + 0x148,ConfigurationDataPointer + 0x148,1,ConfigurationFlag,resourceCreationFlags);
      systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x158);
    }
    *(code **)(SystemResourceManager + 0x158) = systemFunctionPointer;
    *(void* *)(SystemResourceManager + 0x160) = *(void* *)(ConfigurationDataPointer + 0x160);
  }
  *(void* *)(SystemResourceManager + 0x178) = 0;
  *(code **)(SystemResourceManager + 0x180) = _guard_check_icall;
  if (SystemResourceManager + 0x168 != ConfigurationDataPointer + 0x168) {
    systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x178);
    if (systemFunctionPointer != (code *)0x0) {
      (*systemFunctionPointer)(SystemResourceManager + 0x168,ConfigurationDataPointer + 0x168,1);
      systemFunctionPointer = *(code **)(ConfigurationDataPointer + 0x178);
    }
    *(code **)(SystemResourceManager + 0x178) = systemFunctionPointer;
    *(void* *)(SystemResourceManager + 0x180) = *(void* *)(ConfigurationDataPointer + 0x180);
  }
  *(void* *)(SystemResourceManager + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
  *(void* *)(SystemResourceManager + 400) = *(void* *)(ConfigurationDataPointer + 400);
  *(void* *)(SystemResourceManager + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
  *(void* *)(SystemResourceManager + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
  return SystemResourceManager;
}




// 函数: void InitializeSystemResourceManager(void* *SystemResourceManager)
/**
 * @brief 初始化系统资源指针
 * 
 * 该函数负责初始化系统资源指针，设置资源管理的基本参数。
 * 主要用于系统资源的初始化配置。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006cf00：InitializeSystemResourceManagerB
 */
void InitializeSystemResourceManagerB(void* *SystemResourceManager)

{
  int* SystemIntegerPointer;
  int systemResult;
  ulong long resourceAllocationContext;
  ulong long resourceAddress;
  long long *SystemLocalContextPointer;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  long long resourceCounter;
  ulong long SystemOperationFlags;
  bool isByteValid1;
  
  *SystemResourceManager = &SystemResourceTemplateA;
  resourceAllocationContext = SystemResourceManager[4];
  resourceCounter = 0;
  resourceAddress = SystemResourceManager[5];
  for (SystemOperationFlags = resourceAddress; SystemOperationFlags != resourceAllocationContext; SystemOperationFlags = SystemOperationFlags + 1) {
    if ((SystemOperationFlags & BIT_MASK_32_BIT) == 0) {
      if (resourceCounter != 0) {
        SystemThreadFlags = SystemResourceManager[10];
        LOCK();
        SystemIntegerPointer = (int *)(resourceCounter + 0x3530);
        systemResult = *SystemIntegerPointer;
        *SystemIntegerPointer = *SystemIntegerPointer + -0x80000000;
        UNLOCK();
        if (systemResult == 0) {
          SystemMemoryAddress = *(long long *)(SystemThreadFlags + 0x28);
          do {
            *(long long *)(resourceCounter + 0x3538) = SystemMemoryAddress;
            *(uint32_t *)(resourceCounter + 0x3530) = 1;
            SystemLocalContextPointer = (long long *)(SystemThreadFlags + 0x28);
            LOCK();
            localDataIndex = *SystemLocalContextPointer;
            isByteValid1 = SystemMemoryAddress == localDataIndex;
            if (isByteValid1) {
              *SystemLocalContextPointer = resourceCounter;
              localDataIndex = SystemMemoryAddress;
            }
            UNLOCK();
            if (isByteValid1) break;
            LOCK();
            SystemIntegerPointer = (int *)(resourceCounter + 0x3530);
            systemResult = *SystemIntegerPointer;
            *SystemIntegerPointer = *SystemIntegerPointer + 0x7fffffff;
            UNLOCK();
            SystemMemoryAddress = localDataIndex;
          } while (systemResult == 1);
        }
      }
ResourceCounterCheck:
      SystemLocalContextPointer = (long long *)SystemResourceManager[0xc];
      resourceCounter = *(long long *)
               (*(long long *)
                 (SystemLocalContextPointer[3] +
                 (((SystemOperationFlags & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(SystemLocalContextPointer[3] + SystemLocalContextPointer[1] * 8) >> 5)
                  + SystemLocalContextPointer[1] & *SystemLocalContextPointer - 1U) * 8) + 8);
    }
    else if (resourceCounter == 0) goto ResourceCounterCheck;
    ReleaseSystemResource((ulong long)((uint)SystemOperationFlags & BIT_MASK_32_BIT) * 0x1a8 + resourceCounter);
  }
  resourceCounter = SystemResourceManager[8];
  if ((resourceCounter != 0) && ((resourceAddress != resourceAllocationContext || ((resourceAllocationContext & BIT_MASK_32_BIT) != 0)))) {
    SystemThreadFlags = SystemResourceManager[10];
    LOCK();
    SystemIntegerPointer = (int *)(resourceCounter + 0x3530);
    systemResult = *SystemIntegerPointer;
    *SystemIntegerPointer = *SystemIntegerPointer + -0x80000000;
    UNLOCK();
    if (systemResult == 0) {
      SystemMemoryAddress = *(long long *)(SystemThreadFlags + 0x28);
      do {
        *(long long *)(resourceCounter + 0x3538) = SystemMemoryAddress;
        *(uint32_t *)(resourceCounter + 0x3530) = 1;
        SystemLocalContextPointer = (long long *)(SystemThreadFlags + 0x28);
        LOCK();
        localDataIndex = *SystemLocalContextPointer;
        isByteValid1 = SystemMemoryAddress == localDataIndex;
        if (isByteValid1) {
          *SystemLocalContextPointer = resourceCounter;
          localDataIndex = SystemMemoryAddress;
        }
        UNLOCK();
        if (isByteValid1) break;
        LOCK();
        SystemIntegerPointer = (int *)(resourceCounter + 0x3530);
        systemResult = *SystemIntegerPointer;
        *SystemIntegerPointer = *SystemIntegerPointer + 0x7fffffff;
        UNLOCK();
        SystemMemoryAddress = localDataIndex;
      } while (systemResult == 1);
    }
  }
  if (SystemResourceManager[0xc] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemResourceTemplateB;
  return;
}




/**
 * @brief 获取线程本地存储条目
 * 
 * 该函数负责获取或创建线程本地存储（TLS）条目，支持多线程环境下的
 * 线程私有数据管理。使用哈希表来存储和检索线程特定的数据。
 * 
 * @param SystemResourceManager 资源管理器指针，包含线程本地存储的哈希表
 * @return void** 返回线程本地存储条目指针，失败时返回NULL
 * 
 *FUN_18006d0b0：GetThreadLocalStorageEntry
 */
void** GetThreadLocalStorageEntry(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  uint *SystemHashEntryPointer;
  ulong long *SystemHashNodeData;
  ulong long resourceAddress;
  uint currentThreadId;
  ulong long ResourceHash;
  ulong long *hashTableNode;
  void** SystemNextNode;
  long long resourceCounter;
  long long SystemAllocationFlags;
  void* *ThreadLocalStorage;
  ulong long SystemSecondaryStatus;
  ulong long SystemOperationStatus3;
  uint SystemOperationStatus4;
  void* *ThreadLocalStorageEntry;
  bool isEntryAvailable;
  bool isSlotEmpty;
  
  currentThreadId = GetCurrentThreadId();
  SystemOperationStatus4 = (currentThreadId >> 0x10 ^ currentThreadId) * -0x7a143595;
  SystemOperationStatus4 = (SystemOperationStatus4 >> QUADRANT_SHIFT_BITS ^ SystemOperationStatus4) * -0x3d4d51cb;
  SystemOperationStatus3 = (ulong long)(SystemOperationStatus4 >> 0x10 ^ SystemOperationStatus4);
  hashTableNode = (ulong long *)SystemResourceManager[6];
  for (SystemHashNodeData = hashTableNode; ResourceHash = SystemOperationStatus3, SystemHashNodeData != (ulong long *)0x0; SystemHashNodeData = (ulong long *)SystemHashNodeData[2])
  {
    while( true ) {
      ResourceHash = ResourceHash & *SystemHashNodeData - 1;
      SystemOperationStatus4 = *(uint *)(ResourceHash * 0x10 + SystemHashNodeData[1]);
      if (SystemOperationStatus4 == currentThreadId) {
        ThreadLocalStorageEntry = *(void* **)(SystemHashNodeData[1] + 8 + ResourceHash * 0x10);
        if (SystemHashNodeData == hashTableNode) {
          return ThreadLocalStorageEntry;
        }
        do {
          SystemOperationStatus3 = SystemOperationStatus3 & *hashTableNode - 1;
          if (*(int *)(hashTableNode[1] + SystemOperationStatus3 * 0x10) == 0) {
            SystemHashEntryPointer = (uint *)(hashTableNode[1] + SystemOperationStatus3 * 0x10);
            LOCK();
            isSlotEmpty = *SystemHashEntryPointer == 0;
            if (isSlotEmpty) {
              *SystemHashEntryPointer = currentThreadId;
            }
            UNLOCK();
            if (isSlotEmpty) {
              *(void* **)(hashTableNode[1] + 8 + SystemOperationStatus3 * 0x10) = ThreadLocalStorageEntry;
              return ThreadLocalStorageEntry;
            }
          }
          SystemOperationStatus3 = SystemOperationStatus3 + 1;
        } while( true );
      }
      if (SystemOperationStatus4 == 0) break;
      ResourceHash = ResourceHash + 1;
    }
  }
  LOCK();
  PrimaryResourcePointer = SystemResourceManager + 7;
  resourceCounter = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  ResourceHash = resourceCounter + 1;
  ThreadLocalStorageEntry = (void* *)0x0;
  while( true ) {
    if (*hashTableNode >> 1 <= ResourceHash) {
      LOCK();
      SystemHashEntryPointer = (uint *)(SystemResourceManager + 0x4b);
      SystemOperationStatus4 = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer | 1;
      UNLOCK();
      if ((SystemOperationStatus4 & 1) == 0) {
        SystemHashNodeData = (ulong long *)SystemResourceManager[6];
        hashTableNode = SystemHashNodeData;
        SystemSecondaryStatus = *SystemHashNodeData;
        if (*SystemHashNodeData >> 1 <= ResourceHash) {
          do {
            resourceAddress = SystemSecondaryStatus;
            SystemSecondaryStatus = resourceAddress * 2;
          } while ((resourceAddress & SINE_LOOKUP_TABLE_SIZEffffffffffff) <= ResourceHash);
          hashTableNode = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAddress * 0x20 + 0x1f,10);
          if (hashTableNode == (ulong long *)0x0) {
            LOCK();
            SystemResourceManager[7] = SystemResourceManager[7] + -1;
            UNLOCK();
            *(uint32_t *)(SystemResourceManager + 0x4b) = 0;
            return (void* *)0x0;
          }
          *hashTableNode = SystemSecondaryStatus;
          hashTableNode[1] = (ulong long)(-(int)(hashTableNode + 3) & 7) + (long long)(hashTableNode + 3);
          ThreadLocalStorage = ThreadLocalStorageEntry;
          for (; SystemSecondaryStatus != 0; SystemSecondaryStatus = SystemSecondaryStatus - 1) {
            *(void* *)((long long)ThreadLocalStorage + hashTableNode[1] + 8) = 0;
            *(uint32_t *)((long long)ThreadLocalStorage + hashTableNode[1]) = 0;
            ThreadLocalStorage = ThreadLocalStorage + 2;
          }
          hashTableNode[2] = (ulong long)SystemHashNodeData;
          SystemResourceManager[6] = (long long)hashTableNode;
        }
        *(uint32_t *)(SystemResourceManager + 0x4b) = 0;
      }
    }
    if (ResourceHash < (*hashTableNode >> 2) + (*hashTableNode >> 1)) break;
    hashTableNode = (ulong long *)SystemResourceManager[6];
  }
  ThreadLocalStorage = (void* *)*SystemResourceManager;
  while (ThreadLocalStorage != (void* *)0x0) {
    if ((*(char *)(ThreadLocalStorage + 2) != '\0') && (*(char *)(ThreadLocalStorage + 9) == '\0')) {
      isSlotEmpty = true;
      LOCK();
      isEntryAvailable = *(char *)(ThreadLocalStorage + 2) == '\x01';
      if (isEntryAvailable) {
        *(char *)(ThreadLocalStorage + 2) = '\0';
      }
      UNLOCK();
      if (isEntryAvailable) goto EntryAvailableCheck;
    }
    PrimaryResourcePointer = ThreadLocalStorage + 1;
    ThreadLocalStorage = (void* *)(*PrimaryResourcePointer + -8);
    if (*PrimaryResourcePointer == 0) {
      ThreadLocalStorage = ThreadLocalStorageEntry;
    }
  }
  isSlotEmpty = false;
  SystemThreadStorage = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x68,10);
  ThreadLocalStorage = ThreadLocalStorageEntry;
  if (SystemThreadStorage != (void* *)0x0) {
    SystemThreadStorage[1] = 0;
    *(uint8_t *)(SystemThreadStorage + 2) = 0;
    SystemThreadStorage[3] = 0;
    *SystemThreadStorage = &SystemResourceTemplateB;
    SystemThreadStorage[4] = 0;
    SystemThreadStorage[5] = 0;
    SystemThreadStorage[6] = 0;
    SystemThreadStorage[7] = 0;
    SystemThreadStorage[8] = 0;
    *(uint8_t *)(SystemThreadStorage + 9) = 0;
    SystemThreadStorage[10] = SystemResourceManager;
    *SystemThreadStorage = &SystemResourceTemplateA;
    SystemThreadStorage[0xb] = 0x20;
    SystemThreadStorage[0xc] = 0;
    ExpandSystemResourceAllocator(SystemThreadStorage);
    LOCK();
    *(int *)(SystemResourceManager + 1) = (int)SystemResourceManager[1] + 1;
    UNLOCK();
    resourceCounter = *SystemResourceManager;
    do {
      ThreadLocalStorage = (void* *)(resourceCounter + 8);
      if (resourceCounter == 0) {
        ThreadLocalStorage = ThreadLocalStorageEntry;
      }
      SystemThreadStorage[1] = ThreadLocalStorage;
      LOCK();
      SystemAllocationFlags = *SystemResourceManager;
      isEntryAvailable = resourceCounter == SystemAllocationFlags;
      if (isEntryAvailable) {
        *SystemResourceManager = (long long)SystemThreadStorage;
        SystemAllocationFlags = resourceCounter;
      }
      UNLOCK();
      resourceCounter = SystemAllocationFlags;
      ThreadLocalStorage = SystemThreadStorage;
    } while (!isEntryAvailable);
  }
EntryAvailableCheck:
  if (ThreadLocalStorage == (void* *)0x0) {
    LOCK();
    SystemResourceManager[7] = SystemResourceManager[7] + -1;
    UNLOCK();
    return (void* *)0x0;
  }
  if (isSlotEmpty) {
    LOCK();
    SystemResourceManager[7] = SystemResourceManager[7] + -1;
    UNLOCK();
  }
  do {
    SystemOperationStatus3 = SystemOperationStatus3 & *hashTableNode - 1;
    if (*(int *)(hashTableNode[1] + SystemOperationStatus3 * 0x10) == 0) {
      SystemHashEntryPointer = (uint *)(hashTableNode[1] + SystemOperationStatus3 * 0x10);
      LOCK();
      isSlotEmpty = *SystemHashEntryPointer == 0;
      if (isSlotEmpty) {
        *SystemHashEntryPointer = currentThreadId;
      }
      UNLOCK();
      if (isSlotEmpty) {
        *(void* **)(hashTableNode[1] + 8 + SystemOperationStatus3 * 0x10) = ThreadLocalStorage;
        return ThreadLocalStorage;
      }
    }
    SystemOperationStatus3 = SystemOperationStatus3 + 1;
  } while( true );
}



/**
 * @brief 系统资源管理器清理函数
 * 
 * 该函数清理系统资源管理器，初始化资源管理器指针，并根据配置标志
 * 决定是否释放资源管理器内存。用于系统资源管理的清理和回收。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针（包含清理标志）
 * @return 清理后的资源管理器指针
 * 
 *FUN_18006d450：CleanupSystemResourceManager
 */
void* CleanupSystemResourceManager(void* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  InitializeSystemResourceManager();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x68);
  }
  return SystemResourceManager;
}



void* GetSystemDataResourcePointer(ulong long* SystemResourceManager, void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *SystemHashEntryPointer;
  long long ResourceDataOffset;
  long long SystemBufferAddress;
  char operationStatusFlag;
  ulong long ResourceHash;
  ulong long ThreadContextFlag;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  ulong long SystemOperationFlags;
  ulong long SystemOperationStatus1;
  ulong long SystemSecondaryStatus;
  ulong long SystemOperationStatus3;
  
  SystemOperationStatus3 = 0;
  ThreadContextFlag = *SystemResourceManager;
  OperationCode = SystemOperationStatus3;
  SystemOperationFlags = SystemOperationStatus3;
  SystemSecondaryStatus = SystemOperationStatus3;
  do {
    ThreadContextFlag = OperationCode;
    SystemOperationStatus1 = SystemOperationFlags;
    if (ThreadContextFlag == 0) break;
    ResourceHash = *(long long *)(ThreadContextFlag + 0x20) - *(long long *)(ThreadContextFlag + 0x28);
    if ((ulong long)(*(long long *)(ThreadContextFlag + 0x28) - *(long long *)(ThreadContextFlag + 0x20)) < 0x8000000000000001)
    {
      ResourceHash = SystemOperationStatus3;
    }
    if ((ResourceHash != 0) && (SystemSecondaryStatus = SystemSecondaryStatus + 1, ThreadContextFlag = ThreadContextFlag, SystemOperationStatus1 = ResourceHash, ResourceHash <= SystemOperationFlags)) {
      ThreadContextFlag = OperationCode;
      SystemOperationStatus1 = SystemOperationFlags;
    }
    PrimaryResourcePointer = (long long *)(ThreadContextFlag + 8);
    ThreadContextFlag = *PrimaryResourcePointer - 8;
    if (*PrimaryResourcePointer == 0) {
      ThreadContextFlag = SystemOperationStatus3;
    }
    OperationCode = ThreadContextFlag;
    SystemOperationFlags = SystemOperationStatus1;
  } while (SystemSecondaryStatus < 3);
  if (SystemSecondaryStatus != 0) {
    systemStatusFlag = ManageSystemResourceAllocation(ThreadContextFlag,ConfigurationDataPointer,ThreadContextFlag,SystemOperationStatus1,InvalidHandleValue);
    if (systemStatusFlag != '\0') {
      return 1;
    }
    ThreadContextFlag = *SystemResourceManager;
    while (ThreadContextFlag != 0) {
      if (ThreadContextFlag != ThreadContextFlag) {
        if (*(char *)(ThreadContextFlag + 0x48) == '\0') {
          systemStatusFlag = GetSystemResourceHash(ThreadContextFlag,ConfigurationDataPointer);
        }
        else {
          if (0x8000000000000000 <
              (ulong long)
              ((*(long long *)(ThreadContextFlag + 0x30) - *(long long *)(ThreadContextFlag + 0x38)) -
              *(long long *)(ThreadContextFlag + 0x20))) {
            LOCK();
            PrimaryResourcePointer = (long long *)(ThreadContextFlag + 0x30);
            ResourceDataOffset = *PrimaryResourcePointer;
            *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
            UNLOCK();
            if (0x8000000000000000 <
                (ulong long)((ResourceDataOffset - *(long long *)(ThreadContextFlag + 0x20)) - *(long long *)(ThreadContextFlag + 0x38))) {
              LOCK();
              SystemHashEntryPointer = (ulong long *)(ThreadContextFlag + 0x28);
              OperationCode = *SystemHashEntryPointer;
              *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
              UNLOCK();
              PrimaryResourcePointer = *(long long **)(ThreadContextFlag + 0x58);
              SystemBufferAddress = *(long long *)
                       (PrimaryResourcePointer[2] + 8 +
                       (((OperationCode & MAX_UNSIGNED_32_BITffffffe0) - *(long long *)(PrimaryResourcePointer[2] + PrimaryResourcePointer[1] * 0x10)
                        >> 5) + PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
              OperationCode = (ulong long)((uint)OperationCode & BIT_MASK_32_BIT);
              ResourceDataOffset = OperationCode * 0x1a8 + SystemBufferAddress;
              ConfigureResourceManagerData(ConfigurationDataPointer,ResourceDataOffset);
              ReleaseSystemResource(ResourceDataOffset);
              *(uint8_t *)((SystemBufferAddress - OperationCode) + 0x352f) = 1;
              systemStatusFlag = '\x01';
              goto ResourceValidationComplete;
            }
            LOCK();
            *(long long *)(ThreadContextFlag + 0x38) = *(long long *)(ThreadContextFlag + 0x38) + 1;
            UNLOCK();
          }
          systemStatusFlag = '\0';
        }
ResourceValidationComplete:
        if (systemStatusFlag != '\0') {
          return 1;
        }
      }
      PrimaryResourcePointer = (long long *)(ThreadContextFlag + 8);
      ThreadContextFlag = *PrimaryResourcePointer - 8;
      if (*PrimaryResourcePointer == 0) {
        ThreadContextFlag = SystemOperationStatus3;
      }
    }
  }
  return 0;
}



/**
 * @brief 分配系统资源池
 * 
 * 该函数负责分配系统资源池，包括资源池的初始化、配置和状态管理
 * 用于系统资源的动态分配和回收
 * 
 * @param SystemResourceManager 系统资源管理器指针，管理资源的分配和释放
 * @param ConfigurationDataPointer 配置数据指针，包含资源池的配置信息
 * @param AdditionalParameter 额外参数，用于资源池的附加配置
 * @param ConfigurationFlag 配置标志，控制资源池的配置选项
 * @return 资源分配结果，成功返回非零值，失败返回0
 * 
 *FUN_18006d6c0：AllocateSystemResourcePool
 */
void* AllocateSystemResourcePool(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  ulong long SystemOperationStatus;
  long long *resourcePoolPointer;
  char characterProcessingFlag;
  ulong long resourceAddress;
  ulong long *SystemThreadContext;
  void* ResourceHash;
  
  ResourceHash = 0xfffffffffffffffe;
  SystemOperationStatus = *(ulong long *)(SystemResourceManager + 0x20);
  if ((SystemOperationStatus & BIT_MASK_32_BIT) != 0) {
    ProcessSystemResourceDataB((ulong long)((uint)SystemOperationStatus & BIT_MASK_32_BIT) * 0x1a8 + *(long long *)(SystemResourceManager + 0x40));
MemoryAllocationComplete:
    *(ulong long *)(SystemResourceManager + 0x20) = SystemOperationStatus + 1;
    return 1;
  }
  if ((0x8000000000000000 < (*(long long *)(SystemResourceManager + 0x28) - SystemOperationStatus) - 0x20) &&
     (resourcePoolPointer = *(long long **)(SystemResourceManager + 0x60), resourcePoolPointer != (long long *)0x0)) {
    resourceAddress = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
    SystemThreadContext = *(ulong long **)(resourcePoolPointer[3] + resourceAddress * 8);
    if ((*SystemThreadContext == 1) || (SystemThreadContext[1] == 0)) {
      *SystemThreadContext = SystemOperationStatus;
      resourcePoolPointer[1] = resourceAddress;
    }
    else {
      charFlag = GetSystemResourceStatus(SystemResourceManager);
      if (characterProcessingFlag == '\0') {
        return 0;
      }
      resourcePoolPointer = *(long long **)(SystemResourceManager + 0x60);
      resourceAddress = *resourcePoolPointer - 1U & resourcePoolPointer[1] + 1U;
      SystemThreadContext = *(ulong long **)(resourcePoolPointer[3] + resourceAddress * 8);
      *SystemThreadContext = SystemOperationStatus;
      resourcePoolPointer[1] = resourceAddress;
    }
    resourceAddress = CalculateAndFindSystemResourceManager(*(void* *)(SystemResourceManager + 0x50));
    if (resourceAddress != 0) {
      *(void* *)(resourceAddress + 0x3508) = 0;
      ProcessSystemResourceData(resourceAddress,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,ResourceHash);
      SystemThreadContext[1] = resourceAddress;
      *(ulong long *)(SystemResourceManager + 0x40) = resourceAddress;
      goto MemoryAllocationComplete;
    }
    resourcePoolPointer = *(long long **)(SystemResourceManager + 0x60);
    resourcePoolPointer[1] = *resourcePoolPointer - 1U & resourcePoolPointer[1] - 1U;
    SystemThreadContext[1] = 0;
  }
  return 0;
}



/**
 * @brief 管理系统资源分配
 * 
 * 该函数负责管理系统资源的分配，包括资源的获取、释放和状态管理
 * 用于系统资源的动态管理和优化
 * 
 * @param SystemResourceManager 系统资源管理器指针，管理资源的分配和释放
 * @param ConfigurationDataPointer 配置数据指针，包含资源管理的配置信息
 * @return 资源管理结果，成功返回非零值，失败返回0
 * 
 *FUN_18006d810：ManageSystemResourceAllocation
 */
void* ManageSystemResourceAllocation(long long SystemResourceManager,void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *SystemHashEntryPointer;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  void* ThreadContextFlag;
  ulong long OperationCode;
  
  if (*(char *)(SystemResourceManager + 0x48) == '\0') {
    ThreadContextFlag = GetSystemResourceHash();
  }
  else {
    if (0x8000000000000000 <
        (ulong long)
        ((*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x38)) -
        *(long long *)(SystemResourceManager + 0x20))) {
      LOCK();
      PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x30);
      ResourceDataOffset = *PrimaryResourcePointer;
      *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
      UNLOCK();
      if (0x8000000000000000 <
          (ulong long)((ResourceDataOffset - *(long long *)(SystemResourceManager + 0x20)) - *(long long *)(SystemResourceManager + 0x38))) {
        LOCK();
        SystemHashEntryPointer = (ulong long *)(SystemResourceManager + 0x28);
        resourceAddress = *SystemHashEntryPointer;
        *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
        UNLOCK();
        PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x58);
        localSystemPointer = PrimaryResourcePointer[2];
        SystemThreadFlags = *(long long *)
                 (localSystemPointer + 8 +
                 (((resourceAddress & MAX_UNSIGNED_32_BITffffffe0) - *(long long *)(localSystemPointer + PrimaryResourcePointer[1] * 0x10) >> 5) +
                  PrimaryResourcePointer[1] & *PrimaryResourcePointer - 1U) * 0x10);
        OperationCode = (ulong long)((uint)resourceAddress & BIT_MASK_32_BIT);
        ResourceDataOffset = OperationCode * 0x1a8 + SystemThreadFlags;
        ConfigureResourceManagerData(ConfigurationDataPointer,ResourceDataOffset,PrimaryResourcePointer,localSystemPointer,0xfffffffffffffffe,SystemThreadFlags,resourceAddress);
        ReleaseSystemResource(ResourceDataOffset);
        *(uint8_t *)((SystemThreadFlags - OperationCode) + 0x352f) = 1;
        return 1;
      }
      LOCK();
      *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + 1;
      UNLOCK();
    }
    ThreadContextFlag = 0;
  }
  return ThreadContextFlag;
}




/**
 * @brief 系统资源指针计算和查找函数
 * 
 * 该函数负责计算和查找系统资源指针，包括资源地址计算、
 * 锁定操作和偏移量处理。用于系统资源的动态管理和访问。
 * 
 * @param SystemResourceManager 系统资源指针
 * @return 计算结果或资源地址
 * 
 *FUN_18006d920：CalculateAndFindSystemResourceManager
 */
long long CalculateAndFindSystemResourceManager(long long SystemResourceManager)

{
  ulong long *SystemDataPointer;
  uint *SystemHashEntryPointer;
  uint resourceAllocationContext;
  ulong long resourceAddress;
  uint currentThreadId;
  long long SystemThreadFlags;
  long long localDataIndex;
  long long SystemMemoryAddress;
  long long resourceCounter;
  bool isByteValid0;
  
  if (*(ulong long *)(SystemResourceManager + 0x10) < *(ulong long *)(SystemResourceManager + 0x20)) {
    LOCK();
    SystemDataPointer = (ulong long *)(SystemResourceManager + 0x10);
    resourceAddress = *SystemDataPointer;
    *SystemDataPointer = *SystemDataPointer + 1;
    UNLOCK();
    if ((resourceAddress < *(ulong long *)(SystemResourceManager + 0x20)) &&
       (SystemThreadFlags = resourceAddress * 0x3548 + *(long long *)(SystemResourceManager + 0x18), SystemThreadFlags != 0)) {
      return SystemThreadFlags;
    }
  }
  SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28);
ContextValidationCheck:
  do {
    resourceCounter = SystemThreadFlags;
    if (resourceCounter == 0) {
ThreadContextComplete:
      SystemThreadFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x3548,10);
      if (SystemThreadFlags == 0) {
        return 0;
      }
      *(void* *)(SystemThreadFlags + 0x3500) = 0;
      *(void* *)(SystemThreadFlags + 0x3508) = 0;
      *(uint32_t *)(SystemThreadFlags + 0x3530) = 0;
      *(void* *)(SystemThreadFlags + 0x3538) = 0;
      *(void*2 *)(SystemThreadFlags + 0x3540) = 0x100;
      return SystemThreadFlags;
    }
    SystemHashEntryPointer = (uint *)(resourceCounter + 0x3530);
    currentThreadId = *SystemHashEntryPointer;
    if ((currentThreadId & SINE_LOOKUP_TABLE_SIZEffff) == 0) {
ThreadIdValidationCheck:
      SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28);
      goto ContextValidationCheck;
    }
    LOCK();
    resourceAllocationContext = *SystemHashEntryPointer;
    if (currentThreadId == resourceAllocationContext) {
      *SystemHashEntryPointer = currentThreadId + 1;
    }
    UNLOCK();
    if (currentThreadId != resourceAllocationContext) goto ThreadIdValidationCheck;
    LOCK();
    SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28);
    isByteValid0 = resourceCounter == SystemThreadFlags;
    if (isByteValid0) {
      *(long long *)(SystemResourceManager + 0x28) = *(long long *)(resourceCounter + 0x3538);
      SystemThreadFlags = resourceCounter;
    }
    UNLOCK();
    if (isByteValid0) {
      LOCK();
      *SystemHashEntryPointer = *SystemHashEntryPointer - 2;
      UNLOCK();
      if (resourceCounter != 0) {
        return resourceCounter;
      }
      goto LAB_18006d9f6;
    }
    LOCK();
    currentThreadId = *SystemHashEntryPointer;
    *SystemHashEntryPointer = *SystemHashEntryPointer - 1;
    UNLOCK();
    if (currentThreadId == 0x80000001) {
      SystemMemoryAddress = *(long long *)(SystemResourceManager + 0x28);
      do {
        *(long long *)(resourceCounter + 0x3538) = SystemMemoryAddress;
        *SystemHashEntryPointer = 1;
        LOCK();
        localDataIndex = *(long long *)(SystemResourceManager + 0x28);
        isByteValid0 = SystemMemoryAddress == localDataIndex;
        if (isByteValid0) {
          *(long long *)(SystemResourceManager + 0x28) = resourceCounter;
          localDataIndex = SystemMemoryAddress;
        }
        UNLOCK();
        if (isByteValid0) break;
        LOCK();
        currentThreadId = *SystemHashEntryPointer;
        *SystemHashEntryPointer = *SystemHashEntryPointer + 0x7fffffff;
        UNLOCK();
        SystemMemoryAddress = localDataIndex;
      } while (currentThreadId == 1);
    }
  } while( true );
}




// 函数: void ProcessSystemResourceDataC(long long* SystemResourceManager)
/**
 * @brief 处理系统资源数据
 * 
 * 该函数负责处理系统资源数据，包括数据的配置和管理。
 * 主要用于系统资源的动态处理。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006da50：ProcessSystemResourceDataC
 */
void ProcessSystemResourceDataC(long long* SystemResourceManager)

{
  ReleaseSystemResource((ulong long)(*(uint *)(SystemResourceManager + 1) & BIT_MASK_32_BIT) * 0x1a8 + *SystemResourceManager);
  *(uint8_t *)((*SystemResourceManager - (ulong long)(*(uint *)(SystemResourceManager + 1) & BIT_MASK_32_BIT)) + 0x352f) = 1;
  return;
}



/**
 * @brief 获取系统资源哈希值
 * 
 * 该函数负责从资源管理器中获取资源的哈希值
 * 用于资源查找和索引操作
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return ulong long 返回资源的哈希值
 * 
 *FUN_18006da90：GetSystemResourceHash
 */
ulong long GetSystemResourceHash(long long SystemResourceManager,void* ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long *SystemHashEntryPointer;
  uint *SystemHashNodeData;
  uint resourceAddress;
  long long SystemTimeValue;
  ulong long ResourceHash;
  long long localDataIndex;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  long long SystemAllocationFlags;
  ulong long SystemOperationStatus1;
  bool isByteValid2;
  
  OperationCode = (*(long long *)(SystemResourceManager + 0x30) - *(long long *)(SystemResourceManager + 0x38)) -
          *(long long *)(SystemResourceManager + 0x20);
  if (0x8000000000000000 < OperationCode) {
    LOCK();
    PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x30);
    localSystemPointer = *PrimaryResourcePointer;
    *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
    UNLOCK();
    OperationCode = *(ulong long *)(SystemResourceManager + 0x20);
    if (0x8000000000000000 < (localSystemPointer - OperationCode) - *(long long *)(SystemResourceManager + 0x38)) {
      LOCK();
      SystemHashEntryPointer = (ulong long *)(SystemResourceManager + 0x28);
      OperationCode = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
      UNLOCK();
      PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x60);
      SystemOperationStatus1 = (OperationCode & MAX_UNSIGNED_32_BITffffffe0) - **(long long **)(PrimaryResourcePointer[3] + PrimaryResourcePointer[1] * 8) >> 5;
      localSystemPointer = *(long long *)(PrimaryResourcePointer[3] + (PrimaryResourcePointer[1] + SystemOperationStatus1 & *PrimaryResourcePointer - 1U) * 8);
      ResourceHash = *(ulong long *)(localSystemPointer + 8);
      SystemAllocationFlags = (ulong long)((uint)OperationCode & BIT_MASK_32_BIT) * 0x1a8 + ResourceHash;
      localDataIndex = *(long long *)(SystemResourceManager + 0x50);
      ConfigureResourceManagerData(ConfigurationDataPointer,SystemAllocationFlags,SystemOperationStatus1,PrimaryResourcePointer,0xfffffffffffffffe,ResourceHash,OperationCode,localSystemPointer);
      ReleaseSystemResource(SystemAllocationFlags);
      LOCK();
      SystemHashEntryPointer = (ulong long *)(ResourceHash + 0x3508);
      OperationCode = *SystemHashEntryPointer;
      *SystemHashEntryPointer = *SystemHashEntryPointer + 1;
      UNLOCK();
      if (OperationCode == 0x1f) {
        *(void* *)(localSystemPointer + 8) = 0;
        LOCK();
        SystemHashNodeData = (uint *)(ResourceHash + 0x3530);
        resourceAddress = *SystemHashNodeData;
        *SystemHashNodeData = *SystemHashNodeData + 0x80000000;
        UNLOCK();
        OperationCode = (ulong long)resourceAddress;
        if (resourceAddress == 0) {
          SystemOperationStatus1 = *(ulong long *)(localDataIndex + 0x28);
          do {
            *(ulong long *)(ResourceHash + 0x3538) = SystemOperationStatus1;
            *(uint32_t *)(ResourceHash + 0x3530) = 1;
            SystemHashEntryPointer = (ulong long *)(localDataIndex + 0x28);
            LOCK();
            ThreadContextFlag = *SystemHashEntryPointer;
            isByteValid2 = SystemOperationStatus1 == ThreadContextFlag;
            if (isByteValid2) {
              *SystemHashEntryPointer = ResourceHash;
              ThreadContextFlag = SystemOperationStatus1;
            }
            UNLOCK();
            OperationCode = ThreadContextFlag;
            if (isByteValid2) break;
            LOCK();
            SystemHashNodeData = (uint *)(ResourceHash + 0x3530);
            resourceAddress = *SystemHashNodeData;
            OperationCode = (ulong long)resourceAddress;
            *SystemHashNodeData = *SystemHashNodeData + 0x7fffffff;
            UNLOCK();
            SystemOperationStatus1 = ThreadContextFlag;
          } while (resourceAddress == 1);
        }
      }
      return CONCAT71((int7)(OperationCode >> 8),1);
    }
    LOCK();
    *(long long *)(SystemResourceManager + 0x38) = *(long long *)(SystemResourceManager + 0x38) + 1;
    UNLOCK();
  }
  return OperationCode & MAX_UNSIGNED_32_BITffffff00;
}




// 函数: void CleanupSystemResourceDataB(long long* SystemResourceManager)
/**
 * @brief 清理系统资源数据
 * 
 * 该函数负责清理系统资源数据，释放资源并重置状态。
 * 主要用于系统资源的清理和内存回收。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18006dc10：CleanupSystemResourceDataB
 */
void CleanupSystemResourceDataB(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  int NodeIdentifierComparisonResult;
  long long SystemBufferAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  long long localDataIndex;
  bool isConfigValid;
  
  ReleaseSystemResource((ulong long)(*(uint *)(SystemResourceManager + 1) & BIT_MASK_32_BIT) * 0x1a8 + *SystemResourceManager);
  LOCK();
  PrimaryResourcePointer = (long long *)(*SystemResourceManager + 0x3508);
  SystemBufferAddress = *PrimaryResourcePointer;
  *PrimaryResourcePointer = *PrimaryResourcePointer + 1;
  UNLOCK();
  if (SystemBufferAddress == 0x1f) {
    *(void* *)(SystemResourceManager[2] + 8) = 0;
    SystemBufferAddress = *SystemResourceManager;
    localSystemPointer = SystemResourceManager[3];
    LOCK();
    pointerToInteger2 = (int *)(SystemBufferAddress + 0x3530);
    systemCounter = *pointerToInteger2;
    *pointerToInteger2 = *pointerToInteger2 + -0x80000000;
    UNLOCK();
    if (systemCounter == 0) {
      localDataIndex = *(long long *)(localSystemPointer + 0x28);
      do {
        *(long long *)(SystemBufferAddress + 0x3538) = localDataIndex;
        *(uint32_t *)(SystemBufferAddress + 0x3530) = 1;
        PrimaryResourcePointer = (long long *)(localSystemPointer + 0x28);
        LOCK();
        SystemThreadFlags = *PrimaryResourcePointer;
        isConfigValid = localDataIndex == SystemThreadFlags;
        if (isConfigValid) {
          *PrimaryResourcePointer = SystemBufferAddress;
          SystemThreadFlags = localDataIndex;
        }
        UNLOCK();
        if (isConfigValid) {
          return;
        }
        LOCK();
        pointerToInteger2 = (int *)(SystemBufferAddress + 0x3530);
        systemCounter = *pointerToInteger2;
        *pointerToInteger2 = *pointerToInteger2 + 0x7fffffff;
        UNLOCK();
        localDataIndex = SystemThreadFlags;
      } while (systemCounter == 1);
    }
  }
  return;
}



/**
 * @brief 配置资源管理器数据函数
 * 
 * 该函数负责配置资源管理器的数据结构和参数，包括字符串模板、
 * 哈希条目状态、数据索引和各种配置参数的设置。用于系统资源管理的数据初始化。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置结果状态码
 * 
 *FUN_18006dcb0：ConfigureResourceManagerData
 */
long long ConfigureResourceManagerData(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  void** SystemHashEntryPointer;
  
  *(uint32_t *)(SystemResourceManager + 0x10) = *(uint32_t *)(ConfigurationDataPointer + 0x10);
  SystemHashEntryPointer = &SystemStringTemplate;
  if (*(void* **)(ConfigurationDataPointer + 8) != (void* *)0x0) {
    SystemHashEntryPointer = *(void* **)(ConfigurationDataPointer + 8);
  }
  strcpy_s(*(void* *)(SystemResourceManager + 8),0x100,SystemHashEntryPointer);
  *(void* *)(SystemResourceManager + 0x118) = *(void* *)(ConfigurationDataPointer + 0x118);
  resourceDataIndex = SystemResourceManager + 0x148;
  *(void* *)(SystemResourceManager + 0x120) = *(void* *)(ConfigurationDataPointer + 0x120);
  *(void* *)(SystemResourceManager + 0x128) = *(void* *)(ConfigurationDataPointer + 0x128);
  *(void* *)(SystemResourceManager + 0x130) = *(void* *)(ConfigurationDataPointer + 0x130);
  *(void* *)(SystemResourceManager + 0x138) = *(void* *)(ConfigurationDataPointer + 0x138);
  *(uint8_t *)(SystemResourceManager + 0x140) = *(uint8_t *)(ConfigurationDataPointer + 0x140);
  if (resourceDataIndex != ConfigurationDataPointer + 0x148) {
    if (*(code **)(SystemResourceManager + 0x158) != (code *)0x0) {
      (**(code **)(SystemResourceManager + 0x158))(resourceDataIndex,0,0);
    }
    UpdateSystemConfigurationData(resourceDataIndex,ConfigurationDataPointer + 0x148);
  }
  resourceDataIndex = SystemResourceManager + 0x168;
  if (resourceDataIndex != ConfigurationDataPointer + 0x168) {
    if (*(code **)(SystemResourceManager + 0x178) != (code *)0x0) {
      (**(code **)(SystemResourceManager + 0x178))(resourceDataIndex,0,0);
    }
    UpdateSystemConfigurationData(resourceDataIndex,ConfigurationDataPointer + 0x168);
  }
  *(void* *)(SystemResourceManager + 0x188) = *(void* *)(ConfigurationDataPointer + 0x188);
  *(void* *)(SystemResourceManager + 400) = *(void* *)(ConfigurationDataPointer + 400);
  *(void* *)(SystemResourceManager + 0x198) = *(void* *)(ConfigurationDataPointer + 0x198);
  *(void* *)(SystemResourceManager + 0x1a0) = *(void* *)(ConfigurationDataPointer + 0x1a0);
  return SystemResourceManager;
}



/**
 * @brief 使用哈希节点初始化系统内存分配器
 * 
 * 该函数负责使用哈希节点初始化系统内存分配器，包括内存分配、
 * 哈希节点设置和字符串处理。主要用于系统内存管理的基础操作。
 * 
 * @param SystemResourceManager 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @param ConfigurationFlag 配置标志，用于控制初始化行为
 * @return 返回初始化后的资源管理器指针
 * 
 *FUN_18006de00：InitializeSystemMemoryAllocatorWithHashNodes
 */
long long *
InitializeSystemMemoryAllocatorWithHashNodes(long long* SystemResourceManager,void* *ConfigurationDataPointer,void* *AdditionalParameter,void* *ConfigurationFlag)

{
  void** SystemDataPointer;
  code *SystemStringPointer;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  
  *SystemResourceManager = (long long)ConfigurationFlag;
  if (ConfigurationDataPointer != AdditionalParameter) {
    SystemHashNodeData = ConfigurationDataPointer + 0x2b;
    do {
      *ConfigurationFlag = &SystemMemoryAllocatorReference;
      ConfigurationFlag[1] = 0;
      *(uint32_t *)(ConfigurationFlag + 2) = 0;
      *ConfigurationFlag = &SystemMemoryAllocatorTemplate;
      ConfigurationFlag[1] = ConfigurationFlag + 3;
      *(uint32_t *)(ConfigurationFlag + 2) = 0;
      *(uint8_t *)(ConfigurationFlag + 3) = 0;
      *(uint32_t *)(ConfigurationFlag + 2) = *(uint32_t *)(SystemHashNodeData + -0x29);
      presourceAddress = &SystemStringTemplate;
      if ((void* *)SystemHashNodeData[-0x2a] != (void* *)0x0) {
        presourceAddress = (void* *)SystemHashNodeData[-0x2a];
      }
      strcpy_s(ConfigurationFlag[1],0x100,presourceAddress);
      ConfigurationFlag[0x23] = SystemHashNodeData[-8];
      ConfigurationFlag[0x24] = SystemHashNodeData[-7];
      ConfigurationFlag[0x25] = SystemHashNodeData[-6];
      ConfigurationFlag[0x26] = SystemHashNodeData[-5];
      ConfigurationFlag[0x27] = SystemHashNodeData[-4];
      *(uint8_t *)(ConfigurationFlag + 0x28) = *(uint8_t *)(SystemHashNodeData + -3);
      ConfigurationFlag[0x2b] = 0;
      ConfigurationFlag[0x2c] = _guard_check_icall;
      if (ConfigurationFlag + 0x29 != SystemHashNodeData + -2) {
        pSystemOperationResult = (code *)*SystemHashNodeData;
        if (SystemStringPointer != (code *)0x0) {
          (*pSystemOperationResult)(ConfigurationFlag + 0x29,SystemHashNodeData + -2,2);
          pSystemOperationResult = (code *)*SystemHashNodeData;
        }
        ConfigurationFlag[0x2b] = pSystemOperationResult;
        ConfigurationFlag[0x2c] = SystemHashNodeData[1];
        *SystemHashNodeData = 0;
        SystemHashNodeData[1] = _guard_check_icall;
      }
      ConfigurationFlag[0x2f] = 0;
      ConfigurationFlag[0x30] = _guard_check_icall;
      if (ConfigurationFlag + 0x2d != SystemHashNodeData + 2) {
        pSystemOperationResult = (code *)SystemHashNodeData[4];
        if (SystemStringPointer != (code *)0x0) {
          (*pSystemOperationResult)(ConfigurationFlag + 0x2d,SystemHashNodeData + 2,2);
          pSystemOperationResult = (code *)SystemHashNodeData[4];
        }
        ConfigurationFlag[0x2f] = pSystemOperationResult;
        ConfigurationFlag[0x30] = SystemHashNodeData[5];
        SystemHashNodeData[4] = 0;
        SystemHashNodeData[5] = _guard_check_icall;
      }
      ConfigurationFlag[0x31] = SystemHashNodeData[6];
      ConfigurationFlag[0x32] = SystemHashNodeData[7];
      ConfigurationFlag[0x33] = SystemHashNodeData[8];
      ConfigurationFlag[0x34] = SystemHashNodeData[9];
      *SystemResourceManager = *SystemResourceManager + 0x1a8;
      ConfigurationFlag = (void* *)*SystemResourceManager;
      SystemDataPointer = SystemHashNodeData + 10;
      SystemHashNodeData = SystemHashNodeData + 0x35;
    } while (SystemDataPointer != AdditionalParameter);
  }
  return SystemResourceManager;
}



/**
 * @brief 创建系统资源池
 * 
 * 该函数负责创建系统资源池，分配内存并初始化资源池结构
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return long long* 返回创建的资源池指针
 * 
 *FUN_18006e000：CreateSystemResourcePool
 */
long long * CreateSystemResourcePool(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  long long *resourcePoolPointer;
  long long *SystemResourceOffsetPointer;
  ulong long resourceAddress;
  long long *SystemLocalContextPointer;
  
  SystemLocalContextPointer = *(long long **)(SystemResourceManager + 0x318);
  resourceAddress = ConfigurationDataPointer + 0xfU & MAX_UNSIGNED_32_BITfffffff0;
  SystemResourceOffsetPointer = (long long *)0x0;
  resourcePoolPointer = (long long *)SystemLocalContextPointer[3];
  if (resourcePoolPointer != (long long *)0x0) {
    do {
      if ((((char)resourcePoolPointer[4] == '\0') && (resourceAddress <= (ulong long)resourcePoolPointer[1])) &&
         ((SystemResourceOffsetPointer == (long long *)0x0 || ((ulong long)resourcePoolPointer[1] < (ulong long)SystemResourceOffsetPointer[1])))) {
        SystemResourceOffsetPointer = resourcePoolPointer;
      }
      resourcePoolPointer = (long long *)resourcePoolPointer[2];
    } while (resourcePoolPointer != (long long *)0x0);
    if (SystemResourceOffsetPointer != (long long *)0x0) {
      if (resourceAddress < (ulong long)SystemResourceOffsetPointer[1]) {
        resourcePoolPointer = (long long *)CreateResourcePoolPointer(SystemLocalContextPointer + 4);
        *(uint8_t *)(resourcePoolPointer + 4) = 0;
        *resourcePoolPointer = *SystemResourceOffsetPointer + resourceAddress;
        resourcePoolPointer[1] = SystemResourceOffsetPointer[1] - resourceAddress;
        resourceDataIndex = SystemResourceOffsetPointer[2];
        resourcePoolPointer[2] = resourceDataIndex;
        if (resourceDataIndex != 0) {
          *(long long **)(resourceDataIndex + 0x18) = resourcePoolPointer;
        }
        SystemResourceOffsetPointer[2] = (long long)resourcePoolPointer;
        resourcePoolPointer[3] = (long long)SystemResourceOffsetPointer;
        SystemResourceOffsetPointer[1] = resourceAddress;
      }
      *(uint8_t *)(SystemResourceOffsetPointer + 4) = 1;
      *SystemLocalContextPointer = *SystemLocalContextPointer + resourceAddress;
      SystemLocalContextPointer[2] = SystemLocalContextPointer[2] - resourceAddress;
      return SystemResourceOffsetPointer;
    }
  }
  return (long long *)0x0;
}



/**
 * @brief 清理资源管理器函数
 * 
 * 该函数负责清理资源管理器的所有资源，包括销毁互斥锁、条件变量、
 * 释放系统资源和根据配置标志决定是否释放内存。用于系统资源的清理和回收。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针（包含清理标志）
 * @return 清理后的资源管理器指针
 * 
 *FUN_18006e0b0：CleanupResourceManager
 */
long long CleanupResourceManager(long long SystemResourceManager,ulong long ConfigurationDataPointer)

{
  CleanupSystemResourceArray();
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  CleanupSystemResourceManagers(SystemResourceManager + 200);
  ReleaseSystemResources(SystemResourceManager);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x408);
  }
  return SystemResourceManager;
}





/**
 * @brief 初始化系统线程对象函数
 * 
 * 该函数负责创建和初始化系统线程对象，设置线程对象的各个字段和参数，
 * 包括内存指针、计数器、缓冲区大小等。用于系统线程管理的前期准备工作。
 * 
 * @return 初始化结果指针，失败时返回0
 * 
 *FUN_18006e140：InitializeSystemThreadObject
 */
void* InitializeSystemThreadObject(void)

{
  long long resourceDataIndex;
  
  resourceDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x45ee8,10);
  if (resourceDataIndex == 0) {
    return;
  }
  *(void* *)(resourceDataIndex + 0x3500) = 0;
  *(void* *)(resourceDataIndex + 0x3508) = 0;
  *(uint32_t *)(resourceDataIndex + 0x3530) = 0;
  *(void* *)(resourceDataIndex + 0x3538) = 0;
  *(void*2 *)(resourceDataIndex + 0x3540) = 0x100;
  *(void* *)(resourceDataIndex + 0x6a48) = 0;
  *(void* *)(resourceDataIndex + 0x6a50) = 0;
  *(uint32_t *)(resourceDataIndex + 0x6a78) = 0;
  *(void* *)(resourceDataIndex + 0x6a80) = 0;
  *(void*2 *)(resourceDataIndex + 0x6a88) = 0x100;
  *(void* *)(resourceDataIndex + 0x9f90) = 0;
  *(void* *)(resourceDataIndex + 0x9f98) = 0;
  *(uint32_t *)(resourceDataIndex + 0x9fc0) = 0;
  *(void* *)(resourceDataIndex + 0x9fc8) = 0;
  *(void*2 *)(resourceDataIndex + 0x9fd0) = 0x100;
  *(void* *)(resourceDataIndex + 0xd4d8) = 0;
  *(void* *)(resourceDataIndex + 0xd4e0) = 0;
  *(uint32_t *)(resourceDataIndex + 0xd508) = 0;
  *(void* *)(resourceDataIndex + 0xd510) = 0;
  *(void*2 *)(resourceDataIndex + 0xd518) = 0x100;
  *(void* *)(resourceDataIndex + 0x10a20) = 0;
  *(void* *)(resourceDataIndex + 0x10a28) = 0;
  *(uint32_t *)(resourceDataIndex + 0x10a50) = 0;
  *(void* *)(resourceDataIndex + 0x10a58) = 0;
  *(void*2 *)(resourceDataIndex + 0x10a60) = 0x100;
  *(void* *)(resourceDataIndex + 0x13f68) = 0;
  *(void* *)(resourceDataIndex + 0x13f70) = 0;
  *(uint32_t *)(resourceDataIndex + 0x13f98) = 0;
  *(void* *)(resourceDataIndex + 0x13fa0) = 0;
  *(void*2 *)(resourceDataIndex + 0x13fa8) = 0x100;
  *(void* *)(resourceDataIndex + 0x174b0) = 0;
  *(void* *)(resourceDataIndex + 0x174b8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x174e0) = 0;
  *(void* *)(resourceDataIndex + 0x174e8) = 0;
  *(void*2 *)(resourceDataIndex + 0x174f0) = 0x100;
  *(void* *)(resourceDataIndex + 0x1a9f8) = 0;
  *(void* *)(resourceDataIndex + 0x1aa00) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1aa28) = 0;
  *(void* *)(resourceDataIndex + 0x1aa30) = 0;
  *(void*2 *)(resourceDataIndex + 0x1aa38) = 0x100;
  *(void* *)(resourceDataIndex + 0x1df40) = 0;
  *(void* *)(resourceDataIndex + 0x1df48) = 0;
  *(uint32_t *)(resourceDataIndex + 0x1df70) = 0;
  *(void* *)(resourceDataIndex + 0x1df78) = 0;
  *(void*2 *)(resourceDataIndex + 0x1df80) = 0x100;
  *(void* *)(resourceDataIndex + 0x21488) = 0;
  *(void* *)(resourceDataIndex + 0x21490) = 0;
  *(uint32_t *)(resourceDataIndex + 0x214b8) = 0;
  *(void* *)(resourceDataIndex + 0x214c0) = 0;
  *(void*2 *)(resourceDataIndex + 0x214c8) = 0x100;
  *(void* *)(resourceDataIndex + 0x249d0) = 0;
  *(void* *)(resourceDataIndex + 0x249d8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x24a00) = 0;
  *(void* *)(resourceDataIndex + 0x24a08) = 0;
  *(void*2 *)(resourceDataIndex + 0x24a10) = 0x100;
  *(void* *)(resourceDataIndex + 0x27f18) = 0;
  *(void* *)(resourceDataIndex + 0x27f20) = 0;
  *(uint32_t *)(resourceDataIndex + 0x27f48) = 0;
  *(void* *)(resourceDataIndex + 0x27f50) = 0;
  *(void*2 *)(resourceDataIndex + 0x27f58) = 0x100;
  *(void* *)(resourceDataIndex + 0x2b460) = 0;
  *(void* *)(resourceDataIndex + 0x2b468) = 0;
  *(uint32_t *)(resourceDataIndex + 0x2b490) = 0;
  *(void* *)(resourceDataIndex + 0x2b498) = 0;
  *(void*2 *)(resourceDataIndex + 0x2b4a0) = 0x100;
  *(void* *)(resourceDataIndex + 0x2e9a8) = 0;
  *(void* *)(resourceDataIndex + 0x2e9b0) = 0;
  *(uint32_t *)(resourceDataIndex + 0x2e9d8) = 0;
  *(void* *)(resourceDataIndex + 0x2e9e0) = 0;
  *(void*2 *)(resourceDataIndex + 0x2e9e8) = 0x100;
  *(void* *)(resourceDataIndex + 0x31ef0) = 0;
  *(void* *)(resourceDataIndex + 0x31ef8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x31f20) = 0;
  *(void* *)(resourceDataIndex + 0x31f28) = 0;
  *(void*2 *)(resourceDataIndex + 0x31f30) = 0x100;
  *(void* *)(resourceDataIndex + 0x35438) = 0;
  *(void* *)(resourceDataIndex + 0x35440) = 0;
  *(uint32_t *)(resourceDataIndex + 0x35468) = 0;
  *(void* *)(resourceDataIndex + 0x35470) = 0;
  *(void*2 *)(resourceDataIndex + 0x35478) = 0x100;
  *(void* *)(resourceDataIndex + 0x38980) = 0;
  *(void* *)(resourceDataIndex + 0x38988) = 0;
  *(uint32_t *)(resourceDataIndex + 0x389b0) = 0;
  *(void* *)(resourceDataIndex + 0x389b8) = 0;
  *(void*2 *)(resourceDataIndex + 0x389c0) = 0x100;
  *(void* *)(resourceDataIndex + 0x3bec8) = 0;
  *(void* *)(resourceDataIndex + 0x3bed0) = 0;
  *(uint32_t *)(resourceDataIndex + 0x3bef8) = 0;
  *(void* *)(resourceDataIndex + 0x3bf00) = 0;
  *(void*2 *)(resourceDataIndex + 0x3bf08) = 0x100;
  *(void* *)(resourceDataIndex + 0x3f410) = 0;
  *(void* *)(resourceDataIndex + 0x3f418) = 0;
  *(uint32_t *)(resourceDataIndex + 0x3f440) = 0;
  *(void* *)(resourceDataIndex + 0x3f448) = 0;
  *(void*2 *)(resourceDataIndex + 0x3f450) = 0x100;
  *(void* *)(resourceDataIndex + 0x42958) = 0;
  *(void* *)(resourceDataIndex + 0x42960) = 0;
  *(uint32_t *)(resourceDataIndex + 0x42988) = 0;
  *(void* *)(resourceDataIndex + 0x42990) = 0;
  *(void*2 *)(resourceDataIndex + 0x42998) = 0x100;
  *(void* *)(resourceDataIndex + 0x45ea0) = 0;
  *(void* *)(resourceDataIndex + 0x45ea8) = 0;
  *(uint32_t *)(resourceDataIndex + 0x45ed0) = 0;
  *(void* *)(resourceDataIndex + 0x45ed8) = 0;
  *(void*2 *)(resourceDataIndex + 0x45ee0) = 0x100;
  return;
}



/**
 * @brief 初始化系统资源模板
 * 
 * 该函数负责初始化系统资源模板，设置资源管理器的模板数据
 * 用于系统资源的初始化和配置
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于初始化资源模板
 * @param ConfigurationDataPointer 配置数据指针，包含模板的配置信息
 * @return 系统资源管理器指针，返回初始化后的资源管理器
 * 
 *FUN_18006e460：InitializeSystemResourceTemplate
 */
void* * InitializeSystemResourceTemplate(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemResourceTemplateB;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x58);
  }
  return SystemResourceManager;
}




/**
 * @brief 清理资源管理器指针函数
 * 
 * 该函数负责清理资源管理器的指针和数据结构，包括哈希节点、
 * 字符串处理指针、缓冲区地址等。用于系统资源管理器的内存清理。
 * 
 * @param SystemResourceManager 资源管理器指针
 * 
 *FUN_18006e4a0：CleanupSystemResourceManagers
 */
void CleanupSystemResourceManagers(long long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  char *SystemStringPointer;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  
  SystemHashNodeData = (void* *)*SystemResourceManager;
  if (SystemHashNodeData != (void* *)0x0) {
    if ((void* *)SystemHashNodeData[3] != (void* *)0x0) {
      *(void* *)SystemHashNodeData[3] = 0;
    }
    (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemCleanupFunction(SystemHashNodeData);
  }
  if ((SystemResourceManager[6] != 0) && (*(long long *)(SystemResourceManager[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = SystemResourceManager[5];
  while (SystemBufferAddress != 0) {
    pSystemOperationResult = (char *)(SystemBufferAddress + 0x3541);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x3538);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = (void* *)SystemResourceManager[3];
  if (SystemHashNodeData == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
  if (currentThreadId != 0) {
    SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
    SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
      *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
      *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
      SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          SystemHashNodeData,currentThreadId,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 清理资源管理器扩展指针函数
 * 
 * 该函数负责清理资源管理器的扩展指针和数据结构，包括哈希节点、
 * 字符串处理指针、缓冲区地址等。用于系统资源管理器的扩展内存清理。
 * 
 * @param SystemResourceManager 资源管理器指针
 * 
 *FUN_18006e4a4：CleanupResourceManagerExtendedPointers
 */
void CleanupResourceManagerExtendedPointers(long long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  char *SystemStringPointer;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  
  SystemHashNodeData = (void* *)*SystemResourceManager;
  if (SystemHashNodeData != (void* *)0x0) {
    if ((void* *)SystemHashNodeData[3] != (void* *)0x0) {
      *(void* *)SystemHashNodeData[3] = 0;
    }
    (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemCleanupFunction(SystemHashNodeData);
  }
  if ((SystemResourceManager[6] != 0) && (*(long long *)(SystemResourceManager[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = SystemResourceManager[5];
  while (SystemBufferAddress != 0) {
    pSystemOperationResult = (char *)(SystemBufferAddress + 0x3541);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x3538);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = (void* *)SystemResourceManager[3];
  if (SystemHashNodeData == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
  if (currentThreadId != 0) {
    SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
    SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
      *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
      *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
      SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          SystemHashNodeData,currentThreadId,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 重置系统内存块状态
 * 
 * 该函数负责重置系统内存块的状态，清理相关资源
 * 用于系统内存管理中的状态重置操作
 */
void ResetSystemMemoryBlockState(void)

{
  void* *memoryBlockAddress;
  
  if ((void* *)memoryBlockAddress[3] != (void* *)0x0) {
    *(void* *)memoryBlockAddress[3] = 0;
  }
  (**(code **)*memoryBlockAddress)();
  SystemCleanupFunction();
}




/**
 * @brief 清理系统字符串迭代器资源
 * 
 * 该函数负责清理系统字符串迭代器的相关资源，包括哈希节点和缓冲区
 * 用于系统字符串管理中的资源清理操作
 */
void CleanupSystemStringIteratorResources(void)

{
  int *resourceReferenceCount;
  char *SystemStringPointer;
  void* *hashNodePointer;
  long long SystemBufferAddress;
  long long StringIteratorPointer;
  ulong long currentThreadId;
  
  if ((*(long long *)(StringIteratorPointer + 0x30) != 0) &&
     (*(long long *)(*(long long *)(StringIteratorPointer + 0x30) + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = *(long long *)(StringIteratorPointer + 0x28);
  while (SystemBufferAddress != 0) {
    SystemStringPointer = (char *)(SystemBufferAddress + 0x3541);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x3538);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  hashNodePointer = *(void* **)(StringIteratorPointer + 0x18);
  if (hashNodePointer != (void* *)0x0) {
    currentThreadId = (ulong long)hashNodePointer & MAX_UNSIGNED_32_BITffc00000;
    if (currentThreadId != 0) {
      SystemBufferAddress = currentThreadId + 0x80 + ((long long)hashNodePointer - currentThreadId >> 0x10) * 0x50;
      SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
      if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
        *hashNodePointer = *(void* *)(SystemBufferAddress + 0x20);
        *(void* **)(SystemBufferAddress + 0x20) = hashNodePointer;
        resourceReferenceCount = (int *)(SystemBufferAddress + 0x18);
        *resourceReferenceCount = *resourceReferenceCount + -1;
        if (*resourceReferenceCount == 0) {
          ReleaseSystemResource();
          return;
        }
      }
      else {
        SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                            hashNodePointer,currentThreadId,InvalidHandleValue);
      }
    }
    return;
  }
  return;
}




/**
 * @brief 系统资源释放管理器
 * 
 * 该函数负责管理系统资源的释放，包括资源引用计数的管理和资源释放操作
 * 当资源引用计数降为0时，会调用系统资源释放函数来清理资源
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * 
 *FUN_18006e570：ReleaseSystemResourceManager
 */
void ReleaseSystemResourceManager(void* *SystemResourceManager)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  ulong long resourceAllocationContext;
  
  resourceAllocationContext = (ulong long)SystemResourceManager & MAX_UNSIGNED_32_BITffc00000;
  if (resourceAllocationContext != 0) {
    SystemThreadHandle = resourceAllocationContext + 0x80 + ((long long)SystemResourceManager - resourceAllocationContext >> 0x10) * 0x50;
    SystemThreadHandle = SystemThreadHandle - (ulong long)*(uint *)(SystemThreadHandle + 4);
    if ((*(void ***)(resourceAllocationContext + 0x70) == &ExceptionList) && (*(char *)(SystemThreadHandle + 0xe) == '\0')) {
      *SystemResourceManager = *(void* *)(SystemThreadHandle + 0x20);
      *(void* **)(SystemThreadHandle + 0x20) = SystemResourceManager;
      SystemIntegerPointer = (int *)(SystemThreadHandle + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAllocationContext,CONCAT71(0xff000000,*(void ***)(resourceAllocationContext + 0x70) == &ExceptionList),
                          SystemResourceManager,resourceAllocationContext,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 系统资源清理和销毁函数
 * 
 * 该函数负责系统资源的清理和销毁操作，包括互斥锁、条件变量的销毁
 * 以及哈希节点的清理和系统内存的释放
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * 
 *FUN_18006e580：DestroySystemResources
 */
void DestroySystemResources(long long* SystemResourceManager)

{
  int* SystemIntegerPointer;
  char *SystemStringPointer;
  void* *SystemHashNodeData;
  long long SystemBufferAddress;
  ulong long currentThreadId;
  
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  SystemHashNodeData = (void* *)*SystemResourceManager;
  if (SystemHashNodeData != (void* *)0x0) {
    if ((void* *)SystemHashNodeData[3] != (void* *)0x0) {
      *(void* *)SystemHashNodeData[3] = 0;
    }
    (**(code **)*SystemHashNodeData)(SystemHashNodeData,0);
      SystemCleanupFunction(SystemHashNodeData);
  }
  if ((SystemResourceManager[6] != 0) && (*(long long *)(SystemResourceManager[6] + 0x10) != 0)) {
      SystemCleanupFunction();
  }
  SystemBufferAddress = SystemResourceManager[5];
  while (SystemBufferAddress != 0) {
    pSystemOperationResult = (char *)(SystemBufferAddress + 0x3541);
    SystemBufferAddress = *(long long *)(SystemBufferAddress + 0x3538);
    if (*SystemStringPointer != '\0') {
        SystemCleanupFunction();
    }
  }
  SystemHashNodeData = (void* *)SystemResourceManager[3];
  if (SystemHashNodeData == (void* *)0x0) {
    return;
  }
  currentThreadId = (ulong long)SystemHashNodeData & MAX_UNSIGNED_32_BITffc00000;
  if (currentThreadId != 0) {
    SystemBufferAddress = currentThreadId + 0x80 + ((long long)SystemHashNodeData - currentThreadId >> 0x10) * 0x50;
    SystemBufferAddress = SystemBufferAddress - (ulong long)*(uint *)(SystemBufferAddress + 4);
    if ((*(void ***)(currentThreadId + 0x70) == &ExceptionList) && (*(char *)(SystemBufferAddress + 0xe) == '\0')) {
      *SystemHashNodeData = *(void* *)(SystemBufferAddress + 0x20);
      *(void* **)(SystemBufferAddress + 0x20) = SystemHashNodeData;
      SystemIntegerPointer = (int *)(SystemBufferAddress + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(currentThreadId,CONCAT71(0xff000000,*(void ***)(currentThreadId + 0x70) == &ExceptionList),
                          SystemHashNodeData,currentThreadId,InvalidHandleValue);
    }
  }
  return;
}




// 函数: void CleanupSystemResourceArray(long long* SystemResourceManager)
/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，遍历资源链表并逐个清理每个资源项。
 * 使用固定步长0x1a8遍历资源，最后调用系统清理函数完成清理工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源数组
 * 
 *FUN_18006e5d0：CleanupSystemResourceArray
 */
void CleanupSystemResourceArray(long long* SystemResourceManager)

{
  long long resourceEndIndex;
  long long currentResourceHandle;
  
  resourceEndIndex = SystemResourceManager[1];
  for (currentResourceHandle = *SystemResourceManager; currentResourceHandle != resourceEndIndex; currentResourceHandle = currentResourceHandle + 0x1a8) {
    CleanupSystemResourceItem(currentResourceHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




// 函数: void ValidateSystemResourceArray(long long* SystemResourceManager)
/**
 * @brief 系统资源批量清理函数
 * 
 * 该函数负责批量清理系统资源，遍历资源链表并逐个清理每个资源项。
 * 使用固定步长0x1a8遍历资源，最后调用系统清理函数完成清理工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源数组
 * 
 *FUN_18006e640：CleanupSystemResourceBatch
 */
void CleanupSystemResourceBatch(long long* SystemResourceManager)

{
  long long resourceEndIndex;
  long long currentResourceHandle;
  
  resourceEndIndex = SystemResourceManager[1];
  for (currentResourceHandle = *SystemResourceManager; currentResourceHandle != resourceEndIndex; currentResourceHandle = currentResourceHandle + 0x1a8) {
    CleanupSystemResourceItem(currentResourceHandle);
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}



/**
 * @brief 初始化系统资源管理器和数据表
 * 
 * 该函数负责初始化系统资源管理器和数据表，包括：
 * - 设置数据表管理器
 * - 初始化资源管理器指针数组
 * - 配置资源条目和缓冲区
 * - 初始化互斥锁和条件变量
 * - 设置系统资源参数和标志
 * 
 * @param SystemResourceManager 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @return 返回初始化后的资源管理器指针
 * 
 *FUN_18006e660：InitializeSystemResourceManagerAndDataTable
 */
void* * InitializeSystemResourceManagerAndDataTable(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter)

{
  ulong long SystemOperationStatus;
  ulong long resourceCreationFlags;
  ulong long resourceAllocationContext;
  long long SystemBufferAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  long long localDataIndex;
  
  InitializeSystemDataTableManager();
  *SystemResourceManager = &SystemDataTableTemplate;
  SystemResourceManager[0x19] = 0;
  *(uint32_t *)(SystemResourceManager + 0x1a) = 0;
  SystemResourceManager[0x1b] = 0;
  SystemResourceManager[0x1e] = 0;
  resourceEntryPointer = SystemResourceManager + 0x24;
  localDataIndex = 0x20;
  SystemBufferAddress = 0x20;
  SystemThreadContext = resourceEntryPointer;
  do {
    SystemResourceCleanup(SystemThreadContext);
    SystemThreadContext = SystemThreadContext + 2;
    SystemBufferAddress = SystemBufferAddress + -1;
  } while (SystemBufferAddress != 0);
  resourceCreationFlags = 0;
  *(void* *)((long long)SystemResourceManager + 0x324) = 0;
  *(uint32_t *)(SystemResourceManager + 100) = 0;
  SystemResourceManager[0x20] = 0;
  SystemResourceManager[0x21] = 0x20;
  SystemResourceManager[0x22] = resourceEntryPointer;
  do {
    *(uint32_t *)resourceEntryPointer = 0;
    resourceEntryPointer = resourceEntryPointer + 2;
    localDataIndex = localDataIndex + -1;
  } while (localDataIndex != 0);
  SystemResourceManager[0x23] = 0;
  SystemResourceManager[0x1f] = SystemResourceManager + 0x21;
  SystemResourceManager[0x1d] = 0x15;
  SystemBufferAddress = InitializeSystemThreadObject();
  SystemResourceManager[0x1c] = SystemBufferAddress;
  if (SystemBufferAddress == 0) {
    SystemResourceManager[0x1d] = 0;
    SystemOperationStatus = resourceCreationFlags;
  }
  else {
    SystemOperationStatus = SystemResourceManager[0x1d];
  }
  resourceAllocationContext = resourceCreationFlags;
  if (SystemOperationStatus != 0) {
    do {
      *(uint8_t *)(resourceCreationFlags + 0x3541 + SystemResourceManager[0x1c]) = 0;
      resourceAllocationContext = resourceAllocationContext + 1;
      resourceCreationFlags = resourceCreationFlags + 0x3548;
    } while (resourceAllocationContext < (ulong long)SystemResourceManager[0x1d]);
  }
  _Cnd_init_in_situ();
  _Mtx_init_in_situ(SystemResourceManager + 0x6f,2);
  SystemResourceManager[0x79] = 0;
  SystemResourceManager[0x7a] = 0;
  SystemResourceManager[0x7b] = 0;
  *(uint32_t *)(SystemResourceManager + 0x7c) = 3;
  SystemResourceManager[0x7e] = 0;
  *(uint32_t *)(SystemResourceManager + 0x7f) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x3fc) = 4000;
  SystemResourceManager[0x18] = ConfigurationDataPointer;
  SystemResourceManager[0x7d] = AdditionalParameter;
  *(uint8_t *)(SystemResourceManager + 0x80) = 0;
  return SystemResourceManager;
}



/**
 * @brief 使用互斥锁初始化系统资源管理器
 * 
 * 该函数负责使用互斥锁初始化系统资源管理器，包括互斥锁的初始化、
 * 资源管理器的配置和内存分配。主要用于系统资源的同步管理。
 * 
 * @param SystemResourceManager 资源管理器指针，用于管理系统资源
 * @param ConfigurationDataPointer 配置数据指针，包含初始化所需的配置信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @param ConfigurationFlag 配置标志，用于控制初始化行为
 * @return 返回初始化后的资源管理器指针
 * 
 *FUN_18006e870：InitializeSystemResourceManagerWithMutex
 */
uint32_t *
InitializeSystemResourceManagerWithMutex(uint32_t *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint32_t *SystemDataPointer;
  
  *SystemResourceManager = 0;
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  SystemResourceManager[2] = 0;
  SystemResourceManager[3] = 0;
  SystemResourceManager[4] = 3;
  *(void* *)(SystemResourceManager + 6) = 0;
  *(uint32_t **)SystemResourceManager = SystemResourceManager;
  *(uint32_t **)(SystemResourceManager + 2) = SystemResourceManager;
  _Mtx_init_in_situ(SystemResourceManager + 8,0x102,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  *(void* *)(SystemResourceManager + 0x1c) = 1;
  SystemDataPointer = SystemResourceManager + 0x1e;
  *SystemDataPointer = 0;
  SystemResourceManager[0x1f] = 0;
  SystemResourceManager[0x20] = 0;
  SystemResourceManager[0x21] = 0;
  SystemResourceManager[0x22] = 3;
  *(void* *)(SystemResourceManager + 0x24) = 0;
  *(uint32_t **)SystemDataPointer = SystemDataPointer;
  *(uint32_t **)(SystemResourceManager + 0x20) = SystemDataPointer;
  _Mtx_init_in_situ(SystemResourceManager + 0x26,0x102);
  *(void* *)(SystemResourceManager + 0x3a) = 1;
  SystemDataPointer = SystemResourceManager + 0x3c;
  *SystemDataPointer = 0;
  SystemResourceManager[0x3d] = 0;
  SystemResourceManager[0x3e] = 0;
  SystemResourceManager[0x3f] = 0;
  SystemResourceManager[0x40] = 3;
  *(void* *)(SystemResourceManager + 0x42) = 0;
  *(uint32_t **)SystemDataPointer = SystemDataPointer;
  *(uint32_t **)(SystemResourceManager + 0x3e) = SystemDataPointer;
  _Mtx_init_in_situ(SystemResourceManager + 0x44,0x102);
  *(void* *)(SystemResourceManager + 0x58) = 1;
  SystemResourceManager[0x5a] = 0;
  return SystemResourceManager;
}





/**
 * @brief 系统初始化状态管理器
 * 
 * 该函数负责管理系统初始化状态，包括初始化标志的设置、
 * 系统计数器的更新和系统内存的管理
 * 
 *FUN_18006e990：ManageSystemInitializationState
 */
void ManageSystemInitializationState(void)

{
  long long resourceDataIndex;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  long long* SystemMemoryPointer;
  
  resourceDataIndex = SystemInitializationFlag;
  InitializeSystemFlag(SystemInitializationFlag);
  *(int *)(resourceDataIndex + 0xec) = *(int *)(resourceDataIndex + 0xec) + 1;
  systemCounter = _Mtx_lock(resourceDataIndex + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  SystemCalculatedBufferAddress = *(long long **)(resourceDataIndex + 0x78);
  if ((SystemCalculatedBufferAddress != (long long *)(resourceDataIndex + 0x78)) && (*(uint *)(SystemCalculatedBufferAddress + 2) < *(uint *)(resourceDataIndex + 0xec))) {
    SystemCalculatedBufferAddress = *(long long **)(*SystemCalculatedBufferAddress + 8);
    *(long long *)(*SystemCalculatedBufferAddress + 8) = SystemCalculatedBufferAddress[1];
    *(long long *)SystemCalculatedBufferAddress[1] = *SystemCalculatedBufferAddress;
      SystemCleanupFunction();
  }
  systemCounter = _Mtx_unlock(resourceDataIndex + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  *(int *)(resourceDataIndex + 0x164) = *(int *)(resourceDataIndex + 0x164) + 1;
  systemCounter = _Mtx_lock(resourceDataIndex + 0x110);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  SystemCalculatedBufferAddress = *(long long **)(resourceDataIndex + 0xf0);
  do {
    if (SystemCalculatedBufferAddress == (long long *)(resourceDataIndex + 0xf0)) {
LAB_18006f48d:
      systemCounter = _Mtx_unlock(resourceDataIndex + 0x110);
      if (systemCounter != 0) {
        __Throw_C_error_std__YAXH_Z(systemCounter);
      }
      return;
    }
    SystemOperationResult = (**(code **)(*(long long *)SystemCalculatedBufferAddress[3] + 0x40))();
    if (validationStatusFlag != '\0') {
      if (*(uint *)(SystemCalculatedBufferAddress + 2) < *(uint *)(resourceDataIndex + 0x164)) {
        SystemCalculatedBufferAddress = *(long long **)(*SystemCalculatedBufferAddress + 8);
        *(long long *)(*SystemCalculatedBufferAddress + 8) = SystemCalculatedBufferAddress[1];
        *(long long *)SystemCalculatedBufferAddress[1] = *SystemCalculatedBufferAddress;
          SystemCleanupFunction();
      }
      goto LAB_18006f48d;
    }
    SystemCalculatedBufferAddress = (long long *)*SystemCalculatedBufferAddress;
  } while( true );
}





// 函数: void FinalizeSystemMemorySetup(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void FinalizeSystemMemorySetup(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long SystemThreadHandle;
  int NodeIdentifierComparisonResult;
  
  SystemThreadHandle = SystemInitializationFlag;
  ProcessSystemTextureManagerLock(SystemAllocationFlagsTemplate,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  InitializeSystemHandle(SystemThreadHandle);
  systemCounter = _Mtx_lock(SystemThreadHandle + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  if (*(long long *)(SystemThreadHandle + 0x90) != 0) {
    PrimaryResourcePointer = *(long long **)(**(long long **)(SystemThreadHandle + 0x78) + 8);
    *(long long *)(*PrimaryResourcePointer + 8) = PrimaryResourcePointer[1];
    *(long long *)PrimaryResourcePointer[1] = *PrimaryResourcePointer;
      SystemCleanupFunction();
  }
  systemCounter = _Mtx_unlock(SystemThreadHandle + 0x98);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  systemCounter = _Mtx_lock(SystemThreadHandle + 0x110);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  if (*(long long *)(SystemThreadHandle + 0x108) != 0) {
    PrimaryResourcePointer = *(long long **)(**(long long **)(SystemThreadHandle + 0xf0) + 8);
    *(long long *)(*PrimaryResourcePointer + 8) = PrimaryResourcePointer[1];
    *(long long *)PrimaryResourcePointer[1] = *PrimaryResourcePointer;
      SystemCleanupFunction();
  }
  systemCounter = _Mtx_unlock(SystemThreadHandle + 0x110);
  if (systemCounter != 0) {
    __Throw_C_error_std__YAXH_Z(systemCounter);
  }
  return;
}





// 函数: void InitializeSystemResourceManagerEx(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括创建线程对象、
 * 设置资源参数和配置系统状态
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 *FUN_18006edf0：InitializeSystemResourceManagerEx
 */
void InitializeSystemResourceManagerEx(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long DataIndex;
  int SystemOperationResult;
  long long ResourceOffset;
  int SystemIndex;
  long long *SystemPointer;
  long long SystemFlags;
  void* SystemValue;
  uint32_t StackParameter1;
  uint32_t StackParameter2;
  uint32_t StackParameter3;
  uint7 StackParameter4;
  
  ResourceOffset = SystemInitializationFlag;
  SystemValue = 0xfffffffffffffffe;
  if (SystemInitializationFlag != 0) {
    SystemFlags = SystemInitializationFlag + 0xf0;
    DataIndex = SystemInitializationFlag + 0x110;
    SystemIndex = _Mtx_lock(DataIndex);
    if (SystemIndex != 0) {
      __Throw_C_error_std__YAXH_Z(SystemIndex);
    }
    SystemIndex = *(int *)(ResourceOffset + 0x164);
    SystemOperationResult = *(int *)(ResourceOffset + 0x160);
    SystemPointer = (long long *)
             CreateSystemThreadObject(SystemMemoryPoolTemplate,0x28,*(uint8_t *)(ResourceOffset + 0x100),ConfigurationFlag,SystemValue);
    StackParameter2 = (uint32_t)SystemResourceManager;
    StackParameter3 = (uint32_t)((ulong long)SystemResourceManager >> 0x20);
    *(int *)(SystemPointer + 2) = SystemIndex + SystemOperationResult;
    *(uint32_t *)((long long)SystemPointer + 0x14) = StackParameter1;
    *(uint32_t *)(SystemPointer + 3) = StackParameter2;
    *(uint32_t *)((long long)SystemPointer + 0x1c) = StackParameter3;
    SystemPointer[4] = (ulong long)StackParameter4 << 8;
    *SystemPointer = SystemFlags;
    SystemPointer[1] = *(long long *)(ResourceOffset + 0xf8);
    **(long long **)(ResourceOffset + 0xf8) = (long long)SystemPointer;
    *(long long **)(ResourceOffset + 0xf8) = SystemPointer;
    *(long long *)(ResourceOffset + 0x108) = *(long long *)(ResourceOffset + 0x108) + 1;
    SystemIndex = _Mtx_unlock(DataIndex);
    if (SystemIndex != 0) {
      __Throw_C_error_std__YAXH_Z(SystemIndex);
    }
  }
  return;
}



/**
 * @brief 获取系统资源状态
 * 
 * 该函数负责获取系统资源的状态信息，通过线程安全的方式
 * 访问资源管理器中的状态数据
 * 
 * @param SystemResourceManager 资源管理器指针
 * @return 系统状态指针，包含当前系统状态信息
 * 
 *FUN_18006eec0：GetSystemResourceStatus
 */
void* GetSystemResourceStatus(long long SystemResourceManager)

{
  void* SystemStatus;
  int OperationResult;
  
  OperationResult = _Mtx_lock(SystemResourceManager + 0x20);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  SystemStatus = *(void* *)(SystemResourceManager + 0x18);
  OperationResult = _Mtx_unlock(SystemResourceManager + 0x20);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  return SystemStatus;
}




// 函数: void ReleaseSystemResource(long long* SystemResourceManager)
/**
 * @brief 释放系统资源
 * 
 * 该函数负责释放系统资源，包括销毁互斥锁和清理相关资源
 * 确保系统资源的正确释放和内存管理
 * 
 * @param SystemResourceManager 资源管理器指针
 * @return 无返回值
 */
void ReleaseSystemResource(long long* SystemResourceManager)

{
  _Mtx_destroy_in_situ();
  if ((long long *)*SystemResourceManager != SystemResourceManager) {
      SystemCleanupFunction((long long *)*SystemResourceManager);
  }
  return;
}




// 函数: void CleanupSystemResourceArrayEx(long long* SystemResourceManager)
/**
 * @brief 清理系统资源管理器
 * 
 * 该函数负责清理系统资源管理器，确保资源的正确释放
 * 主要用于系统关闭时的资源清理工作
 * 
 * @param SystemResourceManager 资源管理器指针
 * @return 无返回值
 * 
 *FUN_18006ef80：CleanupSystemResourceManager
 */
void CleanupSystemResourceManager(long long* SystemResourceManager)

{
  if ((long long *)*SystemResourceManager != SystemResourceManager) {
      SystemCleanupFunction((long long *)*SystemResourceManager);
  }
  return;
}




// 函数: void InitializeSystemResourceManagerEx2(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 执行系统资源清理操作
 * 
 * 该函数负责执行系统资源的清理操作，包括锁定资源管理器、
 * 清理主要资源指针和释放相关资源
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 *FUN_18006efc0：ExecuteSystemResourceCleanup
 */
void ExecuteSystemResourceCleanup(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *MainResourcePointer;
  int OperationResult;
  
  OperationResult = _Mtx_lock(SystemResourceManager + 4,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  if (SystemResourceManager[3] != 0) {
    MainResourcePointer = *(long long **)(*(long long *)*SystemResourceManager + 8);
    *(long long *)(*MainResourcePointer + 8) = MainResourcePointer[1];
    *(long long *)MainResourcePointer[1] = *MainResourcePointer;
      SystemCleanupFunction();
  }
  OperationResult = _Mtx_unlock(SystemResourceManager + 4);
  if (OperationResult != 0) {
    __Throw_C_error_std__YAXH_Z(OperationResult);
  }
  return;
}




// 函数: void UpdateSystemResourceCounter(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 更新系统资源计数器
 * 
 * 该函数负责更新系统资源的计数器，管理资源的使用统计。
 * 它会锁定资源管理器，更新计数器值，并在必要时清理资源。
 * 
 * @param SystemResourceManager 系统资源指针，指向资源管理器数据结构
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18006f160：UpdateSystemResourceCounter
 */
void UpdateSystemResourceCounter(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  int systemResult;
  
  *(int *)((long long)SystemResourceManager + 0x74) = *(int *)((long long)SystemResourceManager + 0x74) + 1;
  systemResult = _Mtx_lock(SystemResourceManager + 4,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  PrimaryResourcePointer = (long long *)*SystemResourceManager;
  if ((PrimaryResourcePointer != SystemResourceManager) && (*(uint *)(PrimaryResourcePointer + 2) < *(uint *)((long long)SystemResourceManager + 0x74))) {
    PrimaryResourcePointer = *(long long **)(*PrimaryResourcePointer + 8);
    *(long long *)(*PrimaryResourcePointer + 8) = PrimaryResourcePointer[1];
    *(long long *)PrimaryResourcePointer[1] = *PrimaryResourcePointer;
      SystemCleanupFunction();
  }
  systemResult = _Mtx_unlock(SystemResourceManager + 4);
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  return;
}




// 函数: void CleanupSystemResourceHandle(long long* SystemResourceManager)
/**
 * @brief 清理系统资源句柄
 * 
 * 该函数负责清理系统资源句柄，释放相关资源并清理内存。
 * 这是一个简单的资源清理函数，确保资源句柄被正确释放。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源句柄
 * 
 *FUN_18006f310：CleanupSystemResourceHandle
 */
void CleanupSystemResourceHandle(long long* SystemResourceManager)

{
  if ((long long *)*SystemResourceManager != SystemResourceManager) {
      SystemCleanupFunction((long long *)*SystemResourceManager);
  }
  return;
}




/**
 * @brief 处理系统资源队列
 * 
 * 该函数负责处理系统资源队列，管理资源的分配和释放。
 * 主要用于系统资源的队列管理和线程同步。
 * 
 * @param SystemResourceManager 系统资源指针，指向资源队列数据结构
 * 
 *FUN_18006f340：ProcessSystemResourceQueue
 */
void ProcessSystemResourceQueue(long long* SystemResourceManager)

{
  char SystemNodeFlag;
  int systemResult;
  long long *SystemResourceOffsetPointer;
  
  *(int *)((long long)SystemResourceManager + 0x74) = *(int *)((long long)SystemResourceManager + 0x74) + 1;
  systemResult = _Mtx_lock(SystemResourceManager + 4);
  if (systemResult != 0) {
    __Throw_C_error_std__YAXH_Z(systemResult);
  }
  SystemResourceOffsetPointer = (long long *)*SystemResourceManager;
  do {
    if (SystemResourceOffsetPointer == SystemResourceManager) {
LAB_18006f48d:
      systemResult = _Mtx_unlock(SystemResourceManager + 4);
      if (systemResult != 0) {
        __Throw_C_error_std__YAXH_Z(systemResult);
      }
      return;
    }
    charStatus = (**(code **)(*(long long *)SystemResourceOffsetPointer[3] + 0x40))();
    if (initializationStatusFlag != '\0') {
      if (*(uint *)(SystemResourceOffsetPointer + 2) < *(uint *)((long long)SystemResourceManager + 0x74)) {
        SystemResourceOffsetPointer = *(long long **)(*SystemResourceOffsetPointer + 8);
        *(long long *)(*SystemResourceOffsetPointer + 8) = SystemResourceOffsetPointer[1];
        *(long long *)SystemResourceOffsetPointer[1] = *SystemResourceOffsetPointer;
          SystemCleanupFunction();
      }
      goto LAB_18006f48d;
    }
    SystemResourceOffsetPointer = (long long *)*SystemResourceOffsetPointer;
  } while( true );
}




// 函数: void ExecuteSystemEntryPoint(void* *entryPointPtr)
/**
 * @brief 执行系统入口点
 * 
 * 该函数负责执行系统的入口点函数。它会检查入口点指针是否有效，
 * 如果有效则调用相应的函数指针，并处理运行时类型转换。
 * 
 * @param entryPointPtr 入口点指针，指向要执行的函数
 */
void ExecuteSystemEntryPoint(void* *entryPointPtr)

{
  long long runtimeCastResult;
  
  if (entryPointPtr != (void* *)0x0) {
    runtimeCastResult = __RTCastToVoid();
    (**(code **)*entryPointPtr)(entryPointPtr,0);
    if (runtimeCastResult != 0) {
        SystemCleanupFunction(runtimeCastResult);
    }
  }
  return;
}




/**
 * @brief 系统内存数据索引处理器
 * 
 * 该函数负责处理系统内存数据索引，包括索引的获取和清理操作
 * 用于系统内存数据的管理和维护
 * 
 * @return 无返回值
 * 
 *FUN_18006f4cd：ProcessSystemMemoryDataIndex
 */
void ProcessSystemMemoryDataIndex(void)

{
  long long NextDataIndex;
  void* *SystemMemoryBlockPointer;
  
  NextDataIndex = __RTCastToVoid();
  (**(code **)*SystemMemoryBlockPointer)();
  if (NextDataIndex != 0) {
      SystemCleanupFunction(NextDataIndex);
  }
  return;
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，用于系统初始化过程中的占位操作
 * 在某些系统流程中需要调用但不执行任何操作
 * 
 * @return 无返回值
 * 
 *FUN_18006f4fc：SystemNullOperation
 */
void SystemNullOperation(void)

{
  return;
}




/**
 * @brief 执行资源管理器操作
 * 
 * 该函数负责执行资源管理器的特定操作，通过调用资源管理器中的
 * 预定义函数指针来执行相应的操作
 * 
 * @param SystemResourceManager 资源管理器指针，包含要操作的资源管理器
 * @return 无返回值
 * 
 *FUN_18006f500：ExecuteResourceManagerOperation
 */
void ExecuteResourceManagerOperation(long long SystemResourceManager)

{
  if (*(long long **)(SystemResourceManager + 0x70) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemResourceManager + 0x70) + 0x38))();
  }
  return;
}




/**
 * @brief 清理资源管理器状态
 * 
 * 该函数负责清理资源管理器的状态，包括系统清理函数的调用
 * 和资源管理器中特定函数指针的执行
 * 
 * @param SystemResourceManager 资源管理器指针，包含要清理的资源管理器
 * @return 无返回值
 * 
 *FUN_18006f530：CleanupResourceManagerState
 */
void CleanupResourceManagerState(long long SystemResourceManager)

{
  if (*(long long *)(SystemResourceManager + 0x1d8) != 0) {
      SystemCleanupFunction();
  }
  if (*(long long **)(SystemResourceManager + 0x1b8) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemResourceManager + 0x1b8) + 0x38))();
  }
  return;
}



/**
 * @brief 配置系统资源管理器
 * 
 * 该函数负责配置系统资源管理器，包括内存分配器的设置、
 * 全局数据的初始化和系统命令的执行
 * 
 * @param SystemResourceManager 资源管理器指针，包含要配置的资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 额外参数，包含额外的配置参数
 * @param ConfigurationFlag 配置标志，指定配置的方式和选项
 * @return 资源管理器指针，返回配置后的资源管理器指针
 * 
 *ConfigureSystemResourceManager：ConfigureSystemResourceManager
 */
void* *
ConfigureSystemResourceManager(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  if (SystemInitFlagPtr == '\0') {
    *SystemResourceManager = &SystemMemoryAllocatorReference;
    SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
    *(uint32_t *)(SystemResourceManager + 2) = 0;
    *SystemResourceManager = &SystemGlobalDataReference;
    SystemResourceManager[3] = 0;
    SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
    *(uint32_t *)(SystemResourceManager + 2) = 0;
    ExecuteSystemCommand(SystemResourceManager,0,AdditionalParameter,ConfigurationFlag,0,InvalidHandleValue);
    *(uint32_t *)(SystemResourceManager + 2) = 0;
    if ((uint8_t *)SystemResourceManager[1] != (uint8_t *)0x0) {
      *(uint8_t *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
    }
  }
  else {
    ProcessSystemResourceDataExtended(SystemResourceManager,SystemResourceManager);
  }
  return SystemResourceManager;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括配置系统数据、设置标志、
 * 处理调试器检测、显示消息框等系统初始化操作
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统状态码
 * 
 *FUN_18006f620：InitializeSystemResourceManagerA
 */
ulong long InitializeSystemResourceManagerA(void* SystemResourceManager,void* ConfigurationDataPointer)

{
  code *systemFunctionPointer;
  bool isSystemActive;
  long long ResourceDataOffset;
  char SystemOperationStatusFlag;
  int systemValue;
  int CalculationFlags;
  ulong long ThreadContextFlag;
  void* *SystemThreadStorage;
  bool isSystemBusy;
  void* *memoryAllocationEnd;
  void* *pSystemEncryptionKey;
  uint32_t SystemOperationCounter;
  void* SystemContextValue;
  uint8_t SystemResourceStatusFlagCompact [8];
  void* *pEncryptionKeyValue;
  
  ResourceDataOffset = SystemAllocationFlagsTemplate;
  ThreadContextFlag = GetConfigurationDataStatus(ConfigurationDataPointer);
  if (((char)ThreadContextFlag != '\0') || (ThreadContextFlag = WaitForSingleObject(SystemSemaphoreHandle,0), (int)ThreadContextFlag != 0)) {
    return ThreadContextFlag & MAX_UNSIGNED_32_BITffffff00;
  }
  if (ResourceDataOffset != 0) {
    ProcessSystemResourceOffset(ResourceDataOffset);
  }
  isSystemBusy = true;
  SystemOperationStatusFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((SystemOperationStatusFlag == '\0') && (systemValue = IsDebuggerPresent(), systemValue != 0)) {
    isSystemActive = true;
  }
  else {
    isSystemActive = false;
  }
  if (ResourceDataOffset != 0) {
    systemValue = *(int *)(**(long long **)(ResourceDataOffset + 8) + 0x48);
    CalculationFlags = _Thrd_id();
    isSystemBusy = CalculationFlags == systemValue;
  }
  ProcessSystemMemoryAllocation(SystemResourceStatusFlagCompact,0);
  memoryAllocationEnd = &SystemGlobalDataReference;
  SystemContextValue = 0;
  pSystemEncryptionKey = (void* *)0x0;
  SystemOperationCounter = 0;
  ConfigureSystemDataBuffer(&memoryAllocationEnd,&SystemDataBufferTemplate,ConfigurationDataPointer);
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationTemplate);
  SystemThreadStorage = &SystemStringTemplate;
  if (pSystemEncryptionKey != (void* *)0x0) {
    SystemThreadStorage = pSystemEncryptionKey;
  }
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemStringTemplateBuffer,SystemThreadStorage);
  SystemThreadStorage = &SystemStringTemplate;
  if (pEncryptionKeyValue != (void* *)0x0) {
    SystemThreadStorage = pEncryptionKeyValue;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffff00000000,3,SystemThreadStorage);
  InitializeSystemManager();
  SystemThreadStorage = &SystemStringTemplate;
  if (pSystemEncryptionKey != (void* *)0x0) {
    SystemThreadStorage = pSystemEncryptionKey;
  }
  OutputDebugStringA(SystemThreadStorage);
  InitializeSystemConfiguration(ConfigurationDataPointer);
  ResourceDataOffset = SystemRenderManagerPointer;
  if (((isSystemBusy) && (SystemRenderManagerPointer != 0)) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
    ProcessSystemResourceAllocation(*(void* *)(SystemGlobalStatusFlags + 8),*(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                  *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
    *(uint8_t *)(ResourceDataOffset + 0x1609) = 1;
  }
  if (SystemSilentMode == '\0') {
    if ((SystemInitializationFlag == '\0') ||
       ((systemValue = IsDebuggerPresent(), systemValue != 0 && (SystemSilentMode == '\0')))) {
      MessageBoxA(0,ConfigurationDataPointer,&SystemMessageTemplate,0x41010);
    }
    else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
      SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,&SystemMessageTemplate,ConfigurationDataPointer);
    }
  }
  else if (SystemInitializationFlag == '\0') {
    SystemThreadStorage = &SystemStringTemplate;
    if (pSystemEncryptionKey != (void* *)0x0) {
      SystemThreadStorage = pSystemEncryptionKey;
    }
    ConfigureSystemDataTemplate(SystemThreadStorage);
  }
  systemValue = GetSystemConfigurationValue(ConfigurationDataPointer);
  if ((!isSystemActive) && (systemValue == 0)) {
    ProcessSystemConfiguration();
  }
  SetSystemConfigurationValue(ConfigurationDataPointer,0);
  if (SystemGlobalStatusFlags == 0) {
    _Exit(5);
    systemFunctionPointer = (code *)swi(3);
    ThreadContextFlag = (*systemFunctionPointer)();
    return ThreadContextFlag;
  }
  UpdateSystemStatusFlags();
  systemFunctionPointer = (code *)swi(3);
  ThreadContextFlag = (*systemFunctionPointer)();
  return ThreadContextFlag;
}



00018006fc4b)
00018006fc66)
00018006fc6b)
00018006fe26)

/**
 * @brief 系统资源初始化和处理函数
 * 
 * 该函数负责系统资源的初始化和处理，包括调试器检测、信号量等待、
 * 系统配置和资源管理等功能
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @return 系统状态码
 * 
 *FUN_18006f940：InitializeAndProcessSystemResources
 */
ulong long InitializeAndProcessSystemResources(void* SystemResourceManager,void* ConfigurationDataPointer,char AdditionalParameter)

{
  uint8_t SystemOperationStatus;
  code *SystemStringPointer;
  bool isOperationComplete;
  long long SystemBufferAddress;
  void* SystemThreadContext;
  char debuggerCheckResult;
  int systemOffset;
  int systemCode;
  uint32_t ThreadContextFlag;
  ulong long in_RAX;
  long long SystemAllocationFlags;
  void* *ThreadLocalStorage;
  ulong long SystemSecondaryStatus;
  void* SystemOperationStatus3;
  void* *SystemThreadLocalStoragePointer;
  bool isByteValid5;
  byte BooleanStatusFlag;
  void* *DataBufferPtrE0;
  void* *systemDataPointer;
  uint32_t StackUnsignedValueD0;
  ulong long StackUnsignedValueC8;
  void* *pUnsignedStackFlagC0;
  void* *systemGlobalDataPtrB8;
  uint32_t UnsignedStackFlagB0;
  void* UnsignedStackFlagA8;
  void** SystemDataPointer;
  void* *stackParameterB;
  uint32_t SystemConfigurationValue;
  ulong long UnsignedStackFlag88;
  void* *SystemStatusFlagPointer;
  long long StackInteger78;
  uint32_t EncryptionValue68;
  void* SystemOperationCounter;
  
  SystemBufferAddress = SystemAllocationFlagsTemplate;
  SystemOperationCounter = 0xfffffffffffffffe;
  BooleanStatusFlag = 0;
  if (((SystemInitializationFlag == '\0') || (in_RAX = GetConfigurationDataStatus(ConfigurationDataPointer), (char)in_RAX != '\0')) ||
     (in_RAX = WaitForSingleObject(SystemSemaphoreHandle,0), (int)in_RAX != 0)) {
    SystemSecondaryStatus = in_RAX & MAX_UNSIGNED_32_BITffffff00;
  }
  else {
    if (SystemBufferAddress != 0) {
      ProcessSystemResourceOffset(SystemBufferAddress);
    }
    isByteValid5 = true;
    debuggerCheckResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
    if ((debuggerCheckResult == '\0') && (systemOffset = IsDebuggerPresent(), systemOffset != 0)) {
      isOperationComplete = true;
    }
    else {
      isOperationComplete = false;
    }
    if (SystemBufferAddress != 0) {
      systemOffset = *(int *)(**(long long **)(SystemBufferAddress + 8) + 0x48);
      systemCode = _Thrd_id();
      isByteValid5 = systemCode == systemOffset;
    }
    pUnsignedStackFlagC0 = &SystemGlobalDataReference;
    UnsignedStackFlagA8 = 0;
    systemGlobalDataPtrB8 = (void* *)0x0;
    SystemStackFlagB0 = 0;
    if (!isOperationComplete) {
      SystemAllocationFlags = ProcessSystemMemoryAllocation(&DataBufferPtrE0,0);
      UnsignedStackFlagB0 = *(uint32_t *)(SystemAllocationFlags + 0x10);
      systemGlobalDataPtrB8 = *(void* **)(SystemAllocationFlags + 8);
      UnsignedStackFlagA8 = *(void* *)(SystemAllocationFlags + 0x18);
      *(uint32_t *)(SystemAllocationFlags + 0x10) = 0;
      *(void* *)(SystemAllocationFlags + 8) = 0;
      *(void* *)(SystemAllocationFlags + 0x18) = 0;
      DataBufferPtrE0 = &SystemGlobalDataReference;
      if (SystemMemoryAllocatorReferencePointer != (void* *)0x0) {
          SystemCleanupFunction();
      }
      SystemMemoryAllocatorReferencePointer = (void* *)0x0;
      SystemThreadIdentifier = SystemThreadIdentifier & MAX_UNSIGNED_32_BIT00000000;
      DataBufferPtrE0 = &SystemMemoryAllocatorReference;
    }
    SystemThreadContext = systemGlobalDataPtrB8;
    stackParameterA = &SystemGlobalDataReference;
    UnsignedStackFlag88 = 0;
    stackParameterB = (void* *)0x0;
    SystemConfigurationValue = 0;
    ConfigureSystemDataBuffer(&SystemParameterPointerA,&SystemDataTemplateC,ConfigurationDataPointer);
    ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationTemplate);
    ThreadLocalStorage = &SystemStringTemplate;
    if (stackParameterB != (void* *)0x0) {
      ThreadLocalStorage = stackParameterB;
    }
    ConfigureSystemManager(SystemContextManagerPointer,2,0xffffffff00000000,&SystemStringTemplateBuffer,ThreadLocalStorage);
    ThreadLocalStorage = &SystemStringTemplate;
    if (SystemThreadContext != (void* *)0x0) {
      ThreadLocalStorage = SystemThreadContext;
    }
    SystemManagerSetFlags(SystemContextManagerPointer,2,0xffffffff00000000,3,ThreadLocalStorage);
    InitializeSystemManager();
    ThreadLocalStorage = &SystemStringTemplate;
    if (stackParameterB != (void* *)0x0) {
      ThreadLocalStorage = stackParameterB;
    }
    OutputDebugStringA(ThreadLocalStorage);
    InitializeSystemConfiguration(ConfigurationDataPointer);
    if (((SystemInitializationFlag != '\0') && (isOperationComplete)) &&
       ((*(char *)(SystemGlobalStatusFlags + 0x25) != '\0' ||
        ((AdditionalParameter == '\0' || (*(int *)(SystemGlobalStatusFlags + 0x340) == 2)))))) {
      if (SystemDebugFlag == '\0') {
        pSystemOperationResult = (code *)swi(3);
        SystemSecondaryStatus = (*pSystemOperationResult)();
        return SystemSecondaryStatus;
      }
      BooleanStatusFlag = 1;
    }
    if (SystemSilentMode == '\0') {
      if (isByteValid5) {
        if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
          ValidateSystemResourceStatus(*(long long *)(SystemGlobalStatusFlags + 8));
        }
        SystemBufferAddress = SystemRenderManagerPointer;
        if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
          ProcessSystemResourceAllocation(*(void* *)(SystemGlobalStatusFlags + 8),
                        *(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                        *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
          *(uint8_t *)(SystemBufferAddress + 0x1609) = 1;
        }
      }
      DataBufferPtrE0 = &SystemGlobalDataReference;
      StackValueC8 = 0;
      SystemMemoryAllocatorReferencePointer = (void* *)0x0;
      SystemThreadPriority = 0;
      SystemThreadLocalStoragePointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
      *(uint8_t *)SystemThreadLocalStoragePointer = 0;
      SystemMemoryAllocatorReferencePointer = SystemThreadLocalStoragePointer;
      ThreadContextFlag = StartSystemThread(SystemThreadLocalStoragePointer);
      SystemThreadIdentifier = ConcatenatedValue44(SystemThreadIdentifier._4_4_,ThreadContextFlag);
      *SystemThreadLocalStoragePointer = 0x4e524157204c4752;
      *(uint32_t *)(SystemThreadLocalStoragePointer + 1) = 0x474e49;
      SystemThreadPriority = 0xb;
      if (((SystemInitializationFlag == '\0') || (systemOffset = IsDebuggerPresent(), systemOffset != 0)) &&
         (SystemSilentMode == '\0')) {
        MessageBoxA(0,ConfigurationDataPointer,SystemThreadLocalStoragePointer,0x41030);
      }
      else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
        SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,SystemThreadLocalStoragePointer,ConfigurationDataPointer);
      }
      DataBufferPtrE0 = &SystemGlobalDataReference;
        SystemCleanupFunction(SystemThreadLocalStoragePointer);
    }
    if (SystemInitializationFlag == '\0') {
      FormatSystemResourceData(&SystemDebugTemplate,ConfigurationDataPointer);
    }
    systemOffset = GetSystemConfigurationValue(ConfigurationDataPointer);
    if (((!isOperationComplete) && (systemOffset == 0)) && (*(char *)(SystemGlobalStatusFlags + 0x2a) != '\0')) {
      SystemOperationStatus = *(uint8_t *)(SystemGlobalStatusFlags + 0x141);
      SystemOperationStatus3 = CreateSystemObject(&SystemStatusFlagPointer,SystemGlobalStatusFlags + 0x148);
      SystemOperationStatus3 = CreateSystemObject(&DataBufferPtrE0,SystemOperationStatus3);
      SystemStatusFlagPointer = &SystemGlobalDataReference;
      if (StackInteger78 != 0) {
          SystemCleanupFunction();
      }
      StackInteger78 = 0;
      EncryptionValue68 = 0;
      SystemStatusFlagPointer = &SystemMemoryAllocatorReference;
      ThreadLocalStorage = &SystemStringTemplate;
      if (SystemThreadContext != (void* *)0x0) {
        ThreadLocalStorage = SystemThreadContext;
      }
      ProcessSystemConfiguration(SystemOperationStatus3,&DataBufferPtrE0,SystemOperationStatus,0,ThreadLocalStorage);
      DataBufferPtrE0 = &SystemGlobalDataReference;
      if (SystemMemoryAllocatorReferencePointer != (void* *)0x0) {
          SystemCleanupFunction();
      }
      SystemMemoryAllocatorReferencePointer = (void* *)0x0;
      SystemThreadIdentifier = SystemThreadIdentifier & MAX_UNSIGNED_32_BIT00000000;
      DataBufferPtrE0 = &SystemMemoryAllocatorReference;
    }
    SetSystemConfigurationValue(ConfigurationDataPointer,0);
    if (SystemGlobalStatusFlags == 0) {
      charSignal = '\x01';
    }
    else {
      charSignal = *(char *)(SystemGlobalStatusFlags + 0x29);
    }
    if (*(char *)(SystemGlobalStatusFlags + 0x25) != '\0') {
      EmergencySystemExitHandler(SystemGlobalStatusFlags,5);
      pSystemOperationResult = (code *)swi(3);
      SystemSecondaryStatus = (*pSystemOperationResult)();
      return SystemSecondaryStatus;
    }
    if (charSignal != '\0') {
      SystemGlobalStateStorage = 5;
    }
    if ((SystemSilentMode == '\0') && (isByteValid5)) {
      if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
        CleanupSystemResources();
      }
      if (SystemRenderManagerPointer != 0) {
        ProcessRenderManagerData(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
      }
    }
    if (SystemBufferAddress != 0) {
      ResumeSystemThreads(SystemBufferAddress);
    }
    do {
      systemOffset = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemOffset == 0);
    stackParameterA = &SystemGlobalDataReference;
    if (stackParameterB != (void* *)0x0) {
        SystemCleanupFunction();
    }
    stackParameterB = (void* *)0x0;
    UnsignedStackFlag88 = UnsignedStackFlag88 & MAX_UNSIGNED_32_BIT00000000;
    stackParameterA = &SystemMemoryAllocatorReference;
    pUnsignedStackFlagC0 = &SystemGlobalDataReference;
    if (SystemThreadContext != (void* *)0x0) {
        SystemCleanupFunction(SystemThreadContext);
    }
    SystemSecondaryStatus = (ulong long)BooleanStatusFlag;
  }
  return SystemSecondaryStatus;
}




/**
 * @brief 系统资源配置和管理函数
 * 
 * 该函数负责系统资源的配置和管理，包括内存分配、字符处理、
 * 系统索引管理等操作。这是系统初始化过程中的核心函数之一。
 * 
 * @param SystemResourceManager 资源管理器指针，包含系统资源管理信息
 * @param ConfigurationDataPointer 配置数据指针，包含系统配置参数
 * @param AdditionalParameter 额外参数，用于控制系统行为
 * @return ulong long 系统状态码，0表示成功，非0表示错误状态
 * 
 * @note 该函数会检查调试器状态、初始化系统组件、配置系统管理器
 * @note 原始函数名：FUN_18006ff80
 */
ulong long ConfigureAndManageSystemResources(void* SystemResourceManager,void* ConfigurationDataPointer,char AdditionalParameter)

{
  code *systemFunctionPointer;
  long long SystemThreadHandle;
  char characterProcessingFlag;
  int systemIndex;
  int systemValue;
  uint8_t *resourceEntryPointer;
  long long localDataIndex;
  void* **pSystemThreadStorage;
  void* *SystemHashBucket;
  void* *SystemDataPointer0;
  ulong long SystemOperationStatus1;
  void* *pSystemSecondaryStatus;
  uint8_t SystemOperationStatus3;
  bool isByteValid4;
  bool isByteValid5;
  uint32_t SystemOperationStatusFlags;
  byte bStack_d8;
  void* *alternateBufferPtrB0;
  void* *SystemDataBufferPointerA8;
  uint32_t UnsignedStackFlagA0;
  ulong long secondarySystemDataBuffer;
  void* *pStackParameterC;
  void* *pUnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  ulong long SystemUnsignedFlag78;
  void* *SystemProcessFlagsPointer;
  long long LocalSystemStatus;
  uint32_t SystemProcessFlags58;
  void* *memoryAllocationEnd;
  long long SystemStatusFlag48;
  uint32_t SystemContextValue;
  void* SystemResourceStatusFlag;
  
  SystemThreadHandle = SystemAllocationFlagsTemplate;
  SystemResourceStatusFlag = 0xfffffffffffffffe;
  bStack_d8 = 0;
  resourceEntryPointer = (uint8_t *)register0x00000020;
  if (((SystemInitializationFlag == '\0') ||
      (resourceEntryPointer = (uint8_t *)GetConfigurationDataStatus(ConfigurationDataPointer), (char)resourceEntryPointer != '\0')) ||
     (resourceEntryPointer = (uint8_t *)WaitForSingleObject(SystemSemaphoreHandle,0), (int)resourceEntryPointer != 0)) {
    return (ulong long)resourceEntryPointer & MAX_UNSIGNED_32_BITffffff00;
  }
  if (SystemThreadHandle != 0) {
    ProcessSystemResourceOffset(SystemThreadHandle);
  }
  IsByteValidPrimary = true;
  CharacterProcessingFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((CharacterProcessingFlag == '\0') && (SystemIndex = IsDebuggerPresent(), SystemIndex != 0)) {
    IsByteValidSecondary = true;
  }
  else {
    IsByteValidSecondary = false;
  }
  if (SystemThreadHandle != 0) {
    SystemIndex = *(int *)(**(long long **)(SystemThreadHandle + 8) + 0x48);
    SystemValue = _Thrd_id();
    IsByteValidPrimary = SystemValue == SystemIndex;
  }
  SystemSecondaryStatusPointer = (void* *)0x0;
  if (!IsByteValidSecondary) {
    LocalDataIndex = ProcessSystemMemoryAllocation(&SystemProcessFlagsPointer,0);
    SystemSecondaryStatusPointer = *(void* **)(LocalDataIndex + 8);
    *(uint32_t *)(LocalDataIndex + 0x10) = 0;
    *(void* )(LocalDataIndex + 8) = 0;
    *(void* )(LocalDataIndex + 0x18) = 0;
    SystemProcessFlagsPointer = &SystemGlobalDataReference;
    if (SystemStackOffset != 0) {
        SystemCleanupFunction();
    }
    SystemStackOffset = 0;
    SystemProcessFlags = 0;
    SystemProcessFlagsPointer = &SystemMemoryAllocatorReference;
  }
  AlternateBufferPointer = &SystemGlobalDataReference;
  SystemConfigurationValue = 0;
  SystemDataBufferPointer = (void* *)0x0;
  SystemStackFlag = 0;
  ConfigureSystemDataBuffer(&AlternateBufferPointer,&SystemAlternateBufferTemplate,ConfigurationDataPointer);
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationTemplate);
  SystemDataPointer = &SystemStringTemplate;
  if (SystemDataBufferPointer != (void* *)0x0) {
    SystemDataPointer = SystemDataBufferPointer;
  }
  ConfigureSystemManager(SystemContextManagerPointer,2,0xffffffff00000000,&SystemStringTemplateBuffer,SystemDataPointer);
  if (SystemResourceFlagPtr != '\0') {
    SystemDataPointer = &SystemStringTemplate;
    if (SystemSecondaryStatusPointer != (void* *)0x0) {
      SystemDataPointer = SystemSecondaryStatusPointer;
    }
    SystemManagerSetFlags(SystemContextManagerPointer,2,0xffffffff00000000,3,SystemDataPointer);
  }
  InitializeSystemManager();
  SystemDataPointer = &SystemStringTemplate;
  if (SystemDataBufferPointer != (void* *)0x0) {
    SystemDataPointer = SystemDataBufferPointer;
  }
  OutputDebugStringA(SystemDataPointer);
  InitializeSystemConfiguration(ConfigurationDataPointer);
  if ((SystemInitializationFlag != '\0') && (IsByteValidSecondary)) {
    if ((*(char *)(SystemGlobalStatusFlags + 0x25) == '\0') &&
       ((AdditionalParameter != '\0' && (*(int *)(SystemGlobalStatusFlags + 0x340) != 2)))) {
      SystemOperationStatusPrimary = 1;
      SystemStackByte = 1;
      goto LAB_180070230;
    }
    if (SystemDebugFlag == '\0') {
      systemFunctionPointer = (code *)swi(3);
      SystemOperationStatus1 = (*systemFunctionPointer)();
      return SystemOperationStatus1;
    }
  }
  SystemOperationStatus1 = 0;
LAB_180070230:
  if (*(int *)(SystemMemoryBlockSecondary + 0x460) == 0) {
    if (SystemSilentMode == '\0') {
      if (isByteValid4) {
        if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
          ValidateSystemResourceStatus(*(long long *)(SystemGlobalStatusFlags + 8));
        }
        localDataIndex = SystemRenderManagerPointer;
        if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
          ProcessSystemResourceAllocation(*(void* *)(SystemGlobalStatusFlags + 8),
                        *(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                        *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
          *(uint8_t *)(localDataIndex + 0x1609) = 1;
        }
      }
      if (((SystemInitializationFlag == '\0') || (systemIndex = IsDebuggerPresent(), systemIndex != 0)) &&
         (SystemSilentMode == '\0')) {
        MessageBoxA(0,ConfigurationDataPointer,&SystemErrorMessageTemplate,0x41030);
      }
      else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
        SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd,&SystemStackDataTemplate1,&SystemErrorMessageTemplate,ConfigurationDataPointer)
        ;
      }
    }
    else if (SystemInitializationFlag == '\0') {
      FormatSystemResourceData(&SystemWarningTemplate,ConfigurationDataPointer);
    }
    systemIndex = GetSystemConfigurationValue(ConfigurationDataPointer);
    if ((!isByteValid5) && (systemIndex == 0)) {
      isByteValid5 = SystemGlobalStatusFlags == 0;
      if (isByteValid5) {
        SystemOperationStatus3 = 0;
        pSystemConfigurationValue = &SystemGlobalDataReference;
        SystemUnsignedFlag78 = 0;
        pUnsignedStackFlag88 = (void* *)0x0;
        UnsignedStackFlag80 = 0;
        SystemOperationCounterPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x34,0x13);
        *(uint8_t *)SystemOperationCounterPointer = 0;
        pUnsignedStackFlag88 = SystemOperationCounterPointer;
        SystemOperationStatusFlags = StartSystemThread(SystemOperationCounterPointer);
        SystemUnsignedFlag78 = ConcatenatedValue44(SystemUnsignedFlag78.HighPart,SystemOperationStatusFlags);
        *SystemOperationCounterPointer = 0x7270706d75645c5c;
        SystemOperationCounterPointer[1] = 0x2e726f737365636f;
        SystemOperationCounterPointer[2] = 0x6c726f77656c6174;
        SystemOperationCounterPointer[3] = 0x445c6d6f632e7364;
        *(uint32_t *)(SystemOperationCounterPointer + 4) = 0x50706d75;
        *(uint32_t *)((long long)SystemOperationCounterPointer + 0x24) = 0x65636f72;
        *(uint32_t *)(SystemOperationCounterPointer + 5) = 0x6e697373;
        *(uint32_t *)((long long)SystemOperationCounterPointer + 0x2c) = 0x6c6f4667;
        *(uint32_t *)(SystemOperationCounterPointer + 6) = 0x726564;
        UnsignedStackFlag80 = 0x33;
        pSystemThreadStorage = &pStackParameterC;
      }
      else {
        SystemOperationStatus3 = *(uint8_t *)(SystemGlobalStatusFlags + 0x141);
        pSystemThreadStorage = (void* **)CreateSystemObject(&memoryAllocationEnd,SystemGlobalStatusFlags + 0x148);
        SystemOperationCounterPointer = pUnsignedStackFlag88;
      }
      SystemOperationStatusFlags = CreateSystemObject(&SystemProcessFlagsPointer,pSystemThreadStorage);
      if (isByteValid5) {
        pSystemConfigurationValue = &SystemGlobalDataReference;
        if (SystemOperationCounterPointer != (void* *)0x0) {
            SystemCleanupFunction(SystemOperationCounterPointer);
        }
        pUnsignedStackFlag88 = (void* *)0x0;
        SystemUnsignedFlag78 = SystemUnsignedFlag78 & MAX_UNSIGNED_32_BIT00000000;
        pSystemConfigurationValue = &SystemMemoryAllocatorReference;
      }
      if (!isByteValid5) {
        memoryAllocationEnd = &SystemGlobalDataReference;
        if (SystemStatusFlag48 != 0) {
            SystemCleanupFunction();
        }
        SystemStatusFlag48 = 0;
        SystemContextValue = 0;
        memoryAllocationEnd = &SystemMemoryAllocatorReference;
      }
      SystemDataPointer0 = &SystemStringTemplate;
      if (pSystemSecondaryStatus != (void* *)0x0) {
        SystemDataPointer0 = pSystemSecondaryStatus;
      }
      ProcessSystemConfiguration(SystemOperationStatusFlags,&SystemProcessFlagsPointer,SystemOperationStatus3,0,SystemDataPointer0);
      SystemProcessFlagsPointer = &SystemGlobalDataReference;
      if (LocalSystemStatus != 0) {
          SystemCleanupFunction();
      }
      LocalSystemStatus = 0;
      SystemProcessFlags58 = 0;
      SystemProcessFlagsPointer = &SystemMemoryAllocatorReference;
    }
    SetSystemConfigurationValue(ConfigurationDataPointer,0);
    if (SystemGlobalStatusFlags == 0) {
      charFlag = '\x01';
    }
    else {
      charFlag = *(char *)(SystemGlobalStatusFlags + 0x29);
    }
    if (*(char *)(SystemGlobalStatusFlags + 0x25) != '\0') {
      EmergencySystemExitHandler(SystemGlobalStatusFlags,5);
      systemFunctionPointer = (code *)swi(3);
      SystemOperationStatus1 = (*systemFunctionPointer)();
      return SystemOperationStatus1;
    }
    if (charFlag != '\0') {
      SystemGlobalStateStorage = 5;
    }
    if ((SystemSilentMode == '\0') && (isByteValid4)) {
      if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
        CleanupSystemResources();
      }
      if (SystemRenderManagerPointer != 0) {
        ProcessRenderManagerData(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
      }
    }
    if (SystemThreadHandle != 0) {
      ResumeSystemThreads(SystemThreadHandle);
    }
    do {
      systemIndex = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemIndex == 0);
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    if (pUnsignedStackFlagA8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pUnsignedStackFlagA8 = (void* *)0x0;
    secondarySystemDataBuffer = secondarySystemDataBuffer & MAX_UNSIGNED_32_BIT00000000;
    alternateBufferPtrB0 = &SystemMemoryAllocatorReference;
    if (pSystemSecondaryStatus != (void* *)0x0) {
        SystemCleanupFunction(pSystemSecondaryStatus);
    }
    SystemOperationStatus1 = (ulong long)bStack_d8;
  }
  else {
    if (*(int *)(SystemMemoryBlockSecondary + 0x460) == 1) {
      FormatSystemResourceData(&SystemRuntimeConfigurationData,ConfigurationDataPointer);
    }
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    if (pUnsignedStackFlagA8 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pUnsignedStackFlagA8 = (void* *)0x0;
    secondarySystemDataBuffer = secondarySystemDataBuffer & MAX_UNSIGNED_32_BIT00000000;
    alternateBufferPtrB0 = &SystemMemoryAllocatorReference;
    if (pSystemSecondaryStatus != (void* *)0x0) {
        SystemCleanupFunction(pSystemSecondaryStatus);
    }
  }
  return SystemOperationStatus1;
}





/**
 * @brief 初始化资源管理器配置
 * 
 * 该函数负责初始化资源管理器的配置参数，设置系统资源管理的相关属性
 * 用于系统资源管理的前期准备工作
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_180070680：InitializeResourceManagerConfiguration
 */
void InitializeResourceManagerConfiguration(void* SystemResourceManager,void* ConfigurationDataPointer)

{
  bool isDebuggerPresent;
  char validationStatusFlag;
  int memoryComparisonResult;
  int systemIndex;
  long long systemTimeValue;
  void* *resourceEntryPointer;
  void* ThreadContextFlag;
  void* *SystemThreadStorage;
  bool isSystemBusy;
  void* *systemStackPointer70;
  void* *encryptionValuePointer68;
  uint32_t systemStackValue60;
  void* systemStackValue58;
  void* *memoryAllocationEnd;
  long long systemStackValue48;
  uint32_t systemStackValue38;
  
  systemCounter = WaitForSingleObject(SystemSemaphoreHandle,0);
  if (systemCounter != 0) {
    return;
  }
  isSystemBusy = true;
  SystemOperationResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((SystemOperationResult == '\0') && (systemCounter = IsDebuggerPresent(), systemCounter != 0)) {
    isByteValid = true;
  }
  else {
    isByteValid = false;
  }
  if (SystemAllocationFlagsTemplate != 0) {
    systemCounter = *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
    systemIndex = _Thrd_id();
    isSystemBusy = systemIndex == systemCounter;
  }
  SystemThreadStorage = (void* *)0x0;
  if (!isByteValid) {
    localSystemPointer = ProcessSystemMemoryAllocation(&memoryAllocationEnd,0);
    SystemThreadStorage = *(void* **)(localSystemPointer + 8);
    *(uint32_t *)(localSystemPointer + 0x10) = 0;
    *(void* *)(localSystemPointer + 8) = 0;
    *(void* *)(localSystemPointer + 0x18) = 0;
    memoryAllocationEnd = &SystemGlobalDataReference;
    if (SystemStatusFlag48 != 0) {
        SystemCleanupFunction();
    }
    SystemStatusFlag48 = 0;
    SystemContextValue = 0;
    memoryAllocationEnd = &SystemMemoryAllocatorReference;
  }
  SystemProcessFlagsPointer = &SystemGlobalDataReference;
  SystemProcessFlags58 = 0;
  pEncryptionValue68 = (void* *)0x0;
  SystemThreadContext = 0;
  ConfigureSystemDataBuffer(&SystemProcessFlagsPointer,&SystemConfigurationTemplateA,ConfigurationDataPointer);
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferA);
  resourceEntryPointer = &SystemStringTemplate;
  if (pEncryptionValue68 != (void* *)0x0) {
    resourceEntryPointer = pEncryptionValue68;
  }
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferB,resourceEntryPointer);
  resourceEntryPointer = &SystemStringTemplate;
  if (SystemThreadStorage != (void* *)0x0) {
    SystemCurrentNode = SystemNextNode;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffff00000000,3,resourceEntryPointer);
  InitializeSystemManager();
  SystemThreadStorage = &SystemStringTemplate;
  if (pEncryptionValue68 != (void* *)0x0) {
    SystemThreadStorage = pEncryptionValue68;
  }
  OutputDebugStringA(SystemThreadStorage);
  localSystemPointer = SystemRenderManagerPointer;
  if (((isSystemBusy) && (SystemRenderManagerPointer != 0)) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
    ProcessSystemResourceAllocation(*(void* *)(SystemGlobalStatusFlags + 8),*(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                  *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
    *(uint8_t *)(localSystemPointer + 0x1609) = 1;
  }
  if (SystemSilentMode == '\0') {
    InitializeSystemMemoryManager();
  }
  else {
    ThreadContextFlag = GetSystemStatusFlagsInternal(&SystemProcessFlagsPointer);
    FormatSystemResourceData(ThreadContextFlag);
  }
  InitializeSystemData(&SystemInitializationDataPtr,1);
  _Exit(5);
  return;
}



000180070cdc)
000180070ce2)


/**
 * @brief 初始化系统数据结构
 * 
 * 该函数负责初始化系统的核心数据结构
 * 包括内存管理、资源分配和系统配置
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @param ControlFlag 控制标志
 * @param SystemStatus 系统状态
 * 
 *FUN_180070930：InitializeSystemDataStructure
 */
void InitializeSystemDataStructure(void* SystemResourceManager,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag,
                  char ControlFlag,char SystemStatus)

{
  code *systemFunctionPointer;
  bool isSystemActive;
  char characterProcessingFlag;
  int systemIndex;
  uint currentThreadId;
  uint ResourceHash;
  uint32_t ThreadContextFlag;
  int systemCode;
  long long resourceCounter;
  uint8_t *SystemDataPointer0;
  void* *ThreadLocalStorage;
  uint8_t *pSystemSecondaryStatus;
  byte isByteValid3;
  uint SystemOperationStatus4;
  long long resourceDataIndex5;
  long long resourceDataIndex6;
  void* *SystemDataBufferPointer;
  ulong long SystemContextPointer;
  uint8_t SystemConcatenatedBuffer448 [32];
  uint8_t *SystemBytePointer;
  void* *SystemResourcePointer160;
  uint8_t *pSystemConfigurationId;
  uint8_t SystemThreadId148;
  char SystemStatusCharacter;
  void* *pSystemThreadContext140;
  uint8_t *SystemMemoryContext;
  uint StackValue2;
  ulong long SystemMemoryOffset;
  char controlFlag;
  char validationFlag;
  uint32_t StackUnsignedValue11C;
  void* *pUnsignedStackFlag118;
  uint8_t *pUnsignedStackFlag110;
  uint EncryptionOffset1;
  void* EncryptionOffset2;
  void* *pMemoryBufferAddress;
  void* *SystemResourcePointerF0;
  uint32_t SystemConfigurationFlag;
  void* *systemDataPointer;
  long long lStack_d0;
  uint32_t UnsignedStackFlagC0;
  uint32_t secondarySystemDataBuffer;
  uint32_t StackUnsignedValue94;
  long long SystemConfigurationFlags;
  long long SystemConfigurationData;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  void* ConcatenatedValue44;
  ulong long SystemEncryptionKey;
  long long resourceDataIndex7;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)SystemConcatenatedBuffer448;
  controlFlag = ControlFlag;
  SystemDataPointer0 = (uint8_t *)0x0;
  SystemOperationStatus4 = 0;
  SystemOperationMode = 0;
  SystemThreadId148 = 0;
  SystemProcessFlags58 = 0;
  ConcatenatedValue44 = 0;
  secondarySystemDataBuffer = AdditionalParameter;
  SystemConfigurationData = ConfigurationFlag;
  FormatSystemResourceString(&SystemProcessFlags58,0x10,&SystemDataBufferTemplateI,AdditionalParameter);
  resourceCounter = ProcessSystemQueue(&SystemMemoryAllocatorReferencePointer,ConfigurationFlag);
  pUnsignedStackFlag118 = &SystemGlobalDataReference;
  EncryptionOffset2 = 0;
  pUnsignedStackFlag110 = (uint8_t *)0x0;
  EncryptionOffset1 = 0;
  SystemOperationMode = 4;
  ResourceHash = *(uint *)(resourceCounter + 0x10);
  SystemContextPointer = (ulong long)ResourceHash;
  currentThreadId = 0;
  if (*(long long *)(resourceCounter + 8) == 0) {
LAB_180070a3f:
    SystemOperationStatus4 = currentThreadId;
    if (ResourceHash != 0) {
        memcpy(SystemDataPointer0,*(void* *)(resourceCounter + 8),SystemContextPointer);
    }
  }
  else if (ResourceHash != 0) {
    systemIndex = ResourceHash + 1;
    if (systemIndex < 0x10) {
      systemIndex = 0x10;
    }
    SystemDataPointer0 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemIndex,0x13);
    *SystemDataPointer0 = 0;
    pUnsignedStackFlag110 = SystemDataPointer0;
    currentThreadId = StartSystemThread(SystemDataPointer0);
    EncryptionOffset2 = ConcatenatedValue44(EncryptionOffset2._4_4_,currentThreadId);
    goto LAB_180070a3f;
  }
  if (SystemDataPointer0 != (uint8_t *)0x0) {
    SystemDataPointer0[SystemContextPointer] = 0;
  }
  currentThreadId = *(uint *)(resourceCounter + 0x1c);
  EncryptionOffset1 = ResourceHash;
  EncryptionOffset2._4_4_ = currentThreadId;
  if (ConfigurationDataPointer != 0) {
    resourceCounter = -1;
    do {
      resourceDataIndex5 = resourceCounter;
      resourceCounter = resourceDataIndex5 + 1;
    } while (*(char *)(ConfigurationDataPointer + resourceCounter) != '\0');
    if (0 < (int)resourceCounter) {
      systemIndex = ResourceHash + (int)resourceCounter;
      if (systemIndex != 0) {
        ResourceHash = systemIndex + 1;
        if (SystemDataPointer0 == (uint8_t *)0x0) {
          if ((int)ResourceHash < 0x10) {
            ResourceHash = 0x10;
          }
          SystemDataPointer0 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)ResourceHash,0x13);
          *SystemDataPointer0 = 0;
        }
        else {
          if (ResourceHash <= SystemOperationStatus4) goto LAB_180070b00;
          SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
          SystemDataPointer0 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemDataPointer0,ResourceHash,0x10);
        }
        pUnsignedStackFlag110 = SystemDataPointer0;
        EncryptionOffset2._0_4_ = StartSystemThread(SystemDataPointer0);
      }
LAB_180070b00:
        memcpy(SystemDataPointer0 + SystemContextPointer,ConfigurationDataPointer,(long long)((int)resourceDataIndex5 + 2));
    }
  }
  AllocateSystemMemoryBuffer(&pUnsignedStackFlag118,&pMemoryBufferAddress,&SystemProcessFlags58);
  SystemControlFlag = 0;
  SystemOperationMode = 0;
  pUnsignedStackFlag118 = &SystemGlobalDataReference;
  if (SystemDataPointer0 != (uint8_t *)0x0) {
      SystemCleanupFunction(SystemDataPointer0);
  }
  pUnsignedStackFlag110 = (uint8_t *)0x0;
  EncryptionOffset2 = (ulong long)EncryptionOffset2._4_4_ << 0x20;
  pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
  SystemMemoryAllocatorReferencePointer = &SystemGlobalDataReference;
  if (lStack_d0 != 0) {
      SystemCleanupFunction();
  }
  lStack_d0 = 0;
  UnsignedStackFlagC0 = 0;
  SystemMemoryAllocatorReferencePointer = &SystemMemoryAllocatorReference;
  SystemDataBufferPointer = &SystemStringTemplate;
  if (pSystemResourceDataIndex != (void* *)0x0) {
    SystemDataBufferPointer = pSystemResourceDataIndex;
  }
  charFlag = GetConfigurationDataStatus(SystemDataBufferPointer);
  if (charFlag != '\0') {
    pMemoryBufferAddress = &SystemGlobalDataReference;
    if (pSystemResourceDataIndex != (void* *)0x0) {
        SystemCleanupFunction();
    }
    goto LAB_1800718e9;
  }
  systemIndex = WaitForSingleObject(SystemSemaphoreHandle,1);
  resourceCounter = SystemAllocationFlagsTemplate;
  if (systemIndex != 0) {
    pMemoryBufferAddress = &SystemGlobalDataReference;
    if (pSystemResourceDataIndex != (void* *)0x0) {
        SystemCleanupFunction();
    }
    goto LAB_1800718e9;
  }
  SystemConfigurationFlags = SystemAllocationFlagsTemplate;
  pSystemThreadContext140 = &SystemGlobalDataReference;
  SystemMemoryOffset = 0;
  SystemMemoryContext = (uint8_t *)0x0;
  StackValue2 = 0;
  SystemDataBufferPointer = &SystemRootDataPtr;
  if (controlFlag != '\0') {
    SystemDataBufferPointer = &SystemStatusDataPointer;
  }
  resourceDataIndex5 = -1;
  do {
    resourceDataIndex6 = resourceDataIndex5;
    resourceDataIndex5 = resourceDataIndex6 + 1;
  } while (SystemDataBufferPointer[resourceDataIndex5] != '\0');
  systemIndex = (int)resourceDataIndex5;
  if (0 < systemIndex) {
    if (systemIndex != 0) {
      systemIndex = systemIndex + 1;
      if (systemIndex < 0x10) {
        systemIndex = 0x10;
      }
      SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemIndex,0x13);
      *SystemMemoryContext = 0;
      ThreadContextFlag = StartSystemThread(SystemMemoryContext);
      SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
    }
      memcpy(SystemMemoryContext + StackValue2,SystemDataBufferPointer,(long long)((int)resourceDataIndex6 + 2));
  }
  SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
  *SystemMemoryContext = 0;
  currentThreadId = StartSystemThread(SystemMemoryContext);
  SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,currentThreadId);
  *(void*2 *)(SystemMemoryContext + StackValue2) = 10;
  StackValue2 = 1;
  ResourceHash = 2;
  if (SystemMemoryContext == (uint8_t *)0x0) {
    StackValue2 = 1;
    SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
    *SystemMemoryContext = 0;
LAB_180070db8:
    ThreadContextFlag = StartSystemThread(SystemMemoryContext);
    SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
  }
  else if (currentThreadId < 3) {
    SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
    StackValue2 = 1;
    SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,3,0x10);
    goto LAB_180070db8;
  }
  *(void*2 *)(SystemMemoryContext + StackValue2) = 10;
  StackValue2 = 2;
  if (ConfigurationDataPointer != 0) {
    resourceDataIndex5 = -1;
    do {
      resourceDataIndex6 = resourceDataIndex5;
      resourceDataIndex5 = resourceDataIndex6 + 1;
    } while (*(char *)(ConfigurationDataPointer + resourceDataIndex5) != '\0');
    systemIndex = (int)resourceDataIndex5;
    if (0 < systemIndex) {
      currentThreadId = ResourceHash;
      if (systemIndex != -2) {
        SystemOperationStatus4 = systemIndex + 3;
        if (SystemMemoryContext == (uint8_t *)0x0) {
          if ((int)SystemOperationStatus4 < 0x10) {
            SystemOperationStatus4 = 0x10;
          }
          StackValue2 = ResourceHash;
          SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)SystemOperationStatus4,0x13);
          *SystemMemoryContext = 0;
        }
        else {
          currentThreadId = StackValue2;
          if (SystemOperationStatus4 <= (uint)SystemMemoryOffset) goto LAB_180070e64;
          SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
          StackValue2 = ResourceHash;
          SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,SystemOperationStatus4,0x10);
        }
        ThreadContextFlag = StartSystemThread(SystemMemoryContext);
        SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
        currentThreadId = StackValue2;
      }
LAB_180070e64:
      StackValue2 = currentThreadId;
        memcpy(SystemMemoryContext + StackValue2,ConfigurationDataPointer,(long long)((int)resourceDataIndex6 + 2));
    }
  }
  if (SystemMemoryContext == (uint8_t *)0x0) {
    StackValue2 = ResourceHash;
    SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
    *SystemMemoryContext = 0;
LAB_180070ee8:
    ThreadContextFlag = StartSystemThread(SystemMemoryContext);
    SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
  }
  else if ((uint)SystemMemoryOffset < 4) {
    SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
    StackValue2 = ResourceHash;
    SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,4,0x10);
    goto LAB_180070ee8;
  }
  *(void*2 *)(SystemMemoryContext + StackValue2) = 0x3a;
  StackValue2 = 3;
  ProcessSystemData(&pSystemThreadContext140,secondarySystemDataBuffer);
  ResourceHash = StackValue2;
  currentThreadId = StackValue2 + 1;
  if (currentThreadId != 0) {
    SystemOperationStatus4 = StackValue2 + 2;
    if (SystemMemoryContext == (uint8_t *)0x0) {
      if ((int)SystemOperationStatus4 < 0x10) {
        SystemOperationStatus4 = 0x10;
      }
      SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)SystemOperationStatus4,0x13);
      *SystemMemoryContext = 0;
    }
    else {
      if (SystemOperationStatus4 <= (uint)SystemMemoryOffset) goto LAB_180070f81;
      SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
      SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,SystemOperationStatus4,0x10);
    }
    ThreadContextFlag = StartSystemThread(SystemMemoryContext);
    SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
  }
LAB_180070f81:
  *(void*2 *)(SystemMemoryContext + StackValue2) = 10;
  SystemOperationStatus4 = ResourceHash + 0xd;
  StackValue2 = currentThreadId;
  if (SystemOperationStatus4 != 0) {
    currentThreadId = ResourceHash + 0xe;
    if (SystemMemoryContext == (uint8_t *)0x0) {
      if ((int)currentThreadId < 0x10) {
        currentThreadId = 0x10;
      }
      SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)currentThreadId,0x13);
      *SystemMemoryContext = 0;
    }
    else {
      if (currentThreadId <= (uint)SystemMemoryOffset) goto LAB_180071000;
      SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
      SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,currentThreadId,0x10);
    }
    ThreadContextFlag = StartSystemThread(SystemMemoryContext);
    SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
  }
LAB_180071000:
  resourceDataIndex5 = SystemConfigurationData;
  ThreadLocalStorage = (void* *)(SystemMemoryContext + StackValue2);
  *ThreadLocalStorage = 0x6973736572707845;
  *(uint32_t *)(ThreadLocalStorage + 1) = 0x203a6e6f;
  *(uint8_t *)((long long)ThreadLocalStorage + 0xc) = 0;
  resourceDataIndex6 = -1;
  StackValue2 = SystemOperationStatus4;
  if (SystemConfigurationData != 0) {
    do {
      resourceDataIndex7 = resourceDataIndex6;
      resourceDataIndex6 = resourceDataIndex7 + 1;
    } while (*(char *)(SystemConfigurationData + resourceDataIndex6) != '\0');
    if (0 < (int)resourceDataIndex6) {
      systemIndex = SystemOperationStatus4 + (int)resourceDataIndex6;
      if (systemIndex != 0) {
        ResourceHash = systemIndex + 1;
        if (SystemMemoryContext == (uint8_t *)0x0) {
          if ((int)ResourceHash < 0x10) {
            ResourceHash = 0x10;
          }
          SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)ResourceHash,0x13);
          *SystemMemoryContext = 0;
        }
        else {
          if (ResourceHash <= (uint)SystemMemoryOffset) goto LAB_1800710b8;
          SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
          SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,ResourceHash,0x10);
        }
        ThreadContextFlag = StartSystemThread(SystemMemoryContext);
        SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
      }
LAB_1800710b8:
        memcpy(SystemMemoryContext + StackValue2,resourceDataIndex5,(long long)((int)resourceDataIndex7 + 2));
    }
  }
  systemIndex = ResourceHash + 0xe;
  if (systemIndex != 0) {
    ResourceHash = ResourceHash + 0xf;
    if (SystemMemoryContext == (uint8_t *)0x0) {
      if ((int)ResourceHash < 0x10) {
        ResourceHash = 0x10;
      }
      SystemMemoryContext = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)ResourceHash,0x13);
      *SystemMemoryContext = 0;
    }
    else {
      if (ResourceHash <= (uint)SystemMemoryOffset) goto LAB_18007113f;
      SystemBytePointer = (uint8_t *)CONCAT71(SystemBytePointer._1_7_,0x13);
      SystemMemoryContext = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemMemoryContext,ResourceHash,0x10);
    }
    ThreadContextFlag = StartSystemThread(SystemMemoryContext);
    SystemMemoryOffset = ConcatenatedValue44(SystemMemoryOffset.HighPart,ThreadContextFlag);
  }
LAB_18007113f:
  *(void*2 *)(SystemMemoryContext + StackValue2) = 10;
  StackValue2 = systemIndex;
  if (resourceCounter != 0) {
    ProcessSystemResourceOffset(resourceCounter);
  }
  isByteValid3 = 1;
  validationFlag = '\x01';
  charFlag = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
  if ((charFlag != '\0') || (systemIndex = IsDebuggerPresent(), systemIndex == 0)) {
    isByteValid3 = 0;
  }
  if (SystemGlobalStatusFlags == 0) {
    SystemStatusCharacter = '\0';
  }
  else {
    SystemStatusCharacter = *(char *)(SystemGlobalStatusFlags + 0x24);
  }
  isSystemActive = true;
  if (resourceCounter != 0) {
    systemIndex = *(int *)(**(long long **)(resourceCounter + 8) + 0x48);
    systemCode = _Thrd_id();
    validationFlag = systemCode == systemIndex;
    isSystemActive = (bool)validationFlag;
  }
  resourceCounter = SystemRenderManagerPointer;
  if ((SystemSilentMode == '\0') && (isSystemActive)) {
    if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
      ProcessSystemResourceAllocation(*(void* *)(SystemGlobalStatusFlags + 8),*(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                    *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
      *(uint8_t *)(resourceCounter + 0x1609) = 1;
    }
    if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
      ValidateSystemResourceStatus();
    }
  }
  pUnsignedStackFlag118 = &SystemGlobalDataReference;
  EncryptionOffset2 = 0;
  pUnsignedStackFlag110 = (uint8_t *)0x0;
  EncryptionOffset1 = 0;
  if (isByteValid3 == 0) {
    resourceCounter = ProcessSystemMemoryAllocation(&SystemMemoryAllocatorReferencePointer,0);
    EncryptionOffset1 = *(uint *)(resourceCounter + 0x10);
    pUnsignedStackFlag110 = *(uint8_t **)(resourceCounter + 8);
    EncryptionOffset2 = *(ulong long *)(resourceCounter + 0x18);
    *(uint32_t *)(resourceCounter + 0x10) = 0;
    *(void* *)(resourceCounter + 8) = 0;
    *(void* *)(resourceCounter + 0x18) = 0;
    SystemMemoryAllocatorReferencePointer = &SystemGlobalDataReference;
    if (lStack_d0 != 0) {
        SystemCleanupFunction();
    }
    lStack_d0 = 0;
    UnsignedStackFlagC0 = 0;
    SystemMemoryAllocatorReferencePointer = &SystemMemoryAllocatorReference;
  }
  SystemDataPointer0 = pUnsignedStackFlag110;
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferA);
  SystemBytePointer = &SystemStringTemplate;
  if (SystemMemoryContext != (uint8_t *)0x0) {
    SystemBytePointer = SystemMemoryContext;
  }
  ConfigureSystemManager(SystemContextManagerPointer,4,0xffffffff00000000,&SystemConfigurationDataBufferB);
  SystemBytePointer = &SystemStringTemplate;
  if (SystemDataPointer0 != (uint8_t *)0x0) {
    SystemBytePointer = SystemDataPointer0;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,4,0xffffffff00000000,3);
  InitializeSystemManager();
  pSystemSecondaryStatus = &SystemStringTemplate;
  if (SystemMemoryContext != (uint8_t *)0x0) {
    pSystemSecondaryStatus = SystemMemoryContext;
  }
  OutputDebugStringA(pSystemSecondaryStatus);
  ProcessResourceDataIndex(resourceDataIndex5);
  if (SystemInitializationFlag != '\0') {
    if (isByteValid3 != 0) {
      if (((SystemStatusCharacter == '\0') && (SystemStatus != '\0')) && (*(int *)(SystemGlobalStatusFlags + 0x340) != 2)) {
        SystemThreadId148 = 1;
      }
      else if (SystemDebugFlag == '\0') {
        systemFunctionPointer = (code *)swi(3);
        (*systemFunctionPointer)();
        return;
      }
    }
    if ((SystemInitializationFlag == 0) || (*(int *)(SystemInitializationFlag + 0x168) == 2)) {
      ConfigureSystemManager(SystemContextManagerPointer,4,0xffffffff00000000,&SystemSecurityDataBuffer);
      InitializeSystemManager();
      systemIndex = IsDebuggerPresent();
      if ((systemIndex != 0) && (SystemDebugFlag == '\0')) {
        systemFunctionPointer = (code *)swi(3);
        (*systemFunctionPointer)();
        return;
      }
    }
  }
  if (SystemSilentMode == '\0') {
    SystemDataBufferPointer = &SystemThreadDataPointer;
    if (controlFlag != '\0') {
      SystemDataBufferPointer = &SystemProcessDataPointer;
    }
    do {
      while( true ) {
        pSystemSecondaryStatus = &SystemStringTemplate;
        if (SystemMemoryContext != (uint8_t *)0x0) {
          pSystemSecondaryStatus = SystemMemoryContext;
        }
        if (((SystemInitializationFlag == '\0') || (systemIndex = IsDebuggerPresent(), systemIndex != 0)) &&
           (SystemSilentMode == '\0')) break;
        if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
          SystemBytePointer = &SystemStackDataTemplate1;
          SystemResourcePointer160 = SystemDataBufferPointer;
          pSystemConfigurationId = pSystemSecondaryStatus;
          SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd);
        }
      }
      ThreadContextFlag = MessageBoxA(0,pSystemSecondaryStatus,SystemDataBufferPointer,0x52012);
      switch(ThreadContextFlag) {
      case 1:
        systemIndex = 0;
        break;
      default:
        systemIndex = 1;
        break;
      case 4:
        systemIndex = 2;
        break;
      case 5:
        systemIndex = 3;
        break;
      case 6:
        systemIndex = 4;
        break;
      case 7:
        systemIndex = 5;
      }
    } while (systemIndex == 1);
    if (systemIndex == 2) {
      if (isByteValid3 == 0) {
        pSystemSecondaryStatus = &SystemStringTemplate;
        if (SystemDataPointer0 != (uint8_t *)0x0) {
          pSystemSecondaryStatus = SystemDataPointer0;
        }
        if (((SystemInitializationFlag == '\0') || (systemIndex = IsDebuggerPresent(), systemIndex != 0)) &&
           (SystemSilentMode == '\0')) {
          MessageBoxA(0,pSystemSecondaryStatus,&SystemErrorMessageBuffer,0x41010);
        }
        else if (*(char *)(SystemContextManagerPointer + 0x18) != '\0') {
          SystemResourcePointer160 = &SystemErrorMessageBuffer;
          SystemBytePointer = &SystemStackDataTemplate1;
          pSystemConfigurationId = pSystemSecondaryStatus;
          SystemManagerSetFlags(SystemContextManagerPointer,3,0xffffffff00000000,0xd);
        }
      }
      else if (((SystemStatus == '\0') || (*(int *)(SystemGlobalStatusFlags + 0x340) == 2)) &&
              (SystemDebugFlag == '\0')) {
        systemFunctionPointer = (code *)swi(3);
        (*systemFunctionPointer)();
        return;
      }
    }
    else if (systemIndex == 3) goto LAB_1800715eb;
    if (SystemGlobalStatusFlags == 0) {
      charFlag = '\x01';
    }
    else {
      charFlag = *(char *)(SystemGlobalStatusFlags + 0x29);
    }
    if (SystemStatusCharacter != '\0') {
      EmergencySystemExitHandler(charFlag,5);
      systemFunctionPointer = (code *)swi(3);
      (*systemFunctionPointer)();
      return;
    }
    if (charFlag != '\0') {
      SystemGlobalStateStorage = 5;
    }
    if ((SystemSilentMode == '\0') && (validationFlag != '\0')) {
      if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
        CleanupSystemResources();
      }
      if (SystemRenderManagerPointer != 0) {
        ProcessRenderManagerData(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
      }
    }
    if (SystemConfigurationFlags != 0) {
      ResumeSystemThreads();
    }
    do {
      systemIndex = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (systemIndex == 0);
    pUnsignedStackFlag118 = &SystemGlobalDataReference;
    if (SystemDataPointer0 != (uint8_t *)0x0) {
        SystemCleanupFunction(SystemDataPointer0);
    }
    pUnsignedStackFlag110 = (uint8_t *)0x0;
    EncryptionOffset2 = EncryptionOffset2 & MAX_UNSIGNED_32_BIT00000000;
    pUnsignedStackFlag118 = &SystemMemoryAllocatorReference;
    pSystemThreadContext140 = &SystemGlobalDataReference;
    if (SystemMemoryContext != (uint8_t *)0x0) {
        SystemCleanupFunction();
    }
    SystemMemoryContext = (uint8_t *)0x0;
    SystemMemoryOffset = SystemMemoryOffset & MAX_UNSIGNED_32_BIT00000000;
    pSystemThreadContext140 = &SystemMemoryAllocatorReference;
    pMemoryBufferAddress = &SystemGlobalDataReference;
    if (pSystemResourceDataIndex != (void* *)0x0) {
        SystemCleanupFunction();
    }
LAB_1800718e9:
    SystemThreadState = 0;
    SystemResourcePointerF0 = (void* *)0x0;
    pMemoryBufferAddress = &SystemMemoryAllocatorReference;
      ValidateSystemChecksum(SystemEncryptionKey ^ (ulong long)SystemConcatenatedBuffer448);
  }
LAB_1800715eb:
  SystemDataBufferPointer = &SystemStringTemplate;
  if (pSystemResourceDataIndex != (void* *)0x0) {
    SystemDataBufferPointer = pSystemResourceDataIndex;
  }
  ThreadContextFlag = GetSystemContextFlag(SystemDataBufferPointer);
    UpdateContextManagerSystem(SystemContextManagerPointer,&SystemConfigurationDataBufferE,isByteValid3 ^ 1,ThreadContextFlag);
}



000180071b49)
000180071ad3)
000180071a52)
000180071c73)


/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，包括线程创建、内存分配和资源配置
 * 用于系统资源的统一管理和调度
 * 
 * @param SystemResourceManager 资源管理器指针，指向要初始化的资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含资源配置的相关信息
 * @param AdditionalParameter 额外参数，用于初始化过程中的附加配置
 * @param ConfigurationFlag 配置标志，指定初始化的方式和选项
 * @return 无返回值
 * 
 *FUN_180071940：InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(void* SystemResourceManager,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag)

{
  int SystemOperationStatus;
  uint threadCreationFlags;
  uint32_t memoryAllocationContext;
  long long systemBufferAddress;
  void* *threadIdPointer;
  uint32_t *resourceEntryPointer;
  void** systemCurrentNode;
  uint8_t *threadLocalStorage;
  void* *systemValuePointer;
  long long memoryAllocationFlags;
  uint systemOperationStatus1;
  uint systemOperationStatus2;
  void* *stackParameterPointer;
  uint8_t *threadObjectPointer;
  uint stackParameterOffset;
  ulong long threadHandleValue;
  void* *globalDataPointer;
  void* *encryptionKeyPointer;
  uint32_t bufferFlags;
  void* bufferDataPointer;
  void* *memoryAllocationEndPointer;
  long long debugFlag;
  uint32_t allocationSize;
  
  SystemOperationStatus = WaitForSingleObject(SystemSemaphoreHandle,0);
  if (SystemOperationStatus != 0) {
    return;
  }
  systemValuePointer = (void* *)0x0;
  globalDataPointer = &SystemGlobalDataReference;
  bufferDataPointer = 0;
  encryptionKeyPointer = (void* *)0x0;
  bufferFlags = 0;
  SystemOperationStatus = IsDebuggerPresent();
  if (SystemOperationStatus == 0) {
    systemBufferAddress = GetSystemMemoryBuffer(&memoryAllocationEndPointer,0);
    bufferFlags = *(uint32_t *)(systemBufferAddress + 0x10);
    systemValuePointer = *(void* **)(systemBufferAddress + 8);
    bufferDataPointer = *(void* *)(systemBufferAddress + 0x18);
    *(uint32_t *)(systemBufferAddress + 0x10) = 0;
    *(void* *)(systemBufferAddress + 8) = 0;
    *(void* *)(systemBufferAddress + 0x18) = 0;
    memoryAllocationEndPointer = &SystemGlobalDataReference;
    encryptionKeyPointer = systemValuePointer;
    if (debugFlag != 0) {
        SystemCleanupFunction();
    }
    debugFlag = 0;
    allocationSize = 0;
    memoryAllocationEndPointer = &SystemMemoryAllocatorReference;
  }
  pSystemConfigurationValue = &SystemGlobalDataReference;
  threadHandleValue = 0;
  threadObjectPointer = (uint8_t *)0x0;
  stackParameterOffset = 0;
  threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x12,0x13);
  *threadObjectPointer = 0;
  threadCreationFlags = StartSystemThread(threadObjectPointer);
  threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,threadCreationFlags);
  resourceEntryPointer = (uint32_t *)(threadObjectPointer + stackParameterOffset);
  *resourceEntryPointer = 0x65737341;
  resourceEntryPointer[1] = 0x6f697472;
  resourceEntryPointer[2] = 0x6146206e;
  resourceEntryPointer[3] = 0x64656c69;
  *(void*2 *)(systemCurrentNode + 4) = 0x21;
  stackParameterOffset = 0x11;
  if (threadObjectPointer == (uint8_t *)0x0) {
    stackParameterOffset = 0x11;
    threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x13,0x13);
    *threadObjectPointer = 0;
LAB_180071af3:
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,memoryAllocationContext);
  }
  else if (threadCreationFlags < 0x13) {
    stackParameterOffset = 0x11;
    threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,0x13,0x10,0x13);
    goto LAB_180071af3;
  }
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 10;
  stackParameterOffset = 0x12;
  threadCreationFlags = 0x13;
  if (threadObjectPointer == (uint8_t *)0x0) {
    stackParameterOffset = 0x12;
    threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x14,0x13);
    *threadObjectPointer = 0;
LAB_180071b69:
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,memoryAllocationContext);
  }
  else if ((uint)threadHandleValue < 0x14) {
    stackParameterOffset = 0x12;
    threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,0x14,0x10,0x13);
    goto LAB_180071b69;
  }
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 10;
  stackParameterOffset = 0x13;
  if (ConfigurationDataPointer != 0) {
    systemBufferAddress = -1;
    do {
      memoryAllocationFlags = systemBufferAddress;
      systemBufferAddress = memoryAllocationFlags + 1;
    } while (*(char *)(ConfigurationDataPointer + systemBufferAddress) != '\0');
    SystemOperationStatus = (int)systemBufferAddress;
    if (0 < SystemOperationStatus) {
      systemOperationStatus1 = threadCreationFlags;
      if (SystemOperationStatus != -0x13) {
        systemOperationStatus2 = SystemOperationStatus + 0x14;
        if (threadObjectPointer == (uint8_t *)0x0) {
          if ((int)systemOperationStatus2 < 0x10) {
            systemOperationStatus2 = 0x10;
          }
          stackParameterOffset = threadCreationFlags;
          threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemOperationStatus2,0x13);
          *threadObjectPointer = 0;
        }
        else {
          systemOperationStatus1 = stackParameterOffset;
          if (systemOperationStatus2 <= (uint)threadHandleValue) goto LAB_180071c1a;
          stackParameterOffset = threadCreationFlags;
          threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,systemOperationStatus2,0x10,0x13);
        }
        memoryAllocationContext = StartSystemThread(threadObjectPointer);
        threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,memoryAllocationContext);
        systemOperationStatus1 = stackParameterOffset;
      }
LAB_180071c1a:
      stackParameterOffset = systemOperationStatus1;
        memcpy(threadObjectPointer + stackParameterOffset,ConfigurationDataPointer,(long long)((int)memoryAllocationFlags + 2));
    }
  }
  if (threadObjectPointer == (uint8_t *)0x0) {
    stackParameterOffset = threadCreationFlags;
    threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x15,0x13);
    *threadObjectPointer = 0;
LAB_180071c93:
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,memoryAllocationContext);
  }
  else if ((uint)threadHandleValue < 0x15) {
    stackParameterOffset = threadCreationFlags;
    threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,0x15,0x10,0x13);
    goto LAB_180071c93;
  }
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 0x3a;
  stackParameterOffset = 0x14;
  ProcessSystemData(&stackParameterPointer,AdditionalParameter);
  threadCreationFlags = stackParameterOffset;
  systemOperationStatus1 = stackParameterOffset + 1;
  if (systemOperationStatus1 != 0) {
    systemOperationStatus2 = stackParameterOffset + 2;
    if (threadObjectPointer == (uint8_t *)0x0) {
      if ((int)systemOperationStatus2 < 0x10) {
        systemOperationStatus2 = 0x10;
      }
      threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemOperationStatus2,0x13);
      *threadObjectPointer = 0;
    }
    else {
      if (systemOperationStatus2 <= (uint)threadHandleValue) goto LAB_180071d1f;
      threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,systemOperationStatus2,0x10,0x13);
    }
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,memoryAllocationContext);
  }
LAB_180071d1f:
  *(void*2 *)(threadObjectPointer + stackParameterOffset) = 10;
  systemOperationStatus2 = threadCreationFlags + 0xd;
  stackParameterOffset = systemOperationStatus1;
  if (systemOperationStatus2 != 0) {
    systemOperationStatus1 = threadCreationFlags + 0xe;
    if (threadObjectPointer == (uint8_t *)0x0) {
      if ((int)systemOperationStatus1 < 0x10) {
        systemOperationStatus1 = 0x10;
      }
      threadObjectPointer = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)systemOperationStatus1,0x13);
      *threadObjectPointer = 0;
    }
    else {
      if (systemOperationStatus1 <= (uint)threadHandleValue) goto LAB_180071d94;
      threadObjectPointer = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,threadObjectPointer,systemOperationStatus1,0x10,0x13);
    }
    memoryAllocationContext = StartSystemThread(threadObjectPointer);
    threadHandleValue = ConcatenatedValue44(threadHandleValue._4_4_,memoryAllocationContext);
  }
LAB_180071d94:
  hashTableNode = (void* *)(threadObjectPointer + stackParameterOffset);
  *hashTableNode = 0x6973736572707845;
  *(uint32_t *)(hashTableNode + 1) = 0x203a6e6f;
  *(uint8_t *)((long long)hashTableNode + 0xc) = 0;
  SystemBufferAddress = -1;
  UnsignedStackFlag80 = SystemSecondaryStatus;
  if (ConfigurationFlag != 0) {
    do {
      SystemAllocationFlags = SystemBufferAddress;
      SystemBufferAddress = SystemAllocationFlags + 1;
    } while (*(char *)(ConfigurationFlag + SystemBufferAddress) != '\0');
    if (0 < (int)SystemBufferAddress) {
      SystemOperationStatus = SystemSecondaryStatus + (int)SystemBufferAddress;
      if (SystemOperationStatus != 0) {
        resourceCreationFlags = SystemOperationStatus + 1;
        if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
          if ((int)resourceCreationFlags < 0x10) {
            resourceCreationFlags = 0x10;
          }
          pUnsignedStackFlag88 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)resourceCreationFlags,0x13);
          *pUnsignedStackFlag88 = 0;
        }
        else {
          if (resourceCreationFlags <= (uint)SystemUnsignedFlag78) goto LAB_180071e34;
          pUnsignedStackFlag88 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,pUnsignedStackFlag88,resourceCreationFlags,0x10,0x13);
        }
        resourceAllocationContext = StartSystemThread(pUnsignedStackFlag88);
        SystemUnsignedFlag78 = ConcatenatedValue44(SystemUnsignedFlag78.HighPart,resourceAllocationContext);
      }
LAB_180071e34:
        memcpy(pUnsignedStackFlag88 + UnsignedStackFlag80,ConfigurationFlag,(long long)((int)SystemAllocationFlags + 2));
    }
  }
  if (resourceCreationFlags + 0xe != 0) {
    SystemOperationStatus1 = resourceCreationFlags + 0xf;
    if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
      if ((int)SystemOperationStatus1 < 0x10) {
        SystemOperationStatus1 = 0x10;
      }
      pUnsignedStackFlag88 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)SystemOperationStatus1,0x13);
      *pUnsignedStackFlag88 = 0;
    }
    else {
      if (SystemOperationStatus1 <= (uint)SystemUnsignedFlag78) goto LAB_180071eb0;
      pUnsignedStackFlag88 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,pUnsignedStackFlag88,SystemOperationStatus1,0x10,0x13);
    }
    resourceAllocationContext = StartSystemThread(pUnsignedStackFlag88);
    SystemUnsignedFlag78 = ConcatenatedValue44(SystemUnsignedFlag78.HighPart,resourceAllocationContext);
  }
LAB_180071eb0:
  *(void*2 *)(pUnsignedStackFlag88 + UnsignedStackFlag80) = 10;
  UnsignedStackFlag80 = resourceCreationFlags + 0xe;
  ConfigureSystemManager(SystemContextManagerPointer,5,0xffffffff00000000,&SystemConfigurationDataBufferA);
  SystemThreadStorage = &SystemStringTemplate;
  if (pUnsignedStackFlag88 != (uint8_t *)0x0) {
    SystemThreadStorage = pUnsignedStackFlag88;
  }
  ConfigureSystemManager(SystemContextManagerPointer,4,0xffffffff00000000,&SystemConfigurationDataBufferD,SystemThreadStorage);
  SystemThreadContext = &SystemStringTemplate;
  if (SystemOperationCounterPointer != (void* *)0x0) {
    SystemThreadContext = SystemOperationCounterPointer;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,4,0xffffffff00000000,3,SystemThreadContext);
  InitializeSystemManager();
  SystemThreadStorage = &SystemStringTemplate;
  if (pUnsignedStackFlag88 != (uint8_t *)0x0) {
    SystemThreadStorage = pUnsignedStackFlag88;
  }
  OutputDebugStringA(SystemThreadStorage);
  do {
    SystemOperationStatus = ReleaseSemaphore(SystemSemaphoreHandle,1);
  } while (SystemOperationStatus == 0);
  pSystemConfigurationValue = &SystemGlobalDataReference;
  if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
    pUnsignedStackFlag88 = (uint8_t *)0x0;
    SystemUnsignedFlag78 = SystemUnsignedFlag78 & MAX_UNSIGNED_32_BIT00000000;
    pSystemConfigurationValue = &SystemMemoryAllocatorReference;
    SystemProcessFlagsPointer = &SystemGlobalDataReference;
    if (SystemOperationCounterPointer == (void* *)0x0) {
      return;
    }
      SystemCleanupFunction(SystemOperationCounterPointer);
  }
    SystemCleanupFunction();
}



00018007258a)
0001800724fe)
00018007246a)
0001800726c4)


// 函数: void InitializeSystemResourceManagerEx3(void* SystemResourceManager,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag,
/**
 * @brief 系统资源操作处理函数
 * 
 * 该函数负责处理系统资源的各种操作，包括资源分配、数据处理和系统模式配置。
 * 函数会根据操作类型和系统模式执行相应的资源管理操作。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @param OperationType 操作类型
 * @param SystemMode 系统模式
 * 
 *FUN_180072000：ProcessSystemResourceOperation
 */
void ProcessSystemResourceOperation(void* SystemResourceManager,long long ConfigurationDataPointer,uint32_t AdditionalParameter,long long ConfigurationFlag,
                  uint8_t OperationType,char SystemMode)

{
  code *systemFunctionPointer;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  uint resourceAddress;
  int systemValue;
  uint ResourceHash;
  uint32_t ThreadContextFlag;
  uint OperationCode;
  long long resourceCounter;
  uint8_t *SystemDataPointer0;
  void* **pThreadLocalStorage;
  uint32_t *pSystemSecondaryStatus;
  void* *SystemDataConfigurationPointer;
  uint8_t *SystemThreadLocalStoragePointer;
  void* *ThreadLocalStorageEntry;
  uint SystemOperationStatusFlags;
  long long resourceDataIndex7;
  uint8_t SystemOperationStatus8;
  ulong long SystemContextPointer;
  uint8_t EncryptionKeyBuffer168 [32];
  uint8_t *pSystemThreadId148;
  void* *SystemMemoryContext;
  uint8_t *ResourceBufferPointer130;
  uint SystemMemoryOffset;
  ulong long SystemResourceFlags120;
  char SystemStatusByte;
  char SystemControlByte;
  uint8_t SystemByteFlag;
  uint StackUnsignedValue114;
  void* *pUnsignedStackFlag110;
  uint8_t *pEncryptionOffset1;
  uint EncryptionOffset2;
  void* MemoryBufferAddress;
  void* *SystemResourcePointerF0;
  long long SystemMemoryAllocationContext;
  uint32_t SystemMemoryAllocatorStatus;
  void* *dataBufferContext;
  void* *pointerUnsignedC8;
  uint32_t UnsignedStackFlagC0;
  ulong long systemDataBuffer;
  uint32_t UnsignedStackFlagB0;
  void* *SystemDataBufferPointerA8;
  void** SystemDataPointer;
  uint32_t SystemConfigurationValue;
  long long SystemConfigurationData;
  void* *SystemStatusFlagPointer;
  long long StackInteger78;
  uint32_t EncryptionValue68;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  void* ConcatenatedValue44;
  ulong long SystemEncryptionKey;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  SystemEncryptionKey = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionKeyBuffer168;
  SystemDataPointer0 = (uint8_t *)0x0;
  SystemStackFlag114 = 0;
  SystemStackFlag116 = 0;
  SystemParameterFlagB0 = AdditionalParameter;
  SystemConfigurationFlag88 = ConfigurationFlag;
  if ((SystemInitializationFlag != '\0') || (SystemVerboseFlag != '\0')) goto LAB_180072d7b;
  SystemProcessFlags58 = 0;
  ConcatenatedValue44 = 0;
  FormatSystemResourceString(&SystemProcessFlags58,0x10,&SystemDataBufferTemplateI,AdditionalParameter);
  resourceCounter = ProcessSystemQueue(&SystemResourcePointerF0,ConfigurationFlag);
  pUnsignedStackFlag110 = &SystemGlobalDataReference;
  SystemOperationStatusFlags = 0;
  MemoryBufferAddress = 0;
  pEncryptionOffset1 = (uint8_t *)0x0;
  EncryptionOffset2 = 0;
  SystemOperationMode = 4;
  ResourceHash = *(uint *)(resourceCounter + 0x10);
  SystemContextPointer = (ulong long)ResourceHash;
  resourceAddress = 0;
  if (*(long long *)(resourceCounter + 8) == 0) {
LAB_180072120:
    SystemOperationStatusFlags = resourceAddress;
    if (ResourceHash != 0) {
        memcpy(SystemDataPointer0,*(void* *)(resourceCounter + 8),SystemContextPointer);
    }
  }
  else if (ResourceHash != 0) {
    systemCounter = ResourceHash + 1;
    if (MemoryCompareResult < 0x10) {
      systemCounter = 0x10;
    }
    SystemDataPointer0 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemCounter,0x13);
    *SystemDataPointer0 = 0;
    pEncryptionOffset1 = SystemDataPointer0;
    resourceAddress = StartSystemThread(SystemDataPointer0);
    MemoryBufferAddress = ConcatenatedValue44(MemoryBufferAddress._4_4_,resourceAddress);
    goto LAB_180072120;
  }
  if (SystemDataPointer0 != (uint8_t *)0x0) {
    SystemDataPointer0[SystemContextPointer] = 0;
  }
  resourceAddress = *(uint *)(resourceCounter + 0x1c);
  EncryptionOffset2 = ResourceHash;
  MemoryBufferAddress._4_4_ = resourceAddress;
  if (ConfigurationDataPointer != 0) {
    resourceCounter = -1;
    do {
      resourceDataIndex7 = resourceCounter;
      resourceCounter = resourceDataIndex7 + 1;
    } while (*(char *)(ConfigurationDataPointer + resourceCounter) != '\0');
    if (0 < (int)resourceCounter) {
      systemCounter = ResourceHash + (int)resourceCounter;
      if (systemCounter != 0) {
        ResourceHash = systemCounter + 1;
        if (SystemDataPointer0 == (uint8_t *)0x0) {
          if ((int)ResourceHash < 0x10) {
            ResourceHash = 0x10;
          }
          SystemDataPointer0 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)ResourceHash,0x13);
          *SystemDataPointer0 = 0;
        }
        else {
          if (ResourceHash <= SystemOperationStatusFlags) goto LAB_1800721e1;
          pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
          SystemDataPointer0 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,SystemDataPointer0,ResourceHash,0x10);
        }
        pEncryptionOffset1 = SystemDataPointer0;
        MemoryBufferAddress._0_4_ = StartSystemThread(SystemDataPointer0);
      }
LAB_1800721e1:
        memcpy(SystemDataPointer0 + SystemContextPointer,ConfigurationDataPointer,(long long)((int)resourceDataIndex7 + 2));
    }
  }
  FinalizeSystemInitialization(&pUnsignedStackFlag110,&SystemDataBufferPointerA8,&SystemProcessFlags58);
  SystemOperationMode = 0;
  pUnsignedStackFlag110 = &SystemGlobalDataReference;
  if (SystemDataPointer0 != (uint8_t *)0x0) {
      SystemCleanupFunction(SystemDataPointer0);
  }
  SystemDataPointer0 = (uint8_t *)0x0;
  MemoryBufferAddress = (ulong long)MemoryBufferAddress._4_4_ << 0x20;
  SystemMemoryAllocatorReference = &SystemMemoryAllocatorReference;
  SystemGlobalDataReference = &SystemGlobalDataReference;
  if (SystemCleanupFlag != 0) {
      SystemCleanupFunction();
  }
  SystemCleanupFlag = 0;
  SystemDataIndex = 0;
  SystemGlobalDataReference = &SystemMemoryAllocatorReference;
  ThreadLocalStorageEntry = &SystemStringTemplate;
  if (stackParameterA != (void* *)0x0) {
    ThreadLocalStorageEntry = stackParameterA;
  }
  SystemOperationResult = GetConfigurationDataStatus(ThreadLocalStorageEntry);
  if (validationStatusFlag == '\0') {
    systemCounter = WaitForSingleObject(SystemSemaphoreHandle,0);
    if (systemCounter == 0) {
      SystemControlByte = '\x01';
      SystemOperationResult = (**(code **)**(void* **)(SystemMemoryBlockStorage + 0x18))();
      if ((SystemOperationResult == '\0') && (systemCounter = IsDebuggerPresent(), systemCounter != 0)) {
        validationStatusFlag = '\x01';
      }
      else {
        validationStatusFlag = '\0';
      }
      SystemStatusByte = SystemOperationResult;
      if (SystemAllocationFlagsTemplate == 0) {
LAB_1800722f5:
        resourceCounter = SystemRenderManagerPointer;
        if ((SystemRenderManagerPointer != 0) && (*(char *)(SystemRenderManagerPointer + 0x1609) != '\x01')) {
          ProcessSystemResourceAllocation(*(void* *)(SystemGlobalStatusFlags + 8),
                        *(char *)(SystemRuntimeCounter + 0x2028) != '\0',
                        *(uint32_t *)(SystemRenderManagerPointer + 0x160c));
          *(uint8_t *)(resourceCounter + 0x1609) = 1;
        }
        if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
          ValidateSystemResourceStatus();
        }
      }
      else {
        systemCounter = *(int *)(**(long long **)(SystemAllocationFlagsTemplate + 8) + 0x48);
        systemValue = _Thrd_id();
        SystemControlByte = systemValue == systemCounter;
        if ((bool)SystemControlByte) goto LAB_1800722f5;
      }
      if (validationStatusFlag != '\0') {
        if ((SystemMode == '\0') || (*(int *)(SystemGlobalStatusFlags + 0x340) == 2)) {
          systemFunctionPointer = (code *)swi(3);
          (*systemFunctionPointer)();
          return;
        }
        SystemByteFlag = 1;
      }
      pUnsignedStackFlag110 = &SystemGlobalDataReference;
      MemoryBufferAddress = 0;
      pEncryptionOffset1 = (void* *)0x0;
      EncryptionOffset2 = 0;
      if (validationStatusFlag == '\0') {
        resourceCounter = ProcessSystemMemoryAllocation(&SystemResourcePointerF0,0);
        EncryptionOffset2 = *(uint *)(resourceCounter + 0x10);
        pEncryptionOffset1 = *(uint8_t **)(resourceCounter + 8);
        MemoryBufferAddress = *(ulong long *)(resourceCounter + 0x18);
        *(uint32_t *)(resourceCounter + 0x10) = 0;
        *(void* *)(resourceCounter + 8) = 0;
        *(void* *)(resourceCounter + 0x18) = 0;
        SystemResourcePointerF0 = &SystemGlobalDataReference;
        if (SystemMemoryAllocationContext != 0) {
            SystemCleanupFunction();
        }
        SystemMemoryAllocationContext = 0;
        SystemMemoryAllocatorStatus = 0;
        SystemResourcePointerF0 = &SystemMemoryAllocatorReference;
      }
      SystemDataPointer0 = pEncryptionOffset1;
      SystemMemoryContext = &SystemGlobalDataReference;
      SystemResourceFlags120 = 0;
      ResourceBufferPointer130 = (uint8_t *)0x0;
      SystemMemoryOffset = 0;
      ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x15,0x13);
      *ResourceBufferPointer130 = 0;
      ResourceHash = StartSystemThread(ResourceBufferPointer130);
      SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ResourceHash);
      pSystemSecondaryStatus = (uint32_t *)(ResourceBufferPointer130 + SystemMemoryOffset);
      *pSystemSecondaryStatus = 0x69746f4e;
      pSystemSecondaryStatus[1] = 0x61636966;
      pSystemSecondaryStatus[2] = 0x6e6f6974;
      pSystemSecondaryStatus[3] = 0x73734120;
      pSystemSecondaryStatus[4] = 0x21747265;
      *(uint8_t *)(pSystemSecondaryStatus + 5) = 0;
      SystemMemoryOffset = 0x14;
      if (ResourceBufferPointer130 == (uint8_t *)0x0) {
        SystemMemoryOffset = 0x14;
        ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x16,0x13);
        *ResourceBufferPointer130 = 0;
LAB_180072521:
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
      else if (ResourceHash < 0x16) {
        pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
        SystemMemoryOffset = 0x14;
        ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,0x16,0x10);
        goto LAB_180072521;
      }
      *(void*2 *)(ResourceBufferPointer130 + SystemMemoryOffset) = 10;
      SystemMemoryOffset = 0x15;
      ResourceHash = 0x16;
      if (ResourceBufferPointer130 == (uint8_t *)0x0) {
        SystemMemoryOffset = 0x15;
        ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x17,0x13);
        *ResourceBufferPointer130 = 0;
LAB_1800725ac:
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
      else if ((uint)SystemResourceFlags120 < 0x17) {
        pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
        SystemMemoryOffset = 0x15;
        ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,0x17,0x10);
        goto LAB_1800725ac;
      }
      *(void*2 *)(ResourceBufferPointer130 + SystemMemoryOffset) = 10;
      SystemMemoryOffset = 0x16;
      if (ConfigurationDataPointer != 0) {
        resourceCounter = -1;
        do {
          resourceDataIndex7 = resourceCounter;
          resourceCounter = resourceDataIndex7 + 1;
        } while (*(char *)(ConfigurationDataPointer + resourceCounter) != '\0');
        systemCounter = (int)resourceCounter;
        if (0 < systemCounter) {
          resourceAddress = ResourceHash;
          if (systemCounter != -0x16) {
            SystemOperationStatusFlags = systemCounter + 0x17;
            if (ResourceBufferPointer130 == (uint8_t *)0x0) {
              if ((int)SystemOperationStatusFlags < 0x10) {
                SystemOperationStatusFlags = 0x10;
              }
              SystemMemoryOffset = ResourceHash;
              ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)SystemOperationStatusFlags,0x13);
              *ResourceBufferPointer130 = 0;
            }
            else {
              resourceAddress = SystemMemoryOffset;
              if (SystemOperationStatusFlags <= (uint)SystemResourceFlags120) goto LAB_180072662;
              pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
              SystemMemoryOffset = ResourceHash;
              ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,SystemOperationStatusFlags,0x10);
            }
            ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
            SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
            resourceAddress = SystemMemoryOffset;
          }
LAB_180072662:
          SystemMemoryOffset = resourceAddress;
            memcpy(ResourceBufferPointer130 + SystemMemoryOffset,ConfigurationDataPointer,(long long)((int)resourceDataIndex7 + 2));
        }
      }
      if (ResourceBufferPointer130 == (uint8_t *)0x0) {
        SystemMemoryOffset = ResourceHash;
        ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x18,0x13);
        *ResourceBufferPointer130 = 0;
LAB_1800726e7:
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
      else if ((uint)SystemResourceFlags120 < 0x18) {
        pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
        SystemMemoryOffset = ResourceHash;
        ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,0x18,0x10);
        goto LAB_1800726e7;
      }
      *(void*2 *)(ResourceBufferPointer130 + SystemMemoryOffset) = 0x3a;
      SystemMemoryOffset = 0x17;
      ProcessSystemData(&SystemMemoryContext,UnsignedStackFlagB0);
      ResourceHash = SystemMemoryOffset;
      resourceAddress = SystemMemoryOffset + 1;
      if (resourceAddress != 0) {
        SystemOperationStatusFlags = SystemMemoryOffset + 2;
        if (ResourceBufferPointer130 == (uint8_t *)0x0) {
          if ((int)SystemOperationStatusFlags < 0x10) {
            SystemOperationStatusFlags = 0x10;
          }
          ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)SystemOperationStatusFlags,0x13);
          *ResourceBufferPointer130 = 0;
        }
        else {
          if (SystemOperationStatusFlags <= (uint)SystemResourceFlags120) goto LAB_180072780;
          pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
          ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,SystemOperationStatusFlags,0x10);
        }
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
LAB_180072780:
      *(void*2 *)(ResourceBufferPointer130 + SystemMemoryOffset) = 10;
      SystemOperationStatusFlags = ResourceHash + 0xd;
      SystemMemoryOffset = resourceAddress;
      if (SystemOperationStatusFlags != 0) {
        resourceAddress = ResourceHash + 0xe;
        if (ResourceBufferPointer130 == (uint8_t *)0x0) {
          if ((int)resourceAddress < 0x10) {
            resourceAddress = 0x10;
          }
          ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)resourceAddress,0x13);
          *ResourceBufferPointer130 = 0;
        }
        else {
          if (resourceAddress <= (uint)SystemResourceFlags120) goto LAB_1800727ff;
          pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
          ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,resourceAddress,0x10);
        }
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
LAB_1800727ff:
      SystemDataConfigurationPointer = (void* *)(ResourceBufferPointer130 + SystemMemoryOffset);
      *SystemDataConfigurationPointer = 0x6973736572707845;
      *(uint32_t *)(SystemDataConfigurationPointer + 1) = 0x203a6e6f;
      *(uint8_t *)((long long)SystemDataConfigurationPointer + 0xc) = 0;
      resourceCounter = -1;
      SystemMemoryOffset = SystemOperationStatusFlags;
      if (ConfigurationFlag != 0) {
        do {
          resourceDataIndex7 = resourceCounter;
          resourceCounter = resourceDataIndex7 + 1;
        } while (*(char *)(resourceCounter + ConfigurationFlag) != '\0');
        if (0 < (int)resourceCounter) {
          systemCounter = SystemOperationStatusFlags + (int)resourceCounter;
          if (systemCounter != 0) {
            ResourceHash = systemCounter + 1;
            if (ResourceBufferPointer130 == (uint8_t *)0x0) {
              if ((int)ResourceHash < 0x10) {
                ResourceHash = 0x10;
              }
              ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)ResourceHash,0x13);
              *ResourceBufferPointer130 = 0;
            }
            else {
              if (ResourceHash <= (uint)SystemResourceFlags120) goto LAB_1800728ad;
              pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
              ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,ResourceHash,0x10);
            }
            ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
            SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
          }
LAB_1800728ad:
            memcpy(ResourceBufferPointer130 + SystemMemoryOffset,ConfigurationFlag,(long long)((int)resourceDataIndex7 + 2));
        }
      }
      resourceAddress = ResourceHash + 0xf;
      if (resourceAddress != 0) {
        OperationCode = ResourceHash + 0x10;
        if (ResourceBufferPointer130 == (uint8_t *)0x0) {
          if ((int)OperationCode < 0x10) {
            OperationCode = 0x10;
          }
          ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)OperationCode,0x13);
          *ResourceBufferPointer130 = 0;
        }
        else {
          if (OperationCode <= (uint)SystemResourceFlags120) goto LAB_180072934;
          pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
          ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,OperationCode,0x10);
        }
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
LAB_180072934:
      *(void*2 *)(ResourceBufferPointer130 + SystemMemoryOffset) = 0xa0a;
      *(uint8_t *)((long long)(ResourceBufferPointer130 + SystemMemoryOffset) + 2) = 0;
      SystemMemoryOffset = resourceAddress;
      if (ResourceHash + 0x6d != 0) {
        resourceAddress = ResourceHash + 0x6e;
        if (ResourceBufferPointer130 == (uint8_t *)0x0) {
          if ((int)resourceAddress < 0x10) {
            resourceAddress = 0x10;
          }
          ResourceBufferPointer130 = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)(int)resourceAddress,0x13);
          *ResourceBufferPointer130 = 0;
        }
        else {
          if (resourceAddress <= (uint)SystemResourceFlags120) goto LAB_1800729bd;
          pSystemThreadId148 = (uint8_t *)CONCAT71(pSystemThreadId148._1_7_,0x13);
          ResourceBufferPointer130 = (uint8_t *)AllocateThreadMemoryBuffer(SystemMemoryPoolTemplate,ResourceBufferPointer130,resourceAddress,0x10);
        }
        ThreadContextFlag = StartSystemThread(ResourceBufferPointer130);
        SystemResourceFlags120 = ConcatenatedValue44(SystemResourceFlags120._4_4_,ThreadContextFlag);
      }
LAB_1800729bd:
      SystemDataConfigurationPointer = (void* *)(ResourceBufferPointer130 + SystemMemoryOffset);
      *SystemDataConfigurationPointer = 0x232323232323233c;
      SystemDataConfigurationPointer[1] = 0x2323232323232323;
      SystemDataConfigurationPointer[2] = 0x2323232323232323;
      SystemDataConfigurationPointer[3] = 0x2323232323232323;
      SystemDataConfigurationPointer[4] = 0x2323232323232323;
      SystemDataConfigurationPointer[5] = 0x2323232323232323;
      SystemDataConfigurationPointer[6] = 0x2323232323232323;
      SystemDataConfigurationPointer[7] = 0x2323232323232323;
      *(uint32_t *)(SystemDataConfigurationPointer + 8) = 0x23232323;
      *(uint32_t *)((long long)SystemDataConfigurationPointer + 0x44) = 0x23232323;
      *(uint32_t *)(SystemDataConfigurationPointer + 9) = 0x23232323;
      *(uint32_t *)((long long)SystemDataConfigurationPointer + 0x4c) = 0x23232323;
      SystemDataConfigurationPointer[10] = 0x2323232323232323;
      *(uint32_t *)(SystemDataConfigurationPointer + 0xb) = 0x3e232323;
      *(void*2 *)((long long)SystemDataConfigurationPointer + 0x5c) = 0xa0a;
      *(uint8_t *)((long long)SystemDataConfigurationPointer + 0x5e) = 0;
      pSystemThreadId148 = &SystemStringTemplate;
      if (ResourceBufferPointer130 != (uint8_t *)0x0) {
        pSystemThreadId148 = ResourceBufferPointer130;
      }
      SystemMemoryOffset = ResourceHash + 0x6d;
      ConfigureSystemManager(SystemContextManagerPointer,4,0xffffffff00000000,&SystemConfigurationDataBufferB);
      pSystemThreadId148 = &SystemStringTemplate;
      if (SystemDataPointer0 != (void* *)0x0) {
        pSystemThreadId148 = SystemDataPointer0;
      }
      SystemManagerSetFlags(SystemContextManagerPointer,4,0xffffffff00000000,3);
      InitializeSystemManager();
      SystemThreadLocalStoragePointer = &SystemStringTemplate;
      if (ResourceBufferPointer130 != (uint8_t *)0x0) {
        SystemThreadLocalStoragePointer = ResourceBufferPointer130;
      }
      OutputDebugStringA(SystemThreadLocalStoragePointer);
      ProcessResourceDataIndex(ConfigurationFlag);
      ThreadLocalStorageEntry = &SystemStringTemplate;
      if (stackParameterA != (void* *)0x0) {
        ThreadLocalStorageEntry = stackParameterA;
      }
      systemCounter = GetSystemContextFlag(ThreadLocalStorageEntry);
      if ((SystemStatusByte == '\0') && (systemCounter == 0)) {
        if ((SystemGlobalStatusFlags == 0) || (*(char *)(SystemGlobalStatusFlags + 0x141) == '\0')) {
          SystemOperationStatus8 = 0;
        }
        else {
          SystemOperationStatus8 = 1;
        }
        if (SystemGlobalStatusFlags == 0) {
          dataBufferContext = &SystemGlobalDataReference;
          systemDataBuffer = 0;
          pointerUnsignedC8 = (void* *)0x0;
          UnsignedStackFlagC0 = 0;
          SystemDataConfigurationPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x34,0x13);
          *(uint8_t *)SystemDataConfigurationPointer = 0;
          pointerUnsignedC8 = SystemDataConfigurationPointer;
          ThreadContextFlag = StartSystemThread(SystemDataConfigurationPointer);
          systemDataBuffer = ConcatenatedValue44(systemDataBuffer._4_4_,ThreadContextFlag);
          *SystemDataConfigurationPointer = 0x7270706d75645c5c;
          SystemDataConfigurationPointer[1] = 0x2e726f737365636f;
          SystemDataConfigurationPointer[2] = 0x6c726f77656c6174;
          SystemDataConfigurationPointer[3] = 0x445c6d6f632e7364;
          *(uint32_t *)(SystemDataConfigurationPointer + 4) = 0x50706d75;
          *(uint32_t *)((long long)SystemDataConfigurationPointer + 0x24) = 0x65636f72;
          *(uint32_t *)(SystemDataConfigurationPointer + 5) = 0x6e697373;
          *(uint32_t *)((long long)SystemDataConfigurationPointer + 0x2c) = 0x6c6f4667;
          *(uint32_t *)(SystemDataConfigurationPointer + 6) = 0x726564;
          UnsignedStackFlagC0 = 0x33;
          pThreadLocalStorage = &dataBufferContext;
          ResourceHash = 2;
          SystemOperationMode = 2;
        }
        else {
          pThreadLocalStorage = (void* **)CreateSystemObject(&SystemStatusFlagPointer,SystemGlobalStatusFlags + 0x148);
          ResourceHash = 1;
          SystemOperationMode = 1;
          SystemDataConfigurationPointer = pointerUnsignedC8;
        }
        ThreadContextFlag = CreateSystemObject(&SystemResourcePointerF0,pThreadLocalStorage);
        if ((ResourceHash & 2) != 0) {
          ResourceHash = ResourceHash & 0xfffffffd;
          dataBufferContext = &SystemGlobalDataReference;
          SystemOperationMode = ResourceHash;
          if (SystemDataConfigurationPointer != (void* *)0x0) {
              SystemCleanupFunction(SystemDataConfigurationPointer);
          }
          pointerUnsignedC8 = (void* *)0x0;
          systemDataBuffer = systemDataBuffer & MAX_UNSIGNED_32_BIT00000000;
          dataBufferContext = &SystemMemoryAllocatorReference;
        }
        if ((ResourceHash & 1) != 0) {
          SystemOperationMode = ResourceHash & 0xfffffffe;
          SystemStatusFlagPointer = &SystemGlobalDataReference;
          if (StackInteger78 != 0) {
              SystemCleanupFunction();
          }
          StackInteger78 = 0;
          EncryptionValue68 = 0;
          SystemStatusFlagPointer = &SystemMemoryAllocatorReference;
        }
        pSystemThreadId148 = &SystemStringTemplate;
        if (SystemDataPointer0 != (void* *)0x0) {
          pSystemThreadId148 = SystemDataPointer0;
        }
        ValidateSystemConfiguration(ThreadContextFlag,&SystemResourcePointerF0,SystemOperationStatus8,systemConfigurationParameter);
        SystemResourcePointerF0 = &SystemGlobalDataReference;
        if (SystemMemoryAllocationContext != 0) {
            SystemCleanupFunction();
        }
        SystemMemoryAllocationContext = 0;
        SystemMemoryAllocatorStatus = 0;
        SystemResourcePointerF0 = &SystemMemoryAllocatorReference;
      }
      ThreadLocalStorageEntry = &SystemStringTemplate;
      if (stackParameterA != (void* *)0x0) {
        ThreadLocalStorageEntry = stackParameterA;
      }
      UpdateThreadLocalStorageEntry(ThreadLocalStorageEntry,1);
      if (SystemControlByte != '\0') {
        if (*(long long *)(SystemGlobalStatusFlags + 8) != 0) {
          CleanupSystemResources();
        }
        if (SystemRenderManagerPointer != 0) {
          ProcessRenderManagerData(SystemRenderManagerPointer,*(uint8_t *)(SystemRenderManagerPointer + 0x160a));
        }
      }

/**
 * @brief 处理系统资源初始化配置
 * 
 * 该函数负责处理系统资源的初始化配置，包括资源创建和参数设置
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_180072e80：ProcessSystemResourceInitializationConfiguration
 */
void ProcessSystemResourceInitializationConfiguration(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  void* resourceCreationFlags;
  void* *pointerUnsigned30;
  long long LocalMemoryAddress;
  
  PrimaryResourcePointer = *(long long **)(SystemGlobalStatusFlags + 0x2b0);
  if (PrimaryResourcePointer != (long long *)0x0) {
    resourceCreationFlags = (**(code **)(*PrimaryResourcePointer + 0x110))(PrimaryResourcePointer,&pointerUnsigned30,AdditionalParameter,ConfigurationFlag,InvalidHandleValue);
    ConfigureSystemResourceParameters(ConfigurationDataPointer,resourceCreationFlags);
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (LocalMemoryAddress != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}




/**
 * @brief 系统线程初始化和资源管理器
 * 
 * 该函数负责初始化系统线程和资源管理器，包括：
 * - 创建和配置系统线程对象
 * - 管理线程本地存储和资源分配
 * - 处理系统配置数据和缓冲区
 * - 协调多个系统组件的初始化过程
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针的指针
 * @return 初始化成功返回true，失败返回false
 * 
 * 原始函数名：FUN_180072f00
 */
bool InitializeSystemThreadAndResourceManager(void* SystemResourceManager,void* *ConfigurationDataPointer)

{
  uint32_t SystemOperationStatus;
  int systemResult;
  int NodeIdentifierComparisonResult;
  long long SystemBufferAddress;
  void* SystemThreadContext;
  void** SystemRootNode;
  void* **phashTableNode;
  uint8_t *SystemThreadStorage;
  void* ThreadContextFlag;
  void*2 *SystemDataPointer0;
  uint SystemOperationStatus1;
  void* *pSystemSecondaryStatus;
  void* *SystemDataConfigurationPointer;
  void* *SystemThreadLocalStoragePointer;
  char CharacterBuffer;
  uint SystemOperationStatus5;
  void* *pUnsignedStackFlag110;
  void* *systemHashPointer;
  int LocalIndexCounter;
  void* MemoryBufferAddress;
  void* *SystemResourcePointerF0;
  void*2 *pointerUnsignedE8;
  uint32_t SystemMemoryStatusFlag;
  void* SystemMemoryAllocatorStatus;
  void* *dataBufferContext;
  void* *pointerUnsignedC8;
  uint32_t UnsignedStackFlagC0;
  ulong long systemDataBuffer;
  void* *alternateBufferPtrB0;
  void* *SystemDataBufferPointerA8;
  uint32_t UnsignedStackFlagA0;
  ulong long secondarySystemDataBuffer;
  void* *pStackParameterC;
  uint8_t *pUnsignedStackFlag88;
  uint32_t UnsignedStackFlag80;
  ulong long SystemUnsignedFlag78;
  void* *SystemProcessFlagsPointer;
  void* *pEncryptionValue68;
  void* *systemContextPointer;
  long long SystemStatusFlag48;
  void* SystemOperationCounter;
  
  SystemOperationCounter = 0xfffffffffffffffe;
  SystemThreadContext = (void* *)0x0;
  systemCounter = 0;
  WaitForSingleObject(SystemSemaphoreHandle,300000);
  SystemStatusFlag48 = SystemAllocationFlagsTemplate;
  if (SystemAllocationFlagsTemplate != 0) {
    ProcessSystemResourceOffset(SystemAllocationFlagsTemplate);
  }
  SystemResourcePointerF0 = &SystemGlobalDataReference;
  SystemMemoryAllocatorStatus = 0;
  SystemThreadHandle = (void*2 *)0x0;
  SystemThreadState = 0;
  SystemThreadHandle = (void*2 *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x10,0x13);
  *(uint8_t *)SystemThreadHandle = 0;
  SystemOperationStatus = StartSystemThread(SystemThreadHandle);
  SystemMemoryAllocatorStatus = ConcatenatedValue44(SystemMemoryAllocatorStatus._4_4_,SystemOperationStatus);
  *SystemThreadHandle = 0xa0a;
  *(uint8_t *)(SystemThreadHandle + 1) = 0;
  SystemThreadState = 2;
  dataBufferContext = &SystemGlobalDataReference;
  systemDataBuffer = 0;
  pointerUnsignedC8 = (void* *)0x0;
  UnsignedStackFlagC0 = 0;
  InitializeTextureManager(SystemTextureManagerPointer,&pEncryptionValue68);
  if (pEncryptionValue68 != pSystemThreadContext) {
    ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemDataBufferTemplateA,&SystemResourceDataBufferA);
    resourceEntryPointer = SystemThreadContext;
    pSystemSecondaryStatus = SystemThreadContext;
    if ((long long)pSystemThreadContext - (long long)pEncryptionValue68 >> 5 != 0) {
      do {
        SystemDataConfigurationPointer = &SystemStringTemplate;
        if (*(void* **)((long long)(resourceEntryPointer + 1) + (long long)pEncryptionValue68) != (void* *)0x0) {
          SystemDataConfigurationPointer = *(void* **)((long long)(resourceEntryPointer + 1) + (long long)pEncryptionValue68);
        }
        ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemDataBufferTemplateA,SystemDataConfigurationPointer);
        SystemOperationStatus1 = (int)pSystemSecondaryStatus + 1;
        resourceEntryPointer = SystemCurrentNode + 4;
        pSystemSecondaryStatus = (void* *)(ulong long)SystemOperationStatus1;
      } while ((ulong long)(long long)(int)SystemOperationStatus1 <
               (ulong long)((long long)pSystemThreadContext - (long long)pEncryptionValue68 >> 5));
    }
    ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemConfigurationDataBufferF,&SystemConfigurationDataBufferG);
    ConfigureSystemResourceManager(&pUnsignedStackFlag110);
    if (LocalIndexCounter != 0) {
      ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemDataBufferTemplateA,&SystemConfigurationDataBufferH);
      resourceEntryPointer = (void* *)&SystemStringTemplate;
      if (pEncryptionOffset1 != (void* *)0x0) {
        resourceEntryPointer = pEncryptionOffset1;
      }
      ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemConfigurationDataBufferI,resourceEntryPointer);
      ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemConfigurationDataBufferF,&SystemConfigurationDataBufferG);
    }
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    if (pEncryptionOffset1 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pEncryptionOffset1 = (void* *)0x0;
    MemoryBufferAddress = (ulong long)MemoryBufferAddress._4_4_ << 0x20;
    pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
  }
  SystemBufferAddress = ProcessSystemMemoryAllocation(&pUnsignedStackFlag110,ConfigurationDataPointer[1]);
  UnsignedStackFlagC0 = *(uint32_t *)(SystemBufferAddress + 0x10);
  SystemDataConfigurationPointer = *(void* **)(SystemBufferAddress + 8);
  systemDataBuffer = *(ulong long *)(SystemBufferAddress + 0x18);
  *(uint32_t *)(SystemBufferAddress + 0x10) = 0;
  *(void* *)(SystemBufferAddress + 8) = 0;
  *(void* *)(SystemBufferAddress + 0x18) = 0;
  pUnsignedStackFlag110 = &SystemGlobalDataReference;
  pointerUnsignedC8 = SystemDataConfigurationPointer;
  SystemProcessFlagsPointer = SystemDataConfigurationPointer;
  if (pEncryptionOffset1 != (void* *)0x0) {
      SystemCleanupFunction();
  }
  pEncryptionOffset1 = (void* *)0x0;
  MemoryBufferAddress = MemoryBufferAddress & MAX_UNSIGNED_32_BIT00000000;
  pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
  ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemConfigurationDataBufferJ,*(uint32_t *)*ConfigurationDataPointer,
                *(void* *)((uint32_t *)*ConfigurationDataPointer + 4));
  ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemDataBufferTemplateA,&SystemConfigurationDataBufferK);
  SystemThreadLocalStoragePointer = &SystemStringTemplate;
  if (SystemDataConfigurationPointer != (void* *)0x0) {
    SystemThreadLocalStoragePointer = SystemDataConfigurationPointer;
  }
  ConfigureSystemDataBuffer(&SystemResourcePointerF0,&SystemDataBufferTemplateA,SystemThreadLocalStoragePointer);
  SystemDataPointer0 = (void*2 *)&SystemStringTemplate;
  if (pointerUnsignedE8 != (void*2 *)0x0) {
    SystemDataPointer0 = pointerUnsignedE8;
  }
  SystemManagerSetFlags(SystemContextManagerPointer,5,0xffffffff00000000,3,&SystemDataBufferTemplateA,SystemDataPointer0);
  InitializeSystemManager();
  SystemBufferAddress = SystemGlobalStatusFlags;
  if (SystemGlobalStatusFlags == 0) {
    CharacterBuffer = '\0';
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    MemoryBufferAddress = 0;
    pEncryptionOffset1 = (void* *)0x0;
    LocalIndexCounter = 0;
    resourceEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,0x34,0x13);
    *(uint8_t *)resourceEntryPointer = 0;
    pEncryptionOffset1 = resourceEntryPointer;
    SystemOperationStatus = StartSystemThread(resourceEntryPointer);
    MemoryBufferAddress = ConcatenatedValue44(MemoryBufferAddress._4_4_,SystemOperationStatus);
    *resourceEntryPointer = 0x7270706d75645c5c;
    resourceEntryPointer[1] = 0x2e726f737365636f;
    resourceEntryPointer[2] = 0x6c726f77656c6174;
    resourceEntryPointer[3] = 0x445c6d6f632e7364;
    *(uint32_t *)(SystemCurrentNode + 4) = 0x50706d75;
    *(uint32_t *)((long long)resourceEntryPointer + 0x24) = 0x65636f72;
    *(uint32_t *)(resourceEntryPointer + 5) = 0x6e697373;
    *(uint32_t *)((long long)resourceEntryPointer + 0x2c) = 0x6c6f4667;
    *(uint32_t *)(resourceEntryPointer + 6) = 0x726564;
    systemCounter = 0x33;
    LocalIndexCounter = 0x33;
    SystemOperationStatus1 = 2;
    SystemOperationStatus5 = 2;
    phashTableNode = &pEncryptionOffset1;
    SystemThreadContext = pUnsignedStackFlagA8;
  }
  else {
    CharacterBuffer = *(char *)(SystemGlobalStatusFlags + 0x141);
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    systemConfigurationValue = 0;
    pUnsignedStackFlagA8 = (void* *)0x0;
    UnsignedStackFlagA0 = 0;
    if (*(int *)(SystemGlobalStatusFlags + 0x158) != 0) {
      systemResult = *(int *)(SystemGlobalStatusFlags + 0x158) + 1;
      if (systemResult < 0x10) {
        systemResult = 0x10;
      }
      SystemThreadContext = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)systemResult,0x13);
      *(uint8_t *)SystemThreadContext = 0;
      pUnsignedStackFlagA8 = SystemThreadContext;
      SystemOperationStatus = StartSystemThread(SystemThreadContext);
      secondarySystemDataBuffer = ConcatenatedValue44(secondarySystemDataBuffer._4_4_,SystemOperationStatus);
      if (*(int *)(SystemBufferAddress + 0x158) != 0) {
          memcpy(SystemThreadContext,*(void* *)(SystemBufferAddress + 0x150),*(int *)(SystemBufferAddress + 0x158) + 1);
      }
    }
    if (*(long long *)(SystemBufferAddress + 0x150) != 0) {
      UnsignedStackFlagA0 = 0;
      if (SystemThreadContext != (void* *)0x0) {
        *(uint8_t *)SystemThreadContext = 0;
      }
      secondarySystemDataBuffer = secondarySystemDataBuffer & MAX_UNSIGNED_32_BIT;
    }
    SystemOperationStatus1 = 1;
    SystemOperationStatus5 = 1;
    phashTableNode = &SystemDataBufferPointerA8;
    resourceEntryPointer = pEncryptionOffset1;
  }
  pSystemConfigurationValue = &SystemGlobalDataReference;
  SystemUnsignedFlag78 = 0;
  pUnsignedStackFlag88 = (uint8_t *)0x0;
  UnsignedStackFlag80 = 0;
  if (systemCounter != 0) {
    SystemOperationStatus5 = systemCounter + 1;
    SystemOperationStatus1 = SystemOperationStatus5;
    if (SystemOperationStatus5 < 0x10) {
      SystemOperationStatus1 = 0x10;
    }
    SystemThreadStorage = (uint8_t *)CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemOperationStatus1,0x13);
    *SystemThreadStorage = 0;
    pUnsignedStackFlag88 = SystemThreadStorage;
    SystemOperationStatus = StartSystemThread(SystemThreadStorage);
    SystemUnsignedFlag78 = ConcatenatedValue44(SystemUnsignedFlag78.HighPart,SystemOperationStatus);
      memcpy(SystemThreadStorage,*phashTableNode,SystemOperationStatus5);
  }
  SystemUnsignedFlag78 = 0;
  UnsignedStackFlag80 = 0;
  if ((SystemOperationStatus1 & 2) != 0) {
    SystemOperationStatus5 = SystemOperationStatus1 & 0xfffffffd;
    pUnsignedStackFlag110 = &SystemGlobalDataReference;
    if (resourceEntryPointer != (void* *)0x0) {
        SystemCleanupFunction(resourceEntryPointer);
    }
    pEncryptionOffset1 = (void* *)0x0;
    MemoryBufferAddress = MemoryBufferAddress & MAX_UNSIGNED_32_BIT00000000;
    pUnsignedStackFlag110 = &SystemMemoryAllocatorReference;
    SystemOperationStatus1 = SystemOperationStatus5;
  }
  if ((SystemOperationStatus1 & 1) != 0) {
    SystemOperationStatus5 = SystemOperationStatus1 & 0xfffffffe;
    alternateBufferPtrB0 = &SystemGlobalDataReference;
    if (SystemThreadContext != (void* *)0x0) {
        SystemCleanupFunction(SystemThreadContext);
    }
    pUnsignedStackFlagA8 = (void* *)0x0;
    secondarySystemDataBuffer = secondarySystemDataBuffer & MAX_UNSIGNED_32_BIT00000000;
    alternateBufferPtrB0 = &SystemMemoryAllocatorReference;
  }
  SystemThreadLocalStoragePointer = &SystemStringTemplate;
  if (SystemDataConfigurationPointer != (void* *)0x0) {
    SystemThreadLocalStoragePointer = SystemDataConfigurationPointer;
  }
  ProcessSystemConfiguration(0,&pStackParameterC,CharacterBuffer,1,SystemThreadLocalStoragePointer,SystemDataPointer0,SystemOperationStatus5);
  if (SystemStatusFlag48 != 0) {
    ResumeSystemThreads();
  }
  do {
    systemCounter = ReleaseSemaphore(SystemSemaphoreHandle,1);
  } while (systemCounter == 0);
  ThreadContextFlag = __acrt_iob_func(1);
  fflush(ThreadContextFlag);
  ThreadContextFlag = __acrt_iob_func(2);
  fflush(ThreadContextFlag);
  pSystemConfigurationValue = &SystemGlobalDataReference;
  if (pUnsignedStackFlag88 == (uint8_t *)0x0) {
    pUnsignedStackFlag88 = (uint8_t *)0x0;
    SystemUnsignedFlag78 = SystemUnsignedFlag78 & MAX_UNSIGNED_32_BIT00000000;
    pSystemConfigurationValue = &SystemMemoryAllocatorReference;
    for (SystemThreadContext = pEncryptionValue68; SystemThreadContext != pSystemThreadContext; SystemThreadContext = SystemThreadContext + 4) {
      (**(code **)*SystemThreadContext)(SystemThreadContext,0);
    }
    if (pEncryptionValue68 != (void* *)0x0) {
        SystemCleanupFunction();
    }
    dataBufferContext = &SystemGlobalDataReference;
    if (SystemProcessFlagsPointer != (void* *)0x0) {
        SystemCleanupFunction();
    }
    pointerUnsignedC8 = (void* *)0x0;
    systemDataBuffer = systemDataBuffer & MAX_UNSIGNED_32_BIT00000000;
    dataBufferContext = &SystemMemoryAllocatorReference;
    SystemResourcePointerF0 = &SystemGlobalDataReference;
    if (pointerUnsignedE8 == (void*2 *)0x0) {
      return CharacterBuffer != '\0';
    }
      SystemCleanupFunction();
  }
    SystemCleanupFunction();
}





/**
 * @brief 初始化系统资源管理器配置
 * 
 * 该函数负责初始化系统资源管理器的配置，设置管理器参数和标志
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_180073630：InitializeSystemResourceManagerConfiguration
 */
void InitializeSystemResourceManagerConfiguration(void* SystemResourceManager,void* ConfigurationDataPointer)

{
  void** SystemDataPointer;
  char validationStatusFlag;
  uint32_t aSystemParameterPointer [4];
  void* *pointerUnsigned30;
  long long LocalMemoryAddress;
  
  SystemManagerSetFlags(SystemContextManagerPointer,0,0x100000000,0,&SystemResourceManagerDataBufferA,ConfigurationDataPointer,InvalidHandleValue);
  if (SystemInitializationFlag == '\0') {
    aSystemParameterPointer[0] = 0xffff0000;
    ProcessSystemQueue(&pointerUnsigned30,ConfigurationDataPointer);
    SystemDataPointer = *(void* **)*SystemMemoryBlockStorage;
    if (SystemDataPointer == &SystemMemoryBlockTemplatePrimary) {
      SystemOperationResult = *(int *)(SystemStatusFlags + 0xc40) != 0;
    }
    else {
      SystemOperationResult = (**(code **)(SystemDataPointer + 0x50))((void* *)*SystemMemoryBlockStorage);
    }
    if (validationStatusFlag == '\0') {
      (**(code **)(*(long long *)SystemMemoryBlockStorage[1] + 0x18))
                ((long long *)SystemMemoryBlockStorage[1],&pointerUnsigned30,aSystemParameterPointer);
    }
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (LocalMemoryAddress != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}





/**
 * @brief 配置系统资源管理器数据
 * 
 * 该函数负责配置系统资源管理器的数据，设置管理器参数和数据缓冲区
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_180073730：ConfigureSystemResourceManagerData
 */
void ConfigureSystemResourceManagerData(void* SystemResourceManager,void* ConfigurationDataPointer)

{
  void** SystemDataPointer;
  char validationStatusFlag;
  uint32_t aSystemParameterPointer [4];
  void* *pointerUnsigned30;
  long long LocalMemoryAddress;
  
  SystemManagerSetFlags(SystemContextManagerPointer,0,0x100000000,1,&SystemResourceManagerDataBufferB,ConfigurationDataPointer,InvalidHandleValue);
  if (SystemInitializationFlag == '\0') {
    aSystemParameterPointer[0] = 0xff00ff00;
    ProcessSystemQueue(&pointerUnsigned30,ConfigurationDataPointer);
    SystemDataPointer = *(void* **)*SystemMemoryBlockStorage;
    if (SystemDataPointer == &SystemMemoryBlockTemplatePrimary) {
      SystemOperationResult = *(int *)(SystemStatusFlags + 0xc40) != 0;
    }
    else {
      SystemOperationResult = (**(code **)(SystemDataPointer + 0x50))((void* *)*SystemMemoryBlockStorage);
    }
    if (validationStatusFlag == '\0') {
      (**(code **)(*(long long *)SystemMemoryBlockStorage[1] + 0x18))
                ((long long *)SystemMemoryBlockStorage[1],&pointerUnsigned30,aSystemParameterPointer);
    }
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (LocalMemoryAddress != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}





/**
 * @brief 系统管理器参数设置函数
 * 
 * 该函数负责设置系统管理器的各种参数和配置。
 * 函数会根据系统初始化状态执行相应的管理器参数设置操作。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * 
 *FUN_180073830：SetSystemManagerParameters
 */
void SetSystemManagerParameters(void* SystemResourceManager,uint32_t ConfigurationDataPointer,void* AdditionalParameter)

{
  void** SystemDataPointer;
  char validationStatusFlag;
  uint32_t aSystemConfigurationPointer [2];
  void* *pointerUnsigned30;
  long long LocalMemoryAddress;
  
  SystemManagerSetFlags(SystemContextManagerPointer,0,0x100000000,0xc,&SystemResourceManagerDataBufferC,AdditionalParameter,InvalidHandleValue);
  if (SystemInitializationFlag == '\0') {
    aSystemConfigurationPointer[0] = ConfigurationDataPointer;
    ProcessSystemQueue(&pointerUnsigned30,AdditionalParameter);
    SystemDataPointer = *(void* **)*SystemMemoryBlockStorage;
    if (SystemDataPointer == &SystemMemoryBlockTemplatePrimary) {
      SystemOperationResult = *(int *)(SystemStatusFlags + 0xc40) != 0;
    }
    else {
      SystemOperationResult = (**(code **)(SystemDataPointer + 0x50))((void* *)*SystemMemoryBlockStorage);
    }
    if (validationStatusFlag == '\0') {
      (**(code **)(*(long long *)SystemMemoryBlockStorage[1] + 0x18))
                ((long long *)SystemMemoryBlockStorage[1],&pointerUnsigned30,aSystemConfigurationPointer);
    }
    pointerUnsigned30 = &SystemGlobalDataReference;
    if (LocalMemoryAddress != 0) {
        SystemCleanupFunction();
    }
  }
  return;
}




// 函数: void ProcessSystemResourceManagerConfiguration(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统回调函数管理器
 * 
 * 该函数负责管理系统回调函数的初始化和设置，处理系统全局数据引用。
 * 它会调用其他相关函数来完成回调函数的配置和清理工作。
 * 
 * @param SystemResourceManager 回调函数参数1
 * @param ConfigurationDataPointer 回调函数参数2  
 * @param AdditionalParameter 回调函数参数3
 * @param ConfigurationFlag 回调函数参数4
 */
void SystemCallbackManager(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* *pUnsignedStackFlag88;
  void* UnsignedStackFlag80;
  uint32_t SystemUnsignedFlag78;
  void* SystemProcessFlags70;
  void* EncryptionValue68;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  uint32_t ConcatenatedValue44;
  void* SystemEncryptionKey;
  void* SystemOperationCounter;
  void*2 SystemContextValue;
  void* StackPointer36;
  void* StackPointer2E;
  void*2 SystemPointerValue;
  void* ConcatenatedValue44;
  
  ConcatenatedValue44 = 0xfffffffffffffffe;
  pUnsignedStackFlag88 = &SystemGlobalDataReference;
  SystemProcessFlags70 = 0;
  UnsignedStackFlag80 = 0;
  SystemUnsignedFlag78 = 0;
  EncryptionValue68 = 0;
  SystemThreadContext = 0;
  SystemProcessFlags58 = 0;
  ThreadContextFlag = 3;
  SystemContextValue = 0;
  SystemEncryptionKey = 0;
  SystemOperationCounter = 0;
  SystemPointerValue = 0;
  SystemControlValue = 0;
  uStack_2e = 0;
  ProcessSystemResourceAllocation(&pUnsignedStackFlag88,SystemResourceManager,AdditionalParameter,ConfigurationFlag,&EncryptionValue68);
  CleanupSystemResourceData(&pUnsignedStackFlag88,AdditionalParameter);
  ResetResourceManager(&pUnsignedStackFlag88);
  return;
}




/**
 * @brief 资源管理器重置函数
 * 
 * 该函数负责重置资源管理器的各种状态和指针。
 * 函数会清理资源管理器的各个字段，并重置为初始状态。
 * 
 * @param SystemResourceManager 资源管理器指针
 * 
 *FUN_1800739f0：ResetResourceManager
 */
void ResetResourceManager(void* *SystemResourceManager)

{
  if (*(long long *)((long long)SystemResourceManager + 0x52) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)((long long)SystemResourceManager + 0x52) = 0;
  if (*(long long *)((long long)SystemResourceManager + 0x5a) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)((long long)SystemResourceManager + 0x5a) = 0;
  if (SystemResourceManager[8] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[8] = 0;
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[9] = 0;
  ProcessSystemResourcePool();
  *SystemResourceManager = &SystemGlobalDataReference;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  *(uint32_t *)(SystemResourceManager + 3) = 0;
  *SystemResourceManager = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 系统资源清理处理器
 * 
 * 该函数负责清理系统资源，包括内存释放、资源重置和状态清理。
 * 主要用于系统关闭或重启时的资源回收工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要清理的资源结构
 * 
 * @note 该函数在清理过程中会调用SystemCleanupFunction进行最终清理
 * @note 函数使用循环遍历所有相关资源并进行清理
 * @note 如果清理过程中发现错误，会触发系统清理函数
 */
void SystemResourceCleanupHandler(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)SystemResourceManager[1];
  resourcePoolPointer = (long long *)*SystemResourceManager;
  while( true ) {
    if (resourcePoolPointer == PrimaryResourcePointer) {
      if (*SystemResourceManager != 0) {
          SystemCleanupFunction();
      }
      return;
    }
    if (*(long long *)((long long)resourcePoolPointer + 0x12) != 0) {
        SystemCleanupFunction();
    }
    *(void* *)((long long)resourcePoolPointer + 0x12) = 0;
    if (*(long long *)((long long)resourcePoolPointer + 0x1a) != 0) break;
    *(void* *)((long long)resourcePoolPointer + 0x1a) = 0;
    if (*resourcePoolPointer != 0) {
        SystemCleanupFunction();
    }
    *resourcePoolPointer = 0;
    if (resourcePoolPointer[1] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[1] = 0;
    resourcePoolPointer = (long long *)((long long)resourcePoolPointer + 0x24);
  }
    SystemCleanupFunction();
}




/**
 * @brief 处理系统数据块
 * 
 * 该函数处理系统数据块，包括数据块的读取、解析和存储操作。
 * 主要用于系统初始化过程中的数据处理。
 * 
 * @param DataBlockHandle 数据块句柄，用于标识要处理的数据块
 * @param DataBufferPointer 数据缓冲区指针，用于存储处理后的数据
 * 
 * @note 该函数是系统初始化过程中的重要组成部分，负责数据块的格式化处理
 */
void ProcessSystemDataBlock(long long DataBlockHandle, long long *DataBufferPointer)

{
  ushort DataElementSize;
  void* DataPointer;
  int *IntegerBufferPointer;
  uint32_t *UInt32BufferPointer;
  uint *UIntBufferPointer;
  long long DataBlockSize;
  long long DataElementOffset;
  int ElementCount;
  ulong long DataSize;
  long long ElementIndex;
  
  InitializeDataBuffer(DataBufferPointer, DataBlockHandle);
  DataBlockSize = *(long long *)(DataBlockHandle + 0x28) - *(long long *)(DataBlockHandle + 0x20);
  IntegerBufferPointer = (int *)DataBufferPointer[1];
  DataBlockSize = DataBlockSize / 0x12 + (DataBlockSize >> 0x3f);
  ElementCount = (int)(DataBlockSize >> 1) - (int)(DataBlockSize >> 0x3f);
  if ((ulong long)((*DataBufferPointer - (long long)IntegerBufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)IntegerBufferPointer + (4 - *DataBufferPointer));
    IntegerBufferPointer = (int *)DataBufferPointer[1];
  }
  *IntegerBufferPointer = ElementCount;
  UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
  DataBufferPointer[1] = (long long)UInt32BufferPointer;
  DataBlockSize = (long long)ElementCount;
  if (0 < ElementCount) {
    ElementIndex = 0;
    do {
      DataElementOffset = *(long long *)(DataBlockHandle + 0x20) + ElementIndex;
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0x10;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UIntBufferPointer = (uint *)DataBufferPointer[1];
      DataElementSize = *(ushort *)(DataElementOffset + 0x10);
      if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
        UIntBufferPointer = (uint *)DataBufferPointer[1];
      }
      *UIntBufferPointer = (uint)DataElementSize;
      UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
      DataBufferPointer[1] = (long long)UInt32BufferPointer;
      if (*(ushort *)(DataElementOffset + 0x10) != 0) {
        DataPointer = *(void* *)(DataElementOffset + 8);
        DataSize = (ulong long)*(ushort *)(DataElementOffset + 0x10) * 4;
        if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) <= DataSize) {
          ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (DataSize - *DataBufferPointer));
          UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
        }
              memcpy(UInt32BufferPointer, DataPointer, DataSize);
      }
      DataElementOffset = *(long long *)(DataBlockHandle + 0x20) + ElementIndex;
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
        UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
      }
      *UInt32BufferPointer = 0x10;
      DataBufferPointer[1] = DataBufferPointer[1] + 4;
      UIntBufferPointer = (uint *)DataBufferPointer[1];
      DataElementSize = *(ushort *)(DataElementOffset + 0x22);
      if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
        ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
        UIntBufferPointer = (uint *)DataBufferPointer[1];
      }
      *UIntBufferPointer = (uint)DataElementSize;
      UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
      DataBufferPointer[1] = (long long)UInt32BufferPointer;
      if (*(ushort *)(DataElementOffset + 0x22) != 0) {
        DataPointer = *(void* *)(DataElementOffset + 0x1a);
        DataSize = (ulong long)*(ushort *)(DataElementOffset + 0x22) * 4;
        if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) <= DataSize) {
          ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (DataSize - *DataBufferPointer));
          UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
        }
              memcpy(UInt32BufferPointer, DataPointer, DataSize);
      }
      ElementIndex = ElementIndex + 0x24;
      DataBlockSize = DataBlockSize + -1;
    } while (DataBlockSize != 0);
  }
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0x10;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UIntBufferPointer = (uint *)DataBufferPointer[1];
  DataElementSize = *(ushort *)(DataBlockHandle + 0x50);
  if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
    UIntBufferPointer = (uint *)DataBufferPointer[1];
  }
  *UIntBufferPointer = (uint)DataElementSize;
  UInt32BufferPointer = (uint32_t *)(DataBufferPointer[1] + 4);
  DataBufferPointer[1] = (long long)UInt32BufferPointer;
  if (*(ushort *)(DataBlockHandle + 0x50) != 0) {
    DataPointer = *(void* *)(DataBlockHandle + 0x48);
    DataSize = (ulong long)*(ushort *)(DataBlockHandle + 0x50) * 4;
    if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) <= DataSize) {
      ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (DataSize - *DataBufferPointer));
      UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
    }
      memcpy(UInt32BufferPointer, DataPointer, DataSize);
  }
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  if ((ulong long)((*DataBufferPointer - (long long)UInt32BufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UInt32BufferPointer + (4 - *DataBufferPointer));
    UInt32BufferPointer = (uint32_t *)DataBufferPointer[1];
  }
  *UInt32BufferPointer = 0x10;
  DataBufferPointer[1] = DataBufferPointer[1] + 4;
  UIntBufferPointer = (uint *)DataBufferPointer[1];
  DataElementSize = *(ushort *)(DataBlockHandle + 0x62);
  if ((ulong long)((*DataBufferPointer - (long long)UIntBufferPointer) + DataBufferPointer[2]) < 5) {
    ExpandDataBuffer(DataBufferPointer,(long long)UIntBufferPointer + (4 - *DataBufferPointer));
    UIntBufferPointer = (uint *)DataBufferPointer[1];
  }
  *UIntBufferPointer = (uint)DataElementSize;
  DataBlockSize = DataBufferPointer[1] + 4;
  DataBufferPointer[1] = DataBlockSize;
  if (*(ushort *)(DataBlockHandle + 0x62) == 0) {
    return;
  }
  DataPointer = *(void* *)(DataBlockHandle + 0x5a);
  DataSize = (ulong long)*(ushort *)(DataBlockHandle + 0x62) * 4;
  if ((ulong long)((*DataBufferPointer - DataBlockSize) + DataBufferPointer[2]) <= DataSize) {
    ExpandDataBuffer(DataBufferPointer,DataSize + (DataBlockSize - *DataBufferPointer));
    DataBlockSize = DataBufferPointer[1];
  }
  memcpy(DataBlockSize, DataPointer, DataSize);
}




/**
 * @brief 处理系统资源分配
 * 
 * 该函数负责处理系统资源的分配，包括内存分配和资源管理
 * 
 * @param SystemResourceManager 资源管理器指针
 * 
 *FUN_180073adc：ProcessSystemResourceAllocation
 */
void ProcessSystemResourceAllocation(long long SystemResourceManager)

{
  ushort SystemOperationStatus;
  void* resourceCreationFlags;
  int *pointerToInteger3;
  uint32_t *presourceAddress;
  uint *SystemThreadContext;
  long long SystemThreadFlags;
  long long *memoryBlockAddress;
  long long localDataIndex;
  int systemCode;
  ulong long ThreadContextFlag;
  long long SystemAllocationFlags;
  
  InitializeSystemSecurityContext();
  SystemThreadFlags = *(long long *)(SystemResourceManager + 0x28) - *(long long *)(SystemResourceManager + 0x20);
  pointerToInteger3 = (int *)memoryBlockAddress[1];
  SystemThreadFlags = SystemThreadFlags / 0x12 + (SystemThreadFlags >> 0x3f);
  systemCode = (int)(SystemThreadFlags >> 1) - (int)(SystemThreadFlags >> 0x3f);
  if ((ulong long)((*memoryBlockAddress - (long long)pointerToInteger3) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    pointerToInteger3 = (int *)memoryBlockAddress[1];
  }
  *pointerToInteger3 = systemCode;
  presourceAddress = (uint32_t *)(memoryBlockAddress[1] + 4);
  memoryBlockAddress[1] = (long long)presourceAddress;
  SystemThreadFlags = (long long)systemCode;
  if (0 < systemCode) {
    SystemAllocationFlags = 0;
    do {
      localDataIndex = *(long long *)(SystemResourceManager + 0x20) + SystemAllocationFlags;
      if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
        CopySystemMemoryData();
        presourceAddress = (uint32_t *)memoryBlockAddress[1];
      }
      *presourceAddress = 0;
      memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
      presourceAddress = (uint32_t *)memoryBlockAddress[1];
      if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
        CopySystemMemoryData();
        presourceAddress = (uint32_t *)memoryBlockAddress[1];
      }
      *presourceAddress = 0x10;
      memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
      SystemThreadContext = (uint *)memoryBlockAddress[1];
      SystemOperationStatus = *(ushort *)(localDataIndex + 0x10);
      if ((ulong long)((*memoryBlockAddress - (long long)SystemThreadContext) + memoryBlockAddress[2]) < 5) {
        CopySystemMemoryData();
        SystemThreadContext = (uint *)memoryBlockAddress[1];
      }
      *SystemThreadContext = (uint)SystemOperationStatus;
      presourceAddress = (uint32_t *)(memoryBlockAddress[1] + 4);
      memoryBlockAddress[1] = (long long)presourceAddress;
      if (*(ushort *)(localDataIndex + 0x10) != 0) {
        resourceCreationFlags = *(void* *)(localDataIndex + 8);
        ThreadContextFlag = (ulong long)*(ushort *)(localDataIndex + 0x10) * 4;
        if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) <= ThreadContextFlag) {
          CopySystemMemoryData();
          presourceAddress = (uint32_t *)memoryBlockAddress[1];
        }
          memcpy(presourceAddress,resourceCreationFlags,ThreadContextFlag);
      }
      localDataIndex = *(long long *)(SystemResourceManager + 0x20) + SystemAllocationFlags;
      if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
        CopySystemMemoryData();
        presourceAddress = (uint32_t *)memoryBlockAddress[1];
      }
      *presourceAddress = 0;
      memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
      presourceAddress = (uint32_t *)memoryBlockAddress[1];
      if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
        CopySystemMemoryData();
        presourceAddress = (uint32_t *)memoryBlockAddress[1];
      }
      *presourceAddress = 0x10;
      memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
      SystemThreadContext = (uint *)memoryBlockAddress[1];
      SystemOperationStatus = *(ushort *)(localDataIndex + 0x22);
      if ((ulong long)((*memoryBlockAddress - (long long)SystemThreadContext) + memoryBlockAddress[2]) < 5) {
        CopySystemMemoryData();
        SystemThreadContext = (uint *)memoryBlockAddress[1];
      }
      *SystemThreadContext = (uint)SystemOperationStatus;
      presourceAddress = (uint32_t *)(memoryBlockAddress[1] + 4);
      memoryBlockAddress[1] = (long long)presourceAddress;
      if (*(ushort *)(localDataIndex + 0x22) != 0) {
        resourceCreationFlags = *(void* *)(localDataIndex + 0x1a);
        ThreadContextFlag = (ulong long)*(ushort *)(localDataIndex + 0x22) * 4;
        if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) <= ThreadContextFlag) {
          CopySystemMemoryData();
          presourceAddress = (uint32_t *)memoryBlockAddress[1];
        }
          memcpy(presourceAddress,resourceCreationFlags,ThreadContextFlag);
      }
      SystemAllocationFlags = SystemAllocationFlags + 0x24;
      SystemThreadFlags = SystemThreadFlags + -1;
    } while (SystemThreadFlags != 0);
  }
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint32_t *)memoryBlockAddress[1];
  }
  *presourceAddress = 0;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  presourceAddress = (uint32_t *)memoryBlockAddress[1];
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint32_t *)memoryBlockAddress[1];
  }
  *presourceAddress = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemThreadContext = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(SystemResourceManager + 0x50);
  if ((ulong long)((*memoryBlockAddress - (long long)SystemThreadContext) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemThreadContext = (uint *)memoryBlockAddress[1];
  }
  *SystemThreadContext = (uint)SystemOperationStatus;
  presourceAddress = (uint32_t *)(memoryBlockAddress[1] + 4);
  memoryBlockAddress[1] = (long long)presourceAddress;
  if (*(ushort *)(SystemResourceManager + 0x50) != 0) {
    resourceCreationFlags = *(void* *)(SystemResourceManager + 0x48);
    ThreadContextFlag = (ulong long)*(ushort *)(SystemResourceManager + 0x50) * 4;
    if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) <= ThreadContextFlag) {
      CopySystemMemoryData();
      presourceAddress = (uint32_t *)memoryBlockAddress[1];
    }
      memcpy(presourceAddress,resourceCreationFlags,ThreadContextFlag);
  }
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint32_t *)memoryBlockAddress[1];
  }
  *presourceAddress = 0;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  presourceAddress = (uint32_t *)memoryBlockAddress[1];
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint32_t *)memoryBlockAddress[1];
  }
  *presourceAddress = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemThreadContext = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(SystemResourceManager + 0x62);
  if ((ulong long)((*memoryBlockAddress - (long long)SystemThreadContext) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemThreadContext = (uint *)memoryBlockAddress[1];
  }
  *SystemThreadContext = (uint)SystemOperationStatus;
  SystemThreadFlags = memoryBlockAddress[1] + 4;
  memoryBlockAddress[1] = SystemThreadFlags;
  if (*(ushort *)(SystemResourceManager + 0x62) == 0) {
    return;
  }
  resourceCreationFlags = *(void* *)(SystemResourceManager + 0x5a);
  ThreadContextFlag = (ulong long)*(ushort *)(SystemResourceManager + 0x62) * 4;
  if ((ulong long)((*memoryBlockAddress - SystemThreadFlags) + memoryBlockAddress[2]) <= ThreadContextFlag) {
    CopySystemMemoryData();
    SystemThreadFlags = memoryBlockAddress[1];
  }
    memcpy(SystemThreadFlags,resourceCreationFlags,ThreadContextFlag);
}




/**
 * @brief 验证系统资源状态
 * 
 * 该函数负责验证系统资源的状态，确保资源处于有效状态
 * 
 * @param SystemResourceManager 资源管理器指针
 * 
 *FUN_180073b64：ValidateSystemResourceState
 */
void ValidateSystemResourceState(uint *SystemResourceManager)

{
  ushort SystemOperationStatus;
  void* resourceCreationFlags;
  uint32_t *SystemHashNodeData;
  uint *presourceAddress;
  long long *memoryBlockAddress;
  long long SystemTimeValue;
  ulong long ResourceHash;
  long long systemAllocationOffset;
  uint SystemResourceIndex;
  long long systemResourceHandle;
  
  ResourceHash = (ulong long)SystemResourceIndex;
  do {
    localSystemPointer = *(long long *)(systemResourceHandle + 0x20) + ResourceHash;
    if ((ulong long)((*memoryBlockAddress - (long long)SystemResourceManager) + memoryBlockAddress[2]) < 5) {
      CopySystemMemoryData();
      SystemResourceManager = (uint *)memoryBlockAddress[1];
    }
    *SystemResourceManager = SystemResourceIndex;
    memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
    if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
      CopySystemMemoryData();
      SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
    }
    *SystemHashNodeData = 0x10;
    memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
    presourceAddress = (uint *)memoryBlockAddress[1];
    SystemOperationStatus = *(ushort *)(localSystemPointer + 0x10);
    if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
      CopySystemMemoryData();
      presourceAddress = (uint *)memoryBlockAddress[1];
    }
    *presourceAddress = (uint)SystemOperationStatus;
    presourceAddress = (uint *)(memoryBlockAddress[1] + 4);
    memoryBlockAddress[1] = (long long)presourceAddress;
    if (*(ushort *)(localSystemPointer + 0x10) != 0) {
      resourceCreationFlags = *(void* *)(localSystemPointer + 8);
      ResourceHash = (ulong long)*(ushort *)(localSystemPointer + 0x10) * 4;
      if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) <= ResourceHash) {
        CopySystemMemoryData();
        presourceAddress = (uint *)memoryBlockAddress[1];
      }
        memcpy(presourceAddress,resourceCreationFlags,ResourceHash);
    }
    localSystemPointer = *(long long *)(systemResourceHandle + 0x20) + ResourceHash;
    if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
      CopySystemMemoryData();
      presourceAddress = (uint *)memoryBlockAddress[1];
    }
    *presourceAddress = SystemResourceIndex;
    memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
    if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
      CopySystemMemoryData();
      SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
    }
    *SystemHashNodeData = 0x10;
    memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
    presourceAddress = (uint *)memoryBlockAddress[1];
    SystemOperationStatus = *(ushort *)(localSystemPointer + 0x22);
    if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
      CopySystemMemoryData();
      presourceAddress = (uint *)memoryBlockAddress[1];
    }
    *presourceAddress = (uint)SystemOperationStatus;
    SystemResourceManager = (uint *)(memoryBlockAddress[1] + 4);
    memoryBlockAddress[1] = (long long)SystemResourceManager;
    if (*(ushort *)(localSystemPointer + 0x22) != 0) {
      resourceCreationFlags = *(void* *)(localSystemPointer + 0x1a);
      ResourceHash = (ulong long)*(ushort *)(localSystemPointer + 0x22) * 4;
      if ((ulong long)((*memoryBlockAddress - (long long)SystemResourceManager) + memoryBlockAddress[2]) <= ResourceHash) {
        CopySystemMemoryData();
        SystemResourceManager = (uint *)memoryBlockAddress[1];
      }
        memcpy(SystemResourceManager,resourceCreationFlags,ResourceHash);
    }
    ResourceHash = ResourceHash + 0x24;
    systemAllocationOffset = systemAllocationOffset + -1;
  } while (systemAllocationOffset != 0);
  if ((ulong long)((*memoryBlockAddress - (long long)SystemResourceManager) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemResourceManager = (uint *)memoryBlockAddress[1];
  }
  *SystemResourceManager = SystemResourceIndex;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  }
  *SystemHashNodeData = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  presourceAddress = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(systemResourceHandle + 0x50);
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint *)memoryBlockAddress[1];
  }
  *presourceAddress = (uint)SystemOperationStatus;
  presourceAddress = (uint *)(memoryBlockAddress[1] + 4);
  memoryBlockAddress[1] = (long long)presourceAddress;
  if (*(ushort *)(systemResourceHandle + 0x50) != 0) {
    resourceCreationFlags = *(void* *)(systemResourceHandle + 0x48);
    ResourceHash = (ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4;
    if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) <= ResourceHash) {
      CopySystemMemoryData();
      presourceAddress = (uint *)memoryBlockAddress[1];
    }
      memcpy(presourceAddress,resourceCreationFlags,ResourceHash);
  }
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint *)memoryBlockAddress[1];
  }
  *presourceAddress = SystemResourceIndex;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  }
  *SystemHashNodeData = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  presourceAddress = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(systemResourceHandle + 0x62);
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint *)memoryBlockAddress[1];
  }
  *presourceAddress = (uint)SystemOperationStatus;
  localSystemPointer = memoryBlockAddress[1] + 4;
  memoryBlockAddress[1] = localSystemPointer;
  if (*(ushort *)(systemResourceHandle + 0x62) != 0) {
    resourceCreationFlags = *(void* *)(systemResourceHandle + 0x5a);
    ResourceHash = (ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4;
    if ((ulong long)((*memoryBlockAddress - localSystemPointer) + memoryBlockAddress[2]) <= ResourceHash) {
      CopySystemMemoryData();
      localSystemPointer = memoryBlockAddress[1];
    }
      memcpy(localSystemPointer,resourceCreationFlags,ResourceHash);
  }
  return;
}




// 函数: void ValidateSystemResourceManagerSecurity(uint32_t *SystemResourceManager)
/**
 * @brief 初始化资源管理器哈希节点
 * 
 * 该函数负责初始化资源管理器的哈希节点，设置哈希值和相关属性
 * 用于资源管理器的数据结构初始化
 * 
 * @param SystemResourceManager 资源管理器指针，指向要初始化的资源管理器
 * @return 无返回值
 * 
 *FUN_180073e0b：InitializeResourceManagerHashNode
 */
void InitializeResourceManagerHashNode(uint32_t *SystemResourceManager)
{
  ushort SystemResourceStatus;
  void* ResourceCreationFlags;
  uint32_t *SystemHashNodeData;
  uint *SystemStatusValue;
  long long SystemTimestamp;
  long long *SystemMemoryBlockPtr;
  ulong long ResourceHashValue;
  uint32_t ResourceNodeId;
  long long SystemResourceHandle;
  
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)SystemResourceManager) + SystemMemoryBlockPtr[2]) < 5) {
    CopySystemMemoryData();
    SystemResourceManager = (uint32_t *)SystemMemoryBlockPtr[1];
  }
  *SystemResourceManager = ResourceNodeId;
  SystemMemoryBlockPtr[1] = SystemMemoryBlockPtr[1] + 4;
  SystemHashNodeData = (uint32_t *)SystemMemoryBlockPtr[1];
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)SystemHashNodeData) + SystemMemoryBlockPtr[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)SystemMemoryBlockPtr[1];
  }
  *SystemHashNodeData = 0x10;
  SystemMemoryBlockPtr[1] = SystemMemoryBlockPtr[1] + 4;
  SystemStatusValue = (uint *)SystemMemoryBlockPtr[1];
  SystemResourceStatus = *(ushort *)(SystemResourceHandle + 0x50);
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)SystemStatusValue) + SystemMemoryBlockPtr[2]) < 5) {
    CopySystemMemoryData();
    SystemStatusValue = (uint *)SystemMemoryBlockPtr[1];
  }
  *SystemStatusValue = (uint)SystemResourceStatus;
  SystemHashNodeData = (uint32_t *)(SystemMemoryBlockPtr[1] + 4);
  SystemMemoryBlockPtr[1] = (long long)SystemHashNodeData;
  if (*(ushort *)(SystemResourceHandle + 0x50) != 0) {
    ResourceCreationFlags = *(void* *)(SystemResourceHandle + 0x48);
    ResourceHashValue = (ulong long)*(ushort *)(SystemResourceHandle + 0x50) * 4;
    if ((ulong long)((*SystemMemoryBlockPtr - (long long)SystemHashNodeData) + SystemMemoryBlockPtr[2]) <= ResourceHashValue) {
      CopySystemMemoryData();
      SystemHashNodeData = (uint32_t *)SystemMemoryBlockPtr[1];
    }
      memcpy(SystemHashNodeData,ResourceCreationFlags,ResourceHashValue);
  }
  if ((ulong long)((*SystemMemoryBlockPtr - (long long)SystemHashNodeData) + SystemMemoryBlockPtr[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)SystemMemoryBlockPtr[1];
  }
  *SystemHashNodeData = ResourceNodeId;
  SystemMemoryBlockPtr[1] = SystemMemoryBlockPtr[1] + 4;
  return;
}




// 函数: void ProcessSystemResourceOperationA(void)
/**
 * @brief 处理系统资源操作A
 * 
 * 该函数处理系统资源的操作，包括资源分配、数据复制和内存管理。
 * 主要用于系统资源的管理和维护。
 */
void ProcessSystemResourceOperationA(void)

{
  ushort SystemOperationStatus;
  void* resourceCreationFlags;
  uint32_t *SystemHashNodeData;
  uint *presourceAddress;
  long long SystemTimeValue;
  long long *memoryBlockAddress;
  ulong long ResourceHash;
  uint32_t SystemResourceIndex;
  long long systemResourceHandle;
  
  CopySystemMemoryData();
  *(uint32_t *)memoryBlockAddress[1] = SystemResourceIndex;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  }
  *SystemHashNodeData = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  presourceAddress = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(systemResourceHandle + 0x50);
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint *)memoryBlockAddress[1];
  }
  *presourceAddress = (uint)SystemOperationStatus;
  SystemHashNodeData = (uint32_t *)(memoryBlockAddress[1] + 4);
  memoryBlockAddress[1] = (long long)SystemHashNodeData;
  if (*(ushort *)(systemResourceHandle + 0x50) != 0) {
    resourceCreationFlags = *(void* *)(systemResourceHandle + 0x48);
    ResourceHash = (ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4;
    if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) <= ResourceHash) {
      CopySystemMemoryData();
      SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
    }
      memcpy(SystemHashNodeData,resourceCreationFlags,ResourceHash);
  }
  if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  }
  *SystemHashNodeData = SystemResourceIndex;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint32_t *)memoryBlockAddress[1];
  }
  *SystemHashNodeData = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  presourceAddress = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(systemResourceHandle + 0x62);
  if ((ulong long)((*memoryBlockAddress - (long long)presourceAddress) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    presourceAddress = (uint *)memoryBlockAddress[1];
  }
  *presourceAddress = (uint)SystemOperationStatus;
  localSystemPointer = memoryBlockAddress[1] + 4;
  memoryBlockAddress[1] = localSystemPointer;
  if (*(ushort *)(systemResourceHandle + 0x62) != 0) {
    resourceCreationFlags = *(void* *)(systemResourceHandle + 0x5a);
    ResourceHash = (ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4;
    if ((ulong long)((*memoryBlockAddress - localSystemPointer) + memoryBlockAddress[2]) <= ResourceHash) {
      CopySystemMemoryData();
      localSystemPointer = memoryBlockAddress[1];
    }
      memcpy(localSystemPointer,resourceCreationFlags,ResourceHash);
  }
  return;
}




// 函数: void ProcessSystemResourceOperationB(void)
/**
 * @brief 处理系统资源操作B
 * 
 * 该函数处理系统资源的操作，包括数据复制和内存管理。
 * 主要用于系统资源的维护和清理。
 */
void ProcessSystemResourceOperationB(void)

{
  ushort SystemOperationStatus;
  void* resourceCreationFlags;
  uint *SystemHashNodeData;
  long long SystemBufferAddress;
  long long *memoryBlockAddress;
  ulong long currentThreadId;
  long long systemResourceHandle;
  
  CopySystemMemoryData();
  *(uint32_t *)memoryBlockAddress[1] = 0x10;
  memoryBlockAddress[1] = memoryBlockAddress[1] + 4;
  SystemHashNodeData = (uint *)memoryBlockAddress[1];
  SystemOperationStatus = *(ushort *)(systemResourceHandle + 0x62);
  if ((ulong long)((*memoryBlockAddress - (long long)SystemHashNodeData) + memoryBlockAddress[2]) < 5) {
    CopySystemMemoryData();
    SystemHashNodeData = (uint *)memoryBlockAddress[1];
  }
  *SystemHashNodeData = (uint)SystemOperationStatus;
  SystemBufferAddress = memoryBlockAddress[1] + 4;
  memoryBlockAddress[1] = SystemBufferAddress;
  if (*(ushort *)(systemResourceHandle + 0x62) != 0) {
    resourceCreationFlags = *(void* *)(systemResourceHandle + 0x5a);
    currentThreadId = (ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4;
    if ((ulong long)((*memoryBlockAddress - SystemBufferAddress) + memoryBlockAddress[2]) <= currentThreadId) {
      CopySystemMemoryData();
      SystemBufferAddress = memoryBlockAddress[1];
    }
      memcpy(SystemBufferAddress,resourceCreationFlags,currentThreadId);
  }
  return;
}





// 函数: void ProcessSystemResourceOperationC(long long* SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 处理系统资源操作C
 * 
 * 该函数处理系统资源的操作，包括资源分配、线程创建和内存管理。
 * 主要用于系统资源的初始化和维护。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 参数2，用于传递额外的系统参数
 */
void ProcessSystemResourceOperationC(long long* SystemResourceManager,long long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  uint resourceAllocationContext;
  int systemIndex;
  long long SystemTimeValue;
  ulong long ResourceHash;
  long long localDataIndex;
  long long SystemMemoryAddress;
  uint *SystemOperationCounterPointer;
  long long SystemAllocationFlags;
  long long SystemResourceDataIndex;
  long long *PrimaryResourcePointer2;
  
  resourceAllocationContext = **(uint **)(ConfigurationDataPointer + 8);
  SystemOperationCounterPointer = *(uint **)(ConfigurationDataPointer + 8) + 1;
  *(uint **)(ConfigurationDataPointer + 8) = SystemOperationCounterPointer;
  if (resourceAllocationContext != 0) {
    (**(code **)(*SystemResourceManager + 0x18))(SystemResourceManager,SystemOperationCounterPointer,resourceAllocationContext);
    *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + (ulong long)resourceAllocationContext;
    SystemOperationCounterPointer = *(uint **)(ConfigurationDataPointer + 8);
  }
  SystemMemoryAddress = (long long)(int)*SystemOperationCounterPointer;
  *(uint **)(ConfigurationDataPointer + 8) = SystemOperationCounterPointer + 1;
  PrimaryResourcePointer = SystemResourceManager + 4;
  AllocateSystemResourceMemory(PrimaryResourcePointer,SystemMemoryAddress);
  localSystemPointer = *(long long *)(ComparisonDataPointer + 8);
  localDataIndex = 0;
  SystemResourceDataIndex = localDataIndex;
  if (0 < SystemMemoryAddress) {
    do {
      SystemAllocationFlags = *PrimaryResourcePointer;
      *(int **)(ConfigurationDataPointer + 8) = (int *)(localSystemPointer + 8);
      systemIndex = *(int *)(localSystemPointer + 8);
      PrimaryResourcePointer2 = (long long *)(SystemAllocationFlags + SystemResourceDataIndex);
      *(long long *)(ComparisonDataPointer + 8) = localSystemPointer + 0xc;
      if (0 < systemIndex) {
        *(short *)(PrimaryResourcePointer2 + 2) = (short)systemIndex;
        if (PrimaryResourcePointer2[1] != 0) {
            SystemCleanupFunction();
        }
        PrimaryResourcePointer2[1] = 0;
        if (*PrimaryResourcePointer2 == 0) {
          *PrimaryResourcePointer2 = 0;
          if ((ulong long)*(ushort *)(PrimaryResourcePointer2 + 2) == 0) {
            ResourceHash = 0;
            localSystemPointer = localDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(PrimaryResourcePointer2 + 2) * 4,4);
            ResourceHash = (ulong long)*(ushort *)(PrimaryResourcePointer2 + 2);
          }
          PrimaryResourcePointer2[1] = localSystemPointer;
          if (ResourceHash != 0) {
            localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHash << 4,4);
          }
          *PrimaryResourcePointer2 = localDataIndex;
            memcpy(PrimaryResourcePointer2[1],*(void* *)(ConfigurationDataPointer + 8),(long long)(systemIndex * 4));
        }
          SystemCleanupFunction();
      }
      SystemAllocationFlags = *PrimaryResourcePointer;
      pointerToInteger2 = (int *)(localSystemPointer + 0x14);
      *(int **)(ConfigurationDataPointer + 8) = pointerToInteger2;
      localSystemPointer = localSystemPointer + 0x18;
      systemIndex = *pointerToInteger2;
      SystemAllocationFlags = SystemAllocationFlags + SystemResourceDataIndex;
      *(long long *)(ComparisonDataPointer + 8) = localSystemPointer;
      if (0 < systemIndex) {
        *(short *)(SystemAllocationFlags + 0x22) = (short)systemIndex;
        if (*(long long *)(SystemAllocationFlags + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)(SystemAllocationFlags + 0x1a) = 0;
        if (*(long long *)(SystemAllocationFlags + 0x12) == 0) {
          *(void* *)(SystemAllocationFlags + 0x12) = 0;
          if ((ulong long)*(ushort *)(SystemAllocationFlags + 0x22) == 0) {
            ResourceHash = 0;
            localSystemPointer = localDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(SystemAllocationFlags + 0x22) * 4,4);
            ResourceHash = (ulong long)*(ushort *)(SystemAllocationFlags + 0x22);
          }
          *(long long *)(SystemAllocationFlags + 0x1a) = localSystemPointer;
          if (ResourceHash != 0) {
            localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHash << 4,4);
          }
          *(long long *)(SystemAllocationFlags + 0x12) = localDataIndex;
            memcpy(*(void* *)(SystemAllocationFlags + 0x1a),*(void* *)(ConfigurationDataPointer + 8),(long long)(systemIndex * 4));
        }
          SystemCleanupFunction();
      }
      SystemMemoryAddress = SystemMemoryAddress + -1;
      SystemResourceDataIndex = SystemResourceDataIndex + 0x24;
    } while (SystemMemoryAddress != 0);
  }
  *(int **)(ConfigurationDataPointer + 8) = (int *)(localSystemPointer + 8);
  systemIndex = *(int *)(localSystemPointer + 8);
  *(long long *)(ComparisonDataPointer + 8) = localSystemPointer + 0xc;
  if (systemIndex < 1) {
    *(int **)(ConfigurationDataPointer + 8) = (int *)(localSystemPointer + 0x14);
    systemIndex = *(int *)(localSystemPointer + 0x14);
    *(long long *)(ComparisonDataPointer + 8) = localSystemPointer + 0x18;
    if (systemIndex < 1) {
      return;
    }
    *(short *)((long long)SystemResourceManager + 0x62) = (short)systemIndex;
    if (*(long long *)((long long)SystemResourceManager + 0x5a) == 0) {
      *(void* *)((long long)SystemResourceManager + 0x5a) = 0;
      if (*(long long *)((long long)SystemResourceManager + 0x52) == 0) {
        *(void* *)((long long)SystemResourceManager + 0x52) = 0;
        if ((ulong long)*(ushort *)((long long)SystemResourceManager + 0x62) == 0) {
          ResourceHash = 0;
          localSystemPointer = localDataIndex;
        }
        else {
          localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)((long long)SystemResourceManager + 0x62) * 4,
                                4);
          ResourceHash = (ulong long)*(ushort *)((long long)SystemResourceManager + 0x62);
        }
        *(long long *)((long long)SystemResourceManager + 0x5a) = localSystemPointer;
        if (ResourceHash != 0) {
          localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHash << 4,4);
        }
        *(long long *)((long long)SystemResourceManager + 0x52) = localDataIndex;
          memcpy(*(void* *)((long long)SystemResourceManager + 0x5a),*(void* *)(ConfigurationDataPointer + 8),
               (long long)(systemIndex * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(SystemResourceManager + 10) = (short)systemIndex;
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[9] = 0;
  if (SystemResourceManager[8] == 0) {
    SystemResourceManager[8] = 0;
    if ((ulong long)*(ushort *)(SystemResourceManager + 10) == 0) {
      ResourceHash = 0;
      localSystemPointer = localDataIndex;
    }
    else {
      localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(SystemResourceManager + 10) * 4,4);
      ResourceHash = (ulong long)*(ushort *)(SystemResourceManager + 10);
    }
    SystemResourceManager[9] = localSystemPointer;
    if (ResourceHash != 0) {
      localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHash << 4,4);
    }
    SystemResourceManager[8] = localDataIndex;
      memcpy(SystemResourceManager[9],*(void* *)(ConfigurationDataPointer + 8),(long long)(systemIndex * 4));
  }
    SystemCleanupFunction();
}





// 函数: void CleanupSystemResourceManagerFinal(long long* SystemResourceManager)
/**
 * @brief 处理系统资源分配和数据初始化
 * 
 * 该函数负责处理系统资源的分配和数据的初始化操作
 * 用于系统资源管理和数据结构的建立
 * 
 * @param SystemResourceManager 资源管理器指针，指向要处理的资源管理器
 * @return 无返回值
 * 
 *FUN_1800740a2：ProcessSystemResourceAllocation
 */
void ProcessSystemResourceAllocation(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  int *SecondaryResourcePointer;
  uint AllocationContextSize;
  int SystemResourceIndex;
  uint *SystemResourceArray;
  long long SystemTimestamp;
  ulong long ResourceHashValue;
  long long CurrentDataIndex;
  long long MemoryAllocationSize;
  uint *ResourceDataPointer;
  long long ResourceAllocationFlags;
  long long SystemDataIndexPointer;
  long long ResourceDataOffset;
  long long *SecondaryResourceDataPointer;
  
  AllocationContextSize = *SystemResourceArray;
  ResourceDataPointer = SystemResourceArray + 1;
  *(uint **)(SystemDataIndexPointer + 8) = ResourceDataPointer;
  if (AllocationContextSize != 0) {
    (**(code **)(*SystemResourceManager + 0x18))(SystemResourceManager,ResourceDataPointer,AllocationContextSize);
    *(long long *)(SystemDataIndexPointer + 8) = *(long long *)(SystemDataIndexPointer + 8) + (ulong long)AllocationContextSize;
    ResourceDataPointer = *(uint **)(SystemDataIndexPointer + 8);
  }
  MemoryAllocationSize = (long long)(int)*ResourceDataPointer;
  *(uint **)(SystemDataIndexPointer + 8) = ResourceDataPointer + 1;
  PrimaryResourcePointer = SystemResourceManager + 4;
  AllocateSystemResourceMemory(PrimaryResourcePointer,MemoryAllocationSize);
  localSystemPointer = *(long long *)(SystemDataIndexPointer + 8);
  CurrentDataIndex = 0;
  ResourceDataOffset = CurrentDataIndex;
  if (0 < MemoryAllocationSize) {
    do {
      ResourceAllocationFlags = *PrimaryResourcePointer;
      *(int **)(SystemDataIndexPointer + 8) = (int *)(localSystemPointer + 8);
      SystemResourceIndex = *(int *)(localSystemPointer + 8);
      SecondaryResourceDataPointer = (long long *)(ResourceAllocationFlags + ResourceDataOffset);
      *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer + 0xc;
      if (0 < SystemResourceIndex) {
        *(short *)(SecondaryResourceDataPointer + 2) = (short)SystemResourceIndex;
        if (SecondaryResourceDataPointer[1] != 0) {
            SystemCleanupFunction();
        }
        SecondaryResourceDataPointer[1] = 0;
        if (*SecondaryResourceDataPointer == 0) {
          *SecondaryResourceDataPointer = 0;
          if ((ulong long)*(ushort *)(SecondaryResourceDataPointer + 2) == 0) {
            ResourceHashValue = 0;
            localSystemPointer = CurrentDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(SecondaryResourceDataPointer + 2) * 4,4);
            ResourceHashValue = (ulong long)*(ushort *)(SecondaryResourceDataPointer + 2);
          }
          SecondaryResourceDataPointer[1] = localSystemPointer;
          if (ResourceHashValue != 0) {
            CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
          }
          *SecondaryResourceDataPointer = CurrentDataIndex;
            memcpy(SecondaryResourceDataPointer[1],*(void* *)(SystemDataIndexPointer + 8),(long long)(SystemResourceIndex * 4));
        }
          SystemCleanupFunction();
      }
      ResourceAllocationFlags = *PrimaryResourcePointer;
      SecondaryResourcePointer = (int *)(localSystemPointer + 0x14);
      *(int **)(SystemDataIndexPointer + 8) = SecondaryResourcePointer;
      localSystemPointer = localSystemPointer + 0x18;
      SystemResourceIndex = *SecondaryResourcePointer;
      ResourceAllocationFlags = ResourceAllocationFlags + ResourceDataOffset;
      *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer;
      if (0 < SystemResourceIndex) {
        *(short *)(ResourceAllocationFlags + 0x22) = (short)SystemResourceIndex;
        if (*(long long *)(ResourceAllocationFlags + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)(ResourceAllocationFlags + 0x1a) = 0;
        if (*(long long *)(ResourceAllocationFlags + 0x12) == 0) {
          *(void* *)(ResourceAllocationFlags + 0x12) = 0;
          if ((ulong long)*(ushort *)(ResourceAllocationFlags + 0x22) == 0) {
            ResourceHashValue = 0;
            localSystemPointer = CurrentDataIndex;
          }
          else {
            localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(ResourceAllocationFlags + 0x22) * 4,4);
            ResourceHashValue = (ulong long)*(ushort *)(ResourceAllocationFlags + 0x22);
          }
          *(long long *)(ResourceAllocationFlags + 0x1a) = localSystemPointer;
          if (ResourceHashValue != 0) {
            CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
          }
          *(long long *)(ResourceAllocationFlags + 0x12) = CurrentDataIndex;
            memcpy(*(void* *)(ResourceAllocationFlags + 0x1a),*(void* *)(SystemDataIndexPointer + 8),(long long)(SystemResourceIndex * 4)
                );
        }
          SystemCleanupFunction();
      }
      MemoryAllocationSize = MemoryAllocationSize + -1;
      ResourceDataOffset = ResourceDataOffset + 0x24;
    } while (MemoryAllocationSize != 0);
  }
  *(int **)(SystemDataIndexPointer + 8) = (int *)(localSystemPointer + 8);
  SystemResourceIndex = *(int *)(localSystemPointer + 8);
  *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer + 0xc;
  if (SystemResourceIndex < 1) {
    *(int **)(SystemDataIndexPointer + 8) = (int *)(localSystemPointer + 0x14);
    SystemResourceIndex = *(int *)(localSystemPointer + 0x14);
    *(long long *)(SystemDataIndexPointer + 8) = localSystemPointer + 0x18;
    if (SystemResourceIndex < 1) {
      return;
    }
    *(short *)((long long)SystemResourceManager + 0x62) = (short)SystemResourceIndex;
    if (*(long long *)((long long)SystemResourceManager + 0x5a) == 0) {
      *(void* *)((long long)SystemResourceManager + 0x5a) = 0;
      if (*(long long *)((long long)SystemResourceManager + 0x52) == 0) {
        *(void* *)((long long)SystemResourceManager + 0x52) = 0;
        if ((ulong long)*(ushort *)((long long)SystemResourceManager + 0x62) == 0) {
          ResourceHashValue = 0;
          localSystemPointer = CurrentDataIndex;
        }
        else {
          localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)((long long)SystemResourceManager + 0x62) * 4,
                                4);
          ResourceHashValue = (ulong long)*(ushort *)((long long)SystemResourceManager + 0x62);
        }
        *(long long *)((long long)SystemResourceManager + 0x5a) = localSystemPointer;
        if (ResourceHashValue != 0) {
          CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
        }
        *(long long *)((long long)SystemResourceManager + 0x52) = CurrentDataIndex;
          memcpy(*(void* *)((long long)SystemResourceManager + 0x5a),*(void* *)(SystemDataIndexPointer + 8),
               (long long)(SystemResourceIndex * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(SystemResourceManager + 10) = (short)SystemResourceIndex;
  if (SystemResourceManager[9] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[9] = 0;
  if (SystemResourceManager[8] == 0) {
    SystemResourceManager[8] = 0;
    if ((ulong long)*(ushort *)(SystemResourceManager + 10) == 0) {
      ResourceHashValue = 0;
      localSystemPointer = CurrentDataIndex;
    }
    else {
      localSystemPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(SystemResourceManager + 10) * 4,4);
      ResourceHashValue = (ulong long)*(ushort *)(SystemResourceManager + 10);
    }
    SystemResourceManager[9] = localSystemPointer;
    if (ResourceHashValue != 0) {
      CurrentDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceHashValue << 4,4);
    }
    SystemResourceManager[8] = CurrentDataIndex;
      memcpy(SystemResourceManager[9],*(void* *)(SystemDataIndexPointer + 8),(long long)(SystemResourceIndex * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 初始化系统缓冲区管理器
 * 
 * 该函数负责初始化系统缓冲区管理器，设置缓冲区的大小和参数。
 * 主要用于系统缓冲区的创建和管理工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向缓冲区管理器数据结构
 * 
 *FUN_1800740f5：InitializeSystemBufferManager
 */
void InitializeSystemBufferManager(long long SystemResourceManager)

{
  int SystemOperationStatus;
  ulong long resourceCreationFlags;
  long long ResourceDataOffset;
  long long *memoryBlockAddress;
  long long SystemBufferAddress;
  ulong long StringIteratorPointer;
  long long systemDataIndexPtr;
  ulong long currentThreadId;
  long long SystemContextPointer;
  ulong long *resourceEntryPointer;
  long long systemResourceHandle;
  
  currentThreadId = StringIteratorPointer & MAX_UNSIGNED_32_BIT;
  do {
    ResourceDataOffset = SystemResourceManager;
    SystemBufferAddress = *memoryBlockAddress;
    *(int **)(systemDataIndexPtr + 8) = (int *)(ResourceDataOffset + 8);
    SystemOperationStatus = *(int *)(ResourceDataOffset + 8);
    resourceEntryPointer = (ulong long *)(SystemBufferAddress + currentThreadId);
    *(long long *)(systemDataIndexPtr + 8) = ResourceDataOffset + 0xc;
    if (0 < SystemOperationStatus) {
      *(short *)(resourceEntryPointer + 2) = (short)SystemOperationStatus;
      if (resourceEntryPointer[1] != 0) {
          SystemCleanupFunction();
      }
      resourceEntryPointer[1] = StringIteratorPointer;
      if (*resourceEntryPointer == 0) {
        *resourceEntryPointer = StringIteratorPointer;
        if ((ulong long)(ushort)resourceEntryPointer[2] == 0) {
          currentThreadId = 0;
          resourceCreationFlags = StringIteratorPointer;
        }
        else {
          resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)(ushort)resourceEntryPointer[2] * 4,4);
          currentThreadId = (ulong long)(ushort)resourceEntryPointer[2];
        }
        resourceEntryPointer[1] = resourceCreationFlags;
        if (currentThreadId != 0) {
          StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
        }
        *resourceEntryPointer = StringIteratorPointer;
          memcpy(resourceEntryPointer[1],*(void* *)(systemDataIndexPtr + 8),(long long)(SystemOperationStatus * 4));
      }
        SystemCleanupFunction();
    }
    SystemBufferAddress = *memoryBlockAddress;
    *(int **)(systemDataIndexPtr + 8) = (int *)(ResourceDataOffset + 0x14);
    SystemOperationStatus = *(int *)(ResourceDataOffset + 0x14);
    SystemBufferAddress = SystemBufferAddress + currentThreadId;
    *(long long *)(systemDataIndexPtr + 8) = ResourceDataOffset + 0x18;
    if (0 < SystemOperationStatus) {
      *(short *)(SystemBufferAddress + 0x22) = (short)SystemOperationStatus;
      if (*(long long *)(SystemBufferAddress + 0x1a) != 0) {
          SystemCleanupFunction();
      }
      *(ulong long *)(SystemBufferAddress + 0x1a) = StringIteratorPointer;
      if (*(long long *)(SystemBufferAddress + 0x12) == 0) {
        *(ulong long *)(SystemBufferAddress + 0x12) = StringIteratorPointer;
        if ((ulong long)*(ushort *)(SystemBufferAddress + 0x22) == 0) {
          currentThreadId = 0;
          resourceCreationFlags = StringIteratorPointer;
        }
        else {
          resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(SystemBufferAddress + 0x22) * 4,4);
          currentThreadId = (ulong long)*(ushort *)(SystemBufferAddress + 0x22);
        }
        *(ulong long *)(SystemBufferAddress + 0x1a) = resourceCreationFlags;
        if (currentThreadId != 0) {
          StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
        }
        *(ulong long *)(SystemBufferAddress + 0x12) = StringIteratorPointer;
          memcpy(*(void* *)(SystemBufferAddress + 0x1a),*(void* *)(systemDataIndexPtr + 8),(long long)(SystemOperationStatus * 4));
      }
        SystemCleanupFunction();
    }
    currentThreadId = currentThreadId + 0x24;
    SystemContextPointer = SystemContextPointer + -1;
    SystemResourceManager = ResourceDataOffset + 0x18;
  } while (SystemContextPointer != 0);
  *(int **)(systemDataIndexPtr + 8) = (int *)(ResourceDataOffset + 0x20);
  SystemOperationStatus = *(int *)(ResourceDataOffset + 0x20);
  *(long long *)(systemDataIndexPtr + 8) = ResourceDataOffset + 0x24;
  if (SystemOperationStatus < 1) {
    *(int **)(systemDataIndexPtr + 8) = (int *)(ResourceDataOffset + 0x2c);
    SystemOperationStatus = *(int *)(ResourceDataOffset + 0x2c);
    *(long long *)(systemDataIndexPtr + 8) = ResourceDataOffset + 0x30;
    if (SystemOperationStatus < 1) {
      return;
    }
    *(short *)(systemResourceHandle + 0x62) = (short)SystemOperationStatus;
    if (*(long long *)(systemResourceHandle + 0x5a) == 0) {
      *(ulong long *)(systemResourceHandle + 0x5a) = StringIteratorPointer;
      if (*(long long *)(systemResourceHandle + 0x52) == 0) {
        *(ulong long *)(systemResourceHandle + 0x52) = StringIteratorPointer;
        if ((ulong long)*(ushort *)(systemResourceHandle + 0x62) == 0) {
          currentThreadId = 0;
          resourceCreationFlags = StringIteratorPointer;
        }
        else {
          resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4,4);
          currentThreadId = (ulong long)*(ushort *)(systemResourceHandle + 0x62);
        }
        *(ulong long *)(systemResourceHandle + 0x5a) = resourceCreationFlags;
        if (currentThreadId != 0) {
          StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
        }
        *(ulong long *)(systemResourceHandle + 0x52) = StringIteratorPointer;
          memcpy(*(void* *)(systemResourceHandle + 0x5a),*(void* *)(systemDataIndexPtr + 8),
               (long long)(SystemOperationStatus * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(systemResourceHandle + 0x50) = (short)SystemOperationStatus;
  if (*(long long *)(systemResourceHandle + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(ulong long *)(systemResourceHandle + 0x48) = StringIteratorPointer;
  if (*(long long *)(systemResourceHandle + 0x40) == 0) {
    *(ulong long *)(systemResourceHandle + 0x40) = StringIteratorPointer;
    if ((ulong long)*(ushort *)(systemResourceHandle + 0x50) == 0) {
      currentThreadId = 0;
      resourceCreationFlags = StringIteratorPointer;
    }
    else {
      resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4,4);
      currentThreadId = (ulong long)*(ushort *)(systemResourceHandle + 0x50);
    }
    *(ulong long *)(systemResourceHandle + 0x48) = resourceCreationFlags;
    if (currentThreadId != 0) {
      StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,currentThreadId << 4,4);
    }
    *(ulong long *)(systemResourceHandle + 0x40) = StringIteratorPointer;
      memcpy(*(void* *)(systemResourceHandle + 0x48),*(void* *)(systemDataIndexPtr + 8),(long long)(SystemOperationStatus * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 处理系统资源创建
 * 
 * 该函数负责处理系统资源的创建和初始化，包括线程对象的创建和内存分配
 * 用于系统资源的创建和配置
 * 
 * @param SystemResourceManager 系统资源管理器，包含系统资源的相关信息
 * @return 无返回值
 * 
 *FUN_1800742ea：ProcessSystemResourceCreation
 */
void ProcessSystemResourceCreation(long long SystemResourceManager)

{
  int SystemOperationStatus;
  void* resourceCreationFlags;
  ulong long resourceAllocationContext;
  void* StringIteratorPointer;
  long long systemDataIndexPtr;
  long long systemResourceHandle;
  
  *(int **)(systemDataIndexPtr + 8) = (int *)(SystemResourceManager + 8);
  SystemOperationStatus = *(int *)(SystemResourceManager + 8);
  *(long long *)(systemDataIndexPtr + 8) = SystemResourceManager + 0xc;
  if (SystemOperationStatus < 1) {
    *(int **)(systemDataIndexPtr + 8) = (int *)(SystemResourceManager + 0x14);
    SystemOperationStatus = *(int *)(SystemResourceManager + 0x14);
    *(long long *)(systemDataIndexPtr + 8) = SystemResourceManager + 0x18;
    if (SystemOperationStatus < 1) {
      return;
    }
    *(short *)(systemResourceHandle + 0x62) = (short)SystemOperationStatus;
    if (*(long long *)(systemResourceHandle + 0x5a) == 0) {
      *(void* *)(systemResourceHandle + 0x5a) = StringIteratorPointer;
      if (*(long long *)(systemResourceHandle + 0x52) == 0) {
        *(void* *)(systemResourceHandle + 0x52) = StringIteratorPointer;
        if ((ulong long)*(ushort *)(systemResourceHandle + 0x62) == 0) {
          resourceAllocationContext = 0;
          resourceCreationFlags = StringIteratorPointer;
        }
        else {
          resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x62) * 4,4);
          resourceAllocationContext = (ulong long)*(ushort *)(systemResourceHandle + 0x62);
        }
        *(void* *)(systemResourceHandle + 0x5a) = resourceCreationFlags;
        if (resourceAllocationContext != 0) {
          StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAllocationContext << 4,4);
        }
        *(void* *)(systemResourceHandle + 0x52) = StringIteratorPointer;
          memcpy(*(void* *)(systemResourceHandle + 0x5a),*(void* *)(systemDataIndexPtr + 8),
               (long long)(SystemOperationStatus * 4));
      }
        SystemCleanupFunction();
    }
      SystemCleanupFunction();
  }
  *(short *)(systemResourceHandle + 0x50) = (short)SystemOperationStatus;
  if (*(long long *)(systemResourceHandle + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(systemResourceHandle + 0x48) = StringIteratorPointer;
  if (*(long long *)(systemResourceHandle + 0x40) == 0) {
    *(void* *)(systemResourceHandle + 0x40) = StringIteratorPointer;
    if ((ulong long)*(ushort *)(systemResourceHandle + 0x50) == 0) {
      resourceAllocationContext = 0;
      resourceCreationFlags = StringIteratorPointer;
    }
    else {
      resourceCreationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4,4);
      resourceAllocationContext = (ulong long)*(ushort *)(systemResourceHandle + 0x50);
    }
    *(void* *)(systemResourceHandle + 0x48) = resourceCreationFlags;
    if (resourceAllocationContext != 0) {
      StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAllocationContext << 4,4);
    }
    *(void* *)(systemResourceHandle + 0x40) = StringIteratorPointer;
      memcpy(*(void* *)(systemResourceHandle + 0x48),*(void* *)(systemDataIndexPtr + 8),(long long)(SystemOperationStatus * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 系统全局状态初始化函数
 * 
 * 该函数负责初始化系统的全局状态，包括：
 * - 设置系统全局数据结构
 * - 初始化系统状态标志
 * - 配置系统内存管理
 * - 建立系统基础架构
 * 
 * @return 无返回值
 * @note 此函数在系统启动时调用，用于建立系统基础架构
 * @warning 调用此函数前必须确保系统资源已准备就绪
 */
void InitializeSystemGlobalState(void)

{
  void* SystemOperationStatus;
  ulong long resourceCreationFlags;
  void*2 unaff_BP;
  void*6 unaff_0000002a;
  void* StringIteratorPointer;
  long long systemDataIndexPtr;
  long long systemResourceHandle;
  
  *(void*2 *)(systemResourceHandle + 0x50) = unaff_BP;
  if (*(long long *)(systemResourceHandle + 0x48) != 0) {
      SystemCleanupFunction();
  }
  *(void* *)(systemResourceHandle + 0x48) = StringIteratorPointer;
  if (*(long long *)(systemResourceHandle + 0x40) == 0) {
    *(void* *)(systemResourceHandle + 0x40) = StringIteratorPointer;
    if ((ulong long)*(ushort *)(systemResourceHandle + 0x50) == 0) {
      resourceCreationFlags = 0;
      SystemOperationStatus = StringIteratorPointer;
    }
    else {
      SystemOperationStatus = CreateSystemThreadObject(SystemMemoryPoolTemplate,(ulong long)*(ushort *)(systemResourceHandle + 0x50) * 4,4);
      resourceCreationFlags = (ulong long)*(ushort *)(systemResourceHandle + 0x50);
    }
    *(void* *)(systemResourceHandle + 0x48) = SystemOperationStatus;
    if (resourceCreationFlags != 0) {
      StringIteratorPointer = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceCreationFlags << 4,4);
    }
    *(void* *)(systemResourceHandle + 0x40) = StringIteratorPointer;
      memcpy(*(void* *)(systemResourceHandle + 0x48),*(void* *)(systemDataIndexPtr + 8),
           (long long)((int)CONCAT62(unaff_0000002a,unaff_BP) * 4));
  }
    SystemCleanupFunction();
}





/**
 * @brief 系统资源时间戳管理函数
 * 
 * 该函数负责管理系统资源的时间戳，包括：
 * - 更新资源访问时间
 * - 记录资源修改时间
 * - 管理资源生命周期
 * - 处理时间相关的资源操作
 * 
 * @param SystemResourceManager 系统资源指针，指向需要管理的资源
 * @param ConfigurationDataPointer 时间参数，用于时间戳操作
 * @return 无返回值
 * @note 此函数用于资源的时间管理和生命周期控制
 * @warning 调用此函数前确保资源指针有效
 */
void ManageSystemResourceTimestamp(long long SystemResourceManager, long long TimestampParameter)

{
  uint *SystemDataPointer;
  int systemResult;
  uint resourceAllocationContext;
  int *pointerToInteger4;
  long long SystemTimeValue;
  int CalculationFlags;
  int systemOffset;
  int systemCode;
  uint32_t ThreadContextFlag;
  uint32_t SystemOperationFlags;
  uint32_t SystemOperationStatus1;
  uint8_t *pSystemSecondaryStatus;
  uint32_t *SystemDataConfigurationPointer;
  uint8_t aMemoryBufferAddress [32];
  void* SystemMemoryAllocatorStatus;
  void* *pointerUnsignedC8;
  uint8_t *pUnsignedStackFlagC0;
  uint32_t systemDataBuffer;
  uint8_t aUnsignedStackFlagB0 [136];
  ulong long EncryptionKeyValue;
  
  SystemMemoryAllocatorStatus = 0xfffffffffffffffe;
  EncryptionKeyValue = SystemEncryptionKeyTemplate ^ (ulong long)aMemoryBufferAddress;
  pointerToInteger4 = *(int **)(ConfigurationDataPointer + 8);
  systemResult = *pointerToInteger4;
  *(int **)(ConfigurationDataPointer + 8) = pointerToInteger4 + 1;
  CalculationFlags = pointerToInteger4[2];
  systemOffset = pointerToInteger4[3];
  systemCode = pointerToInteger4[4];
  *(int *)(SystemResourceManager + 0x18) = pointerToInteger4[1];
  *(int *)(SystemResourceManager + 0x1c) = CalculationFlags;
  *(int *)(SystemResourceManager + 0x20) = systemOffset;
  *(int *)(SystemResourceManager + 0x24) = systemCode;
  pSystemSecondaryStatus = (uint8_t *)(*(long long *)(ComparisonDataPointer + 8) + 0x10);
  *(uint8_t **)(ConfigurationDataPointer + 8) = pSystemSecondaryStatus;
  *(uint8_t *)(SystemResourceManager + 0x28) = *pSystemSecondaryStatus;
  localSystemPointer = *(long long *)(ComparisonDataPointer + 8);
  *(uint32_t **)(ConfigurationDataPointer + 8) = (uint32_t *)(localSystemPointer + 1);
  if (systemResult == 0) {
    pointerUnsignedC8 = &SystemResourceTemplatePrimary;
    pUnsignedStackFlagC0 = aUnsignedStackFlagB0;
    systemDataBuffer = 0;
    aUnsignedStackFlagB0[0] = 0;
    resourceAllocationContext = **(uint **)(ConfigurationDataPointer + 8);
    SystemDataPointer = *(uint **)(ConfigurationDataPointer + 8) + 1;
    *(uint **)(ConfigurationDataPointer + 8) = SystemDataPointer;
    if (resourceAllocationContext != 0) {
      ProcessSystemDataPointer(&pointerUnsignedC8,SystemDataPointer,resourceAllocationContext);
      *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + (ulong long)resourceAllocationContext;
    }
    pointerUnsignedC8 = &SystemMemoryAllocatorReference;
    SystemDataConfigurationPointer = *(uint32_t **)(ConfigurationDataPointer + 8);
  }
  else {
    ThreadContextFlag = *(uint32_t *)(localSystemPointer + 5);
    SystemOperationFlags = *(uint32_t *)(localSystemPointer + 9);
    SystemOperationStatus1 = *(uint32_t *)(localSystemPointer + 0xd);
    *(uint32_t *)(SystemResourceManager + 8) = *(uint32_t *)(localSystemPointer + 1);
    *(uint32_t *)(SystemResourceManager + 0xc) = ThreadContextFlag;
    *(uint32_t *)(SystemResourceManager + 0x10) = SystemOperationFlags;
    *(uint32_t *)(SystemResourceManager + 0x14) = SystemOperationStatus1;
    *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + 0x10;
    SystemDataConfigurationPointer = *(uint32_t **)(ConfigurationDataPointer + 8);
  }
  *(uint32_t *)(SystemResourceManager + 0x2c) = *SystemDataConfigurationPointer;
  SystemDataConfigurationPointer = (uint32_t *)(*(long long *)(ComparisonDataPointer + 8) + 4);
  *(uint32_t **)(ConfigurationDataPointer + 8) = SystemDataConfigurationPointer;
  *(uint32_t *)(SystemResourceManager + 0x30) = *SystemDataConfigurationPointer;
  SystemDataConfigurationPointer = (uint32_t *)(*(long long *)(ComparisonDataPointer + 8) + 4);
  *(uint32_t **)(ConfigurationDataPointer + 8) = SystemDataConfigurationPointer;
  *(uint32_t *)(SystemResourceManager + 0x34) = *SystemDataConfigurationPointer;
  *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + 4;
    ValidateSystemChecksum(EncryptionKeyValue ^ (ulong long)aMemoryBufferAddress);
}




/**
 * @brief 系统数据表创建和配置函数
 * 
 * 该函数负责创建和配置系统数据表，包括：
 * - 分配数据表内存
 * - 初始化数据表结构
 * - 设置数据表参数
 * - 配置数据表属性
 * 
 * @param SystemResourceManager 系统资源指针，用于数据表创建
 * @param ConfigurationDataPointer 配置参数，包含数据表的配置信息
 * @return 返回创建的数据表指针
 * @note 此函数用于系统数据表的动态创建和配置
 * @warning 调用此函数后需要正确释放返回的数据表
 */
void* * CreateAndConfigureSystemDataTable(void* SystemResourceManager, long long ConfigurationParameter)

{
  void* SystemOperationStatus;
  void** SystemDataTable;
  
  SystemHashEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x38,8,3,InvalidHandleValue);
  *SystemHashEntryPointer = &SystemResourceManagerDataTableA;
  *SystemHashEntryPointer = &SystemResourceManagerDataTableB;
  *(void* *)((long long)SystemHashEntryPointer + 0x2c) = 0;
  *(uint32_t *)((long long)SystemHashEntryPointer + 0x34) = 0;
  *(uint8_t *)(SystemHashEntryPointer + 5) = 0;
  SystemHashEntryPointer[3] = 0;
  SystemHashEntryPointer[4] = 0;
  SystemHashEntryPointer[1] = 0;
  SystemHashEntryPointer[2] = 0;
  if (ConfigurationDataPointer != 0) {
    SystemOperationStatus = *(void* *)(ConfigurationDataPointer + 0x10);
    SystemHashEntryPointer[1] = *(void* *)(ConfigurationDataPointer + 8);
    SystemHashEntryPointer[2] = SystemOperationStatus;
    SystemOperationStatus = *(void* *)(ConfigurationDataPointer + 0x20);
    SystemHashEntryPointer[3] = *(void* *)(ConfigurationDataPointer + 0x18);
    SystemHashEntryPointer[4] = SystemOperationStatus;
    *(uint8_t *)(SystemHashEntryPointer + 5) = *(uint8_t *)(ConfigurationDataPointer + 0x28);
    *(uint32_t *)((long long)SystemHashEntryPointer + 0x2c) = *(uint32_t *)(ConfigurationDataPointer + 0x2c);
    *(uint32_t *)(SystemHashEntryPointer + 6) = *(uint32_t *)(ConfigurationDataPointer + 0x30);
    *(uint32_t *)((long long)SystemHashEntryPointer + 0x34) = *(uint32_t *)(ConfigurationDataPointer + 0x34);
  }
  return SystemHashEntryPointer;
}





/**
 * @brief 初始化系统资源缓冲区
 * 
 * 该函数负责初始化系统资源管理器的缓冲区，包括内存分配和数据结构设置
 * 用于系统资源管理器的初始化和配置
 * 
 * @param SystemResourceManager 系统资源管理器，包含系统资源的相关信息
 * @return 无返回值
 * 
 *FUN_1800746c0：InitializeSystemResourceBuffer
 */
void InitializeSystemResourceBuffer(long long SystemResourceManager)

{
  long long resourceDataIndex;
  int systemResult;
  long long *SystemResourceOffsetPointer;
  long long* SystemMemoryPointer;
  void* SystemThreadContext;
  
  if (*(char *)(*(long long *)(SystemResourceManager + 0x20) + 0x28) == '\0') {
    SystemResourceOffsetPointer = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,0x10,4,InvalidHandleValue);
    *SystemResourceOffsetPointer = (long long)&SystemMemoryTemplateA;
    *SystemResourceOffsetPointer = (long long)&SystemMemoryTemplateB;
    *(uint32_t *)(SystemResourceOffsetPointer + 1) = 0;
    *SystemResourceOffsetPointer = (long long)&SystemResourceDataTableA;
    SystemResourceOffsetPointer[2] = (long long)&SystemMemoryAllocatorReference;
    SystemResourceOffsetPointer[3] = 0;
    *(uint32_t *)(SystemResourceOffsetPointer + 4) = 0;
    SystemResourceOffsetPointer[2] = (long long)&SystemResourceTemplatePrimary;
    SystemResourceOffsetPointer[3] = (long long)(SystemResourceOffsetPointer + 5);
    *(uint32_t *)(SystemResourceOffsetPointer + 4) = 0;
    *(uint8_t *)(SystemResourceOffsetPointer + 5) = 0;
    *(uint8_t *)((long long)SystemResourceOffsetPointer + 0xb2) = 0;
    *(uint32_t *)(SystemResourceOffsetPointer + 1) = 0;
    *(void*2 *)(SystemResourceOffsetPointer + 0x16) = 0;
    SystemResourceOffsetPointer[0x15] = 0;
    *SystemResourceOffsetPointer = (long long)&SystemResourceDataTableB;
    SystemResourceOffsetPointer[0x15] = 0;
    *(uint8_t *)(SystemResourceOffsetPointer + 0x17) = 0;
    (**(code **)(*SystemResourceOffsetPointer + 0x28))(SystemResourceOffsetPointer);
    SystemCalculatedBufferAddress = *(long long **)(SystemResourceManager + 0xb0);
    *(long long **)(SystemResourceManager + 0xb0) = SystemResourceOffsetPointer;
    if (SystemCalculatedBufferAddress != (long long *)0x0) {
      (**(code **)(*SystemCalculatedBufferAddress + 0x38))();
    }
    *(long long *)(*(long long *)(SystemResourceManager + 0xb0) + 0xa8) = SystemResourceManager;
    SystemCalculatedBufferAddress = (long long *)(*(long long *)(SystemResourceManager + 0xb0) + 0x10);
    SystemThreadContext = &SystemStringTemplate;
    if (*(void* **)(SystemResourceManager + 0x70) != (void* *)0x0) {
      SystemThreadContext = *(void* **)(SystemResourceManager + 0x70);
    }
    (**(code **)(*SystemCalculatedBufferAddress + 0x10))(SystemCalculatedBufferAddress,SystemThreadContext);
    *(uint8_t *)(*(long long *)(SystemResourceManager + 0xb0) + 0xb1) = 1;
    resourceDataIndex = SystemInputManagerPointer;
    SystemCalculatedBufferAddress = *(long long **)(SystemResourceManager + 0xb0);
    systemResult = (**(code **)(*SystemCalculatedBufferAddress + 0x60))(SystemCalculatedBufferAddress);
    *(uint8_t *)((long long)SystemCalculatedBufferAddress + 0xb2) = 1;
    CalculateSystemMemoryAddress((long long)systemResult * 0x98 + resourceDataIndex + 8,SystemCalculatedBufferAddress);
  }
  return;
}




/**
 * @brief 释放系统资源缓冲区
 * 
 * 该函数负责释放系统资源管理器的缓冲区，清理内存和资源
 * 用于系统资源的清理和回收
 * 
 * @param SystemResourceManager 系统资源管理器，包含系统资源的相关信息
 * @return 无返回值
 * 
 *FUN_180074840：ReleaseSystemResourceBuffer
 */
void ReleaseSystemResourceBuffer(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long **pSecondaryResourcePointer;
  
  if (*(long long *)(SystemResourceManager + 0xb0) != 0) {
    *(void* *)(*(long long *)(SystemResourceManager + 0xb0) + 0xa8) = 0;
    pSecondaryResourcePointer = &PrimaryResourcePointer;
    PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0xb0);
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x28))();
    }
    ReleaseSystemMemoryBuffer();
    pSecondaryResourcePointer = *(long long ***)(SystemResourceManager + 0xb0);
    *(void* *)(SystemResourceManager + 0xb0) = 0;
    if (pSecondaryResourcePointer != (long long **)0x0) {
                    0001800748c2. Too many branches
                          (**(code **)((long long)*pSecondaryResourcePointer + 0x38))();
      return;
    }
  }
  return;
}




/**
 * @brief 配置系统资源数据
 * 
 * 该函数负责配置系统资源数据，设置数据参数和属性
 * 用于系统资源的配置和管理
 * 
 * @param SystemResourceManager 系统资源管理器，包含系统资源的相关信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置的相关信息
 * @return 无返回值
 * 
 *FUN_1800748d0：ConfigureSystemResourceData
 */
void ConfigureSystemResourceData(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  uint8_t SystemOperationStatus;
  uint32_t resourceCreationFlags;
  uint32_t resourceAllocationContext;
  uint32_t resourceAddress;
  uint32_t *SystemThreadContext;
  uint8_t *resourceEntryPointer;
  
  SystemThreadContext = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemThreadContext) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemThreadContext + (4 - *ConfigurationDataPointer));
    SystemThreadContext = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemThreadContext = 1;
  SystemThreadContext = (uint32_t *)(ConfigurationDataPointer[1] + 4);
  ConfigurationDataPointer[1] = (long long)SystemThreadContext;
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemThreadContext) + ConfigurationDataPointer[2]) < 0x11) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemThreadContext + (0x10 - *ConfigurationDataPointer));
    SystemThreadContext = (uint32_t *)ConfigurationDataPointer[1];
  }
  resourceCreationFlags = *(uint32_t *)(SystemResourceManager + 0x1c);
  resourceAllocationContext = *(uint32_t *)(SystemResourceManager + 0x20);
  resourceAddress = *(uint32_t *)(SystemResourceManager + 0x24);
  *SystemThreadContext = *(uint32_t *)(SystemResourceManager + 0x18);
  SystemThreadContext[1] = resourceCreationFlags;
  SystemThreadContext[2] = resourceAllocationContext;
  SystemThreadContext[3] = resourceAddress;
  resourceEntryPointer = (uint8_t *)(ConfigurationDataPointer[1] + 0x10);
  ConfigurationDataPointer[1] = (long long)resourceEntryPointer;
  SystemOperationStatus = *(uint8_t *)(SystemResourceManager + 0x28);
  if ((ulong long)((*ConfigurationDataPointer - (long long)resourceEntryPointer) + ConfigurationDataPointer[2]) < 2) {
    CopySystemMemoryData(ConfigurationDataPointer,resourceEntryPointer + (1 - *ConfigurationDataPointer));
    resourceEntryPointer = (uint8_t *)ConfigurationDataPointer[1];
  }
  *resourceEntryPointer = SystemOperationStatus;
  SystemThreadContext = (uint32_t *)(ConfigurationDataPointer[1] + 1);
  ConfigurationDataPointer[1] = (long long)SystemThreadContext;
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemThreadContext) + ConfigurationDataPointer[2]) < 0x11) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemThreadContext + (0x10 - *ConfigurationDataPointer));
    SystemThreadContext = (uint32_t *)ConfigurationDataPointer[1];
  }
  resourceCreationFlags = *(uint32_t *)(SystemResourceManager + 0xc);
  resourceAllocationContext = *(uint32_t *)(SystemResourceManager + 0x10);
  resourceAddress = *(uint32_t *)(SystemResourceManager + 0x14);
  *SystemThreadContext = *(uint32_t *)(SystemResourceManager + 8);
  SystemThreadContext[1] = resourceCreationFlags;
  SystemThreadContext[2] = resourceAllocationContext;
  SystemThreadContext[3] = resourceAddress;
  SystemThreadContext = (uint32_t *)(ConfigurationDataPointer[1] + 0x10);
  ConfigurationDataPointer[1] = (long long)SystemThreadContext;
  resourceCreationFlags = *(uint32_t *)(SystemResourceManager + 0x2c);
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemThreadContext) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemThreadContext + (4 - *ConfigurationDataPointer));
    SystemThreadContext = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemThreadContext = resourceCreationFlags;
  SystemThreadContext = (uint32_t *)(ConfigurationDataPointer[1] + 4);
  ConfigurationDataPointer[1] = (long long)SystemThreadContext;
  resourceCreationFlags = *(uint32_t *)(SystemResourceManager + 0x30);
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemThreadContext) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemThreadContext + (4 - *ConfigurationDataPointer));
    SystemThreadContext = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemThreadContext = resourceCreationFlags;
  SystemThreadContext = (uint32_t *)(ConfigurationDataPointer[1] + 4);
  ConfigurationDataPointer[1] = (long long)SystemThreadContext;
  resourceCreationFlags = *(uint32_t *)(SystemResourceManager + 0x34);
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemThreadContext) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemThreadContext + (4 - *ConfigurationDataPointer));
    *(uint32_t *)ConfigurationDataPointer[1] = resourceCreationFlags;
  }
  else {
    *SystemThreadContext = resourceCreationFlags;
  }
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  return;
}




/**
 * @brief 处理系统资源池
 * 
 * 该函数负责处理系统资源池，管理资源的分配和释放
 * 用于系统资源池的管理和维护
 * 
 * @param SystemResourceManager 系统资源管理器，包含系统资源的相关信息
 * @return 无返回值
 * 
 *FUN_180074a80：ProcessSystemResourcePool
 */
void ProcessSystemResourcePool(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  
  PrimaryResourcePointer = (long long *)SystemResourceManager[1];
  resourcePoolPointer = (long long *)*SystemResourceManager;
  while( true ) {
    if (resourcePoolPointer == PrimaryResourcePointer) {
      if (*SystemResourceManager != 0) {
          SystemCleanupFunction();
      }
      return;
    }
    if (*(long long *)((long long)resourcePoolPointer + 0x12) != 0) {
        SystemCleanupFunction();
    }
    *(void* *)((long long)resourcePoolPointer + 0x12) = 0;
    if (*(long long *)((long long)resourcePoolPointer + 0x1a) != 0) break;
    *(void* *)((long long)resourcePoolPointer + 0x1a) = 0;
    if (*resourcePoolPointer != 0) {
        SystemCleanupFunction();
    }
    *resourcePoolPointer = 0;
    if (resourcePoolPointer[1] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[1] = 0;
    resourcePoolPointer = (long long *)((long long)resourcePoolPointer + 0x24);
  }
    SystemCleanupFunction();
}




/**
 * @brief 分配系统资源内存
 * 
 * 该函数负责分配系统资源内存，管理内存的分配和配置
 * 用于系统资源的内存分配和管理
 * 
 * @param SystemResourceManager 系统资源管理器，包含系统资源的相关信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置的相关信息
 * @return 无返回值
 * 
 *FUN_180074b30：AllocateSystemResourceMemory
 */
void AllocateSystemResourceMemory(long long* SystemResourceManager,ulong long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  ulong long resourceCreationFlags;
  long long *SystemResourceOffsetPointer;
  long long SystemBufferAddress;
  long long SystemTimeValue;
  
  PrimaryResourcePointer = (long long *)SystemResourceManager[1];
  localSystemPointer = *SystemResourceManager;
  resourceCreationFlags = ((long long)PrimaryResourcePointer - localSystemPointer) / 0x24;
  if (resourceCreationFlags < ConfigurationDataPointer) {
    SystemBufferAddress = ConfigurationDataPointer - resourceCreationFlags;
    ExpandSystemResourceManagerHashTable(SystemResourceManager,SystemBufferAddress,(long long)PrimaryResourcePointer - localSystemPointer,SystemBufferAddress,InvalidHandleValue);
  }
  else {
    SystemResourceOffsetPointer = (long long *)(ConfigurationDataPointer * 0x24 + localSystemPointer);
    if (SystemResourceOffsetPointer != PrimaryResourcePointer) {
      do {
        if (*(long long *)((long long)SystemResourceOffsetPointer + 0x12) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)((long long)SystemResourceOffsetPointer + 0x12) = 0;
        if (*(long long *)((long long)SystemResourceOffsetPointer + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void* *)((long long)SystemResourceOffsetPointer + 0x1a) = 0;
        if (*SystemResourceOffsetPointer != 0) {
            SystemCleanupFunction();
        }
        *SystemResourceOffsetPointer = 0;
        if (SystemResourceOffsetPointer[1] != 0) {
            SystemCleanupFunction();
        }
        SystemResourceOffsetPointer[1] = 0;
        SystemResourceOffsetPointer = (long long *)((long long)SystemResourceOffsetPointer + 0x24);
      } while (SystemResourceOffsetPointer != PrimaryResourcePointer);
      localSystemPointer = *SystemResourceManager;
    }
    SystemResourceManager[1] = ConfigurationDataPointer * 0x24 + localSystemPointer;
  }
  return;
}





/**
 * @brief 扩展系统资源管理器的哈希表容量
 * 
 * 该函数负责扩展系统资源管理器的哈希表容量，重新分配内存并复制现有数据
 * 用于系统资源管理器的动态扩容操作
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针
 * @param ConfigurationDataPointer 配置数据指针，指定要扩展的容量
 * @return 无返回值
 * 
 *FUN_180074c20：ExpandSystemResourceManagerHashTable
 */
void ExpandSystemResourceManagerHashTable(void** SystemResourceManager, unsigned long long ConfigurationDataPointer)
{
  long long* PrimaryResourcePointer;
  long long* ResourcePoolPointer;
  void** SystemHashNodeData;
  long long* SystemMemoryPointer;
  long long* LocalSystemPointer;
  unsigned long long HashValue;
  void** SystemCurrentNode;
  long long LocalMemoryAddress;
  unsigned long long NewHashTableSize;
  
  void** hashTableNode = (void**)SystemResourceManager[1];
  if (((unsigned long long)((SystemResourceManager[2] - (long long)hashTableNode) / 0x24)) < ConfigurationDataPointer) {
    SystemHashNodeData = (void**)*SystemResourceManager;
    LocalMemoryAddress = ((long long)hashTableNode - (long long)SystemHashNodeData) / 0x24;
    NewHashTableSize = LocalMemoryAddress * 2;
    if (LocalMemoryAddress == 0) {
      NewHashTableSize = 1;
    }
    if (NewHashTableSize < LocalMemoryAddress + ConfigurationDataPointer) {
      NewHashTableSize = LocalMemoryAddress + ConfigurationDataPointer;
    }
    PrimaryResourcePointer = (long long*)0x0;
    if (NewHashTableSize != 0) {
      PrimaryResourcePointer = (long long*)
               CreateSystemThreadObject(SystemMemoryPoolTemplate, NewHashTableSize * 0x24, *(uint8_t*)(SystemResourceManager + 3), hashTableNode,
                             0xfffffffffffffffe);
      hashTableNode = (void**)SystemResourceManager[1];
      SystemHashNodeData = (void**)*SystemResourceManager;
    }
    ResourcePoolPointer = PrimaryResourcePointer;
    if (SystemHashNodeData != hashTableNode) {
      LocalMemoryAddress = (long long)PrimaryResourcePointer - (long long)SystemHashNodeData;
      long long* BufferBaseAddress = (long long*)((long long)SystemHashNodeData + 0x1a);
      do {
        *(void**)(LocalMemoryAddress + -10 + (long long)BufferBaseAddress) = *(void**)((long long)BufferBaseAddress + -10);
        if (*(long long*)((long long)BufferBaseAddress + -0x12) == 0) {
          *(void**)(LocalMemoryAddress + -0x12 + (long long)BufferBaseAddress) = 0;
        }
        else {
          *(long long*)(LocalMemoryAddress + -0x12 + (long long)BufferBaseAddress) = *(long long*)((long long)BufferBaseAddress + -0x12);
          *(void**)((long long)BufferBaseAddress + -0x12) = 0;
        }
        if (*(long long*)((long long)BufferBaseAddress + -0x1a) == 0) {
          *ResourcePoolPointer = 0;
        }
        else {
          *ResourcePoolPointer = *(long long*)((long long)BufferBaseAddress + -0x1a);
          *(void**)((long long)BufferBaseAddress + -0x1a) = 0;
        }
        *(void**)((long long)BufferBaseAddress + -10) = 0;
        *(short*)(LocalMemoryAddress + 8 + (long long)BufferBaseAddress) = (short)BufferBaseAddress[1];
        if (*BufferBaseAddress == 0) {
          *(void**)((long long)BufferBaseAddress + LocalMemoryAddress) = 0;
        }
        else {
          *(long long*)((long long)BufferBaseAddress + LocalMemoryAddress) = *BufferBaseAddress;
          *BufferBaseAddress = 0;
        }
        if (BufferBaseAddress[-1] == 0) {
          *(void**)(LocalMemoryAddress + -8 + (long long)BufferBaseAddress) = 0;
        }
        else {
          *(long long*)(LocalMemoryAddress + -8 + (long long)BufferBaseAddress) = BufferBaseAddress[-1];
          BufferBaseAddress[-1] = 0;
        }
        *(void**)(BufferBaseAddress + 1) = 0;
        ResourcePoolPointer = (long long*)((long long)ResourcePoolPointer + 0x24);
        SystemHashNodeData = (void**)((long long)BufferBaseAddress + 10);
        BufferBaseAddress = (long long*)((long long)BufferBaseAddress + 0x24);
      } while (SystemHashNodeData != hashTableNode);
    }
    if (ConfigurationDataPointer != 0) {
      hashTableNode = (void**)((long long)ResourcePoolPointer + 0x1a);
      HashValue = ConfigurationDataPointer;
      do {
        hashTableNode[-1] = 0;
        *hashTableNode = 0;
        *(void**)(hashTableNode + 1) = 0;
        *(void**)((long long)hashTableNode + -10) = 0;
        *(void**)((long long)hashTableNode + -0x1a) = 0;
        *(void**)((long long)hashTableNode + -0x12) = 0;
        *(void**)(hashTableNode + 1) = 0;
        hashTableNode[-1] = 0;
        *hashTableNode = 0;
        hashTableNode = (void**)((long long)hashTableNode + 0x24);
        HashValue = HashValue - 1;
      } while (HashValue != 0);
    }
    long long* BufferBaseAddress = (long long*)SystemResourceManager[1];
    LocalSystemPointer = (long long**)*SystemResourceManager;
    if (LocalSystemPointer != (long long**)BufferBaseAddress) {
      do {
        if (*(long long*)((long long)LocalSystemPointer + 0x12) != 0) {
            SystemCleanupFunction();
        }
        *(void**)((long long)LocalSystemPointer + 0x12) = 0;
        if (*(long long*)((long long)LocalSystemPointer + 0x1a) != 0) {
            SystemCleanupFunction();
        }
        *(void**)((long long)LocalSystemPointer + 0x1a) = 0;
        if (*LocalSystemPointer != 0) {
            SystemCleanupFunction();
        }
        *LocalSystemPointer = 0;
        if (LocalSystemPointer[1] != 0) {
            SystemCleanupFunction();
        }
        LocalSystemPointer[1] = 0;
        LocalSystemPointer = (long long**)((long long)LocalSystemPointer + 0x24);
      } while (LocalSystemPointer != (long long**)BufferBaseAddress);
      LocalSystemPointer = (long long**)*SystemResourceManager;
    }
    if (LocalSystemPointer != (long long**)0x0) {
        SystemCleanupFunction((void*)LocalSystemPointer);
    }
    *SystemResourceManager = (void**)PrimaryResourcePointer;
    SystemResourceManager[1] = (long long)ResourcePoolPointer + ConfigurationDataPointer * 0x24;
    SystemResourceManager[2] = (long long)PrimaryResourcePointer + NewHashTableSize * 0x24;
  }
  else {
    if (ConfigurationDataPointer != 0) {
      SystemHashNodeData = (void**)((long long)hashTableNode + 0x1a);
      NewHashTableSize = ConfigurationDataPointer;
      do {
        hashTableNode[1] = 0;
        hashTableNode[2] = 0;
        hashTableNode[3] = 0;
        *(uint32_t*)(hashTableNode + 4) = 0;
        *(void**)((long long)SystemHashNodeData + -10) = 0;
        *hashTableNode = 0;
        *(void**)((long long)SystemHashNodeData + -0x12) = 0;
        *(void**)(SystemHashNodeData + 1) = 0;
        SystemHashNodeData[-1] = 0;
        *SystemHashNodeData = 0;
        hashTableNode = (void**)((long long)hashTableNode + 0x24);
        SystemHashNodeData = (void**)((long long)SystemHashNodeData + 0x24);
        NewHashTableSize = NewHashTableSize - 1;
      } while (NewHashTableSize != 0);
      hashTableNode = (void**)SystemResourceManager[1];
    }
    SystemResourceManager[1] = (long long)hashTableNode + ConfigurationDataPointer * 0x24;
  }
  return;
}




/**
 * @brief 清理系统资源管理器
 * 
 * 该函数负责清理系统资源管理器，释放相关资源并重置状态
 * 用于系统资源的清理和释放操作
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @return 无返回值
 * 
 *FUN_180074ed0：CleanupSystemResourceManager
 */
void CleanupSystemResourceManager(long long* SystemResourceManager)
{
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = 0;
  if (SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET] = 0;
  return;
}



/**
 * @brief 初始化系统资源管理器模板
 * 
 * 该函数负责初始化系统资源管理器模板，设置基本参数和配置
 * 用于系统资源管理器的初始化操作
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 系统资源管理器指针
 * 
 *FUN_180074f20：InitializeSystemResourceManagerTemplate
 */
void** InitializeSystemResourceManagerTemplate(void** SystemResourceManager, unsigned long long ConfigurationDataPointer, void* AdditionalParameter, void* ConfigurationFlag)
{
  *SystemResourceManager = &SystemResourceManagerTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager, 0x38, AdditionalParameter, ConfigurationFlag, 0xfffffffffffffffe);
  }
  return SystemResourceManager;
}



/**
 * @brief 释放并重置系统资源管理器
 * 
 * 该函数负责释放系统资源管理器并重置其状态
 * 用于系统资源管理器的清理和重置操作
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源管理器指针
 * 
 *FUN_180074f70：ReleaseAndResetSystemResourceManager
 */
void** ReleaseAndResetSystemResourceManager(void** SystemResourceManager, unsigned long long ConfigurationDataPointer)
{
  *SystemResourceManager = &SystemResourceManagerTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager, 8);
  }
  return SystemResourceManager;
}



/**
 * @brief 配置系统资源数据结构
 * 
 * 该函数负责配置系统资源数据结构，设置内存分配器和资源模板
 * 用于系统资源数据结构的初始化和配置
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针的指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 配置数据指针
 * 
 *FUN_180074fb0：ConfigureSystemResourceDataStructure
 */
void** ConfigureSystemResourceDataStructure(void* SystemResourceManager, void** ConfigurationDataPointer, void* AdditionalParameter, void* ConfigurationFlag)
{
  *ConfigurationDataPointer = &SystemMemoryAllocatorReference;
  ConfigurationDataPointer[1] = 0;
  *(uint32_t*)(ConfigurationDataPointer + 2) = 0;
  *ConfigurationDataPointer = &SystemResourceTemplatePrimary;
  ConfigurationDataPointer[1] = ConfigurationDataPointer + 3;
  *(uint8_t*)(ConfigurationDataPointer + 3) = 0;
  *(uint32_t*)(ConfigurationDataPointer + 2) = 7;
  strcpy_s(ConfigurationDataPointer[1], 0x80, &SystemStringTemplateA, ConfigurationFlag, 0, 0xfffffffffffffffe);
  return ConfigurationDataPointer;
}




/**
 * @brief 初始化系统资源管理器扩展版本
 * 
 * 该函数负责初始化系统资源管理器的扩展版本，设置各种参数和配置
 * 用于系统资源管理器的完整初始化操作
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @return 系统资源管理器指针
 * 
 *FUN_180075030：InitializeSystemResourceManagerEx
 */
void** InitializeSystemResourceManagerEx(void** SystemResourceManager, char ConfigurationDataPointer, char AdditionalParameter)
{
  long long* PrimaryResourcePointer;
  uint8_t IsSystemActive;
  long long* ResourceDataOffset;
  long long* SystemMemoryPointer;
  
  *SystemResourceManager = &SystemMemoryTemplateA;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *SystemResourceManager = &SystemResourceDataTableA;
  SystemResourceManager[2] = &SystemMemoryAllocatorReference;
  SystemResourceManager[3] = 0;
  *(uint32_t *)(SystemResourceManager + 4) = 0;
  SystemResourceManager[2] = &SystemResourceTemplatePrimary;
  SystemResourceManager[3] = SystemResourceManager + 5;
  *(uint32_t *)(SystemResourceManager + 4) = 0;
  *(uint8_t *)(SystemResourceManager + 5) = 0;
  *(uint8_t *)((long long)SystemResourceManager + 0xb2) = 0;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *(void*2 *)(SystemResourceManager + 0x16) = 0;
  SystemResourceManager[0x15] = 0;
  *SystemResourceManager = &SystemResourceDataTableC;
  InitializeResourceManager(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET);
  *(uint32_t *)(SystemResourceManager + 0x1e) = 0;
  LOCK();
  *(uint32_t *)(SystemResourceManager + 0x1d) = 0;
  UNLOCK();
  LOCK();
  *(uint8_t *)((long long)SystemResourceManager + 0xec) = 0;
  UNLOCK();
  *(uint32_t *)(SystemResourceManager + 0x1e) = 0;
  SystemResourceManager[0x23] = 0;
  SystemResourceManager[0x36] = 0;
  SystemResourceManager[0x37] = 0;
  SystemResourceManager[0x38] = 0;
  SystemResourceManager[0x3e] = SystemResourceManager;
  SystemResourceManager[0x3d] = 0;
  SystemResourceManager[0x42] = 0;
  SystemResourceManager[0x43] = 0;
  SystemResourceManager[0x44] = 0;
  SystemResourceManager[0x45] = 0;
  *(uint32_t *)(SystemResourceManager + 0x46) = 3;
  SystemResourceManager[0x4d] = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x2a4) = 0;
  *(void* *)((long long)SystemResourceManager + 0x274) = 0;
  *(void* *)((long long)SystemResourceManager + 0x27c) = 0;
  *(void* *)((long long)SystemResourceManager + 0x284) = 0;
  *(void* *)((long long)SystemResourceManager + 0x28c) = 0;
  *(void* *)((long long)SystemResourceManager + 0x294) = 0;
  *(void* *)((long long)SystemResourceManager + 0x29c) = 0;
  *(void*2 *)(SystemResourceManager + 0x5d) = 0;
  SystemResourceManager[0x5c] = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x2ec) = 0xffffffff;
  *(void*2 *)(SystemResourceManager + 0x5f) = 0;
  SystemResourceManager[0x5e] = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x2fc) = 0xffffffff;
  *(byte *)((long long)SystemResourceManager + 0xfd) = *(byte *)((long long)SystemResourceManager + 0xfd) & 0xfb;
  *(byte *)((long long)SystemResourceManager + 0xfd) = *(byte *)((long long)SystemResourceManager + 0xfd) | ConfigurationDataPointer << 2;
  SystemResourceManager[0x15] = 0;
  *(uint32_t *)(SystemResourceManager + 0x17) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0xbc) = 0;
  *(uint32_t *)(SystemResourceManager + 0x18) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0xc4) = 0;
  *(byte *)((long long)SystemResourceManager + 0xfe) = *(byte *)((long long)SystemResourceManager + 0xfe) & 0xfe;
  *(uint8_t *)((long long)SystemResourceManager + 0xfc) = 0;
  long long* BufferBaseAddress = (long long*)SystemResourceManager[0x36];
  SystemResourceManager[0x36] = 0;
  if (BufferBaseAddress != (long long*)0x0) {
    (**(code **)(*BufferBaseAddress + 0x38))();
  }
  SystemResourceManager[0x39] = 0;
  SystemResourceManager[0x3c] = 0;
  if (AdditionalParameter == '\0') {
    *(uint8_t*)((long long)SystemResourceManager + 0xfd) = *(uint8_t*)((long long)SystemResourceManager + 0xfd) & 0xdf;
  }
  else {
    *(uint8_t*)((long long)SystemResourceManager + 0xfd) = *(uint8_t*)((long long)SystemResourceManager + 0xfd) | 0x20;
  }
  *(uint8_t*)((long long)SystemResourceManager + 0xfd) = *(uint8_t*)((long long)SystemResourceManager + 0xfd) & 0xbf;
  *(uint8_t*)((long long)SystemResourceManager + 0xff) = 1;
  BufferBaseAddress = (long long*)SystemResourceManager[0x37];
  SystemResourceManager[0x37] = 0;
  if (BufferBaseAddress != (long long*)0x0) {
    (**(code **)(*BufferBaseAddress + 0x38))();
  }
  *(uint8_t*)((long long)SystemResourceManager + 0xf4) = 0;
  *(uint32_t*)(SystemResourceManager + 0x20) = 0;
  *(uint8_t*)((long long)SystemResourceManager + 0xf7) = 0;
  *(uint8_t*)((long long)SystemResourceManager + 0xfd) = *(uint8_t*)((long long)SystemResourceManager + 0xfd) & 0x6d;
  ResourceDataOffset = (long long*)SystemResourceManager[0x38];
  SystemResourceManager[0x38] = 0;
  if (ResourceDataOffset != (long long*)0x0) {
    (**(code **)(*ResourceDataOffset + 0x38))();
  }
  IsSystemActive = *(uint8_t*)((long long)SystemResourceManager + 0xfd) & 0xf7;
  *(uint8_t*)((long long)SystemResourceManager + 0xfd) = IsSystemActive;
  SystemResourceManager[0x47] = 0x3f8000003f800000;
  SystemResourceManager[0x48] = 0x3f8000003f800000;
  SystemResourceManager[0x49] = 0x3f8000003f800000;
  SystemResourceManager[0x4a] = 0x3f8000003f800000;
  *(uint32_t *)(SystemResourceManager + 0x4c) = 0x3f800000;
  SystemResourceManager[0x24] = 0x3f800000;
  SystemResourceManager[0x25] = 0;
  SystemResourceManager[0x26] = 0x3f80000000000000;
  SystemResourceManager[0x27] = 0;
  SystemResourceManager[0x28] = 0;
  SystemResourceManager[0x29] = 0x3f800000;
  SystemResourceManager[0x2a] = 0;
  SystemResourceManager[0x2b] = 0x3f80000000000000;
  SystemResourceManager[0x2c] = 0x3f800000;
  SystemResourceManager[0x2d] = 0;
  SystemResourceManager[0x2e] = 0x3f80000000000000;
  SystemResourceManager[0x2f] = 0;
  SystemResourceManager[0x30] = 0;
  SystemResourceManager[0x31] = 0x3f800000;
  SystemResourceManager[0x32] = 0;
  SystemResourceManager[0x33] = 0x3f80000000000000;
  *(byte *)((long long)SystemResourceManager + 0xfd) = isSystemActive | 1;
  *(byte *)((long long)SystemResourceManager + 0xfe) = *(byte *)((long long)SystemResourceManager + 0xfe) | 2;
  *(uint32_t *)(SystemResourceManager + 0x4e) = 0x21;
  *(uint32_t *)((long long)SystemResourceManager + 0x104) = 0x80;
  *(uint8_t *)((long long)SystemResourceManager + 0xf6) = 0;
  *(void*2 *)((long long)SystemResourceManager + 0xfa) = 0;
  *(void* *)((long long)SystemResourceManager + 0x204) = 0;
  SystemResourceManager[0x3f] = 0;
  *(uint32_t *)(SystemResourceManager + 0x40) = 0;
  *(uint32_t *)(SystemResourceManager + 0x5b) = 0xbf800000;
  *(uint32_t *)((long long)SystemResourceManager + 0x2dc) = 0xbf800000;
  SystemResourceManager[0x55] = 0;
  SystemResourceManager[0x56] = 0;
  SystemResourceManager[0x57] = 0;
  SystemResourceManager[0x58] = 0;
  *(uint32_t *)(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0xcc) = 0;
  *(uint32_t *)(SystemResourceManager + 0x1a) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0xd4) = 0x7f7fffff;
  *(uint32_t *)(SystemResourceManager + 0x1b) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0xdc) = 0;
  *(uint32_t *)(SystemResourceManager + 0x1c) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0xe4) = 0x7f7fffff;
  *(uint32_t *)(SystemResourceManager + 0x21) = 0xffffffff;
  SystemResourceManager[0x5a] = 0;
  if (ConfigurationDataPointer == '\0') {
    PrimaryResourcePointer = (long long*)SystemResourceManager[0x42];
    SystemResourceManager[0x42] = 0;
    if (PrimaryResourcePointer != (long long*)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))(PrimaryResourcePointer, 0);
    }
  }
  *(uint8_t*)(SystemResourceManager + 0x1f) = 0;
  *(uint32_t*)(SystemResourceManager + 0x34) = 0x3f800000;
  *(uint32_t*)((long long)SystemResourceManager + 0x1a4) = 0x3f800000;
  *(uint32_t*)(SystemResourceManager + 0x35) = 0x3f800000;
  *(uint32_t*)((long long)SystemResourceManager + 0x1ac) = 0x7f7fffff;
  *(uint32_t*)(SystemResourceManager + 0x3a) = 0xffffffff;
  ResourceDataOffset = (long long*)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate, 0x70, 8, 9, BufferBaseAddress, ResourceDataOffset);
  *ResourceDataOffset = (long long)&SystemMemoryTemplateA;
  *ResourceDataOffset = (long long)&SystemMemoryTemplateB;
  *(uint32_t*)(ResourceDataOffset + 1) = 0;
  *ResourceDataOffset = (long long)&SystemResourceDataTableD;
  ResourceDataOffset[4] = (long long)&SystemMemoryAllocatorReference;
  ResourceDataOffset[5] = 0;
  *(uint32_t*)(ResourceDataOffset + 6) = 0;
  ResourceDataOffset[4] = (long long)&SystemGlobalDataReference;
  ResourceDataOffset[7] = 0;
  ResourceDataOffset[5] = 0;
  *(uint32_t*)(ResourceDataOffset + 6) = 0;
  *(uint32_t*)(ResourceDataOffset + 8) = 0xffffffff;
  *(uint32_t*)((long long)ResourceDataOffset + 0x44) = 0x3f000000;
  *(uint32_t*)(ResourceDataOffset + 9) = 0x3f000000;
  *(uint32_t*)((long long)ResourceDataOffset + 0x4c) = 0x3f4ccccd;
  *(uint32_t*)(ResourceDataOffset + 10) = 0x3f000000;
  *(uint32_t*)((long long)ResourceDataOffset + 0x54) = 0x3e99999a;
  *(uint32_t*)(ResourceDataOffset + 0xb) = 0x411cf5c3;
  *(uint32_t*)((long long)ResourceDataOffset + 0x5c) = 0x3f800000;
  *(uint32_t*)(ResourceDataOffset + 0xc) = 0xbf800000;
  *(uint32_t*)((long long)ResourceDataOffset + 100) = 0x3f800000;
  *(uint32_t*)(ResourceDataOffset + 0xd) = 0x3f000000;
  *(uint32_t*)((long long)ResourceDataOffset + 0x6c) = 0x3f800000;
  *(uint32_t*)(ResourceDataOffset + 2) = 0x3f800000;
  *(uint32_t*)((long long)ResourceDataOffset + 0x14) = 0x78;
  *(void**)(ResourceDataOffset + 3) = 0;
  *(uint8_t*)((long long)ResourceDataOffset + 0x1a) = 0;
  (**(code **)(*ResourceDataOffset + 0x28))(ResourceDataOffset);
  BufferBaseAddress = (long long*)SystemResourceManager[0x4d];
  SystemResourceManager[0x4d] = ResourceDataOffset;
  if (BufferBaseAddress != (long long*)0x0) {
    (**(code **)(*BufferBaseAddress + 0x38))();
  }
  *(uint8_t*)((long long)SystemResourceManager + 0xfe) = *(uint8_t*)((long long)SystemResourceManager + 0xfe) & 0xf3;
  SystemResourceManager[0x3b] = 0;
  LOCK();
  *(uint8_t*)((long long)SystemResourceManager + 0xf9) = 0;
  UNLOCK();
  SystemResourceManager[0x59] = 0;
  *(uint8_t *)((long long)SystemResourceManager + 0xf5) = 0;
  SystemResourceManager[0x4b] = 0;
  return SystemResourceManager;
}



/**
 * @brief 释放系统资源并清理内存
 * 
 * 该函数负责释放系统资源并清理相关内存
 * 用于系统资源的释放和内存清理操作
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 系统资源管理器指针
 * 
 *FUN_180075580：ReleaseSystemResourcesAndCleanupMemory
 */
void* ReleaseSystemResourcesAndCleanupMemory(void* SystemResourceManager, unsigned long long ConfigurationDataPointer)
{
  InitializeSystemResourceManager();
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager, 0x300);
  }
  return SystemResourceManager;
}



/**
 * @brief 系统资源处理和状态管理器
 * 
 * 该函数负责处理系统资源和管理操作状态，包括：
 * - 设置系统内存和资源分配
 * - 处理系统配置参数
 * - 管理资源操作的执行状态
 * - 清理临时资源和状态标志
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 操作状态码，成功返回0，失败返回非0值
 * 
 * 原始函数名：FUN_1800755c0
 */
uint8_t ProcessSystemResourceAndManageStatus(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  uint8_t SystemOperationStatus;
  void* CreationFlags;
  void* *ResourcePointer;
  long long LocalStackOffset;
  
  CreationFlags = 0xfffffffffffffffe;
  SetupSystemMemory(&ResourcePointer);
  SystemOperationStatus = SearchSystemResource(SystemResourceManager + TRANSFORM_CONTEXT_OFFSET_218,&ResourcePointer,AdditionalParameter,ConfigurationFlag,CreationFlags);
  ResourcePointer = &SystemGlobalDataReference;
  if (LocalStackOffset != 0) {
      SystemCleanupFunction();
  }
  return SystemOperationStatus;
}



000180276fbd)


/**
 * @brief 处理系统资源管理器的数据配置
 * 
 * 该函数负责处理系统资源管理器的数据配置，包括资源分配、线程管理
 * 和哈希值计算等操作
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针的指针
 * @return 无返回值
 * 
 *FUN_180075630：ProcessSystemResourceManagerConfiguration
 */
void ProcessSystemResourceManagerConfiguration(long long SystemResourceManager, void** ConfigurationDataPointer)
{
  void** SystemDataPointer;
  long long* ResourcePoolPointer;
  long long ResourceDataOffset;
  uint32_t resourceAddress;
  uint32_t CurrentThreadId;
  uint32_t HashValue;
  void* SystemValue7;
  char CharacterInput;
  long long ResourceCounter;
  long long* PrimaryResourcePointer0;
  uint SystemOperationStatus;
  float RatioValue;
  float InterpolationFactor1;
  float InterpolationFactor2;
  float InterpolationFactor3;
  float InterpolationFactor4;
  float InterpolationFactor5;
  float MagnitudeSquared1;
  uint8_t StackBuffer[184];
  void* Value30;
  
  SystemOperationStatus = *(uint*)(SystemResourceManager + 0x100) & 0xfbffffff;
  *(uint*)(SystemResourceManager + 0x100) = SystemOperationStatus;
  Value30 = (void*)0x180075655;
  CharacterInput = GetCharacterInputFromConfiguration(ConfigurationDataPointer);
  if (CharacterInput == '\0') {
    *(uint*)(SystemResourceManager + 0x100) = SystemOperationStatus | 0x4000000;
  }
  SystemValue7 = ConfigurationDataPointer[1];
  ResourcePoolPointer = *(long long**)(SystemResourceManager + 0x1c8);
  *(void**)(SystemResourceManager + 0x120) = *ConfigurationDataPointer;
  *(void**)(SystemResourceManager + 0x128) = SystemValue7;
  SystemValue7 = ConfigurationDataPointer[3];
  *(void**)(SystemResourceManager + 0x130) = ConfigurationDataPointer[2];
  *(void**)(SystemResourceManager + 0x138) = SystemValue7;
  resourceAddress = *(uint32_t*)((long long)ConfigurationDataPointer + 0x24);
  CurrentThreadId = *(uint32_t*)(ConfigurationDataPointer + 5);
  HashValue = *(uint32_t*)((long long)ConfigurationDataPointer + 0x2c);
  *(uint32_t*)(SystemResourceManager + 0x140) = *(uint32_t*)(ConfigurationDataPointer + 4);
  *(uint32_t*)(SystemResourceManager + 0x144) = resourceAddress;
  *(uint32_t*)(SystemResourceManager + 0x148) = CurrentThreadId;
  *(uint32_t*)(SystemResourceManager + 0x14c) = HashValue;
  resourceAddress = *(uint32_t*)((long long)ConfigurationDataPointer + 0x34);
  CurrentThreadId = *(uint32_t*)(ConfigurationDataPointer + 7);
  HashValue = *(uint32_t*)((long long)ConfigurationDataPointer + 0x3c);
  *(uint32_t*)(SystemResourceManager + 0x150) = *(uint32_t*)(ConfigurationDataPointer + 6);
  *(uint32_t*)(SystemResourceManager + 0x154) = resourceAddress;
  *(uint32_t*)(SystemResourceManager + 0x158) = CurrentThreadId;
  *(uint32_t*)(SystemResourceManager + 0x15c) = HashValue;
  if (ResourcePoolPointer != (long long*)0x0) {
    if (*(code**)(*ResourcePoolPointer + 0x160) == (code*)&SystemCodeEntryPointA) {
      SystemDataPointer = (void**)((long long)ResourcePoolPointer + 0x214);
      *(uint32_t*)((long long)ResourcePoolPointer + 0x244) = 0;
      if (ResourcePoolPointer[8] - ResourcePoolPointer[7] >> 4 == 0) {
        *SystemDataPointer = 0;
        *(void**)((long long)ResourcePoolPointer + 0x21c) = 0;
        *(void**)((long long)ResourcePoolPointer + 0x224) = 0;
        *(void**)((long long)ResourcePoolPointer + 0x22c) = 0;
        *(void**)((long long)ResourcePoolPointer + 0x234) = 0;
        *(void**)((long long)ResourcePoolPointer + 0x23c) = 0;
      }
      else {
        *SystemDataPointer = (void**)0x4cbebc204cbebc20;
        *(void**)((long long)ResourcePoolPointer + 0x21c) = (void**)0x7f7fffff4cbebc20;
        *(uint32_t*)((long long)ResourcePoolPointer + 0x234) = 0;
        *(uint32_t*)(ResourcePoolPointer + 0x47) = 0;
        *(uint32_t*)((long long)ResourcePoolPointer + 0x23c) = 0;
        *(uint32_t*)(ResourcePoolPointer + 0x48) = 0x7f7fffff;
        *(void**)((long long)ResourcePoolPointer + 0x224) = (void**)0xccbebc20ccbebc20;
        *(void**)((long long)ResourcePoolPointer + 0x22c) = (void**)0x7f7fffffccbebc20;
        PrimaryResourcePointer0 = (long long*)ResourcePoolPointer[7];
        if (PrimaryResourcePointer0 < (long long*)ResourcePoolPointer[8]) {
          do {
            ResourceDataOffset = *PrimaryResourcePointer0;
            if (((*(uint8_t*)(ResourceDataOffset + 0x100) & 0x20) == 0) || (ResourcePoolPointer[5] == 0)) {
              ResourceCounter = ResourceDataOffset + 0x120;
            }
            else {
              ResourceCounter = CalculateResourceCount(ResourceDataOffset + 0x120, StackBuffer, ResourcePoolPointer[5] + 0x70);
            }
            ProcessResourceDataAllocation(SystemDataPointer, ResourceDataOffset + 0x274, ResourceCounter);
            PrimaryResourcePointer0 = PrimaryResourcePointer0 + 2;
          } while (PrimaryResourcePointer0 < (long long*)ResourcePoolPointer[8]);
        }
        if (((ResourcePoolPointer[8] - ResourcePoolPointer[7] & MAX_UNSIGNED_32_BITfffffff0U) == 0x10) &&
           (ResourceDataOffset = *(long long*)ResourcePoolPointer[7], (*(uint*)(ResourceDataOffset + 0x100) & 0x4000000) == 0)) {
          SystemValue7 = *(void**)(ResourceDataOffset + 0x29c);
          *(void**)((long long)ResourcePoolPointer + 0x234) = *(void**)(ResourceDataOffset + 0x294);
          *(void**)((long long)ResourcePoolPointer + 0x23c) = SystemValue7;
          *(uint32_t*)((long long)ResourcePoolPointer + 0x244) =
               *(uint32_t*)(*(long long*)ResourcePoolPointer[7] + 0x2a4);
        }
        else {
          CleanupSystemDataPointer(SystemDataPointer);
          PrimaryResourcePointer0 = (long long*)ResourcePoolPointer[7];
          InterpolationFactor2 = 0.0;
          if (PrimaryResourcePointer0 < (long long*)ResourcePoolPointer[8]) {
            do {
              ResourceDataOffset = *PrimaryResourcePointer0;
              if ((*(uint *)(ResourceDataOffset + 0x100) & 0x4000000) == 0) {
                scaleResult1 = *(float *)(ResourceDataOffset + 0x294);
                InterpolationParam4 = *(float *)(ResourceDataOffset + 0x298);
                InterpolationParam5 = *(float *)(ResourceDataOffset + 0x29c);
                RatioValue = *(float *)(ResourceDataOffset + 0x2a4);
              }
              else {
                RatioValue = *(float *)(ResourceDataOffset + 0x298);
                InterpolationParam5 = *(float *)(ResourceDataOffset + 0x294);
                InterpolationParam1 = *(float *)(ResourceDataOffset + 0x29c);
                scaleResult1 = *(float *)(ResourceDataOffset + 0x130) * RatioValue + *(float *)(ResourceDataOffset + 0x120) * InterpolationParam5 +
                         *(float *)(ResourceDataOffset + 0x140) * InterpolationParam1 + *(float *)(ResourceDataOffset + 0x150);
                InterpolationParam4 = *(float *)(ResourceDataOffset + 0x134) * RatioValue + *(float *)(ResourceDataOffset + 0x124) * InterpolationParam5 +
                         *(float *)(ResourceDataOffset + 0x144) * InterpolationParam1 + *(float *)(ResourceDataOffset + 0x154);
                InterpolationParam5 = *(float *)(ResourceDataOffset + 0x138) * RatioValue + *(float *)(ResourceDataOffset + 0x128) * InterpolationParam5 +
                         *(float *)(ResourceDataOffset + 0x148) * InterpolationParam1 + *(float *)(ResourceDataOffset + 0x158);
                RatioValue = *(float *)(ResourceDataOffset + 0x140) * *(float *)(ResourceDataOffset + 0x140) +
                         *(float *)(ResourceDataOffset + 0x144) * *(float *)(ResourceDataOffset + 0x144) +
                         *(float *)(ResourceDataOffset + 0x148) * *(float *)(ResourceDataOffset + 0x148);
                InterpolationParam1 = *(float *)(ResourceDataOffset + 0x130) * *(float *)(ResourceDataOffset + 0x130) +
                         *(float *)(ResourceDataOffset + 0x134) * *(float *)(ResourceDataOffset + 0x134) +
                         *(float *)(ResourceDataOffset + 0x138) * *(float *)(ResourceDataOffset + 0x138);
                MagnitudeSquared = *(float *)(ResourceDataOffset + 0x120) * *(float *)(ResourceDataOffset + 0x120) +
                         *(float *)(ResourceDataOffset + 0x124) * *(float *)(ResourceDataOffset + 0x124) +
                         *(float *)(ResourceDataOffset + 0x128) * *(float *)(ResourceDataOffset + 0x128);
                if (MagnitudeSquared <= InterpolationParam1) {
                  if (RatioValue <= InterpolationParam1) {
                    RatioValue = InterpolationParam1;
                  }
                }
                else if (RatioValue <= MagnitudeSquared) {
                  RatioValue = MagnitudeSquared;
                }
                if ((RatioValue - 1.0 <= -1e-06) || (1e-06 <= RatioValue - 1.0)) {
                  RatioValue = SQRT(RatioValue) * *(float *)(ResourceDataOffset + 0x2a4);
                }
                else {
                  RatioValue = *(float *)(ResourceDataOffset + 0x2a4) * 1.0;
                }
              }
              InterpolationParam5 = *(float *)((long long)resourcePoolPointer + 0x23c) - InterpolationParam5;
              scaleResult1 = *(float *)((long long)resourcePoolPointer + 0x234) - InterpolationParam3;
              InterpolationParam4 = (*(float *)(resourcePoolPointer + 0x47) - InterpolationParam4) * (*(float *)(resourcePoolPointer + 0x47) - InterpolationParam4) +
                       InterpolationParam3 * InterpolationParam3 + InterpolationParam5 * InterpolationParam5;
              scaleResult1 = InterpolationParam2 - RatioValue;
              if (InterpolationParam3 <= 0.0) {
                scaleResult1 = 0.0;
              }
              if (InterpolationParam3 * InterpolationParam3 < InterpolationParam4) {
                InterpolationParam2 = SQRT(InterpolationParam4) + RatioValue;
              }
              PrimaryResourcePointer0 = PrimaryResourcePointer0 + 2;
            } while (PrimaryResourcePointer0 < (long long *)resourcePoolPointer[8]);
            if ((0.0 < InterpolationParam2) &&
               (InterpolationParam2 < *(float *)((long long)resourcePoolPointer + 0x244) ||
                InterpolationParam2 == *(float *)((long long)resourcePoolPointer + 0x244))) {
              *(float *)((long long)resourcePoolPointer + 0x244) = InterpolationParam2;
            }
          }
        }
      }
      return;
    }
    SystemResourceStatusFlag = 0x1800756d4;
    (**(code **)(*resourcePoolPointer + 0x160))();
  }
  return;
}




// 函数: void InitializeSystemResourceManager(void* *SystemResourceManager)
/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，包括内存分配、资源池清理和系统配置
 * 用于系统启动时的资源管理器初始化和重置操作
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针，用于初始化资源管理器
 * @return 无返回值
 * 
 *FUN_1800756e0：InitializeSystemResourceManager
 */
void InitializeSystemResourceManager(void* *SystemResourceManager)

{
  byte *pisByteValid;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  void* resourceAddress;
  
  resourceAddress = 0xfffffffffffffffe;
  *SystemResourceManager = &SystemResourceDataTableC;
  SystemResourceManager[0x39] = 0;
  if (SystemResourceManager[0x59] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x59] = 0;
  resourcePoolPointer = (long long *)SystemResourceManager[0x37];
  SystemResourceManager[0x37] = 0;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  resourcePoolPointer = (long long *)SystemResourceManager[0x38];
  SystemResourceManager[0x38] = 0;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  if (SystemResourceManager[0x5a] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x5a] = 0;
  resourcePoolPointer = (long long *)SystemResourceManager[0x4b];
  if (resourcePoolPointer != (long long *)0x0) {
    if (*resourcePoolPointer != 0) {
        SystemCleanupFunction();
    }
    *resourcePoolPointer = 0;
    if (resourcePoolPointer[2] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[2] = 0;
    if (resourcePoolPointer[7] != 0) {
        SystemCleanupFunction();
    }
    resourcePoolPointer[2] = 0;
    resourcePoolPointer[7] = 0;
      SystemCleanupFunction(resourcePoolPointer);
  }
  SystemResourceManager[0x4b] = 0;
  if (*(char*)((long long)SystemResourceManager + 0xf9) != '\0') {
    if (SystemResourceManager[0x3b] != 0) {
        SystemCleanupFunction();
    }
    SystemResourceManager[0x3b] = 0;
    LOCK();
    *(uint8_t *)((long long)SystemResourceManager + 0xf9) = 0;
    UNLOCK();
  }
  if (SystemResourceManager[0x3d] != 0) {
    ConfigureSystemMemoryRegion();
    SystemResourceManager[0x3d] = 0;
    if (SystemResourceManager[0x3e] != 0) {
      pisByteValid = (byte *)(SystemResourceManager[0x3e] + 0xfe);
      *pisByteValid = *pisByteValid & 0xfb;
    }
  }
  resourcePoolPointer = (long long *)SystemResourceManager[0x42];
  SystemResourceManager[0x42] = 0;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  ResourceDataOffset = SystemResourceManager[0x3c];
  if (ResourceDataOffset != 0) {
    ConfigureSystemMemoryRegion(ResourceDataOffset,0x18,0x10,FUN_18007bb70,resourceAddress,ResourceDataOffset);
      SystemCleanupFunction(ResourceDataOffset);
  }
  SystemResourceManager[0x3c] = 0;
  InitializeSystemResourceTable(SystemResourceManager + 0x5e);
  ConfigureSystemResourceTable(SystemResourceManager + 0x5c);
  if ((long long *)SystemResourceManager[0x4d] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x4d] + 0x38))();
  }
  CleanupSystemMemoryAllocation();
  if ((long long *)SystemResourceManager[0x42] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x42] + 0x38))();
  }
  if (SystemResourceManager[0x3d] != 0) {
    ConfigureSystemMemoryRegion();
  }
  if ((long long *)SystemResourceManager[0x38] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x38] + 0x38))();
  }
  if ((long long *)SystemResourceManager[0x37] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x37] + 0x38))();
  }
  if ((long long *)SystemResourceManager[0x36] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x36] + 0x38))();
  }
  if ((long long *)SystemResourceManager[0x23] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[0x23] + 0x38))();
  }
  *SystemResourceManager = &SystemResourceDataTableA;
  SystemResourceManager[2] = &SystemMemoryAllocatorReference;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  return;
}




/**
 * @brief 系统资源管理器配置函数
 * 
 * 该函数负责配置系统资源管理器，包括加密密钥处理和系统上下文设置
 * 用于系统资源管理器的配置和初始化操作
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于配置资源管理器
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @return 无返回值
 * 
 *FUN_180075990：ConfigureSystemResourceManager
 */
void ConfigureSystemResourceManager(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  void* SystemOperationCounter;
  uint32_t SystemContextValue;
  long long LocalSystemValue;
  uint8_t aEncryptionKeyValue [8];
  long long LocalMemorySize;
  uint32_t ConcatenatedValue44;
  long long *LocalResourcePointer;
  
  if (*(long long *)(SystemResourceManager + 0x1b0) != *ConfigurationDataPointer) {
    if (*ConfigurationDataPointer == 0) {
      LocalResourcePointer = (long long *)0x0;
      aEncryptionKeyValue[0] = 0;
      ConcatenatedValue44 = 0;
      LocalMemorySize = SystemResourceManager;
      InitializeSystemEncryptionContext(aEncryptionKeyValue);
      if ((*(int *)(SystemResourceManager + 0x208) != 0) || (*(int *)(SystemResourceManager + 0x204) != 0)) {
        SystemOperationCounter = *(void* *)(SystemResourceManager + 0x1b0);
        SystemContextValue = 0;
        AcquireSystemOperationCounter(&SystemOperationCounter);
        PrimaryResourcePointer = LocalResourcePointer;
        InitializeResourcePointer(LocalResourcePointer + 2,LocalSystemValue + 0x10);
        InitializeResourcePointer(PrimaryResourcePointer + 7,LocalSystemValue + 0x38);
        ConfigureResourceSettings(PrimaryResourcePointer + 0xc,LocalSystemValue + 0x60);
        SetupResourceParameters(PrimaryResourcePointer + 0x11,LocalSystemValue + 0x88);
        ValidateResourceConfiguration(PrimaryResourcePointer + 0x19,LocalSystemValue + 200);
        ReleaseSystemOperationCounter(&SystemOperationCounter);
      }
      CleanupSystemResourceEncryption(aEncryptionKeyValue);
      if (LocalResourcePointer != (long long *)0x0) {
        (**(code **)(*LocalResourcePointer + 0x38))();
      }
    }
    ConfigurationDataPointer = (long long *)*ConfigurationDataPointer;
    if (ConfigurationDataPointer != (long long *)0x0) {
      (**(code **)(*ConfigurationDataPointer + 0x28))(ConfigurationDataPointer);
    }
    PrimaryResourcePointer = *(long long **)(SystemResourceManager + 0x1b0);
    *(long long **)(SystemResourceManager + 0x1b0) = ConfigurationDataPointer;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
  }
  return;
}



/**
 * @brief 系统资源管理器句柄计算函数
 * 
 * 该函数负责计算系统资源管理器的句柄值，包括操作完成状态检查和句柄计算
 * 用于系统资源管理器的句柄生成和管理
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于计算句柄
 * @return 返回计算后的句柄值
 * 
 *FUN_180075af0：CalculateSystemResourceManagerHandle
 */
long long CalculateSystemResourceManagerHandle(long long SystemResourceManager)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  byte isOperationComplete;
  
  isOperationComplete = *(byte *)(SystemResourceManager + 0xfd) & 0x20;
  resourceDataIndex = SystemResourceManager;
  if (isOperationComplete == 0) {
    resourceDataIndex = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  SystemThreadHandle = 2;
  if (0xffff < *(int *)(resourceDataIndex + 0x200)) {
    SystemThreadHandle = 4;
  }
  if (isOperationComplete == 0) {
    SystemResourceManager = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  return (*(int *)(SystemResourceManager + 0x1fc) * 3) * SystemThreadHandle;
}



/**
 * @brief 系统资源管理器浮点数处理函数
 * 
 * 该函数负责处理系统资源管理器的浮点数操作，包括系统状态检查和浮点数计算
 * 用于系统资源管理器的浮点数处理和计算
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于浮点数处理
 * @return 返回处理后的浮点数指针
 * 
 *FUN_180075b70：ProcessSystemResourceManagerFloat
 */
float * ProcessSystemResourceManagerFloat(float *SystemResourceManager)

{
  float *primaryFloatPointer;
  byte isSystemActive;
  long long *SystemResourceOffsetPointer;
  float *pfloatValue4;
  char operationStatusFlag;
  float *pfloatValue6;
  uint SystemLoopCounter;
  ulong long OperationCode;
  bool isSystemBusy;
  float ScalingFactor;
  float OffsetValue;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  uint32_t StackUnsignedValueAC;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  uint32_t StackUnsignedValue9C;
  float *SystemFloatPointer;
  uint32_t SystemConfigurationValue;
  long long SystemConfigurationData;
  void* SystemUnsignedFlag78;
  void* SystemProcessFlags70;
  void* EncryptionValue68;
  void* ThreadContextFlag;
  float SystemFloatValue1;
  float SystemFloatValue2;
  float SystemFloatValue3;
  float fStack_4c;
  void* SystemEncryptionKey;
  void* SystemOperationCounter;
  void* SystemContextValue;
  
  SystemContextValue = 0xfffffffffffffffe;
  pfloatValue6 = SystemResourceManager;
  if ((*(byte *)((long long)SystemResourceManager + 0xfd) & 0x20) == 0) {
    pfloatValue6 = (float *)func_0x000180085de0(*(void* *)(SystemResourceManager + 0x6c));
  }
  if ((*(long long *)(pfloatValue6 + 0x84) != 0) && (((uint)SystemResourceManager[0x40] & 0x80) == 0)) {
    primaryFloatPointer = SystemResourceManager + 0x9d;
    primaryFloatPointer[0] = 1e+08;
    primaryFloatPointer[1] = 1e+08;
    SystemResourceManager[0x9f] = 1e+08;
    SystemResourceManager[0xa0] = 3.4028235e+38;
    SystemResourceManager[0xa1] = -1e+08;
    SystemResourceManager[0xa2] = -1e+08;
    SystemResourceManager[0xa3] = -1e+08;
    SystemResourceManager[0xa4] = 3.4028235e+38;
    ThreadContextFlag = 0;
    SystemResourceManager[0xa9] = 0.0;
    SystemResourceManager[0xa5] = 0.0;
    SystemResourceManager[0xa6] = 0.0;
    SystemResourceManager[0xa7] = 0.0;
    SystemResourceManager[0xa8] = 3.4028235e+38;
    SystemConfigurationValue = 0;
    SystemFloatPointer = pfloatValue6;
    ProcessFloatValue(&SystemFloatPointer);
    if (*(int *)(SystemConfigurationData + 0x10) != 0) {
      do {
        pfloatValue6 = (float *)((long long)(int)ThreadContextFlag * 0x10 + *(long long *)(SystemConfigurationData + 0x18));
        fStack_a8 = *pfloatValue6;
        if (*primaryFloatPointer < fStack_a8) {
          fStack_a8 = *primaryFloatPointer;
        }
        fStack_a4 = pfloatValue6[1];
        if (SystemResourceManager[0x9e] < fStack_a4) {
          fStack_a4 = SystemResourceManager[0x9e];
        }
        fStack_a0 = pfloatValue6[2];
        if (SystemResourceManager[0x9f] < fStack_a0) {
          fStack_a0 = SystemResourceManager[0x9f];
        }
        *(ulong long *)primaryFloatPointer = ConcatenatedValue44(fStack_a4,fStack_a8);
        *(ulong long *)(SystemResourceManager + 0x9f) = ConcatenatedValue44(uStack_9c,fStack_a0);
        fStack_b8 = *pfloatValue6;
        if (fStack_b8 < SystemResourceManager[0xa1]) {
          fStack_b8 = SystemResourceManager[0xa1];
        }
        fStack_b4 = pfloatValue6[1];
        if (fStack_b4 < SystemResourceManager[0xa2]) {
          fStack_b4 = SystemResourceManager[0xa2];
        }
        fStack_b0 = pfloatValue6[2];
        if (fStack_b0 < SystemResourceManager[0xa3]) {
          fStack_b0 = SystemResourceManager[0xa3];
        }
        *(ulong long *)(SystemResourceManager + 0xa1) = ConcatenatedValue44(fStack_b4,fStack_b8);
        *(ulong long *)(SystemResourceManager + 0xa3) = ConcatenatedValue44(uStack_ac,fStack_b0);
        ThreadContextFlag = ThreadContextFlag + 1;
      } while (ThreadContextFlag < *(uint *)(SystemConfigurationData + 0x10));
    }
    pfloatValue6 = *(float **)(SystemResourceManager + 0x6e);
    if ((pfloatValue6 != (float *)0x0) && (((uint)pfloatValue6[0x4e] & 0x3000) != 0)) {
      SystemUnsignedFlag78 = *(void* *)(SystemResourceManager + 0x48);
      SystemProcessFlags70 = *(void* *)(SystemResourceManager + 0x4a);
      EncryptionValue68 = *(void* *)(SystemResourceManager + 0x4c);
      SystemThreadContext = *(void* *)(SystemResourceManager + 0x4e);
      SystemFloatValue1 = SystemResourceManager[0x50];
      SystemFloatValue2 = SystemResourceManager[0x51];
      SystemFloatValue3 = SystemResourceManager[0x52];
      fStack_4c = SystemResourceManager[0x53];
      SystemEncryptionKey = *(void* *)(SystemResourceManager + 0x54);
      SystemOperationCounter = *(void* *)(SystemResourceManager + 0x56);
      ProcessSystemUnsignedFlagInitialization(&SystemUnsignedFlag78);
      ProcessRenderObjectStateAllocation(primaryFloatPointer,primaryFloatPointer,&SystemUnsignedFlag78);
      pfloatValue6 = *(float **)(SystemResourceManager + 0x6e);
      if (((uint)pfloatValue6[0x4e] & 0x3000) == 0x2000) {
        SystemUnsignedFlag78 = *(void* *)(SystemResourceManager + 0x48);
        SystemProcessFlags70 = *(void* *)(SystemResourceManager + 0x4a);
        EncryptionValue68 = *(void* *)(SystemResourceManager + 0x4c);
        SystemThreadContext = *(void* *)(SystemResourceManager + 0x4e);
        SystemFloatValue1 = SystemResourceManager[0x50];
        SystemFloatValue2 = SystemResourceManager[0x51];
        SystemFloatValue3 = SystemResourceManager[0x52];
        fStack_4c = SystemResourceManager[0x53];
        SystemEncryptionKey = *(void* *)(SystemResourceManager + 0x54);
        SystemOperationCounter = *(void* *)(SystemResourceManager + 0x56);
        ProcessSystemUnsignedFlagWithFloatingValue(&SystemUnsignedFlag78,0x3fc90fdb);
        ProcessRenderObjectStateAllocation(primaryFloatPointer,primaryFloatPointer,&SystemUnsignedFlag78);
        SystemUnsignedFlag78 = *(void* *)(SystemResourceManager + 0x48);
        SystemProcessFlags70 = *(void* *)(SystemResourceManager + 0x4a);
        EncryptionValue68 = *(void* *)(SystemResourceManager + 0x4c);
        SystemThreadContext = *(void* *)(SystemResourceManager + 0x4e);
        SystemFloatValue1 = SystemResourceManager[0x50];
        SystemFloatValue2 = SystemResourceManager[0x51];
        SystemFloatValue3 = SystemResourceManager[0x52];
        fStack_4c = SystemResourceManager[0x53];
        SystemEncryptionKey = *(void* *)(SystemResourceManager + 0x54);
        SystemOperationCounter = *(void* *)(SystemResourceManager + 0x56);
        ResetSystemUnsignedFlag(&SystemUnsignedFlag78);
        pfloatValue6 = (float *)ProcessRenderObjectStateAllocation(primaryFloatPointer,primaryFloatPointer,&SystemUnsignedFlag78);
      }
    }
    pfloatValue4 = SystemFloatPointer;
    if (SystemResourceManager[0xa1] < *primaryFloatPointer) {
      SystemResourceManager[0xa9] = 0.0;
      primaryFloatPointer[0] = 0.0;
      primaryFloatPointer[1] = 0.0;
      SystemResourceManager[0x9f] = 0.0;
      SystemResourceManager[0xa0] = 0.0;
      SystemResourceManager[0xa1] = 0.0;
      SystemResourceManager[0xa2] = 0.0;
      SystemResourceManager[0xa3] = 0.0;
      SystemResourceManager[0xa4] = 0.0;
      SystemResourceManager[0xa5] = 0.0;
      SystemResourceManager[0xa6] = 0.0;
      SystemResourceManager[0xa7] = 0.0;
      SystemResourceManager[0xa8] = 0.0;
    }
    else {
      SystemResourceManager[0xa5] = (SystemResourceManager[0xa1] + *primaryFloatPointer) * 0.5;
      SystemResourceManager[0xa6] = (SystemResourceManager[0xa2] + SystemResourceManager[0x9e]) * 0.5;
      SystemResourceManager[0xa7] = (SystemResourceManager[0xa3] + SystemResourceManager[0x9f]) * 0.5;
      SystemResourceManager[0xa8] = 3.4028235e+38;
      ScalingFactor = 0.0;
      OperationCode = (ulong long)*(uint *)(SystemConfigurationData + 0x10);
      if (0 < (int)*(uint *)(SystemConfigurationData + 0x10)) {
        pfloatValue6 = *(float **)(SystemConfigurationData + 0x18);
        OffsetValue = ScalingFactor;
        do {
          ScalingFactor = (*pfloatValue6 - SystemResourceManager[0xa5]) * (*pfloatValue6 - SystemResourceManager[0xa5]) +
                   (pfloatValue6[1] - SystemResourceManager[0xa6]) * (pfloatValue6[1] - SystemResourceManager[0xa6]) +
                   (pfloatValue6[2] - SystemResourceManager[0xa7]) * (pfloatValue6[2] - SystemResourceManager[0xa7]);
          if (ScalingFactor <= OffsetValue) {
            ScalingFactor = OffsetValue;
          }
          pfloatValue6 = pfloatValue6 + 4;
          OperationCode = OperationCode - 1;
          OffsetValue = ScalingFactor;
        } while (OperationCode != 0);
      }
      SystemResourceManager[0xa9] = SQRT(ScalingFactor);
    }
    if (SystemFloatPointer != (float *)0x0) {
      while( true ) {
        LOCK();
        systemStatusFlag = *(char *)(pfloatValue4 + 0x3b);
        isSystemBusy = systemStatusFlag == '\0';
        if (isSystemBusy) {
          *(char *)(pfloatValue4 + 0x3b) = '\x01';
          systemStatusFlag = '\0';
        }
        UNLOCK();
        if (isSystemBusy) break;
        ScalingFactor = (float)_Thrd_id();
        if ((pfloatValue4[0x3c] == ScalingFactor) || (pfloatValue4[0x3c] != 0.0)) goto LAB_180075f4f;
        Sleep();
      }
      systemStatusFlag = '\0';
LAB_180075f4f:
      LOCK();
      primaryFloatPointer = pfloatValue4 + 0x3a;
      ScalingFactor = *primaryFloatPointer;
      pfloatValue6 = (float *)(ulong long)(uint)ScalingFactor;
      *primaryFloatPointer = (float)((int)*primaryFloatPointer + -1);
      UNLOCK();
      if (systemStatusFlag == '\0') {
        if ((((ScalingFactor == 1.4013e-45) && (*(long long *)(SystemFloatPointer + 0x84) != 0)) &&
            (pfloatValue6 = SystemFloatPointer, ValidateSystemString(SystemFloatPointer), *(char *)(pfloatValue6 + 0x3f) == '\0')) &&
           ((*(char *)(pfloatValue6 + 0x3d) == '\0' &&
            (((*(byte *)((long long)pfloatValue6 + 0xfd) & 0x20) == 0 ||
             ((*(byte *)((long long)pfloatValue6 + 0xfe) & 1) == 0)))))) {
          SystemResourceOffsetPointer = *(long long **)(pfloatValue6 + 0x84);
          pfloatValue6[0x84] = 0.0;
          pfloatValue6[0x85] = 0.0;
          if (SystemResourceOffsetPointer != (long long *)0x0) {
            (**(code **)(*SystemResourceOffsetPointer + 0x38))();
          }
        }
        LOCK();
        isSystemActive = *(byte *)(pfloatValue4 + 0x3b);
        *(byte *)(pfloatValue4 + 0x3b) = 0;
        pfloatValue6 = (float *)(ulong long)isSystemActive;
        UNLOCK();
      }
    }
  }
  return pfloatValue6;
}




// 函数: void InitializeSystemResourceManagerFinal(long long* SystemResourceManager)
/**
 * @brief 系统资源管理器初始化函数（扩展版本）
 * 
 * 该函数负责扩展初始化系统资源管理器，包括系统操作状态检查和资源池管理
 * 用于系统资源管理器的扩展初始化和配置
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于扩展初始化
 * @return 无返回值
 * 
 *FUN_180075ff0：InitializeSystemResourceManagerExtended
 */
void InitializeSystemResourceManagerExtended(long long* SystemResourceManager)

{
  ushort SystemOperationStatus;
  long long *resourcePoolPointer;
  uint resourceAllocationContext;
  int systemIndex;
  int systemValue;
  int CalculationFlags;
  long long localDataIndex;
  float floatValue8;
  float ScaleValue;
  uint8_t StackBuffer2 [8];
  long long *pLocalStackInitializationFlag;
  uint32_t SystemMemoryOffset;
  long long *SecondaryResourcePointer;
  long long *pStackValue3;
  uint32_t UnsignedStackFlag110;
  long long LocalSystemAddress;
  void* EncryptionOffset2;
  void* MemoryBufferAddress;
  uint8_t SystemResourceDataIndex;
  void* StackPointerE8;
  void* SystemMemoryAllocatorStatus;
  void* StackPointerC8;
  void* UnsignedStackFlagC0;
  uint8_t systemDataBuffer;
  void* UnsignedStackFlagB0;
  void* UnsignedStackFlagA0;
  void* StackParameterC;
  
  SystemConfigurationValue = 0xfffffffffffffffe;
  while( true ) {
    if (((int)SystemResourceManager[0x41] != 0) &&
       ((floatValue8 = *(float *)(SystemResourceManager + 0x5b) - *(float *)((long long)SystemResourceManager + 0x2dc), floatValue8 <= -0.01
        || (0.01 <= floatValue8)))) {
      resourcePoolPointer = SystemResourceManager;
      if ((((*(byte *)((long long)SystemResourceManager + 0xfd) & 0x40) == 0) || (SystemResourceManager[0x42] == 0)) &&
         (SystemResourceManager[0x36] != 0)) {
        resourcePoolPointer = (long long *)AllocateSystemResourcePool();
      }
      CalculationFlags = 0;
      if (resourcePoolPointer == SystemResourceManager) {
        SecondaryResourcePointer = (long long *)0x0;
        StackBuffer2[0] = 0;
        SystemMemoryOffset = 0;
        pLocalStackInitializationFlag = resourcePoolPointer;
        InitializeSystemResourceEncryption(StackBuffer2);
        resourcePoolPointer = SecondaryResourcePointer + 0x16;
        SystemOperationStatus = *(ushort *)(SecondaryResourcePointer + 0x18);
        floatValue8 = *(float *)(SecondaryResourcePointer[0x17] + -4 + (ulong long)SystemOperationStatus * 4);
        ScaleValue = *(float *)((long long)SystemResourceManager + 0x2dc);
        if (floatValue8 < *(float *)((long long)SystemResourceManager + 0x2dc)) {
          *(float *)((long long)SystemResourceManager + 0x2dc) = floatValue8;
          SystemOperationStatus = *(ushort *)(SecondaryResourcePointer + 0x18);
          ScaleValue = floatValue8;
        }
        resourceAllocationContext = (uint)SystemOperationStatus;
        if (SystemOperationStatus < 2) {
          CalculationFlags = resourceAllocationContext - 1;
          floatValue8 = 0.0;
          systemValue = CalculationFlags;
        }
        else {
          systemValue = resourceAllocationContext - 1;
          if (0 < (int)(resourceAllocationContext - 2)) {
            do {
              systemIndex = systemValue + CalculationFlags >> 1;
              if (*(float *)(SecondaryResourcePointer[0x17] + (long long)systemIndex * 4) <= ScaleValue) {
                CalculationFlags = systemIndex;
                systemIndex = systemValue;
              }
              systemValue = systemIndex;
            } while (CalculationFlags < systemValue + -1);
          }
          floatValue8 = *(float *)(SecondaryResourcePointer[0x17] + (long long)CalculationFlags * 4);
          floatValue8 = (ScaleValue - floatValue8) / (*(float *)(SecondaryResourcePointer[0x17] + (long long)systemValue * 4) - floatValue8);
          if (0.0 <= floatValue8) {
            if (1.0 <= floatValue8) {
              floatValue8 = 1.0;
            }
          }
          else {
            floatValue8 = 0.0;
          }
        }
        if (-1 < CalculationFlags) {
          (**(code **)(*SystemResourceManager + 0x28))(SystemResourceManager);
          EncryptionOffset2 = 0;
          MemoryBufferAddress = 0;
          SystemMemoryAllocatorStatus = 0;
          SystemInitializationStatus = 0;
          StackPointerF0 = 0;
          InitializeSystemEncryptionContext(&EncryptionOffset2,SystemResourceManager,0);
          (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
          ProcessSystemEncryptionCalculation(&EncryptionOffset2,resourcePoolPointer,systemValue,CalculationFlags,floatValue8);
          FinalizeSystemEncryptionContext(&EncryptionOffset2);
        }
        CleanupSystemResourceEncryption(StackBuffer2);
        if (SecondaryResourcePointer != (long long *)0x0) {
          (**(code **)(*SecondaryResourcePointer + 0x38))();
        }
      }
      else {
        UnsignedStackFlag110 = 0;
        pStackValue3 = resourcePoolPointer;
        InitializeSystemStackContext(&pStackValue3);
        localDataIndex = LocalSystemAddress + 0xb0;
        SystemOperationStatus = *(ushort *)(LocalSystemAddress + 0xc0);
        floatValue8 = *(float *)(*(long long *)(LocalSystemAddress + 0xb8) + -4 + (ulong long)SystemOperationStatus * 4);
        ScaleValue = *(float *)((long long)SystemResourceManager + 0x2dc);
        if (floatValue8 < *(float *)((long long)SystemResourceManager + 0x2dc)) {
          *(float *)((long long)SystemResourceManager + 0x2dc) = floatValue8;
          SystemOperationStatus = *(ushort *)(LocalSystemAddress + 0xc0);
          ScaleValue = floatValue8;
        }
        resourceAllocationContext = (uint)SystemOperationStatus;
        if (SystemOperationStatus < 2) {
          CalculationFlags = resourceAllocationContext - 1;
          floatValue8 = 0.0;
          systemValue = CalculationFlags;
        }
        else {
          systemValue = resourceAllocationContext - 1;
          if (0 < (int)(resourceAllocationContext - 2)) {
            do {
              systemIndex = systemValue + CalculationFlags >> 1;
              if (*(float *)(*(long long *)(LocalSystemAddress + 0xb8) + (long long)systemIndex * 4) <= ScaleValue) {
                CalculationFlags = systemIndex;
                systemIndex = systemValue;
              }
              systemValue = systemIndex;
            } while (CalculationFlags < systemValue + -1);
          }
          floatValue8 = *(float *)(*(long long *)(LocalSystemAddress + 0xb8) + (long long)CalculationFlags * 4);
          floatValue8 = (ScaleValue - floatValue8) /
                  (*(float *)(*(long long *)(LocalSystemAddress + 0xb8) + (long long)systemValue * 4) - floatValue8);
          if (0.0 <= floatValue8) {
            if (1.0 <= floatValue8) {
              floatValue8 = 1.0;
            }
          }
          else {
            floatValue8 = 0.0;
          }
        }
        if (-1 < CalculationFlags) {
          (**(code **)(*SystemResourceManager + 0x28))(SystemResourceManager);
          StackValueC8 = 0;
          UnsignedStackFlagC0 = 0;
          UnsignedStackFlagA0 = 0;
          SystemStackFlagB0 = 0;
          systemDataBuffer = 0;
          InitializeSystemDataBuffer(&SystemDataBufferContext,SystemResourceManager,0);
          (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
          ProcessSystemBufferData(&SystemDataBufferContext,localDataIndex,systemValue,CalculationFlags,floatValue8);
          CleanupSystemDataBuffer(&SystemDataBufferContext);
        }
        ProcessSystemStackContext(&pStackValue3);
      }
      *(uint32_t *)(SystemResourceManager + 0x5b) = *(uint32_t *)((long long)SystemResourceManager + 0x2dc);
    }
    if ((*(byte *)((long long)SystemResourceManager + 0xfd) & 0x20) != 0) break;
    SystemResourceManager = (long long *)SystemResourceManager[0x36];
  }
  return;
}




/**
 * @brief 系统资源管理器配置和数据复制器
 * 
 * 该函数负责配置系统资源管理器并复制相关数据，包括：
 * - 分配和初始化系统资源管理器内存
 * - 复制系统配置数据和资源参数
 * - 设置线程创建标志和资源地址
 * - 管理哈希表项和数据索引
 * - 配置系统资源管理器的各种属性
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置完成后的配置数据指针
 * 
 * 原始函数名：FUN_1800763c0
 */
long long * SystemResourceManagerConfiguratorAndDataCopier(long long* SystemResourceManager,long long *ConfigurationDataPointer)

{
  byte *pisByteValid;
  uint32_t resourceCreationFlags;
  long long ResourceDataOffset;
  uint32_t resourceAddress;
  uint32_t currentThreadId;
  uint32_t ResourceHash;
  void* ThreadContextFlag;
  void* OperationCode;
  void* ThreadContextFlag;
  void* SystemOperationFlags;
  long long SystemResourceDataIndex;
  long long resourceDataIndex2;
  long long resourceDataIndex3;
  long long resourceDataIndex4;
  long long resourceDataIndex5;
  long long resourceDataIndex6;
  long long resourceDataIndex7;
  void* SystemOperationStatus8;
  long long *PrimaryResourcePointer9;
  void* *SystemHashEntryPointer0;
  long long *PrimaryResourcePointer;
  long long *SecondaryResourcePointer;
  uint32_t ThreadCreationFlags;
  
  SecondaryResourcePointer = ConfigurationDataPointer;
  SystemOperationStatus8 = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x300,0x10,9,0,InvalidHandleValue);
  PrimaryResourcePointer9 = (long long *)InitializeSystemResourceManagerEx(SystemOperationStatus8,0,0);
  *ConfigurationDataPointer = (long long)PrimaryResourcePointer9;
  if (PrimaryResourcePointer9 != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer9 + 0x28))(PrimaryResourcePointer9);
  }
  ThreadCreationFlags = 1;
  *(byte *)(*ConfigurationDataPointer + 0xfd) = *(byte *)(*ConfigurationDataPointer + 0xfd) & 0xdf;
  SystemResourceDataIndex = SystemResourceManager[0x18];
  ResourceDataOffset = *ConfigurationDataPointer;
  *(long long *)(ResourceDataOffset + 0xb8) = SystemResourceManager[0x17];
  *(long long *)(ResourceDataOffset + 0xc0) = SystemResourceDataIndex;
  *(byte *)(*ConfigurationDataPointer + 0xfd) = *(byte *)(*ConfigurationDataPointer + 0xfd) & 0xbf;
  resourceCreationFlags = *(uint32_t *)((long long)SystemResourceManager + 0xcc);
  SystemResourceDataIndex = SystemResourceManager[0x1a];
  resourceAddress = *(uint32_t *)((long long)SystemResourceManager + 0xd4);
  resourceDataIndex2 = SystemResourceManager[0x1b];
  currentThreadId = *(uint32_t *)((long long)SystemResourceManager + 0xdc);
  resourceDataIndex3 = SystemResourceManager[0x1c];
  ResourceHash = *(uint32_t *)((long long)SystemResourceManager + 0xe4);
  ResourceDataOffset = *ConfigurationDataPointer;
  *(int *)(ResourceDataOffset + 200) = (int)SystemResourceManager[0x19];
  *(uint32_t *)(ResourceDataOffset + 0xcc) = resourceCreationFlags;
  *(int *)(ResourceDataOffset + 0xd0) = (int)SystemResourceDataIndex;
  *(uint32_t *)(ResourceDataOffset + 0xd4) = resourceAddress;
  *(int *)(ResourceDataOffset + 0xd8) = (int)resourceDataIndex2;
  *(uint32_t *)(ResourceDataOffset + 0xdc) = currentThreadId;
  *(int *)(ResourceDataOffset + 0xe0) = (int)resourceDataIndex3;
  *(uint32_t *)(ResourceDataOffset + 0xe4) = ResourceHash;
  if ((*(byte *)((long long)SystemResourceManager + 0xfd) & 0x20) == 0) {
    ConfigureSystemResourceManager(*ConfigurationDataPointer,SystemResourceManager + 0x36);
  }
  else {
    ResourceDataOffset = *ConfigurationDataPointer;
    PrimaryResourcePointer = SystemResourceManager;
    (**(code **)(*SystemResourceManager + 0x28))(SystemResourceManager);
    ConfigureSystemResourceManager(ResourceDataOffset,&PrimaryResourcePointer);
    (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
  }
  *(long long *)(*ConfigurationDataPointer + 0xa8) = SystemResourceManager[0x15];
  pisByteValid = (byte *)(*ConfigurationDataPointer + 0xfd);
  *pisByteValid = *pisByteValid ^ (*(byte *)(*ConfigurationDataPointer + 0xfd) ^ *(byte *)((long long)SystemResourceManager + 0xfd)) & 2;
  *(int *)(*ConfigurationDataPointer + 0x100) = (int)SystemResourceManager[0x20];
  SystemResourceDataIndex = SystemResourceManager[0x48];
  ResourceDataOffset = *ConfigurationDataPointer;
  *(long long *)(ResourceDataOffset + 0x238) = SystemResourceManager[0x47];
  *(long long *)(ResourceDataOffset + 0x240) = SystemResourceDataIndex;
  SystemResourceDataIndex = SystemResourceManager[0x4a];
  ResourceDataOffset = *ConfigurationDataPointer;
  *(long long *)(ResourceDataOffset + 0x248) = SystemResourceManager[0x49];
  *(long long *)(ResourceDataOffset + 0x250) = SystemResourceDataIndex;
  resourceCreationFlags = *(uint32_t *)((long long)SystemResourceManager + 0x2ac);
  SystemResourceDataIndex = SystemResourceManager[0x56];
  resourceAddress = *(uint32_t *)((long long)SystemResourceManager + 0x2b4);
  ResourceDataOffset = *ConfigurationDataPointer;
  *(int *)(ResourceDataOffset + 0x2a8) = (int)SystemResourceManager[0x55];
  *(uint32_t *)(ResourceDataOffset + 0x2ac) = resourceCreationFlags;
  *(int *)(ResourceDataOffset + 0x2b0) = (int)SystemResourceDataIndex;
  *(uint32_t *)(ResourceDataOffset + 0x2b4) = resourceAddress;
  resourceCreationFlags = *(uint32_t *)((long long)SystemResourceManager + 700);
  SystemResourceDataIndex = SystemResourceManager[0x58];
  resourceAddress = *(uint32_t *)((long long)SystemResourceManager + 0x2c4);
  ResourceDataOffset = *ConfigurationDataPointer;
  *(int *)(ResourceDataOffset + 0x2b8) = (int)SystemResourceManager[0x57];
  *(uint32_t *)(ResourceDataOffset + 700) = resourceCreationFlags;
  *(int *)(ResourceDataOffset + 0x2c0) = (int)SystemResourceDataIndex;
  *(uint32_t *)(ResourceDataOffset + 0x2c4) = resourceAddress;
  *(int *)(*ConfigurationDataPointer + 0x108) = (int)SystemResourceManager[0x21];
  if ((long long *)(*ConfigurationDataPointer + TRANSFORM_CONTEXT_OFFSET_218) != SystemResourceManager + 0x43) {
    ProcessSystemConfigurationData((long long *)(*ConfigurationDataPointer + TRANSFORM_CONTEXT_OFFSET_218),SystemResourceManager[0x43],SystemResourceManager[0x44]);
  }
  SystemHashEntryPointer0 = &SystemStringTemplate;
  if ((void* *)SystemResourceManager[3] != (void* *)0x0) {
    SystemHashEntryPointer0 = (void* *)SystemResourceManager[3];
  }
  (**(code **)(*(long long *)(*ConfigurationDataPointer + 0x10) + 0x10))((long long *)(*ConfigurationDataPointer + 0x10),SystemHashEntryPointer0);
  *(uint8_t *)(*ConfigurationDataPointer + 0xf6) = *(uint8_t *)((long long)SystemResourceManager + 0xf6);
  SystemOperationStatus8 = *(void* *)((long long)SystemResourceManager + 0x27c);
  ThreadContextFlag = *(void* *)((long long)SystemResourceManager + 0x284);
  OperationCode = *(void* *)((long long)SystemResourceManager + 0x28c);
  ThreadContextFlag = *(void* *)((long long)SystemResourceManager + 0x294);
  SystemOperationFlags = *(void* *)((long long)SystemResourceManager + 0x29c);
  resourceCreationFlags = *(uint32_t *)((long long)SystemResourceManager + 0x2a4);
  ResourceDataOffset = *ConfigurationDataPointer;
  *(void* *)(ResourceDataOffset + 0x274) = *(void* *)((long long)SystemResourceManager + 0x274);
  *(void* *)(ResourceDataOffset + 0x27c) = SystemOperationStatus8;
  *(void* *)(ResourceDataOffset + 0x284) = ThreadContextFlag;
  *(void* *)(ResourceDataOffset + 0x28c) = OperationCode;
  *(void* *)(ResourceDataOffset + 0x294) = ThreadContextFlag;
  *(void* *)(ResourceDataOffset + 0x29c) = SystemOperationFlags;
  *(uint32_t *)(ResourceDataOffset + 0x2a4) = resourceCreationFlags;
  *(uint8_t *)(*ConfigurationDataPointer + 0xff) = *(uint8_t *)((long long)SystemResourceManager + 0xff);
  *(int *)(*ConfigurationDataPointer + 0x270) = (int)SystemResourceManager[0x4e];
  SystemResourceDataIndex = SystemResourceManager[0x25];
  resourceDataIndex2 = SystemResourceManager[0x26];
  resourceDataIndex3 = SystemResourceManager[0x27];
  resourceDataIndex4 = SystemResourceManager[0x28];
  resourceDataIndex5 = SystemResourceManager[0x29];
  resourceDataIndex6 = SystemResourceManager[0x2a];
  resourceDataIndex7 = SystemResourceManager[0x2b];
  ResourceDataOffset = *ConfigurationDataPointer;
  *(long long *)(ResourceDataOffset + 0x120) = SystemResourceManager[0x24];
  *(long long *)(ResourceDataOffset + 0x128) = SystemResourceDataIndex;
  *(long long *)(ResourceDataOffset + 0x130) = resourceDataIndex2;
  *(long long *)(ResourceDataOffset + 0x138) = resourceDataIndex3;
  *(long long *)(ResourceDataOffset + 0x140) = resourceDataIndex4;
  *(long long *)(ResourceDataOffset + 0x148) = resourceDataIndex5;
  *(long long *)(ResourceDataOffset + 0x150) = resourceDataIndex6;
  *(long long *)(ResourceDataOffset + 0x158) = resourceDataIndex7;
  SystemResourceDataIndex = SystemResourceManager[0x2d];
  resourceDataIndex2 = SystemResourceManager[0x2e];
  resourceDataIndex3 = SystemResourceManager[0x2f];
  resourceDataIndex4 = SystemResourceManager[0x30];
  resourceCreationFlags = *(uint32_t *)((long long)SystemResourceManager + 0x184);
  resourceDataIndex5 = SystemResourceManager[0x31];
  resourceAddress = *(uint32_t *)((long long)SystemResourceManager + 0x18c);
  resourceDataIndex6 = SystemResourceManager[0x32];
  currentThreadId = *(uint32_t *)((long long)SystemResourceManager + 0x194);
  resourceDataIndex7 = SystemResourceManager[0x33];
  ResourceHash = *(uint32_t *)((long long)SystemResourceManager + 0x19c);
  ResourceDataOffset = *ConfigurationDataPointer;
  *(long long *)(ResourceDataOffset + 0x160) = SystemResourceManager[0x2c];
  *(long long *)(ResourceDataOffset + 0x168) = SystemResourceDataIndex;
  *(long long *)(ResourceDataOffset + 0x170) = resourceDataIndex2;
  *(long long *)(ResourceDataOffset + 0x178) = resourceDataIndex3;
  *(int *)(ResourceDataOffset + 0x180) = (int)resourceDataIndex4;
  *(uint32_t *)(ResourceDataOffset + 0x184) = resourceCreationFlags;
  *(int *)(ResourceDataOffset + 0x188) = (int)resourceDataIndex5;
  *(uint32_t *)(ResourceDataOffset + 0x18c) = resourceAddress;
  *(int *)(ResourceDataOffset + 400) = (int)resourceDataIndex6;
  *(uint32_t *)(ResourceDataOffset + 0x194) = currentThreadId;
  *(int *)(ResourceDataOffset + 0x198) = (int)resourceDataIndex7;
  *(uint32_t *)(ResourceDataOffset + 0x19c) = ResourceHash;
  pisByteValid = (byte *)(*ConfigurationDataPointer + 0xfd);
  *pisByteValid = *pisByteValid ^ (*(byte *)(*ConfigurationDataPointer + 0xfd) ^ *(byte *)((long long)SystemResourceManager + 0xfd)) & 1;
  *(uint8_t *)(*ConfigurationDataPointer + 0xf7) = *(uint8_t *)((long long)SystemResourceManager + 0xf7);
  *(int *)(*ConfigurationDataPointer + 0x208) = (int)SystemResourceManager[0x41];
  *(int *)(*ConfigurationDataPointer + 0x1f8) = (int)SystemResourceManager[0x3f];
  *(uint32_t *)(*ConfigurationDataPointer + 0x1fc) = *(uint32_t *)((long long)SystemResourceManager + 0x1fc);
  *(int *)(*ConfigurationDataPointer + 0x200) = (int)SystemResourceManager[0x40];
  *(uint32_t *)(*ConfigurationDataPointer + 0x204) = *(uint32_t *)((long long)SystemResourceManager + 0x204);
  *(int *)(*ConfigurationDataPointer + 0x2d8) = (int)SystemResourceManager[0x5b];
  resourceCreationFlags = *(uint32_t *)((long long)SystemResourceManager + 0x2dc);
  *(uint32_t *)(*ConfigurationDataPointer + 0x2dc) = resourceCreationFlags;
  ResourceDataOffset = *ConfigurationDataPointer;
  PrimaryResourcePointer9 = (long long *)SystemResourceManager[0x4d];
  if (PrimaryResourcePointer9 != (long long *)0x0) {
    PrimaryResourcePointer = PrimaryResourcePointer9;
    (**(code **)(*PrimaryResourcePointer9 + 0x28))(PrimaryResourcePointer9,resourceCreationFlags,(int)resourceDataIndex4,(int)resourceDataIndex6,ThreadCreationFlags);
  }
  PrimaryResourcePointer = *(long long **)(ResourceDataOffset + 0x268);
  *(long long **)(ResourceDataOffset + 0x268) = PrimaryResourcePointer9;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x38))();
  }
  ConfigureSystemResourceManagerThread(*ConfigurationDataPointer,SystemResourceManager + 0x37);
  return ConfigurationDataPointer;
}




// 函数: void ProcessSystemResourceManagerFinal(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 系统资源管理器高级配置函数
 * 
 * 该函数负责高级配置系统资源管理器，包括加密密钥处理和资源创建
 * 用于系统资源管理器的高级配置和初始化
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于高级配置
 * @param ConfigurationDataPointer 配置数据指针，包含配置信息
 * @param AdditionalParameter 附加参数，用于扩展配置
 * @param ConfigurationFlag 配置标志，用于控制配置行为
 * @return 无返回值
 * 
 *FUN_180076760：ConfigureSystemResourceManagerAdvanced
 */
void ConfigureSystemResourceManagerAdvanced(long long* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  void* resourceCreationFlags;
  long long *plongValue40;
  long long *plongValue38;
  uint8_t SystemResourceStatusFlagCompact [8];
  void* EncryptionKeyValue;
  long long *PrimarySystemPointer;
  void*2 SystemEncryptionOffset;
  char cStack_e;
  
  resourceCreationFlags = 0xfffffffffffffffe;
  if (SystemResourceManager[0x42] == 0) {
    SystemResourceManager[0x3f] = 0;
    SystemResourceManager[0x40] = 0;
    *(uint32_t *)(SystemResourceManager + 0x41) = 0;
    ExecuteSystemOperation();
  }
  else {
    (**(code **)(*SystemResourceManager + 0x28))();
    plongValue40 = (long long *)0x0;
    plongValue38 = (long long *)0x0;
    PrimarySystemPointer = (long long *)0x0;
    EncryptionKeyValue = 0;
    SystemResourceStatusFlagCompact[0] = 0;
    InitializeMemoryAllocatorWithFlags(&plongValue40,SystemResourceManager,0,ConfigurationFlag,resourceCreationFlags);
    (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
    PrimaryResourcePointer = plongValue38;
    *(uint32_t *)(plongValue38 + 2) = 0;
    *(uint32_t *)(plongValue38 + 7) = 0;
    *(uint32_t *)(plongValue38 + 0x11) = 0;
    *(uint32_t *)(plongValue38 + 0xc) = 0;
    *(void*2 *)(plongValue38 + 0x18) = 0;
    if (plongValue38[0x17] != 0) {
        SystemCleanupFunction();
    }
    plongValue38[0x17] = 0;
    ProcessSystemResourceIndex(plongValue38[0x16]);
    PrimaryResourcePointer[0x16] = 0;
    *(uint32_t *)(PrimaryResourcePointer + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = 0;
    SystemEncryptionOffset = 0x101;
    if ((plongValue40 != (long long *)0x0) && (plongValue38 != (long long *)0x0)) {
      if (cStack_e != '\0') {
        ProcessSystemResourceManagerFloat();
      }
      CleanupSystemResourceEncryption(SystemResourceStatusFlagCompact);
      if ((char)SystemEncryptionOffset != '\0') {
        ExecuteSystemOperation(plongValue40);
      }
      if (SystemEncryptionOffset._1_1_ != '\0') {
        ExecuteSystemOperation(plongValue40);
      }
      PrimaryResourcePointer = plongValue38;
      plongValue38 = (long long *)0x0;
      if (PrimaryResourcePointer != (long long *)0x0) {
        (**(code **)(*PrimaryResourcePointer + 0x38))();
      }
    }
    CleanupSystemResourceEncryption(SystemResourceStatusFlagCompact);
    if (PrimarySystemPointer != (long long *)0x0) {
      (**(code **)(*PrimarySystemPointer + 0x38))();
    }
    if (plongValue38 != (long long *)0x0) {
      (**(code **)(*plongValue38 + 0x38))();
    }
    if (plongValue40 != (long long *)0x0) {
      (**(code **)(*plongValue40 + 0x38))();
      return;
    }
  }
  return;
}




// 函数: void ValidateSystemResourceManagerFinal(long long SystemResourceManager,long long *ConfigurationDataPointer)
/**
 * @brief 系统资源管理器线程配置函数
 * 
 * 该函数负责配置系统资源管理器的线程相关操作，包括线程ID检查和资源分配
 * 用于系统资源管理器的线程安全配置
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于线程配置
 * @param ConfigurationDataPointer 配置数据指针，包含线程配置信息
 * @return 无返回值
 * 
 *FUN_180076910：ConfigureSystemResourceManagerThread
 */
void ConfigureSystemResourceManagerThread(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  byte isByteValid;
  long long SystemThreadHandle;
  uint8_t resourceAllocationContext;
  byte isResourceAvailable;
  uint currentThreadId;
  long long SystemThreadFlags;
  long long *plocalDataIndex;
  
  if (*ConfigurationDataPointer != *(long long *)(SystemResourceManager + 0x1b8)) {
    if (*(char *)(SystemResourceManager + 0xb1) != '\0') {
        SystemDataOperation();
    }
    InitializeSystemThreadContext(SystemResourceManager + 0x1b8);
    SystemThreadHandle = *(long long *)(SystemResourceManager + 0x1b8);
    if (SystemThreadHandle != 0) {
      SystemThreadFlags = 0;
      isByteValid = *(byte *)(SystemResourceManager + 0xfd);
      isResourceAvailable = (byte)((uint)*(uint32_t *)(*(long long *)(SystemThreadHandle + 0x1e0) + 0x1588) >> 0x1b) << 7;
      *(byte *)(SystemResourceManager + 0xfd) = isResourceAvailable | isByteValid & 0x7f;
      currentThreadId = *(uint *)(SystemThreadHandle + 0x138) & 0x3000;
      if (currentThreadId == 0x1000) {
        *(uint8_t *)(SystemResourceManager + 0xf7) = 1;
      }
      else {
        resourceAllocationContext = 0;
        if (currentThreadId == 0x2000) {
          resourceAllocationContext = 2;
        }
        *(uint8_t *)(SystemResourceManager + 0xf7) = resourceAllocationContext;
      }
      isResourceAvailable = isResourceAvailable | isByteValid & 0x77;
      *(byte *)(SystemResourceManager + 0xfd) = isResourceAvailable;
      plocalDataIndex = (long long *)(SystemThreadHandle + 0xb8);
      do {
        if (0xf < SystemThreadFlags) break;
        if ((*plocalDataIndex != 0) && (*(int *)(*plocalDataIndex + 0x36c) != 0)) {
          isResourceAvailable = isResourceAvailable | 8;
          *(byte *)(SystemResourceManager + 0xfd) = isResourceAvailable;
        }
        SystemThreadFlags = SystemThreadFlags + 1;
        plocalDataIndex = plocalDataIndex + 1;
      } while ((isResourceAvailable & 8) == 0);
      ProcessSystemResourceManager(SystemResourceManager);
    }
  }
  return;
}




/**
 * @brief 增加系统资源引用计数
 * 
 * 该函数负责增加系统资源的引用计数，确保资源在使用过程中不会被意外释放。
 * 它使用互斥锁确保线程安全，防止多线程环境下的竞态条件。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含资源信息和引用计数
 * @note 这是系统资源生命周期管理的重要函数
 */
void IncrementSystemResourceReferenceCount(long long SystemResourceManager)

{
  int SystemOperationStatus;
  
  SystemOperationStatus = _Mtx_lock(0x180c91910);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  *(char *)(SystemResourceManager + 0xfc) = *(char *)(SystemResourceManager + 0xfc) + '\x01';
  SystemOperationStatus = _Mtx_unlock(0x180c91910);
  if (SystemOperationStatus != 0) {
    __Throw_C_error_std__YAXH_Z(SystemOperationStatus);
  }
  return;
}




// 函数: void CleanupSystemResourceManagerThread(long long SystemResourceManager)
/**
 * @brief 系统资源引用计数管理器
 * 
 * 该函数负责管理系统资源的引用计数，当引用计数降为0时，
 * 会执行资源清理和释放操作。它使用互斥锁确保线程安全。
 * 
 * @param SystemResourceManager 系统资源指针，包含引用计数和资源信息
 * @note 这是系统资源生命周期管理的核心函数
 */
void ManageSystemResourceReferenceCount(long long SystemResourceManager)

{
  char *ReferenceCountPointer;
  long long *resourcePoolPointer;
  int LockStatus;
  bool IsResourceLocked;
  
  LockStatus = _Mtx_lock(0x180c91910);
  if (LockStatus != 0) {
    __Throw_C_error_std__YAXH_Z(LockStatus);
  }
  ReferenceCountPointer = (char *)(SystemResourceManager + 0xfc);
  *ReferenceCountPointer = *ReferenceCountPointer + -1;
  if (*ReferenceCountPointer == '\0') {
    while( true ) {
      LOCK();
      IsResourceLocked = *(char *)(SystemResourceManager + 0xec) == '\0';
      if (IsResourceLocked) {
        *(char *)(SystemResourceManager + 0xec) = '\x01';
      }
      UNLOCK();
      if (IsResourceLocked) break;
      Sleep();
    }
    while (*(int *)(SystemResourceManager + 0xe8) != 0) {
      Sleep(0);
    }
    if ((((*(long long *)(SystemResourceManager + 0x210) != 0) &&
         (ValidateSystemString(SystemResourceManager), *ReferenceCountPointer == '\0')) &&
        (*(char *)(SystemResourceManager + 0xf4) == '\0')) &&
       (((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0 || ((*(byte *)(SystemResourceManager + 0xfe) & 1) == 0)))) {
      resourcePoolPointer = *(long long **)(SystemResourceManager + 0x210);
      *(void* *)(SystemResourceManager + 0x210) = 0;
      if (resourcePoolPointer != (long long *)0x0) {
        (**(code **)(*resourcePoolPointer + 0x38))();
      }
    }
    LOCK();
    if (*(char *)(SystemResourceManager + 0xec) == '\x01') {
      *(char *)(SystemResourceManager + 0xec) = '\0';
    }
    UNLOCK();
  }
  LockStatus = _Mtx_unlock(0x180c91910);
  if (LockStatus != 0) {
    __Throw_C_error_std__YAXH_Z(LockStatus);
  }
  return;
}



/**
 * @brief 系统资源状态验证器
 * 
 * 该函数负责验证系统资源的状态和可用性，包括：
 * - 检查系统资源的操作完成状态
 * - 验证资源管理器的有效性
 * - 处理系统资源的配置和状态标志
 * - 确保资源数据的完整性和可用性
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @return 资源有效返回1，无效返回0
 * 
 * 原始函数名：FUN_180076b90
 */
void* SystemResourceStatusValidator(long long SystemResourceManager)

{
  byte isByteValid;
  long long SystemThreadHandle;
  byte isOperationComplete;
  
  isOperationComplete = *(byte *)(SystemResourceManager + 0xfd);
  SystemThreadHandle = SystemResourceManager;
  if ((isOperationComplete & 0x20) == 0) {
    SystemThreadHandle = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  if (0 < *(int *)(SystemThreadHandle + 0x200)) {
    SystemThreadHandle = *(long long *)(SystemResourceManager + 0x1b8);
    isByteValid = *(byte *)(SystemThreadHandle + 0x38c);
    if (isByteValid == 9) {
      isByteValid = func_0x00018022d300();
      *(byte *)(SystemThreadHandle + 0x38c) = isByteValid;
      isOperationComplete = *(byte *)(SystemResourceManager + 0xfd);
    }
    if ((isOperationComplete & 0x20) == 0) {
      SystemResourceManager = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
    }
    if ((*(long long *)(SystemResourceManager + 0x1e0) == 0) ||
       (*(byte *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + (ulong long)isByteValid * 0x18) < 2)) {
      return 0;
    }
  }
  return 1;
}




/**
 * @brief 系统资源管理器配置处理器
 * 
 * 该函数负责处理系统资源管理器的配置操作，包括：
 * - 管理主资源指针和资源池
 * - 处理哈希节点数据和系统操作状态
 * - 执行资源计数和系统哈希计算
 * - 管理系统堆栈指针和操作标志
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置处理结果状态码
 * 
 * 原始函数名：FUN_180076c50
 */
int SystemResourceManagerConfigurationProcessor(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  ulong long *SystemHashNodeData;
  char SystemOperationStatusFlag;
  int systemValue;
  uint ResourceHash;
  long long localDataIndex;
  char *pcharInput;
  long long resourceCounter;
  ulong long SystemOperationFlags;
  ulong long SystemOperationStatus1;
  ulong long *pSystemSecondaryStatus;
  uint SystemOperationStatus3;
  ulong long SystemOperationStatus4;
  uint32_t extraout_XMM0_Da;
  uint32_t SystemOperationStatus5;
  void* SystemContextValue;
  void** hashTableNode;
  void** SystemStackPointer;
  uint InputStackParameterNegative38;
  void* SystemOperationStatusFlags;
  ulong long *SystemStatusFlagPointer;
  long long *SystemPoolPointer;
  code *SystemFunctionPointer70;
  code *SystemFunctionPointer68;
  void* ThreadContextFlag;
  void* SystemProcessFlags58;
  void* ConcatenatedValue44;
  uint32_t SystemEncryptionKey;
  
  SystemOperationStatusFlags = 0xfffffffffffffffe;
  systemValue = 0;
  if (((*(long long *)(SystemResourceManager + 0x1b8) != 0) && (systemValue = 0, (*(byte *)(ConfigurationDataPointer + 1) & 4) == 0)) &&
     (*(char*)((long long)ConfigurationDataPointer + 0x12) == '\0')) {
    systemValue = GetSystemOperationValue();
  }
  if ((*(byte *)(ConfigurationDataPointer + 1) & 0x20) == 0) {
    SystemOperationStatusFlag = ValidateSystemResourceManagerStatus(SystemResourceManager);
    if (SystemOperationStatusFlag == '\0') {
      if ((char)ConfigurationDataPointer[2] != '\0') {
        SystemStatusFlagPointer = (ulong long *)0x0;
        SystemPoolPointer = (long long *)0x0;
        SystemFunctionPointer70 = (code *)0x0;
        SystemFunctionPointer68 = _guard_check_icall;
        ProcessSystemResourceValidation(extraout_XMM0_Da,SystemResourceManager,&SystemStatusFlagPointer);
        if (SystemFunctionPointer70 != (code *)0x0) {
          (*SystemFunctionPointer70)(&SystemStatusFlagPointer,0,0);
        }
      }
      SystemOperationStatusFlag = ValidateSystemResourceManagerStatus(SystemResourceManager);
      if (SystemOperationStatusFlag == '\0') {
        systemValue = systemValue + 1;
        if (*ConfigurationDataPointer != 0) {
          SystemContextValue = SystemResourceManager;
          InitializeSystemHandle(*ConfigurationDataPointer,&SystemContextValue);
        }
      }
    }
    else if ((char)ConfigurationDataPointer[2] != '\0') {
      ReleaseSystemResourceManager(SystemResourceManager,0);
    }
  }
  if ((*(byte *)(ConfigurationDataPointer + 1) & 0x10) == 0) {
    return systemValue;
  }
  SystemThreadContext = 0;
  SystemProcessFlags58 = 0;
  ConcatenatedValue44 = 0;
  SystemEncryptionKey = 3;
  StackPointer1 = *(void* **)(SystemResourceManager + 0x1b8);
  SystemOperationStatus3 = *(uint *)(SystemResourceManager + 0x100) >> 0x16;
  pcharInput = "";
  if ((char *)StackPointer1[3] != (char *)0x0) {
    pcharInput = (char *)StackPointer1[3];
  }
  ResourceHash = 0x1505;
  SystemOperationStatusFlag = *pcharInput;
  while (SystemOperationStatusFlag != '\0') {
    pcharInput = pcharInput + 1;
    ResourceHash = ResourceHash * 0x21 + (int)SystemOperationStatusFlag;
    SystemOperationStatusFlag = *pcharInput;
  }
  SystemOperationStatus1 = (ulong long)ResourceHash;
  if ((SystemOperationStatus3 & 1) != 0) {
    SystemOperationStatus1 = (ulong long)ResourceHash | 0x400000000;
  }
  resourceCounter = ConfigurationDataPointer[9];
  if (resourceCounter != 0) {
    PrimaryResourcePointer = (long long *)(*(long long *)(resourceCounter + 8) + *(ulong long *)(resourceCounter + 0x10) * 8);
    pSystemSecondaryStatus = (ulong long *)*PrimaryResourcePointer;
    resourcePoolPointer = (long long *)
             (*(long long *)(resourceCounter + 8) + (SystemOperationStatus1 % (*(ulong long *)(resourceCounter + 0x10) & MAX_UNSIGNED_32_BIT)) * 8)
    ;
    for (SystemHashNodeData = (ulong long *)*resourcePoolPointer;
        (SystemStatusFlagPointer = pSystemSecondaryStatus, SystemPoolPointer = PrimaryResourcePointer, SystemHashNodeData != (ulong long *)0x0 &&
        (SystemStatusFlagPointer = SystemHashNodeData, SystemPoolPointer = resourcePoolPointer, SystemOperationStatus1 != *SystemHashNodeData));
        SystemHashNodeData = (ulong long *)SystemHashNodeData[1]) {
    }
    if (SystemStatusFlagPointer != pSystemSecondaryStatus) goto LAB_180076feb;
  }
  PrimaryResourcePointer = ConfigurationDataPointer + 5;
  resourceCounter = ConfigurationDataPointer[7] - *PrimaryResourcePointer;
  if ((ulong long)(resourceCounter / 0x18) < 0x100) {
    localDataIndex = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x1800,(char)ConfigurationDataPointer[8]);
    resourceCounter = *PrimaryResourcePointer;
    if (resourceCounter != ConfigurationDataPointer[6]) {
        memmove(localDataIndex,resourceCounter,ConfigurationDataPointer[6] - resourceCounter);
    }
    if (resourceCounter != 0) {
        SystemCleanupFunction();
    }
    *PrimaryResourcePointer = localDataIndex;
    ConfigurationDataPointer[6] = localDataIndex;
    ConfigurationDataPointer[7] = localDataIndex + 0x1800;
    resourceCounter = 0;
  }
  SystemStackPointer = &SystemContextValue;
  SystemContextValue = 0;
  SystemOperationStatus5 = InitializeResourceContext(resourceCounter,StackPointer1,&SystemThreadContext,0,InputStackParameterNegative38 & 0xffffff00,0,
                         (byte)SystemOperationStatus3 & 1,PrimaryResourcePointer,1,0,0,&SystemContextValue,SystemOperationStatusFlags);
  StackPointer1 = &SystemContextValue;
  SystemContextValue = 0;
  SystemOperationStatusFlag = ValidateResourceInitialization(SystemOperationStatus5,PrimaryResourcePointer,&SystemContextValue);
  if (SystemOperationStatusFlag == '\0') {
    systemValue = systemValue + 1;
  }
  ConfigurationDataPointer[6] = *PrimaryResourcePointer;
  resourceCounter = ConfigurationDataPointer[9];
  SystemOperationStatus4 = SystemOperationStatus1 % (ulong long)*(uint *)(resourceCounter + 0x10);
  for (pSystemSecondaryStatus = *(ulong long **)(*(long long *)(resourceCounter + 8) + SystemOperationStatus4 * 8); pSystemSecondaryStatus != (ulong long *)0x0
      ; pSystemSecondaryStatus = (ulong long *)pSystemSecondaryStatus[1]) {
    if (SystemOperationStatus1 == *pSystemSecondaryStatus) goto LAB_180076feb;
  }
  PrimaryResourcePointer = *(long long **)(resourceCounter + 0x30);
  SystemOperationFlags = (long long)(int)PrimaryResourcePointer[2] + 0xfU & MAX_UNSIGNED_32_BITfffffff0;
  *(int *)(PrimaryResourcePointer + 2) = (int)SystemOperationFlags + 0x10;
  pSystemSecondaryStatus = (ulong long *)(*PrimaryResourcePointer + SystemOperationFlags);
  *pSystemSecondaryStatus = SystemOperationStatus1;
  pSystemSecondaryStatus[1] = 0;
  ProcessResourceAllocationData(resourceCounter + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,&SystemContextValue,*(uint32_t *)(resourceCounter + 0x10),*(uint32_t *)(resourceCounter + 0x18),
                1);
  if ((char)SystemContextValue != '\0') {
    SystemOperationStatus4 = SystemOperationStatus1 % (ulong long)SystemContextValue._4_4_;
    ProcessResourceIndexData(resourceCounter,SystemContextValue._4_4_);
  }
  pSystemSecondaryStatus[1] = *(ulong long *)(*(long long *)(resourceCounter + 8) + SystemOperationStatus4 * 8);
  *(ulong long **)(*(long long *)(resourceCounter + 8) + SystemOperationStatus4 * 8) = pSystemSecondaryStatus;
  *(long long *)(resourceCounter + 0x18) = *(long long *)(resourceCounter + 0x18) + 1;
LAB_180076feb:
  InitializeThreadContext(&SystemThreadContext);
  return systemValue;
}




/**
 * @brief 释放系统资源管理器
 * 
 * 该函数负责释放系统资源管理器及其关联的资源。
 * 它会递减引用计数，当计数降为0时执行实际的资源释放操作。
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针，指向要释放的资源管理器
 * @note 这是系统资源清理的关键函数
 */
void ReleaseSystemResourceManager(long long* SystemResourceManager)

{
  void** SystemDataPointer;
  void** SystemDataTable;
  
  SystemDataPointer = (void* *)SystemResourceManager[SYSTEM_RESOURCE_DATA_POINTER_OFFSET];
  for (SystemHashEntryPointer = (void* *)*SystemResourceManager; SystemHashEntryPointer != SystemDataPointer; SystemHashEntryPointer = SystemHashEntryPointer + 6) {
    *SystemHashEntryPointer = &SystemGlobalDataReference;
    if (SystemHashEntryPointer[1] != 0) {
        SystemCleanupFunction();
    }
    SystemHashEntryPointer[1] = 0;
    *(uint32_t *)(SystemHashEntryPointer + 3) = 0;
    *SystemHashEntryPointer = &SystemMemoryAllocatorReference;
  }
  if (*SystemResourceManager != 0) {
      SystemCleanupFunction();
  }
  return;
}




ulong long InitializeSystemResourceContext(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  byte isSystemActive;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  long long SystemTimeValue;
  long long SystemThreadFlags;
  
  if (*(long long *)(SystemResourceManager + 0x1b8) != 0) {
    SystemThreadFlags = 0xb8;
    localSystemPointer = SystemGlobalStatusFlags;
    do {
      ResourceDataOffset = *(long long *)(SystemThreadFlags + *(long long *)(SystemResourceManager + 0x1b8));
      if ((((ResourceDataOffset != 0) && (*(long long *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x328 + SystemThreadFlags) == 0)) &&
          ((*(uint *)(ResourceDataOffset + 0x328) & 0x20000000) == 0)) && (*(long long *)(ResourceDataOffset + 0x370) == 0)) {
        if (*(long long *)(ResourceDataOffset + 0x1d8) == 0) {
          ProcessResourceOffset(ResourceDataOffset,0);
          localSystemPointer = SystemGlobalStatusFlags;
          SystemIntegerPointer = (int *)(*(long long *)(SystemThreadFlags + *(long long *)(SystemResourceManager + 0x1b8)) + 0x3a8);
          *SystemIntegerPointer = *SystemIntegerPointer + 1;
        }
        else if (localSystemPointer != 0) {
          *(long long *)(ResourceDataOffset + 0x340) = (long long)*(int *)(localSystemPointer + 0x224);
        }
      }
      SystemThreadFlags = SystemThreadFlags + 8;
    } while (SystemThreadFlags < 0x138);
  }
  isSystemActive = *(byte *)(SystemResourceManager + 0xf9);
  if (isSystemActive != 0) {
    if (*(long long *)(SystemResourceManager + 0x1d8) != 0) {
        SystemCleanupFunction();
    }
    *(void* *)(SystemResourceManager + 0x1d8) = 0;
    LOCK();
    isSystemActive = *(byte *)(SystemResourceManager + 0xf9);
    *(byte *)(SystemResourceManager + 0xf9) = 0;
    UNLOCK();
  }
  resourceAddress = (ulong long)isSystemActive;
  if (*(long long *)(SystemResourceManager + 0x1e8) != 0) {
    ConfigureSystemMemoryRegion();
    resourceAddress = *(ulong long *)(SystemResourceManager + 0x1f0);
    *(void* *)(SystemResourceManager + 0x1e8) = 0;
    if (resourceAddress != 0) {
      *(byte *)(resourceAddress + 0xfe) = *(byte *)(resourceAddress + 0xfe) & 0xfb;
    }
  }
  return resourceAddress;
}





/**
 * @brief 销毁系统资源管理器
 * 
 * 该函数负责完全销毁系统资源管理器，释放所有关联的内存和资源。
 * 它会清理资源池、释放内存并重置管理器状态。
 * 
 * @param SystemResourceManager 系统资源管理器指针的指针，指向要销毁的资源管理器
 * @note 这是系统资源完全清理的最终函数
 */
void DestroySystemResourceManager(long long* SystemResourceManager)

{
  void* SystemOperationStatus;
  ulong long *SystemHashEntryPointer;
  ulong long resourceAllocationContext;
  long long* SystemMemoryPointer;
  long long SystemTimeValue;
  byte isThreadActive;
  uint8_t StackBuffer [32];
  ulong long *pEncryptionValue68;
  void* ThreadContextFlag;
  void* *memoryAllocationBuffer;
  ulong long *memoryAllocationEnd;
  ulong long SystemEncryptionKey;
  ulong long StackBuffer40 [2];
  void* SystemResourceStatusFlag;
  char SystemCharacter1;
  char SystemCharacter2;
  char SystemCharacter3;
  ulong long SystemMaxOperationCount;
  
  ThreadContextFlag = 0xfffffffffffffffe;
  SystemMaxOperationCount = SystemEncryptionKeyTemplate ^ (ulong long)StackBuffer;
  SystemOperationStatus = *(void* *)(SystemResourceManager[0x37] + 0x1e0);
  memoryAllocationBuffer = &SystemMemoryTemplateE;
  memoryAllocationEnd = StackBuffer40;
  StackBuffer40[0] = StackBuffer40[0] & MAX_UNSIGNED_32_BITffffff00;
  SystemEncryptionKey._0_4_ = 0x12;
  strcpy_s(StackBuffer40,0x20,&SystemStringTemplateB);
  resourceAllocationContext = AllocateSystemResourceContext(SystemOperationStatus,&memoryAllocationBuffer,0);
  memoryAllocationBuffer = &SystemMemoryAllocatorReference;
  if (resourceAllocationContext != 0) {
    localSystemPointer = SystemResourceManager[0x37];
    if ((*(ulong long *)(localSystemPointer + 0x140) & resourceAllocationContext) != 0) {
      isThreadActive = *(byte *)((long long)SystemResourceManager + 0xfd) & 0x20;
      SystemCalculatedBufferAddress = SystemResourceManager;
      if (isThreadActive == 0) {
        SystemCalculatedBufferAddress = (long long *)func_0x000180085de0(SystemResourceManager[0x36]);
      }
      if (((*(uint *)(SystemCalculatedBufferAddress + 0x20) & 0x8000000) == 0) && (isThreadActive != 0)) {
        pEncryptionValue68 = (ulong long *)SystemResourceManager;
        (**(code **)(*SystemResourceManager + 0x28))(SystemResourceManager);
        memoryAllocationBuffer = (void* *)0x0;
        memoryAllocationEnd = (ulong long *)0x0;
        pEncryptionValue68 = &SystemEncryptionKey;
        SystemResourceStatusFlag = 0;
        StackBuffer40[0] = 0;
        SystemEncryptionKey._0_4_ = (uint)SystemEncryptionKey & 0xffffff00;
        InitializeMemoryAllocator(&memoryAllocationBuffer,SystemResourceManager,0);
        (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
        ReleaseMemoryAllocator(&memoryAllocationBuffer);
        ResetMemoryAllocator(&memoryAllocationBuffer);
        CleanupMemoryAllocator(&memoryAllocationBuffer);
        localSystemPointer = SystemResourceManager[0x37];
      }
      if ((*(ulong long *)(localSystemPointer + 0x140) & resourceAllocationContext) != 0) goto LAB_18007738d;
    }
    SystemCalculatedBufferAddress = SystemResourceManager;
    if ((*(byte *)((long long)SystemResourceManager + 0xfd) & 0x20) == 0) {
      SystemCalculatedBufferAddress = (long long *)func_0x000180085de0(SystemResourceManager[0x36]);
    }
    if ((*(uint *)(SystemCalculatedBufferAddress + 0x20) & 0x8000000) != 0) {
      pEncryptionValue68 = (ulong long *)SystemResourceManager;
      (**(code **)(*SystemResourceManager + 0x28))(SystemResourceManager);
      memoryAllocationBuffer = (void* *)0x0;
      memoryAllocationEnd = (ulong long *)0x0;
      pEncryptionValue68 = &SystemEncryptionKey;
      SystemResourceStatusFlag = 0;
      StackBuffer40[0] = 0;
      SystemEncryptionKey._0_4_ = (uint)SystemEncryptionKey & 0xffffff00;
      InitializeMemoryAllocator(&memoryAllocationBuffer,SystemResourceManager,0);
      (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
      ValidateMemoryAllocator(&memoryAllocationBuffer);
      if (memoryAllocationEnd != (ulong long *)0x0) {
        if (SystemCharacter3 != '\0') {
          ProcessMemoryAllocation(memoryAllocationBuffer);
        }
        CleanupSystemResourceEncryption(&SystemEncryptionKey);
        if (SystemCharacter1 != '\0') {
          ExecuteSystemOperation(memoryAllocationBuffer);
        }
        if (SystemCharacter2 != '\0') {
          ExecuteSystemOperation(memoryAllocationBuffer);
        }
        SystemHashEntryPointer = memoryAllocationEnd;
        pEncryptionValue68 = memoryAllocationEnd;
        memoryAllocationEnd = (ulong long *)0x0;
        if (SystemHashEntryPointer != (ulong long *)0x0) {
          (**(code **)(*SystemHashEntryPointer + 0x38))();
        }
      }
      CleanupMemoryAllocator(&memoryAllocationBuffer);
    }
  }
LAB_18007738d:
    ValidateSystemChecksum(SystemMaxOperationCount ^ (ulong long)StackBuffer);
}




void* ConfigureSystemResourceData(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  uint *SystemDataPointer;
  long long *resourcePoolPointer;
  uint resourceAllocationContext;
  code *pSystemOperationStatusFlag;
  bool isMemoryReady;
  byte isThreadActive;
  char resourceStatusFlag;
  int systemCode;
  uint SystemOperationCounter;
  long long SystemAllocationFlags;
  long long SystemResourceDataIndex;
  long long resourceDataIndex2;
  long long resourceDataIndex3;
  ulong long SystemOperationStatus4;
  code *systemFunctionPointer5;
  bool isEntryAvailable;
  void* SystemUnsignedFlag78;
  uint32_t SystemProcessFlags70;
  uint32_t StackUnsignedValue6C;
  void*2 EncryptionValue68;
  uint8_t SystemByteFlag1;
  uint32_t StackUnsignedValue64;
  uint8_t SystemThreadContext;
  void* SystemProcessFlags58;
  long long LocalSystemValue1;
  void* SystemEncryptionKey;
  void* SystemOperationCounter;
  uint32_t SystemContextValue;
  void* SystemResourceStatusFlag;
  
  resourceDataIndex3 = SystemResourceManager;
  if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
    resourceDataIndex3 = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x1b8);
  isThreadActive = *(byte *)(resourceDataIndex2 + 0x38c);
  if (isThreadActive == 9) {
    isThreadActive = func_0x00018022d300();
    *(byte *)(resourceDataIndex2 + 0x38c) = isThreadActive;
  }
  if ((*(long long *)(resourceDataIndex3 + 0x1e0) == 0) ||
     (((resourceDataIndex2 = (ulong long)isThreadActive * 0x18,
       *(char *)(*(long long *)(resourceDataIndex3 + 0x1e0) + 0x15 + resourceDataIndex2) != '\x03' &&
       (*(char *)(*(long long *)(resourceDataIndex3 + 0x1e0) + 0x15 + resourceDataIndex2) != '\x04')) &&
      (*(char *)(*(long long *)(resourceDataIndex3 + 0x1e0) + resourceDataIndex2 + 0x15) != '\x02')))) {
    *(int *)(ConfigurationDataPointer + 0x124e8) = *(int *)(ConfigurationDataPointer + 0x124e8) + 1;
  }
  else if (*(char *)(*(long long *)(resourceDataIndex3 + 0x1e0) + resourceDataIndex2 + 0x15) != '\x04') {
    SystemUnsignedFlag78 = 0;
    SystemProcessFlags70 = 0;
    uStack_6c = 0xffffffff;
    EncryptionValue68 = 1;
    SystemByteFlag1 = 0;
    uStack_64 = 0xffffffff;
    SystemThreadContext = 1;
    SystemProcessFlags58 = 0;
    LocalSystemValue1 = 0;
    SystemEncryptionKey = 0;
    SystemOperationCounter = 0;
    SystemContextValue = 3;
    SystemResourceStatusFlag = 0;
    systemCode = ProcessSystemConfigurationData(*(void* *)(SystemResourceManager + 0x1b8),&SystemUnsignedFlag78);
    if (systemCode < 1) {
      if (LocalSystemValue1 != 0) {
          SystemCleanupFunction();
      }
      isMemoryReady = false;
      if ((*(byte *)(SystemResourceManager + 0xfd) & 8) != 0) {
        resourceDataIndex3 = 0xb8;
        systemFunctionPointer5 = (code *)&SystemFunctionEntryPointA;
        do {
          resourceDataIndex2 = *(long long *)(resourceDataIndex3 + *(long long *)(SystemResourceManager + 0x1b8));
          if (((resourceDataIndex2 != 0) && (SystemResourceDataIndex = *(long long *)(resourceDataIndex2 + 0x370), SystemResourceDataIndex != 0)) &&
             ((charBuffer = func_0x0001802434e0(), charBuffer != '\0' &&
              ((*(char *)(SystemResourceDataIndex + 0xde) != '\0' &&
               (isMemoryReady = true, (*(byte *)(ConfigurationDataPointer + 0x1bd8) & 0x20) != 0)))))) {
            pSystemOperationStatusFlag = *(code **)(**(long long **)(ConfigurationDataPointer + 0x3580) + 0xb8);
            if (pSystemOperationStatusFlag == systemFunctionPointer5) {
              SystemResourceDataIndex = (*(long long **)(ConfigurationDataPointer + 0x3580))[0xda];
            }
            else {
              SystemResourceDataIndex = (*pSystemOperationStatusFlag)();
            }
            SystemDataPointer = (uint *)(SystemResourceDataIndex + 0x3f68);
            LOCK();
            resourceAllocationContext = *SystemDataPointer;
            *SystemDataPointer = *SystemDataPointer + 1;
            UNLOCK();
            ThreadContextFlag = resourceAllocationContext >> 10;
            SystemOperationStatus4 = (ulong long)ThreadContextFlag;
            if (*(long long *)(SystemResourceDataIndex + 0x3f70 + (ulong long)ThreadContextFlag * 8) == 0) {
              SystemAllocationFlags = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
              resourcePoolPointer = (long long *)(SystemResourceDataIndex + 0x3f70 + SystemOperationStatus4 * 8);
              LOCK();
              isEntryAvailable = *resourcePoolPointer == 0;
              if (isEntryAvailable) {
                *resourcePoolPointer = SystemAllocationFlags;
              }
              UNLOCK();
              if (isEntryAvailable) {
                LOCK();
                *(uint8_t *)(SystemOperationStatus4 + 0x48 + (long long)SystemDataPointer) = 0;
                UNLOCK();
              }
              else {
                if (SystemAllocationFlags != 0) {
                    SystemCleanupFunction();
                }
                do {
                } while (*(char *)(SystemOperationStatus4 + 0x48 + (long long)SystemDataPointer) != '\0');
              }
            }
            else {
              do {
              } while (*(char *)(SystemOperationStatus4 + 0x48 + (long long)SystemDataPointer) != '\0');
            }
            *(long long *)
             (*(long long *)(SystemResourceDataIndex + 0x3f70 + SystemOperationStatus4 * 8) + (ulong long)(resourceAllocationContext + ThreadContextFlag * -0x400) * 8)
                 = resourceDataIndex2;
            systemFunctionPointer5 = (code *)&SystemFunctionEntryPointA;
          }
          resourceDataIndex3 = resourceDataIndex3 + 8;
        } while (resourceDataIndex3 < 0x138);
        if (isMemoryReady) {
          return 0;
        }
      }
      *(byte *)(SystemResourceManager + 0xfe) = *(byte *)(SystemResourceManager + 0xfe) | 4;
      return 1;
    }
    if (LocalSystemValue1 != 0) {
        SystemCleanupFunction();
    }
  }
  return 0;
}




/**
 * @brief 重置系统资源管理器状态
 * 
 * 该函数负责重置系统资源管理器的状态，将其恢复到初始状态。
 * 它会清理当前的资源状态，但不会释放管理器本身。
 * 
 * @param SystemResourceManager 系统资源管理器指针，指向要重置的资源管理器
 * @note 这是系统资源状态重置的核心函数
 */
void ResetSystemResourceManagerState(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  long long ResourceDataOffset;
  ulong long resourceAddress;
  
  SystemHashEntryPointer = *(void* **)(SystemResourceManager + 0x28);
  if (SystemHashEntryPointer == (void* *)0x0) {
    return;
  }
  SystemMemoryBaseAddress = (ulong long)SystemHashEntryPointer & MAX_UNSIGNED_32_BITffc00000;
  if (SystemMemoryBaseAddress != 0) {
    ResourceDataOffset = SystemMemoryBaseAddress + 0x80 + ((long long)SystemHashEntryPointer - SystemMemoryBaseAddress >> 0x10) * 0x50;
    ResourceDataOffset = ResourceDataOffset - (ulong long)*(uint *)(ResourceDataOffset + 4);
    if ((*(void ***)(resourceAddress + 0x70) == &ExceptionList) && (*(char *)(ResourceDataOffset + 0xe) == '\0')) {
      *SystemHashEntryPointer = *(void* *)(ResourceDataOffset + 0x20);
      *(void* **)(ResourceDataOffset + 0x20) = SystemHashEntryPointer;
      SystemIntegerPointer = (int *)(ResourceDataOffset + 0x18);
      *SystemIntegerPointer = *SystemIntegerPointer + -1;
      if (*SystemIntegerPointer == 0) {
        ReleaseSystemResource();
        return;
      }
    }
    else {
      SystemExceptionCheck(resourceAddress,CONCAT71(0xff000000,*(void ***)(resourceAddress + 0x70) == &ExceptionList),
                          SystemHashEntryPointer,resourceAddress,InvalidHandleValue);
    }
  }
  return;
}




/**
 * @brief 处理系统资源管理和配置操作
 * 
 * 该函数负责系统资源的复杂管理操作，包括：
 * - 系统资源管理器的配置和初始化
 * - 线程上下文的管理和同步
 * - 哈希表节点的创建和维护
 * - 系统安全参数的设置和验证
 * - 资源分配和内存管理
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志
 * @param SystemConfigurationParameter 系统配置参数
 * @return 操作结果状态码
 */
ulong long ProcessSystemResourceManagement(long long SystemResourceManager, uint *ConfigurationDataPointer, float *AdditionalParameter, long long ConfigurationFlag,
                                        long long SystemConfigurationParameter)

{
  float CalculatedValue1;
  float CalculatedValue2;
  float CalculatedValue3;
  float CalculatedValue4;
  float BaseValue;
  uint ResourceHash;
  uint32_t ThreadContextFlag;
  uint32_t OperationCode;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  float InterpolationParam2;
  float InterpolationParam3;
  float InterpolationParam4;
  float InterpolationParam5;
  float MagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  char StatusCharacter;
  byte SystemActiveFlag;
  uint32_t InitializationFlags;
  void* ConfigurationData;
  ulong long SecurityParameter;
  void* *HashEntryPointer;
  long long ThreadHandle1;
  long long ThreadHandle2;
  uint32_t *HashEntryPointer2;
  uint *HashNodeData;
  byte OperationCompleteFlag;
  char *CharacterFlag;
  int SystemCounter;
  ulong long AllocationContext;
  uint *HashNodeData2;
  bool IsOperationComplete;
  uint32_t StackBuffer1 [2];
  uint *StackPointer1;
  float *FloatPointer1;
  long long StackValue1;
  uint32_t StackBuffer2 [2];
  ulong long StackValue2;
  void* *MemoryOffsetArray [2];
  long long StackValue3;
  void* EncryptionOffset1;
  void* EncryptionOffset2;
  void* MemoryBufferAddress;
  void* StackPointerF0;
  void* StackPointerE8;
  void* StackPointerE0;
  void* SystemMemoryAllocatorStatus;
  void* StackPointerD0;
  float fStack_c8;
  float fStack_c4;
  float fStack_c0;
  float fStack_bc;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  float fStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  float fStack_9c;
  float fStack_98;
  float fStack_94;
  float fStack_90;
  float fStack_8c;
  
  StackPointer1 = ConfigurationDataPointer;
  FloatPointer1 = AdditionalParameter;
  StackValue1 = ConfigurationFlag;
  if (*(char *)(SystemResourceManager + 0xf9) == '\0') {
    ConfigurationData = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xc0,8,9);
    ConfigurationData = ProcessConfigurationData(ConfigurationData);
    *(void* *)(SystemResourceManager + 0x1d8) = ConfigurationData;
    LOCK();
    *(uint8_t *)(SystemResourceManager + 0xf9) = 1;
    UNLOCK();
  }
  if ((char)*(byte *)(SystemResourceManager + 0xfd) < '\0') {
    ThreadHandle1 = *(long long *)(SystemResourceManager + 0x1b8);
    ConfigurationData = *(void* *)(ThreadHandle1 + 0x290);
    *(void* *)(SystemResourceManager + 0x2a8) = *(void* *)(ThreadHandle1 + 0x288);
    *(void* *)(SystemResourceManager + 0x2b0) = ConfigurationData;
    InitializationFlags = *(uint32_t *)(ThreadHandle1 + 0x29c);
    ThreadContextFlag = *(uint32_t *)(ThreadHandle1 + 0x2a0);
    OperationCode = *(uint32_t *)(ThreadHandle1 + 0x2a4);
    *(uint32_t *)(SystemResourceManager + 0x2b8) = *(uint32_t *)(ThreadHandle1 + 0x298);
    *(uint32_t *)(SystemResourceManager + 700) = InitializationFlags;
    *(uint32_t *)(SystemResourceManager + 0x2c0) = ThreadContextFlag;
    *(uint32_t *)(SystemResourceManager + 0x2c4) = OperationCode;
  }
  SecurityParameter = (ulong long)*(uint *)(SystemResourceManager + 0x270);
  if ((*ConfigurationDataPointer & *(uint *)(SystemResourceManager + 0x270)) == 0) goto SystemSecurityValidationFailed;
  OperationCompleteFlag = *(byte *)(SystemResourceManager + 0xfd) & 0x20;
  ThreadHandle1 = SystemResourceManager;
  if (OperationCompleteFlag == 0) {
    ThreadHandle1 = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  if (*(int *)(ThreadHandle1 + 0x200) == 0) {
SystemResourceValidationPoint:
    if ((*(byte *)(SystemResourceManager + 0x100) & 4) != 0) goto SystemResourceProcessingComplete;
    ThreadHandle1 = *(long long *)(SystemResourceManager + 0x1b8);
    SecurityParameter = 0;
    if (*(char *)(ThreadHandle1 + 0x38c) == '\t') {
      SecurityParameter = func_0x00018022d300();
      *(char *)(ThreadHandle1 + 0x38c) = (char)SecurityParameter;
      if ((char)SecurityParameter == '\t') goto SystemResourceProcessingComplete;
    }
SystemSecurityValidationFailed:
    SecurityParameter = SecurityParameter & MAX_UNSIGNED_32_BITffffff00;
  }
  else {
    ThreadHandle1 = SystemResourceManager;
    if (OperationCompleteFlag == 0) {
      ThreadHandle1 = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
    }
    if (*(int *)(ThreadHandle1 + 0x1fc) * 3 == 0) goto SystemResourceValidationPoint;
SystemResourceProcessingComplete:
    SystemOperationResult1 = func_0x0001800854e0(SystemResourceManager);
    if ((SystemOperationResult1 == '\0') || (ConfigurationFlag == 0)) {
      ReleaseSystemResourceManager(SystemResourceManager,0);
      if ((*(byte *)(SystemResourceManager + 0xfe) & 4) == 0) {
        ConfigurationData = ConfigureSystemResourceManagerExtended(SystemResourceManager,ConfigurationDataPointer);
        OperationCompleteFlag = (char)ConfigurationData << 2;
        SystemActiveFlag = OperationCompleteFlag | *(byte *)(SystemResourceManager + 0xfe) & 0xfb;
        SecurityParameter = CONCAT71((int7)((ulong long)ConfigurationData >> 8),SystemActiveFlag);
        *(byte *)(SystemResourceManager + 0xfe) = SystemActiveFlag;
        if ((OperationCompleteFlag & 4) == 0) goto FUN_180077ef9;
      }
      ResourceHash = *(uint *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x388);
      if (((ResourceHash >> 0x19 & 1) != 0) ||
         ((*(long long *)(SystemResourceManager + 600) != 0 && (0 < *(int *)(*(long long *)(SystemResourceManager + 600) + 0x1c)))
         )) {
        SystemCounter = *(int *)(SystemGlobalStatusFlags + 0x224);
        HashEntryPointer = *(void* **)(SystemResourceManager + 600);
        if (HashEntryPointer == (void* *)0x0) {
          HashEntryPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,3);
          *(void* *)((long long)HashEntryPointer + 0x2c) = 0xffffffffffffffff;
          *(uint32_t *)(HashEntryPointer + 9) = 0xffffffff;
          *HashEntryPointer = 0;
          HashEntryPointer[2] = 0;
          HashEntryPointer[7] = 0;
          *(uint32_t *)(HashEntryPointer + 5) = 0xffffffff;
          *(uint32_t *)(HashEntryPointer + 4) = 0xffffffff;
          HashEntryPointer[3] = 0;
          *(uint32_t *)(HashEntryPointer + 8) = 0;
          *(uint32_t *)(HashEntryPointer + 1) = 0;
          *(uint8_t *)((long long)HashEntryPointer + 0x44) = 0;
          *(uint8_t *)((long long)HashEntryPointer + 0x24) = 0;
          *(void* **)(SystemResourceManager + 600) = HashEntryPointer;
        }
        AdditionalParameter = FloatPointer1;
        if (*(int *)(HashEntryPointer + 4) != SystemCounter) {
          *(int *)(HashEntryPointer + 4) = SystemCounter;
          ProcessSystemResourceConfiguration(SystemResourceManager,systemConfigurationParameter);
          AdditionalParameter = FloatPointer1;
          if (((byte)(ResourceHash >> 0x19) & 1) != 0) {
            if ((*(uint *)(SystemResourceManager + 0x100) & 0x800) != 0) {
              CleanupSystemResourceManagerData(SystemResourceManager);
            }
            StackValue3 = SystemDataMemoryContext + 0x5868;
            HashNodeData = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0x6a78) * 0x908 + StackValue3);
            LOCK();
            ResourceHash = *HashNodeData;
            *HashNodeData = *HashNodeData + 1;
            UNLOCK();
            SecurityParameter = (ulong long)(ResourceHash >> 9);
            AllocationContext = (ulong long)(ResourceHash >> 9);
            CharacterFlag = (char *)((long long)HashNodeData + AllocationContext + 0x808);
            HashNodeData2 = HashNodeData + (SecurityParameter + 1) * 2;
            StackValue2 = SecurityParameter;
            do {
              SystemCounter = (int)AllocationContext;
              if (*(long long *)HashNodeData2 == 0) {
                ThreadHandle1 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0xc000,0x25);
                LOCK();
                IsOperationComplete = *(long long *)(HashNodeData + (long long)SystemCounter * 2 + 2) == 0;
                if (IsOperationComplete) {
                  *(long long *)(HashNodeData + (long long)SystemCounter * 2 + 2) = ThreadHandle1;
                }
                UNLOCK();
                if (IsOperationComplete) {
                  ProcessSystemHashNodeData(HashNodeData,SystemCounter << 9);
                  LOCK();
                  *(uint8_t *)((long long)HashNodeData + (long long)SystemCounter + 0x808) = 0;
                  UNLOCK();
                  SecurityParameter = StackValue2;
                }
                else {
                  if (ThreadHandle1 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                    SecurityParameter = StackValue2;
                  } while (*CharacterFlag != '\0');
                }
              }
              else {
                do {
                } while (*CharacterFlag != '\0');
              }
              CharacterFlag = CharacterFlag + 1;
              AllocationContext = (ulong long)(SystemCounter + 1);
              HashNodeData2 = HashNodeData2 + 2;
            } while ((long long)(CharacterFlag + (-0x808 - (long long)HashNodeData)) <= (long long)SecurityParameter);
            HashEntryPointer = (void* *)
                      (*(long long *)
                        ((long long)*(int *)(StackValue3 + 0x1210) * 0x908 + StackValue3 + 8 +
                        SecurityParameter * 8) + (ulong long)(ResourceHash - (ResourceHash & 0xfffffe00)) * 0x60);
            ThreadHandle1 = SystemResourceManager;
            MemoryOffsetArray[0] = HashEntryPointer;
            if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
              ThreadHandle1 = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
            }
            ThreadHandle2 = *(long long *)(SystemResourceManager + 0x1b8);
            OperationCompleteFlag = *(byte *)(ThreadHandle2 + 0x38c);
            if (OperationCompleteFlag == 9) {
              OperationCompleteFlag = func_0x00018022d300();
              *(byte *)(ThreadHandle2 + 0x38c) = OperationCompleteFlag;
            }
            ConfigurationDataPointer = StackPointer1;
            ThreadHandle1 = *(long long *)(ThreadHandle1 + 0x1e0);
            *HashEntryPointer = *(void* *)(ThreadHandle1 + (ulong long)OperationCompleteFlag * 0x18);
            HashEntryPointer[1] = *(void* *)(ThreadHandle1 + 8 + (ulong long)OperationCompleteFlag * 0x18);
            *(uint32_t *)(MemoryOffsetArray[0] + 2) =
                 *(uint32_t *)(*(long long *)(SystemResourceManager + 600) + 0x2c);
            *(uint32_t *)((long long)MemoryOffsetArray[0] + 0x14) =
                 *(uint32_t *)(*(long long *)(SystemResourceManager + 600) + 0x4c);
            *(int *)(MemoryOffsetArray[0] + 9) = (int)*(char *)(*(long long *)(SystemResourceManager + 600) + 0x44);
            if ((*(long long *)(SystemResourceManager + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x14) == 0)) {
              InitializationFlags = 0xffffffff;
            }
            else {
              InitializationFlags = *(uint32_t *)(SystemResourceManager + 0x108);
            }
            *(uint32_t *)(MemoryOffsetArray[0] + 3) = InitializationFlags;
            if ((*(long long *)(SystemResourceManager + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x14) == 0)) {
              InitializationFlags = 0xffffffff;
            }
            else {
              InitializationFlags = *(uint32_t *)(SystemResourceManager + 0x10c);
            }
            *(uint32_t *)((long long)MemoryOffsetArray[0] + 0x1c) = InitializationFlags;
            if ((*(long long *)(SystemResourceManager + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x14) == 0)) {
              InitializationFlags = 0xffffffff;
            }
            else {
              InitializationFlags = *(uint32_t *)(SystemResourceManager + 0x110);
            }
            *(uint32_t *)(MemoryOffsetArray[0] + 4) = InitializationFlags;
            *(byte *)((long long)MemoryOffsetArray[0] + 0x4e) = *(byte *)(SystemResourceManager + 0xfe) >> 3 & 1;
            if (*(int *)(SystemResourceManager + 0x108) != -1) {
              HashEntryPointer2 = *(uint32_t **)(SystemResourceManager + 0x2d0);
              InitializationFlags = HashEntryPointer2[1];
              ThreadContextFlag = HashEntryPointer2[2];
              OperationCode = HashEntryPointer2[3];
              *(uint32_t *)(MemoryOffsetArray[0] + 5) = *HashEntryPointer2;
              *(uint32_t *)((long long)MemoryOffsetArray[0] + 0x2c) = InitializationFlags;
              *(uint32_t *)(MemoryOffsetArray[0] + 6) = ThreadContextFlag;
              *(uint32_t *)((long long)MemoryOffsetArray[0] + 0x34) = OperationCode;
              ConfigurationData = *(void* *)(HashEntryPointer2 + 6);
              MemoryOffsetArray[0][7] = *(void* *)(HashEntryPointer2 + 4);
              MemoryOffsetArray[0][8] = ConfigurationData;
            }
            *(uint8_t *)((long long)MemoryOffsetArray[0] + 0x4f) =
                 *(uint8_t *)(*(long long *)(SystemResourceManager + 600) + 0x24);
            ThreadHandle1 = *(long long *)(SystemResourceManager + 600);
            if (*(char *)(ThreadHandle1 + 0x24) != '\0') {
              InitializationFlags = *(uint32_t *)(SystemResourceManager + 0x2ac);
              ThreadContextFlag = *(uint32_t *)(SystemResourceManager + 0x2b0);
              OperationCode = *(uint32_t *)(SystemResourceManager + 0x2b4);
              *(uint32_t *)(MemoryOffsetArray[0] + 10) = *(uint32_t *)(SystemResourceManager + 0x2a8);
              *(uint32_t *)((long long)MemoryOffsetArray[0] + 0x54) = InitializationFlags;
              *(uint32_t *)(MemoryOffsetArray[0] + 0xb) = ThreadContextFlag;
              *(uint32_t *)((long long)MemoryOffsetArray[0] + 0x5c) = OperationCode;
              ThreadHandle1 = *(long long *)(SystemResourceManager + 600);
            }
            *(bool *)((long long)MemoryOffsetArray[0] + 0x4c) = *(long long *)(ThreadHandle1 + 0x10) != 0;
            *(uint8_t *)((long long)MemoryOffsetArray[0] + 0x4d) = 1;
            if ((*(char *)(systemConfigurationParameter + 0xc) != '\0') ||
               (0 < *(int *)(*(long long *)(SystemResourceManager + 600) + 0x1c))) {
              *(uint8_t *)((long long)MemoryOffsetArray[0] + 0x4d) = 0;
            }
            if (*(uint **)(StackPointer1 + 10) == (uint *)0x0) {
              StackBuffer2[0] = 0xffffffff;
              HashEntryPointer2 = StackBuffer2;
              HashNodeData2 = StackPointer1;
            }
            else {
              StackBuffer1[0] = 0xffffffff;
              HashEntryPointer2 = StackBuffer1;
              HashNodeData2 = *(uint **)(StackPointer1 + 10);
            }
            ProcessSystemMemoryAllocation(HashNodeData2 + 0xce2,HashEntryPointer2,MemoryOffsetArray);
            AdditionalParameter = FloatPointer1;
            ConfigurationFlag = StackValue1;
          }
        }
      }
    }
    if ((*(uint *)(SystemResourceManager + 0x100) & 0x4000000) != 0) {
      ScaleValue = *AdditionalParameter;
      ScalingFactor = AdditionalParameter[1];
      OffsetValue = AdditionalParameter[2];
      RatioValue = AdditionalParameter[3];
      InterpolationParam1 = AdditionalParameter[4];
      InterpolationParam2 = AdditionalParameter[5];
      scaleResult1 = AdditionalParameter[6];
      InterpolationParam4 = AdditionalParameter[7];
      InterpolationParam5 = AdditionalParameter[8];
      MagnitudeSquared = AdditionalParameter[9];
      ResultValue1 = AdditionalParameter[10];
      ResultValue2 = AdditionalParameter[0xb];
      floatValue1 = *(float *)(SystemResourceManager + 0x124);
      floatValue2 = *(float *)(SystemResourceManager + 0x120);
      floatValue3 = *(float *)(SystemResourceManager + 0x128);
      floatValue4 = *(float *)(SystemResourceManager + 0x134);
      BaseValue = *(float *)(SystemResourceManager + 0x130);
      fStack_c8 = floatValue1 * InterpolationParam1 + floatValue2 * ScaleValue + floatValue3 * InterpolationParam5;
      fStack_c4 = floatValue1 * InterpolationParam2 + floatValue2 * ScalingFactor + floatValue3 * MagnitudeSquared;
      fStack_c0 = floatValue1 * InterpolationParam3 + floatValue2 * OffsetValue + floatValue3 * ResultValue1;
      fStack_bc = floatValue1 * InterpolationParam4 + floatValue2 * RatioValue + floatValue3 * ResultValue2;
      floatValue1 = *(float *)(SystemResourceManager + 0x138);
      floatValue2 = *(float *)(SystemResourceManager + 0x140);
      floatValue3 = *(float *)(SystemResourceManager + 0x144);
      fStack_b8 = floatValue4 * InterpolationParam1 + BaseValue * ScaleValue + floatValue1 * InterpolationParam5;
      fStack_b4 = floatValue4 * InterpolationParam2 + BaseValue * ScalingFactor + floatValue1 * MagnitudeSquared;
      fStack_b0 = floatValue4 * InterpolationParam3 + BaseValue * OffsetValue + floatValue1 * ResultValue1;
      fStack_ac = floatValue4 * InterpolationParam4 + BaseValue * RatioValue + floatValue1 * ResultValue2;
      floatValue1 = *(float *)(SystemResourceManager + 0x148);
      floatValue4 = *(float *)(SystemResourceManager + 0x154);
      BaseValue = *(float *)(SystemResourceManager + 0x150);
      fStack_a8 = floatValue3 * InterpolationParam1 + floatValue2 * ScaleValue + floatValue1 * InterpolationParam5;
      fStack_a4 = floatValue3 * InterpolationParam2 + floatValue2 * ScalingFactor + floatValue1 * MagnitudeSquared;
      fStack_a0 = floatValue3 * InterpolationParam3 + floatValue2 * OffsetValue + floatValue1 * ResultValue1;
      fStack_9c = floatValue3 * InterpolationParam4 + floatValue2 * RatioValue + floatValue1 * ResultValue2;
      floatValue1 = *(float *)(SystemResourceManager + 0x158);
      fStack_98 = floatValue4 * InterpolationParam1 + BaseValue * ScaleValue + floatValue1 * InterpolationParam5 + AdditionalParameter[0xc];
      fStack_94 = floatValue4 * InterpolationParam2 + BaseValue * ScalingFactor + floatValue1 * MagnitudeSquared + AdditionalParameter[0xd];
      fStack_90 = floatValue4 * InterpolationParam3 + BaseValue * OffsetValue + floatValue1 * ResultValue1 + AdditionalParameter[0xe];
      fStack_8c = floatValue4 * InterpolationParam4 + BaseValue * RatioValue + floatValue1 * ResultValue2 + AdditionalParameter[0xf];
      AdditionalParameter = &fStack_c8;
    }
    InitializeSystemEncryptionParameters(&EncryptionOffset1,ConfigurationDataPointer + 0xc,*(uint8_t *)(SystemResourceManager + 0xf7),AdditionalParameter);
    ResourceHash = ConfigurationDataPointer[0x6f6];
    SystemCounter = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (((*(byte *)(SystemResourceManager + 0xfd) & 1) == 0) &&
       ((*(int *)(SystemResourceManager + 0x1d0) == SystemCounter || (*(int *)(SystemResourceManager + 0x1d0) == SystemCounter + -1)))) {
      OperationCompleteFlag = 0;
    }
    else {
      OperationCompleteFlag = 1;
    }
    *(byte *)(SystemResourceManager + 0xfd) = *(byte *)(SystemResourceManager + 0xfd) & 0xfe | OperationCompleteFlag;
    SystemActiveFlag = (byte)ResourceHash & 0x20;
    if ((SystemActiveFlag != 0) && (OperationCompleteFlag != 0)) {
      *(void* *)(SystemResourceManager + 0x160) = EncryptionOffset1;
      *(void* *)(SystemResourceManager + 0x168) = EncryptionOffset2;
      *(void* *)(SystemResourceManager + 0x170) = MemoryBufferAddress;
      *(void* *)(SystemResourceManager + 0x178) = SystemResourceDataIndex;
      *(void* *)(SystemResourceManager + 0x180) = uStack_e8;
      *(void* *)(SystemResourceManager + 0x188) = uStack_e0;
      *(void* *)(SystemResourceManager + 400) = SystemMemoryAllocatorStatus;
      *(void* *)(SystemResourceManager + 0x198) = uStack_d0;
    }
    SecurityParameter = ValidateSystemSecurityConfiguration(ConfigurationDataPointer,SystemResourceManager,&EncryptionOffset1,ConfigurationFlag,systemConfigurationParameter);
    *(byte *)(SystemResourceManager + 0xfd) = *(byte *)(SystemResourceManager + 0xfd) & 0xfe;
    *(int *)(SystemResourceManager + 0x1d0) = SystemCounter;
    if (SystemActiveFlag != 0) {
      *(void* *)(SystemResourceManager + 0x160) = EncryptionOffset1;
      *(void* *)(SystemResourceManager + 0x168) = EncryptionOffset2;
      *(void* *)(SystemResourceManager + 0x170) = MemoryBufferAddress;
      *(void* *)(SystemResourceManager + 0x178) = SystemResourceDataIndex;
      *(void* *)(SystemResourceManager + 0x180) = uStack_e8;
      *(void* *)(SystemResourceManager + 0x188) = uStack_e0;
      *(void* *)(SystemResourceManager + 400) = SystemMemoryAllocatorStatus;
      *(void* *)(SystemResourceManager + 0x198) = uStack_d0;
    }
  }
  return SecurityParameter;
}





/**
 * @brief 系统资源管理和线程初始化函数
 * 
 * 该函数负责系统资源的分配、管理和线程初始化操作。
 * 主要功能包括：
 * - 系统内存池的分配和管理
 * - 线程对象的创建和初始化
 * - 系统资源状态的检查和更新
 * - 哈希节点的管理和同步
 * 
 * @return 无返回值
 * 
 *FUN_18007799c：SystemNoOperationA
 */
void SystemNoOperationA(void)

{
  uint SystemOperationStatus;
  float CalculatedValue2;
  float CalculatedValue3;
  float CalculatedValue4;
  float BaseValue;
  float floatValue6;
  uint32_t ThreadContextFlag;
  uint32_t OperationCode;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  float InterpolationParam2;
  float InterpolationParam3;
  float InterpolationParam4;
  float InterpolationParam5;
  float MagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  void* ThreadCreationFlags;
  void* MemoryAllocationFlags;
  void* InitializationFlags;
  void* ConfigurationData;
  void* SecurityParameter;
  void* NetworkConnectionFlags;
  void* resourceCreationFlags7;
  void* resourceCreationFlags8;
  byte isSystemActive9;
  byte isOperationComplete0;
  uint32_t resourceAllocationContext1;
  ulong long resourceAllocationContext2;
  long long ResourceDataOffset3;
  long long ResourceDataOffset4;
  uint32_t *HashNodeData2;
  long long memoryBlockAddress;
  uint *SystemHashNodeData6;
  char *pcharFlag7;
  void* *SystemHashNodeData8;
  float *pfloatValue39;
  int systemAllocationOffsetD;
  int systemIndex0;
  ulong long resourceAddress1;
  uint *presourceAddress2;
  bool in_ZF;
  bool isResourceAvailable3;
  uint32_t InputStackParameter30;
  ulong long InputStackParameter38;
  void* *InputStackParameter40;
  long long InputStackParameter50;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float FloatStackArray[16];
  uint32_t ResourceFlags[8];
  uint32_t ThreadCreationFlags;
  long long ResourceOffset;
  float *FloatParameterArray;
  void* ThreadParameter;
  long long SystemMemoryOffset;
  
  if (!in_ZF) {
    InitializeSystemEnvironment();
  }
  InputStackParameter50 = SystemDataMemoryContext + 0x5868;
  SystemHashNodeData6 = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0x6a78) * 0x908 + InputStackParameter50);
  LOCK();
  SystemOperationStatus = *SystemHashNodeData6;
  *SystemHashNodeData6 = *SystemHashNodeData6 + systemAllocationOffsetD;
  UNLOCK();
  resourceAllocationContext2 = (ulong long)(SystemOperationStatus >> 9);
  resourceAddress1 = (ulong long)(SystemOperationStatus >> 9);
  pcharFlag7 = (char *)((long long)SystemHashNodeData6 + resourceAddress1 + 0x808);
  presourceAddress2 = SystemHashNodeData6 + (resourceAllocationContext2 + 1) * 2;
  InputStackParameter38 = resourceAllocationContext2;
  do {
    systemIndex0 = (int)resourceAddress1;
    if (*(long long *)presourceAddress2 == 0) {
      ResourceDataOffset3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0xc000,0x25);
      LOCK();
      isResourceAvailable3 = *(long long *)(SystemHashNodeData6 + (long long)systemIndex0 * 2 + 2) == 0;
      if (isResourceAvailable3) {
        *(long long *)(SystemHashNodeData6 + (long long)systemIndex0 * 2 + 2) = ResourceDataOffset3;
      }
      UNLOCK();
      if (isResourceAvailable3) {
        ProcessHashNodeData(SystemHashNodeData6,systemIndex0 << 9);
        LOCK();
        *(uint8_t *)((long long)SystemHashNodeData6 + (long long)systemIndex0 + 0x808) = 0;
        UNLOCK();
        resourceAllocationContext2 = InputStackParameter38;
      }
      else {
        if (ResourceDataOffset3 != 0) {
            SystemCleanupFunction();
        }
        do {
          resourceAllocationContext2 = InputStackParameter38;
        } while (*pcharFlag7 != '\0');
      }
    }
    else {
      do {
      } while (*pcharFlag7 != '\0');
    }
    pcharFlag7 = pcharFlag7 + 1;
    resourceAddress1 = (ulong long)(systemIndex0 + 1);
    presourceAddress2 = presourceAddress2 + 2;
  } while ((long long)(pcharFlag7 + (-0x808 - (long long)SystemHashNodeData6)) <= (long long)resourceAllocationContext2);
  SystemHashNodeData8 = (void* *)
            (*(long long *)
              ((long long)*(int *)(InputStackParameter50 + 0x1210) * 0x908 + InputStackParameter50 + 8 +
              resourceAllocationContext2 * 8) + (ulong long)(SystemOperationStatus - (SystemOperationStatus & 0xfffffe00)) * 0x60);
  ResourceDataOffset3 = memoryBlockAddress;
  InputStackParameter40 = SystemHashNodeData8;
  if ((*(byte *)(memoryBlockAddress + 0xfd) & 0x20) == 0) {
    ResourceDataOffset3 = func_0x000180085de0(*(void* *)(memoryBlockAddress + 0x1b0));
  }
  ResourceDataOffset4 = *(long long *)(memoryBlockAddress + 0x1b8);
  isSystemActive9 = *(byte *)(ResourceDataOffset4 + 0x38c);
  if (isSystemActive9 == 9) {
    isSystemActive9 = func_0x00018022d300();
    *(byte *)(ResourceDataOffset4 + 0x38c) = isSystemActive9;
  }
  ResourceDataOffset4 = ResourceOffset;
  ResourceDataOffset3 = *(long long *)(ResourceDataOffset3 + 0x1e0);
  *SystemHashNodeData8 = *(void* *)(ResourceDataOffset3 + (ulong long)isSystemActive9 * 0x18);
  SystemHashNodeData8[1] = *(void* *)(ResourceDataOffset3 + 8 + (ulong long)isSystemActive9 * 0x18);
  *(uint32_t *)(InputStackParameter40 + 2) = *(uint32_t *)(*(long long *)(memoryBlockAddress + 600) + 0x2c);
  *(uint32_t *)((long long)InputStackParameter40 + 0x14) =
       *(uint32_t *)(*(long long *)(memoryBlockAddress + 600) + 0x4c);
  *(int *)(InputStackParameter40 + 9) = (int)*(char *)(*(long long *)(memoryBlockAddress + 600) + 0x44);
  if ((*(long long *)(memoryBlockAddress + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) == 0)) {
    resourceAllocationContext1 = 0xffffffff;
  }
  else {
    resourceAllocationContext1 = *(uint32_t *)(memoryBlockAddress + 0x108);
  }
  *(uint32_t *)(InputStackParameter40 + 3) = resourceAllocationContext1;
  if ((*(long long *)(memoryBlockAddress + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) == 0)) {
    resourceAllocationContext1 = 0xffffffff;
  }
  else {
    resourceAllocationContext1 = *(uint32_t *)(memoryBlockAddress + 0x10c);
  }
  *(uint32_t *)((long long)InputStackParameter40 + 0x1c) = resourceAllocationContext1;
  if ((*(long long *)(memoryBlockAddress + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) == 0)) {
    resourceAllocationContext1 = 0xffffffff;
  }
  else {
    resourceAllocationContext1 = *(uint32_t *)(memoryBlockAddress + 0x110);
  }
  *(uint32_t *)(InputStackParameter40 + 4) = resourceAllocationContext1;
  *(byte *)((long long)InputStackParameter40 + 0x4e) = *(byte *)(memoryBlockAddress + 0xfe) >> 3 & 1;
  if (*(int *)(memoryBlockAddress + 0x108) != -1) {
    HashNodeData2 = *(uint32_t **)(memoryBlockAddress + 0x2d0);
    resourceAllocationContext1 = HashNodeData2[1];
    ThreadContextFlag = HashNodeData2[2];
    OperationCode = HashNodeData2[3];
    *(uint32_t *)(InputStackParameter40 + 5) = *HashNodeData2;
    *(uint32_t *)((long long)InputStackParameter40 + 0x2c) = resourceAllocationContext1;
    *(uint32_t *)(InputStackParameter40 + 6) = ThreadContextFlag;
    *(uint32_t *)((long long)InputStackParameter40 + 0x34) = OperationCode;
    ThreadCreationFlags = *(void* *)(HashNodeData2 + 6);
    InputStackParameter40[7] = *(void* *)(HashNodeData2 + 4);
    InputStackParameter40[8] = ThreadCreationFlags;
  }
  *(uint8_t *)((long long)InputStackParameter40 + 0x4f) =
       *(uint8_t *)(*(long long *)(memoryBlockAddress + 600) + 0x24);
  ResourceDataOffset3 = *(long long *)(memoryBlockAddress + 600);
  if (*(char *)(ResourceDataOffset3 + 0x24) != '\0') {
    resourceAllocationContext1 = *(uint32_t *)(memoryBlockAddress + 0x2ac);
    ThreadContextFlag = *(uint32_t *)(memoryBlockAddress + 0x2b0);
    OperationCode = *(uint32_t *)(memoryBlockAddress + 0x2b4);
    *(uint32_t *)(InputStackParameter40 + 10) = *(uint32_t *)(memoryBlockAddress + 0x2a8);
    *(uint32_t *)((long long)InputStackParameter40 + 0x54) = resourceAllocationContext1;
    *(uint32_t *)(InputStackParameter40 + 0xb) = ThreadContextFlag;
    *(uint32_t *)((long long)InputStackParameter40 + 0x5c) = OperationCode;
    ResourceDataOffset3 = *(long long *)(memoryBlockAddress + 600);
  }
  *(bool *)((long long)InputStackParameter40 + 0x4c) = *(long long *)(ResourceDataOffset3 + 0x10) != 0;
  *(uint8_t *)((long long)InputStackParameter40 + 0x4d) = 1;
  if ((*(char *)(SystemMemoryOffset + 0xc) != '\0') ||
     (0 < *(int *)(*(long long *)(memoryBlockAddress + 600) + 0x1c))) {
    *(uint8_t *)((long long)InputStackParameter40 + 0x4d) = 0;
  }
  if (*(long long *)(ResourceOffset + 0x28) == 0) {
    InputStackParameter30 = 0xffffffff;
    HashNodeData2 = &StackBuffer30;
    ResourceDataOffset3 = ResourceOffset;
  }
  else {
    ThreadCreationFlags = 0xffffffff;
    HashNodeData2 = &stackBuffer170;
    ResourceDataOffset3 = *(long long *)(ResourceOffset + 0x28);
  }
  ProcessSystemResourceDataAllocation(ResourceDataOffset3 + 0x3388,HashNodeData2,&StackBuffer40);
  pfloatValue39 = FloatParameterArray;
  if ((*(uint *)(memoryBlockAddress + 0x100) & 0x4000000) != 0) {
    FloatVectorFirstComponent = *FloatParameterArray;
    FloatVectorSecondComponent = FloatParameterArray[1];
    FloatVectorThirdComponent = FloatParameterArray[2];
    FloatVectorFourthComponent = FloatParameterArray[3];
    InterpolationFactorX = FloatParameterArray[4];
    InterpolationFactorY = FloatParameterArray[5];
    InterpolationFactorZ = FloatParameterArray[6];
    InterpolationFactorW = FloatParameterArray[7];
    MagnitudeSquared = FloatParameterArray[8];
    FloatVectorNinthComponent = FloatParameterArray[9];
    FloatVectorTenthComponent = FloatParameterArray[10];
    floatValue2 = *(float *)(memoryBlockAddress + 0x124);
    floatValue3 = *(float *)(memoryBlockAddress + 0x120);
    floatValue4 = *(float *)(memoryBlockAddress + 0x128);
    BaseValue = *(float *)(memoryBlockAddress + 0x134);
    floatValue6 = *(float *)(memoryBlockAddress + 0x130);
    FloatTransformA0 = floatValue2 * InterpolationFactorX + floatValue3 * FloatVectorFirstComponent + floatValue4 * InterpolationFactorW;
    FloatTransformA4 = floatValue2 * InterpolationFactorY + floatValue3 * FloatVectorSecondComponent + floatValue4 * MagnitudeSquared;
    FloatTransformA8 = floatValue2 * InterpolationParam3 + floatValue3 * FloatVectorThirdComponent + floatValue4 * FloatVectorNinthComponent;
    FloatTransformAC = floatValue2 * InterpolationFactorW + floatValue3 * FloatVectorFourthComponent + floatValue4 * FloatVectorTenthComponent;
    floatValue2 = *(float *)(memoryBlockAddress + 0x138);
    floatValue3 = *(float *)(memoryBlockAddress + 0x140);
    floatValue4 = *(float *)(memoryBlockAddress + 0x144);
    FloatTransformB0 = BaseValue * InterpolationFactorX + floatValue6 * FloatVectorFirstComponent + floatValue2 * InterpolationFactorW;
    FloatTransformB4 = BaseValue * InterpolationFactorY + floatValue6 * FloatVectorSecondComponent + floatValue2 * MagnitudeSquared;
    FloatTransformB8 = BaseValue * InterpolationParam3 + floatValue6 * FloatVectorThirdComponent + floatValue2 * FloatVectorNinthComponent;
    FloatTransformBC = BaseValue * InterpolationFactorW + floatValue6 * FloatVectorFourthComponent + floatValue2 * FloatVectorTenthComponent;
    floatValue2 = *(float *)(memoryBlockAddress + 0x148);
    BaseValue = *(float *)(memoryBlockAddress + 0x154);
    floatValue6 = *(float *)(memoryBlockAddress + 0x150);
    FloatTransformC0 = floatValue4 * InterpolationFactorX + floatValue3 * FloatVectorFirstComponent + floatValue2 * InterpolationFactorW;
    FloatTransformC4 = floatValue4 * InterpolationFactorY + floatValue3 * FloatVectorSecondComponent + floatValue2 * MagnitudeSquared;
    FloatTransformC8 = floatValue4 * InterpolationParam3 + floatValue3 * FloatVectorThirdComponent + floatValue2 * FloatVectorNinthComponent;
    FloatTransformCC = floatValue4 * InterpolationFactorW + floatValue3 * FloatVectorFourthComponent + floatValue2 * FloatVectorTenthComponent;
    floatValue2 = *(float *)(memoryBlockAddress + 0x158);
    FloatTransformD0 =
         BaseValue * InterpolationFactorX + floatValue6 * FloatVectorFirstComponent + floatValue2 * InterpolationFactorW + FloatParameterArray[0xc];
    FloatTransformD4 =
         BaseValue * InterpolationFactorY + floatValue6 * FloatVectorSecondComponent + floatValue2 * MagnitudeSquared + FloatParameterArray[0xd];
    FloatTransformD8 =
         BaseValue * InterpolationParam3 + floatValue6 * FloatVectorThirdComponent + floatValue2 * FloatVectorNinthComponent + FloatParameterArray[0xe];
    FloatTransformDC =
         BaseValue * InterpolationFactorW + floatValue6 * FloatVectorFourthComponent + floatValue2 * FloatVectorTenthComponent + FloatParameterArray[0xf];
    pfloatValue39 = &stackBufferA0;
  }
  ConfigureSystemResourceBuffer(&StackBuffer60,ResourceDataOffset4 + 0x30,*(uint8_t *)(memoryBlockAddress + 0xf7),pfloatValue39);
  resourceCreationFlags8 = ThreadCreationParameter;
  resourceCreationFlags7 = InputStackParameter90;
  NetworkConnectionFlags = InputStackParameter88;
  SecurityParameter = InputStackParameter80;
  ConfigurationData = InputStackParameter78;
  InitializationFlags = InputStackParameter70;
  MemoryAllocationFlags = InputStackParameter68;
  ThreadCreationFlags = InputStackParameter60;
  isSystemActive9 = *(byte *)(ResourceDataOffset4 + 0x1bd8);
  systemIndex0 = *(int *)(SystemGlobalStatusFlags + 0x224);
  if (((*(byte *)(memoryBlockAddress + 0xfd) & 1) == 0) &&
     ((*(int *)(memoryBlockAddress + 0x1d0) == systemIndex0 || (*(int *)(memoryBlockAddress + 0x1d0) == systemIndex0 + -1)))) {
    isOperationComplete0 = 0;
  }
  else {
    isOperationComplete0 = 1;
  }
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe | isOperationComplete0;
  isSystemActive9 = isSystemActive9 & 0x20;
  if ((isSystemActive9 != 0) && (isOperationComplete0 != 0)) {
    *(void* *)(memoryBlockAddress + 0x160) = InputStackParameter60;
    *(void* *)(memoryBlockAddress + 0x168) = InputStackParameter68;
    *(void* )(memoryBlockAddress + 0x170) = TransformStackParameter;
    *(void* )(memoryBlockAddress + 0x178) = PhysicsStackParameter;
    *(void* )(memoryBlockAddress + 0x180) = AudioStackParameter;
    *(void* )(memoryBlockAddress + 0x188) = NetworkStackParameter;
    *(void* )(memoryBlockAddress + 400) = SecurityParameter;
    *(void* )(memoryBlockAddress + 0x198) = ThreadContextParameter;
  }
  ValidateSystemResourceData(ResourceDataOffset4);
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe;
  *(int *)(memoryBlockAddress + 0x1d0) = systemIndex0;
  if (isSystemActive9 != 0) {
    *(void* *)(memoryBlockAddress + 0x160) = ThreadCreationFlags;
    *(void* *)(memoryBlockAddress + 0x168) = MemoryAllocationFlags;
    *(void* *)(memoryBlockAddress + 0x170) = InitializationFlags;
    *(void* *)(memoryBlockAddress + 0x178) = ConfigurationData;
    *(void* *)(memoryBlockAddress + 0x180) = SecurityParameter;
    *(void* *)(memoryBlockAddress + 0x188) = NetworkConnectionFlags;
    *(void* *)(memoryBlockAddress + 400) = resourceCreationFlags7;
    *(void* *)(memoryBlockAddress + 0x198) = resourceCreationFlags8;
  }
  return;
}





/**
 * @brief 全局系统资源清理器
 * 
 * 该函数负责清理全局系统资源，释放所有未使用的资源。
 * 它会在系统关闭或资源回收时被调用，确保系统资源的正确释放。
 * 
 * @note 这是系统全局资源清理的最终函数
 */
void CleanupGlobalSystemResources(void)

{
  float CalculatedValue1;
  float CalculatedValue2;
  float CalculatedValue3;
  float CalculatedValue4;
  float BaseValue;
  int CalculationFlags;
  uint32_t ThreadContextFlag;
  uint32_t OperationCode;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  float InterpolationParam2;
  float InterpolationParam3;
  float InterpolationParam4;
  float InterpolationParam5;
  float MagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  void* ThreadCreationFlags;
  void* MemoryAllocationFlags;
  void* InitializationFlags;
  void* ConfigurationData;
  void* SecurityParameter;
  void* NetworkConnectionFlags;
  void* resourceCreationFlags7;
  void* resourceCreationFlags8;
  long long SystemThreadHandle9;
  byte isOperationComplete0;
  byte OperationCompleteFlag;
  uint32_t resourceAllocationContext2;
  long long ResourceDataOffset3;
  uint32_t *SystemHashNodeData4;
  long long memoryBlockAddress;
  void* *systemDataIndexPtr;
  long long ResourceDataOffset5;
  float *pfloatValue36;
  uint32_t InputStackParameter30;
  long long InputStackParameter40;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float StackFloatParameterA0;
  float StackFloatParameterA4;
  float StackFloatParameterA8;
  float StackFloatParameterAC;
  float StackFloatParameterB0;
  float StackFloatParameterB4;
  float StackFloatParameterB8;
  float StackFloatParameterBC;
  float StackFloatParameterC0;
  float StackFloatParameterC4;
  float StackFloatParameterC8;
  float StackFloatParameterCC;
  float StackFloatParameterD0;
  float StackFloatParameterD4;
  float StackFloatParameterD8;
  float StackFloatParameterDC;
  uint32_t StackParameterE0;
  uint32_t StackParameterE8;
  uint32_t StackParameterF0;
  uint32_t StackParameterF8;
  uint32_t StackParameter100;
  uint32_t StackParameter108;
  uint32_t StackParameter110;
  uint32_t StackParameter118;
  uint32_t StackParameter170;
  long long StackParameter178;
  float *FloatParameterArray;
  void* StackParameter188;
  long long StackParameter190;
  
  ResourceDataOffset3 = *(long long *)(memoryBlockAddress + 0x1b8);
  isOperationComplete0 = *(byte *)(ResourceDataOffset3 + 0x38c);
  ResourceDataOffset5 = memoryBlockAddress;
  if (isOperationComplete0 == 9) {
    isOperationComplete0 = func_0x00018022d300();
    *(byte *)(ResourceDataOffset3 + 0x38c) = isOperationComplete0;
  }
  SystemThreadHandle9 = StackParameter178;
  ResourceDataOffset3 = *(long long *)(ResourceDataOffset5 + 0x1e0);
  *systemDataIndexPtr = *(void* *)(ResourceDataOffset3 + (ulong long)isOperationComplete0 * 0x18);
  systemDataIndexPtr[1] = *(void* *)(ResourceDataOffset3 + 8 + (ulong long)isOperationComplete0 * 0x18);
  *(uint32_t *)(InputStackParameter40 + 0x10) = *(uint32_t *)(*(long long *)(memoryBlockAddress + 600) + 0x2c)
  ;
  *(uint32_t *)(InputStackParameter40 + 0x14) = *(uint32_t *)(*(long long *)(memoryBlockAddress + 600) + 0x4c)
  ;
  *(int *)(InputStackParameter40 + 0x48) = (int)*(char *)(*(long long *)(memoryBlockAddress + 600) + 0x44);
  if ((*(long long *)(memoryBlockAddress + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) == 0)) {
    resourceAllocationContext2 = 0xffffffff;
  }
  else {
    resourceAllocationContext2 = *(uint32_t *)(memoryBlockAddress + 0x108);
  }
  *(uint32_t *)(InputStackParameter40 + 0x18) = resourceAllocationContext2;
  if ((*(long long *)(memoryBlockAddress + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) == 0)) {
    resourceAllocationContext2 = 0xffffffff;
  }
  else {
    resourceAllocationContext2 = *(uint32_t *)(memoryBlockAddress + 0x10c);
  }
  *(uint32_t *)(InputStackParameter40 + 0x1c) = resourceAllocationContext2;
  if ((*(long long *)(memoryBlockAddress + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) == 0)) {
    resourceAllocationContext2 = 0xffffffff;
  }
  else {
    resourceAllocationContext2 = *(uint32_t *)(memoryBlockAddress + 0x110);
  }
  *(uint32_t *)(InputStackParameter40 + 0x20) = resourceAllocationContext2;
  *(byte *)(InputStackParameter40 + 0x4e) = *(byte *)(memoryBlockAddress + 0xfe) >> 3 & 1;
  if (*(int *)(memoryBlockAddress + 0x108) != -1) {
    SystemHashNodeData4 = *(uint32_t **)(memoryBlockAddress + 0x2d0);
    resourceAllocationContext2 = SystemHashNodeData4[1];
    ThreadContextFlag = SystemHashNodeData4[2];
    OperationCode = SystemHashNodeData4[3];
    *(uint32_t *)(InputStackParameter40 + 0x28) = *SystemHashNodeData4;
    *(uint32_t *)(InputStackParameter40 + 0x2c) = resourceAllocationContext2;
    *(uint32_t *)(InputStackParameter40 + 0x30) = ThreadContextFlag;
    *(uint32_t *)(InputStackParameter40 + 0x34) = OperationCode;
    ThreadCreationFlags = *(void* *)(SystemHashNodeData4 + 6);
    *(void* *)(InputStackParameter40 + 0x38) = *(void* *)(SystemHashNodeData4 + 4);
    *(void* *)(InputStackParameter40 + 0x40) = ThreadCreationFlags;
  }
  *(uint8_t *)(InputStackParameter40 + 0x4f) = *(uint8_t *)(*(long long *)(memoryBlockAddress + 600) + 0x24)
  ;
  ResourceDataOffset3 = *(long long *)(memoryBlockAddress + 600);
  if (*(char *)(ResourceDataOffset3 + 0x24) != '\0') {
    resourceAllocationContext2 = *(uint32_t *)(memoryBlockAddress + 0x2ac);
    ThreadContextFlag = *(uint32_t *)(memoryBlockAddress + 0x2b0);
    OperationCode = *(uint32_t *)(memoryBlockAddress + 0x2b4);
    *(uint32_t *)(InputStackParameter40 + 0x50) = *(uint32_t *)(memoryBlockAddress + 0x2a8);
    *(uint32_t *)(InputStackParameter40 + 0x54) = resourceAllocationContext2;
    *(uint32_t *)(InputStackParameter40 + 0x58) = ThreadContextFlag;
    *(uint32_t *)(InputStackParameter40 + 0x5c) = OperationCode;
    ResourceDataOffset3 = *(long long *)(memoryBlockAddress + 600);
  }
  *(bool *)(InputStackParameter40 + 0x4c) = *(long long *)(ResourceDataOffset3 + 0x10) != 0;
  *(uint8_t *)(InputStackParameter40 + 0x4d) = 1;
  if ((*(char *)(SystemMemoryOffset + 0xc) != '\0') ||
     (0 < *(int *)(*(long long *)(memoryBlockAddress + 600) + 0x1c))) {
    *(uint8_t *)(InputStackParameter40 + 0x4d) = 0;
  }
  if (*(long long *)(ResourceOffset + 0x28) == 0) {
    InputStackParameter30 = 0xffffffff;
    SystemHashNodeData4 = &StackBuffer30;
    ResourceDataOffset3 = ResourceOffset;
  }
  else {
    ThreadCreationFlags = 0xffffffff;
    SystemHashNodeData4 = &stackBuffer170;
    ResourceDataOffset3 = *(long long *)(ResourceOffset + 0x28);
  }
  ProcessSystemHashNodeAllocation(ResourceDataOffset3 + 0x3388,SystemHashNodeData4,&StackBuffer40);
  pfloatValue36 = FloatParameterArray;
  if ((*(uint *)(memoryBlockAddress + 0x100) & 0x4000000) != 0) {
    FloatVectorFirstComponent = *FloatParameterArray;
    FloatVectorSecondComponent = FloatParameterArray[1];
    FloatVectorThirdComponent = FloatParameterArray[2];
    FloatVectorFourthComponent = FloatParameterArray[3];
    InterpolationFactorX = FloatParameterArray[4];
    InterpolationFactorY = FloatParameterArray[5];
    InterpolationFactorZ = FloatParameterArray[6];
    InterpolationFactorW = FloatParameterArray[7];
    MagnitudeSquared = FloatParameterArray[8];
    FloatVectorNinthComponent = FloatParameterArray[9];
    FloatVectorTenthComponent = FloatParameterArray[10];
    FloatTransformValue1 = *(float *)(memoryBlockAddress + 0x124);
    FloatTransformValue2 = *(float *)(memoryBlockAddress + 0x120);
    FloatTransformValue3 = *(float *)(memoryBlockAddress + 0x128);
    FloatTransformValue4 = *(float *)(memoryBlockAddress + 0x134);
    FloatTransformValue5 = *(float *)(memoryBlockAddress + 0x130);
    FloatTransformA0 = FloatTransformValue1 * InterpolationFactorX + FloatTransformValue2 * FloatVectorFirstComponent + FloatTransformValue3 * InterpolationFactorW;
    FloatTransformA4 = FloatTransformValue1 * InterpolationFactorY + FloatTransformValue2 * FloatVectorSecondComponent + FloatTransformValue3 * MagnitudeSquared;
    FloatTransformA8 = FloatTransformValue1 * InterpolationParam3 + FloatTransformValue2 * FloatVectorThirdComponent + FloatTransformValue3 * FloatVectorNinthComponent;
    FloatTransformAC = FloatTransformValue1 * InterpolationFactorW + FloatTransformValue2 * FloatVectorFourthComponent + FloatTransformValue3 * FloatVectorTenthComponent;
    FloatTransformValue6 = *(float *)(memoryBlockAddress + 0x138);
    FloatTransformValue7 = *(float *)(memoryBlockAddress + 0x140);
    FloatTransformValue8 = *(float *)(memoryBlockAddress + 0x144);
    FloatTransformB0 = FloatTransformValue4 * InterpolationFactorX + FloatTransformValue5 * FloatVectorFirstComponent + FloatTransformValue6 * InterpolationFactorW;
    FloatTransformB4 = FloatTransformValue4 * InterpolationFactorY + FloatTransformValue5 * FloatVectorSecondComponent + FloatTransformValue6 * MagnitudeSquared;
    FloatTransformB8 = FloatTransformValue4 * InterpolationParam3 + FloatTransformValue5 * FloatVectorThirdComponent + FloatTransformValue6 * FloatVectorNinthComponent;
    FloatTransformBC = FloatTransformValue4 * InterpolationFactorW + FloatTransformValue5 * FloatVectorFourthComponent + FloatTransformValue6 * FloatVectorTenthComponent;
    FloatTransformValue6 = *(float *)(memoryBlockAddress + 0x148);
    FloatTransformValue4 = *(float *)(memoryBlockAddress + 0x154);
    FloatTransformValue5 = *(float *)(memoryBlockAddress + 0x150);
    FloatTransformC0 = FloatTransformValue8 * InterpolationFactorX + FloatTransformValue7 * FloatVectorFirstComponent + FloatTransformValue6 * InterpolationFactorW;
    FloatTransformC4 = FloatTransformValue8 * InterpolationFactorY + FloatTransformValue7 * FloatVectorSecondComponent + FloatTransformValue6 * MagnitudeSquared;
    FloatTransformC8 = FloatTransformValue8 * InterpolationParam3 + FloatTransformValue7 * FloatVectorThirdComponent + FloatTransformValue6 * FloatVectorNinthComponent;
    FloatTransformCC = FloatTransformValue8 * InterpolationFactorW + FloatTransformValue7 * FloatVectorFourthComponent + FloatTransformValue6 * FloatVectorTenthComponent;
    FloatTransformValue6 = *(float *)(memoryBlockAddress + 0x158);
    FloatTransformD0 =
         FloatTransformValue4 * InterpolationFactorX + FloatTransformValue5 * FloatVectorFirstComponent + FloatTransformValue6 * InterpolationFactorW + FloatParameterArray[0xc];
    FloatTransformD4 =
         FloatTransformValue4 * InterpolationFactorY + FloatTransformValue5 * FloatVectorSecondComponent + FloatTransformValue6 * MagnitudeSquared + FloatParameterArray[0xd];
    FloatTransformD8 =
         FloatTransformValue4 * InterpolationParam3 + FloatTransformValue5 * FloatVectorThirdComponent + FloatTransformValue6 * FloatVectorNinthComponent + FloatParameterArray[0xe];
    FloatTransformDC =
         FloatTransformValue4 * InterpolationFactorW + FloatTransformValue5 * FloatVectorFourthComponent + FloatTransformValue6 * FloatVectorTenthComponent + FloatParameterArray[0xf];
    pfloatValue36 = &stackBufferA0;
  }
  InitializeSystemThreadBuffer(&StackBuffer60,SystemThreadHandle9 + 0x30,*(uint8_t *)(memoryBlockAddress + 0xf7),pfloatValue36);
  resourceCreationFlags8 = ThreadCreationParameter;
  resourceCreationFlags7 = InputStackParameter90;
  NetworkConnectionFlags = InputStackParameter88;
  SecurityParameter = InputStackParameter80;
  ConfigurationData = InputStackParameter78;
  InitializationFlags = InputStackParameter70;
  MemoryAllocationFlags = InputStackParameter68;
  ThreadCreationFlags = InputStackParameter60;
  isOperationComplete0 = *(byte *)(SystemThreadHandle9 + 0x1bd8);
  CalculationFlags = *(int *)(SystemGlobalStatusFlags + 0x224);
  if (((*(byte *)(memoryBlockAddress + 0xfd) & 1) == 0) &&
     ((*(int *)(memoryBlockAddress + 0x1d0) == CalculationFlags || (*(int *)(memoryBlockAddress + 0x1d0) == CalculationFlags + -1)))) {
    OperationCompleteFlag = 0;
  }
  else {
    OperationCompleteFlag = 1;
  }
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe | OperationCompleteFlag;
  isOperationComplete0 = isOperationComplete0 & 0x20;
  if ((isOperationComplete0 != 0) && (OperationCompleteFlag != 0)) {
    *(void* *)(memoryBlockAddress + 0x160) = InputStackParameter60;
    *(void* *)(memoryBlockAddress + 0x168) = InputStackParameter68;
    *(void* )(memoryBlockAddress + 0x170) = TransformStackParameter;
    *(void* )(memoryBlockAddress + 0x178) = PhysicsStackParameter;
    *(void* )(memoryBlockAddress + 0x180) = AudioStackParameter;
    *(void* )(memoryBlockAddress + 0x188) = NetworkStackParameter;
    *(void* )(memoryBlockAddress + 400) = SecurityParameter;
    *(void* )(memoryBlockAddress + 0x198) = ThreadContextParameter;
  }
  ValidateSystemThreadHandle(SystemThreadHandle9);
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe;
  *(int *)(memoryBlockAddress + 0x1d0) = CalculationFlags;
  if (isOperationComplete0 != 0) {
    *(void* *)(memoryBlockAddress + 0x160) = ThreadCreationFlags;
    *(void* *)(memoryBlockAddress + 0x168) = MemoryAllocationFlags;
    *(void* *)(memoryBlockAddress + 0x170) = InitializationFlags;
    *(void* *)(memoryBlockAddress + 0x178) = ConfigurationData;
    *(void* *)(memoryBlockAddress + 0x180) = SecurityParameter;
    *(void* *)(memoryBlockAddress + 0x188) = NetworkConnectionFlags;
    *(void* *)(memoryBlockAddress + 400) = resourceCreationFlags7;
    *(void* *)(memoryBlockAddress + 0x198) = resourceCreationFlags8;
  }
  return;
}





/**
 * @brief 处理系统矩阵运算
 * 
 * 该函数负责执行游戏引擎中的矩阵运算，包括矩阵变换、向量运算和插值计算。
 * 主要用于3D图形渲染、物理模拟和动画系统的数学计算。
 * 
 * 功能包括：
 * - 矩阵元素的计算和变换
 * - 向量运算和插值
 * - 旋转角度和缩放因子的处理
 * - 四元数运算
 * - 物理和音频系统的参数计算
 * 
 * @note 该函数在系统初始化和运行时都会被调用，是数学运算的核心组件
 */
void ProcessSystemMatrixOperations(void)

{
  float MatrixElementX;
  float MatrixElementY;
  float MatrixElementZ;
  float MatrixElementW;
  float VectorMagnitude;
  int CalculationFlags;
  float RotationAngleX;
  float RotationAngleY;
  float RotationAngleZ;
  float ScaleFactor;
  float TranslationX;
  float AspectRatio;
  float InterpolationAlpha;
  float InterpolationBeta;
  float InterpolationGamma;
  float InterpolationDelta;
  float InterpolationEpsilon;
  float MagnitudeSquared;
  void* SystemContextPointer;
  void* ResourceCreationFlags;
  void* ThreadCreationFlags;
  void* MemoryAllocationFlags;
  void* InitializationFlags;
  void* ConfigurationData;
  void* SecurityContextFlags;
  void* NetworkConnectionFlags;
  byte IsPhysicsSystemActive;
  long long memoryBlockAddress;
  byte IsAudioSystemActive;
  float *StringIteratorPointer;
  long long RegisterR13Value;
  bool ZeroFlag;
  void* MatrixStackParameter;
  void* VectorStackParameter;
  void* TransformStackParameter;
  void* PhysicsStackParameter;
  void* AudioStackParameter;
  void* NetworkStackParameter;
  void* SecurityParameter;
  void* ThreadContextParameter;
  float StackMatrixElement1;
  float StackMatrixElement2;
  float StackMatrixElement3;
  float StackMatrixElement4;
  float StackVectorElement1;
  float StackVectorElement2;
  float StackVectorElement3;
  float StackVectorElement4;
  float StackTransformElement1;
  float StackTransformElement2;
  float StackTransformElement3;
  float StackTransformElement4;
  float StackPhysicsElement1;
  float StackPhysicsElement2;
  float StackPhysicsElement3;
  float StackPhysicsElement4;
  
  if (!ZeroFlag) {
    RotationAngleX = *StringIteratorPointer;
    RotationAngleY = StringIteratorPointer[1];
    RotationAngleZ = StringIteratorPointer[2];
    ScaleFactor = StringIteratorPointer[3];
    TranslationX = StringIteratorPointer[4];
    AspectRatio = StringIteratorPointer[5];
    InterpolationAlpha = StringIteratorPointer[6];
    InterpolationBeta = StringIteratorPointer[7];
    MatrixElementX = StringIteratorPointer[8];
    InterpolationDelta = StringIteratorPointer[9];
    InterpolationEpsilon = StringIteratorPointer[10];
    MagnitudeSquared = StringIteratorPointer[0xb];
    MatrixElementX = *(float *)(memoryBlockAddress + 0x124);
    MatrixElementY = *(float *)(memoryBlockAddress + 0x120);
    MatrixElementZ = *(float *)(memoryBlockAddress + 0x128);
    MatrixElementW = *(float *)(memoryBlockAddress + 0x134);
    VectorMagnitude = *(float *)(memoryBlockAddress + 0x130);
    StackMatrixElement1 = MatrixElementX * TranslationX + MatrixElementY * RotationAngleX + MatrixElementZ * InterpolationGamma;
    StackMatrixElement2 = MatrixElementX * AspectRatio + MatrixElementY * RotationAngleY + MatrixElementZ * InterpolationDelta;
    StackMatrixElement3 = MatrixElementX * InterpolationAlpha + MatrixElementY * RotationAngleZ + MatrixElementZ * InterpolationEpsilon;
    StackMatrixElement4 = MatrixElementX * InterpolationBeta + MatrixElementY * ScaleFactor + MatrixElementZ * MagnitudeSquared;
    float QuaternionW = *(float *)(memoryBlockAddress + 0x138);
    float TransformX = *(float *)(memoryBlockAddress + 0x140);
    float TransformY = *(float *)(memoryBlockAddress + 0x144);
    StackVectorElement1 = MatrixElementW * TranslationX + VectorMagnitude * RotationAngleX + QuaternionW * InterpolationGamma;
    StackVectorElement2 = MatrixElementW * AspectRatio + VectorMagnitude * RotationAngleY + QuaternionW * InterpolationDelta;
    StackVectorElement3 = MatrixElementW * InterpolationAlpha + VectorMagnitude * RotationAngleZ + QuaternionW * InterpolationEpsilon;
    StackVectorElement4 = MatrixElementW * InterpolationBeta + VectorMagnitude * ScaleFactor + QuaternionW * MagnitudeSquared;
    QuaternionW = *(float *)(memoryBlockAddress + 0x148);
    MatrixElementW = *(float *)(memoryBlockAddress + 0x154);
    VectorMagnitude = *(float *)(memoryBlockAddress + 0x150);
    StackTransformElement1 = TransformY * TranslationX + TransformX * RotationAngleX + QuaternionW * InterpolationGamma;
    StackTransformElement2 = TransformY * AspectRatio + TransformX * RotationAngleY + QuaternionW * InterpolationDelta;
    StackTransformElement3 = TransformY * InterpolationAlpha + TransformX * RotationAngleZ + QuaternionW * InterpolationEpsilon;
    StackTransformElement4 = TransformY * InterpolationBeta + TransformX * ScaleFactor + QuaternionW * MagnitudeSquared;
    QuaternionW = *(float *)(memoryBlockAddress + 0x158);
    StackPhysicsElement1 = MatrixElementW * TranslationX + VectorMagnitude * RotationAngleX + QuaternionW * InterpolationGamma + StringIteratorPointer[0xc];
    StackPhysicsElement2 = MatrixElementW * AspectRatio + VectorMagnitude * RotationAngleY + QuaternionW * InterpolationDelta + StringIteratorPointer[0xd];
    StackPhysicsElement3 = MatrixElementW * InterpolationAlpha + VectorMagnitude * RotationAngleZ + QuaternionW * InterpolationEpsilon + StringIteratorPointer[0xe];
    StackPhysicsElement4 = MatrixElementW * InterpolationBeta + VectorMagnitude * ScaleFactor + QuaternionW * MagnitudeSquared + StringIteratorPointer[0xf];
  }
  ProcessSystemMatrixOperations(&StackParameterArray, RegisterR13Value + 0x30, *(uint8_t *)(memoryBlockAddress + 0xf7));
  NetworkConnectionFlags = ThreadContextParameter;
  SecurityParameter = SecurityParameter;
  ConfigurationData = NetworkStackParameter;
  InitializationFlags = AudioStackParameter;
  MemoryAllocationFlags = PhysicsStackParameter;
  ThreadCreationFlags = TransformStackParameter;
  ResourceCreationFlags = VectorStackParameter;
  SystemContextPointer = MatrixStackParameter;
  IsAudioSystemActive = *(byte *)(RegisterR13Value + 0x1bd8);
  CalculationFlags = *(int *)(SystemGlobalStatusFlags + 0x224);
  if (((*(byte *)(memoryBlockAddress + 0xfd) & 1) == 0) &&
     ((*(int *)(memoryBlockAddress + 0x1d0) == CalculationFlags || (*(int *)(memoryBlockAddress + 0x1d0) == CalculationFlags + -1)))) {
    IsPhysicsSystemActive = 0;
  }
  else {
    IsPhysicsSystemActive = 1;
  }
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe | IsPhysicsSystemActive;
  IsAudioSystemActive = IsAudioSystemActive & 0x20;
  if ((IsAudioSystemActive != 0) && (IsPhysicsSystemActive != 0)) {
    *(void* *)(memoryBlockAddress + 0x160) = MatrixStackParameter;
    *(void* *)(memoryBlockAddress + 0x168) = VectorStackParameter;
    *(void* )(memoryBlockAddress + 0x170) = TransformStackParameter;
    *(void* )(memoryBlockAddress + 0x178) = PhysicsStackParameter;
    *(void* )(memoryBlockAddress + 0x180) = AudioStackParameter;
    *(void* )(memoryBlockAddress + 0x188) = NetworkStackParameter;
    *(void* )(memoryBlockAddress + 400) = SecurityParameter;
    *(void* )(memoryBlockAddress + 0x198) = ThreadContextParameter;
  }
  ProcessSystemCleanupOperations();
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe;
  *(int *)(memoryBlockAddress + 0x1d0) = CalculationFlags;
  if (IsAudioSystemActive != 0) {
    *(void* *)(memoryBlockAddress + 0x160) = SystemContextPointer;
    *(void* *)(memoryBlockAddress + 0x168) = ResourceCreationFlags;
    *(void* *)(memoryBlockAddress + 0x170) = ThreadCreationFlags;
    *(void* *)(memoryBlockAddress + 0x178) = MemoryAllocationFlags;
    *(void* *)(memoryBlockAddress + 0x180) = InitializationFlags;
    *(void* *)(memoryBlockAddress + 0x188) = ConfigurationData;
    *(void* *)(memoryBlockAddress + 400) = SecurityParameter;
    *(void* *)(memoryBlockAddress + 0x198) = NetworkConnectionFlags;
  }
  return;
}





/**
 * @brief 初始化系统向量计算功能
 * 
 * 该函数负责初始化游戏引擎的向量计算子系统，设置向量运算的基础设施。
 * 主要用于3D图形渲染、物理模拟和动画系统的向量数学运算。
 * 
 * 功能包括：
 * - 向量运算器的初始化
 * - 数学运算参数的设置
 * - 向量计算缓冲区的配置
 * - 物理和音频系统的向量参数初始化
 * 
 * @note 该函数在系统初始化阶段被调用，是向量运算系统的基础组件
 */
void InitializeSystemVectorCalculations(void)

{
  float CalculatedValue1;
  float CalculatedValue2;
  float CalculatedValue3;
  float CalculatedValue4;
  float BaseValue;
  int CalculationFlags;
  float floatValue7;
  float floatValue8;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  float InterpolationParam2;
  float InterpolationParam3;
  float InterpolationParam4;
  float InterpolationParam5;
  float MagnitudeSquared;
  void* SystemContextPointer;
  void* ResourceCreationFlags;
  void* ThreadCreationFlags;
  void* MemoryAllocationFlags;
  void* InitializationFlags;
  void* ConfigurationData;
  void* SecurityParameter;
  void* NetworkConnectionFlags;
  byte isSystemActive7;
  long long memoryBlockAddress;
  byte IsAudioSystemActive;
  float *pfloatValue29;
  long long SystemContextPointer;
  uint32_t AudioSystemActivationFlag;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  float AudioStackFloatParameterA0;
  float AudioStackFloatParameterA4;
  float AudioStackFloatParameterA8;
  float AudioStackFloatParameterAC;
  float AudioStackFloatParameterB0;
  float AudioStackFloatParameterB4;
  float AudioStackFloatParameterB8;
  float AudioStackFloatParameterBC;
  float AudioStackFloatParameterC0;
  float AudioStackFloatParameterC4;
  float AudioStackFloatParameterC8;
  float AudioStackFloatParameterCC;
  float AudioStackFloatParameterD0;
  float AudioStackFloatParameterD4;
  float AudioStackFloatParameterD8;
  float AudioStackFloatParameterDC;
  uint32_t StackParameterE0;
  uint32_t StackParameterE8;
  uint32_t StackParameterF0;
  uint32_t StackParameterF8;
  uint32_t StackParameter100;
  uint32_t StackParameter108;
  uint32_t StackParameter110;
  uint32_t StackParameter118;
  float *FloatParameterArray;
  void* StackParameter188;
  
  AudioSystemActivationFlag = 0xffffffff;
  ProcessSystemContextAllocation(SystemContextPointer + 0x3388,&StackBuffer30);
  pfloatValue29 = FloatParameterArray;
  if ((*(uint *)(memoryBlockAddress + 0x100) & 0x4000000) != 0) {
    FloatVectorFirstComponent = *FloatParameterArray;
    FloatVectorSecondComponent = FloatParameterArray[1];
    FloatVectorThirdComponent = FloatParameterArray[2];
    FloatVectorFourthComponent = FloatParameterArray[3];
    FloatVectorFifthComponent = FloatParameterArray[4];
    FloatVectorSixthComponent = FloatParameterArray[5];
    InterpolationFactorX = FloatParameterArray[6];
    InterpolationFactorY = FloatParameterArray[7];
    InterpolationFactorZ = FloatParameterArray[8];
    InterpolationFactorW = FloatParameterArray[9];
    InterpolationFactorV = FloatParameterArray[10];
    MagnitudeSquared = FloatParameterArray[0xb];
    FloatTransformValue1 = *(float *)(memoryBlockAddress + 0x124);
    FloatTransformValue2 = *(float *)(memoryBlockAddress + 0x120);
    FloatTransformValue3 = *(float *)(memoryBlockAddress + 0x128);
    FloatTransformValue4 = *(float *)(memoryBlockAddress + 0x134);
    FloatTransformValue5 = *(float *)(memoryBlockAddress + 0x130);
    FloatTransformA0 = FloatTransformValue1 * FloatVectorFifthComponent + FloatTransformValue2 * FloatVectorFirstComponent + FloatTransformValue3 * InterpolationFactorZ;
    FloatTransformA4 = FloatTransformValue1 * FloatVectorSixthComponent + FloatTransformValue2 * FloatVectorSecondComponent + FloatTransformValue3 * InterpolationFactorW;
    FloatTransformA8 = FloatTransformValue1 * InterpolationFactorX + FloatTransformValue2 * FloatVectorThirdComponent + FloatTransformValue3 * InterpolationFactorV;
    FloatTransformAC = FloatTransformValue1 * InterpolationFactorY + FloatTransformValue2 * FloatVectorFourthComponent + FloatTransformValue3 * MagnitudeSquared;
    FloatTransformValue6 = *(float *)(memoryBlockAddress + 0x138);
    FloatTransformValue7 = *(float *)(memoryBlockAddress + 0x140);
    FloatTransformValue8 = *(float *)(memoryBlockAddress + 0x144);
    FloatTransformB0 = FloatTransformValue4 * FloatVectorFifthComponent + FloatTransformValue5 * FloatVectorFirstComponent + FloatTransformValue6 * InterpolationFactorZ;
    FloatTransformB4 = FloatTransformValue4 * FloatVectorSixthComponent + FloatTransformValue5 * FloatVectorSecondComponent + FloatTransformValue6 * InterpolationFactorW;
    FloatTransformB8 = FloatTransformValue4 * InterpolationFactorX + FloatTransformValue5 * FloatVectorThirdComponent + FloatTransformValue6 * InterpolationFactorV;
    FloatTransformBC = FloatTransformValue4 * InterpolationFactorY + FloatTransformValue5 * FloatVectorFourthComponent + FloatTransformValue6 * MagnitudeSquared;
    FloatTransformValue9 = *(float *)(memoryBlockAddress + 0x148);
    FloatTransformValue4 = *(float *)(memoryBlockAddress + 0x154);
    FloatTransformValue5 = *(float *)(memoryBlockAddress + 0x150);
    FloatTransformC0 = FloatTransformValue8 * FloatVectorFifthComponent + FloatTransformValue7 * FloatVectorFirstComponent + FloatTransformValue9 * InterpolationFactorZ;
    FloatTransformC4 = FloatTransformValue8 * FloatVectorSixthComponent + FloatTransformValue7 * FloatVectorSecondComponent + FloatTransformValue9 * InterpolationFactorW;
    FloatTransformC8 = FloatTransformValue8 * InterpolationFactorX + FloatTransformValue7 * FloatVectorThirdComponent + FloatTransformValue9 * InterpolationFactorV;
    FloatTransformCC = FloatTransformValue8 * InterpolationFactorY + FloatTransformValue7 * FloatVectorFourthComponent + FloatTransformValue9 * MagnitudeSquared;
    FloatTransformValue9 = *(float *)(memoryBlockAddress + 0x158);
    FloatTransformD0 =
         FloatTransformValue4 * FloatVectorFifthComponent + FloatTransformValue5 * FloatVectorFirstComponent + FloatTransformValue9 * InterpolationFactorZ + FloatParameterArray[0xc];
    FloatTransformD4 =
         FloatTransformValue4 * FloatVectorSixthComponent + FloatTransformValue5 * FloatVectorSecondComponent + FloatTransformValue9 * InterpolationFactorW + FloatParameterArray[0xd];
    FloatTransformD8 =
         FloatTransformValue4 * InterpolationFactorX + FloatTransformValue5 * FloatVectorThirdComponent + FloatTransformValue9 * InterpolationFactorV + FloatParameterArray[0xe];
    FloatTransformDC =
         FloatTransformValue4 * InterpolationFactorY + FloatTransformValue5 * FloatVectorFourthComponent + FloatTransformValue9 * MagnitudeSquared + FloatParameterArray[0xf];
    pfloatValue29 = &stackBufferA0;
  }
  ConfigureSystemContextBuffer(&StackBuffer60,SystemContextPointer + 0x30,*(uint8_t *)(memoryBlockAddress + 0xf7),pfloatValue29);
  NetworkConnectionFlags = ThreadCreationParameter;
  SecurityParameter = InputStackParameter90;
  ConfigurationData = InputStackParameter88;
  InitializationFlags = InputStackParameter80;
  MemoryAllocationFlags = InputStackParameter78;
  ThreadCreationFlags = InputStackParameter70;
  ResourceCreationFlags = InputStackParameter68;
  SystemContextPointer = InputStackParameter60;
  IsAudioSystemActive = *(byte *)(SystemContextPointer + 0x1bd8);
  CalculationFlags = *(int *)(SystemGlobalStatusFlags + 0x224);
  if (((*(byte *)(memoryBlockAddress + 0xfd) & 1) == 0) &&
     ((*(int *)(memoryBlockAddress + 0x1d0) == CalculationFlags || (*(int *)(memoryBlockAddress + 0x1d0) == CalculationFlags + -1)))) {
    isSystemActive7 = 0;
  }
  else {
    isSystemActive7 = 1;
  }
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe | isSystemActive7;
  IsAudioSystemActive = IsAudioSystemActive & 0x20;
  if ((IsAudioSystemActive != 0) && (isSystemActive7 != 0)) {
    *(void* *)(memoryBlockAddress + 0x160) = InputStackParameter60;
    *(void* *)(memoryBlockAddress + 0x168) = InputStackParameter68;
    *(void* )(memoryBlockAddress + 0x170) = TransformStackParameter;
    *(void* )(memoryBlockAddress + 0x178) = PhysicsStackParameter;
    *(void* )(memoryBlockAddress + 0x180) = AudioStackParameter;
    *(void* )(memoryBlockAddress + 0x188) = NetworkStackParameter;
    *(void* )(memoryBlockAddress + 400) = SecurityParameter;
    *(void* )(memoryBlockAddress + 0x198) = ThreadContextParameter;
  }
  ProcessSystemCleanupOperations();
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe;
  *(int *)(memoryBlockAddress + 0x1d0) = CalculationFlags;
  if (IsAudioSystemActive != 0) {
    *(void* *)(memoryBlockAddress + 0x160) = SystemContextPointer;
    *(void* *)(memoryBlockAddress + 0x168) = ResourceCreationFlags;
    *(void* *)(memoryBlockAddress + 0x170) = ThreadCreationFlags;
    *(void* *)(memoryBlockAddress + 0x178) = MemoryAllocationFlags;
    *(void* *)(memoryBlockAddress + 0x180) = InitializationFlags;
    *(void* *)(memoryBlockAddress + 0x188) = ConfigurationData;
    *(void* *)(memoryBlockAddress + 400) = SecurityParameter;
    *(void* *)(memoryBlockAddress + 0x198) = NetworkConnectionFlags;
  }
  return;
}





// 函数: void ExecuteSystemTransformOperations(void)
void ExecuteSystemTransformOperations(void)

{
  int SystemOperationStatus;
  void* resourceCreationFlags;
  void* resourceAllocationContext;
  void* resourceAddress;
  void* currentThreadId;
  void* ResourceHash;
  void* ThreadContextFlag;
  void* OperationCode;
  void* ThreadContextFlag;
  byte isByteValid0;
  long long memoryBlockAddress;
  byte isByteValid1;
  long long SystemContextPointer;
  void* InputStackParameter60;
  void* InputStackParameter68;
  void* InputStackParameter70;
  void* InputStackParameter78;
  void* InputStackParameter80;
  void* InputStackParameter88;
  void* InputStackParameter90;
  void* ThreadCreationParameter;
  
  FinalizeSystemContextBuffer(&StackBuffer60,SystemContextPointer + 0x30,*(uint8_t *)(memoryBlockAddress + 0xf7));
  ThreadContextFlag = ThreadCreationParameter;
  OperationCode = InputStackParameter90;
  ThreadContextFlag = InputStackParameter88;
  ResourceHash = InputStackParameter80;
  currentThreadId = InputStackParameter78;
  resourceAddress = InputStackParameter70;
  resourceAllocationContext = InputStackParameter68;
  resourceCreationFlags = InputStackParameter60;
  isByteValid1 = *(byte *)(SystemContextPointer + 0x1bd8);
  SystemOperationStatus = *(int *)(SystemGlobalStatusFlags + 0x224);
  if (((*(byte *)(memoryBlockAddress + 0xfd) & 1) == 0) &&
     ((*(int *)(memoryBlockAddress + 0x1d0) == SystemOperationStatus || (*(int *)(memoryBlockAddress + 0x1d0) == SystemOperationStatus + -1)))) {
    isByteValid0 = 0;
  }
  else {
    isByteValid0 = 1;
  }
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe | isByteValid0;
  isByteValid1 = isByteValid1 & 0x20;
  if ((isByteValid1 != 0) && (isByteValid0 != 0)) {
    *(void* *)(memoryBlockAddress + 0x160) = InputStackParameter60;
    *(void* *)(memoryBlockAddress + 0x168) = InputStackParameter68;
    *(void* )(memoryBlockAddress + 0x170) = TransformStackParameter;
    *(void* )(memoryBlockAddress + 0x178) = PhysicsStackParameter;
    *(void* )(memoryBlockAddress + 0x180) = AudioStackParameter;
    *(void* )(memoryBlockAddress + 0x188) = NetworkStackParameter;
    *(void* )(memoryBlockAddress + 400) = SecurityParameter;
    *(void* )(memoryBlockAddress + 0x198) = ThreadContextParameter;
  }
  ProcessSystemCleanupOperations();
  *(byte *)(memoryBlockAddress + 0xfd) = *(byte *)(memoryBlockAddress + 0xfd) & 0xfe;
  *(int *)(memoryBlockAddress + 0x1d0) = SystemOperationStatus;
  if (isByteValid1 != 0) {
    *(void* *)(memoryBlockAddress + 0x160) = resourceCreationFlags;
    *(void* *)(memoryBlockAddress + 0x168) = resourceAllocationContext;
    *(void* *)(memoryBlockAddress + 0x170) = resourceAddress;
    *(void* *)(memoryBlockAddress + 0x178) = currentThreadId;
    *(void* *)(memoryBlockAddress + 0x180) = ResourceHash;
    *(void* *)(memoryBlockAddress + 0x188) = ThreadContextFlag;
    *(void* *)(memoryBlockAddress + 400) = OperationCode;
    *(void* *)(memoryBlockAddress + 0x198) = ThreadContextFlag;
  }
  return;
}



uint8_t ValidateSystemIntegrity(void)

{
  return 0;
}



/**
 * @brief 处理系统资源初始化
 * 
 * 该函数负责初始化系统资源，包括线程创建、内存分配、配置参数设置等。
 * 它会根据传入的配置参数创建系统线程，并初始化相关的资源管理结构。
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志指针
 * @param primaryConfigurationParameter 主要配置参数
 * @param secondaryConfigurationParameter 次要配置参数
 * @return ulong long 初始化结果状态码
 */
ulong long ProcessSystemResourceInitialization(long long SystemResourceManager,void* ConfigurationDataPointer,uint32_t AdditionalParameter,float *ConfigurationFlag,
                       uint32_t primaryConfigurationParameter,uint32_t secondaryConfigurationParameter)

{
  float CalculatedValue1;
  float CalculatedValue2;
  float CalculatedValue3;
  float CalculatedValue4;
  float BaseValue;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  float InterpolationParam2;
  float InterpolationParam3;
  float InterpolationParam4;
  float InterpolationParam5;
  float MagnitudeSquared;
  char CharacterVariable19;
  ulong long in_RAX;
  long long SystemThreadIndex;
  ulong long ThreadCreationFlags;
  long long SystemThreadHandle2;
  byte isSystemActive3;
  void* UnsignedStackFlag88;
  ulong long UnsignedStackFlag80;
  void* SystemUnsignedFlag78;
  ulong long SystemProcessFlags70;
  void* EncryptionValue68;
  ulong long SystemThreadContext;
  float SystemFloatValue1;
  float SystemFloatValue2;
  float SystemFloatValue3;
  uint32_t StackUnsignedValue4C;
  
  SystemThreadHandle2 = *(long long *)(SystemResourceManager + 0x1b8);
  if (SystemThreadHandle2 != 0) {
    isSystemActive3 = *(byte *)(SystemResourceManager + 0xfd) & 0x20;
    SystemThreadIndex = SystemResourceManager;
    if (isSystemActive3 == 0) {
      SystemThreadIndex = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
    }
    if (*(int *)(SystemThreadIndex + 0x200) != 0) {
      SystemThreadIndex = SystemResourceManager;
      if (isSystemActive3 == 0) {
        SystemThreadIndex = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
      }
      if (*(int *)(SystemThreadIndex + 0x1fc) * 3 != 0) goto LAB_180077fcf;
    }
    if ((*(byte *)(SystemResourceManager + 0x100) & 4) != 0) {
LAB_180077fcf:
      SystemThreadHandle2 = *(long long *)(SystemResourceManager + 0x1b8);
      charStatus9 = *(char *)(SystemThreadHandle2 + 0x38c);
      if (charStatus9 == '\t') {
        charStatus9 = func_0x00018022d300();
        *(char *)(SystemThreadHandle2 + 0x38c) = charStatus9;
      }
      charStatus9 = ValidateSystemResourceStatus(SystemResourceManager,SystemResourceManager + 0x1e8,charStatus9,1);
      if (charStatus9 == '\0') {
        *(byte *)(SystemResourceManager + 0xfe) = *(byte *)(SystemResourceManager + 0xfe) & 0xfb;
      }
      if ((*(uint *)(SystemResourceManager + 0x100) & 0x4000000) == 0) {
        UnsignedStackFlag88 = *(void* *)ConfigurationFlag;
        UnsignedStackFlag80._0_4_ = (float)*(void* *)(ConfigurationFlag + 2);
        SystemUnsignedFlag78 = *(void* *)(ConfigurationFlag + 4);
        SystemProcessFlags70._0_4_ = (float)*(void* *)(ConfigurationFlag + 6);
        EncryptionValue68 = *(void* *)(ConfigurationFlag + 8);
        SystemThreadContext.PrimaryField = (float)*(void* *)(ConfigurationFlag + 10);
        SystemFloatValue1 = ConfigurationFlag[0xc];
        SystemFloatValue2 = ConfigurationFlag[0xd];
        SystemFloatValue3 = ConfigurationFlag[0xe];
      }
      else {
        ScalingFactor = ConfigurationFlag[4];
        OffsetValue = ConfigurationFlag[5];
        RatioValue = ConfigurationFlag[6];
        floatValue1 = *(float *)(SystemResourceManager + 0x120);
        floatValue2 = *(float *)(SystemResourceManager + 0x128);
        floatValue3 = *(float *)(SystemResourceManager + 0x134);
        floatValue4 = *(float *)(SystemResourceManager + 0x144);
        BaseValue = *(float *)(SystemResourceManager + 0x154);
        InterpolationParam1 = *ConfigurationFlag;
        InterpolationParam2 = ConfigurationFlag[1];
        scaleResult1 = ConfigurationFlag[2];
        InterpolationParam4 = ConfigurationFlag[8];
        InterpolationParam5 = ConfigurationFlag[9];
        MagnitudeSquared = ConfigurationFlag[10];
        floatValue6 = *(float *)(SystemResourceManager + 0x124);
        floatValue7 = *(float *)(SystemResourceManager + 0x130);
        UnsignedStackFlag80._0_4_ = floatValue6 * RatioValue + floatValue1 * InterpolationParam3 + floatValue2 * MagnitudeSquared;
        floatValue8 = *(float *)(SystemResourceManager + 0x138);
        ScaleValue = *(float *)(SystemResourceManager + 0x140);
        SystemProcessFlags70._0_4_ = floatValue3 * RatioValue + floatValue7 * InterpolationParam3 + floatValue8 * MagnitudeSquared;
        UnsignedStackFlag88 = ConcatenatedValue44(floatValue6 * OffsetValue + floatValue1 * InterpolationParam2 + floatValue2 * InterpolationParam5,
                             floatValue6 * ScalingFactor + floatValue1 * InterpolationParam1 + floatValue2 * InterpolationParam4);
        floatValue1 = *(float *)(SystemResourceManager + 0x148);
        floatValue2 = *(float *)(SystemResourceManager + 0x150);
        SystemThreadContext.PrimaryField = floatValue4 * RatioValue + ScaleValue * InterpolationParam3 + floatValue1 * MagnitudeSquared;
        floatValue6 = *(float *)(SystemResourceManager + 0x158);
        SystemUnsignedFlag78 = ConcatenatedValue44(floatValue3 * OffsetValue + floatValue7 * InterpolationParam2 + floatValue8 * InterpolationParam5,
                             floatValue3 * ScalingFactor + floatValue7 * InterpolationParam1 + floatValue8 * InterpolationParam4);
        EncryptionValue68 = ConcatenatedValue44(floatValue4 * OffsetValue + ScaleValue * InterpolationParam2 + floatValue1 * InterpolationParam5,
                             floatValue4 * ScalingFactor + ScaleValue * InterpolationParam1 + floatValue1 * InterpolationParam4);
        SystemFloatValue1 = BaseValue * ScalingFactor + floatValue2 * InterpolationParam1 + floatValue6 * InterpolationParam4 + ConfigurationFlag[0xc];
        SystemFloatValue2 = BaseValue * OffsetValue + floatValue2 * InterpolationParam2 + floatValue6 * InterpolationParam5 + ConfigurationFlag[0xd];
        SystemFloatValue3 = BaseValue * RatioValue + floatValue2 * InterpolationParam3 + floatValue6 * MagnitudeSquared + ConfigurationFlag[0xe];
      }
      SystemFloatValue = 0x3f800000;
      SystemThreadContext = (ulong long)(uint)(float)SystemThreadContext;
      SystemProcessFlags70 = (ulong long)(uint)(float)SystemProcessFlags70;
      UnsignedStackFlag80 = (ulong long)(uint)(float)UnsignedStackFlag80;
      ThreadCreationFlags = InitializeSystemThreadCreation(ConfigurationDataPointer,SystemResourceManager,AdditionalParameter,&UnsignedStackFlag88,primaryConfigurationParameter,secondaryConfigurationParameter);
      return ThreadCreationFlags;
    }
    in_RAX = 0;
    if (*(char *)(SystemThreadHandle2 + 0x38c) == '\t') {
      in_RAX = func_0x00018022d300(SystemThreadHandle2);
      *(char *)(SystemThreadHandle2 + 0x38c) = (char)in_RAX;
      if ((char)in_RAX == '\t') goto LAB_180077fcf;
    }
  }
  return in_RAX & MAX_UNSIGNED_32_BITffffff00;
}




// 函数: void ProcessSystemFloatOperations(void* SystemResourceManager,void* ConfigurationDataPointer,float AdditionalParameter,float ConfigurationFlag)
void ProcessSystemFloatOperations(void* SystemResourceManager,void* ConfigurationDataPointer,float AdditionalParameter,float ConfigurationFlag)

{
  float CalculatedValue1;
  float CalculatedValue2;
  float CalculatedValue3;
  float CalculatedValue4;
  float BaseValue;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float ScaleValue;
  long long memoryBlockAddress;
  float *systemDataIndexPtr;
  uint32_t SystemResourceCounter;
  float in_XMM0_Dc;
  float in_XMM1_Dc;
  float in_XMM4_Da;
  float in_XMM4_Db;
  float in_XMM4_Dc;
  float in_XMM5_Da;
  uint32_t StackParameter28;
  float FloatTransform30;
  float FloatStack34;
  float FloatStack38;
  uint32_t SystemDataFlag0;
  float FloatStack40;
  float FloatStack44;
  float FloatStack48;
  uint32_t SystemDataFlag1;
  float FloatStack50;
  float FloatStack54;
  float FloatStack58;
  uint32_t SystemDataFlag2;
  float FloatStack60;
  float FloatStack64;
  float FloatStack68;
  uint32_t SystemDataPointer9;
  uint32_t InputParameterE0;
  uint32_t InputParameterE8;
  
  floatValue4 = *systemDataIndexPtr;
  BaseValue = systemDataIndexPtr[1];
  floatValue6 = systemDataIndexPtr[2];
  floatValue7 = systemDataIndexPtr[8];
  floatValue8 = systemDataIndexPtr[9];
  ScaleValue = systemDataIndexPtr[10];
  floatValue1 = *(float *)(memoryBlockAddress + 0x124);
  floatValue2 = *(float *)(memoryBlockAddress + 0x130);
  FloatTransform30 = floatValue1 * in_XMM4_Da + (float)SystemResourceManager * floatValue4 + (float)ConfigurationDataPointer * floatValue7;
  FloatStack34 =
       floatValue1 * in_XMM4_Db + (float)((ulong long)SystemResourceManager >> 0x20) * BaseValue +
       (float)((ulong long)ConfigurationDataPointer >> 0x20) * floatValue8;
  FloatStack38 = floatValue1 * in_XMM4_Dc + in_XMM0_Dc * floatValue6 + in_XMM1_Dc * ScaleValue;
  floatValue1 = *(float *)(memoryBlockAddress + 0x138);
  floatValue3 = *(float *)(memoryBlockAddress + 0x140);
  FloatStack40 = in_XMM5_Da * in_XMM4_Da + floatValue2 * floatValue4 + floatValue1 * floatValue7;
  FloatStack44 = in_XMM5_Da * in_XMM4_Db + floatValue2 * BaseValue + floatValue1 * floatValue8;
  FloatStack48 = in_XMM5_Da * in_XMM4_Dc + floatValue2 * floatValue6 + floatValue1 * ScaleValue;
  floatValue1 = *(float *)(memoryBlockAddress + 0x148);
  floatValue2 = *(float *)(memoryBlockAddress + 0x150);
  FloatStack50 = ConfigurationFlag * in_XMM4_Da + floatValue3 * floatValue4 + floatValue1 * floatValue7;
  FloatStack54 = ConfigurationFlag * in_XMM4_Db + floatValue3 * BaseValue + floatValue1 * floatValue8;
  FloatStack58 = ConfigurationFlag * in_XMM4_Dc + floatValue3 * floatValue6 + floatValue1 * ScaleValue;
  floatValue1 = *(float *)(memoryBlockAddress + 0x158);
  FloatStack60 = AdditionalParameter * in_XMM4_Da + floatValue2 * floatValue4 + floatValue1 * floatValue7 + systemDataIndexPtr[0xc];
  FloatStack64 = AdditionalParameter * in_XMM4_Db + floatValue2 * BaseValue + floatValue1 * floatValue8 + systemDataIndexPtr[0xd];
  FloatStack68 = AdditionalParameter * in_XMM4_Dc + floatValue2 * floatValue6 + floatValue1 * ScaleValue + systemDataIndexPtr[0xe];
  StackParameter28 = InputParameterE8;
  SystemDataPointer9 = 0x3f800000;
  SystemDataFlag2 = 0;
  SystemDataFlag1 = 0;
  SystemDataFlag0 = 0;
  ProcessSystemFloatingPointCalculation(0x3f800000,floatValue1 * floatValue7,systemResourceCounterD,&StackBuffer30,InputParameterE0);
  return;
}




/**
 * @brief 初始化系统数据索引指针
 * 
 * 该函数负责初始化系统数据索引指针，设置系统资源计数器
 * 和相关数据结构。用于系统数据管理的初始化工作。
 * 
 * @return 无返回值
 * 
 * 原始函数名：FUN_180078143
 */
void InitializeSystemDataIndexPointer(void)

{
  void* *systemDataIndexPtr;
  uint32_t SystemResourceCounter;
  uint32_t StackParameter28;
  void* SystemDataPointer0;
  ulong long SystemDataPointer1;
  void* SystemDataPointer2;
  ulong long SystemDataPointer3;
  void* SystemDataPointer4;
  ulong long SystemDataPointer5;
  uint32_t SystemDataPointer6;
  uint32_t SystemDataPointer7;
  uint32_t SystemDataPointer8;
  uint32_t SystemDataPointer9;
  uint32_t InputParameterE0;
  uint32_t InputParameterE8;
  
  SystemDataPointer0 = *systemDataIndexPtr;
  SystemDataPointer2 = systemDataIndexPtr[2];
  SystemDataPointer4 = systemDataIndexPtr[4];
  SystemDataPointer6 = *(uint32_t *)(systemDataIndexPtr + 6);
  SystemDataPointer7 = *(uint32_t *)((long long)systemDataIndexPtr + 0x34);
  SystemDataPointer8 = *(uint32_t *)(systemDataIndexPtr + 7);
  StackParameter28 = InputParameterE8;
  SystemDataPointer9 = 0x3f800000;
  SystemDataPointer5 = systemDataIndexPtr[5] & MAX_UNSIGNED_32_BIT;
  SystemDataPointer3 = systemDataIndexPtr[3] & MAX_UNSIGNED_32_BIT;
  SystemDataPointer1 = systemDataIndexPtr[1] & MAX_UNSIGNED_32_BIT;
  ProcessSystemDataPointerCalculation(0x3f800000,SystemDataPointer6,systemResourceCounterD,&StackBuffer30,InputParameterE0);
  return;
}





/**
 * @brief 处理系统资源管理器状态
 * 
 * 该函数负责处理系统资源管理器的状态，包括资源创建、配置
 * 和状态管理。用于系统资源管理器的状态维护工作。
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @return 无返回值
 * 
 * 原始函数名：ProcessSystemResourceManager
 */
void ProcessSystemResourceManagerStatus(long long SystemResourceManager)

{
  long long resourceDataIndex;
  uint32_t resourceCreationFlags;
  uint32_t resourceAllocationContext;
  uint32_t resourceAddress;
  char operationStatusFlag;
  uint8_t ResourceHash;
  void** SystemCurrentNode;
  long long SystemMemoryAddress;
  uint SystemOperationCounter;
  bool isByteValid0;
  float OffsetValue;
  
  SystemMemoryAddress = SystemResourceManager;
  if ((*(long long *)(SystemResourceManager + 0x1c8) != 0) &&
     (resourceDataIndex = *(long long *)(*(long long *)(SystemResourceManager + 0x1c8) + 0x28), resourceDataIndex != 0)) {
    OffsetValue = (*(float *)(resourceDataIndex + 0x74) * *(float *)(resourceDataIndex + 0x88) -
             *(float *)(resourceDataIndex + 0x78) * *(float *)(resourceDataIndex + 0x84)) * *(float *)(resourceDataIndex + 0x90);
    func_0x0001800773c0(OffsetValue,(*(float *)(resourceDataIndex + 0x78) * *(float *)(resourceDataIndex + 0x80) -
                               *(float *)(resourceDataIndex + 0x70) * *(float *)(resourceDataIndex + 0x88)) *
                               *(float *)(resourceDataIndex + 0x94) + OffsetValue +
                               (*(float *)(resourceDataIndex + 0x70) * *(float *)(resourceDataIndex + 0x84) -
                               *(float *)(resourceDataIndex + 0x74) * *(float *)(resourceDataIndex + 0x80)) *
                               *(float *)(resourceDataIndex + 0x98) < 0.0);
  }
  if (*(long long *)(SystemMemoryAddress + 0x1b8) == 0) {
LAB_SystemStatusCheck:
    IsSystemByteValid = (*(byte *)(SystemResourceManager + 0xfd) & 2) != 0;
  }
  else {
    SystemConfigurationFlag = *(uint *)(*(long long *)(SystemMemoryAddress + 0x1b8) + 0x138);
    if ((SystemConfigurationFlag & 0x20) != 0) {
      SystemStatusFlag = '\0';
      goto LAB_SystemStatusSet;
    }
    if ((SystemConfigurationFlag & 0x10) == 0) goto LAB_SystemStatusCheck;
    IsSystemByteValid = (*(byte *)(SystemResourceManager + 0xfd) & 2) == 0;
  }
  SystemStatusFlag = IsSystemByteValid + '\x01';
LAB_SystemStatusSet:
  *(char *)(SystemResourceManager + 0xff) = SystemStatusFlag;
  SystemMemoryAddress = *(long long *)(SystemResourceManager + 0x1b8);
  SystemConfigurationFlag = *(uint *)(SystemMemoryAddress + 0x138) & 0x3000;
  ResourceHashValue = 0;
  if (SystemConfigurationFlag == 0x1000) {
    *(uint8_t *)(SystemResourceManager + 0xf7) = 1;
  }
  else {
    if (SystemConfigurationFlag == 0x2000) {
      ResourceHashValue = 2;
    }
    *(uint8_t *)(SystemResourceManager + 0xf7) = ResourceHashValue;
  }
  if ((((*(float *)(SystemMemoryAddress + 0x288) != 0.0) || (*(float *)(SystemMemoryAddress + 0x28c) != 0.0)) ||
      (*(float *)(SystemMemoryAddress + 0x290) != 0.0)) || (*(float *)(SystemMemoryAddress + 0x294) != 0.0)) {
    resourceCreationFlags = *(uint32_t *)(SystemMemoryAddress + 0x28c);
    resourceAllocationContext = *(uint32_t *)(SystemMemoryAddress + 0x290);
    resourceAddress = *(uint32_t *)(SystemMemoryAddress + 0x294);
    *(uint32_t *)(SystemResourceManager + 0x2a8) = *(uint32_t *)(SystemMemoryAddress + 0x288);
    *(uint32_t *)(SystemResourceManager + 0x2ac) = resourceCreationFlags;
    *(uint32_t *)(SystemResourceManager + 0x2b0) = resourceAllocationContext;
    *(uint32_t *)(SystemResourceManager + 0x2b4) = resourceAddress;
  }
  if (((*(float *)(SystemMemoryAddress + 0x298) != 0.0) || (*(float *)(SystemMemoryAddress + 0x29c) != 0.0)) ||
     ((*(float *)(SystemMemoryAddress + 0x2a0) != 0.0 || (*(float *)(SystemMemoryAddress + 0x2a4) != 0.0)))) {
    resourceCreationFlags = *(uint32_t *)(SystemMemoryAddress + 0x29c);
    resourceAllocationContext = *(uint32_t *)(SystemMemoryAddress + 0x2a0);
    resourceAddress = *(uint32_t *)(SystemMemoryAddress + 0x2a4);
    *(uint32_t *)(SystemResourceManager + 0x2b8) = *(uint32_t *)(SystemMemoryAddress + 0x298);
    *(uint32_t *)(SystemResourceManager + 700) = resourceCreationFlags;
    *(uint32_t *)(SystemResourceManager + 0x2c0) = resourceAllocationContext;
    *(uint32_t *)(SystemResourceManager + 0x2c4) = resourceAddress;
  }
  *(void*2 *)(SystemMemoryAddress + 0x3c0) = 0xffff;
  ValidateSystemResourceManager(SystemResourceManager);
  if ((*(long long *)(SystemResourceManager + 600) == 0) &&
     ((*(uint *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)hashTableNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(hashTableNode + 9) = 0xffffffff;
    *hashTableNode = 0;
    hashTableNode[2] = 0;
    hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0;
    *(uint32_t *)(hashTableNode + 5) = 0xffffffff;
    *(uint32_t *)(hashTableNode + 4) = 0xffffffff;
    hashTableNode[3] = 0;
    *(uint32_t *)(hashTableNode + 8) = 0;
    *(uint32_t *)(hashTableNode + 1) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x44) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x24) = 0;
    *(void* **)(SystemResourceManager + 600) = hashTableNode;
  }
  return;
}





/**
 * @brief 验证系统资源管理器状态
 * 
 * 该函数负责验证系统资源管理器的状态，包括资源可用性、
 * 配置正确性和系统完整性检查。用于系统资源管理的验证工作。
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @return 无返回值
 * 
 * 原始函数名：FUN_1800781f4
 */
void ValidateSystemResourceManagerStatus(long long SystemResourceManager)

{
  long long resourceDataIndex;
  uint32_t resourceCreationFlags;
  uint32_t resourceAllocationContext;
  uint32_t resourceAddress;
  char operationStatusFlag;
  uint8_t ResourceHash;
  long long in_RAX;
  void** SystemCurrentNode;
  uint OperationCode;
  long long memoryBlockAddress;
  bool isSystemBusy;
  float ScalingFactor;
  
  if ((in_RAX != 0) && (resourceDataIndex = *(long long *)(in_RAX + 0x28), resourceDataIndex != 0)) {
    ScalingFactor = (*(float *)(resourceDataIndex + 0x74) * *(float *)(resourceDataIndex + 0x88) -
             *(float *)(resourceDataIndex + 0x78) * *(float *)(resourceDataIndex + 0x84)) * *(float *)(resourceDataIndex + 0x90);
    func_0x0001800773c0(ScalingFactor,(*(float *)(resourceDataIndex + 0x78) * *(float *)(resourceDataIndex + 0x80) -
                               *(float *)(resourceDataIndex + 0x70) * *(float *)(resourceDataIndex + 0x88)) *
                               *(float *)(resourceDataIndex + 0x94) + ScalingFactor +
                               (*(float *)(resourceDataIndex + 0x70) * *(float *)(resourceDataIndex + 0x84) -
                               *(float *)(resourceDataIndex + 0x74) * *(float *)(resourceDataIndex + 0x80)) *
                               *(float *)(resourceDataIndex + 0x98) < 0.0);
  }
  if (*(long long *)(SystemResourceManager + 0x1b8) == 0) {
LAB_SystemStatusCheck:
    isSystemBusy = (*(byte *)(memoryBlockAddress + 0xfd) & 2) != 0;
  }
  else {
    OperationCode = *(uint *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x138);
    if ((OperationCode & 0x20) != 0) {
      systemStatusFlag = '\0';
      goto LAB_SystemStatusSet;
    }
    if ((OperationCode & 0x10) == 0) goto LAB_SystemStatusCheck;
    isSystemBusy = (*(byte *)(memoryBlockAddress + 0xfd) & 2) == 0;
  }
  systemStatusFlag = isSystemBusy + '\x01';
LAB_SystemStatusSet:
  *(char *)(memoryBlockAddress + 0xff) = systemStatusFlag;
  resourceDataIndex = *(long long *)(memoryBlockAddress + 0x1b8);
  OperationCode = *(uint *)(resourceDataIndex + 0x138) & 0x3000;
  ResourceHash = 0;
  if (OperationCode == 0x1000) {
    *(uint8_t *)(memoryBlockAddress + 0xf7) = 1;
  }
  else {
    if (OperationCode == 0x2000) {
      ResourceHash = 2;
    }
    *(uint8_t *)(memoryBlockAddress + 0xf7) = ResourceHash;
  }
  if ((((*(float *)(resourceDataIndex + 0x288) != 0.0) || (*(float *)(resourceDataIndex + 0x28c) != 0.0)) ||
      (*(float *)(resourceDataIndex + 0x290) != 0.0)) || (*(float *)(resourceDataIndex + 0x294) != 0.0)) {
    resourceCreationFlags = *(uint32_t *)(resourceDataIndex + 0x28c);
    resourceAllocationContext = *(uint32_t *)(resourceDataIndex + 0x290);
    resourceAddress = *(uint32_t *)(resourceDataIndex + 0x294);
    *(uint32_t *)(memoryBlockAddress + 0x2a8) = *(uint32_t *)(resourceDataIndex + 0x288);
    *(uint32_t *)(memoryBlockAddress + 0x2ac) = resourceCreationFlags;
    *(uint32_t *)(memoryBlockAddress + 0x2b0) = resourceAllocationContext;
    *(uint32_t *)(memoryBlockAddress + 0x2b4) = resourceAddress;
  }
  if (((*(float *)(resourceDataIndex + 0x298) != 0.0) || (*(float *)(resourceDataIndex + 0x29c) != 0.0)) ||
     ((*(float *)(resourceDataIndex + 0x2a0) != 0.0 || (*(float *)(resourceDataIndex + 0x2a4) != 0.0)))) {
    resourceCreationFlags = *(uint32_t *)(resourceDataIndex + 0x29c);
    resourceAllocationContext = *(uint32_t *)(resourceDataIndex + 0x2a0);
    resourceAddress = *(uint32_t *)(resourceDataIndex + 0x2a4);
    *(uint32_t *)(memoryBlockAddress + 0x2b8) = *(uint32_t *)(resourceDataIndex + 0x298);
    *(uint32_t *)(memoryBlockAddress + 700) = resourceCreationFlags;
    *(uint32_t *)(memoryBlockAddress + 0x2c0) = resourceAllocationContext;
    *(uint32_t *)(memoryBlockAddress + 0x2c4) = resourceAddress;
  }
  *(void*2 *)(resourceDataIndex + 0x3c0) = 0xffff;
  ValidateSystemResourceManager();
  if ((*(long long *)(memoryBlockAddress + 600) == 0) &&
     ((*(uint *)(*(long long *)(memoryBlockAddress + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)hashTableNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(hashTableNode + 9) = 0xffffffff;
    *hashTableNode = 0;
    hashTableNode[2] = 0;
    hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0;
    *(uint32_t *)(hashTableNode + 5) = 0xffffffff;
    *(uint32_t *)(hashTableNode + 4) = 0xffffffff;
    hashTableNode[3] = 0;
    *(uint32_t *)(hashTableNode + 8) = 0;
    *(uint32_t *)(hashTableNode + 1) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x44) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x24) = 0;
    *(void* **)(memoryBlockAddress + 600) = hashTableNode;
  }
  return;
}





/**
 * @brief 处理系统浮点数变换和资源管理
 * 
 * 该函数负责处理系统浮点数变换计算，包括矩阵变换、插值计算
 * 和系统资源管理。用于图形渲染和数学计算中的浮点数处理。
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 * 原始函数名：FUN_180078239
 */
void ProcessSystemFloatTransformation(float SystemResourceManager, float ConfigurationDataPointer, float AdditionalParameter, float ConfigurationFlag)

{
  long long resourceDataIndex;
  uint32_t resourceCreationFlags;
  uint32_t resourceAllocationContext;
  uint32_t resourceAddress;
  char operationStatusFlag;
  uint8_t ResourceHash;
  long long in_RAX;
  void** SystemCurrentNode;
  long long in_RCX;
  uint OperationCode;
  long long memoryBlockAddress;
  bool isSystemBusy;
  float ScalingFactor;
  float in_XMM4_Da;
  float in_XMM5_Da;
  float systemFloatValue;
  
  ScalingFactor = (*(float *)(in_RAX + 0x74) * ConfigurationDataPointer - AdditionalParameter * ConfigurationFlag) * *(float *)(in_RAX + 0x90);
  func_0x0001800773c0(ScalingFactor,(AdditionalParameter * in_XMM4_Da - SystemResourceManager * ConfigurationDataPointer) * *(float *)(in_RAX + 0x94)
                             + ScalingFactor +
                             (in_XMM5_Da * ConfigurationFlag - *(float *)(in_RAX + 0x74) * in_XMM4_Da) *
                             *(float *)(in_RAX + 0x98) < systemFloatValue);
  if (*(long long *)(in_RCX + 0x1b8) == 0) {
LAB_SystemStatusCheck:
    isSystemBusy = (*(byte *)(memoryBlockAddress + 0xfd) & 2) != 0;
  }
  else {
    OperationCode = *(uint *)(*(long long *)(in_RCX + 0x1b8) + 0x138);
    if ((OperationCode & 0x20) != 0) {
      systemStatusFlag = '\0';
      goto LAB_SystemStatusSet;
    }
    if ((OperationCode & 0x10) == 0) goto LAB_SystemStatusCheck;
    isSystemBusy = (*(byte *)(memoryBlockAddress + 0xfd) & 2) == 0;
  }
  systemStatusFlag = isSystemBusy + '\x01';
LAB_SystemStatusSet:
  *(char *)(memoryBlockAddress + 0xff) = systemStatusFlag;
  resourceDataIndex = *(long long *)(memoryBlockAddress + 0x1b8);
  OperationCode = *(uint *)(resourceDataIndex + 0x138) & 0x3000;
  ResourceHash = 0;
  if (OperationCode == 0x1000) {
    *(uint8_t *)(memoryBlockAddress + 0xf7) = 1;
  }
  else {
    if (OperationCode == 0x2000) {
      ResourceHash = 2;
    }
    *(uint8_t *)(memoryBlockAddress + 0xf7) = ResourceHash;
  }
  if ((((systemFloatValue != *(float *)(resourceDataIndex + 0x288)) || (systemFloatValue != *(float *)(resourceDataIndex + 0x28c))
       ) || (systemFloatValue != *(float *)(resourceDataIndex + 0x290))) ||
     (systemFloatValue != *(float *)(resourceDataIndex + 0x294))) {
    resourceCreationFlags = *(uint32_t *)(resourceDataIndex + 0x28c);
    resourceAllocationContext = *(uint32_t *)(resourceDataIndex + 0x290);
    resourceAddress = *(uint32_t *)(resourceDataIndex + 0x294);
    *(uint32_t *)(memoryBlockAddress + 0x2a8) = *(uint32_t *)(resourceDataIndex + 0x288);
    *(uint32_t *)(memoryBlockAddress + 0x2ac) = resourceCreationFlags;
    *(uint32_t *)(memoryBlockAddress + 0x2b0) = resourceAllocationContext;
    *(uint32_t *)(memoryBlockAddress + 0x2b4) = resourceAddress;
  }
  if (((systemFloatValue != *(float *)(resourceDataIndex + 0x298)) || (systemFloatValue != *(float *)(resourceDataIndex + 0x29c)))
     || ((systemFloatValue != *(float *)(resourceDataIndex + 0x2a0) || (systemFloatValue != *(float *)(resourceDataIndex + 0x2a4))
         ))) {
    resourceCreationFlags = *(uint32_t *)(resourceDataIndex + 0x29c);
    resourceAllocationContext = *(uint32_t *)(resourceDataIndex + 0x2a0);
    resourceAddress = *(uint32_t *)(resourceDataIndex + 0x2a4);
    *(uint32_t *)(memoryBlockAddress + 0x2b8) = *(uint32_t *)(resourceDataIndex + 0x298);
    *(uint32_t *)(memoryBlockAddress + 700) = resourceCreationFlags;
    *(uint32_t *)(memoryBlockAddress + 0x2c0) = resourceAllocationContext;
    *(uint32_t *)(memoryBlockAddress + 0x2c4) = resourceAddress;
  }
  *(void*2 *)(resourceDataIndex + 0x3c0) = 0xffff;
  ValidateSystemResourceManager();
  if ((*(long long *)(memoryBlockAddress + 600) == 0) &&
     ((*(uint *)(*(long long *)(memoryBlockAddress + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)hashTableNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(hashTableNode + 9) = 0xffffffff;
    *hashTableNode = 0;
    hashTableNode[2] = 0;
    hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0;
    *(uint32_t *)(hashTableNode + 5) = 0xffffffff;
    *(uint32_t *)(hashTableNode + 4) = 0xffffffff;
    hashTableNode[3] = 0;
    *(uint32_t *)(hashTableNode + 8) = 0;
    *(uint32_t *)(hashTableNode + 1) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x44) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x24) = 0;
    *(void* **)(memoryBlockAddress + 600) = hashTableNode;
  }
  return;
}





// 函数: void CleanupSystemResources(long long SystemResourceManager)
/**
 * @brief 处理系统资源状态和配置
 * 
 * 该函数负责处理系统资源的状态管理和配置操作，包括资源状态检查、
 * 哈希值设置和资源参数配置。用于系统资源的动态管理。
 * 
 * @param SystemResourceManager 系统资源指针，指向需要管理的资源
 * 
 *FUN_1800782a8：ProcessSystemResourceStatusAndConfiguration
 */
void ProcessSystemResourceStatusAndConfiguration(long long SystemResourceManager)

{
  long long resourceDataIndex;
  uint32_t resourceCreationFlags;
  uint32_t resourceAllocationContext;
  uint32_t resourceAddress;
  char systemStatusFlag;
  uint8_t ResourceHash;
  void** systemCurrentNode;
  uint OperationCode;
  long long memoryBlockAddress;
  bool isSystemBusy;
  float systemFloatValue;
  
  if (*(long long *)(SystemResourceManager + 0x1b8) == 0) {
LAB_SystemStatusCheck:
    isSystemBusy = (*(byte *)(memoryBlockAddress + 0xfd) & 2) != 0;
  }
  else {
    OperationCode = *(uint *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x138);
    if ((OperationCode & 0x20) != 0) {
      systemStatusFlag = '\0';
      goto LAB_SystemStatusSet;
    }
    if ((OperationCode & 0x10) == 0) goto LAB_SystemStatusCheck;
    isSystemBusy = (*(byte *)(memoryBlockAddress + 0xfd) & 2) == 0;
  }
  systemStatusFlag = isSystemBusy + '\x01';
LAB_SystemStatusSet:
  *(char *)(memoryBlockAddress + 0xff) = systemStatusFlag;
  resourceDataIndex = *(long long *)(memoryBlockAddress + 0x1b8);
  OperationCode = *(uint *)(resourceDataIndex + 0x138) & 0x3000;
  ResourceHash = 0;
  if (OperationCode == 0x1000) {
    *(uint8_t *)(memoryBlockAddress + 0xf7) = 1;
  }
  else {
    if (OperationCode == 0x2000) {
      ResourceHash = 2;
    }
    *(uint8_t *)(memoryBlockAddress + 0xf7) = ResourceHash;
  }
  if ((((systemFloatValue != *(float *)(resourceDataIndex + 0x288)) || (systemFloatValue != *(float *)(resourceDataIndex + 0x28c))
       ) || (systemFloatValue != *(float *)(resourceDataIndex + 0x290))) ||
     (systemFloatValue != *(float *)(resourceDataIndex + 0x294))) {
    resourceCreationFlags = *(uint32_t *)(resourceDataIndex + 0x28c);
    resourceAllocationContext = *(uint32_t *)(resourceDataIndex + 0x290);
    resourceAddress = *(uint32_t *)(resourceDataIndex + 0x294);
    *(uint32_t *)(memoryBlockAddress + 0x2a8) = *(uint32_t *)(resourceDataIndex + 0x288);
    *(uint32_t *)(memoryBlockAddress + 0x2ac) = resourceCreationFlags;
    *(uint32_t *)(memoryBlockAddress + 0x2b0) = resourceAllocationContext;
    *(uint32_t *)(memoryBlockAddress + 0x2b4) = resourceAddress;
  }
  if (((systemFloatValue != *(float *)(resourceDataIndex + 0x298)) || (systemFloatValue != *(float *)(resourceDataIndex + 0x29c)))
     || ((systemFloatValue != *(float *)(resourceDataIndex + 0x2a0) || (systemFloatValue != *(float *)(resourceDataIndex + 0x2a4))
         ))) {
    resourceCreationFlags = *(uint32_t *)(resourceDataIndex + 0x29c);
    resourceAllocationContext = *(uint32_t *)(resourceDataIndex + 0x2a0);
    resourceAddress = *(uint32_t *)(resourceDataIndex + 0x2a4);
    *(uint32_t *)(memoryBlockAddress + 0x2b8) = *(uint32_t *)(resourceDataIndex + 0x298);
    *(uint32_t *)(memoryBlockAddress + 700) = resourceCreationFlags;
    *(uint32_t *)(memoryBlockAddress + 0x2c0) = resourceAllocationContext;
    *(uint32_t *)(memoryBlockAddress + 0x2c4) = resourceAddress;
  }
  *(void*2 *)(resourceDataIndex + 0x3c0) = 0xffff;
  ValidateSystemResourceManager();
  if ((*(long long *)(memoryBlockAddress + 600) == 0) &&
     ((*(uint *)(*(long long *)(memoryBlockAddress + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)hashTableNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(hashTableNode + 9) = 0xffffffff;
    *hashTableNode = 0;
    hashTableNode[2] = 0;
    hashTableNode[SYSTEM_NODE_IDENTIFIER2_INDEX] = 0;
    *(uint32_t *)(hashTableNode + 5) = 0xffffffff;
    *(uint32_t *)(hashTableNode + 4) = 0xffffffff;
    hashTableNode[3] = 0;
    *(uint32_t *)(hashTableNode + 8) = 0;
    *(uint32_t *)(hashTableNode + 1) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x44) = 0;
    *(uint8_t *)((long long)hashTableNode + 0x24) = 0;
    *(void* **)(memoryBlockAddress + 600) = hashTableNode;
  }
  return;
}





// 函数: void InitializeSystemGlobalData(void)
/**
 * @brief 初始化系统数据索引
 * 
 * 该函数负责初始化系统数据索引结构，包括内存分配、数据指针设置和索引配置。
 * 用于系统数据的索引管理和快速访问。
 * 
 * @return 无返回值
 * 
 *FUN_1800783b0：InitializeSystemDataIndex
 */
void InitializeSystemDataIndex(void)

{
  void** SystemDataPointer;
  long long memoryBlockAddress;
  void* systemDataIndexPtr;
  
  if ((*(uint *)(*(long long *)(memoryBlockAddress + 0x1b8) + 0x388) >> 0x19 & 1) != 0) {
    SystemDataPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,9);
    *(void* *)((long long)SystemDataPointer + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(SystemDataPointer + 9) = 0xffffffff;
    *SystemDataPointer = systemDataIndexPtr;
    SystemDataPointer[2] = systemDataIndexPtr;
    SystemDataPointer[7] = systemDataIndexPtr;
    *(uint32_t *)(SystemDataPointer + 5) = 0xffffffff;
    *(uint32_t *)(SystemDataPointer + 4) = 0xffffffff;
    SystemDataPointer[3] = systemDataIndexPtr;
    *(int *)(SystemDataPointer + 8) = (int)systemDataIndexPtr;
    *(int *)(SystemDataPointer + 1) = (int)systemDataIndexPtr;
    *(char*)((long long)SystemDataPointer + 0x44) = (char)systemDataIndexPtr;
    *(char*)((long long)SystemDataPointer + 0x24) = (char)systemDataIndexPtr;
    *(void* **)(memoryBlockAddress + 600) = SystemDataPointer;
  }
  return;
}



void* * InitializeSystemResourceManager(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = 0xfffffffffffffffe;
  *SystemResourceManager = &SystemResourceDataTableE;
  ExecuteSystemResourceCleanup();
  ConfigureSystemMemoryRegion(SystemResourceManager + 1,8,7,InitializeMemoryManager,SystemOperationStatus);
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0x158);
  }
  return SystemResourceManager;
}





// 函数: void ConfigureSystemResourceManager(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 配置系统资源管理器
 * 
 * 该函数负责配置系统资源管理器，包括资源池设置、数据偏移量配置和线程ID管理。
 * 用于系统资源的配置和初始化。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * @return 无返回值
 * 
 *ExecuteSystemResourceCleanup：ConfigureSystemResourceManager
 */
void ConfigureSystemResourceManager(void* *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  long long ResourceDataOffset;
  uint32_t resourceAddress;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  if (0 < *(int *)(SystemDataBufferPointer + 0x40)) {
    SystemResourceManager[0x26] = *(void* *)(SystemDataBufferPointer + 0x38);
  }
  resourcePoolPointer = SystemResourceManager + 1;
  ResourceDataOffset = 7;
  do {
    PrimaryResourcePointer = (long long *)*resourcePoolPointer;
    *resourcePoolPointer = 0;
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
    resourcePoolPointer = resourcePoolPointer + 1;
    ResourceDataOffset = ResourceDataOffset + -1;
  } while (ResourceDataOffset != 0);
  SystemResourceManager[0x20] = 0x3f8000003f800000;
  SystemResourceManager[0x21] = 0x3f8000003f800000;
  SystemResourceManager[0x22] = 0;
  *(uint32_t *)(SystemResourceManager + 0x23) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x11c) = 0x3f800000;
  SystemResourceManager[0x24] = 0x3f800000;
  *(uint32_t *)(SystemResourceManager + 0x25) = 0;
  *(void* *)((long long)SystemResourceManager + 0x13c) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x144) = 0;
  *(uint32_t *)(SystemResourceManager + 0x29) = 0x3f800000;
  *(uint32_t *)((long long)SystemResourceManager + 0x14c) = 0x3f800000;
  *(void*2 *)(SystemResourceManager + 0x2a) = 0;
  *(uint8_t *)((long long)SystemResourceManager + 0x152) = 1;
  *(uint32_t *)(SystemResourceManager + 0x27) = 0;
  SystemResourceManager[8] = 0x3f800000;
  SystemResourceManager[9] = 0;
  SystemResourceManager[10] = 0x3f80000000000000;
  SystemResourceManager[0xb] = 0;
  *(uint32_t *)(SystemResourceManager + 0xc) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 100) = 0;
  *(uint32_t *)(SystemResourceManager + 0xd) = 0x3f800000;
  *(uint32_t *)((long long)SystemResourceManager + 0x6c) = 0;
  *(uint32_t *)(SystemResourceManager + 0xe) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x74) = 0;
  *(uint32_t *)(SystemResourceManager + 0xf) = 0;
  *(uint32_t *)((long long)SystemResourceManager + 0x7c) = 0x3f800000;
  if ((void* *)*SystemResourceManager == &SystemResourceDataTableE) {
    SystemResourceManager[0x10] = SystemResourceManager[8];
    SystemResourceManager[0x11] = SystemResourceManager[9];
    SystemResourceManager[0x12] = SystemResourceManager[10];
    SystemResourceManager[0x13] = SystemResourceManager[0xb];
    *(uint32_t *)(SystemResourceManager + 0x14) = *(uint32_t *)(SystemResourceManager + 0xc);
    *(uint32_t *)((long long)SystemResourceManager + 0xa4) = *(uint32_t *)((long long)SystemResourceManager + 100);
    *(uint32_t *)(SystemResourceManager + 0x15) = *(uint32_t *)(SystemResourceManager + 0xd);
    *(uint32_t *)((long long)SystemResourceManager + 0xac) = *(uint32_t *)((long long)SystemResourceManager + 0x6c);
    *(uint32_t *)(SystemResourceManager + 0x16) = *(uint32_t *)(SystemResourceManager + 0xe);
    *(uint32_t *)((long long)SystemResourceManager + 0xb4) = *(uint32_t *)((long long)SystemResourceManager + 0x74);
    *(uint32_t *)(SystemResourceManager + 0x17) = *(uint32_t *)(SystemResourceManager + 0xf);
    *(uint32_t *)((long long)SystemResourceManager + 0xbc) = *(uint32_t *)((long long)SystemResourceManager + 0x7c);
    resourceAddress = AllocateSystemResourceAddress();
    *(uint32_t *)((long long)SystemResourceManager + 0x8c) = 0;
    *(uint32_t *)((long long)SystemResourceManager + 0x9c) = 0;
    *(uint32_t *)((long long)SystemResourceManager + 0xac) = 0;
    *(uint32_t *)((long long)SystemResourceManager + 0xbc) = 0x3f800000;
    ConfigureSystemResourceAddress(resourceAddress,SystemResourceManager + 0x18);
  }
  else {
    (**(code **)((void* *)*SystemResourceManager + 0x10))(SystemResourceManager,0,AdditionalParameter,ConfigurationFlag,currentThreadId);
  }
  return;
}





// 函数: void InitializeSystemResourcePool(void* *SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 初始化系统资源数据
 * 
 * 该函数负责初始化系统资源数据，包括数据索引设置和配置标志处理。
 * 用于系统资源数据的初始化和配置。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 无返回值
 * 
 *FUN_1800786e0：InitializeSystemResourceData
 */
void InitializeSystemResourceData(void* *SystemResourceManager,long long ConfigurationDataPointer)

{
  long long resourceDataIndex;
  uint32_t configurationFlags;
  long long *resourceConfigurationPointer;
  void* resourceIdentifier;
  float *transformMatrixPointer;
  void* *resourceNamePointer;
  long long dataIndex;
  long long *memoryAllocationPointer;
  int resourceId;
  float matrixScaleFactor;
  uint32_t operationStatusPrimary;
  uint32_t operationStatusSecondary;
  uint32_t operationStatusTertiary;
  float matrixInterpolationFactorX;
  float matrixInterpolationFactorY;
  float matrixInterpolationFactorZ;
  float matrixInterpolationFactorW;
  float vectorMagnitudeSquared;
  float matrixElementX;
  float matrixElementY;
  float matrixElementZ;
  float matrixElementW;
  float matrixElementA;
  float matrixElementB;
  float matrixElementC;
  float matrixElementD;
  float matrixElementE;
  float matrixElementF;
  float matrixElementG;
  float matrixElementH;
  float matrixElementI;
  float matrixElementJ;
  long long *stackMemoryPointer;
  void* stackBufferArray [2];
  void* stackBufferPointer;
  void* processBufferPointer;
  void* resourceDataBuffer;
  uint32_t bufferFlags;
  
  resourceId = 0;
  memoryAllocationPointer = SystemResourceManager + 1;
  do {
    resourceConfigurationPointer = (long long *)GetResourceConfigurationPointer(ConfigurationDataPointer,resourceId);
    if (resourceConfigurationPointer != (long long *)0x0) {
      stackMemoryPointer = resourceConfigurationPointer;
      (**(code **)(*resourceConfigurationPointer + 0x28))(resourceConfigurationPointer);
    }
    stackMemoryPointer = (long long *)*memoryAllocationPointer;
    *memoryAllocationPointer = (long long)resourceConfigurationPointer;
    if (stackMemoryPointer != (long long *)0x0) {
      (**(code **)(*stackMemoryPointer + 0x38))();
    }
    if ((((*(char *)(ConfigurationDataPointer + 0x380) != '\0') && (*(char *)(ConfigurationDataPointer + 0x381) == '\0')) &&
        (resourceDataIndex = *memoryAllocationPointer, resourceDataIndex != 0)) && ((*(uint *)(resourceDataIndex + 0x328) & 0x200000) == 0)) {
      resourceNamePointer = &SystemStringTemplate;
      if (*(void* **)(resourceDataIndex + 0x18) != (void* *)0x0) {
        resourceNamePointer = *(void* **)(resourceDataIndex + 0x18);
      }
      AllocateSystemMemory(&SystemResourceDataBuffer,resourceNamePointer);
    }
    resourceId = resourceId + 1;
    memoryAllocationPointer = memoryAllocationPointer + 1;
  } while (resourceId < 7);
  resourceIdentifier = GetSystemResourceIdentifier(ConfigurationDataPointer,&processBufferPointer);
  resourceDataIndex = SystemDataBufferPointer;
  resourceId = FindSystemDataIndex(SystemDataBufferPointer,resourceIdentifier);
  if ((resourceId == -1) || (dataIndex = (long long)resourceId * 0x68 + *(long long *)(resourceDataIndex + 0x38), dataIndex == 0)) {
    dataIndex = *(long long *)(resourceDataIndex + 0x28);
  }
  processBufferPointer = &SystemGlobalDataReference;
  if (resourceDataBuffer != 0) {
      SystemCleanupFunction();
  }
  resourceDataBuffer = 0;
  bufferFlags = 0;
  processBufferPointer = &SystemMemoryAllocatorReference;
  if (dataIndex == 0) {
    dataIndex = *(long long *)(SystemDataBufferPointer + 0x38);
  }
  SystemResourceManager[0x26] = dataIndex;
  if ((*(char *)(ConfigurationDataPointer + 0x248) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc730();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x240);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x114) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x254) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc760();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x24c);
  }
  *(uint32_t *)(SystemResourceManager + 0x23) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2f0) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ProcessResourceConfigurationData(*(long long *)(ConfigurationDataPointer + 0x3c8),&processBufferPointer);
    configurationFlags = (uint32_t)processBufferPointer;
    operationStatusPrimary = processBufferPointer._4_4_;
    operationStatusSecondary = (uint32_t)resourceDataBuffer;
    operationStatusTertiary = resourceDataBuffer._4_4_;
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2d0);
    operationStatusPrimary = *(uint32_t *)(ConfigurationDataPointer + 0x2d4);
    operationStatusSecondary = *(uint32_t *)(ConfigurationDataPointer + 0x2d8);
    operationStatusTertiary = *(uint32_t *)(ConfigurationDataPointer + 0x2dc);
  }
  *(uint32_t *)(SystemResourceManager + 0x20) = configurationFlags;
  *(uint32_t *)((long long)SystemResourceManager + 0x104) = operationStatusPrimary;
  *(uint32_t *)(SystemResourceManager + 0x21) = operationStatusSecondary;
  *(uint32_t *)((long long)SystemResourceManager + 0x10c) = operationStatusTertiary;
  if ((*(char *)(ConfigurationDataPointer + 0x2fc) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fca90();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2f4);
  }
  *(uint32_t *)(SystemResourceManager + 0x22) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x260) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fcac0();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 600);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x11c) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x26c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fcb00();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x264);
  }
  *(uint32_t *)(SystemResourceManager + 0x24) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x278) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fcb40();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x270);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x124) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x284) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fcb80();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x27c);
  }
  *(uint32_t *)(SystemResourceManager + 0x25) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x290) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc7a0();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x288);
  }
  *(uint32_t *)(SystemResourceManager + 0x27) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x29c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc7d0();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x294);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x13c) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2a8) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc800();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2a0);
  }
  *(uint32_t *)(SystemResourceManager + 0x28) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2b4) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc840();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2ac);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x144) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2c0) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc880();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2b8);
  }
  *(uint32_t *)(SystemResourceManager + 0x29) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x2cc) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc8c0();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x2c4);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x14c) = configurationFlags;
  if ((*(char *)(ConfigurationDataPointer + 0x29c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    configurationFlags = func_0x0001801fc7d0();
  }
  else {
    configurationFlags = *(uint32_t *)(ConfigurationDataPointer + 0x294);
  }
  *(uint32_t *)((long long)SystemResourceManager + 0x13c) = configurationFlags;
  *(uint8_t *)((long long)SystemResourceManager + 0x152) = *(uint8_t *)(ConfigurationDataPointer + 0x380);
  *(uint8_t *)(SystemResourceManager + 0x2a) = *(uint8_t *)(ConfigurationDataPointer + 0x381);
  if ((*(char *)(ConfigurationDataPointer + 0x35c) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ValidateResourceConfiguration(*(long long *)(ConfigurationDataPointer + 0x3c8),&PrimaryResourcePointer);
  }
  else {
    PrimaryResourcePointer = *(long long **)(ConfigurationDataPointer + 0x34c);
  }
  if ((*(char *)(ConfigurationDataPointer + 0x348) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    InitializeResourceConfiguration(*(long long *)(ConfigurationDataPointer + 0x3c8),SystemStackParameters);
  }
  else {
    SystemStackParameters[0] = *(void* *)(ConfigurationDataPointer + 0x338);
  }
  if ((*(char *)(ConfigurationDataPointer + 0x334) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ProcessResourceConfiguration(*(long long *)(ConfigurationDataPointer + 0x3c8),&SystemConfigurationPointer);
  }
  else {
    SystemConfigurationPointer = *(void* *)(ConfigurationDataPointer + 0x324);
  }
  if ((*(char *)(ConfigurationDataPointer + 800) == '\0') && (*(long long *)(ConfigurationDataPointer + 0x3c8) != 0)) {
    ConfigureResourceSettings(*(long long *)(ConfigurationDataPointer + 0x3c8),&SystemProcessFlags58);
  }
  else {
    SystemProcessFlags58 = *(void* **)(ConfigurationDataPointer + 0x300);
    ThreadContextFlag = *(void* *)(ConfigurationDataPointer + 0x308);
  }
  InitializeSystemResourceManagerParameters(SystemResourceManager + 8,&SystemProcessFlags58,&SystemConfigurationPointer,SystemStackParameters,&PrimaryResourcePointer);
  if ((void* *)*SystemResourceManager == &SystemResourceDataTableE) {
    pBaseValue = (float *)(SystemResourceManager + 0x10);
    *(void* *)pBaseValue = SystemResourceManager[8];
    SystemResourceManager[0x11] = SystemResourceManager[9];
    SystemResourceManager[0x12] = SystemResourceManager[10];
    SystemResourceManager[0x13] = SystemResourceManager[0xb];
    *(uint32_t *)(SystemResourceManager + 0x14) = *(uint32_t *)(SystemResourceManager + 0xc);
    *(uint32_t *)((long long)SystemResourceManager + 0xa4) = *(uint32_t *)((long long)SystemResourceManager + 100);
    *(uint32_t *)(SystemResourceManager + 0x15) = *(uint32_t *)(SystemResourceManager + 0xd);
    *(uint32_t *)((long long)SystemResourceManager + 0xac) = *(uint32_t *)((long long)SystemResourceManager + 0x6c);
    *(uint32_t *)(SystemResourceManager + 0x16) = *(uint32_t *)(SystemResourceManager + 0xe);
    *(uint32_t *)((long long)SystemResourceManager + 0xb4) = *(uint32_t *)((long long)SystemResourceManager + 0x74);
    *(uint32_t *)(SystemResourceManager + 0x17) = *(uint32_t *)(SystemResourceManager + 0xf);
    *(uint32_t *)((long long)SystemResourceManager + 0xbc) = *(uint32_t *)((long long)SystemResourceManager + 0x7c);
    ProcessSystemStatusUpdate();
    *(uint32_t *)((long long)SystemResourceManager + 0x8c) = 0;
    *(uint32_t *)((long long)SystemResourceManager + 0x9c) = 0;
    *(uint32_t *)((long long)SystemResourceManager + 0xac) = 0;
    *(uint32_t *)((long long)SystemResourceManager + 0xbc) = 0x3f800000;
    MagnitudeSquared = pBaseValue[6];
    InterpolationParam4 = pBaseValue[0xd];
    ScalingFactor = pBaseValue[9];
    InterpolationParam5 = pBaseValue[1];
    scaleResult1 = pBaseValue[0xe];
    floatValue23 = pBaseValue[2];
    floatValue25 = pBaseValue[10];
    floatValue28 = pBaseValue[5];
    floatValue24 = InterpolationParam3 * ScalingFactor - InterpolationParam4 * floatValue25;
    floatValue21 = InterpolationParam3 * floatValue28 - InterpolationParam4 * MagnitudeSquared;
    floatValue22 = InterpolationParam3 * InterpolationParam5 - InterpolationParam4 * floatValue23;
    floatValue29 = floatValue28 * floatValue25 - ScalingFactor * MagnitudeSquared;
    ResultValue2 = InterpolationParam5 * floatValue25 - ScalingFactor * floatValue23;
    *(float *)(SystemResourceManager + 0x18) = floatValue29;
    ResultValue1 = InterpolationParam5 * MagnitudeSquared - floatValue28 * floatValue23;
    floatValue30 = floatValue23 * pBaseValue[9] - floatValue25 * pBaseValue[1];
    *(float *)((long long)SystemResourceManager + 0xc4) = floatValue30;
    InterpolationParam4 = pBaseValue[5];
    scaleResult1 = pBaseValue[1];
    *(uint32_t *)((long long)SystemResourceManager + 0xcc) = 0;
    floatValue31 = MagnitudeSquared * InterpolationParam3 - floatValue23 * InterpolationParam4;
    *(float *)(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = floatValue31;
    InterpolationParam2 = MagnitudeSquared * pBaseValue[8] - floatValue25 * pBaseValue[4];
    *(float *)(SystemResourceManager + 0x1a) = InterpolationParam2;
    floatValue27 = floatValue25 * *pBaseValue - floatValue23 * pBaseValue[8];
    *(float *)((long long)SystemResourceManager + 0xd4) = floatValue27;
    InterpolationParam4 = pBaseValue[4];
    scaleResult1 = *pBaseValue;
    *(uint32_t *)((long long)SystemResourceManager + 0xdc) = 0;
    floatValue26 = floatValue23 * InterpolationParam4 - MagnitudeSquared * InterpolationParam3;
    *(float *)(SystemResourceManager + 0x1b) = floatValue26;
    scaleResult1 = ScalingFactor * pBaseValue[4] - floatValue28 * pBaseValue[8];
    *(float *)(SystemResourceManager + 0x1c) = InterpolationParam3;
    ScalingFactor = InterpolationParam5 * pBaseValue[8] - ScalingFactor * *pBaseValue;
    *(float *)((long long)SystemResourceManager + 0xe4) = ScalingFactor;
    MagnitudeSquared = pBaseValue[4];
    InterpolationParam4 = *pBaseValue;
    *(uint32_t *)((long long)SystemResourceManager + 0xec) = 0;
    floatValue28 = floatValue28 * InterpolationParam4 - InterpolationParam5 * MagnitudeSquared;
    *(float *)(SystemResourceManager + 0x1d) = floatValue28;
    InterpolationParam4 = (floatValue21 * pBaseValue[8] - floatValue24 * pBaseValue[4]) - floatValue29 * pBaseValue[0xc];
    *(float *)(SystemResourceManager + 0x1e) = InterpolationParam4;
    floatValue25 = (floatValue24 * *pBaseValue - floatValue22 * pBaseValue[8]) + ResultValue2 * pBaseValue[0xc];
    *(float *)((long long)SystemResourceManager + 0xf4) = floatValue25;
    floatValue23 = (floatValue22 * pBaseValue[4] - floatValue21 * *pBaseValue) - ResultValue1 * pBaseValue[0xc];
    *(float *)(SystemResourceManager + 0x1f) = floatValue23;
    InterpolationParam5 = (floatValue29 * *pBaseValue - ResultValue2 * pBaseValue[4]) + ResultValue1 * pBaseValue[8];
    *(float *)((long long)SystemResourceManager + 0xfc) = InterpolationParam5;
    MagnitudeSquared = floatValue30 * pBaseValue[4] + floatValue29 * *pBaseValue + floatValue31 * pBaseValue[8];
    if (MagnitudeSquared != 1.0) {
      MagnitudeSquared = 1.0 / MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x1a) = InterpolationParam2 * MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x1c) = InterpolationParam3 * MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x18) = floatValue29 * MagnitudeSquared;
      *(float *)((long long)SystemResourceManager + 0xc4) = floatValue30 * MagnitudeSquared;
      *(float *)(SystemResourceManager + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = floatValue31 * MagnitudeSquared;
      *(float *)((long long)SystemResourceManager + 0xd4) = floatValue27 * MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x1b) = floatValue26 * MagnitudeSquared;
      *(float *)((long long)SystemResourceManager + 0xe4) = ScalingFactor * MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x1d) = floatValue28 * MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x1e) = InterpolationParam4 * MagnitudeSquared;
      *(float *)((long long)SystemResourceManager + 0xf4) = floatValue25 * MagnitudeSquared;
      *(float *)(SystemResourceManager + 0x1f) = floatValue23 * MagnitudeSquared;
      *(float *)((long long)SystemResourceManager + 0xfc) = InterpolationParam5 * MagnitudeSquared;
    }
    return;
  }
  (**(code **)((void* *)*SystemResourceManager + 0x10))(SystemResourceManager);
  return;
}




// 函数: void ProcessSystemFloatOperations(long long SystemResourceManager)
/**
 * @brief 处理系统浮点数运算和插值计算
 * 
 * 该函数负责处理系统中的浮点数运算，包括插值计算、
 * 比例因子计算和幅度值计算。用于系统数学运算处理。
 * 
 * @param SystemResourceManager 系统资源指针，包含运算所需的资源数据
 * 
 *FUN_180078c10：ProcessSystemFloatCalculations
 */
void ProcessSystemFloatCalculations(long long SystemResourceManager)

{
  float *primaryFloatPointer;
  float secondaryFloatValue;
  float tertiaryFloatValue;
  float quaternaryFloatValue;
  float fifthFloatValue;
  float sixthFloatValue;
  float seventhFloatValue;
  float eighthFloatValue;
  float ninthFloatValue;
  float scaleFactor;
  float eleventhFloatValue;
  float ratioValue;
  float firstInterpolationFactor;
  float secondInterpolationFactor;
  float thirdInterpolationFactor;
  float fourthInterpolationFactor;
  float fifthInterpolationFactor;
  float firstMagnitudeSquared;
  float nineteenthFloatValue;
  float twentiethFloatValue;
  
  primaryFloatPointer = (float *)(SystemResourceManager + 0x80);
  *(void* *)primaryFloatPointer = *(void* *)(SystemResourceManager + 0x40);
  *(void* *)(SystemResourceManager + 0x88) = *(void* *)(SystemResourceManager + 0x48);
  *(void* *)(SystemResourceManager + 0x90) = *(void* *)(SystemResourceManager + 0x50);
  *(void* *)(SystemResourceManager + 0x98) = *(void* *)(SystemResourceManager + 0x58);
  *(uint32_t *)(SystemResourceManager + 0xa0) = *(uint32_t *)(SystemResourceManager + 0x60);
  *(uint32_t *)(SystemResourceManager + 0xa4) = *(uint32_t *)(SystemResourceManager + 100);
  *(uint32_t *)(SystemResourceManager + 0xa8) = *(uint32_t *)(SystemResourceManager + 0x68);
  *(uint32_t *)(SystemResourceManager + 0xac) = *(uint32_t *)(SystemResourceManager + 0x6c);
  *(uint32_t *)(SystemResourceManager + 0xb0) = *(uint32_t *)(SystemResourceManager + 0x70);
  *(uint32_t *)(SystemResourceManager + 0xb4) = *(uint32_t *)(SystemResourceManager + 0x74);
  *(uint32_t *)(SystemResourceManager + 0xb8) = *(uint32_t *)(SystemResourceManager + 0x78);
  *(uint32_t *)(SystemResourceManager + 0xbc) = *(uint32_t *)(SystemResourceManager + 0x7c);
  ProcessSystemStatusUpdate();
  *(uint32_t *)(SystemResourceManager + 0xbc) = 0x3f800000;
  *(uint32_t *)(SystemResourceManager + 0x8c) = 0;
  *(uint32_t *)(SystemResourceManager + 0x9c) = 0;
  *(uint32_t *)(SystemResourceManager + 0xac) = 0;
  floatValue7 = primaryFloatPointer[6];
  BaseValue = primaryFloatPointer[0xd];
  floatValue2 = primaryFloatPointer[9];
  floatValue6 = primaryFloatPointer[1];
  floatValue4 = primaryFloatPointer[0xe];
  RatioValue = primaryFloatPointer[2];
  InterpolationParam2 = primaryFloatPointer[10];
  InterpolationParam5 = primaryFloatPointer[5];
  InterpolationParam1 = floatValue4 * floatValue2 - BaseValue * InterpolationParam2;
  ScalingFactor = floatValue4 * InterpolationParam5 - BaseValue * floatValue7;
  OffsetValue = floatValue4 * floatValue6 - BaseValue * RatioValue;
  MagnitudeSquared = InterpolationParam5 * InterpolationParam2 - floatValue2 * floatValue7;
  ScaleValue = floatValue6 * InterpolationParam2 - floatValue2 * RatioValue;
  *(float *)(SystemResourceManager + 0xc0) = MagnitudeSquared;
  floatValue8 = floatValue6 * floatValue7 - InterpolationParam5 * RatioValue;
  ResultValue1 = RatioValue * primaryFloatPointer[9] - InterpolationParam2 * primaryFloatPointer[1];
  *(float *)(SystemResourceManager + 0xc4) = ResultValue1;
  BaseValue = primaryFloatPointer[5];
  floatValue4 = primaryFloatPointer[1];
  *(uint32_t *)(SystemResourceManager + 0xcc) = 0;
  ResultValue2 = floatValue7 * floatValue4 - RatioValue * BaseValue;
  *(float *)(SystemResourceManager + 200) = ResultValue2;
  floatValue3 = floatValue7 * primaryFloatPointer[8] - InterpolationParam2 * primaryFloatPointer[4];
  *(float *)(SystemResourceManager + 0xd0) = floatValue3;
  InterpolationParam4 = InterpolationParam2 * *primaryFloatPointer - RatioValue * primaryFloatPointer[8];
  *(float *)(SystemResourceManager + 0xd4) = InterpolationParam4;
  BaseValue = primaryFloatPointer[4];
  floatValue4 = *primaryFloatPointer;
  *(uint32_t *)(SystemResourceManager + 0xdc) = 0;
  scaleResult1 = RatioValue * BaseValue - floatValue7 * floatValue4;
  *(float *)(SystemResourceManager + 0xd8) = InterpolationParam3;
  floatValue4 = floatValue2 * primaryFloatPointer[4] - InterpolationParam5 * primaryFloatPointer[8];
  *(float *)(SystemResourceManager + 0xe0) = floatValue4;
  floatValue2 = floatValue6 * primaryFloatPointer[8] - floatValue2 * *primaryFloatPointer;
  *(float *)(SystemResourceManager + 0xe4) = floatValue2;
  floatValue7 = primaryFloatPointer[4];
  BaseValue = *primaryFloatPointer;
  *(uint32_t *)(SystemResourceManager + 0xec) = 0;
  InterpolationParam5 = InterpolationParam5 * BaseValue - floatValue6 * floatValue7;
  *(float *)(SystemResourceManager + 0xe8) = InterpolationParam5;
  BaseValue = (ScalingFactor * primaryFloatPointer[8] - InterpolationParam1 * primaryFloatPointer[4]) - MagnitudeSquared * primaryFloatPointer[0xc];
  *(float *)(SystemResourceManager + 0xf0) = BaseValue;
  InterpolationParam2 = (InterpolationParam1 * *primaryFloatPointer - OffsetValue * primaryFloatPointer[8]) + ScaleValue * primaryFloatPointer[0xc];
  *(float *)(SystemResourceManager + 0xf4) = InterpolationParam2;
  RatioValue = (OffsetValue * primaryFloatPointer[4] - ScalingFactor * *primaryFloatPointer) - floatValue8 * primaryFloatPointer[0xc];
  *(float *)(SystemResourceManager + 0xf8) = RatioValue;
  floatValue6 = (MagnitudeSquared * *primaryFloatPointer - ScaleValue * primaryFloatPointer[4]) + floatValue8 * primaryFloatPointer[8];
  *(float *)(SystemResourceManager + 0xfc) = floatValue6;
  floatValue7 = ResultValue1 * primaryFloatPointer[4] + MagnitudeSquared * *primaryFloatPointer + ResultValue2 * primaryFloatPointer[8];
  if (floatValue7 != 1.0) {
    floatValue7 = 1.0 / floatValue7;
    *(float *)(SystemResourceManager + 0xd0) = floatValue3 * floatValue7;
    *(float *)(SystemResourceManager + 0xe0) = floatValue4 * floatValue7;
    *(float *)(SystemResourceManager + 0xc0) = MagnitudeSquared * floatValue7;
    *(float *)(SystemResourceManager + 0xc4) = ResultValue1 * floatValue7;
    *(float *)(SystemResourceManager + 200) = ResultValue2 * floatValue7;
    *(float *)(SystemResourceManager + 0xd4) = InterpolationParam4 * floatValue7;
    *(float *)(SystemResourceManager + 0xd8) = InterpolationParam3 * floatValue7;
    *(float *)(SystemResourceManager + 0xe4) = floatValue2 * floatValue7;
    *(float *)(SystemResourceManager + 0xe8) = InterpolationParam5 * floatValue7;
    *(float *)(SystemResourceManager + 0xf0) = BaseValue * floatValue7;
    *(float *)(SystemResourceManager + 0xf4) = InterpolationParam2 * floatValue7;
    *(float *)(SystemResourceManager + 0xf8) = RatioValue * floatValue7;
    *(float *)(SystemResourceManager + 0xfc) = floatValue6 * floatValue7;
  }
  return;
}




/**
 * @brief 序列化系统资源管理器数据
 * 
 * 将系统资源管理器中的数据按照固定格式序列化到配置数据缓冲区中。
 * 该函数处理一个20元素的数据结构，其中特定位置（索引4, 8, 12）被设置为浮点数1.0。
 * 用于系统资源数据的标准化存储和传输。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要序列化的源数据
 * @param ConfigurationDataPointer 配置数据指针，目标缓冲区用于存储序列化后的数据
 * @return 无返回值
 */
void SerializeSystemResourceManagerData(uint32_t *SystemResourceManager,long long *ConfigurationDataPointer)

{
  uint32_t SystemOperationStatus;
  uint32_t *SystemHashEntryPointer;
  
  SystemOperationStatus = *SystemResourceManager;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[2];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[3];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[5];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[6];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[7];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[9];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[10];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0xb];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0xd];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0xe];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0xf];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = 0x3f800000;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0x11];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0x12];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0x13];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0x14];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0x15];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashEntryPointer = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashEntryPointer = (uint32_t *)ConfigurationDataPointer[1];
  SystemOperationStatus = SystemResourceManager[0x16];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashEntryPointer) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashEntryPointer + (4 - *ConfigurationDataPointer));
    *(uint32_t *)ConfigurationDataPointer[1] = SystemOperationStatus;
  }
  else {
    *SystemHashEntryPointer = SystemOperationStatus;
  }
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  return;
}




// 函数: void ValidateSystemResourceStatus(long long SystemResourceManager)
/**
 * @brief 系统资源管理器初始化函数
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理器的各种参数和状态。
 * 包括资源句柄、系统状态标志和资源数据的初始化。
 * 
 * @param SystemResourceManager 资源管理器指针，指向需要初始化的资源管理器
 * 
 *ValidateSystemString：InitializeSystemResourceManagerEx
 */
void InitializeSystemResourceManagerEx(long long SystemResourceManager)

{
  long long systemDataIndex;
  long long systemResourceHandle;
  byte systemConfigurationFlag;
  
  systemResourceHandle = *(long long *)(SystemResourceManager + 0x210);
  *(uint32_t *)(SystemResourceManager + 0x1f8) = *(uint32_t *)(systemResourceHandle + 0x10);
  *(uint32_t *)(SystemResourceManager + 0x1fc) = *(uint32_t *)(systemResourceHandle + 0x88);
  *(uint32_t *)(SystemResourceManager + 0x200) = *(uint32_t *)(systemResourceHandle + 0x60);
  systemConfigurationFlag = *(byte *)(SystemResourceManager + 0xfd) & 0x40;
  if ((((systemConfigurationFlag != 0) && (systemResourceHandle != 0)) || (*(long long *)(SystemResourceManager + 0x1b0) == 0)) ||
     (systemDataIndex = GetSystemConfigurationStatus(), SystemResourceManager == systemDataIndex)) {
    *(uint32_t *)(SystemResourceManager + 0x204) = *(uint32_t *)(systemResourceHandle + 200);
  }
  if (((systemConfigurationFlag == 0) || (systemResourceHandle == 0)) &&
     ((*(long long *)(SystemResourceManager + 0x1b0) != 0 && (systemDataIndex = GetSystemConfigurationStatus(), SystemResourceManager != systemDataIndex)))) {
    return;
  }
  *(uint *)(SystemResourceManager + 0x208) = (uint)*(ushort *)(systemResourceHandle + 0xc0);
  return;
}





// 函数: void ConfigureSystemResourceParameters(long long SystemResourceManager,long long ConfigurationDataPointer)
/**
 * @brief 系统资源配置处理函数
 * 
 * 该函数负责处理系统资源的配置和初始化，包括资源分配、
 * 状态设置和数据传输等功能。这是系统资源管理的重要组成部分。
 * 
 * @param SystemResourceManager 资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *ProcessSystemResourceConfiguration：ProcessSystemResourceConfiguration
 */
void ProcessSystemResourceConfiguration(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  long long *primaryResourcePointer;
  int *systemCounterPointer;
  long long *resourceOffsetPointer;
  byte *systemDataPointer;
  void* *threadIdPointer;
  float scaleFactor1;
  float scaleFactor2;
  float scaleFactor3;
  float scaleFactor4;
  float scaleFactor5;
  float scaleFactor6;
  float scaleFactor7;
  float scaleFactor8;
  float scaleFactor9;
  uint8_t SystemOperationStatus5;
  char CharacterVariable16;
  long long resourceDataIndex7;
  float *pMagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  void* resourceAllocationContext1;
  uint32_t resourceAllocationContext2;
  long long ResourceDataOffset3;
  long long *SystemResourceOffsetPointer4;
  long long ResourceDataOffset5;
  uint resourceAllocationContext6;
  int systemCounter7;
  uint resourceAllocationContext8;
  int systemCounter9;
  ulong long resourceAddress0;
  char *pSystemOperationStatusFlag1;
  uint *presourceAddress2;
  int systemIndex3;
  int systemIndex4;
  int systemIndex5;
  uint32_t *presourceAddress6;
  uint *presourceAddress7;
  ulong long resourceAddress8;
  ulong long resourceAddress9;
  bool isMemoryReady0;
  
  resourceDataIndex7 = SystemDataMemoryContext;
  ResourceDataOffset3 = SystemResourceManager;
  if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
    ResourceDataOffset3 = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  LOCK();
  pointerToInteger2 = (int *)(resourceDataIndex7 + 0xed8);
  systemIndex3 = *pointerToInteger2;
  *pointerToInteger2 = *pointerToInteger2 + *(int *)(ResourceDataOffset3 + 0x200);
  UNLOCK();
  resourceDataIndex7 = *(long long *)(SystemResourceManager + 600);
  SystemOperationStatus5 = *(uint8_t *)(ConfigurationDataPointer + 0x24);
  resourceAllocationContext2 = *(uint32_t *)(ConfigurationDataPointer + 0x20);
  charStatus6 = *(char *)(ConfigurationDataPointer + 0xd);
  *(uint32_t *)(resourceDataIndex7 + 0x48) = *(uint32_t *)(resourceDataIndex7 + 0x2c);
  *(uint32_t *)(resourceDataIndex7 + 0x50) = *(uint32_t *)(resourceDataIndex7 + 0x4c);
  *(int *)(resourceDataIndex7 + 0x4c) = systemIndex3;
  *(uint8_t *)(resourceDataIndex7 + 0x44) = SystemOperationStatus5;
  *(uint32_t *)(resourceDataIndex7 + 0x2c) = resourceAllocationContext2;
  if (charStatus6 != -1) {
    resourceAllocationContext8 = (int)*(char *)(ConfigurationDataPointer + 0xd) + *(int *)(ConfigurationDataPointer + 0x18);
    pMagnitudeSquared = (float *)**(long long **)(SystemResourceManager + 600);
    resourceAllocationContext6 = resourceAllocationContext8 >> QUADRANT_SHIFT_BITS;
    resourceDataIndex7 = *(long long *)
              ((long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc30 +
              (ulong long)resourceAllocationContext6 * 8);
    ResourceDataOffset3 = (ulong long)(resourceAllocationContext8 + resourceAllocationContext6 * -0x2000) * 0x40;
    resourceAllocationContext1 = ((void* *)(resourceDataIndex7 + ResourceDataOffset3))[1];
    *(void* *)pMagnitudeSquared = *(void* *)(resourceDataIndex7 + ResourceDataOffset3);
    *(void* *)(pMagnitudeSquared + 2) = resourceAllocationContext1;
    SystemThreadContext = (void* *)(resourceDataIndex7 + 0x10 + ResourceDataOffset3);
    resourceAllocationContext1 = SystemThreadContext[1];
    *(void* *)(pMagnitudeSquared + 4) = *SystemThreadContext;
    *(void* *)(pMagnitudeSquared + 6) = resourceAllocationContext1;
    SystemThreadContext = (void* *)(resourceDataIndex7 + 0x20 + ResourceDataOffset3);
    resourceAllocationContext1 = SystemThreadContext[1];
    *(void* *)(pMagnitudeSquared + 8) = *SystemThreadContext;
    *(void* *)(pMagnitudeSquared + 10) = resourceAllocationContext1;
    SystemThreadContext = (void* *)(resourceDataIndex7 + 0x30 + ResourceDataOffset3);
    resourceAllocationContext1 = SystemThreadContext[1];
    *(void* *)(pMagnitudeSquared + 0xc) = *SystemThreadContext;
    *(void* *)(pMagnitudeSquared + 0xe) = resourceAllocationContext1;
    resourceDataIndex7 = *(long long *)(ConfigurationDataPointer + 0x10);
    ResultValue1 = pMagnitudeSquared[8];
    ResultValue2 = pMagnitudeSquared[9];
    floatValue21 = pMagnitudeSquared[10];
    floatValue22 = pMagnitudeSquared[0xb];
    floatValue23 = *pMagnitudeSquared;
    floatValue24 = pMagnitudeSquared[1];
    floatValue25 = pMagnitudeSquared[2];
    floatValue26 = pMagnitudeSquared[3];
    floatValue27 = pMagnitudeSquared[4];
    floatValue28 = pMagnitudeSquared[5];
    floatValue29 = pMagnitudeSquared[6];
    floatValue30 = pMagnitudeSquared[7];
    floatValue6 = *(float *)(resourceDataIndex7 + 0x374);
    floatValue7 = *(float *)(resourceDataIndex7 + 0x370);
    floatValue8 = *(float *)(resourceDataIndex7 + 0x378);
    ScaleValue = *(float *)(resourceDataIndex7 + 900);
    ScalingFactor = *(float *)(resourceDataIndex7 + 0x394);
    OffsetValue = *(float *)(resourceDataIndex7 + 0x380);
    RatioValue = *(float *)(resourceDataIndex7 + 0x388);
    InterpolationParam1 = *(float *)(resourceDataIndex7 + 0x390);
    InterpolationParam2 = *(float *)(resourceDataIndex7 + 0x398);
    *pMagnitudeSquared = floatValue6 * floatValue27 + floatValue7 * floatValue23 + floatValue8 * ResultValue1;
    pMagnitudeSquared[1] = floatValue6 * floatValue28 + floatValue7 * floatValue24 + floatValue8 * ResultValue2;
    pMagnitudeSquared[2] = floatValue6 * floatValue29 + floatValue7 * floatValue25 + floatValue8 * floatValue21;
    pMagnitudeSquared[3] = floatValue6 * floatValue30 + floatValue7 * floatValue26 + floatValue8 * floatValue22;
    pMagnitudeSquared[4] = ScaleValue * floatValue27 + OffsetValue * floatValue23 + RatioValue * ResultValue1;
    pMagnitudeSquared[5] = ScaleValue * floatValue28 + OffsetValue * floatValue24 + RatioValue * ResultValue2;
    pMagnitudeSquared[6] = ScaleValue * floatValue29 + OffsetValue * floatValue25 + RatioValue * floatValue21;
    pMagnitudeSquared[7] = ScaleValue * floatValue30 + OffsetValue * floatValue26 + RatioValue * floatValue22;
    pMagnitudeSquared[8] = ScalingFactor * floatValue27 + InterpolationParam1 * floatValue23 + InterpolationParam2 * ResultValue1;
    pMagnitudeSquared[9] = ScalingFactor * floatValue28 + InterpolationParam1 * floatValue24 + InterpolationParam2 * ResultValue2;
    pMagnitudeSquared[10] = ScalingFactor * floatValue29 + InterpolationParam1 * floatValue25 + InterpolationParam2 * floatValue21;
    pMagnitudeSquared[0xb] = ScalingFactor * floatValue30 + InterpolationParam1 * floatValue26 + InterpolationParam2 * floatValue22;
  }
  resourceDataIndex7 = *(long long *)(SystemResourceManager + 600);
  if (*(int *)(resourceDataIndex7 + 0x28) != *(int *)(SystemGlobalStatusFlags + 0x224)) {
    systemIndex3 = *(int *)(resourceDataIndex7 + 0x1c) + *(int *)(resourceDataIndex7 + 0x18);
    *(int *)(resourceDataIndex7 + 0x28) = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (0 < systemIndex3) {
      ResourceDataOffset3 = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
      resourceAllocationContext2 = AllocateSystemResourceContext(ResourceDataOffset3,systemIndex3);
      *(uint32_t *)(resourceDataIndex7 + 0x30) = resourceAllocationContext2;
      ProcessSystemResourceContext(ResourceDataOffset3,resourceAllocationContext2);
      if (*(long long *)(resourceDataIndex7 + 0x10) == 0) {
        if (*(int *)(resourceDataIndex7 + 0x18) != 0) {
          *(uint32_t *)(resourceDataIndex7 + 0x2c) = *(uint32_t *)(resourceDataIndex7 + 0x30);
          return;
        }
      }
      else {
        charStatus6 = *(char *)(resourceDataIndex7 + 0x44);
        resourceAddress0 = (ulong long)charStatus6;
        PrimaryResourcePointer = (long long *)(resourceDataIndex7 + 0x38);
        systemIndex3 = (int)charStatus6;
        if (*(int *)(resourceDataIndex7 + 0x40) == (int)charStatus6) {
          SystemResourceOffsetPointer4 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(resourceDataIndex7 + 0x40) = systemIndex3;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus6 == '\0') {
            SystemResourceOffsetPointer4 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            SystemResourceOffsetPointer4 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus6 * 4);
            *PrimaryResourcePointer = (long long)SystemResourceOffsetPointer4;
          }
        }
        if (SystemResourceOffsetPointer4 != (long long *)0x0) {
          systemIndex4 = 0;
          resourceAllocationContext6 = (uint)charStatus6;
          systemIndex5 = systemIndex4;
          if ((0 < systemIndex3) && (0xf < resourceAllocationContext6)) {
            systemCounter9 = *(int *)(resourceDataIndex7 + 0x2c);
            SystemResourceOffsetPointer = (long long *)((long long)SystemResourceOffsetPointer4 + (long long)(charStatus6 + -1) * 4);
            if ((((long long *)(resourceDataIndex7 + 0x2c) < SystemResourceOffsetPointer4) || (SystemResourceOffsetPointer < (long long *)(resourceDataIndex7 + 0x2c)))
               && ((PrimaryResourcePointer < SystemResourceOffsetPointer4 || (systemIndex5 = 0, SystemResourceOffsetPointer < PrimaryResourcePointer)))) {
              resourceAllocationContext8 = resourceAllocationContext6 & 0x8000000f;
              if ((int)resourceAllocationContext8 < 0) {
                resourceAllocationContext8 = (resourceAllocationContext8 - 1 | 0xfffffff0) + 1;
              }
              SystemResourceOffsetPointer4 = SystemResourceOffsetPointer4 + 4;
              systemCounter7 = 8;
              do {
                *(int *)(SystemResourceOffsetPointer4 + -4) = systemIndex4 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -0x1c) = systemIndex4 + 1 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + -3) = systemIndex4 + 2 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -0x14) = systemIndex4 + 3 + systemCounter9;
                systemIndex4 = systemIndex4 + 0x10;
                *(int *)(SystemResourceOffsetPointer4 + -2) = systemCounter7 + -4 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -0xc) = systemCounter7 + -3 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + -1) = systemCounter7 + -2 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -4) = systemCounter7 + -1 + systemCounter9;
                *(int *)SystemResourceOffsetPointer4 = systemCounter7 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 4) = systemCounter7 + 1 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + 1) = systemCounter7 + 2 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 0xc) = systemCounter7 + 3 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + 2) = systemCounter7 + 4 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 0x14) = systemCounter7 + 5 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + 3) = systemCounter7 + 6 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 0x1c) = systemCounter7 + 7 + systemCounter9;
                SystemResourceOffsetPointer4 = SystemResourceOffsetPointer4 + 8;
                systemCounter7 = systemCounter7 + 0x10;
                systemIndex5 = systemIndex4;
              } while (systemIndex4 < (int)(resourceAllocationContext6 - resourceAllocationContext8));
            }
          }
          for (ResourceDataOffset3 = (long long)systemIndex5; ResourceDataOffset3 < (long long)resourceAddress0; ResourceDataOffset3 = ResourceDataOffset3 + 1) {
            systemIndex4 = *(int *)(resourceDataIndex7 + 0x2c) + systemIndex5;
            systemIndex5 = systemIndex5 + 1;
            *(int *)(*PrimaryResourcePointer + ResourceDataOffset3 * 4) = systemIndex4;
          }
          systemIndex5 = *(int *)(resourceDataIndex7 + 0x18);
          systemIndex4 = 0;
          if (0 < (long long)systemIndex5) {
            ResourceDataOffset3 = 0;
            do {
              systemCounter9 = *(int *)(resourceDataIndex7 + 0x30) + systemIndex4;
              systemIndex4 = systemIndex4 + 1;
              pisResourceAvailable = (byte *)(*(long long *)(resourceDataIndex7 + 0x10) + ResourceDataOffset3);
              ResourceDataOffset3 = ResourceDataOffset3 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisResourceAvailable * 4) = systemCounter9;
            } while (ResourceDataOffset3 < systemIndex5);
          }
        }
        presourceAddress2 = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 +
                          SystemDataMemoryContext + 0x9d0);
        if (systemIndex3 == 0) {
          resourceAllocationContext6 = (int)charStatus6 - 1;
        }
        else {
          LOCK();
          resourceAllocationContext6 = *presourceAddress2;
          *presourceAddress2 = *presourceAddress2 + (int)charStatus6;
          UNLOCK();
          resourceAddress8 = (ulong long)(resourceAllocationContext6 >> 0xb);
          resourceAddress9 = (ulong long)(charStatus6 + -1 + resourceAllocationContext6 >> 0xb);
          if (resourceAddress8 <= resourceAddress9) {
            pSystemOperationStatusFlag1 = (char *)((long long)presourceAddress2 + resourceAddress8 + 0x108);
            ResourceDataOffset3 = (resourceAddress9 - resourceAddress8) + 1;
            presourceAddress7 = presourceAddress2 + resourceAddress8 * 2 + 2;
            do {
              systemIndex5 = (int)resourceAddress8;
              if (*(long long *)presourceAddress7 == 0) {
                ResourceDataOffset5 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isMemoryReady0 = *(long long *)(presourceAddress2 + (long long)systemIndex5 * 2 + 2) == 0;
                if (isMemoryReady0) {
                  *(long long *)(presourceAddress2 + (long long)systemIndex5 * 2 + 2) = ResourceDataOffset5;
                }
                UNLOCK();
                if (isMemoryReady0) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex5 + 0x108 + (long long)presourceAddress2) = 0;
                  UNLOCK();
                }
                else {
                  if (ResourceDataOffset5 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*pSystemOperationStatusFlag1 != '\0');
                }
              }
              else {
                do {
                } while (*pSystemOperationStatusFlag1 != '\0');
              }
              resourceAddress8 = (ulong long)(systemIndex5 + 1);
              presourceAddress7 = presourceAddress7 + 2;
              pSystemOperationStatusFlag1 = pSystemOperationStatusFlag1 + 1;
              ResourceDataOffset3 = ResourceDataOffset3 + -1;
            } while (ResourceDataOffset3 != 0);
          }
        }
        presourceAddress6 = *(uint32_t **)(resourceDataIndex7 + 0x38);
        resourceAllocationContext8 = resourceAllocationContext6 >> 0xb;
        *(uint *)(resourceDataIndex7 + 0x2c) = resourceAllocationContext6;
        if (resourceAllocationContext8 == (int)charStatus6 + resourceAllocationContext6 >> 0xb) {
            memcpy(*(long long *)(presourceAddress2 + (ulong long)resourceAllocationContext8 * 2 + 2) +
                 (ulong long)(resourceAllocationContext6 + resourceAllocationContext8 * -0x800) * 4,presourceAddress6,(resourceAddress0 & MAX_UNSIGNED_32_BIT) << 2);
        }
        if (systemIndex3 != 0) {
          resourceAddress0 = resourceAddress0 & MAX_UNSIGNED_32_BIT;
          do {
            resourceAllocationContext2 = *presourceAddress6;
            presourceAddress6 = presourceAddress6 + 1;
            *(uint32_t *)
             (*(long long *)(presourceAddress2 + (ulong long)(resourceAllocationContext6 >> 0xb) * 2 + 2) +
             (ulong long)(resourceAllocationContext6 + (resourceAllocationContext6 >> 0xb) * -0x800) * 4) = resourceAllocationContext2;
            resourceAddress0 = resourceAddress0 - 1;
            resourceAllocationContext6 = resourceAllocationContext6 + 1;
          } while (resourceAddress0 != 0);
        }
      }
    }
  }
  return;
}





/**
 * @brief 处理系统资源验证和计算
 * 
 * 对系统资源进行验证操作，包括浮点数计算、资源分配和状态检查。
 * 该函数处理复杂的资源管理操作，包括插值计算、内存分配和资源状态更新。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要处理的系统资源
 * @return 无返回值
 */
void ProcessSystemResourceValidation(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  int *pointerToInteger2;
  long long *SystemResourceOffsetPointer;
  byte *pisResourceAvailable;
  void* SystemThreadContext;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  float InterpolationParam2;
  uint8_t SystemOperationStatus5;
  char CharacterVariable16;
  long long resourceDataIndex7;
  float *pMagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  void* resourceAllocationContext1;
  uint32_t resourceAllocationContext2;
  long long ResourceDataOffset3;
  long long *SystemResourceOffsetPointer4;
  long long ResourceDataOffset5;
  uint resourceAllocationContext6;
  int systemCounter7;
  uint resourceAllocationContext8;
  int systemCounter9;
  ulong long resourceAddress0;
  char *pSystemOperationStatusFlag1;
  uint *presourceAddress2;
  int systemIndex3;
  long long systemDataIndexPtr;
  int systemIndex4;
  int systemIndex5;
  uint32_t *presourceAddress6;
  uint *presourceAddress7;
  ulong long resourceAddress8;
  ulong long resourceAddress9;
  bool in_ZF;
  bool isMemoryReady0;
  
  resourceDataIndex7 = SystemDataMemoryContext;
  ResourceDataOffset3 = SystemResourceManager;
  if (in_ZF) {
    ResourceDataOffset3 = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  LOCK();
  pointerToInteger2 = (int *)(resourceDataIndex7 + 0xed8);
  systemIndex3 = *pointerToInteger2;
  *pointerToInteger2 = *pointerToInteger2 + *(int *)(ResourceDataOffset3 + 0x200);
  UNLOCK();
  resourceDataIndex7 = *(long long *)(SystemResourceManager + 600);
  SystemOperationStatus5 = *(uint8_t *)(systemDataIndexPtr + 0x24);
  resourceAllocationContext2 = *(uint32_t *)(systemDataIndexPtr + 0x20);
  charStatus6 = *(char *)(systemDataIndexPtr + 0xd);
  *(uint32_t *)(resourceDataIndex7 + 0x48) = *(uint32_t *)(resourceDataIndex7 + 0x2c);
  *(uint32_t *)(resourceDataIndex7 + 0x50) = *(uint32_t *)(resourceDataIndex7 + 0x4c);
  *(int *)(resourceDataIndex7 + 0x4c) = systemIndex3;
  *(uint8_t *)(resourceDataIndex7 + 0x44) = SystemOperationStatus5;
  *(uint32_t *)(resourceDataIndex7 + 0x2c) = resourceAllocationContext2;
  if (charStatus6 != -1) {
    resourceAllocationContext8 = (int)*(char *)(systemDataIndexPtr + 0xd) + *(int *)(systemDataIndexPtr + 0x18);
    pMagnitudeSquared = (float *)**(long long **)(SystemResourceManager + 600);
    resourceAllocationContext6 = resourceAllocationContext8 >> QUADRANT_SHIFT_BITS;
    resourceDataIndex7 = *(long long *)
              ((long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc30 +
              (ulong long)resourceAllocationContext6 * 8);
    ResourceDataOffset3 = (ulong long)(resourceAllocationContext8 + resourceAllocationContext6 * -0x2000) * 0x40;
    resourceAllocationContext1 = ((void* *)(resourceDataIndex7 + ResourceDataOffset3))[1];
    *(void* *)pMagnitudeSquared = *(void* *)(resourceDataIndex7 + ResourceDataOffset3);
    *(void* *)(pMagnitudeSquared + 2) = resourceAllocationContext1;
    SystemThreadContext = (void* *)(resourceDataIndex7 + 0x10 + ResourceDataOffset3);
    resourceAllocationContext1 = SystemThreadContext[1];
    *(void* *)(pMagnitudeSquared + 4) = *SystemThreadContext;
    *(void* *)(pMagnitudeSquared + 6) = resourceAllocationContext1;
    SystemThreadContext = (void* *)(resourceDataIndex7 + 0x20 + ResourceDataOffset3);
    resourceAllocationContext1 = SystemThreadContext[1];
    *(void* *)(pMagnitudeSquared + 8) = *SystemThreadContext;
    *(void* *)(pMagnitudeSquared + 10) = resourceAllocationContext1;
    SystemThreadContext = (void* *)(resourceDataIndex7 + 0x30 + ResourceDataOffset3);
    resourceAllocationContext1 = SystemThreadContext[1];
    *(void* *)(pMagnitudeSquared + 0xc) = *SystemThreadContext;
    *(void* *)(pMagnitudeSquared + 0xe) = resourceAllocationContext1;
    resourceDataIndex7 = *(long long *)(systemDataIndexPtr + 0x10);
    ResultValue1 = pMagnitudeSquared[8];
    ResultValue2 = pMagnitudeSquared[9];
    floatValue21 = pMagnitudeSquared[10];
    floatValue22 = pMagnitudeSquared[0xb];
    floatValue23 = *pMagnitudeSquared;
    floatValue24 = pMagnitudeSquared[1];
    floatValue25 = pMagnitudeSquared[2];
    floatValue26 = pMagnitudeSquared[3];
    floatValue27 = pMagnitudeSquared[4];
    floatValue28 = pMagnitudeSquared[5];
    floatValue29 = pMagnitudeSquared[6];
    floatValue30 = pMagnitudeSquared[7];
    floatValue6 = *(float *)(resourceDataIndex7 + 0x374);
    floatValue7 = *(float *)(resourceDataIndex7 + 0x370);
    floatValue8 = *(float *)(resourceDataIndex7 + 0x378);
    ScaleValue = *(float *)(resourceDataIndex7 + 900);
    ScalingFactor = *(float *)(resourceDataIndex7 + 0x394);
    OffsetValue = *(float *)(resourceDataIndex7 + 0x380);
    RatioValue = *(float *)(resourceDataIndex7 + 0x388);
    InterpolationParam1 = *(float *)(resourceDataIndex7 + 0x390);
    InterpolationParam2 = *(float *)(resourceDataIndex7 + 0x398);
    *pMagnitudeSquared = floatValue6 * floatValue27 + floatValue7 * floatValue23 + floatValue8 * ResultValue1;
    pMagnitudeSquared[1] = floatValue6 * floatValue28 + floatValue7 * floatValue24 + floatValue8 * ResultValue2;
    pMagnitudeSquared[2] = floatValue6 * floatValue29 + floatValue7 * floatValue25 + floatValue8 * floatValue21;
    pMagnitudeSquared[3] = floatValue6 * floatValue30 + floatValue7 * floatValue26 + floatValue8 * floatValue22;
    pMagnitudeSquared[4] = ScaleValue * floatValue27 + OffsetValue * floatValue23 + RatioValue * ResultValue1;
    pMagnitudeSquared[5] = ScaleValue * floatValue28 + OffsetValue * floatValue24 + RatioValue * ResultValue2;
    pMagnitudeSquared[6] = ScaleValue * floatValue29 + OffsetValue * floatValue25 + RatioValue * floatValue21;
    pMagnitudeSquared[7] = ScaleValue * floatValue30 + OffsetValue * floatValue26 + RatioValue * floatValue22;
    pMagnitudeSquared[8] = ScalingFactor * floatValue27 + InterpolationParam1 * floatValue23 + InterpolationParam2 * ResultValue1;
    pMagnitudeSquared[9] = ScalingFactor * floatValue28 + InterpolationParam1 * floatValue24 + InterpolationParam2 * ResultValue2;
    pMagnitudeSquared[10] = ScalingFactor * floatValue29 + InterpolationParam1 * floatValue25 + InterpolationParam2 * floatValue21;
    pMagnitudeSquared[0xb] = ScalingFactor * floatValue30 + InterpolationParam1 * floatValue26 + InterpolationParam2 * floatValue22;
  }
  resourceDataIndex7 = *(long long *)(SystemResourceManager + 600);
  if (*(int *)(resourceDataIndex7 + 0x28) != *(int *)(SystemGlobalStatusFlags + 0x224)) {
    systemIndex3 = *(int *)(resourceDataIndex7 + 0x1c) + *(int *)(resourceDataIndex7 + 0x18);
    *(int *)(resourceDataIndex7 + 0x28) = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (0 < systemIndex3) {
      ResourceDataOffset3 = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
      resourceAllocationContext2 = AllocateSystemResourceContext(ResourceDataOffset3,systemIndex3);
      *(uint32_t *)(resourceDataIndex7 + 0x30) = resourceAllocationContext2;
      ProcessSystemResourceContext(ResourceDataOffset3,resourceAllocationContext2);
      if (*(long long *)(resourceDataIndex7 + 0x10) == 0) {
        if (*(int *)(resourceDataIndex7 + 0x18) != 0) {
          *(uint32_t *)(resourceDataIndex7 + 0x2c) = *(uint32_t *)(resourceDataIndex7 + 0x30);
          return;
        }
      }
      else {
        charStatus6 = *(char *)(resourceDataIndex7 + 0x44);
        resourceAddress0 = (ulong long)charStatus6;
        PrimaryResourcePointer = (long long *)(resourceDataIndex7 + 0x38);
        systemIndex3 = (int)charStatus6;
        if (*(int *)(resourceDataIndex7 + 0x40) == (int)charStatus6) {
          SystemResourceOffsetPointer4 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(resourceDataIndex7 + 0x40) = systemIndex3;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus6 == '\0') {
            SystemResourceOffsetPointer4 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            SystemResourceOffsetPointer4 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus6 * 4);
            *PrimaryResourcePointer = (long long)SystemResourceOffsetPointer4;
          }
        }
        if (SystemResourceOffsetPointer4 != (long long *)0x0) {
          systemIndex4 = 0;
          resourceAllocationContext6 = (uint)charStatus6;
          systemIndex5 = systemIndex4;
          if ((0 < systemIndex3) && (0xf < resourceAllocationContext6)) {
            systemCounter9 = *(int *)(resourceDataIndex7 + 0x2c);
            SystemResourceOffsetPointer = (long long *)((long long)SystemResourceOffsetPointer4 + (long long)(charStatus6 + -1) * 4);
            if ((((long long *)(resourceDataIndex7 + 0x2c) < SystemResourceOffsetPointer4) || (SystemResourceOffsetPointer < (long long *)(resourceDataIndex7 + 0x2c)))
               && ((PrimaryResourcePointer < SystemResourceOffsetPointer4 || (systemIndex5 = 0, SystemResourceOffsetPointer < PrimaryResourcePointer)))) {
              resourceAllocationContext8 = resourceAllocationContext6 & 0x8000000f;
              if ((int)resourceAllocationContext8 < 0) {
                resourceAllocationContext8 = (resourceAllocationContext8 - 1 | 0xfffffff0) + 1;
              }
              SystemResourceOffsetPointer4 = SystemResourceOffsetPointer4 + 4;
              systemCounter7 = 8;
              do {
                *(int *)(SystemResourceOffsetPointer4 + -4) = systemIndex4 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -0x1c) = systemIndex4 + 1 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + -3) = systemIndex4 + 2 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -0x14) = systemIndex4 + 3 + systemCounter9;
                systemIndex4 = systemIndex4 + 0x10;
                *(int *)(SystemResourceOffsetPointer4 + -2) = systemCounter7 + -4 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -0xc) = systemCounter7 + -3 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + -1) = systemCounter7 + -2 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + -4) = systemCounter7 + -1 + systemCounter9;
                *(int *)SystemResourceOffsetPointer4 = systemCounter7 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 4) = systemCounter7 + 1 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + 1) = systemCounter7 + 2 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 0xc) = systemCounter7 + 3 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + 2) = systemCounter7 + 4 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 0x14) = systemCounter7 + 5 + systemCounter9;
                *(int *)(SystemResourceOffsetPointer4 + 3) = systemCounter7 + 6 + systemCounter9;
                *(int *)((long long)SystemResourceOffsetPointer4 + 0x1c) = systemCounter7 + 7 + systemCounter9;
                SystemResourceOffsetPointer4 = SystemResourceOffsetPointer4 + 8;
                systemCounter7 = systemCounter7 + 0x10;
                systemIndex5 = systemIndex4;
              } while (systemIndex4 < (int)(resourceAllocationContext6 - resourceAllocationContext8));
            }
          }
          for (ResourceDataOffset3 = (long long)systemIndex5; ResourceDataOffset3 < (long long)resourceAddress0; ResourceDataOffset3 = ResourceDataOffset3 + 1) {
            systemIndex4 = *(int *)(resourceDataIndex7 + 0x2c) + systemIndex5;
            systemIndex5 = systemIndex5 + 1;
            *(int *)(*PrimaryResourcePointer + ResourceDataOffset3 * 4) = systemIndex4;
          }
          systemIndex5 = *(int *)(resourceDataIndex7 + 0x18);
          systemIndex4 = 0;
          if (0 < (long long)systemIndex5) {
            ResourceDataOffset3 = 0;
            do {
              systemCounter9 = *(int *)(resourceDataIndex7 + 0x30) + systemIndex4;
              systemIndex4 = systemIndex4 + 1;
              pisResourceAvailable = (byte *)(*(long long *)(resourceDataIndex7 + 0x10) + ResourceDataOffset3);
              ResourceDataOffset3 = ResourceDataOffset3 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisResourceAvailable * 4) = systemCounter9;
            } while (ResourceDataOffset3 < systemIndex5);
          }
        }
        presourceAddress2 = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 +
                          SystemDataMemoryContext + 0x9d0);
        if (systemIndex3 == 0) {
          resourceAllocationContext6 = (int)charStatus6 - 1;
        }
        else {
          LOCK();
          resourceAllocationContext6 = *presourceAddress2;
          *presourceAddress2 = *presourceAddress2 + (int)charStatus6;
          UNLOCK();
          resourceAddress8 = (ulong long)(resourceAllocationContext6 >> 0xb);
          resourceAddress9 = (ulong long)(charStatus6 + -1 + resourceAllocationContext6 >> 0xb);
          if (resourceAddress8 <= resourceAddress9) {
            pSystemOperationStatusFlag1 = (char *)((long long)presourceAddress2 + resourceAddress8 + 0x108);
            ResourceDataOffset3 = (resourceAddress9 - resourceAddress8) + 1;
            presourceAddress7 = presourceAddress2 + resourceAddress8 * 2 + 2;
            do {
              systemIndex5 = (int)resourceAddress8;
              if (*(long long *)presourceAddress7 == 0) {
                ResourceDataOffset5 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isMemoryReady0 = *(long long *)(presourceAddress2 + (long long)systemIndex5 * 2 + 2) == 0;
                if (isMemoryReady0) {
                  *(long long *)(presourceAddress2 + (long long)systemIndex5 * 2 + 2) = ResourceDataOffset5;
                }
                UNLOCK();
                if (isMemoryReady0) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex5 + 0x108 + (long long)presourceAddress2) = 0;
                  UNLOCK();
                }
                else {
                  if (ResourceDataOffset5 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*pSystemOperationStatusFlag1 != '\0');
                }
              }
              else {
                do {
                } while (*pSystemOperationStatusFlag1 != '\0');
              }
              resourceAddress8 = (ulong long)(systemIndex5 + 1);
              presourceAddress7 = presourceAddress7 + 2;
              pSystemOperationStatusFlag1 = pSystemOperationStatusFlag1 + 1;
              ResourceDataOffset3 = ResourceDataOffset3 + -1;
            } while (ResourceDataOffset3 != 0);
          }
        }
        presourceAddress6 = *(uint32_t **)(resourceDataIndex7 + 0x38);
        resourceAllocationContext8 = resourceAllocationContext6 >> 0xb;
        *(uint *)(resourceDataIndex7 + 0x2c) = resourceAllocationContext6;
        if (resourceAllocationContext8 == (int)charStatus6 + resourceAllocationContext6 >> 0xb) {
            memcpy(*(long long *)(presourceAddress2 + (ulong long)resourceAllocationContext8 * 2 + 2) +
                 (ulong long)(resourceAllocationContext6 + resourceAllocationContext8 * -0x800) * 4,presourceAddress6,(resourceAddress0 & MAX_UNSIGNED_32_BIT) << 2);
        }
        if (systemIndex3 != 0) {
          resourceAddress0 = resourceAddress0 & MAX_UNSIGNED_32_BIT;
          do {
            resourceAllocationContext2 = *presourceAddress6;
            presourceAddress6 = presourceAddress6 + 1;
            *(uint32_t *)
             (*(long long *)(presourceAddress2 + (ulong long)(resourceAllocationContext6 >> 0xb) * 2 + 2) +
             (ulong long)(resourceAllocationContext6 + (resourceAllocationContext6 >> 0xb) * -0x800) * 4) = resourceAllocationContext2;
            resourceAddress0 = resourceAddress0 - 1;
            resourceAllocationContext6 = resourceAllocationContext6 + 1;
          } while (resourceAddress0 != 0);
        }
      }
    }
  }
  return;
}





/**
 * @brief 初始化系统资源池
 * 
 * 该函数负责初始化系统资源池，设置资源池的参数和状态。
 * 用于系统资源的分配和管理工作。
 * 
 * @return 无返回值
 * 
 * 原始函数名：FUN_1800792ea
 */
void InitializeSystemResourcePool(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  void* *presourceAddress;
  float BaseValue;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  char CharacterVariable14;
  float *pInterpolationParam3;
  long long resourceDataIndex6;
  float InterpolationParam5;
  float MagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  float floatValue28;
  void* resourceCreationFlags9;
  uint32_t resourceAllocationContext0;
  long long ResourceDataOffset1;
  long long *SystemResourceOffsetPointer2;
  uint resourceAllocationContext3;
  int systemCounter4;
  uint resourceAllocationContext5;
  int systemCounter6;
  long long memoryBlockAddress;
  ulong long resourceAllocationContext7;
  char *pcharFlag8;
  uint *SystemHashNodeData9;
  int systemIndex0;
  long long systemDataIndexPtr;
  int systemIndex1;
  int systemIndex2;
  long long SystemBufferAddress3;
  uint32_t *presourceAddress4;
  uint *presourceAddress5;
  ulong long resourceAddress6;
  ulong long resourceAddress7;
  bool isResourceAvailable8;
  uint32_t unaff_XMM7_Da;
  uint32_t unaff_XMM7_Db;
  void* SystemDataPointer4;
  void* InputParameter58;
  
  resourceAllocationContext5 = (int)*(char *)(systemDataIndexPtr + 0xd) + *(int *)(systemDataIndexPtr + 0x18);
  pscaleResult1 = (float *)**(long long **)(memoryBlockAddress + 600);
  SystemBufferAddress3 = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
  resourceAllocationContext3 = resourceAllocationContext5 >> QUADRANT_SHIFT_BITS;
  resourceDataIndex6 = *(long long *)(SystemBufferAddress3 + 8 + (ulong long)resourceAllocationContext3 * 8);
  ResourceDataOffset1 = (ulong long)(resourceAllocationContext5 + resourceAllocationContext3 * -0x2000) * 0x40;
  resourceCreationFlags9 = ((void* *)(resourceDataIndex6 + ResourceDataOffset1))[1];
  *(void* *)pscaleResult1 = *(void* *)(resourceDataIndex6 + ResourceDataOffset1);
  *(void* *)(pInterpolationParam3 + 2) = resourceCreationFlags9;
  presourceAddress = (void* *)(resourceDataIndex6 + 0x10 + ResourceDataOffset1);
  resourceCreationFlags9 = presourceAddress[1];
  *(void* *)(pInterpolationParam3 + 4) = *presourceAddress;
  *(void* *)(pInterpolationParam3 + 6) = resourceCreationFlags9;
  presourceAddress = (void* *)(resourceDataIndex6 + 0x20 + ResourceDataOffset1);
  resourceCreationFlags9 = presourceAddress[1];
  *(void* *)(pInterpolationParam3 + 8) = *presourceAddress;
  *(void* *)(pInterpolationParam3 + 10) = resourceCreationFlags9;
  presourceAddress = (void* *)(resourceDataIndex6 + 0x30 + ResourceDataOffset1);
  resourceCreationFlags9 = presourceAddress[1];
  *(void* *)(pInterpolationParam3 + 0xc) = *presourceAddress;
  *(void* *)(pInterpolationParam3 + 0xe) = resourceCreationFlags9;
  resourceDataIndex6 = *(long long *)(systemDataIndexPtr + 0x10);
  InterpolationParam5 = pInterpolationParam3[8];
  MagnitudeSquared = pInterpolationParam3[9];
  ResultValue1 = pInterpolationParam3[10];
  ResultValue2 = pInterpolationParam3[0xb];
  floatValue21 = *pInterpolationParam3;
  floatValue22 = pInterpolationParam3[1];
  floatValue23 = pInterpolationParam3[2];
  floatValue24 = pInterpolationParam3[3];
  floatValue25 = pInterpolationParam3[4];
  floatValue26 = pInterpolationParam3[5];
  floatValue27 = pInterpolationParam3[6];
  floatValue28 = pInterpolationParam3[7];
  BaseValue = *(float *)(resourceDataIndex6 + 0x374);
  floatValue6 = *(float *)(resourceDataIndex6 + 0x370);
  floatValue7 = *(float *)(resourceDataIndex6 + 0x378);
  floatValue8 = *(float *)(resourceDataIndex6 + 900);
  ScaleValue = *(float *)(resourceDataIndex6 + 0x394);
  ScalingFactor = *(float *)(resourceDataIndex6 + 0x380);
  OffsetValue = *(float *)(resourceDataIndex6 + 0x388);
  RatioValue = *(float *)(resourceDataIndex6 + 0x390);
  InterpolationParam1 = *(float *)(resourceDataIndex6 + 0x398);
  *pscaleResult1 = BaseValue * floatValue25 + floatValue6 * floatValue21 + floatValue7 * InterpolationParam5;
  pInterpolationParam3[1] = BaseValue * floatValue26 + floatValue6 * floatValue22 + floatValue7 * MagnitudeSquared;
  pInterpolationParam3[2] = BaseValue * floatValue27 + floatValue6 * floatValue23 + floatValue7 * ResultValue1;
  pInterpolationParam3[3] = BaseValue * floatValue28 + floatValue6 * floatValue24 + floatValue7 * ResultValue2;
  pInterpolationParam3[4] = floatValue8 * floatValue25 + ScalingFactor * floatValue21 + OffsetValue * InterpolationParam5;
  pInterpolationParam3[5] = floatValue8 * floatValue26 + ScalingFactor * floatValue22 + OffsetValue * MagnitudeSquared;
  pInterpolationParam3[6] = floatValue8 * floatValue27 + ScalingFactor * floatValue23 + OffsetValue * ResultValue1;
  pInterpolationParam3[7] = floatValue8 * floatValue28 + ScalingFactor * floatValue24 + OffsetValue * ResultValue2;
  pInterpolationParam3[8] = ScaleValue * floatValue25 + RatioValue * floatValue21 + InterpolationParam1 * InterpolationParam5;
  pInterpolationParam3[9] = ScaleValue * floatValue26 + RatioValue * floatValue22 + InterpolationParam1 * MagnitudeSquared;
  pInterpolationParam3[10] = ScaleValue * floatValue27 + RatioValue * floatValue23 + InterpolationParam1 * ResultValue1;
  pInterpolationParam3[0xb] = ScaleValue * floatValue28 + RatioValue * floatValue24 + InterpolationParam1 * ResultValue2;
  resourceDataIndex6 = *(long long *)(memoryBlockAddress + 600);
  if (*(int *)(resourceDataIndex6 + 0x28) != *(int *)(SystemGlobalStatusFlags + 0x224)) {
    systemIndex0 = *(int *)(resourceDataIndex6 + 0x1c) + *(int *)(resourceDataIndex6 + 0x18);
    *(int *)(resourceDataIndex6 + 0x28) = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (0 < systemIndex0) {
      SystemDataPointer4 = InputParameter58;
      ResourceDataOffset1 = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
      resourceAllocationContext0 = AcquireResourceHandle(ResourceDataOffset1,systemIndex0,SystemBufferAddress3,pInterpolationParam3,ConcatenatedValue44(unaff_XMM7_Db,unaff_XMM7_Da));
      *(uint32_t *)(resourceDataIndex6 + 0x30) = resourceAllocationContext0;
      ReleaseResourceHandle(ResourceDataOffset1,resourceAllocationContext0);
      if (*(long long *)(resourceDataIndex6 + 0x10) == 0) {
        if (*(int *)(resourceDataIndex6 + 0x18) != 0) {
          *(uint32_t *)(resourceDataIndex6 + 0x2c) = *(uint32_t *)(resourceDataIndex6 + 0x30);
          return;
        }
      }
      else {
        charStatus4 = *(char *)(resourceDataIndex6 + 0x44);
        resourceAllocationContext7 = (ulong long)charStatus4;
        PrimaryResourcePointer = (long long *)(resourceDataIndex6 + 0x38);
        systemIndex0 = (int)charStatus4;
        if (*(int *)(resourceDataIndex6 + 0x40) == (int)charStatus4) {
          SystemResourceOffsetPointer2 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(resourceDataIndex6 + 0x40) = systemIndex0;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus4 == '\0') {
            SystemResourceOffsetPointer2 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            SystemResourceOffsetPointer2 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus4 * 4);
            *PrimaryResourcePointer = (long long)SystemResourceOffsetPointer2;
          }
        }
        if (SystemResourceOffsetPointer2 != (long long *)0x0) {
          systemIndex1 = 0;
          resourceAllocationContext3 = (uint)charStatus4;
          systemIndex2 = systemIndex1;
          if ((0 < systemIndex0) && (0xf < resourceAllocationContext3)) {
            systemCounter6 = *(int *)(resourceDataIndex6 + 0x2c);
            resourcePoolPointer = (long long *)((long long)SystemResourceOffsetPointer2 + (long long)(charStatus4 + -1) * 4);
            if ((((long long *)(resourceDataIndex6 + 0x2c) < SystemResourceOffsetPointer2) || (resourcePoolPointer < (long long *)(resourceDataIndex6 + 0x2c)))
               && ((PrimaryResourcePointer < SystemResourceOffsetPointer2 || (systemIndex2 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              resourceAllocationContext5 = resourceAllocationContext3 & 0x8000000f;
              if ((int)resourceAllocationContext5 < 0) {
                resourceAllocationContext5 = (resourceAllocationContext5 - 1 | 0xfffffff0) + 1;
              }
              SystemResourceOffsetPointer2 = SystemResourceOffsetPointer2 + 4;
              systemCounter4 = 8;
              do {
                *(int *)(SystemResourceOffsetPointer2 + -4) = systemIndex1 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + -0x1c) = systemIndex1 + 1 + systemCounter6;
                *(int *)(SystemResourceOffsetPointer2 + -3) = systemIndex1 + 2 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + -0x14) = systemIndex1 + 3 + systemCounter6;
                systemIndex1 = systemIndex1 + 0x10;
                *(int *)(SystemResourceOffsetPointer2 + -2) = systemCounter4 + -4 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + -0xc) = systemCounter4 + -3 + systemCounter6;
                *(int *)(SystemResourceOffsetPointer2 + -1) = systemCounter4 + -2 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + -4) = systemCounter4 + -1 + systemCounter6;
                *(int *)SystemResourceOffsetPointer2 = systemCounter4 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + 4) = systemCounter4 + 1 + systemCounter6;
                *(int *)(SystemResourceOffsetPointer2 + 1) = systemCounter4 + 2 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + 0xc) = systemCounter4 + 3 + systemCounter6;
                *(int *)(SystemResourceOffsetPointer2 + 2) = systemCounter4 + 4 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + 0x14) = systemCounter4 + 5 + systemCounter6;
                *(int *)(SystemResourceOffsetPointer2 + 3) = systemCounter4 + 6 + systemCounter6;
                *(int *)((long long)SystemResourceOffsetPointer2 + 0x1c) = systemCounter4 + 7 + systemCounter6;
                SystemResourceOffsetPointer2 = SystemResourceOffsetPointer2 + 8;
                systemCounter4 = systemCounter4 + 0x10;
                systemIndex2 = systemIndex1;
              } while (systemIndex1 < (int)(resourceAllocationContext3 - resourceAllocationContext5));
            }
          }
          for (ResourceDataOffset1 = (long long)systemIndex2; ResourceDataOffset1 < (long long)resourceAllocationContext7; ResourceDataOffset1 = ResourceDataOffset1 + 1) {
            systemIndex1 = *(int *)(resourceDataIndex6 + 0x2c) + systemIndex2;
            systemIndex2 = systemIndex2 + 1;
            *(int *)(*PrimaryResourcePointer + ResourceDataOffset1 * 4) = systemIndex1;
          }
          systemIndex2 = *(int *)(resourceDataIndex6 + 0x18);
          systemIndex1 = 0;
          if (0 < (long long)systemIndex2) {
            ResourceDataOffset1 = 0;
            do {
              systemCounter6 = *(int *)(resourceDataIndex6 + 0x30) + systemIndex1;
              systemIndex1 = systemIndex1 + 1;
              pisOperationComplete = (byte *)(*(long long *)(resourceDataIndex6 + 0x10) + ResourceDataOffset1);
              ResourceDataOffset1 = ResourceDataOffset1 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemCounter6;
            } while (ResourceDataOffset1 < systemIndex2);
          }
        }
        SystemHashNodeData9 = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 +
                          SystemDataMemoryContext + 0x9d0);
        if (systemIndex0 == 0) {
          resourceAllocationContext3 = (int)charStatus4 - 1;
        }
        else {
          LOCK();
          resourceAllocationContext3 = *SystemHashNodeData9;
          *SystemHashNodeData9 = *SystemHashNodeData9 + (int)charStatus4;
          UNLOCK();
          resourceAddress6 = (ulong long)(resourceAllocationContext3 >> 0xb);
          resourceAddress7 = (ulong long)(charStatus4 + -1 + resourceAllocationContext3 >> 0xb);
          if (resourceAddress6 <= resourceAddress7) {
            pcharFlag8 = (char *)((long long)SystemHashNodeData9 + resourceAddress6 + 0x108);
            ResourceDataOffset1 = (resourceAddress7 - resourceAddress6) + 1;
            presourceAddress5 = SystemHashNodeData9 + resourceAddress6 * 2 + 2;
            do {
              systemIndex2 = (int)resourceAddress6;
              if (*(long long *)presourceAddress5 == 0) {
                SystemBufferAddress3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isResourceAvailable8 = *(long long *)(SystemHashNodeData9 + (long long)systemIndex2 * 2 + 2) == 0;
                if (isResourceAvailable8) {
                  *(long long *)(SystemHashNodeData9 + (long long)systemIndex2 * 2 + 2) = SystemBufferAddress3;
                }
                UNLOCK();
                if (isResourceAvailable8) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex2 + 0x108 + (long long)SystemHashNodeData9) = 0;
                  UNLOCK();
                }
                else {
                  if (SystemBufferAddress3 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*pcharFlag8 != '\0');
                }
              }
              else {
                do {
                } while (*pcharFlag8 != '\0');
              }
              resourceAddress6 = (ulong long)(systemIndex2 + 1);
              presourceAddress5 = presourceAddress5 + 2;
              pcharFlag8 = pcharFlag8 + 1;
              ResourceDataOffset1 = ResourceDataOffset1 + -1;
            } while (ResourceDataOffset1 != 0);
          }
        }
        presourceAddress4 = *(uint32_t **)(resourceDataIndex6 + 0x38);
        resourceAllocationContext5 = resourceAllocationContext3 >> 0xb;
        *(uint *)(resourceDataIndex6 + 0x2c) = resourceAllocationContext3;
        if (resourceAllocationContext5 == (int)charStatus4 + resourceAllocationContext3 >> 0xb) {
            memcpy(*(long long *)(SystemHashNodeData9 + (ulong long)resourceAllocationContext5 * 2 + 2) +
                 (ulong long)(resourceAllocationContext3 + resourceAllocationContext5 * -0x800) * 4,presourceAddress4,(resourceAllocationContext7 & MAX_UNSIGNED_32_BIT) << 2);
        }
        if (systemIndex0 != 0) {
          resourceAllocationContext7 = resourceAllocationContext7 & MAX_UNSIGNED_32_BIT;
          do {
            resourceAllocationContext0 = *presourceAddress4;
            presourceAddress4 = presourceAddress4 + 1;
            *(uint32_t *)
             (*(long long *)(SystemHashNodeData9 + (ulong long)(resourceAllocationContext3 >> 0xb) * 2 + 2) +
             (ulong long)(resourceAllocationContext3 + (resourceAllocationContext3 >> 0xb) * -0x800) * 4) = resourceAllocationContext0;
            resourceAllocationContext7 = resourceAllocationContext7 - 1;
            resourceAllocationContext3 = resourceAllocationContext3 + 1;
          } while (resourceAllocationContext7 != 0);
        }
      }
    }
  }
  return;
}





/**
 * @brief 配置系统资源参数
 * 
 * 该函数负责配置系统资源的参数，包括资源分配、配置设置
 * 和参数验证。用于系统资源的配置工作。
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志指针
 * @return 无返回值
 * 
 * 原始函数名：FUN_180079309
 */
void ConfigureSystemResourceParameters(long long SystemResourceManager, uint ConfigurationDataPointer, void* AdditionalParameter, float *ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  void* *presourceAddress;
  float BaseValue;
  float floatValue6;
  float floatValue7;
  float floatValue8;
  float ScaleValue;
  float ScalingFactor;
  float OffsetValue;
  float RatioValue;
  float InterpolationParam1;
  char CharacterVariable14;
  long long resourceDataIndex5;
  float InterpolationParam4;
  float InterpolationParam5;
  float MagnitudeSquared;
  float ResultValue1;
  float ResultValue2;
  float floatValue21;
  float floatValue22;
  float floatValue23;
  float floatValue24;
  float floatValue25;
  float floatValue26;
  float floatValue27;
  void* resourceCreationFlags8;
  uint32_t resourceCreationFlags9;
  uint resourceAllocationContext0;
  long long ResourceDataOffset1;
  long long *SystemResourceOffsetPointer2;
  long long ResourceDataOffset3;
  int systemCounter4;
  int systemCounter5;
  long long memoryBlockAddress;
  ulong long resourceAllocationContext6;
  char *pcharFlag7;
  uint *SystemHashNodeData8;
  int systemCounter9;
  uint resourceAddress0;
  long long systemDataIndexPtr;
  int systemIndex1;
  int systemIndex2;
  uint32_t *presourceAddress3;
  uint *presourceAddress4;
  ulong long resourceAddress5;
  ulong long resourceAddress6;
  bool isResourceAvailable7;
  uint32_t unaff_XMM7_Da;
  uint32_t unaff_XMM7_Db;
  void* SystemDataPointer4;
  void* InputParameter58;
  
  SystemResourceManager = (long long)*(int *)(SystemResourceManager + 0x250) * 0x128 + SystemResourceManager;
  resourceDataIndex5 = *(long long *)(SystemResourceManager + 8 + (ulong long)(ConfigurationDataPointer >> QUADRANT_SHIFT_BITS) * 8);
  ResourceDataOffset1 = (ulong long)(ConfigurationDataPointer + (ConfigurationDataPointer >> QUADRANT_SHIFT_BITS) * -0x2000) * 0x40;
  resourceCreationFlags8 = ((void* *)(resourceDataIndex5 + ResourceDataOffset1))[1];
  *(void* *)ConfigurationFlag = *(void* *)(resourceDataIndex5 + ResourceDataOffset1);
  *(void* *)(ConfigurationFlag + 2) = resourceCreationFlags8;
  presourceAddress = (void* *)(resourceDataIndex5 + 0x10 + ResourceDataOffset1);
  resourceCreationFlags8 = presourceAddress[1];
  *(void* *)(ConfigurationFlag + 4) = *presourceAddress;
  *(void* *)(ConfigurationFlag + 6) = resourceCreationFlags8;
  presourceAddress = (void* *)(resourceDataIndex5 + 0x20 + ResourceDataOffset1);
  resourceCreationFlags8 = presourceAddress[1];
  *(void* *)(ConfigurationFlag + 8) = *presourceAddress;
  *(void* *)(ConfigurationFlag + 10) = resourceCreationFlags8;
  presourceAddress = (void* *)(resourceDataIndex5 + 0x30 + ResourceDataOffset1);
  resourceCreationFlags8 = presourceAddress[1];
  *(void* *)(ConfigurationFlag + 0xc) = *presourceAddress;
  *(void* *)(ConfigurationFlag + 0xe) = resourceCreationFlags8;
  resourceDataIndex5 = *(long long *)(systemDataIndexPtr + 0x10);
  InterpolationParam4 = ConfigurationFlag[8];
  InterpolationParam5 = ConfigurationFlag[9];
  MagnitudeSquared = ConfigurationFlag[10];
  ResultValue1 = ConfigurationFlag[0xb];
  ResultValue2 = *ConfigurationFlag;
  floatValue21 = ConfigurationFlag[1];
  floatValue22 = ConfigurationFlag[2];
  floatValue23 = ConfigurationFlag[3];
  floatValue24 = ConfigurationFlag[4];
  floatValue25 = ConfigurationFlag[5];
  floatValue26 = ConfigurationFlag[6];
  floatValue27 = ConfigurationFlag[7];
  BaseValue = *(float *)(resourceDataIndex5 + 0x374);
  floatValue6 = *(float *)(resourceDataIndex5 + 0x370);
  floatValue7 = *(float *)(resourceDataIndex5 + 0x378);
  floatValue8 = *(float *)(resourceDataIndex5 + 900);
  ScaleValue = *(float *)(resourceDataIndex5 + 0x394);
  ScalingFactor = *(float *)(resourceDataIndex5 + 0x380);
  OffsetValue = *(float *)(resourceDataIndex5 + 0x388);
  RatioValue = *(float *)(resourceDataIndex5 + 0x390);
  InterpolationParam1 = *(float *)(resourceDataIndex5 + 0x398);
  *ConfigurationFlag = BaseValue * floatValue24 + floatValue6 * ResultValue2 + floatValue7 * InterpolationParam4;
  ConfigurationFlag[1] = BaseValue * floatValue25 + floatValue6 * floatValue21 + floatValue7 * InterpolationParam5;
  ConfigurationFlag[2] = BaseValue * floatValue26 + floatValue6 * floatValue22 + floatValue7 * MagnitudeSquared;
  ConfigurationFlag[3] = BaseValue * floatValue27 + floatValue6 * floatValue23 + floatValue7 * ResultValue1;
  ConfigurationFlag[4] = floatValue8 * floatValue24 + ScalingFactor * ResultValue2 + OffsetValue * InterpolationParam4;
  ConfigurationFlag[5] = floatValue8 * floatValue25 + ScalingFactor * floatValue21 + OffsetValue * InterpolationParam5;
  ConfigurationFlag[6] = floatValue8 * floatValue26 + ScalingFactor * floatValue22 + OffsetValue * MagnitudeSquared;
  ConfigurationFlag[7] = floatValue8 * floatValue27 + ScalingFactor * floatValue23 + OffsetValue * ResultValue1;
  ConfigurationFlag[8] = ScaleValue * floatValue24 + RatioValue * ResultValue2 + InterpolationParam1 * InterpolationParam4;
  ConfigurationFlag[9] = ScaleValue * floatValue25 + RatioValue * floatValue21 + InterpolationParam1 * InterpolationParam5;
  ConfigurationFlag[10] = ScaleValue * floatValue26 + RatioValue * floatValue22 + InterpolationParam1 * MagnitudeSquared;
  ConfigurationFlag[0xb] = ScaleValue * floatValue27 + RatioValue * floatValue23 + InterpolationParam1 * ResultValue1;
  resourceDataIndex5 = *(long long *)(memoryBlockAddress + 600);
  if (*(int *)(resourceDataIndex5 + 0x28) != *(int *)(SystemGlobalStatusFlags + 0x224)) {
    systemCounter9 = *(int *)(resourceDataIndex5 + 0x1c) + *(int *)(resourceDataIndex5 + 0x18);
    *(int *)(resourceDataIndex5 + 0x28) = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (0 < systemCounter9) {
      SystemDataPointer4 = InputParameter58;
      ResourceDataOffset1 = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
      resourceCreationFlags9 = AcquireResourceHandle(ResourceDataOffset1,systemCounter9,SystemResourceManager,ConfigurationFlag,ConcatenatedValue44(unaff_XMM7_Db,unaff_XMM7_Da));
      *(uint32_t *)(resourceDataIndex5 + 0x30) = resourceCreationFlags9;
      ReleaseResourceHandle(ResourceDataOffset1,resourceCreationFlags9);
      if (*(long long *)(resourceDataIndex5 + 0x10) == 0) {
        if (*(int *)(resourceDataIndex5 + 0x18) != 0) {
          *(uint32_t *)(resourceDataIndex5 + 0x2c) = *(uint32_t *)(resourceDataIndex5 + 0x30);
          return;
        }
      }
      else {
        charStatus4 = *(char *)(resourceDataIndex5 + 0x44);
        resourceAllocationContext6 = (ulong long)charStatus4;
        PrimaryResourcePointer = (long long *)(resourceDataIndex5 + 0x38);
        systemCounter9 = (int)charStatus4;
        if (*(int *)(resourceDataIndex5 + 0x40) == (int)charStatus4) {
          SystemResourceOffsetPointer2 = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(resourceDataIndex5 + 0x40) = systemCounter9;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (charStatus4 == '\0') {
            SystemResourceOffsetPointer2 = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            SystemResourceOffsetPointer2 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)charStatus4 * 4);
            *PrimaryResourcePointer = (long long)SystemResourceOffsetPointer2;
          }
        }
        if (SystemResourceOffsetPointer2 != (long long *)0x0) {
          systemIndex1 = 0;
          resourceAddress0 = (uint)charStatus4;
          systemIndex2 = systemIndex1;
          if ((0 < systemCounter9) && (0xf < resourceAddress0)) {
            systemCounter5 = *(int *)(resourceDataIndex5 + 0x2c);
            resourcePoolPointer = (long long *)((long long)SystemResourceOffsetPointer2 + (long long)(charStatus4 + -1) * 4);
            if ((((long long *)(resourceDataIndex5 + 0x2c) < SystemResourceOffsetPointer2) || (resourcePoolPointer < (long long *)(resourceDataIndex5 + 0x2c)))
               && ((PrimaryResourcePointer < SystemResourceOffsetPointer2 || (systemIndex2 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              resourceAllocationContext0 = resourceAddress0 & 0x8000000f;
              if ((int)resourceAllocationContext0 < 0) {
                resourceAllocationContext0 = (resourceAllocationContext0 - 1 | 0xfffffff0) + 1;
              }
              SystemResourceOffsetPointer2 = SystemResourceOffsetPointer2 + 4;
              systemCounter4 = 8;
              do {
                *(int *)(SystemResourceOffsetPointer2 + -4) = systemIndex1 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + -0x1c) = systemIndex1 + 1 + systemCounter5;
                *(int *)(SystemResourceOffsetPointer2 + -3) = systemIndex1 + 2 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + -0x14) = systemIndex1 + 3 + systemCounter5;
                systemIndex1 = systemIndex1 + 0x10;
                *(int *)(SystemResourceOffsetPointer2 + -2) = systemCounter4 + -4 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + -0xc) = systemCounter4 + -3 + systemCounter5;
                *(int *)(SystemResourceOffsetPointer2 + -1) = systemCounter4 + -2 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + -4) = systemCounter4 + -1 + systemCounter5;
                *(int *)SystemResourceOffsetPointer2 = systemCounter4 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + 4) = systemCounter4 + 1 + systemCounter5;
                *(int *)(SystemResourceOffsetPointer2 + 1) = systemCounter4 + 2 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + 0xc) = systemCounter4 + 3 + systemCounter5;
                *(int *)(SystemResourceOffsetPointer2 + 2) = systemCounter4 + 4 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + 0x14) = systemCounter4 + 5 + systemCounter5;
                *(int *)(SystemResourceOffsetPointer2 + 3) = systemCounter4 + 6 + systemCounter5;
                *(int *)((long long)SystemResourceOffsetPointer2 + 0x1c) = systemCounter4 + 7 + systemCounter5;
                SystemResourceOffsetPointer2 = SystemResourceOffsetPointer2 + 8;
                systemCounter4 = systemCounter4 + 0x10;
                systemIndex2 = systemIndex1;
              } while (systemIndex1 < (int)(resourceAddress0 - resourceAllocationContext0));
            }
          }
          for (ResourceDataOffset1 = (long long)systemIndex2; ResourceDataOffset1 < (long long)resourceAllocationContext6; ResourceDataOffset1 = ResourceDataOffset1 + 1) {
            systemIndex1 = *(int *)(resourceDataIndex5 + 0x2c) + systemIndex2;
            systemIndex2 = systemIndex2 + 1;
            *(int *)(*PrimaryResourcePointer + ResourceDataOffset1 * 4) = systemIndex1;
          }
          systemIndex2 = *(int *)(resourceDataIndex5 + 0x18);
          systemIndex1 = 0;
          if (0 < (long long)systemIndex2) {
            ResourceDataOffset1 = 0;
            do {
              systemCounter5 = *(int *)(resourceDataIndex5 + 0x30) + systemIndex1;
              systemIndex1 = systemIndex1 + 1;
              pisOperationComplete = (byte *)(*(long long *)(resourceDataIndex5 + 0x10) + ResourceDataOffset1);
              ResourceDataOffset1 = ResourceDataOffset1 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = systemCounter5;
            } while (ResourceDataOffset1 < systemIndex2);
          }
        }
        SystemHashNodeData8 = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 +
                          SystemDataMemoryContext + 0x9d0);
        if (systemCounter9 == 0) {
          resourceAddress0 = (int)charStatus4 - 1;
        }
        else {
          LOCK();
          resourceAddress0 = *SystemHashNodeData8;
          *SystemHashNodeData8 = *SystemHashNodeData8 + (int)charStatus4;
          UNLOCK();
          resourceAddress5 = (ulong long)(resourceAddress0 >> 0xb);
          resourceAddress6 = (ulong long)(charStatus4 + -1 + resourceAddress0 >> 0xb);
          if (resourceAddress5 <= resourceAddress6) {
            pcharFlag7 = (char *)((long long)SystemHashNodeData8 + resourceAddress5 + 0x108);
            ResourceDataOffset1 = (resourceAddress6 - resourceAddress5) + 1;
            presourceAddress4 = SystemHashNodeData8 + resourceAddress5 * 2 + 2;
            do {
              systemIndex2 = (int)resourceAddress5;
              if (*(long long *)presourceAddress4 == 0) {
                ResourceDataOffset3 = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isResourceAvailable7 = *(long long *)(SystemHashNodeData8 + (long long)systemIndex2 * 2 + 2) == 0;
                if (isResourceAvailable7) {
                  *(long long *)(SystemHashNodeData8 + (long long)systemIndex2 * 2 + 2) = ResourceDataOffset3;
                }
                UNLOCK();
                if (isResourceAvailable7) {
                  LOCK();
                  *(uint8_t *)((long long)systemIndex2 + 0x108 + (long long)SystemHashNodeData8) = 0;
                  UNLOCK();
                }
                else {
                  if (ResourceDataOffset3 != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*pcharFlag7 != '\0');
                }
              }
              else {
                do {
                } while (*pcharFlag7 != '\0');
              }
              resourceAddress5 = (ulong long)(systemIndex2 + 1);
              presourceAddress4 = presourceAddress4 + 2;
              pcharFlag7 = pcharFlag7 + 1;
              ResourceDataOffset1 = ResourceDataOffset1 + -1;
            } while (ResourceDataOffset1 != 0);
          }
        }
        presourceAddress3 = *(uint32_t **)(resourceDataIndex5 + 0x38);
        resourceAllocationContext0 = resourceAddress0 >> 0xb;
        *(uint *)(resourceDataIndex5 + 0x2c) = resourceAddress0;
        if (resourceAllocationContext0 == (int)charStatus4 + resourceAddress0 >> 0xb) {
            memcpy(*(long long *)(SystemHashNodeData8 + (ulong long)resourceAllocationContext0 * 2 + 2) +
                 (ulong long)(resourceAddress0 + resourceAllocationContext0 * -0x800) * 4,presourceAddress3,(resourceAllocationContext6 & MAX_UNSIGNED_32_BIT) << 2);
        }
        if (systemCounter9 != 0) {
          resourceAllocationContext6 = resourceAllocationContext6 & MAX_UNSIGNED_32_BIT;
          do {
            resourceCreationFlags9 = *presourceAddress3;
            presourceAddress3 = presourceAddress3 + 1;
            *(uint32_t *)
             (*(long long *)(SystemHashNodeData8 + (ulong long)(resourceAddress0 >> 0xb) * 2 + 2) +
             (ulong long)(resourceAddress0 + (resourceAddress0 >> 0xb) * -0x800) * 4) = resourceCreationFlags9;
            resourceAllocationContext6 = resourceAllocationContext6 - 1;
            resourceAddress0 = resourceAddress0 + 1;
          } while (resourceAllocationContext6 != 0);
        }
      }
    }
  }
  return;
}





/**
 * @brief 重置系统资源计数器
 * 
 * 该函数负责重置系统资源计数器，清理资源统计信息。
 * 用于系统资源管理的重置工作。
 * 
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007940e
 */
void ResetSystemResourceCounter(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char SystemOperationStatusFlag;
  long long SystemTimeValue;
  uint32_t ResourceHash;
  uint SystemLoopCounter;
  long long *pSystemMemoryAddress;
  long long resourceCounter;
  int SystemOperationStatus0;
  int SystemOperationStatus1;
  long long memoryBlockAddress;
  long long resourceDataIndex2;
  ulong long SystemOperationStatus3;
  char *systemFunctionPointer4;
  uint *ThreadLocalStorageEntry;
  int SystemOperationStatusFlags;
  uint SystemOperationStatus7;
  int SystemOperationStatus8;
  int SystemContextPointer;
  uint32_t *SystemHashEntryPointer0;
  uint *SystemHashEntryPointer1;
  ulong long MemoryAllocationFlags;
  ulong long InitializationFlags;
  bool isSystemActive4;
  void* SystemDataPointer4;
  void* InputParameter58;
  
  localSystemPointer = *(long long *)(memoryBlockAddress + 600);
  if (*(int *)(localSystemPointer + 0x28) != *(int *)(SystemGlobalStatusFlags + 0x224)) {
    SystemOperationStatusFlags = *(int *)(localSystemPointer + 0x1c) + *(int *)(localSystemPointer + 0x18);
    *(int *)(localSystemPointer + 0x28) = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (0 < SystemOperationStatusFlags) {
      SystemDataPointer4 = InputParameter58;
      resourceDataIndex2 = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
      ResourceHash = AcquireResourceHandle(resourceDataIndex2,SystemOperationStatusFlags);
      *(uint32_t *)(localSystemPointer + 0x30) = ResourceHash;
      ReleaseResourceHandle(resourceDataIndex2,ResourceHash);
      if (*(long long *)(localSystemPointer + 0x10) == 0) {
        if (*(int *)(localSystemPointer + 0x18) != 0) {
          *(uint32_t *)(localSystemPointer + 0x2c) = *(uint32_t *)(localSystemPointer + 0x30);
          return;
        }
      }
      else {
        SystemOperationStatusFlag = *(char *)(localSystemPointer + 0x44);
        SystemOperationStatus3 = (ulong long)SystemOperationStatusFlag;
        PrimaryResourcePointer = (long long *)(localSystemPointer + 0x38);
        SystemOperationStatusFlags = (int)SystemOperationStatusFlag;
        if (*(int *)(localSystemPointer + 0x40) == (int)SystemOperationStatusFlag) {
          pSystemMemoryAddress = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(localSystemPointer + 0x40) = SystemOperationStatusFlags;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (SystemOperationStatusFlag == '\0') {
            pSystemMemoryAddress = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            pSystemMemoryAddress = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)SystemOperationStatusFlag * 4);
            *PrimaryResourcePointer = (long long)pSystemMemoryAddress;
          }
        }
        if (pSystemMemoryAddress != (long long *)0x0) {
          SystemOperationStatus8 = 0;
          SystemOperationStatus7 = (uint)SystemOperationStatusFlag;
          SystemContextPointer = SystemOperationStatus8;
          if ((0 < SystemOperationStatusFlags) && (0xf < SystemOperationStatus7)) {
            SystemOperationStatus1 = *(int *)(localSystemPointer + 0x2c);
            resourcePoolPointer = (long long *)((long long)pSystemMemoryAddress + (long long)(SystemOperationStatusFlag + -1) * 4);
            if ((((long long *)(localSystemPointer + 0x2c) < pSystemMemoryAddress) || (resourcePoolPointer < (long long *)(localSystemPointer + 0x2c))) &&
               ((PrimaryResourcePointer < pSystemMemoryAddress || (SystemContextPointer = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              ThreadContextFlag = SystemOperationStatus7 & 0x8000000f;
              if ((int)ThreadContextFlag < 0) {
                ThreadContextFlag = (ThreadContextFlag - 1 | 0xfffffff0) + 1;
              }
              pSystemMemoryAddress = pSystemMemoryAddress + 4;
              SystemOperationStatus0 = 8;
              do {
                *(int *)(pSystemMemoryAddress + -4) = SystemOperationStatus8 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + -0x1c) = SystemOperationStatus8 + 1 + SystemOperationStatus1;
                *(int *)(pSystemMemoryAddress + -3) = SystemOperationStatus8 + 2 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + -0x14) = SystemOperationStatus8 + 3 + SystemOperationStatus1;
                SystemOperationStatus8 = SystemOperationStatus8 + 0x10;
                *(int *)(pSystemMemoryAddress + -2) = SystemOperationStatus0 + -4 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + -0xc) = SystemOperationStatus0 + -3 + SystemOperationStatus1;
                *(int *)(pSystemMemoryAddress + -1) = SystemOperationStatus0 + -2 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + -4) = SystemOperationStatus0 + -1 + SystemOperationStatus1;
                *(int *)pSystemMemoryAddress = SystemOperationStatus0 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + 4) = SystemOperationStatus0 + 1 + SystemOperationStatus1;
                *(int *)(pSystemMemoryAddress + 1) = SystemOperationStatus0 + 2 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + 0xc) = SystemOperationStatus0 + 3 + SystemOperationStatus1;
                *(int *)(pSystemMemoryAddress + 2) = SystemOperationStatus0 + 4 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + 0x14) = SystemOperationStatus0 + 5 + SystemOperationStatus1;
                *(int *)(pSystemMemoryAddress + 3) = SystemOperationStatus0 + 6 + SystemOperationStatus1;
                *(int *)((long long)pSystemMemoryAddress + 0x1c) = SystemOperationStatus0 + 7 + SystemOperationStatus1;
                pSystemMemoryAddress = pSystemMemoryAddress + 8;
                SystemOperationStatus0 = SystemOperationStatus0 + 0x10;
                SystemContextPointer = SystemOperationStatus8;
              } while (SystemOperationStatus8 < (int)(SystemOperationStatus7 - ThreadContextFlag));
            }
          }
          for (resourceDataIndex2 = (long long)SystemContextPointer; resourceDataIndex2 < (long long)SystemOperationStatus3; resourceDataIndex2 = resourceDataIndex2 + 1) {
            SystemOperationStatus8 = *(int *)(localSystemPointer + 0x2c) + SystemContextPointer;
            SystemContextPointer = SystemContextPointer + 1;
            *(int *)(*PrimaryResourcePointer + resourceDataIndex2 * 4) = SystemOperationStatus8;
          }
          SystemContextPointer = *(int *)(localSystemPointer + 0x18);
          SystemOperationStatus8 = 0;
          if (0 < (long long)SystemContextPointer) {
            resourceDataIndex2 = 0;
            do {
              SystemOperationStatus1 = *(int *)(localSystemPointer + 0x30) + SystemOperationStatus8;
              SystemOperationStatus8 = SystemOperationStatus8 + 1;
              pisOperationComplete = (byte *)(*(long long *)(localSystemPointer + 0x10) + resourceDataIndex2);
              resourceDataIndex2 = resourceDataIndex2 + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = SystemOperationStatus1;
            } while (resourceDataIndex2 < SystemContextPointer);
          }
        }
        ThreadLocalStorageEntry = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 +
                          SystemDataMemoryContext + 0x9d0);
        if (SystemOperationStatusFlags == 0) {
          SystemOperationStatus7 = (int)SystemOperationStatusFlag - 1;
        }
        else {
          LOCK();
          SystemOperationStatus7 = *ThreadLocalStorageEntry;
          *ThreadLocalStorageEntry = *ThreadLocalStorageEntry + (int)SystemOperationStatusFlag;
          UNLOCK();
          MemoryAllocationFlags = (ulong long)(SystemOperationStatus7 >> 0xb);
          InitializationFlags = (ulong long)(SystemOperationStatusFlag + -1 + SystemOperationStatus7 >> 0xb);
          if (MemoryAllocationFlags <= InitializationFlags) {
            systemFunctionPointer4 = (char *)((long long)ThreadLocalStorageEntry + MemoryAllocationFlags + 0x108);
            resourceDataIndex2 = (InitializationFlags - MemoryAllocationFlags) + 1;
            SystemHashEntryPointer1 = ThreadLocalStorageEntry + MemoryAllocationFlags * 2 + 2;
            do {
              SystemContextPointer = (int)MemoryAllocationFlags;
              if (*(long long *)SystemHashEntryPointer1 == 0) {
                resourceCounter = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isSystemActive4 = *(long long *)(ThreadLocalStorageEntry + (long long)SystemContextPointer * 2 + 2) == 0;
                if (isSystemActive4) {
                  *(long long *)(ThreadLocalStorageEntry + (long long)SystemContextPointer * 2 + 2) = resourceCounter;
                }
                UNLOCK();
                if (isSystemActive4) {
                  LOCK();
                  *(uint8_t *)((long long)SystemContextPointer + 0x108 + (long long)ThreadLocalStorageEntry) = 0;
                  UNLOCK();
                }
                else {
                  if (resourceCounter != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*systemFunctionPointer4 != '\0');
                }
              }
              else {
                do {
                } while (*systemFunctionPointer4 != '\0');
              }
              MemoryAllocationFlags = (ulong long)(SystemContextPointer + 1);
              SystemHashEntryPointer1 = SystemHashEntryPointer1 + 2;
              systemFunctionPointer4 = systemFunctionPointer4 + 1;
              resourceDataIndex2 = resourceDataIndex2 + -1;
            } while (resourceDataIndex2 != 0);
          }
        }
        SystemHashEntryPointer0 = *(uint32_t **)(localSystemPointer + 0x38);
        ThreadContextFlag = SystemOperationStatus7 >> 0xb;
        *(uint *)(localSystemPointer + 0x2c) = SystemOperationStatus7;
        if (ThreadContextFlag == (int)SystemOperationStatusFlag + SystemOperationStatus7 >> 0xb) {
            memcpy(*(long long *)(ThreadLocalStorageEntry + (ulong long)ThreadContextFlag * 2 + 2) +
                 (ulong long)(SystemOperationStatus7 + ThreadContextFlag * -0x800) * 4,SystemHashEntryPointer0,(SystemOperationStatus3 & MAX_UNSIGNED_32_BIT) << 2);
        }
        if (SystemOperationStatusFlags != 0) {
          SystemOperationStatus3 = SystemOperationStatus3 & MAX_UNSIGNED_32_BIT;
          do {
            ResourceHash = *SystemHashEntryPointer0;
            SystemHashEntryPointer0 = SystemHashEntryPointer0 + 1;
            *(uint32_t *)
             (*(long long *)(ThreadLocalStorageEntry + (ulong long)(SystemOperationStatus7 >> 0xb) * 2 + 2) +
             (ulong long)(SystemOperationStatus7 + (SystemOperationStatus7 >> 0xb) * -0x800) * 4) = ResourceHash;
            SystemOperationStatus3 = SystemOperationStatus3 - 1;
            SystemOperationStatus7 = SystemOperationStatus7 + 1;
          } while (SystemOperationStatus3 != 0);
        }
      }
    }
  }
  return;
}




void* * GetSystemResourceConfigurationPointer(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  void* configurationResultPointer;
  
  configurationResultPointer = (void*)0xfffffffffffffffe;
  if (*(long long *)(SystemResourceManager + 0x1b8) != 0) {
    return (void* *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x10);
  }
  if (*(int *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8) +
              0x48) < SystemDataValue5) {
    CheckSystemDataAvailability(&SystemDataValue5);
    if (SystemDataValue5 == -1) {
      SystemDataValue6 = &SystemResourceTemplatePrimary;
      SystemDataValue7 = &SystemDataValue8;

// 函数: void InitializeSystemResourceAllocation(long long SystemResourceManager)
/**
 * @brief 系统资源锁定状态管理器函数
 * 
 * 该函数负责管理系统资源的锁定状态，确保资源访问的同步性。
 * 它会检查资源的状态标志，并在必要时等待资源解锁。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要管理的资源信息
 * @note 这是系统资源同步管理的重要组成部分，用于确保资源访问的安全性
 */
void ManageSystemResourceLockState(long long SystemResourceManager)

{
  long long resourceDataIndex;
  int systemResult;
  long long ResourceDataOffset;
  
  if (((*(byte *)(SystemResourceManager + 0xfd) & 0x20) != 0) && (*(long long *)(SystemResourceManager + 0x1e0) != 0)) {
    systemResult = 0;
    ResourceDataOffset = 0;
    do {
      while ((*(char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + ResourceDataOffset) == '\x02' ||
             (*(char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + ResourceDataOffset) == '\x01'))) {
        Sleep(0);
      }
      resourceDataIndex = (long long)systemResult;
      ResourceDataOffset = ResourceDataOffset + 0x18;
      systemResult = systemResult + 1;
      LOCK();
      *(uint8_t *)(*(long long *)(SystemResourceManager + 0x1e0) + resourceDataIndex * 0x18 + 0x15) = 0;
      UNLOCK();
    } while (systemResult < 0x10);
  }
  return;
}



/**
 * @brief 系统资源状态获取器函数
 * 
 * 该函数负责获取系统资源的当前状态，包括锁定状态和可用性。
 * 它会轮询资源状态，并在资源可用时返回状态信息。
 * 
 * @return 系统资源状态字节，包含资源的当前状态信息
 * @note 这是系统资源状态监控的重要组成部分，用于实时获取资源状态
 */
uint8_t GetSystemResourceState(void)

{
  uint8_t *SystemDataPointer;
  uint8_t resourceCreationFlags;
  long long ResourceDataOffset;
  long long memoryBlockAddress;
  int systemIndex;
  long long SystemTimeValue;
  
  systemIndex = 0;
  localSystemPointer = 0;
  do {
    while ((*(char *)(*(long long *)(memoryBlockAddress + 0x1e0) + 0x15 + localSystemPointer) == '\x02' ||
           (*(char *)(*(long long *)(memoryBlockAddress + 0x1e0) + 0x15 + localSystemPointer) == '\x01'))) {
      Sleep(0);
    }
    ResourceDataOffset = (long long)systemIndex;
    localSystemPointer = localSystemPointer + 0x18;
    systemIndex = systemIndex + 1;
    LOCK();
    SystemDataPointer = (uint8_t *)(*(long long *)(memoryBlockAddress + 0x1e0) + ResourceDataOffset * 0x18 + 0x15);
    resourceCreationFlags = *SystemDataPointer;
    *SystemDataPointer = 0;
    UNLOCK();
  } while (systemIndex < 0x10);
  return resourceCreationFlags;
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，用于占位或作为默认的空实现。
 * 在某些情况下，它可能被用作回调函数或默认处理函数。
 * 
 * @note 这是一个占位函数，不执行任何实际操作
 */
void SystemNoOperation(void)

{
  return;
}



/**
 * @brief 系统状态标志获取器函数
 * 
 * 该函数负责获取系统的状态标志，包括系统运行状态和错误状态。
 * 它会读取系统状态寄存器，并返回当前的状态信息。
 * 
 * @return 系统状态标志字节，包含系统的当前状态信息
 * @note 这是系统状态监控的重要组成部分，用于实时获取系统状态
 */
uint8_t GetSystemStatusFlag(void)

{
  uint8_t *SystemDataPointer;
  uint8_t resourceCreationFlags;
  long long ResourceDataOffset;
  long long memoryBlockAddress;
  int unaff_ESI;
  long long systemDataIndexPtr;
  
  do {
    Sleep(0);
    while ((*(char *)(*(long long *)(memoryBlockAddress + 0x1e0) + 0x15 + systemDataIndexPtr) != '\x02' &&
           (*(char *)(*(long long *)(memoryBlockAddress + 0x1e0) + 0x15 + systemDataIndexPtr) != '\x01'))) {
      ResourceDataOffset = (long long)unaff_ESI;
      systemDataIndexPtr = systemDataIndexPtr + 0x18;
      unaff_ESI = unaff_ESI + 1;
      LOCK();
      SystemDataPointer = (uint8_t *)(*(long long *)(memoryBlockAddress + 0x1e0) + ResourceDataOffset * 0x18 + 0x15);
      resourceCreationFlags = *SystemDataPointer;
      *SystemDataPointer = 0;
      UNLOCK();
      if (0xf < unaff_ESI) {
        return resourceCreationFlags;
      }
    }
  } while( true );
}



000180079699)

float * ProcessSystemFloatData(float *SystemResourceManager)

{
  float *primaryFloatPointer;
  byte isSystemActive;
  long long *SystemResourceOffsetPointer;
  float *pfloatValue4;
  char operationStatusFlag;
  float floatValue6;
  float *pfloatValue7;
  uint OperationCode;
  ulong long ThreadContextFlag;
  bool isByteValid0;
  float OffsetValue;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  uint32_t StackUnsignedValueAC;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  uint32_t StackUnsignedValue9C;
  float *SystemFloatPointer;
  uint32_t SystemConfigurationValue;
  long long SystemConfigurationData;
  void* UnsignedStackFlag80;
  void* SystemUnsignedFlag78;
  void* SystemProcessFlags70;
  void* EncryptionValue68;
  void* ThreadContextFlag;
  void* *memoryAllocationBuffer;
  float SystemFloatValue3;
  float fStack_4c;
  void* *pSystemEncryptionKey;
  void* SystemOperationCounter;
  void* SystemContextValue;
  uint8_t SystemResourceStatusFlagCompact [8];
  float *pfStack_28;
  uint32_t SystemMaxOperationCount;
  
  SystemContextValue = 0xfffffffffffffffe;
  if (((uint)SystemResourceManager[0x40] & 0x10000) == 0) {
    SystemResourceStatusFlagCompact[0] = 0;
    SystemMaxOperationCount = 0;
    UnsignedStackFlag80 = 0x1800795fa;
    pfStack_28 = SystemResourceManager;
    InitializeSystemResourceEncryption(SystemResourceStatusFlagCompact);
    UnsignedStackFlag80 = 0x180079605;
    floatValue6 = (float)GetSystemTimeValue(0);
    if ((10 < (int)floatValue6) ||
       ((int)(*(int *)(*(long long *)(SystemResourceManager + 0x84) + 0x88) +
             (*(int *)(*(long long *)(SystemResourceManager + 0x84) + 0x88) >> 0x1f & 3U)) >> 2 < (int)floatValue6)) {
      pSystemEncryptionKey = &SystemStringTemplate;
      if (*(void* **)(SystemResourceManager + 6) != (void* *)0x0) {
        pSystemEncryptionKey = *(void* **)(SystemResourceManager + 6);
      }
      SystemOperationCounter = ConcatenatedValue44(SystemOperationCounter._4_4_,*(uint32_t *)(*(long long *)(SystemResourceManager + 0x84) + 0x60));
      memoryAllocationBuffer = &SystemMemoryBufferTemplateA;
      UnsignedStackFlag80 = 0x18007967a;
      SystemFloatValue3 = floatValue6;
      SystemManagerSetFlags(SystemContextManagerPointer,0,0x80000000000,3);
    }
    SystemResourceManager[0x40] = (float)((uint)SystemResourceManager[0x40] | 0x10000);
    UnsignedStackFlag80 = 0x18007968e;
    CleanupSystemResourceEncryption(SystemResourceStatusFlagCompact);
  }
  SystemContextValue = 0xfffffffffffffffe;
  pfloatValue7 = SystemResourceManager;
  if ((*(byte *)((long long)SystemResourceManager + 0xfd) & 0x20) == 0) {
    pfloatValue7 = (float *)func_0x000180085de0(*(void* *)(SystemResourceManager + 0x6c));
  }
  if ((*(long long *)(pfloatValue7 + 0x84) != 0) && (((uint)SystemResourceManager[0x40] & 0x80) == 0)) {
    primaryFloatPointer = SystemResourceManager + 0x9d;
    primaryFloatPointer[0] = 1e+08;
    primaryFloatPointer[1] = 1e+08;
    SystemResourceManager[0x9f] = 1e+08;
    SystemResourceManager[0xa0] = 3.4028235e+38;
    SystemResourceManager[0xa1] = -1e+08;
    SystemResourceManager[0xa2] = -1e+08;
    SystemResourceManager[0xa3] = -1e+08;
    SystemResourceManager[0xa4] = 3.4028235e+38;
    OperationCode = 0;
    SystemResourceManager[0xa9] = 0.0;
    SystemResourceManager[0xa5] = 0.0;
    SystemResourceManager[0xa6] = 0.0;
    SystemResourceManager[0xa7] = 0.0;
    SystemResourceManager[0xa8] = 3.4028235e+38;
    SystemConfigurationValue = 0;
    SystemFloatPointer = pfloatValue7;
    InitializeSystemContext(&SystemFloatPointer);
    if (*(int *)(SystemConfigurationData + 0x10) != 0) {
      do {
        pfloatValue7 = (float *)((long long)(int)OperationCode * 0x10 + *(long long *)(SystemConfigurationData + 0x18));
        fStack_a8 = *pfloatValue7;
        if (*primaryFloatPointer < fStack_a8) {
          fStack_a8 = *primaryFloatPointer;
        }
        fStack_a4 = pfloatValue7[1];
        if (SystemResourceManager[0x9e] < fStack_a4) {
          fStack_a4 = SystemResourceManager[0x9e];
        }
        fStack_a0 = pfloatValue7[2];
        if (SystemResourceManager[0x9f] < fStack_a0) {
          fStack_a0 = SystemResourceManager[0x9f];
        }
        *(ulong long *)primaryFloatPointer = ConcatenatedValue44(fStack_a4,fStack_a8);
        *(ulong long *)(SystemResourceManager + 0x9f) = ConcatenatedValue44(uStack_9c,fStack_a0);
        fStack_b8 = *pfloatValue7;
        if (fStack_b8 < SystemResourceManager[0xa1]) {
          fStack_b8 = SystemResourceManager[0xa1];
        }
        fStack_b4 = pfloatValue7[1];
        if (fStack_b4 < SystemResourceManager[0xa2]) {
          fStack_b4 = SystemResourceManager[0xa2];
        }
        fStack_b0 = pfloatValue7[2];
        if (fStack_b0 < SystemResourceManager[0xa3]) {
          fStack_b0 = SystemResourceManager[0xa3];
        }
        *(ulong long *)(SystemResourceManager + 0xa1) = ConcatenatedValue44(fStack_b4,fStack_b8);
        *(ulong long *)(SystemResourceManager + 0xa3) = ConcatenatedValue44(uStack_ac,fStack_b0);
        OperationCode = OperationCode + 1;
      } while (OperationCode < *(uint *)(SystemConfigurationData + 0x10));
    }
    pfloatValue7 = *(float **)(SystemResourceManager + 0x6e);
    if ((pfloatValue7 != (float *)0x0) && (((uint)pfloatValue7[0x4e] & 0x3000) != 0)) {
      SystemUnsignedFlag78 = *(void* *)(SystemResourceManager + 0x48);
      SystemProcessFlags70 = *(void* *)(SystemResourceManager + 0x4a);
      EncryptionValue68 = *(void* *)(SystemResourceManager + 0x4c);
      SystemThreadContext = *(void* *)(SystemResourceManager + 0x4e);
      memoryAllocationBuffer = *(void* **)(SystemResourceManager + 0x50);
      SystemFloatValue3 = SystemResourceManager[0x52];
      fStack_4c = SystemResourceManager[0x53];
      pSystemEncryptionKey = *(void* **)(SystemResourceManager + 0x54);
      SystemOperationCounter = *(void* *)(SystemResourceManager + 0x56);
      ProcessSystemUnsignedFlagInitialization(&SystemUnsignedFlag78);
      ProcessRenderObjectStateAllocation(primaryFloatPointer,primaryFloatPointer,&SystemUnsignedFlag78);
      pfloatValue7 = *(float **)(SystemResourceManager + 0x6e);
      if (((uint)pfloatValue7[0x4e] & 0x3000) == 0x2000) {
        SystemUnsignedFlag78 = *(void* *)(SystemResourceManager + 0x48);
        SystemProcessFlags70 = *(void* *)(SystemResourceManager + 0x4a);
        EncryptionValue68 = *(void* *)(SystemResourceManager + 0x4c);
        SystemThreadContext = *(void* *)(SystemResourceManager + 0x4e);
        memoryAllocationBuffer = *(void* **)(SystemResourceManager + 0x50);
        SystemFloatValue3 = SystemResourceManager[0x52];
        fStack_4c = SystemResourceManager[0x53];
        pSystemEncryptionKey = *(void* **)(SystemResourceManager + 0x54);
        SystemOperationCounter = *(void* *)(SystemResourceManager + 0x56);
        ProcessSystemUnsignedFlagWithFloatingValue(&SystemUnsignedFlag78,0x3fc90fdb);
        ProcessRenderObjectStateAllocation(primaryFloatPointer,primaryFloatPointer,&SystemUnsignedFlag78);
        SystemUnsignedFlag78 = *(void* *)(SystemResourceManager + 0x48);
        SystemProcessFlags70 = *(void* *)(SystemResourceManager + 0x4a);
        EncryptionValue68 = *(void* *)(SystemResourceManager + 0x4c);
        SystemThreadContext = *(void* *)(SystemResourceManager + 0x4e);
        memoryAllocationBuffer = *(void* **)(SystemResourceManager + 0x50);
        SystemFloatValue3 = SystemResourceManager[0x52];
        fStack_4c = SystemResourceManager[0x53];
        pSystemEncryptionKey = *(void* **)(SystemResourceManager + 0x54);
        SystemOperationCounter = *(void* *)(SystemResourceManager + 0x56);
        ResetSystemUnsignedFlag(&SystemUnsignedFlag78);
        pfloatValue7 = (float *)ProcessRenderObjectStateAllocation(primaryFloatPointer,primaryFloatPointer,&SystemUnsignedFlag78);
      }
    }
    pfloatValue4 = SystemFloatPointer;
    if (SystemResourceManager[0xa1] < *primaryFloatPointer) {
      SystemResourceManager[0xa9] = 0.0;
      primaryFloatPointer[0] = 0.0;
      primaryFloatPointer[1] = 0.0;
      SystemResourceManager[0x9f] = 0.0;
      SystemResourceManager[0xa0] = 0.0;
      SystemResourceManager[0xa1] = 0.0;
      SystemResourceManager[0xa2] = 0.0;
      SystemResourceManager[0xa3] = 0.0;
      SystemResourceManager[0xa4] = 0.0;
      SystemResourceManager[0xa5] = 0.0;
      SystemResourceManager[0xa6] = 0.0;
      SystemResourceManager[0xa7] = 0.0;
      SystemResourceManager[0xa8] = 0.0;
    }
    else {
      SystemResourceManager[0xa5] = (SystemResourceManager[0xa1] + *primaryFloatPointer) * 0.5;
      SystemResourceManager[0xa6] = (SystemResourceManager[0xa2] + SystemResourceManager[0x9e]) * 0.5;
      SystemResourceManager[0xa7] = (SystemResourceManager[0xa3] + SystemResourceManager[0x9f]) * 0.5;
      SystemResourceManager[0xa8] = 3.4028235e+38;
      floatValue6 = 0.0;
      ThreadContextFlag = (ulong long)*(uint *)(SystemConfigurationData + 0x10);
      if (0 < (int)*(uint *)(SystemConfigurationData + 0x10)) {
        pfloatValue7 = *(float **)(SystemConfigurationData + 0x18);
        OffsetValue = floatValue6;
        do {
          floatValue6 = (*pfloatValue7 - SystemResourceManager[0xa5]) * (*pfloatValue7 - SystemResourceManager[0xa5]) +
                  (pfloatValue7[1] - SystemResourceManager[0xa6]) * (pfloatValue7[1] - SystemResourceManager[0xa6]) +
                  (pfloatValue7[2] - SystemResourceManager[0xa7]) * (pfloatValue7[2] - SystemResourceManager[0xa7]);
          if (floatValue6 <= OffsetValue) {
            floatValue6 = OffsetValue;
          }
          pfloatValue7 = pfloatValue7 + 4;
          ThreadContextFlag = ThreadContextFlag - 1;
          OffsetValue = floatValue6;
        } while (ThreadContextFlag != 0);
      }
      SystemResourceManager[0xa9] = SQRT(floatValue6);
    }
    if (SystemFloatPointer != (float *)0x0) {
      while( true ) {
        LOCK();
        systemStatusFlag = *(char *)(pfloatValue4 + 0x3b);
        isByteValid0 = systemStatusFlag == '\0';
        if (isByteValid0) {
          *(char *)(pfloatValue4 + 0x3b) = '\x01';
          systemStatusFlag = '\0';
        }
        UNLOCK();
        if (isByteValid0) break;
        floatValue6 = (float)_Thrd_id();
        if ((pfloatValue4[0x3c] == floatValue6) || (pfloatValue4[0x3c] != 0.0)) goto LAB_180075f4f;
        Sleep();
      }
      systemStatusFlag = '\0';
LAB_180075f4f:
      LOCK();
      primaryFloatPointer = pfloatValue4 + 0x3a;
      floatValue6 = *primaryFloatPointer;
      pfloatValue7 = (float *)(ulong long)(uint)floatValue6;
      *primaryFloatPointer = (float)((int)*primaryFloatPointer + -1);
      UNLOCK();
      if (systemStatusFlag == '\0') {
        if ((((floatValue6 == 1.4013e-45) && (*(long long *)(SystemFloatPointer + 0x84) != 0)) &&
            (pfloatValue7 = SystemFloatPointer, ValidateSystemString(SystemFloatPointer), *(char *)(pfloatValue7 + 0x3f) == '\0')) &&
           ((*(char *)(pfloatValue7 + 0x3d) == '\0' &&
            (((*(byte *)((long long)pfloatValue7 + 0xfd) & 0x20) == 0 ||
             ((*(byte *)((long long)pfloatValue7 + 0xfe) & 1) == 0)))))) {
          SystemResourceOffsetPointer = *(long long **)(pfloatValue7 + 0x84);
          pfloatValue7[0x84] = 0.0;
          pfloatValue7[0x85] = 0.0;
          if (SystemResourceOffsetPointer != (long long *)0x0) {
            (**(code **)(*SystemResourceOffsetPointer + 0x38))();
          }
        }
        LOCK();
        isSystemActive = *(byte *)(pfloatValue4 + 0x3b);
        *(byte *)(pfloatValue4 + 0x3b) = 0;
        pfloatValue7 = (float *)(ulong long)isSystemActive;
        UNLOCK();
      }
    }
  }
  return pfloatValue7;
}



0001800797c0)
0001800797c8)
0001800797cd)
0001800797dd)


/**
 * @brief 初始化系统资源缓存
 * 
 * 初始化系统资源的缓存机制，包括哈希表、内存分配和资源数据结构。
 * 该函数负责设置资源缓存的基础设施，为后续的资源操作提供支持。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要初始化的资源管理系统
 * @return 无返回值
 */
void InitializeSystemResourceCache(long long SystemResourceManager)

{
  int* SystemIntegerPointer;
  uint *SystemHashEntryPointer;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  float BaseValue;
  void* ResourceHash;
  void* ThreadContextFlag;
  uint8_t aOperationCode [16];
  bool isSystemBusy;
  int *SystemIntegerPointer0;
  int SystemOperationStatus1;
  long long resourceDataIndex2;
  int *SystemIntegerPointer3;
  int *SystemIntegerPointer4;
  int *SystemIntegerPointer5;
  int *SystemIntegerPointer6;
  long long resourceDataIndex7;
  float *pMagnitudeSquared;
  uint SystemContextPointer;
  int *pointerToInteger20;
  long long SystemThreadHandle1;
  long long SystemThreadHandle2;
  long long SystemThreadHandle3;
  long long SystemThreadHandle4;
  int *pointerToInteger25;
  int *pointerToInteger26;
  int systemResult7;
  ulong long resourceCreationFlags8;
  uint32_t *HashEntryPointer2;
  ulong long resourceAllocationContext0;
  long long ResourceDataOffset1;
  uint *SystemHashNodeData2;
  uint resourceAllocationContext3;
  int *pointerToInteger34;
  uint8_t (*paresourceAllocationContext5) [16];
  ulong long resourceAllocationContext6;
  uint8_t (*paresourceAllocationContext7) [16];
  ulong long resourceAllocationContext8;
  long long *SystemResourceOffsetPointer9;
  long long SystemBufferAddress0;
  ulong long resourceAddress1;
  uint8_t (*paresourceAddress2) [16];
  long long SystemBufferAddress3;
  bool isResourceAvailable4;
  float floatValue45;
  float floatValue46;
  uint8_t aresourceAddress7 [16];
  float floatValue48;
  float floatValue49;
  float BaseValue0;
  float BaseValue1;
  float BaseValue2;
  float BaseValue3;
  int LoopCounter;
  ulong long SystemParameterPointer;
  ulong long SystemConfigurationPointer;
  int *piStack_218;
  int *piStack_210;
  int *piStack_208;
  uint32_t StackValue200;
  int *piStack_1f8;
  int *piStack_1f0;
  int stackVariable1E8;
  uint8_t (*paGlobalDataFlags2) [16];
  ulong long SystemTimeFlag1d8;
  long long longValue1d0;
  uint SystemThreadStackSize;
  uint GlobalDataFlags;
  uint32_t StackUnsignedValue1BC;
  void* SystemOperationFlag1b8;
  int *piStack_1b0;
  uint32_t StackUnsignedValue1A8;
  void* CalculationFlags1A0;
  void* SystemStackFlag;
  int *piStack_190;
  uint32_t ConcatenatedValue448;
  void* ConcatenatedValue440;
  float fStack_178;
  float fStack_174;
  long long longValue170;
  long long *pSystemMemoryOffset168;
  long long *pSystemMemoryOffset160;
  uint32_t SystemConfigurationId;
  uint8_t aSystemResourceSize [16];
  void* SystemThreadContext140;
  uint32_t StackUnsignedValue138;
  uint32_t *ResourceBufferPointer130;
  void* SystemMemoryOffset;
  void* SystemResourceFlags120;
  uint32_t UnsignedStackFlag118;
  void* UnsignedStackFlag110;
  void* EncryptionOffset1;
  void* EncryptionOffset2;
  void* MemoryBufferAddress;
  void* StackPointerF0;
  void* StackPointerE8;
  void* StackPointerE0;
  void* SystemMemoryAllocatorStatus;
  void* StackPointerD0;
  void* StackPointerC8;
  void* UnsignedStackFlagC0;
  void* systemDataBuffer;
  uint32_t UnsignedStackFlagB0;
  
  UnsignedStackFlag110 = 0xfffffffffffffffe;
  SystemIntegerPointer = (int *)(SystemResourceManager + 0x60);
  systemResult7 = *SystemIntegerPointer;
  SystemOperationStatus1 = *(int *)(SystemResourceManager + 0x88);
  resourceCreationFlags8 = (ulong long)SystemOperationStatus1;
  iStack_1e8 = *(int *)(SystemResourceManager + 0x10);
  ResourceBufferPointer130 = (uint32_t *)0x0;
  SystemMemoryOffset = 0;
  SystemResourceFlags120 = 0;
  UnsignedStackFlag118 = 3;
  ConfigureResourceBuffer(&ResourceBufferPointer130,resourceCreationFlags8);
  resourceAddress1 = resourceCreationFlags8;
  HashEntryPointer2 = ResourceBufferPointer130;
  if (0 < SystemOperationStatus1) {
    for (; resourceAddress1 != 0; resourceAddress1 = resourceAddress1 - 1) {
      *HashEntryPointer2 = 1;
      HashEntryPointer2 = HashEntryPointer2 + 1;
    }
  }
  aSystemResourceSize = ZEXT816(0);
  SystemThreadContext140 = 0;
  uStack_138 = 3;
  SystemThreadHandle1 = (ulong long)*(ushort *)(SystemResourceManager + 0xc0) + 1;
  if (SystemThreadHandle1 == 0) {
    SystemThreadHandle1 = 0;
    aSystemResourceSize = ZEXT816(0) << 0x40;
  }
  else {
    ProcessThreadHandle(aSystemResourceSize,SystemThreadHandle1);
    SystemThreadHandle1 = aSystemResourceSize._0_8_;
  }
  paGlobalDataFlags2 = (uint8_t (*) [16])(ulong long)*(ushort *)(SystemResourceManager + 0xc0);
  SystemThreadHandle3 = -1;
  do {
    ResourceDataOffset1 = SystemThreadHandle3 + 1;
    SystemThreadHandle2 = ResourceDataOffset1 * 0x20;
    resourceDataIndex7 = *(long long *)(SystemThreadHandle1 + 8 + SystemThreadHandle2);
    SystemThreadHandle4 = *(long long *)(SystemThreadHandle1 + SystemThreadHandle2);
    resourceAddress1 = resourceDataIndex7 - SystemThreadHandle4 >> 4;
    if (resourceAddress1 < resourceCreationFlags8) {
      resourceAllocationContext0 = resourceCreationFlags8 - resourceAddress1;
      if ((ulong long)(*(long long *)(SystemThreadHandle1 + 0x10 + SystemThreadHandle2) - resourceDataIndex7 >> 4) < resourceAllocationContext0) {
        if (resourceAddress1 == 0) {
          resourceAddress1 = 1;
        }
        else {
          resourceAddress1 = resourceAddress1 * 2;
        }
        if (resourceAddress1 < resourceCreationFlags8) {
          resourceAddress1 = resourceCreationFlags8;
        }
        if (resourceAddress1 == 0) {
          resourceDataIndex2 = 0;
        }
        else {
          resourceDataIndex2 = CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceAddress1 << 4,*(uint8_t *)(SystemThreadHandle1 + 0x18 + SystemThreadHandle2))
          ;
          resourceDataIndex7 = *(long long *)(SystemThreadHandle1 + 8 + SystemThreadHandle2);
          SystemThreadHandle4 = *(long long *)(SystemThreadHandle1 + SystemThreadHandle2);
        }
        if (SystemThreadHandle4 != resourceDataIndex7) {
            memmove(resourceDataIndex2,SystemThreadHandle4,resourceDataIndex7 - SystemThreadHandle4);
        }
        if (resourceAllocationContext0 != 0) {
            memset(resourceDataIndex2,0,resourceAllocationContext0 * 0x10);
        }
        if (*(long long *)(SystemThreadHandle1 + SystemThreadHandle2) != 0) {
            SystemCleanupFunction();
        }
        *(long long *)(SystemThreadHandle1 + SystemThreadHandle2) = resourceDataIndex2;
        *(long long *)(SystemThreadHandle1 + 8 + SystemThreadHandle2) = resourceDataIndex2;
        *(ulong long *)(SystemThreadHandle1 + 0x10 + SystemThreadHandle2) = resourceAddress1 * 0x10 + resourceDataIndex2;
      }
      else {
        if (resourceAllocationContext0 != 0) {
            memset(resourceDataIndex7,0,resourceAllocationContext0 * 0x10);
        }
        *(long long *)(SystemThreadHandle1 + 8 + SystemThreadHandle2) = resourceDataIndex7;
      }
    }
    else {
      *(ulong long *)(SystemThreadHandle1 + 8 + SystemThreadHandle2) = resourceCreationFlags8 * 0x10 + SystemThreadHandle4;
    }
    resourceAllocationContext6 = 0;
    resourceAddress1 = resourceAllocationContext6;
    resourceAllocationContext0 = resourceAllocationContext6;
    resourceAllocationContext8 = resourceCreationFlags8;
    if (0 < (long long)resourceCreationFlags8) {
      do {
        SystemThreadHandle1 = *(long long *)(SystemResourceManager + 0x90);
        SystemThreadHandle4 = (long long)*(int *)(SystemThreadHandle1 + 8 + resourceAddress1);
        resourceDataIndex7 = (long long)*(int *)(SystemThreadHandle1 + 4 + resourceAddress1) * 0x5c;
        if (SystemThreadHandle3 == -1) {
          resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x68);
          SystemBufferAddress0 = *(long long *)(SystemResourceManager + 0x18);
          resourceDataIndex7 = (long long)*(int *)(resourceDataIndex7 + resourceDataIndex2);
          SystemThreadHandle1 = (long long)*(int *)((long long)*(int *)(SystemThreadHandle1 + resourceAddress1) * 0x5c + resourceDataIndex2);
          floatValue48 = *(float *)(SystemBufferAddress0 + 8 + SystemThreadHandle1 * 0x10);
          floatValue49 = *(float *)(SystemBufferAddress0 + 8 + resourceDataIndex7 * 0x10) - floatValue48;
          BaseValue = *(float *)(SystemBufferAddress0 + 4 + SystemThreadHandle1 * 0x10);
          BaseValue2 = *(float *)(SystemBufferAddress0 + 4 + resourceDataIndex7 * 0x10);
          BaseValue1 = *(float *)(SystemBufferAddress0 + SystemThreadHandle1 * 0x10);
          SystemThreadHandle1 = (long long)*(int *)(SystemThreadHandle4 * 0x5c + resourceDataIndex2);
          floatValue48 = *(float *)(SystemBufferAddress0 + 8 + SystemThreadHandle1 * 0x10) - floatValue48;
          floatValue45 = *(float *)(SystemBufferAddress0 + 4 + SystemThreadHandle1 * 0x10);
          floatValue46 = *(float *)(SystemBufferAddress0 + resourceDataIndex7 * 0x10);
          BaseValue3 = *(float *)(SystemBufferAddress0 + SystemThreadHandle1 * 0x10);
        }
        else {
          resourceDataIndex2 = *(long long *)(SystemResourceManager + 0x68);
          SystemBufferAddress0 = *(long long *)(SystemThreadHandle3 * 0x50 + *(long long *)(SystemResourceManager + 0xb0) + 8);
          resourceDataIndex7 = (long long)*(int *)(resourceDataIndex7 + resourceDataIndex2);
          SystemThreadHandle1 = (long long)*(int *)((long long)*(int *)(SystemThreadHandle1 + resourceAddress1) * 0x5c + resourceDataIndex2);
          floatValue48 = *(float *)(SystemBufferAddress0 + 8 + SystemThreadHandle1 * 0x10);
          floatValue49 = *(float *)(SystemBufferAddress0 + 8 + resourceDataIndex7 * 0x10) - floatValue48;
          BaseValue = *(float *)(SystemBufferAddress0 + 4 + SystemThreadHandle1 * 0x10);
          BaseValue2 = *(float *)(SystemBufferAddress0 + 4 + resourceDataIndex7 * 0x10);
          BaseValue1 = *(float *)(SystemBufferAddress0 + SystemThreadHandle1 * 0x10);
          SystemThreadHandle1 = (long long)*(int *)(SystemThreadHandle4 * 0x5c + resourceDataIndex2);
          floatValue48 = *(float *)(SystemBufferAddress0 + 8 + SystemThreadHandle1 * 0x10) - floatValue48;
          floatValue45 = *(float *)(SystemBufferAddress0 + 4 + SystemThreadHandle1 * 0x10);
          floatValue46 = *(float *)(SystemBufferAddress0 + resourceDataIndex7 * 0x10);
          BaseValue3 = *(float *)(SystemBufferAddress0 + SystemThreadHandle1 * 0x10);
        }
        BaseValue0 = (floatValue46 - BaseValue1) * (floatValue45 - BaseValue) - (BaseValue2 - BaseValue) * (BaseValue3 - BaseValue1);
        BaseValue1 = floatValue49 * (BaseValue3 - BaseValue1) - floatValue48 * (floatValue46 - BaseValue1);
        floatValue48 = floatValue48 * (BaseValue2 - BaseValue) - floatValue49 * (floatValue45 - BaseValue);
        fStack_174 = SQRT(BaseValue1 * BaseValue1 + floatValue48 * floatValue48 + BaseValue0 * BaseValue0);
        if (fStack_174 <= 0.0) {
          floatValue48 = 0.0;
          BaseValue1 = 0.0;
          fStack_178 = 1.0;
          fStack_174 = 1.0;
        }
        else {
          fStack_178 = 1.0 / fStack_174;
          floatValue48 = floatValue48 * fStack_178;
          BaseValue1 = fStack_178 * BaseValue1;
          fStack_178 = fStack_178 * BaseValue0;
        }
        ConcatenatedValue440 = ConcatenatedValue44(BaseValue1,floatValue48);
        pMagnitudeSquared = (float *)(*(long long *)(aSystemResourceSize._0_8_ + SystemThreadHandle2) + resourceAllocationContext0);
        *pMagnitudeSquared = floatValue48;
        pMagnitudeSquared[1] = BaseValue1;
        pMagnitudeSquared[2] = fStack_178;
        pMagnitudeSquared[3] = fStack_174;
        resourceAllocationContext8 = resourceAllocationContext8 - 1;
        resourceAddress1 = resourceAddress1 + 0xc;
        resourceAllocationContext0 = resourceAllocationContext0 + 0x10;
      } while (resourceAllocationContext8 != 0);
    }
    SystemThreadHandle1 = aSystemResourceSize._0_8_;
    SystemThreadHandle3 = ResourceDataOffset1;
  } while (ResourceDataOffset1 < (long long)paGlobalDataFlags2);
  longValue170 = 0;
  pSystemMemoryOffset168 = (long long *)0x0;
  pSystemMemoryOffset160 = (long long *)0x0;
  SystemConfigurationId = 3;
  AllocateSystemBuffer(&longValue170,(long long)systemResult7);
  resourceAddress1 = resourceAllocationContext6;
  SystemConfigurationPointer = resourceCreationFlags8;
  if (0 < (long long)resourceCreationFlags8) {
    do {
      SystemThreadHandle3 = longValue170;
      SystemIntegerPointer3 = (int *)0x0;
      SystemThreadHandle1 = *(long long *)(SystemResourceManager + 0x90);
      ResourceDataOffset1 = (ulong long)*(uint *)(SystemThreadHandle1 + resourceAllocationContext6) * 0x20;
      pointerToInteger20 = *(int **)(ResourceDataOffset1 + 8 + longValue170);
      systemResult7 = (int)resourceAddress1;
      if (pointerToInteger20 < *(int **)(ResourceDataOffset1 + 0x10 + longValue170)) {
        *(int **)(ResourceDataOffset1 + 8 + longValue170) = pointerToInteger20 + 1;
        *pointerToInteger20 = systemResult7;
      }
      else {
        SystemIntegerPointer5 = *(int **)(ResourceDataOffset1 + longValue170);
        resourceDataIndex7 = (long long)pointerToInteger20 - (long long)SystemIntegerPointer5 >> 2;
        if (resourceDataIndex7 == 0) {
          resourceDataIndex7 = 1;
LAB_180079c12:
          SystemIntegerPointer3 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceDataIndex7 * 4,
                                         *(uint8_t *)(ResourceDataOffset1 + 0x18 + longValue170));
          pointerToInteger20 = *(int **)(ResourceDataOffset1 + 8 + SystemThreadHandle3);
          SystemIntegerPointer5 = *(int **)(ResourceDataOffset1 + SystemThreadHandle3);
        }
        else {
          resourceDataIndex7 = resourceDataIndex7 * 2;
          if (resourceDataIndex7 != 0) goto LAB_180079c12;
        }
        if (SystemIntegerPointer5 != pointerToInteger20) {
            memmove(SystemIntegerPointer3,SystemIntegerPointer5,(long long)pointerToInteger20 - (long long)SystemIntegerPointer5);
        }
        *SystemIntegerPointer3 = systemResult7;
        if (*(long long *)(ResourceDataOffset1 + SystemThreadHandle3) != 0) {
            SystemCleanupFunction();
        }
        *(int **)(ResourceDataOffset1 + SystemThreadHandle3) = SystemIntegerPointer3;
        *(int **)(ResourceDataOffset1 + 8 + SystemThreadHandle3) = SystemIntegerPointer3 + 1;
        *(int **)(ResourceDataOffset1 + 0x10 + SystemThreadHandle3) = SystemIntegerPointer3 + resourceDataIndex7;
      }
      SystemThreadHandle3 = longValue170;
      SystemIntegerPointer3 = (int *)0x0;
      ResourceDataOffset1 = (ulong long)*(uint *)(SystemThreadHandle1 + 4 + resourceAllocationContext6) * 0x20;
      pointerToInteger20 = *(int **)(ResourceDataOffset1 + 8 + longValue170);
      if (pointerToInteger20 < *(int **)(ResourceDataOffset1 + 0x10 + longValue170)) {
        *(int **)(ResourceDataOffset1 + 8 + longValue170) = pointerToInteger20 + 1;
        *pointerToInteger20 = systemResult7;
      }
      else {
        SystemIntegerPointer5 = *(int **)(ResourceDataOffset1 + longValue170);
        resourceDataIndex7 = (long long)pointerToInteger20 - (long long)SystemIntegerPointer5 >> 2;
        if (resourceDataIndex7 == 0) {
          resourceDataIndex7 = 1;
LAB_180079cd7:
          SystemIntegerPointer3 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,resourceDataIndex7 * 4,
                                         *(uint8_t *)(ResourceDataOffset1 + 0x18 + longValue170));
          pointerToInteger20 = *(int **)(ResourceDataOffset1 + 8 + SystemThreadHandle3);
          SystemIntegerPointer5 = *(int **)(ResourceDataOffset1 + SystemThreadHandle3);
        }
        else {
          resourceDataIndex7 = resourceDataIndex7 * 2;
          if (resourceDataIndex7 != 0) goto LAB_180079cd7;
        }
        if (SystemIntegerPointer5 != pointerToInteger20) {
            memmove(SystemIntegerPointer3,SystemIntegerPointer5,(long long)pointerToInteger20 - (long long)SystemIntegerPointer5);
        }
        *SystemIntegerPointer3 = systemResult7;
        if (*(long long *)(ResourceDataOffset1 + SystemThreadHandle3) != 0) {
            SystemCleanupFunction();
        }
        *(int **)(ResourceDataOffset1 + SystemThreadHandle3) = SystemIntegerPointer3;
        *(int **)(ResourceDataOffset1 + 8 + SystemThreadHandle3) = SystemIntegerPointer3 + 1;
        *(int **)(ResourceDataOffset1 + 0x10 + SystemThreadHandle3) = SystemIntegerPointer3 + resourceDataIndex7;
      }
      SystemThreadHandle3 = longValue170;
      SystemThreadHandle1 = (ulong long)*(uint *)(SystemThreadHandle1 + 8 + resourceAllocationContext6) * 0x20;
      pointerToInteger20 = *(int **)(SystemThreadHandle1 + 8 + longValue170);
      if (pointerToInteger20 < *(int **)(SystemThreadHandle1 + 0x10 + longValue170)) {
        *(int **)(SystemThreadHandle1 + 8 + longValue170) = pointerToInteger20 + 1;
        *pointerToInteger20 = systemResult7;
      }
      else {
        SystemIntegerPointer3 = *(int **)(SystemThreadHandle1 + longValue170);
        ResourceDataOffset1 = (long long)pointerToInteger20 - (long long)SystemIntegerPointer3 >> 2;
        if (ResourceDataOffset1 == 0) {
          ResourceDataOffset1 = 1;
LAB_180079d9b:
          SystemIntegerPointer5 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,ResourceDataOffset1 * 4,
                                         *(uint8_t *)(SystemThreadHandle1 + 0x18 + longValue170));
          pointerToInteger20 = *(int **)(SystemThreadHandle1 + 8 + SystemThreadHandle3);
          SystemIntegerPointer3 = *(int **)(SystemThreadHandle1 + SystemThreadHandle3);
        }
        else {
          ResourceDataOffset1 = ResourceDataOffset1 * 2;
          if (ResourceDataOffset1 != 0) goto LAB_180079d9b;
          SystemIntegerPointer5 = (int *)0x0;
        }
        if (SystemIntegerPointer3 != pointerToInteger20) {
            memmove(SystemIntegerPointer5,SystemIntegerPointer3,(long long)pointerToInteger20 - (long long)SystemIntegerPointer3);
        }
        *SystemIntegerPointer5 = systemResult7;
        if (*(long long *)(SystemThreadHandle1 + SystemThreadHandle3) != 0) {
            SystemCleanupFunction();
        }
        *(int **)(SystemThreadHandle1 + SystemThreadHandle3) = SystemIntegerPointer5;
        *(int **)(SystemThreadHandle1 + 8 + SystemThreadHandle3) = SystemIntegerPointer5 + 1;
        *(int **)(SystemThreadHandle1 + 0x10 + SystemThreadHandle3) = SystemIntegerPointer5 + ResourceDataOffset1;
      }
      resourceAllocationContext6 = resourceAllocationContext6 + 0xc;
      SystemConfigurationPointer = SystemConfigurationPointer - 1;
      resourceAddress1 = (ulong long)(systemResult7 + 1);
    } while (SystemConfigurationPointer != 0);
  }
  SystemContextPointer = 0;
  SystemInitializationFlag = 0;
  if (*SystemIntegerPointer < 1) {
LAB_18007a5ac:
    InitializeResourceBuffer(&longValue170);
    SystemThreadHandle1 = (long long)iStack_1e8;
    SystemTimeFlag1d8 = (ulong long)*(ushort *)(SystemResourceManager + 0xc0);
    SystemParameterPointer = -1;
    do {
      piStack_218 = (int *)0x0;
      piStack_210 = (int *)0x0;
      piStack_208 = (int *)0x0;
      StackValue200 = 3;
      if (SystemThreadHandle1 == 0) {
        InitializeThreadContext(0);
        piStack_210 = piStack_218;
      }
      else {
        ProcessThreadContext(&piStack_218,SystemThreadHandle1);
      }
      SystemResourceOffsetPointer9 = (long long *)((SystemParameterPointer + 1) * 0x20 + aSystemResourceSize._0_8_);
      SystemThreadHandle3 = 0;
      piStack_1f0 = (int *)0x0;
      if (0 < (long long)resourceCreationFlags8) {
        piStack_1f8 = (int *)0x0;
        do {
          SystemThreadHandle1 = 0;
          ConcatenatedValue440 = *(long long *)(SystemResourceManager + 0x90) + (long long)piStack_1f8;
          SystemContextPointer = ResourceBufferPointer130[(long long)piStack_1f0];
          if (SystemContextPointer == 0) {
            do {
              if (SystemParameterPointer == -1) {
                ResourceDataOffset1 = (long long)*(int *)(ConcatenatedValue440 + SystemThreadHandle1 * 4) * 0x5c +
                         *(long long *)(SystemResourceManager + 0x68);
                ResourceHash = ((void* *)(SystemThreadHandle3 + *SystemResourceOffsetPointer9))[1];
                *(void* *)(ResourceDataOffset1 + 4) = *(void* *)(SystemThreadHandle3 + *SystemResourceOffsetPointer9);
                *(void* *)(ResourceDataOffset1 + 0xc) = ResourceHash;
                ResourceHash = ((void* *)(SystemThreadHandle3 + *SystemResourceOffsetPointer9))[1];
                *(void* *)(ResourceDataOffset1 + 0x34) = *(void* *)(SystemThreadHandle3 + *SystemResourceOffsetPointer9);
                *(void* *)(ResourceDataOffset1 + 0x3c) = ResourceHash;
                floatValue48 = *(float *)(ResourceDataOffset1 + 8);
                BaseValue2 = *(float *)(ResourceDataOffset1 + 4);
                BaseValue1 = *(float *)(ResourceDataOffset1 + 0xc);
                floatValue45 = BaseValue1 * BaseValue1 + BaseValue2 * BaseValue2 + floatValue48 * floatValue48;
                aresourceAddress7 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aresourceAddress7._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *(float *)(ResourceDataOffset1 + 4) = floatValue45 * BaseValue2;
                *(float *)(ResourceDataOffset1 + 8) = floatValue45 * floatValue48;
                *(float *)(ResourceDataOffset1 + 0xc) = floatValue45 * BaseValue1;
                floatValue48 = *(float *)(ResourceDataOffset1 + 0x38);
                BaseValue2 = *(float *)(ResourceDataOffset1 + 0x34);
                BaseValue1 = *(float *)(ResourceDataOffset1 + 0x3c);
                floatValue45 = BaseValue1 * BaseValue1 + BaseValue2 * BaseValue2 + floatValue48 * floatValue48;
                aresourceAddress7 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aresourceAddress7._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *(float *)(ResourceDataOffset1 + 0x34) = BaseValue2 * floatValue45;
                *(float *)(ResourceDataOffset1 + 0x38) = floatValue48 * floatValue45;
                *(float *)(ResourceDataOffset1 + 0x3c) = BaseValue1 * floatValue45;
              }
              else {
                ResourceHash = ((void* *)(SystemThreadHandle3 + *SystemResourceOffsetPointer9))[1];
                SystemHashNodeData = (void* *)
                         (*(long long *)(*(long long *)(SystemResourceManager + 0xb0) + 0x30 + SystemParameterPointer * 0x50) +
                         (long long)*(int *)(ConcatenatedValue440 + SystemThreadHandle1 * 4) * 0x10);
                *SystemHashNodeData = *(void* *)(SystemThreadHandle3 + *SystemResourceOffsetPointer9);
                SystemHashNodeData[1] = ResourceHash;
                pMagnitudeSquared = (float *)((long long)*(int *)(ConcatenatedValue440 + SystemThreadHandle1 * 4) * 0x10 +
                                   *(long long *)
                                    (*(long long *)(SystemResourceManager + 0xb0) + 0x30 + SystemParameterPointer * 0x50));
                floatValue48 = pMagnitudeSquared[1];
                BaseValue2 = *pMagnitudeSquared;
                BaseValue1 = pMagnitudeSquared[2];
                floatValue45 = BaseValue1 * BaseValue1 + BaseValue2 * BaseValue2 + floatValue48 * floatValue48;
                aresourceAddress7 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aresourceAddress7._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *pMagnitudeSquared = BaseValue2 * floatValue45;
                pMagnitudeSquared[1] = floatValue48 * floatValue45;
                pMagnitudeSquared[2] = BaseValue1 * floatValue45;
              }
              SystemThreadHandle1 = SystemThreadHandle1 + 1;
            } while (SystemThreadHandle1 < 3);
          }
          else {
            longValue1d0 = 0;
            do {
              SystemIntegerPointer = piStack_218;
              ResourceDataOffset1 = 0;
              SystemHashNodeData2 = (uint *)((long long)*(int *)(ConcatenatedValue440 + longValue1d0 * 4) * 0x5c +
                                *(long long *)(SystemResourceManager + 0x68));
              isResourceAvailable4 = false;
              resourceDataIndex7 = (long long)
                       (int)((*(long long *)((long long)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8) + 8) -
                             *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8)) / 0x14);
              SystemThreadHandle1 = ResourceDataOffset1;
              if (3 < resourceDataIndex7) {
                SystemThreadHandle4 = (resourceDataIndex7 - 4U >> 2) + 1;
                SystemThreadHandle1 = SystemThreadHandle4 * 4;
                do {
                  resourceAllocationContext3 = *SystemHashNodeData2;
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)resourceAllocationContext3 * 8) + ResourceDataOffset1) &
                      SystemContextPointer) != 0) {
                    SystemHashEntryPointer = (uint *)(ResourceDataOffset1 + *(long long *)(piStack_218 + (ulong long)resourceAllocationContext3 * 8));
                    *SystemHashEntryPointer = *SystemHashEntryPointer | SystemContextPointer;
                    SystemThreadHandle2 = *SystemResourceOffsetPointer9;
                    floatValue48 = *(float *)(SystemThreadHandle3 + 8 + SystemThreadHandle2);
                    BaseValue2 = *(float *)(SystemThreadHandle3 + 4 + SystemThreadHandle2);
                    resourceDataIndex2 = *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8);
                    *(float *)(resourceDataIndex2 + 4 + ResourceDataOffset1) =
                         *(float *)(resourceDataIndex2 + 4 + ResourceDataOffset1) + *(float *)(SystemThreadHandle3 + SystemThreadHandle2);
                    *(float *)(resourceDataIndex2 + 8 + ResourceDataOffset1) = BaseValue2 + *(float *)(resourceDataIndex2 + 8 + ResourceDataOffset1);
                    *(float *)(resourceDataIndex2 + 0xc + ResourceDataOffset1) = floatValue48 + *(float *)(resourceDataIndex2 + 0xc + ResourceDataOffset1);
                    isResourceAvailable4 = true;
                    resourceAllocationContext3 = *SystemHashNodeData2;
                  }
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)resourceAllocationContext3 * 8) + 0x14 + ResourceDataOffset1)
                      & SystemContextPointer) != 0) {
                    SystemHashEntryPointer = (uint *)(*(long long *)(piStack_218 + (ulong long)resourceAllocationContext3 * 8) + 0x14 +
                                     ResourceDataOffset1);
                    *SystemHashEntryPointer = *SystemHashEntryPointer | SystemContextPointer;
                    SystemThreadHandle2 = *SystemResourceOffsetPointer9;
                    floatValue48 = *(float *)(SystemThreadHandle3 + 8 + SystemThreadHandle2);
                    BaseValue2 = *(float *)(SystemThreadHandle3 + 4 + SystemThreadHandle2);
                    resourceDataIndex2 = *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8);
                    *(float *)(resourceDataIndex2 + 0x18 + ResourceDataOffset1) =
                         *(float *)(resourceDataIndex2 + 0x18 + ResourceDataOffset1) + *(float *)(SystemThreadHandle3 + SystemThreadHandle2);
                    *(float *)(resourceDataIndex2 + 0x1c + ResourceDataOffset1) = BaseValue2 + *(float *)(resourceDataIndex2 + 0x1c + ResourceDataOffset1)
                    ;
                    *(float *)(resourceDataIndex2 + 0x20 + ResourceDataOffset1) = floatValue48 + *(float *)(resourceDataIndex2 + 0x20 + ResourceDataOffset1)
                    ;
                    isResourceAvailable4 = true;
                    resourceAllocationContext3 = *SystemHashNodeData2;
                  }
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)resourceAllocationContext3 * 8) + 0x28 + ResourceDataOffset1)
                      & SystemContextPointer) != 0) {
                    SystemHashEntryPointer = (uint *)(*(long long *)(piStack_218 + (ulong long)resourceAllocationContext3 * 8) + 0x28 +
                                     ResourceDataOffset1);
                    *SystemHashEntryPointer = *SystemHashEntryPointer | SystemContextPointer;
                    SystemThreadHandle2 = *SystemResourceOffsetPointer9;
                    floatValue48 = *(float *)(SystemThreadHandle3 + 8 + SystemThreadHandle2);
                    BaseValue2 = *(float *)(SystemThreadHandle3 + 4 + SystemThreadHandle2);
                    resourceDataIndex2 = *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8);
                    *(float *)(resourceDataIndex2 + 0x2c + ResourceDataOffset1) =
                         *(float *)(resourceDataIndex2 + 0x2c + ResourceDataOffset1) + *(float *)(SystemThreadHandle3 + SystemThreadHandle2);
                    *(float *)(resourceDataIndex2 + 0x30 + ResourceDataOffset1) = BaseValue2 + *(float *)(resourceDataIndex2 + 0x30 + ResourceDataOffset1)
                    ;
                    *(float *)(resourceDataIndex2 + 0x34 + ResourceDataOffset1) = floatValue48 + *(float *)(resourceDataIndex2 + 0x34 + ResourceDataOffset1)
                    ;
                    isResourceAvailable4 = true;
                  }
                  resourceAllocationContext3 = *(uint *)(ResourceDataOffset1 + 0x3c +
                                    *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8));
                  if ((SystemContextPointer & resourceAllocationContext3) != 0) {
                    *(uint *)(*(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8) + 0x3c + ResourceDataOffset1)
                         = resourceAllocationContext3 | SystemContextPointer;
                    SystemThreadHandle2 = *SystemResourceOffsetPointer9;
                    floatValue48 = *(float *)(SystemThreadHandle3 + 8 + SystemThreadHandle2);
                    BaseValue2 = *(float *)(SystemThreadHandle3 + 4 + SystemThreadHandle2);
                    resourceDataIndex2 = *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8);
                    *(float *)(resourceDataIndex2 + 0x40 + ResourceDataOffset1) =
                         *(float *)(resourceDataIndex2 + 0x40 + ResourceDataOffset1) + *(float *)(SystemThreadHandle3 + SystemThreadHandle2);
                    *(float *)(resourceDataIndex2 + 0x44 + ResourceDataOffset1) = BaseValue2 + *(float *)(resourceDataIndex2 + 0x44 + ResourceDataOffset1)
                    ;
                    *(float *)(resourceDataIndex2 + 0x48 + ResourceDataOffset1) = floatValue48 + *(float *)(resourceDataIndex2 + 0x48 + ResourceDataOffset1)
                    ;
                    isResourceAvailable4 = true;
                  }
                  ResourceDataOffset1 = ResourceDataOffset1 + 0x50;
                  SystemThreadHandle4 = SystemThreadHandle4 + -1;
                } while (SystemThreadHandle4 != 0);
              }
              paresourceAddress2 = (uint8_t (*) [16])0x0;
              if (SystemThreadHandle1 < resourceDataIndex7) {
                ResourceDataOffset1 = SystemThreadHandle1 * 0x14;
                resourceDataIndex7 = resourceDataIndex7 - SystemThreadHandle1;
                do {
                  resourceAllocationContext3 = *(uint *)(ResourceDataOffset1 + *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8));
                  if ((SystemContextPointer & resourceAllocationContext3) != 0) {
                    *(uint *)(ResourceDataOffset1 + *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8)) =
                         resourceAllocationContext3 | SystemContextPointer;
                    SystemThreadHandle1 = *SystemResourceOffsetPointer9;
                    floatValue48 = *(float *)(SystemThreadHandle3 + 8 + SystemThreadHandle1);
                    BaseValue2 = *(float *)(SystemThreadHandle3 + 4 + SystemThreadHandle1);
                    SystemThreadHandle4 = *(long long *)(piStack_218 + (ulong long)*SystemHashNodeData2 * 8);
                    *(float *)(ResourceDataOffset1 + 4 + SystemThreadHandle4) =
                         *(float *)(ResourceDataOffset1 + 4 + SystemThreadHandle4) + *(float *)(SystemThreadHandle3 + SystemThreadHandle1);
                    *(float *)(ResourceDataOffset1 + 8 + SystemThreadHandle4) = BaseValue2 + *(float *)(ResourceDataOffset1 + 8 + SystemThreadHandle4);
                    *(float *)(ResourceDataOffset1 + 0xc + SystemThreadHandle4) = floatValue48 + *(float *)(ResourceDataOffset1 + 0xc + SystemThreadHandle4);
                    isResourceAvailable4 = true;
                  }
                  ResourceDataOffset1 = ResourceDataOffset1 + 0x14;
                  resourceDataIndex7 = resourceDataIndex7 + -1;
                } while (resourceDataIndex7 != 0);
              }
              if (!isResourceAvailable4) {
                SystemThreadHandle1 = *SystemResourceOffsetPointer9;
                SystemOperationFlag1b8._4_4_ = *(uint32_t *)(SystemThreadHandle3 + 8 + SystemThreadHandle1);
                SystemOperationFlag1b8._0_4_ = *(uint32_t *)(SystemThreadHandle3 + 4 + SystemThreadHandle1);
                uStack_1bc = *(uint32_t *)(SystemThreadHandle3 + SystemThreadHandle1);
                CalculationFlags1A0 = (int *)ConcatenatedValue44((uint32_t)SystemOperationFlag1b8,uStack_1bc);
                SystemStackFlag = (int *)ConcatenatedValue44(0x7f7fffff,SystemOperationFlag1b8._4_4_);
                piStack_1b0 = (int *)ConcatenatedValue44(piStack_1b0._4_4_,0x7f7fffff);
                resourceAddress1 = (ulong long)*SystemHashNodeData2;
                paresourceAllocationContext7 = *(uint8_t (**) [16])(piStack_218 + resourceAddress1 * 8 + 2);
                GlobalDataFlags = SystemContextPointer;
                if (paresourceAllocationContext7 < *(uint8_t (**) [16])(piStack_218 + resourceAddress1 * 8 + 4)) {
                  *(uint8_t **)(piStack_218 + resourceAddress1 * 8 + 2) = paresourceAllocationContext7[1] + 4;
                  aOperationCode._4_4_ = uStack_1bc;
                  aOperationCode._0_4_ = SystemContextPointer;
                  aOperationCode._8_4_ = (uint32_t)SystemOperationFlag1b8;
                  aOperationCode._12_4_ = SystemOperationFlag1b8._4_4_;
                  *paresourceAllocationContext7 = aOperationCode;
                  *(uint32_t *)paresourceAllocationContext7[1] = 0x7f7fffff;
                }
                else {
                  paresourceAllocationContext5 = *(uint8_t (**) [16])(piStack_218 + resourceAddress1 * 8);
                  SystemThreadHandle1 = ((long long)paresourceAllocationContext7 - (long long)paresourceAllocationContext5) / 0x14;
                  if (SystemThreadHandle1 == 0) {
                    SystemConfigurationPointer = 1;
LAB_18007ac04:
                    paresourceAddress2 = (uint8_t (*) [16])
                               CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemConfigurationPointer * 0x14,
                                             (char)piStack_218[resourceAddress1 * 8 + 6]);
                    paresourceAllocationContext7 = *(uint8_t (**) [16])(SystemIntegerPointer + resourceAddress1 * 8 + 2);
                    paresourceAllocationContext5 = *(uint8_t (**) [16])(SystemIntegerPointer + resourceAddress1 * 8);
                  }
                  else {
                    SystemConfigurationPointer = SystemThreadHandle1 * 2;
                    if (SystemConfigurationPointer != 0) goto LAB_18007ac04;
                  }
                  paGlobalDataFlags2 = paresourceAddress2;
                  if (paresourceAllocationContext5 != paresourceAllocationContext7) {
                      memmove(paresourceAddress2,paresourceAllocationContext5,(long long)paresourceAllocationContext7 - (long long)paresourceAllocationContext5);
                  }
                  aresourceAddress7._4_4_ = uStack_1bc;
                  aresourceAddress7._0_4_ = GlobalDataFlags;
                  aresourceAddress7._8_4_ = (uint32_t)SystemOperationFlag1b8;
                  aresourceAddress7._12_4_ = SystemOperationFlag1b8._4_4_;
                  *paresourceAddress2 = aresourceAddress7;
                  *(uint32_t *)paresourceAddress2[1] = piStack_1b0._0_4_;
                  if (*(long long *)(SystemIntegerPointer + resourceAddress1 * 8) != 0) {
                      SystemCleanupFunction();
                  }
                  *(uint8_t (**) [16])(SystemIntegerPointer + resourceAddress1 * 8) = paresourceAddress2;
                  *(uint8_t **)(SystemIntegerPointer + resourceAddress1 * 8 + 2) = paresourceAddress2[1] + 4;
                  *(ulong long *)(SystemIntegerPointer + resourceAddress1 * 8 + 4) = (long long)paresourceAddress2 + SystemConfigurationPointer * 0x14;
                }
              }
              longValue1d0 = longValue1d0 + 1;
            } while (longValue1d0 < 3);
          }
          piStack_1f0 = (int *)((long long)piStack_1f0 + 1);
          piStack_1f8 = piStack_1f8 + 3;
          SystemThreadHandle3 = SystemThreadHandle3 + 0x10;
        } while ((long long)piStack_1f0 < (long long)resourceCreationFlags8);
        SystemThreadHandle1 = (long long)iStack_1e8;
      }
      resourceDataIndex7 = 0;
      SystemThreadHandle3 = resourceDataIndex7;
      ResourceDataOffset1 = SystemThreadHandle1;
      if (0 < SystemThreadHandle1) {
        do {
          systemResult7 = (int)((*(long long *)(SystemThreadHandle3 + 8 + (long long)piStack_218) -
                         *(long long *)(SystemThreadHandle3 + (long long)piStack_218)) / 0x14);
          SystemThreadHandle2 = (long long)systemResult7;
          SystemThreadHandle4 = resourceDataIndex7;
          if (0 < systemResult7) {
            do {
              resourceDataIndex2 = *(long long *)(SystemThreadHandle3 + (long long)piStack_218);
              floatValue48 = *(float *)(resourceDataIndex2 + 8 + SystemThreadHandle4);
              BaseValue2 = *(float *)(resourceDataIndex2 + 4 + SystemThreadHandle4);
              BaseValue1 = *(float *)(resourceDataIndex2 + 0xc + SystemThreadHandle4);
              floatValue45 = BaseValue2 * BaseValue2 + floatValue48 * floatValue48 + BaseValue1 * BaseValue1;
              if (SQRT(floatValue45) == 0.0) {
                *(uint8_t (*) [16])(resourceDataIndex2 + 4 + SystemThreadHandle4) = SystemZeroVectorData;
              }
              else {
                aresourceAddress7 = rsqrtss(ZEXT416((uint)floatValue45),ZEXT416((uint)floatValue45));
                floatValue46 = aresourceAddress7._0_4_;
                floatValue45 = floatValue46 * 0.5 * (3.0 - floatValue45 * floatValue46 * floatValue46);
                *(float *)(resourceDataIndex2 + 4 + SystemThreadHandle4) = BaseValue2 * floatValue45;
                *(float *)(resourceDataIndex2 + 8 + SystemThreadHandle4) = floatValue45 * floatValue48;
                *(float *)(resourceDataIndex2 + 0xc + SystemThreadHandle4) = BaseValue1 * floatValue45;
              }
              SystemThreadHandle2 = SystemThreadHandle2 + -1;
              SystemThreadHandle4 = SystemThreadHandle4 + 0x14;
            } while (SystemThreadHandle2 != 0);
          }
          ResourceDataOffset1 = ResourceDataOffset1 + -1;
          SystemThreadHandle3 = SystemThreadHandle3 + 0x20;
        } while (ResourceDataOffset1 != 0);
      }
      SystemThreadHandle3 = resourceDataIndex7;
      if (0 < (long long)resourceCreationFlags8) {
        do {
          SystemContextPointer = ResourceBufferPointer130[SystemThreadHandle3];
          if (SystemContextPointer != 0) {
            SystemThreadHandle1 = *(long long *)(SystemResourceManager + 0x90);
            resourceDataIndex2 = (long long)*(int *)(resourceDataIndex7 + SystemThreadHandle1) * 0x5c;
            SystemThreadHandle2 = (long long)*(int *)(*(long long *)(SystemResourceManager + 0x68) + resourceDataIndex2);
            SystemThreadHandle4 = 0;
            systemResult7 = (int)((*(long long *)(piStack_218 + SystemThreadHandle2 * 8 + 2) -
                           *(long long *)(piStack_218 + SystemThreadHandle2 * 8)) / 0x14);
            ResourceDataOffset1 = -1;
            if (0 < systemResult7) {
              SystemHashNodeData2 = *(uint **)(piStack_218 + SystemThreadHandle2 * 8);
              do {
                ResourceDataOffset1 = SystemThreadHandle4;
                if ((*SystemHashNodeData2 & SystemContextPointer) != 0) break;
                SystemThreadHandle4 = SystemThreadHandle4 + 1;
                SystemHashNodeData2 = SystemHashNodeData2 + 5;
                ResourceDataOffset1 = -1;
              } while (SystemThreadHandle4 < systemResult7);
            }
            SystemThreadHandle4 = *(long long *)(piStack_218 + SystemThreadHandle2 * 8);
            SystemHashNodeData = (void* *)(SystemThreadHandle4 + 4 + ResourceDataOffset1 * 0x14);
            ResourceHash = *SystemHashNodeData;
            ThreadContextFlag = SystemHashNodeData[1];
            if (SystemParameterPointer == -1) {
              SystemHashNodeData = (void* *)(*(long long *)(SystemResourceManager + 0x68) + 4 + resourceDataIndex2);
              *SystemHashNodeData = ResourceHash;
              SystemHashNodeData[1] = ThreadContextFlag;
              SystemHashNodeData = (void* *)(SystemThreadHandle4 + 4 + ResourceDataOffset1 * 0x14);
              ResourceHash = SystemHashNodeData[1];
              presourceAddress = (void* *)
                       ((long long)*(int *)(resourceDataIndex7 + SystemThreadHandle1) * 0x5c + 0x34 +
                       *(long long *)(SystemResourceManager + 0x68));
              *presourceAddress = *SystemHashNodeData;
              presourceAddress[1] = ResourceHash;
            }
            else {
              SystemHashNodeData = (void* *)
                       (*(long long *)(*(long long *)(SystemResourceManager + 0xb0) + 0x30 + SystemParameterPointer * 0x50) +
                       (long long)*(int *)(resourceDataIndex7 + SystemThreadHandle1) * 0x10);
              *SystemHashNodeData = ResourceHash;
              SystemHashNodeData[1] = ThreadContextFlag;
            }
            SystemBufferAddress0 = (long long)*(int *)(resourceDataIndex7 + 4 + SystemThreadHandle1);
            resourceDataIndex2 = SystemBufferAddress0 * 0x5c;
            SystemThreadHandle2 = (long long)*(int *)(*(long long *)(SystemResourceManager + 0x68) + resourceDataIndex2);
            SystemThreadHandle4 = 0;
            systemResult7 = (int)((*(long long *)(piStack_218 + SystemThreadHandle2 * 8 + 2) -
                           *(long long *)(piStack_218 + SystemThreadHandle2 * 8)) / 0x14);
            ResourceDataOffset1 = -1;
            if (0 < systemResult7) {
              SystemHashNodeData2 = *(uint **)(piStack_218 + SystemThreadHandle2 * 8);
              do {
                ResourceDataOffset1 = SystemThreadHandle4;
                if ((*SystemHashNodeData2 & SystemContextPointer) != 0) break;
                SystemThreadHandle4 = SystemThreadHandle4 + 1;
                SystemHashNodeData2 = SystemHashNodeData2 + 5;
                ResourceDataOffset1 = -1;
              } while (SystemThreadHandle4 < systemResult7);
            }
            SystemThreadHandle4 = *(long long *)(piStack_218 + SystemThreadHandle2 * 8);
            SystemHashNodeData = (void* *)(SystemThreadHandle4 + 4 + ResourceDataOffset1 * 0x14);
            ResourceHash = *SystemHashNodeData;
            ThreadContextFlag = SystemHashNodeData[1];
            if (SystemParameterPointer == -1) {
              SystemHashNodeData = (void* *)(*(long long *)(SystemResourceManager + 0x68) + 4 + resourceDataIndex2);
              *SystemHashNodeData = ResourceHash;
              SystemHashNodeData[1] = ThreadContextFlag;
              SystemHashNodeData = (void* *)(SystemThreadHandle4 + 4 + ResourceDataOffset1 * 0x14);
              ResourceHash = SystemHashNodeData[1];
              presourceAddress = (void* *)
                       ((long long)*(int *)(resourceDataIndex7 + 4 + SystemThreadHandle1) * 0x5c + 0x34 +
                       *(long long *)(SystemResourceManager + 0x68));
              *presourceAddress = *SystemHashNodeData;
              presourceAddress[1] = ResourceHash;
            }
            else {
              SystemHashNodeData = (void* *)
                       (*(long long *)(*(long long *)(SystemResourceManager + 0xb0) + 0x30 + SystemParameterPointer * 0x50) +
                       SystemBufferAddress0 * 0x10);
              *SystemHashNodeData = ResourceHash;
              SystemHashNodeData[1] = ThreadContextFlag;
            }
            SystemBufferAddress0 = (long long)*(int *)(resourceDataIndex7 + 8 + SystemThreadHandle1);
            SystemBufferAddress3 = SystemBufferAddress0 * 0x5c;
            resourceDataIndex2 = (long long)*(int *)(SystemBufferAddress3 + *(long long *)(SystemResourceManager + 0x68));
            SystemThreadHandle4 = 0;
            SystemThreadHandle2 = (long long)
                     (int)((*(long long *)(piStack_218 + resourceDataIndex2 * 8 + 2) -
                           *(long long *)(piStack_218 + resourceDataIndex2 * 8)) / 0x14);
            ResourceDataOffset1 = -1;
            if (0 < SystemThreadHandle2) {
              SystemHashNodeData2 = *(uint **)(piStack_218 + resourceDataIndex2 * 8);
              do {
                ResourceDataOffset1 = SystemThreadHandle4;
                if ((*SystemHashNodeData2 & SystemContextPointer) != 0) break;
                SystemThreadHandle4 = SystemThreadHandle4 + 1;
                SystemHashNodeData2 = SystemHashNodeData2 + 5;
                ResourceDataOffset1 = -1;
              } while (SystemThreadHandle4 < SystemThreadHandle2);
            }
            SystemThreadHandle4 = *(long long *)(piStack_218 + resourceDataIndex2 * 8);
            aresourceAddress7 = *(uint8_t (*) [16])(SystemThreadHandle4 + 4 + ResourceDataOffset1 * 0x14);
            if (SystemParameterPointer == -1) {
              *(uint8_t (*) [16])(SystemBufferAddress3 + 4 + *(long long *)(SystemResourceManager + 0x68)) = aresourceAddress7;
              SystemHashNodeData = (void* *)(SystemThreadHandle4 + 4 + ResourceDataOffset1 * 0x14);
              ResourceHash = SystemHashNodeData[1];
              presourceAddress = (void* *)
                       ((long long)*(int *)(resourceDataIndex7 + 8 + SystemThreadHandle1) * 0x5c + 0x34 +
                       *(long long *)(SystemResourceManager + 0x68));
              *presourceAddress = *SystemHashNodeData;
              presourceAddress[1] = ResourceHash;
            }
            else {
              *(uint8_t (*) [16])
               (*(long long *)(*(long long *)(SystemResourceManager + 0xb0) + 0x30 + SystemParameterPointer * 0x50) +
               SystemBufferAddress0 * 0x10) = aresourceAddress7;
            }
          }
          SystemThreadHandle3 = SystemThreadHandle3 + 1;
          resourceDataIndex7 = resourceDataIndex7 + 0xc;
        } while (SystemThreadHandle3 < (long long)resourceCreationFlags8);
        SystemThreadHandle1 = (long long)iStack_1e8;
      }
      ValidateThreadContext(&piStack_218);
      SystemParameterPointer = SystemParameterPointer + 1;
      if ((long long)SystemTimeFlag1d8 <= (long long)SystemParameterPointer) {
        InitializeResourceBuffer(aSystemResourceSize);
        if (ResourceBufferPointer130 != (uint32_t *)0x0) {
            SystemCleanupFunction(ResourceBufferPointer130);
        }
        return;
      }
    } while( true );
  }
  longValue1d0 = 0;
LAB_180079e40:
  paresourceAddress2 = (uint8_t (*) [16])(longValue1d0 * 0x20);
  pointerToInteger20 = *(int **)(*paresourceAddress2 + longValue170);
  resourceAddress1 = *(long long *)(*paresourceAddress2 + longValue170 + 8) - (long long)pointerToInteger20 >> 2;
  paGlobalDataFlags2 = paresourceAddress2;
  if (1 < resourceAddress1) {
    isResourceAvailable4 = true;
    SystemThreadStackSize = ResourceBufferPointer130[*pointerToInteger20];
    systemResult7 = 1;
    SystemContextPointer = SystemThreadStackSize;
    SystemIntegerPointer3 = pointerToInteger20;
    do {
      SystemIntegerPointer3 = SystemIntegerPointer3 + 1;
      if ((SystemContextPointer & ResourceBufferPointer130[*SystemIntegerPointer3]) == 0) {
        isResourceAvailable4 = false;
        break;
      }
      SystemContextPointer = SystemContextPointer | ResourceBufferPointer130[*SystemIntegerPointer3];
      systemResult7 = systemResult7 + 1;
    } while ((ulong long)(long long)systemResult7 < resourceAddress1);
    SystemContextPointer = (uint)SystemParameterPointer;
    if (!isResourceAvailable4) {
      CalculationFlags1A0 = (int *)0x0;
      SystemStackFlag = (int *)0x0;
      piStack_190 = (int *)0x0;
      ConcatenatedValue448 = 3;
      SystemIntegerPointer4 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,4,CONCAT71((uint7)(uint3)(SystemParameterPointer >> 8),3));
      *SystemIntegerPointer4 = *pointerToInteger20;
      pointerToInteger20 = SystemIntegerPointer4 + 1;
      piStack_218 = (int *)0x0;
      piStack_210 = (int *)0x0;
      SystemIntegerPointer3 = (int *)0x0;
      piStack_208 = (int *)0x0;
      StackValue200 = 3;
      LoopCounter = 1;
      piStack_1f8 = *(int **)(*paresourceAddress2 + longValue170);
      SystemIntegerPointer5 = pointerToInteger20;
      CalculationFlags1A0 = SystemIntegerPointer4;
      SystemStackFlag = pointerToInteger20;
      piStack_190 = pointerToInteger20;
      if (1 < (ulong long)(*(long long *)(*paresourceAddress2 + longValue170 + 8) - (long long)piStack_1f8 >> 2)) {
        SystemConfigurationPointer = 4;
        pointerToInteger25 = (int *)0x0;
        do {
          pointerToInteger26 = piStack_210;
          SystemIntegerPointer6 = (int *)0x0;
          if (piStack_210 < SystemIntegerPointer3) {
            *piStack_210 = *(int *)(SystemConfigurationPointer + (long long)piStack_1f8);
            SystemIntegerPointer6 = pointerToInteger25;
          }
          else {
            SystemTimeFlag1d8 = (long long)piStack_210 - (long long)pointerToInteger25;
            if ((long long)SystemTimeFlag1d8 >> 2 == 0) {
              piStack_1f0 = (int *)0x1;
LAB_180079fb3:
              SystemIntegerPointer6 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,(long long)piStack_1f0 * 4,
                                             CONCAT71((int7)(SystemConfigurationPointer >> 8),3));
            }
            else {
              piStack_1f0 = (int *)(((long long)SystemTimeFlag1d8 >> 2) * 2);
              if (piStack_1f0 != (int *)0x0) goto LAB_180079fb3;
            }
            if (pointerToInteger25 != pointerToInteger26) {
                memmove(SystemIntegerPointer6,pointerToInteger25,SystemTimeFlag1d8);
            }
            *SystemIntegerPointer6 = *(int *)(SystemConfigurationPointer + (long long)piStack_1f8);
            if (pointerToInteger25 != (int *)0x0) {
                SystemCleanupFunction(pointerToInteger25);
            }
            SystemIntegerPointer3 = SystemIntegerPointer6 + (long long)piStack_1f0;
            paresourceAddress2 = paGlobalDataFlags2;
            piStack_218 = SystemIntegerPointer6;
            piStack_208 = SystemIntegerPointer3;
            piStack_210 = SystemIntegerPointer6;
          }
          piStack_210 = piStack_210 + 1;
          LoopCounter = LoopCounter + 1;
          SystemConfigurationPointer = SystemConfigurationPointer + 4;
          piStack_1f8 = *(int **)(*paresourceAddress2 + longValue170);
          pointerToInteger25 = SystemIntegerPointer6;
        } while ((ulong long)(long long)LoopCounter <
                 (ulong long)(*(long long *)(*paresourceAddress2 + longValue170 + 8) - (long long)piStack_1f8 >> 2)
                );
      }
      do {
        SystemIntegerPointer3 = (int *)0x0;
        GlobalDataFlags = 0;
        uStack_1bc = 0;
        SystemOperationFlag1b8 = (int *)0x0;
        piStack_1b0 = (int *)0x0;
        uStack_1a8 = 3;
        isResourceAvailable4 = false;
        isSystemBusy = false;
        resourceAllocationContext3 = 0;
        ConcatenatedValue440 = (long long)piStack_210 - (long long)piStack_218 >> 2;
        pointerToInteger26 = (int *)0x0;
        pointerToInteger25 = (int *)0x0;
        SystemIntegerPointer6 = pointerToInteger25;
        pointerToInteger34 = SystemIntegerPointer3;
        SystemIntegerPointer0 = piStack_218;
        piStack_1f8 = piStack_210;
        if (ConcatenatedValue440 != 0) {
          do {
            piStack_1f0 = SystemIntegerPointer0;
            SystemIntegerPointer6 = (int *)0x0;
            systemResult7 = *piStack_1f0;
            if ((SystemThreadStackSize & ResourceBufferPointer130[systemResult7]) == 0) {
              if (pointerToInteger26 < SystemIntegerPointer3) {
                *pointerToInteger26 = systemResult7;
                SystemIntegerPointer6 = pointerToInteger25;
                resourceAllocationContext3 = (uint)pointerToInteger34;
              }
              else {
                SystemTimeFlag1d8 = (long long)pointerToInteger26 - (long long)pointerToInteger25;
                if ((long long)SystemTimeFlag1d8 >> 2 == 0) {
                  SystemThreadHandle1 = 1;
LAB_18007a203:
                  SystemIntegerPointer6 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadHandle1 * 4,3);
                }
                else {
                  SystemThreadHandle1 = ((long long)SystemTimeFlag1d8 >> 2) * 2;
                  if (SystemThreadHandle1 != 0) goto LAB_18007a203;
                }
                if (pointerToInteger25 != pointerToInteger26) {
                    memmove(SystemIntegerPointer6,pointerToInteger25,SystemTimeFlag1d8);
                }
                *SystemIntegerPointer6 = *piStack_1f0;
                if (pointerToInteger25 != (int *)0x0) {
                    SystemCleanupFunction(pointerToInteger25);
                }
                GlobalDataFlags = (uint)SystemIntegerPointer6;
                uStack_1bc = (uint32_t)((ulong long)SystemIntegerPointer6 >> 0x20);
                SystemIntegerPointer3 = SystemIntegerPointer6 + SystemThreadHandle1;
                piStack_1b0 = SystemIntegerPointer3;
                pointerToInteger26 = SystemIntegerPointer6;
              }
              pointerToInteger26 = pointerToInteger26 + 1;
              SystemOperationFlag1b8 = pointerToInteger26;
              isResourceAvailable4 = isSystemBusy;
            }
            else {
              SystemThreadStackSize = SystemThreadStackSize | ResourceBufferPointer130[systemResult7];
              if (pointerToInteger20 < SystemIntegerPointer5) {
                SystemStackFlag = pointerToInteger20 + 1;
                *pointerToInteger20 = systemResult7;
                pointerToInteger20 = SystemStackFlag;
                SystemIntegerPointer6 = pointerToInteger25;
                resourceAllocationContext3 = (uint)pointerToInteger34;
                isResourceAvailable4 = true;
              }
              else {
                SystemTimeFlag1d8 = (long long)pointerToInteger20 - (long long)SystemIntegerPointer4;
                if ((long long)SystemTimeFlag1d8 >> 2 == 0) {
                  SystemThreadHandle1 = 1;
LAB_18007a142:
                  SystemIntegerPointer5 = (int *)CreateSystemThreadObject(SystemMemoryPoolTemplate,SystemThreadHandle1 * 4,3);
                }
                else {
                  SystemThreadHandle1 = ((long long)SystemTimeFlag1d8 >> 2) * 2;
                  SystemIntegerPointer5 = SystemIntegerPointer6;
                  if (SystemThreadHandle1 != 0) goto LAB_18007a142;
                }
                if (SystemIntegerPointer4 != pointerToInteger20) {
                    memmove(SystemIntegerPointer5,SystemIntegerPointer4,SystemTimeFlag1d8);
                }
                *SystemIntegerPointer5 = *piStack_1f0;
                pointerToInteger20 = SystemIntegerPointer5 + 1;
                if (SystemIntegerPointer4 != (int *)0x0) {
                    SystemCleanupFunction(SystemIntegerPointer4);
                }
                piStack_190 = SystemIntegerPointer5 + SystemThreadHandle1;
                SystemIntegerPointer6 = pointerToInteger25;
                SystemIntegerPointer3 = piStack_1b0;
                SystemIntegerPointer4 = SystemIntegerPointer5;
                CalculationFlags1A0 = SystemIntegerPointer5;
                SystemStackFlag = pointerToInteger20;
                isResourceAvailable4 = true;
              }
            }
            resourceAllocationContext3 = resourceAllocationContext3 + 1;
            piStack_1f0 = piStack_1f0 + 1;
            pointerToInteger25 = SystemIntegerPointer6;
            pointerToInteger34 = (int *)(ulong long)resourceAllocationContext3;
            SystemIntegerPointer0 = piStack_1f0;
            SystemIntegerPointer5 = piStack_190;
            isSystemBusy = isResourceAvailable4;
          } while ((ulong long)(long long)(int)resourceAllocationContext3 < ConcatenatedValue440);
        }
        SystemResourceOffsetPointer9 = pSystemMemoryOffset168;
        GlobalDataFlags = (uint)piStack_218;
        uStack_1bc = (uint32_t)((ulong long)piStack_218 >> 0x20);
        SystemOperationFlag1b8._0_4_ = SUB84(piStack_1f8,0);
        SystemOperationFlag1b8._4_4_ = (uint32_t)((ulong long)piStack_1f8 >> 0x20);
        piStack_1b0 = piStack_208;
        StackValue200 = 3;
        uStack_1a8 = 3;
        piStack_210 = pointerToInteger26;
        piStack_208 = SystemIntegerPointer3;
        piStack_1f8 = pointerToInteger26;
        if ((((long long)pointerToInteger26 - (long long)SystemIntegerPointer6 & MAX_UNSIGNED_32_BITfffffffcU) == 0) || (!isResourceAvailable4))
        goto LAB_18007a312;
        isResourceAvailable4 = piStack_218 != (int *)0x0;
        piStack_218 = SystemIntegerPointer6;
        if (isResourceAvailable4) {
            SystemCleanupFunction();
        }
      } while( true );
    }
  }
  goto LAB_18007a58b;
LAB_18007a312:
  if (piStack_218 != (int *)0x0) {
    piStack_218 = SystemIntegerPointer6;
      SystemCleanupFunction();
  }
  SystemIntegerPointer3 = *(int **)(*paGlobalDataFlags2 + longValue170);
  piStack_218 = SystemIntegerPointer6;
  if (((*(long long *)(*paGlobalDataFlags2 + longValue170 + 8) - (long long)SystemIntegerPointer3 ^
       (long long)pointerToInteger20 - (long long)SystemIntegerPointer4) & MAX_UNSIGNED_32_BITfffffffcU) != 0) {
    *(int **)(*paGlobalDataFlags2 + longValue170) = SystemIntegerPointer4;
    SystemStackFlag = *(int **)(*paGlobalDataFlags2 + longValue170 + 8);
    *(int **)(*paGlobalDataFlags2 + longValue170 + 8) = pointerToInteger20;
    piStack_190 = *(int **)(paGlobalDataFlags2[1] + longValue170);
    *(int **)(paGlobalDataFlags2[1] + longValue170) = SystemIntegerPointer5;
    ConcatenatedValue448 = *(uint32_t *)(paGlobalDataFlags2[1] + longValue170 + 8);
    *(uint32_t *)(paGlobalDataFlags2[1] + longValue170 + 8) = 3;
    CalculationFlags1A0 = SystemIntegerPointer3;
    if (pSystemMemoryOffset168 < pSystemMemoryOffset160) {
      resourceAddress1 = (long long)pointerToInteger26 - (long long)SystemIntegerPointer6;
      *(uint32_t *)(pSystemMemoryOffset168 + 3) = 3;
      if (resourceAddress1 < 4) {
        SystemThreadHandle1 = 0;
        pSystemMemoryOffset168 = pSystemMemoryOffset168 + 4;
      }
      else {
        pSystemMemoryOffset168 = pSystemMemoryOffset168 + 4;
        SystemThreadHandle1 = CreateSystemThreadObject(SystemMemoryPoolTemplate,((long long)resourceAddress1 >> 2) * 4,3);
      }
      *SystemResourceOffsetPointer9 = SystemThreadHandle1;
      SystemResourceOffsetPointer9[1] = SystemThreadHandle1;
      SystemResourceOffsetPointer9[2] = SystemThreadHandle1 + ((long long)resourceAddress1 >> 2) * 4;
      if (SystemIntegerPointer6 != pointerToInteger26) {
          memmove(*SystemResourceOffsetPointer9,SystemIntegerPointer6,resourceAddress1);
      }
      SystemResourceOffsetPointer9[1] = *SystemResourceOffsetPointer9;
    }
    else {
      UpdateThreadContext(&longValue170,&piStack_218);
      pointerToInteger26 = piStack_210;
      SystemIntegerPointer6 = piStack_218;
    }
    SystemThreadHandle3 = longValue1d0;
    systemResult7 = *SystemIntegerPointer;
    ResourceDataOffset1 = longValue1d0 * 0x5c;
    SystemThreadHandle1 = *(long long *)(SystemResourceManager + 0x68);
    EncryptionOffset1 = *(void* *)(ResourceDataOffset1 + SystemThreadHandle1);
    EncryptionOffset2 = ((void* *)(ResourceDataOffset1 + SystemThreadHandle1))[1];
    SystemHashNodeData = (void* *)(ResourceDataOffset1 + 0x10 + SystemThreadHandle1);
    MemoryBufferAddress = *SystemHashNodeData;
    SystemResourceDataIndex = SystemHashNodeData[1];
    SystemHashNodeData = (void* *)(ResourceDataOffset1 + 0x20 + SystemThreadHandle1);
    SystemHashNodeData0 = *SystemHashNodeData;
    SystemHashNodeData0_1 = SystemHashNodeData[1];
    SystemHashNodeData = (void* *)(ResourceDataOffset1 + 0x30 + SystemThreadHandle1);
    SystemMemoryAllocatorStatus = *SystemHashNodeData;
    SystemHashNodeData1 = SystemHashNodeData[1];
    SystemHashNodeData = (void* *)(ResourceDataOffset1 + 0x40 + SystemThreadHandle1);
    SystemHashNodeData2 = *SystemHashNodeData;
    UnsignedStackFlagC0 = SystemHashNodeData[1];
    systemDataBuffer = *(void* *)(ResourceDataOffset1 + 0x50 + SystemThreadHandle1);
    UnsignedStackFlagB0 = *(uint32_t *)(ResourceDataOffset1 + 0x58 + SystemThreadHandle1);
    ProcessIntegerPointer(SystemIntegerPointer,&EncryptionOffset1);
    resourceAllocationContext8 = (long long)pointerToInteger26 - (long long)SystemIntegerPointer6 >> 2;
    resourceAllocationContext0 = 0;
    pointerToInteger20 = SystemIntegerPointer6;
    resourceAddress1 = resourceAllocationContext0;
    if (resourceAllocationContext8 != 0) {
      do {
        ResourceDataOffset1 = (long long)*pointerToInteger20;
        SystemThreadHandle1 = *(long long *)(SystemResourceManager + 0x90);
        if (*(uint *)(SystemThreadHandle1 + ResourceDataOffset1 * 0xc) == (uint)SystemParameterPointer) {
          *(int *)(SystemThreadHandle1 + ResourceDataOffset1 * 0xc) = systemResult7;
        }
        if (*(uint *)(SystemThreadHandle1 + 4 + ResourceDataOffset1 * 0xc) == (uint)SystemParameterPointer) {
          *(int *)(SystemThreadHandle1 + 4 + ResourceDataOffset1 * 0xc) = systemResult7;
        }
        if (*(uint *)(SystemThreadHandle1 + 8 + ResourceDataOffset1 * 0xc) == (uint)SystemParameterPointer) {
          *(int *)(SystemThreadHandle1 + 8 + ResourceDataOffset1 * 0xc) = systemResult7;
        }
        resourceAllocationContext3 = (int)resourceAddress1 + 1;
        pointerToInteger20 = pointerToInteger20 + 1;
        resourceAddress1 = (ulong long)resourceAllocationContext3;
      } while ((ulong long)(long long)(int)resourceAllocationContext3 < resourceAllocationContext8);
    }
    resourceAddress1 = resourceAllocationContext0;
    SystemIntegerPointer4 = SystemIntegerPointer3;
    if (*(short *)(SystemResourceManager + 0xc0) != 0) {
      do {
        SystemThreadHandle1 = resourceAllocationContext0 + *(long long *)(SystemResourceManager + 0xb0);
        ResourceDataOffset1 = *(long long *)(resourceAllocationContext0 + 0x30 + *(long long *)(SystemResourceManager + 0xb0));
        SystemHashNodeData = (void* *)(ResourceDataOffset1 + SystemThreadHandle3 * 0x10);
        ResourceHash = *SystemHashNodeData;
        ThreadContextFlag = SystemHashNodeData[1];
        systemResult7 = *(int *)(SystemThreadHandle1 + 0x2c);
        SystemOperationStatus1 = *(int *)(SystemThreadHandle1 + 0x28);
        if (systemResult7 <= SystemOperationStatus1) {
          if (systemResult7 < 2) {
            *(uint32_t *)(SystemThreadHandle1 + 0x2c) = 8;
          }
          else {
            *(int *)(SystemThreadHandle1 + 0x2c) = (systemResult7 >> 1) + systemResult7;
          }
          ProcessThreadHandleData(SystemThreadHandle1 + 0x28);
          SystemOperationStatus1 = *(int *)(SystemThreadHandle1 + 0x28);
          ResourceDataOffset1 = *(long long *)(SystemThreadHandle1 + 0x30);
        }
        SystemHashNodeData = (void* *)(ResourceDataOffset1 + (long long)SystemOperationStatus1 * 0x10);
        *SystemHashNodeData = ResourceHash;
        SystemHashNodeData[1] = ThreadContextFlag;
        *(int *)(SystemThreadHandle1 + 0x28) = *(int *)(SystemThreadHandle1 + 0x28) + 1;
        resourceAllocationContext3 = (int)resourceAddress1 + 1;
        resourceAllocationContext0 = resourceAllocationContext0 + 0x50;
        resourceAddress1 = (ulong long)resourceAllocationContext3;
      } while ((int)resourceAllocationContext3 < (int)(uint)*(ushort *)(SystemResourceManager + 0xc0));
    }
  }
  if (SystemIntegerPointer6 != (int *)0x0) {
      SystemCleanupFunction(SystemIntegerPointer6);
  }
  if (SystemIntegerPointer4 != (int *)0x0) {
      SystemCleanupFunction(SystemIntegerPointer4);
  }
LAB_18007a58b:
  SystemContextPointer = SystemContextPointer + 1;
  SystemParameterPointer = (ulong long)SystemContextPointer;
  longValue1d0 = longValue1d0 + 1;
  if (*SystemIntegerPointer <= (int)SystemContextPointer) goto LAB_18007a5ac;
  goto LAB_180079e40;
}




/**
 * @brief 配置系统资源表
 * 
 * 配置系统资源表的结构和参数，包括资源索引、数据指针和状态标志。
 * 该函数负责设置资源表的基本配置，为资源管理提供基础支持。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要配置的资源表
 * @return 无返回值
 */
void ConfigureSystemResourceTable(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  
  for (PrimaryResourcePointer = (long long *)*SystemResourceManager; PrimaryResourcePointer != (long long *)SystemResourceManager[1]; PrimaryResourcePointer = PrimaryResourcePointer + 4) {
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}




/**
 * @brief 验证系统资源表
 * 
 * 验证系统资源表的完整性和有效性，检查资源数据的正确性。
 * 该函数负责确保资源表的数据结构完整，为后续操作提供验证保障。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要验证的资源表
 * @return 无返回值
 */
void ValidateSystemResourceTable(long long* SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  
  for (PrimaryResourcePointer = (long long *)*SystemResourceManager; PrimaryResourcePointer != (long long *)SystemResourceManager[1]; PrimaryResourcePointer = PrimaryResourcePointer + 4) {
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
  }
  if (*SystemResourceManager == 0) {
    return;
  }
    SystemCleanupFunction();
}



uint8_t ValidateSystemResourceAccess(long long SystemResourceManager)

{
  char SystemNodeFlag;
  long long SystemThreadHandle;
  
  SystemThreadHandle = *(long long *)(SystemResourceManager + 0x1b8);
  charStatus = *(char *)(SystemThreadHandle + 0x38c);
  if (charStatus == '\t') {
    charStatus = func_0x00018022d300();
    *(char *)(SystemThreadHandle + 0x38c) = charStatus;
  }
  charStatus = ProcessCharacterStatus(SystemResourceManager,SystemResourceManager + 0x1e8,charStatus);
  if (initializationStatusFlag == '\0') {
    *(byte *)(SystemResourceManager + 0xfe) = *(byte *)(SystemResourceManager + 0xfe) & 0xfb;
    return 0;
  }
  return 1;
}



00018007b857)
00018007b868)
00018007b879)

ulong long ProcessSystemResourceConfiguration(long long SystemResourceManager,long long *ConfigurationDataPointer,byte AdditionalParameter,char ConfigurationFlag)

{
  byte *pisByteValid;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  int systemIndex;
  byte isMemoryReady;
  long long SystemThreadFlags;
  void** SystemCurrentNode;
  ulong long OperationCode;
  void* ThreadContextFlag;
  long long *PrimaryResourcePointer0;
  long long *PrimaryResourcePointer1;
  long long *PrimaryResourcePointer2;
  uint32_t SystemOperationStatus3;
  long long *PrimaryResourcePointer4;
  bool isByteValid5;
  long long *plStack_f0;
  long long *plStack_e8;
  long long *plStack_e0;
  long long *plStack_d8;
  long long *stackPointerD0;
  long long *plStack_c8;
  long long *plStack_c0;
  long long *plStack_b8;
  uint8_t aUnsignedStackFlagB0 [8];
  long long lStack_a8;
  uint32_t UnsignedStackFlagA0;
  long long *plStack_98;
  long long SystemConfigurationFlags;
  uint32_t UnsignedStackFlag88;
  long long *aSystemPoolPointer [2];
  code *SystemFunctionPointer68;
  void* *systemContextPointer;
  void* SystemProcessFlags58;
  long long *pLocalSystemValue1;
  long long *pSystemStatusFlag48;
  long long *plongValue40;
  
  SystemProcessFlags58 = 0xfffffffffffffffe;
  while ((SystemThreadFlags = SystemResourceManager, (*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0 &&
         (SystemThreadFlags = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0)), SystemThreadFlags != SystemResourceManager))) {
    if ((ConfigurationFlag != '\0') ||
       (pisByteValid = (byte *)(SystemResourceManager + 0x100), SystemResourceManager = SystemThreadFlags, (*pisByteValid & 8) != 0)) {
      ConfigurationFlag = '\x01';
      SystemResourceManager = SystemThreadFlags;
    }
  }
  if ((*(byte *)(SystemResourceManager + 0x100) & 8) != 0) {
    ConfigurationFlag = '\x01';
  }
  CleanupSystemResources(SystemResourceManager);
  PrimaryResourcePointer4 = (long long *)(*(long long *)(SystemThreadFlags + 0x1e0) + (ulong long)AdditionalParameter * 0x18);
  if ((long long *)*ConfigurationDataPointer != PrimaryResourcePointer4) {
    if ((long long *)*ConfigurationDataPointer != (long long *)0x0) {
      ConfigureSystemMemoryRegion();
    }
    *ConfigurationDataPointer = (long long)PrimaryResourcePointer4;
    if (PrimaryResourcePointer4 != (long long *)0x0) {
      LOCK();
      *(int *)(PrimaryResourcePointer4 + 2) = (int)PrimaryResourcePointer4[2] + 1;
      UNLOCK();
    }
    if (ConfigurationDataPointer[1] != 0) {
      pisByteValid = (byte *)(ConfigurationDataPointer[1] + 0xfe);
      *pisByteValid = *pisByteValid & 0xfb;
    }
  }
  LOCK();
  isByteValid5 = *(char*)((long long)PrimaryResourcePointer4 + 0x15) == '\0';
  if (isByteValid5) {
    *(char*)((long long)PrimaryResourcePointer4 + 0x15) = '\x01';
  }
  UNLOCK();
  if (!isByteValid5) goto LAB_18007b8fd;
  SystemThreadFlags = SystemResourceManager;
  if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
    SystemThreadFlags = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  if (*(int *)(SystemThreadFlags + 0x200) < 1) {
    LOCK();
    if (*(char*)((long long)PrimaryResourcePointer4 + 0x15) == '\x01') {
      *(char*)((long long)PrimaryResourcePointer4 + 0x15) = '\x03';
    }
    UNLOCK();
    goto LAB_18007b8fd;
  }
  if (*PrimaryResourcePointer4 == 0) {
    hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x28,8,0x20);
    *hashTableNode = &SystemMemoryTemplateA;
    *hashTableNode = &SystemMemoryTemplateB;
    *(uint32_t *)(hashTableNode + 1) = 0;
    *hashTableNode = &SystemHashBucketTableA;
    LOCK();
    *(uint8_t *)(hashTableNode + 2) = 0;
    UNLOCK();
    LOCK();
    *(uint32_t *)((long long)hashTableNode + 0x14) = 0;
    UNLOCK();
    hashTableNode[3] = 0;
    hashTableNode[4] = SystemResourceManager;
    SystemResourceManagerLink(PrimaryResourcePointer4);
  }
  if (PrimaryResourcePointer4[1] == 0) {
    hashTableNode = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,0x20);
    *hashTableNode = &SystemMemoryTemplateA;
    *hashTableNode = &SystemMemoryTemplateB;
    *(uint32_t *)(hashTableNode + 1) = 0;
    *hashTableNode = &SystemHashBucketTableB;
    LOCK();
    *(uint32_t *)(hashTableNode + 2) = 0;
    UNLOCK();
    hashTableNode[3] = 0;
    SystemResourceManagerLink(PrimaryResourcePointer4 + 1);
  }
  UnsignedStackFlag88 = 1;
  SystemConfigurationFlags = SystemResourceManager;
  InitializeSystemContext(&SystemConfigurationFlags);
  SystemThreadFlags = *(long long *)(SystemResourceManager + 0x210);
  if (SystemThreadFlags == 0) {
LAB_18007b44a:
    if (*(long long *)(SystemResourceManager + 0xa8) == 0) {
LAB_18007b454:
      LOCK();
      *(uint8_t *)((long long)PrimaryResourcePointer4 + 0x15) = 4;
      UNLOCK();
      OperationCode = ProcessSystemStatus(&SystemConfigurationFlags);
      return OperationCode & MAX_UNSIGNED_32_BITffffff00;
    }
  }
  else {
    if (*(int *)(SystemThreadFlags + 0x60) == 0) goto LAB_18007b454;
    if (SystemThreadFlags == 0) goto LAB_18007b44a;
  }
  ThreadContextFlag = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xa0,8,0x20);
  PrimaryResourcePointer0 = (long long *)GetThreadContextPointer(ThreadContextFlag);
  pLocalSystemValue1 = PrimaryResourcePointer0;
  if (PrimaryResourcePointer0 != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
  }
  SystemThreadFlags = SystemResourceManager;
  if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
    SystemThreadFlags = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  *(uint32_t *)(PrimaryResourcePointer0 + 2) = *(uint32_t *)(SystemThreadFlags + 0x200);
  *(byte *)(PrimaryResourcePointer0 + 0x13) =
       *(byte *)(PrimaryResourcePointer0 + 0x13) ^ (*(byte *)(SystemResourceManager + 0xfe) >> 1 ^ *(byte *)(PrimaryResourcePointer0 + 0x13)) & 1;
  *(byte *)((long long)PrimaryResourcePointer0 + 0x14) = AdditionalParameter;
  SystemOperationResult = *(char *)(SystemResourceManager + 0xfa);
  *(char*)((long long)PrimaryResourcePointer0 + 0x15) = SystemOperationResult;
  if (SystemOperationResult == '\x01') {
    ConfigurationFlag = '\x01';
  }
  PrimaryResourcePointer1 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x30,8,0x20);
  *PrimaryResourcePointer1 = (long long)&SystemMemoryTemplateA;
  *PrimaryResourcePointer1 = (long long)&SystemMemoryTemplateB;
  *(uint32_t *)(PrimaryResourcePointer1 + 1) = 0;
  *PrimaryResourcePointer1 = (long long)&SystemResourceDataTableF;
  PrimaryResourcePointer1[4] = 0;
  PrimaryResourcePointer1[2] = 0;
  *(byte *)(PrimaryResourcePointer1 + 5) = *(byte *)(PrimaryResourcePointer1 + 5) | 1;
  pSystemStatusFlag48 = PrimaryResourcePointer1;
  (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
  isMemoryReady = *(byte *)(SystemResourceManager + 0xfd) & 0x20;
  SystemThreadFlags = SystemResourceManager;
  if (isMemoryReady == 0) {
    SystemThreadFlags = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  systemCounter = *(int *)(SystemThreadFlags + 0x200);
  SystemThreadFlags = SystemResourceManager;
  if (isMemoryReady == 0) {
    SystemThreadFlags = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  systemIndex = *(int *)(SystemThreadFlags + 0x1fc);
  SystemOperationStatus3 = 2;
  if (0xffff < systemCounter) {
    SystemOperationStatus3 = 4;
  }
  *(byte *)(PrimaryResourcePointer1 + 5) =
       *(byte *)(PrimaryResourcePointer1 + 5) ^ (*(byte *)(SystemResourceManager + 0xfe) >> 1 ^ *(byte *)(PrimaryResourcePointer1 + 5)) & 1;
  *(uint32_t *)((long long)PrimaryResourcePointer1 + 0x14) = SystemOperationStatus3;
  *(int *)(PrimaryResourcePointer1 + 2) = systemIndex * 3;
  *(uint8_t *)(PrimaryResourcePointer1 + 3) = *(uint8_t *)(SystemResourceManager + 0xfa);
  if ((*(long long *)(SystemResourceManager + 0xa8) == 0) || (*(long long *)(SystemResourceManager + 0x210) != 0)) {
    if (ConfigurationFlag == '\0') {
      ThreadContextFlag = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xe0,8,3);
      (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
      (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
      SystemFunctionPointer68 = SystemMemoryAllocationCallback;
      pSystemThreadContext = &SystemValueTableA;
      SystemContextPointer = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag);
      *SystemContextPointer = SystemResourceManager;
      *(byte *)(SystemContextPointer + 1) = AdditionalParameter;
      SystemContextPointer[2] = (long long)SystemResourcePrimary;
      SystemContextPointer[3] = (long long)SystemResourceSecondary;
      SystemResourceArray[0] = SystemContextPointer;
      SystemResourceTertiary = (long long *)InitializeSystemResourceManager(ThreadContextFlag,SystemResourceArray);
      SystemResourceManagerPointer = SystemResourceTertiary;
      SystemResourceValue = SystemResourceTertiary;
      ThreadContextFlag = SystemAllocationFlagsTemplate;
      if (SystemResourceTertiary != (long long *)0x0) {
        (**(code **)(*SystemResourceTertiary + 0x28))(SystemResourceTertiary);
        ThreadContextFlag = SystemAllocationFlagsTemplate;
        (**(code **)(*SystemResourceTertiary + 0x28))(SystemResourceTertiary);
      }
      ProcessThreadContextData(ThreadContextFlag,&SystemResourceManagerPointer);
      if (SystemResourceTertiary != (long long *)0x0) {
        SystemThreadFlags = *SystemResourceTertiary;
SystemResourceCleanupPoint:
        (**(code **)(SystemThreadFlags + 0x38))(SystemResourceTertiary);
      }
    }
    else {
      plStack_e0 = PrimaryResourcePointer1;
      (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
      plStack_d8 = PrimaryResourcePointer0;
      (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
      ProcessResourceAllocation(SystemResourceManager,AdditionalParameter,&plStack_d8,&plStack_e0);
      plStack_d0 = PrimaryResourcePointer1;
      (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
      plStack_c8 = PrimaryResourcePointer0;
      (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
      ConfigureResourceAllocation(SystemResourceManager,AdditionalParameter,&plStack_c8,&plStack_d0);
      ProcessSystemStatus(&SystemConfigurationFlags);
      if (*(char *)(SystemResourceManager + 0xf4) == '\x01') {
        plStack_b8 = (long long *)0x0;
        plStack_98 = (long long *)0x0;
        aUnsignedStackFlagB0[0] = 0;
        UnsignedStackFlagA0 = 3;
        lStack_a8 = SystemResourceManager;
        InitializeSystemResourceEncryption(aUnsignedStackFlagB0);
        PrimaryResourcePointer2 = plStack_98;
        plStack_98 = (long long *)0x0;
        if (PrimaryResourcePointer2 != (long long *)0x0) {
          (**(code **)(*PrimaryResourcePointer2 + 0x38))();
        }
        CleanupSystemResourceEncryption(aUnsignedStackFlagB0);
        if (plStack_98 != (long long *)0x0) {
          SystemThreadFlags = *plStack_98;
          PrimaryResourcePointer2 = plStack_98;
          goto LAB_18007b8dc;
        }
      }
    }
  }
  else {
    plStack_f0 = PrimaryResourcePointer0;
    (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
    plStack_e8 = PrimaryResourcePointer1;
    (**(code **)(*PrimaryResourcePointer1 + 0x28))(PrimaryResourcePointer1);
    FinalizeResourceAllocation(SystemResourceManager,AdditionalParameter,&plStack_e8,&plStack_f0,ConfigurationFlag);
  }
  (**(code **)(*PrimaryResourcePointer1 + 0x38))(PrimaryResourcePointer1);
  (**(code **)(*PrimaryResourcePointer0 + 0x38))(PrimaryResourcePointer0);
  ProcessSystemStatus(&SystemConfigurationFlags);
LAB_18007b8fd:
  return (ulong long)((byte)(*(char*)((long long)PrimaryResourcePointer4 + 0x15) - 2U) < 2);
}




/**
 * @brief 处理系统资源分配
 * 
 * 处理系统资源的分配操作，包括内存分配、资源初始化和状态设置。
 * 该函数负责管理资源的分配流程，确保资源正确分配和初始化。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要分配的资源
 * @return 无返回值
 */
void ProcessSystemResourceAllocation(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  long long *resourcePoolPointer;
  long long *PrimaryResourcePointer;
  long long *SecondaryResourcePointer;
  long long **ResourceReferencePointer;
  long long **ppStackValue1;
  void* resourceAllocationContext;
  uint8_t StackBuffer40 [8];
  long long longValue38;
  uint32_t SystemResourceStatusFlag;
  long long *pLocalMemoryAddress;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  resourceDataIndex = *SystemResourceManager;
  ResourceReferencePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = (long long *)SystemResourceManager[3];
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  ppStackValue1 = &SecondaryResourcePointer;
  SecondaryResourcePointer = (long long *)SystemResourceManager[2];
  if (SecondaryResourcePointer != (long long *)0x0) {
    (**(code **)(*SecondaryResourcePointer + 0x28))();
  }
  ProcessResourceAllocation(resourceDataIndex,(char)SystemResourceManager[1],&SecondaryResourcePointer,&PrimaryResourcePointer,resourceAllocationContext);
  resourceDataIndex = *SystemResourceManager;
  ResourceReferencePointer = &PrimaryResourcePointer;
  PrimaryResourcePointer = (long long *)SystemResourceManager[3];
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  ppStackValue1 = &SecondaryResourcePointer;
  SecondaryResourcePointer = (long long *)SystemResourceManager[2];
  if (SecondaryResourcePointer != (long long *)0x0) {
    (**(code **)(*SecondaryResourcePointer + 0x28))();
  }
  ConfigureResourceAllocation(resourceDataIndex,(char)SystemResourceManager[1],&SecondaryResourcePointer,&PrimaryResourcePointer);
  longValue38 = *SystemResourceManager;
  if (*(char *)(longValue38 + 0xf4) == '\x01') {
    PrimaryResourcePointer = (long long *)0x0;
    pLocalMemoryAddress = (long long *)0x0;
    StackBuffer40[0] = 0;
    SystemResourceStatusFlag = 3;
    InitializeSystemResourceEncryption(StackBuffer40);
    resourcePoolPointer = pLocalMemoryAddress;
    SecondaryResourcePointer = pLocalMemoryAddress;
    pLocalMemoryAddress = (long long *)0x0;
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x38))();
    }
    CleanupSystemResourceEncryption(StackBuffer40);
    if (pLocalMemoryAddress != (long long *)0x0) {
      (**(code **)(*pLocalMemoryAddress + 0x38))();
    }
  }
  return;
}




/**
 * @brief 释放系统资源句柄
 * 
 * 释放系统资源的句柄，清理相关资源并更新状态。
 * 该函数负责安全地释放资源句柄，防止资源泄漏。
 * 
 * @param SystemResourceManager 资源管理器指针，包含要释放的资源句柄
 * @return 无返回值
 */
void ReleaseSystemResourceHandle(long long SystemResourceManager)

{
  if (*(long long **)(SystemResourceManager + 0x18) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemResourceManager + 0x18) + 0x38))();
  }
  if (*(long long **)(SystemResourceManager + 0x10) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemResourceManager + 0x10) + 0x38))();
  }
  return;
}





/**
 * @brief 初始化系统内存操作状态
 * 
 * 该函数负责初始化系统内存操作状态，为系统内存管理做准备。
 * 如果系统资源管理器的内存操作状态为空，则分配新的内存并初始化。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含系统资源管理信息
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007baa0
 */
void InitializeSystemMemoryOperationStatus(long long SystemResourceManager)

{
  void* SystemOperationStatus;
  
  if (*(long long *)(SystemResourceManager + 0x1e0) == 0) {
    SystemOperationStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x180,8,0x1c);
      memset(SystemOperationStatus,0,0x180);
  }
  return;
}




/**
 * @brief 执行系统资源管理器回调函数
 * 
 * 该函数负责执行系统资源管理器的回调函数，包括主回调函数和参数回调函数。
 * 如果系统资源管理器或回调参数有效，则调用相应的回调函数。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含回调函数信息
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007bb70
 */
void ExecuteSystemResourceManagerCallbacks(long long* SystemResourceManager)

{
  if ((long long *)SystemResourceManager[1] != (long long *)0x0) {
    (**(code **)(*(long long *)SystemResourceManager[1] + 0x38))();
  }
  if ((long long *)*callbackParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*callbackParameter + 0x38))();
  }
  return;
}



00018007c17d)
00018007c188)


/**
 * @brief 游戏对象变换数据复制函数
 * 
 * 该函数负责在游戏对象之间复制变换相关的数据，包括位置、旋转、缩放等
 * 变换矩阵数据。它会比较源对象和目标对象的变换数据，并在需要时进行
 * 数据同步和更新。
 * 
 * @param targetObjectPointer 目标对象指针
 * @param sourceObjectPointer 源对象指针（可为空）
 * @param transformDataSource 变换数据源对象
 */
void CopyGameObjectTransformData(long long targetObjectPointer,long long sourceObjectPointer,long long transformDataSource)

{
  int TransformCompareResult;
  uint32_t SourceFlags;
  uint32_t TargetFlags;
  uint32_t TransformFlags;
  void* TransformDataPointer;
  long long *ObjectMatrixPointer;
  long long TransformOffset;
  long long *SourceMatrixPointer;
  void* *TargetObjectPointer;
  uint *ObjectFlagsPointer;
  uint BitPosition;
  void* *SourceObjectPointer;
  uint SourceObjectFlags;
  uint TargetObjectFlags;
  ulong long StackGuardValue;
  uint BitMask;
  uint CurrentBit;
  uint8_t StackBuffer [32];
  void* StackParameter;
  long long *MatrixStackPointer;
  void* ObjectPointer;
  long long *OffsetPointer;
  long long AlignmentValue;
  ulong long ChecksumValue;
  
  StackParameter = 0xfffffffffffffffe;
  ChecksumValue = SystemSecurityKey ^ (ulong long)StackBuffer;
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(SystemResourceManager + 0x238) == *(float *)(ConfigurationDataPointer + 0x44) &&
       (*(float *)(SystemResourceManager + 0x23c) == *(float *)(ConfigurationDataPointer + 0x48))) &&
      (*(float *)(SystemResourceManager + 0x240) == *(float *)(ConfigurationDataPointer + 0x4c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x4c);
    *(void* *)(SystemResourceManager + 0x238) = *(void* *)(AdditionalParameter + 0x44);
    *(void* *)(SystemResourceManager + 0x240) = currentThreadId;
  }
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(SystemResourceManager + 0x248) == *(float *)(ConfigurationDataPointer + 0x54) &&
       (*(float *)(SystemResourceManager + 0x24c) == *(float *)(ConfigurationDataPointer + 0x58))) &&
      (*(float *)(SystemResourceManager + 0x250) == *(float *)(ConfigurationDataPointer + 0x5c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x5c);
    *(void* *)(SystemResourceManager + 0x248) = *(void* *)(AdditionalParameter + 0x54);
    *(void* *)(SystemResourceManager + 0x250) = currentThreadId;
  }
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(SystemResourceManager + 0x2a8) == *(float *)(ConfigurationDataPointer + 100) &&
       (*(float *)(SystemResourceManager + 0x2ac) == *(float *)(ConfigurationDataPointer + 0x68))) &&
      (*(float *)(SystemResourceManager + 0x2b0) == *(float *)(ConfigurationDataPointer + 0x6c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x6c);
    *(void* *)(SystemResourceManager + 0x2a8) = *(void* *)(AdditionalParameter + 100);
    *(void* *)(SystemResourceManager + 0x2b0) = currentThreadId;
  }
  if ((ConfigurationDataPointer == 0) ||
     (((*(float *)(SystemResourceManager + 0x2b8) == *(float *)(ConfigurationDataPointer + 0x74) &&
       (*(float *)(SystemResourceManager + 700) == *(float *)(ConfigurationDataPointer + 0x78))) &&
      (*(float *)(SystemResourceManager + 0x2c0) == *(float *)(ConfigurationDataPointer + 0x7c))))) {
    currentThreadId = *(void* *)(AdditionalParameter + 0x7c);
    *(void* *)(SystemResourceManager + 0x2b8) = *(void* *)(AdditionalParameter + 0x74);
    *(void* *)(SystemResourceManager + 0x2c0) = currentThreadId;
  }
  if (sourceString == 0) {
    *(uint32_t *)(SystemResourceManager + 0x100) = *(uint32_t *)(AdditionalParameter + 0x30);
  }
  else {
    SystemOperationStatus7 = 1;
    SystemOperationStatus1 = 2;
    do {
      SystemDataPointer0 = (uint *)(SystemResourceManager + 0x100);
      SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
      SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      if ((SystemOperationStatus7 & SystemOperationStatusFlags) != (SystemOperationStatus7 & SystemOperationStatus4)) {
        if ((SystemOperationStatus7 & SystemOperationStatus4) == 0) {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) & ~(1 << (SystemOperationStatus1 - 2 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *SystemDataPointer0 | 1 << (SystemOperationStatus1 - 2 & BIT_MASK_32_BIT);
        }
        *SystemDataPointer0 = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 1 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 1 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 - 1 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 - 1 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 2 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 2 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 3 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 3 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 1 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 1 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 4 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 4 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 2 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 2 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 5 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 5 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          *SystemDataPointer0 = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 3 & BIT_MASK_32_BIT));
          SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
          SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
        }
        else {
          *(uint *)(SystemResourceManager + 0x100) = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 3 & BIT_MASK_32_BIT);
          SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
          SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
        }
      }
      SystemDataPointer0 = (uint *)(SystemResourceManager + 0x100);
      SystemOperationStatus3 = SystemOperationStatus7 << 6 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 6 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 4 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 4 & BIT_MASK_32_BIT);
        }
        *SystemDataPointer0 = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 7 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 7 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 5 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 5 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 8 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 8 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 6 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 6 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 9 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 9 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 7 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 7 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus3 = SystemOperationStatus7 << 10 & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 10 & SystemOperationStatusFlags) != SystemOperationStatus3) {
        if (SystemOperationStatus3 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 8 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 8 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
        SystemOperationStatusFlags = *(uint *)(ConfigurationDataPointer + 0x30);
        SystemOperationStatus4 = *(uint *)(AdditionalParameter + 0x30);
      }
      SystemOperationStatus4 = SystemOperationStatus7 << 0xb & SystemOperationStatus4;
      if ((SystemOperationStatus7 << 0xb & SystemOperationStatusFlags) != SystemOperationStatus4) {
        if (SystemOperationStatus4 == 0) {
          SystemOperationStatusFlags = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 9 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 9 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
      }
      SystemOperationStatusFlags = SystemOperationStatus7 << 0xc & *(uint *)(AdditionalParameter + 0x30);
      if ((SystemOperationStatus7 << 0xc & *(uint *)(ConfigurationDataPointer + 0x30)) != SystemOperationStatusFlags) {
        if (SystemOperationStatusFlags == 0) {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) & ~(1 << (SystemOperationStatus1 + 10 & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 10 & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
      }
      SystemOperationStatusFlags = SystemOperationStatus7 << 0xd & *(uint *)(AdditionalParameter + 0x30);
      if ((SystemOperationStatus7 << 0xd & *(uint *)(ConfigurationDataPointer + 0x30)) != SystemOperationStatusFlags) {
        if (SystemOperationStatusFlags == 0) {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) & ~(1 << (SystemOperationStatus1 + 0xb & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 0xb & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
      }
      SystemOperationStatusFlags = SystemOperationStatus7 << 0xe & *(uint *)(AdditionalParameter + 0x30);
      if ((SystemOperationStatus7 << 0xe & *(uint *)(ConfigurationDataPointer + 0x30)) != SystemOperationStatusFlags) {
        SystemDataPointer0 = (uint *)(SystemResourceManager + 0x100);
        if (SystemOperationStatusFlags == 0) {
          *SystemDataPointer0 = *SystemDataPointer0 & ~(1 << (SystemOperationStatus1 + 0xc & BIT_MASK_32_BIT));
        }
        else {
          *SystemDataPointer0 = *SystemDataPointer0 | 1 << (SystemOperationStatus1 + 0xc & BIT_MASK_32_BIT);
        }
      }
      SystemOperationStatusFlags = SystemOperationStatus7 << 0xf & *(uint *)(AdditionalParameter + 0x30);
      if ((SystemOperationStatus7 << 0xf & *(uint *)(ConfigurationDataPointer + 0x30)) != SystemOperationStatusFlags) {
        if (SystemOperationStatusFlags == 0) {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) & ~(1 << (SystemOperationStatus1 + 0xd & BIT_MASK_32_BIT));
        }
        else {
          SystemOperationStatusFlags = *(uint *)(SystemResourceManager + 0x100) | 1 << (SystemOperationStatus1 + 0xd & BIT_MASK_32_BIT);
        }
        *(uint *)(SystemResourceManager + 0x100) = SystemOperationStatusFlags;
      }
      SystemOperationStatus7 = SystemOperationStatus7 << 0x10 | SystemOperationStatus7 >> 0x10;
      SystemOperationStatus = SystemOperationStatus1 + 0xe;
      SystemOperationStatus1 = SystemOperationStatus1 + 0x10;
    } while (SystemOperationStatus < 0x20);
  }
  *(uint32_t *)(SystemResourceManager + 0x208) = *(uint32_t *)(AdditionalParameter + 0x84);
  *(uint32_t *)(SystemResourceManager + 0x1f8) = *(uint32_t *)(AdditionalParameter + 0x88);
  *(uint32_t *)(SystemResourceManager + 0x1fc) = *(uint32_t *)(AdditionalParameter + 0x8c);
  *(uint32_t *)(SystemResourceManager + 0x200) = *(uint32_t *)(AdditionalParameter + 0x90);
  *(uint32_t *)(SystemResourceManager + 0x204) = *(uint32_t *)(AdditionalParameter + 0x94);
  currentThreadId = *(void* *)(AdditionalParameter + 0xa0);
  *(void* *)(SystemResourceManager + 0x274) = *(void* *)(AdditionalParameter + 0x98);
  *(void* *)(SystemResourceManager + 0x27c) = currentThreadId;
  currentThreadId = *(void* *)(AdditionalParameter + 0xb0);
  *(void* *)(SystemResourceManager + 0x284) = *(void* *)(AdditionalParameter + 0xa8);
  *(void* *)(SystemResourceManager + 0x28c) = currentThreadId;
  resourceCreationFlags = *(uint32_t *)(AdditionalParameter + 0xbc);
  resourceAllocationContext = *(uint32_t *)(AdditionalParameter + 0xc0);
  resourceAddress = *(uint32_t *)(AdditionalParameter + 0xc4);
  *(uint32_t *)(SystemResourceManager + 0x294) = *(uint32_t *)(AdditionalParameter + 0xb8);
  *(uint32_t *)(SystemResourceManager + 0x298) = resourceCreationFlags;
  *(uint32_t *)(SystemResourceManager + 0x29c) = resourceAllocationContext;
  *(uint32_t *)(SystemResourceManager + 0x2a0) = resourceAddress;
  *(uint32_t *)(SystemResourceManager + 0x2a4) = *(uint32_t *)(AdditionalParameter + 200);
  pLocalSystemValue = (long long *)0x0;
  LocalMemoryAddress = 0;
  if (ConfigurationDataPointer != 0) {
    pSystemThreadFlags = (long long *)(ConfigurationDataPointer + 0x158);
    if ((*pSystemThreadFlags == 0) && (*(long long *)(ConfigurationDataPointer + 0x160) == 0)) {
      pSystemThreadFlags = (long long *)(ConfigurationDataPointer + 0x34);
    }
    pLocalSystemValue = (long long *)*pSystemThreadFlags;
    LocalMemoryAddress = pSystemThreadFlags[1];
  }
  SystemContextValue = 0;
  pSystemThreadFlags = (long long *)(SystemResourceManager + 0x1b8);
  plongValue40 = (long long *)*pSystemThreadFlags;
  *pSystemThreadFlags = 0;
  if (plongValue40 != (long long *)0x0) {
    (**(code **)(*plongValue40 + 0x38))();
  }
  pSystemMemoryAddress = (long long *)(AdditionalParameter + 0x158);
  if ((*pSystemMemoryAddress == 0) && (*(long long *)(AdditionalParameter + 0x160) == 0)) {
    pSystemMemoryAddress = (long long *)(AdditionalParameter + 0x34);
  }
  localDataIndex = ProcessSystemDataRequest(*(void* *)(SystemResourceManager + 0xa8),&SystemRequestTemplate,pSystemMemoryAddress);
  if (localDataIndex != 0) {
    ProcessResourceIndex(pSystemThreadFlags,localDataIndex + 0xb0);
  }
  if (*pSystemThreadFlags == 0) {
    pSystemSecondaryStatus = &SystemStringTemplate;
    if (*(void* **)(SystemResourceManager + 0x18) != (void* *)0x0) {
      pSystemSecondaryStatus = *(void* **)(SystemResourceManager + 0x18);
    }
    ProcessSystemStatusBuffer(&SystemStatusBufferTemplateA,pSystemSecondaryStatus);
    pSystemMemoryAddress = (long long *)AllocateSystemMemoryContext(SystemDataSystemMemoryContextPointer,&pLocalSystemValue,0);
    localDataIndex = *pSystemMemoryAddress;
    *pSystemMemoryAddress = 0;
    plongValue40 = (long long *)*pSystemThreadFlags;
    *pSystemThreadFlags = localDataIndex;
    if (plongValue40 != (long long *)0x0) {
      (**(code **)(*plongValue40 + 0x38))();
    }
    if (pLocalSystemValue != (long long *)0x0) {
      (**(code **)(*pLocalSystemValue + 0x38))();
    }
  }
  ProcessSystemResourceManager(SystemResourceManager);
  if ((*(long long *)(SystemResourceManager + 600) == 0) &&
     ((*(uint *)(*(long long *)(SystemResourceManager + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    SystemOperationCounterPointer = (void* *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x58,8,0x1c);
    *(void* *)((long long)SystemOperationCounterPointer + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(SystemOperationCounterPointer + 9) = 0xffffffff;
    *SystemOperationCounterPointer = 0;
    SystemOperationCounterPointer[2] = 0;
    SystemOperationCounterPointer[7] = 0;
    *(uint32_t *)(SystemOperationCounterPointer + 5) = 0xffffffff;
    *(uint32_t *)(SystemOperationCounterPointer + 4) = 0xffffffff;
    SystemOperationCounterPointer[3] = 0;
    *(uint32_t *)(SystemOperationCounterPointer + 8) = 0;
    *(uint32_t *)(SystemOperationCounterPointer + 1) = 0;
    *(uint8_t *)((long long)SystemOperationCounterPointer + 0x44) = 0;
    *(uint8_t *)((long long)SystemOperationCounterPointer + 0x24) = 0;
    *(void* **)(SystemResourceManager + 600) = SystemOperationCounterPointer;
  }
  *(uint8_t *)(SystemResourceManager + 0xf6) = *(uint8_t *)(AdditionalParameter + 0xcc);
  if ((void* *)(SystemResourceManager + TRANSFORM_CONTEXT_OFFSET_218) != (void* *)(AdditionalParameter + 0xd0)) {
    ProcessTransformContext((void* *)(SystemResourceManager + TRANSFORM_CONTEXT_OFFSET_218),*(void* *)(AdditionalParameter + 0xd0),
                  *(void* *)(AdditionalParameter + 0xd8));
  }
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x10) = *(uint32_t *)(AdditionalParameter + 0xf0);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x14) = *(uint32_t *)(AdditionalParameter + 0x144);
  *(uint8_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x18) = *(uint8_t *)(AdditionalParameter + 0x148);
  *(uint8_t *)(*(long long *)(SystemResourceManager + 0x268) + SYSTEM_NODE_ACTIVE_FLAG_OFFSET) = *(uint8_t *)(AdditionalParameter + 0x149);
  *(uint8_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x1a) = *(uint8_t *)(AdditionalParameter + 0x14a);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x44) = *(uint32_t *)(AdditionalParameter + 0x118);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x48) = *(uint32_t *)(AdditionalParameter + 0x11c);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x4c) = *(uint32_t *)(AdditionalParameter + 0x120);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x50) = *(uint32_t *)(AdditionalParameter + 0x124);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x54) = *(uint32_t *)(AdditionalParameter + 0x128);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x58) = *(uint32_t *)(AdditionalParameter + 300);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x5c) = *(uint32_t *)(AdditionalParameter + 0x130);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x60) = *(uint32_t *)(AdditionalParameter + 0x134);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 100) = *(uint32_t *)(AdditionalParameter + 0x138);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x68) = *(uint32_t *)(AdditionalParameter + 0x13c);
  *(uint32_t *)(*(long long *)(SystemResourceManager + 0x268) + 0x6c) = *(uint32_t *)(AdditionalParameter + 0x140);
  localDataIndex = *(long long *)(SystemResourceManager + 0x268);
  SystemOperationStatus1 = *(uint *)(AdditionalParameter + 0x108);
  SystemOperationStatus5 = (ulong long)SystemOperationStatus1;
  if (*(long long *)(AdditionalParameter + 0x100) != 0) {
    ExecuteSystemCommand(localDataIndex + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,SystemOperationStatus5);
  }
  if (SystemOperationStatus1 != 0) {
      memcpy(*(void* *)(localDataIndex + 0x28),*(void* *)(AdditionalParameter + 0x100),SystemOperationStatus5);
  }
  *(uint32_t *)(localDataIndex + 0x30) = 0;
  if (*(long long *)(localDataIndex + 0x28) != 0) {
    *(uint8_t *)(SystemOperationStatus5 + *(long long *)(localDataIndex + 0x28)) = 0;
  }
  *(uint32_t *)(localDataIndex + 0x3c) = *(uint32_t *)(AdditionalParameter + 0x114);
    ValidateSystemChecksum(SystemMaxOperationCount ^ (ulong long)aEncryptionValue68);
}




/**
 * @brief 系统初始化参数配置函数
 * 
 * 该函数负责配置系统初始化参数，设置初始化标志和配置选项
 * 用于系统初始化过程的参数配置和验证
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志指针
 * @param InitializationFlag 初始化标志
 * 
 *FUN_18007c490：ConfigureSystemInitializationParameters
 */
void ConfigureSystemInitializationParameters(long long* SystemResourceManager,byte ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag,char InitializationFlag)

{
  char *SystemCharacterPointer;
  long long *resourcePoolPointer;
  long long *LocalResourceOffset;
  long long* SystemMemoryPointer;
  code *SystemCodePointer;
  char SystemCharacterFlag;
  void* *hashTableNode;
  uint32_t SystemStatusFlag1;
  uint32_t SystemStatusFlag2;
  uint32_t SystemStatusFlag3;
  uint32_t SystemStatusFlag4;
  code *SystemFunctionPointer1;
  void* *SystemNodePointer;
  void* SystemResourceManager1;
  uint32_t SystemConfigurationFlag1;
  uint32_t SystemConfigurationFlag2;
  long long *SystemDataPointer1;
  byte SystemDataByte1;
  long long *SystemDataPointer2;
  long long *SystemDataConfigurationPointer;
  long long *SystemThreadLocalStoragePointer;
  byte SystemDataByte2;
  long long *SystemDataPointer5;
  long long *SystemResourceStringPointer;
  void* SystemStackParameter;
  long long **SystemDoublePointer;
  uint8_t SystemBuffer1 [16];
  code *SystemFunctionPointer2;
  uint8_t SystemBuffer2 [16];
  code *SystemFunctionPointer3;
  
  SystemStackParameter = 0xfffffffffffffffe;
  resourcePoolPointer = (long long *)*ConfigurationFlag;
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
  }
  LocalResourceOffset = (long long *)*AdditionalParameter;
  if (LocalResourceOffset != (long long *)0x0) {
    (**(code **)(*LocalResourceOffset + 0x28))(LocalResourceOffset);
  }
  SystemConfigurationFlag1 = CONCAT31(SystemConfigurationFlag1._1_3_,ConfigurationDataPointer);
  SystemResourceManager1 = SystemResourceManager;
  if ((void* *)*SystemResourceManager == &SystemResourceDataTableC) {
    LOCK();
    *(int *)(SystemResourceManager + 1) = (int)SystemResourceManager[1] + 1;
    UNLOCK();
  }
  else {
    (**(code **)((void* *)*SystemResourceManager + 0x28))(SystemResourceManager);
  }
  if (InitializationFlag == '\0') {
    LocalBufferAddress = *(long long **)(SystemResourceManager[0x15] + 0x88);
    SystemCodePointer = *(code **)(*LocalBufferAddress + 0x70);
    SystemFunctionPointer1 = (code *)&SystemCodeEntryPointC;
    SystemNodePointer = &SystemNodeTableA;
    SystemStatusFlag1 = (uint32_t)SystemResourceManager1;
    SystemStatusFlag2 = SystemResourceManager1._4_4_;
    SystemStatusFlag3 = SystemConfigurationFlag1;
    SystemStatusFlag4 = SystemConfigurationFlag2;
    SystemThreadLocalStoragePointer = SystemResourceManager;
    SystemDataByte2 = ConfigurationDataPointer;
    SystemDataPointer5 = resourcePoolPointer;
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
    }
    SystemResourceStringPointer = LocalResourceOffset;
    if (LocalResourceOffset != (long long *)0x0) {
      (**(code **)(*LocalResourceOffset + 0x28))(LocalResourceOffset);
    }
    InitializeSystemBuffer(SystemBuffer2,&SystemThreadLocalStoragePointer);
    (*SystemCodePointer)(LocalBufferAddress,&SystemInitializationData,SystemResourceManager + 0x17,0,SystemBuffer2,&SystemStatusFlag1);
    if (SystemFunctionPointer3 != (code *)0x0) {
      (*SystemFunctionPointer3)(SystemBuffer2,0,0);
    }
    if (SystemFunctionPointer1 != (code *)0x0) {
      (*SystemFunctionPointer1)(&SystemStatusFlag1,0,0);
    }
  }
  else {
    LocalBufferAddress = *(long long **)(SystemResourceManager[0x15] + 0x88);
    SystemCodePointer = *(code **)(*LocalBufferAddress + 0x60);
    SystemDoublePointer = &SystemDataPointer1;
    SystemDataPointer1 = SystemResourceManager;
    SystemDataByte1 = ConfigurationDataPointer;
    SystemDataPointer2 = resourcePoolPointer;
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
    }
    SystemDataConfigurationPointer = LocalResourceOffset;
    if (LocalResourceOffset != (long long *)0x0) {
      (**(code **)(*LocalResourceOffset + 0x28))(LocalResourceOffset);
    }
    InitializeSystemBuffer(SystemBuffer1,&SystemDataPointer1);
    SystemCharacterFlag = (*SystemCodePointer)(LocalBufferAddress,&SystemInitializationData,SystemResourceManager + 0x17,0,SystemBuffer1);
    if (SystemFunctionPointer2 != (code *)0x0) {
      (*SystemFunctionPointer2)(SystemBuffer1,0,0);
    }
    if (SystemCharacterFlag == '\0') {
      hashTableNode = &SystemStringTemplate;
      if ((void* *)SystemResourceManager[3] != (void* *)0x0) {
        hashTableNode = (void* *)SystemResourceManager[3];
      }
      AllocateSystemMemory(&SystemHashBuffer,hashTableNode);
      systemFunctionPointer = (char *)(SystemResourceManager[0x3c] + 0x15 + (ulong long)ConfigurationDataPointer * 0x18);
      LOCK();
      if (*systemFunctionPointer == '\x01') {
        *systemFunctionPointer = '\x04';
      }
      UNLOCK();
      (**(code **)(*SystemResourceManager + 0x38))(SystemResourceManager);
    }
  }
  if (SystemResourceOffsetPointer != (long long *)0x0) {
    (**(code **)(*SystemResourceOffsetPointer + 0x38))(SystemResourceOffsetPointer);
  }
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))(resourcePoolPointer);
  }
  if ((long long *)*AdditionalParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*AdditionalParameter + 0x38))();
  }
  if ((long long *)*ConfigurationFlag != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationFlag + 0x38))();
  }
  return;
}




/**
 * @brief 配置系统哈希表和内存分配
 * 
 * 该函数负责配置系统哈希表和内存分配，包括哈希表条目的设置和内存分配。
 * 如果系统资源管理器包含有效的哈希表条目，则使用该条目，否则使用系统字符串模板。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含哈希表和内存分配信息
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007c790
 */
void ConfigureSystemHashTableAndMemoryAllocation(long long* SystemResourceManager)

{
  char *systemFunctionPointer;
  void** SystemHashEntryPointer;
  
  SystemHashEntryPointer = &SystemStringTemplate;
  if (*(void* **)(*SystemResourceManager + 0x18) != (void* *)0x0) {
    SystemHashEntryPointer = *(void* **)(*SystemResourceManager + 0x18);
  }
  AllocateSystemMemory(&SystemHashBuffer,SystemHashEntryPointer);
  systemFunctionPointer = (char *)(*(long long *)(*SystemResourceManager + 0x1e0) + 0x15 +
                   (ulong long)*(byte *)(SystemResourceManager + 1) * 0x18);
  LOCK();
  if (*systemFunctionPointer == '\x01') {
    *systemFunctionPointer = '\x04';
  }
  UNLOCK();
                    00018007c7e6. Too many branches
                      (**(code **)(*(long long *)*SystemResourceManager + 0x38))();
  return;
}



/**
 * @brief 初始化系统资源管理器配置
 * 
 * 该函数负责初始化系统资源管理器配置，包括主要资源指针的设置和回调函数的调用。
 * 从配置数据指针复制配置信息到系统资源管理器，并初始化主要资源指针。
 * 
 * @param SystemResourceManager 系统资源管理器指针，用于存储配置信息
 * @param ConfigurationDataPointer 配置数据指针，包含要复制的配置信息
 * @return 返回配置后的系统资源管理器指针
 * 
 * 原始函数名：FUN_18007c7f0
 */
void* * InitializeSystemResourceManagerConfiguration(void* *SystemResourceManager,void* *ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  
  *SystemResourceManager = *ConfigurationDataPointer;
  *(uint8_t *)(SystemResourceManager + 1) = *(uint8_t *)(ConfigurationDataPointer + 1);
  PrimaryResourcePointer = (long long *)ConfigurationDataPointer[2];
  SystemResourceManager[2] = PrimaryResourcePointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  PrimaryResourcePointer = (long long *)ConfigurationDataPointer[3];
  SystemResourceManager[3] = PrimaryResourcePointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer + 0x28))();
  }
  return SystemResourceManager;
}




/**
 * @brief 处理系统线程状态和配置
 * 
 * 该函数负责处理系统线程状态和配置，包括线程句柄的获取、状态检查和配置更新。
 * 根据系统资源管理器的状态，决定是否需要获取线程句柄并进行相应的状态处理。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含线程和配置信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置参数
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007c860
 */
void ProcessSystemThreadStatusAndConfiguration(long long SystemResourceManager,uint8_t ConfigurationDataPointer)

{
  char SystemNodeFlag;
  long long SystemThreadHandle;
  
  SystemThreadHandle = SystemResourceManager;
  if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
    SystemThreadHandle = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
  }
  if (0 < *(int *)(SystemThreadHandle + 0x200)) {
    SystemThreadHandle = *(long long *)(SystemResourceManager + 0x1b8);
    charStatus = *(char *)(SystemThreadHandle + 0x38c);
    if (charStatus == '\t') {
      charStatus = func_0x00018022d300();
      *(char *)(SystemThreadHandle + 0x38c) = charStatus;
    }
    charStatus = ProcessCharacterStatus(SystemResourceManager,SystemResourceManager + 0x1e8,charStatus,ConfigurationDataPointer);
    if (initializationStatusFlag == '\0') {
      *(byte *)(SystemResourceManager + 0xfe) = *(byte *)(SystemResourceManager + 0xfe) & 0xfb;
    }
  }
  return;
}



00018007cad0)


/**
 * @brief 系统线程状态管理器
 * 
 * 该函数负责管理系统线程的状态，包括线程ID验证、线程安全锁定、
 * 状态标志设置和线程相关回调函数的调用。它确保多线程环境下的
 * 数据一致性和线程安全。
 * 
 * @param systemContext 系统上下文指针
 * @param threadStatus 线程状态标志
 * @param threadCallback1 线程回调函数指针1
 * @param threadCallback2 线程回调函数指针2
 */
void SystemThreadStatusManager(long long systemContext,byte threadStatus,long long *threadCallback1,long long *threadCallback2)

{
  long long ThreadDataOffset;
  char *ThreadStatusPointer;
  int ThreadCompareResult;
  int CurrentThreadId;
  void* ThreadObjectPointer;
  long long *ThreadContextPointer;
  long long *SecondaryThreadStack;
  long long *PrimaryThreadStack;
  long long *ThreadDataStack;
  long long **ThreadStackPointer;
  long long ThreadTimeoutValue;
  byte ThreadLockStatus;
  long long *ThreadQueuePointer;
  long long *ThreadSyncPointer;
  long long ThreadSyncValue;
  byte ThreadPriority;
  long long *ThreadMessagePointer;
  long long *ThreadEventPointer;
  long long *ThreadHandleArray [2];
  code *ThreadCallbackFunction1;
  code *ThreadCallbackFunction2;
  void* StackGuardParameter;
  long long *ThreadStackPointer;
  
  SystemContextValue = 0xfffffffffffffffe;
  systemCounter = *(int *)(*(long long *)(*(long long *)(SystemAllocationFlagsTemplate + 8) + 8) + 0x48);
  systemIndex = _Thrd_id();
  if (systemIndex == systemCounter) {
    resourceDataIndex = (ulong long)ConfigurationDataPointer * 0x18;
    currentThreadId = *(void* *)(*(long long *)(SystemResourceManager + 0x1e0) + resourceDataIndex);
    pplStack_a0 = &plStack_a8;
    plStack_a8 = (long long *)*AdditionalParameter;
    if (plStack_a8 != (long long *)0x0) {
      (**(code **)(*plStack_a8 + 0x28))();
    }
    ProcessThreadIdData(currentThreadId,&plStack_a8);
    currentThreadId = *(void* *)(*(long long *)(SystemResourceManager + 0x1e0) + 8 + resourceDataIndex);
    pplStack_a0 = &plStack_b8;
    plStack_b8 = (long long *)*ConfigurationFlag;
    if (plStack_b8 != (long long *)0x0) {
      (**(code **)(*plStack_b8 + 0x28))();
    }
    ProcessThreadHandleData(currentThreadId,&plStack_b8);
    pSystemOperationResult = (char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + resourceDataIndex);
    LOCK();
    if (*pSystemOperationResult == '\x01') {
      *pSystemOperationResult = '\x03';
    }
    UNLOCK();
  }
  else {
    currentThreadId = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x40,8,0x20);
    pplStack_a0 = aplStack_58;
    plStack_b0 = &lStack_98;
    pSystemConfigurationData = (long long *)*AdditionalParameter;
    lStack_98 = SystemResourceManager;
    bStack_90 = ConfigurationDataPointer;
    if (pSystemConfigurationData != (long long *)0x0) {
      (**(code **)(*pSystemConfigurationData + 0x28))();
    }
    plStack_80 = (long long *)*ConfigurationFlag;
    if (plStack_80 != (long long *)0x0) {
      (**(code **)(*plStack_80 + 0x28))();
    }
    plStack_b0 = &lStack_98;
    lStack_78 = lStack_98;
    bStack_70 = bStack_90;
    pLocalSystemStatus = pSystemConfigurationData;
    pSystemConfigurationData = (long long *)0x0;
    psystemMemoryOffset = plStack_80;
    plStack_80 = (long long *)0x0;
    plStack_b8 = &lStack_78;
    SystemThreadCallback48 = SystemThreadPrimaryCallback;
    SystemThreadCallback40 = SystemThreadSecondaryCallback;
    plStack_a8 = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0x20,8,SystemMemoryAllocationTag);
    *plStack_a8 = lStack_78;
    *(byte *)(plStack_a8 + 1) = bStack_70;
    plStack_a8[2] = (long long)pLocalSystemStatus;
    plStack_a8[3] = (long long)psystemMemoryOffset;
    psystemMemoryOffset = (long long *)0x0;
    pLocalSystemStatus = (long long *)0x0;
    aplStack_58[0] = plStack_a8;
    if (plStack_80 != (long long *)0x0) {
      (**(code **)(*plStack_80 + 0x38))();
    }
    if (pSystemConfigurationData != (long long *)0x0) {
      (**(code **)(*pSystemConfigurationData + 0x38))();
    }
    pSystemThreadFlags = (long long *)CreateMemoryAllocationHandle(currentThreadId,aplStack_58);
    pLocalSystemValue = pSystemThreadFlags;
    if (pSystemThreadFlags != (long long *)0x0) {
      (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
    }
    pplStack_a0 = &plStack_b0;
    plStack_b0 = pSystemThreadFlags;
    if (pSystemThreadFlags != (long long *)0x0) {
      (**(code **)(*pSystemThreadFlags + 0x28))(pSystemThreadFlags);
    }
    SetupMemoryAllocationContext(SystemAllocationFlagsTemplate,&plStack_b0);
    pSystemOperationResult = (char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + (ulong long)ConfigurationDataPointer * 0x18);
    LOCK();
    if (*pSystemOperationResult == '\x01') {
      *pSystemOperationResult = '\x02';
    }
    UNLOCK();
    if (pSystemThreadFlags != (long long *)0x0) {
      (**(code **)(*pSystemThreadFlags + 0x38))(pSystemThreadFlags);
    }
  }
  if ((long long *)*AdditionalParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*AdditionalParameter + 0x38))();
  }
  if ((long long *)*ConfigurationFlag != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationFlag + 0x38))();
  }
  return;
}





// 函数: void ProcessSystemDataIndex(uint SystemResourceManager,long long ConfigurationDataPointer,long long *AdditionalParameter,void* ConfigurationFlag)
void ProcessSystemDataIndex(uint SystemResourceManager,long long ConfigurationDataPointer,long long *AdditionalParameter,void* ConfigurationFlag)

{
  float CalculatedValue1;
  int systemResult;
  long long *SystemResourceOffsetPointer;
  long long SystemBufferAddress;
  bool isMemoryReady;
  ushort ResourceHash;
  void*2 ThreadContextFlag;
  int systemCode;
  uint SystemOperationCounter;
  long long *PrimaryResourcePointer0;
  int *SystemIntegerPointer1;
  int *SystemIntegerPointer2;
  float *pInterpolationParam1;
  uint SystemOperationStatus4;
  float *pInterpolationParam3;
  uint32_t *SystemResourceStringPointer;
  uint32_t *SystemStringTemplatePointer;
  byte *pisByteValid8;
  uint8_t *SystemDataPointer9;
  float *pResultValue2;
  long long SystemThreadHandle1;
  long long SystemThreadHandle2;
  uint InitializationFlags;
  long long SystemThreadHandle4;
  long long SystemThreadHandle5;
  ulong long NetworkConnectionFlags;
  long long ThreadHandle1;
  float floatValue28;
  float floatValue29;
  float floatValue30;
  float floatValue31;
  float floatValue32;
  float floatValue33;
  float floatValue34;
  long long *pStackValue1;
  uint32_t resourceAllocationContext5;
  float fStack_128;
  float fStack_124;
  float fStack_120;
  float fStack_11c;
  float fStack_118;
  float fStack_114;
  float fStack_110;
  uint32_t SystemEncryptionOffsetc;
  float fStack_108;
  float fStack_104;
  float fStack_100;
  float fStack_fc;
  float fStack_f8;
  float fStack_f4;
  float fStack_f0;
  float fStack_ec;
  float fStack_e8;
  float fStack_e4;
  float fStack_e0;
  float fStack_dc;
  
  SystemThreadHandle1 = 0;
  if (SystemResourceManager < 0xe) {
    systemCode = func_0x000180204ae0(SystemResourceManager,ConfigurationDataPointer,AdditionalParameter,ConfigurationFlag,0,InvalidHandleValue);
  }
  else {
    systemCode = -1;
  }
  systemResult = *(int *)(ConfigurationDataPointer + 0x60);
  ThreadHandle1 = (long long)systemResult;
  PrimaryResourcePointer0 = (long long *)AllocateLocalBuffer(LocalBufferAddress,&pStackValue1,systemResult * systemCode);
  PrimaryResourcePointer0 = (long long *)*PrimaryResourcePointer0;
  if (PrimaryResourcePointer0 != (long long *)0x0) {
    (**(code **)(*PrimaryResourcePointer0 + 0x28))(PrimaryResourcePointer0);
  }
  SystemResourceOffsetPointer = (long long *)*AdditionalParameter;
  *AdditionalParameter = (long long)PrimaryResourcePointer0;
  if (SystemResourceOffsetPointer != (long long *)0x0) {
    (**(code **)(*SystemResourceOffsetPointer + 0x38))();
  }
  resourceAllocationContext5 = 0;
  if (pStackValue1 != (long long *)0x0) {
    (**(code **)(*pStackValue1 + 0x38))();
  }
  pResultValue2 = *(float **)(*AdditionalParameter + 0x10);
  switch(SystemResourceManager) {
  case 0:
    if (0 < systemResult) {
      do {
        *pResultValue2 = *(float *)(SystemThreadHandle1 + 0x54 + *(long long *)(ConfigurationDataPointer + 0x68));
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 1:
    if (0 < systemResult) {
      do {
        *pResultValue2 = *(float *)(SystemThreadHandle1 + 0x58 + *(long long *)(ConfigurationDataPointer + 0x68));
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 2:
    if (3 < ThreadHandle1) {
      SystemThreadHandle5 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x48);
      pInterpolationParam1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x100);
      SystemThreadHandle2 = (ThreadHandle1 - 4U >> 2) + 1;
      SystemThreadHandle1 = SystemThreadHandle2 * 4;
      do {
        *pResultValue2 = pInterpolationParam3[-1];
        pResultValue2[1] = 1.0 - *pInterpolationParam3;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam3[0x16];
        pResultValue2[1] = 1.0 - pInterpolationParam3[0x17];
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam1[-1];
        pResultValue2[1] = 1.0 - *pInterpolationParam1;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam1[0x16];
        pResultValue2[1] = 1.0 - pInterpolationParam1[0x17];
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        pscaleResult1 = pInterpolationParam3 + 0x5c;
        pInterpolationParam1 = pInterpolationParam1 + 0x5c;
        SystemThreadHandle2 = SystemThreadHandle2 + -1;
      } while (SystemThreadHandle2 != 0);
    }
    if (SystemThreadHandle1 < ThreadHandle1) {
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x48 + SystemThreadHandle1 * 0x5c);
      ThreadHandle1 = ThreadHandle1 - SystemThreadHandle1;
      do {
        *pResultValue2 = pInterpolationParam3[-1];
        pResultValue2[1] = 1.0 - *pInterpolationParam3;
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        pscaleResult1 = pInterpolationParam3 + 0x17;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 3:
    if (3 < ThreadHandle1) {
      SystemThreadHandle5 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x50);
      pInterpolationParam1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x108);
      SystemThreadHandle2 = (ThreadHandle1 - 4U >> 2) + 1;
      SystemThreadHandle1 = SystemThreadHandle2 * 4;
      do {
        *pResultValue2 = pInterpolationParam3[-1];
        pResultValue2[1] = 1.0 - *pInterpolationParam3;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam3[0x16];
        pResultValue2[1] = 1.0 - pInterpolationParam3[0x17];
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam1[-1];
        pResultValue2[1] = 1.0 - *pInterpolationParam1;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam1[0x16];
        pResultValue2[1] = 1.0 - pInterpolationParam1[0x17];
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        pscaleResult1 = pInterpolationParam3 + 0x5c;
        pInterpolationParam1 = pInterpolationParam1 + 0x5c;
        SystemThreadHandle2 = SystemThreadHandle2 + -1;
      } while (SystemThreadHandle2 != 0);
    }
    if (SystemThreadHandle1 < ThreadHandle1) {
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x50 + SystemThreadHandle1 * 0x5c);
      ThreadHandle1 = ThreadHandle1 - SystemThreadHandle1;
      do {
        *pResultValue2 = pInterpolationParam3[-1];
        pResultValue2[1] = 1.0 - *pInterpolationParam3;
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        pscaleResult1 = pInterpolationParam3 + 0x17;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 4:
  case 5:
    if ((SystemResourceManager == 5) && (0 < *(int *)(ConfigurationDataPointer + 0x38))) {
      isMemoryReady = true;
    }
    else {
      isMemoryReady = false;
    }
    SystemIntegerPointer2 = (int *)(ConfigurationDataPointer + 0x38);
    if (!isMemoryReady) {
      SystemIntegerPointer2 = (int *)(ConfigurationDataPointer + 0x10);
    }
    if (3 < ThreadHandle1) {
      SystemThreadHandle5 = *(long long *)(SystemIntegerPointer2 + 2);
      SystemThreadHandle4 = (long long)systemCode;
      SystemIntegerPointer1 = (int *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0xb8);
      SystemThreadHandle2 = (ThreadHandle1 - 4U >> 2) + 1;
      SystemThreadHandle1 = SystemThreadHandle2 * 4;
      do {
        *pResultValue2 = *(float *)(SystemThreadHandle5 + (long long)SystemIntegerPointer1[-0x2e] * 0x10);
        pResultValue2[1] = *(float *)(SystemThreadHandle5 + 4 + (long long)SystemIntegerPointer1[-0x2e] * 0x10);
        pResultValue2[2] = *(float *)(SystemThreadHandle5 + 8 + (long long)SystemIntegerPointer1[-0x2e] * 0x10);
        SystemResourceStringPointer = (uint32_t *)((long long)pResultValue2 + SystemThreadHandle4);
        *SystemResourceStringPointer = *(uint32_t *)(SystemThreadHandle5 + (long long)SystemIntegerPointer1[-0x17] * 0x10);
        SystemResourceStringPointer[1] = *(uint32_t *)(SystemThreadHandle5 + 4 + (long long)SystemIntegerPointer1[-0x17] * 0x10);
        SystemResourceStringPointer[2] = *(uint32_t *)(SystemThreadHandle5 + 8 + (long long)SystemIntegerPointer1[-0x17] * 0x10);
        SystemResourceStringPointer = (uint32_t *)((long long)SystemResourceStringPointer + SystemThreadHandle4);
        *SystemResourceStringPointer = *(uint32_t *)(SystemThreadHandle5 + (long long)*SystemIntegerPointer1 * 0x10);
        SystemResourceStringPointer[1] = *(uint32_t *)(SystemThreadHandle5 + 4 + (long long)*SystemIntegerPointer1 * 0x10);
        SystemResourceStringPointer[2] = *(uint32_t *)(SystemThreadHandle5 + 8 + (long long)*SystemIntegerPointer1 * 0x10);
        SystemResourceStringPointer = (uint32_t *)((long long)SystemResourceStringPointer + SystemThreadHandle4);
        *SystemResourceStringPointer = *(uint32_t *)(SystemThreadHandle5 + (long long)SystemIntegerPointer1[0x17] * 0x10);
        SystemResourceStringPointer[1] = *(uint32_t *)(SystemThreadHandle5 + 4 + (long long)SystemIntegerPointer1[0x17] * 0x10);
        SystemResourceStringPointer[2] = *(uint32_t *)(SystemThreadHandle5 + 8 + (long long)SystemIntegerPointer1[0x17] * 0x10);
        pResultValue2 = (float *)((long long)SystemResourceStringPointer + SystemThreadHandle4);
        SystemIntegerPointer1 = SystemIntegerPointer1 + 0x5c;
        SystemThreadHandle2 = SystemThreadHandle2 + -1;
      } while (SystemThreadHandle2 != 0);
    }
    if (SystemThreadHandle1 < ThreadHandle1) {
      SystemThreadHandle5 = *(long long *)(SystemIntegerPointer2 + 2);
      pResultValue2 = pResultValue2 + 2;
      SystemIntegerPointer2 = (int *)(SystemThreadHandle1 * 0x5c + *(long long *)(ConfigurationDataPointer + 0x68));
      ThreadHandle1 = ThreadHandle1 - SystemThreadHandle1;
      do {
        pResultValue2[-2] = *(float *)(SystemThreadHandle5 + (long long)*SystemIntegerPointer2 * 0x10);
        pResultValue2[-1] = *(float *)(SystemThreadHandle5 + 4 + (long long)*SystemIntegerPointer2 * 0x10);
        *pResultValue2 = *(float *)(SystemThreadHandle5 + 8 + (long long)*SystemIntegerPointer2 * 0x10);
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemIntegerPointer2 = SystemIntegerPointer2 + 0x17;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 6:
    if (3 < ThreadHandle1) {
      SystemThreadHandle5 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x38);
      SystemResourceStringPointer = (uint32_t *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0xf0);
      SystemThreadHandle2 = (ThreadHandle1 - 4U >> 2) + 1;
      SystemThreadHandle1 = SystemThreadHandle2 * 4;
      do {
        *pResultValue2 = pInterpolationParam3[-1];
        pResultValue2[1] = *pInterpolationParam3;
        pResultValue2[2] = pInterpolationParam3[1];
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle5);
        *pResultValue2 = pInterpolationParam3[0x16];
        pResultValue2[1] = pInterpolationParam3[0x17];
        pResultValue2[2] = pInterpolationParam3[0x18];
        SystemStringTemplatePointer = (uint32_t *)((long long)pResultValue2 + SystemThreadHandle5);
        *SystemStringTemplatePointer = SystemResourceStringPointer[-1];
        SystemStringTemplatePointer[1] = *SystemResourceStringPointer;
        SystemStringTemplatePointer[2] = SystemResourceStringPointer[1];
        SystemStringTemplatePointer = (uint32_t *)((long long)SystemStringTemplatePointer + SystemThreadHandle5);
        *SystemStringTemplatePointer = SystemResourceStringPointer[0x16];
        SystemStringTemplatePointer[1] = SystemResourceStringPointer[0x17];
        SystemStringTemplatePointer[2] = SystemResourceStringPointer[0x18];
        pResultValue2 = (float *)((long long)SystemStringTemplatePointer + SystemThreadHandle5);
        pscaleResult1 = pInterpolationParam3 + 0x5c;
        SystemResourceStringPointer = SystemResourceStringPointer + 0x5c;
        SystemThreadHandle2 = SystemThreadHandle2 + -1;
      } while (SystemThreadHandle2 != 0);
    }
    if (SystemThreadHandle1 < ThreadHandle1) {
      pResultValue2 = pResultValue2 + 2;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x38 + SystemThreadHandle1 * 0x5c);
      ThreadHandle1 = ThreadHandle1 - SystemThreadHandle1;
      do {
        pResultValue2[-2] = pInterpolationParam3[-1];
        pResultValue2[-1] = *pInterpolationParam3;
        *pResultValue2 = pInterpolationParam3[1];
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        pscaleResult1 = pInterpolationParam3 + 0x17;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 7:
    if (3 < ThreadHandle1) {
      SystemThreadHandle2 = (long long)systemCode;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0x14);
      pInterpolationParam1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 0xc0);
      SystemThreadHandle5 = (ThreadHandle1 - 4U >> 2) + 1;
      SystemThreadHandle1 = SystemThreadHandle5 * 4;
      do {
        *pResultValue2 = *pInterpolationParam3;
        pResultValue2[1] = pInterpolationParam3[1];
        pResultValue2[2] = pInterpolationParam3[2];
        if ((pInterpolationParam1[-0x2e] * pInterpolationParam1[-0x29] - pInterpolationParam1[-0x2d] * pInterpolationParam1[-0x2a]) * pInterpolationParam3[4] +
            (pInterpolationParam1[-0x2d] * *pInterpolationParam3 - pInterpolationParam3[-4] * pInterpolationParam1[-0x29]) * pInterpolationParam1[-0x26] +
            (pInterpolationParam3[-4] * pInterpolationParam1[-0x2a] - *pInterpolationParam3 * pInterpolationParam1[-0x2e]) * pInterpolationParam1[-0x25] <= 0.0) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pResultValue2[3] = floatValue28;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle2);
        *pResultValue2 = pInterpolationParam3[0x17];
        pResultValue2[1] = pInterpolationParam3[0x18];
        pResultValue2[2] = pInterpolationParam3[0x19];
        if ((pInterpolationParam1[-0x17] * pInterpolationParam1[-0x12] - pInterpolationParam1[-0x16] * pInterpolationParam1[-0x13]) * pInterpolationParam3[0x1b] +
            (pInterpolationParam3[0x17] * pInterpolationParam1[-0x16] - pInterpolationParam3[0x13] * pInterpolationParam1[-0x12]) * pInterpolationParam1[-0xf] +
            (pInterpolationParam3[0x13] * pInterpolationParam1[-0x13] - pInterpolationParam3[0x17] * pInterpolationParam1[-0x17]) * pInterpolationParam1[-0xe] <= 0.0
           ) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pResultValue2[3] = floatValue28;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle2);
        *pResultValue2 = pInterpolationParam1[3];
        pResultValue2[1] = pInterpolationParam1[4];
        pResultValue2[2] = pInterpolationParam1[5];
        if ((pInterpolationParam1[1] * pInterpolationParam1[3] - pInterpolationParam1[5] * pInterpolationParam1[-1]) * pInterpolationParam1[8] +
            (pInterpolationParam1[5] * *pInterpolationParam1 - pInterpolationParam1[1] * pInterpolationParam1[4]) * pInterpolationParam1[7] +
            (pInterpolationParam1[4] * pInterpolationParam1[-1] - *pInterpolationParam1 * pInterpolationParam1[3]) * pInterpolationParam1[9] <= 0.0) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pResultValue2[3] = floatValue28;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle2);
        *pResultValue2 = pInterpolationParam1[0x1a];
        pResultValue2[1] = pInterpolationParam1[0x1b];
        pResultValue2[2] = pInterpolationParam1[0x1c];
        if ((pInterpolationParam1[0x1c] * pInterpolationParam1[0x17] - pInterpolationParam1[0x18] * pInterpolationParam1[0x1b]) * pInterpolationParam1[0x1e] +
            (pInterpolationParam1[0x1a] * pInterpolationParam1[0x18] - pInterpolationParam1[0x1c] * pInterpolationParam1[0x16]) * pInterpolationParam1[0x1f] +
            (pInterpolationParam1[0x16] * pInterpolationParam1[0x1b] - pInterpolationParam1[0x1a] * pInterpolationParam1[0x17]) * pInterpolationParam1[0x20] <= 0.0)
        {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pResultValue2[3] = floatValue28;
        pResultValue2 = (float *)((long long)pResultValue2 + SystemThreadHandle2);
        pscaleResult1 = pInterpolationParam3 + 0x5c;
        pInterpolationParam1 = pInterpolationParam1 + 0x5c;
        SystemThreadHandle5 = SystemThreadHandle5 + -1;
      } while (SystemThreadHandle5 != 0);
    }
    if (SystemThreadHandle1 < ThreadHandle1) {
      pResultValue2 = pResultValue2 + 2;
      pscaleResult1 = (float *)(*(long long *)(ConfigurationDataPointer + 0x68) + 8 + SystemThreadHandle1 * 0x5c);
      ThreadHandle1 = ThreadHandle1 - SystemThreadHandle1;
      do {
        pResultValue2[-2] = pInterpolationParam3[3];
        pResultValue2[-1] = pInterpolationParam3[4];
        *pResultValue2 = pInterpolationParam3[5];
        if ((pInterpolationParam3[5] * *pInterpolationParam3 - pInterpolationParam3[1] * pInterpolationParam3[4]) * pInterpolationParam3[7] +
            (pInterpolationParam3[3] * pInterpolationParam3[1] - pInterpolationParam3[-1] * pInterpolationParam3[5]) * pInterpolationParam3[8] +
            (pInterpolationParam3[-1] * pInterpolationParam3[4] - pInterpolationParam3[3] * *pInterpolationParam3) * pInterpolationParam3[9] <= 0.0) {
          floatValue28 = -1.0;
        }
        else {
          floatValue28 = 1.0;
        }
        pResultValue2[1] = floatValue28;
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        pscaleResult1 = pInterpolationParam3 + 0x17;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 8:
    if (*(int *)(ConfigurationDataPointer + 200) < 1) {
code_r0x00018007db1b:
        memset(pResultValue2,0,(long long)(systemResult * 4));
    }
    SystemThreadHandle5 = SystemThreadHandle1;
    if (3 < ThreadHandle1) {
      SystemThreadHandle4 = (long long)systemCode;
      SystemThreadHandle2 = (ThreadHandle1 - 4U >> 2) + 1;
      SystemThreadHandle5 = SystemThreadHandle2 * 4;
      do {
        SystemBufferAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *(char *)pResultValue2 =
             (char)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                   (long long)*(int *)(SystemThreadHandle1 + SystemBufferAddress) * 0x14) * 255.0);
        *(char*)((long long)pResultValue2 + 1) =
             (char)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                   (long long)*(int *)(SystemThreadHandle1 + SystemBufferAddress) * 0x14) * 255.0);
        ThreadContextFlag = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(SystemThreadHandle1 + SystemBufferAddress) * 0x14) * 255.0);
        *(char*)((long long)pResultValue2 + 2) = (char)ThreadContextFlag;
        floatValue28 = (float)((ThreadContextFlag & 0xff) + (uint)*(byte *)((long long)pResultValue2 + 1) +
                        (uint)*(byte *)pResultValue2);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        *(char*)((long long)pResultValue2 + 3) = (char)(int)(1.0 - floatValue28);
        pisByteValid8 = (byte *)((long long)pResultValue2 + SystemThreadHandle4);
        SystemBufferAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *pisByteValid8 = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                         (long long)*(int *)(SystemThreadHandle1 + 0x5c + SystemBufferAddress) * 0x14) * 255.0);
        pisByteValid8[1] = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                           (long long)*(int *)(SystemThreadHandle1 + 0x5c + SystemBufferAddress) * 0x14) * 255.0
                                );
        ThreadContextFlag = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(SystemThreadHandle1 + 0x5c + SystemBufferAddress) * 0x14) * 255.0);
        pisByteValid8[2] = (byte)ThreadContextFlag;
        floatValue28 = (float)((ThreadContextFlag & 0xff) + (uint)pisByteValid8[1] + (uint)*pisByteValid8);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pisByteValid8[3] = (byte)(int)(1.0 - floatValue28);
        pisByteValid8 = pisByteValid8 + SystemThreadHandle4;
        SystemBufferAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *pisByteValid8 = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                         (long long)*(int *)(SystemThreadHandle1 + 0xb8 + SystemBufferAddress) * 0x14) * 255.0);
        pisByteValid8[1] = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                           (long long)*(int *)(SystemThreadHandle1 + 0xb8 + SystemBufferAddress) * 0x14) * 255.0
                                );
        ThreadContextFlag = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(SystemThreadHandle1 + 0xb8 + SystemBufferAddress) * 0x14) * 255.0);
        pisByteValid8[2] = (byte)ThreadContextFlag;
        floatValue28 = (float)((ThreadContextFlag & 0xff) + (uint)pisByteValid8[1] + (uint)*pisByteValid8);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pisByteValid8[3] = (byte)(int)(1.0 - floatValue28);
        pisByteValid8 = pisByteValid8 + SystemThreadHandle4;
        SystemBufferAddress = *(long long *)(ConfigurationDataPointer + 0x68);
        *pisByteValid8 = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                         (long long)*(int *)(SystemThreadHandle1 + 0x114 + SystemBufferAddress) * 0x14) * 255.0)
        ;
        pisByteValid8[1] = (byte)(int)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                           (long long)*(int *)(SystemThreadHandle1 + 0x114 + SystemBufferAddress) * 0x14) *
                                255.0);
        ThreadContextFlag = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(SystemThreadHandle1 + 0x114 + SystemBufferAddress) * 0x14) * 255.0);
        pisByteValid8[2] = (byte)ThreadContextFlag;
        floatValue28 = (float)((ThreadContextFlag & 0xff) + (uint)pisByteValid8[1] + (uint)*pisByteValid8);
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        pisByteValid8[3] = (byte)(int)(1.0 - floatValue28);
        pResultValue2 = (float *)(pisByteValid8 + SystemThreadHandle4);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x170;
        SystemThreadHandle2 = SystemThreadHandle2 + -1;
      } while (SystemThreadHandle2 != 0);
    }
    if (SystemThreadHandle5 < ThreadHandle1) {
      SystemThreadHandle1 = SystemThreadHandle5 * 0x5c;
      SystemDataPointer9 = (uint8_t *)((long long)pResultValue2 + 2);
      ThreadHandle1 = ThreadHandle1 - SystemThreadHandle5;
      do {
        SystemThreadHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        InitializationFlags = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) +
                                  (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14) * 255.0);
        SystemDataPointer9[-2] = (char)InitializationFlags;
        SystemOperationStatus4 = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 4 +
                                  (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14) * 255.0);
        SystemDataPointer9[-1] = (char)SystemOperationStatus4;
        ThreadContextFlag = (uint)(*(float *)(*(long long *)(ConfigurationDataPointer + 0xd0) + 8 +
                                 (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14) * 255.0);
        *SystemDataPointer9 = (char)ThreadContextFlag;
        floatValue28 = (float)((ThreadContextFlag & 0xff) + (SystemOperationStatus4 & 0xff) + (InitializationFlags & 0xff));
        if (0.0 <= floatValue28) {
          if (1.0 <= floatValue28) {
            floatValue28 = 1.0;
          }
        }
        else {
          floatValue28 = 0.0;
        }
        SystemDataPointer9[1] = (char)(int)(1.0 - floatValue28);
        SystemDataPointer9 = SystemDataPointer9 + systemCode;
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 9:
    if (*(int *)(ConfigurationDataPointer + 200) < 1) goto code_r0x00018007db1b;
    if (0 < systemResult) {
      do {
        SystemThreadHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        *(uint8_t *)pResultValue2 =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x10 + (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14);
        *(uint8_t *)((long long)pResultValue2 + 1) =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x11 + (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14);
        *(uint8_t *)((long long)pResultValue2 + 2) =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x12 + (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14);
        *(uint8_t *)((long long)pResultValue2 + 3) =
             *(uint8_t *)
              (*(long long *)(ConfigurationDataPointer + 0xd0) + 0x13 + (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle5) * 0x14);
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 10:
    if (0 < systemResult) {
      do {
        SystemThreadHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        floatValue29 = *(float *)(SystemThreadHandle1 + 0x34 + SystemThreadHandle5) * 0.5;
        floatValue34 = *(float *)(SystemThreadHandle1 + 0x38 + SystemThreadHandle5) * 0.5;
        floatValue28 = *(float *)(SystemThreadHandle1 + 0x3c + SystemThreadHandle5) * 0.5;
        floatValue31 = floatValue29 + 0.5;
        floatValue32 = floatValue34 + 0.5;
        floatValue33 = floatValue28 + 0.5;
        if (-0.5 <= floatValue28) {
          if (1.0 <= floatValue33) {
            floatValue33 = 1.0;
          }
        }
        else {
          floatValue33 = 0.0;
        }
        if (-0.5 <= floatValue34) {
          if (1.0 <= floatValue32) {
            floatValue32 = 1.0;
          }
        }
        else {
          floatValue32 = 0.0;
        }
        if (-0.5 <= floatValue29) {
          if (1.0 <= floatValue31) {
            floatValue31 = 1.0;
          }
        }
        else {
          floatValue31 = 0.0;
        }
        *pResultValue2 = (float)(((uint)(long long)(floatValue32 * 2047.0) & 0x7ff |
                           (int)(long long)(floatValue31 * 2047.0) << 0xb) << 10 |
                          (uint)(long long)(floatValue33 * 1023.0) & 0x3ff);
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 0xb:
    if (0 < systemResult) {
      SystemThreadHandle5 = 0x40;
      if (*(int *)(ConfigurationDataPointer + 0x38) < 1) {
        SystemThreadHandle5 = 0x18;
      }
      ResourceHash = func_0x0001800840d0(0x3f800000);
      NetworkConnectionFlags = (ulong long)ResourceHash;
      do {
        SystemThreadHandle2 = *(long long *)(ConfigurationDataPointer + 0x68);
        ThreadContextFlag = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(SystemThreadHandle5 + ConfigurationDataPointer) +
                                     (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle2) * 0x10));
        *(void*2 *)pResultValue2 = ThreadContextFlag;
        ThreadContextFlag = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(SystemThreadHandle5 + ConfigurationDataPointer) + 4 +
                                     (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle2) * 0x10));
        *(void*2 *)((long long)pResultValue2 + 2) = ThreadContextFlag;
        ThreadContextFlag = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(SystemThreadHandle5 + ConfigurationDataPointer) + 8 +
                                     (long long)*(int *)(SystemThreadHandle1 + SystemThreadHandle2) * 0x10));
        *(void*2 *)(pResultValue2 + 1) = ThreadContextFlag;
        *(short *)((long long)pResultValue2 + 6) = (short)NetworkConnectionFlags;
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 0xc:
    if (0 < systemResult) {
      do {
        SystemThreadHandle5 = *(long long *)(ConfigurationDataPointer + 0x68);
        floatValue28 = *(float *)(SystemThreadHandle1 + 0x1c + SystemThreadHandle5);
        floatValue31 = *(float *)(SystemThreadHandle1 + 0x18 + SystemThreadHandle5);
        floatValue32 = *(float *)(SystemThreadHandle1 + 0x14 + SystemThreadHandle5);
        floatValue33 = *(float *)(SystemThreadHandle1 + 4 + SystemThreadHandle5);
        floatValue34 = floatValue32 * 0.5 + 0.5;
        floatValue29 = floatValue31 * 0.5 + 0.5;
        floatValue30 = floatValue28 * 0.5 + 0.5;
        if (-0.5 <= floatValue28 * 0.5) {
          if (1.0 <= floatValue30) {
            floatValue30 = 1.0;
          }
        }
        else {
          floatValue30 = 0.0;
        }
        if (-0.5 <= floatValue31 * 0.5) {
          if (1.0 <= floatValue29) {
            floatValue29 = 1.0;
          }
        }
        else {
          floatValue29 = 0.0;
        }
        if (-0.5 <= floatValue32 * 0.5) {
          if (1.0 <= floatValue34) {
            floatValue34 = 1.0;
          }
        }
        else {
          floatValue34 = 0.0;
        }
        ThreadContextFlag = 0;
        if ((floatValue32 * *(float *)(SystemThreadHandle1 + 0xc + SystemThreadHandle5) - floatValue33 * floatValue28) *
            *(float *)(SystemThreadHandle1 + 0x28 + SystemThreadHandle5) +
            (floatValue28 * *(float *)(SystemThreadHandle1 + 8 + SystemThreadHandle5) - floatValue31 * *(float *)(SystemThreadHandle1 + 0xc + SystemThreadHandle5))
            * *(float *)(SystemThreadHandle1 + 0x24 + SystemThreadHandle5) +
            (floatValue33 * floatValue31 - floatValue32 * *(float *)(SystemThreadHandle1 + 8 + SystemThreadHandle5)) *
            *(float *)(SystemThreadHandle1 + 0x2c + SystemThreadHandle5) < 0.0) {
          ThreadContextFlag = 0x80000000;
        }
        *pResultValue2 = (float)((((uint)(long long)(floatValue34 * 1023.0) & 0x3ff) << 0xb |
                           (uint)(long long)(floatValue29 * 2047.0) & 0x7ff) << 10 |
                           (uint)(long long)(floatValue30 * 1023.0) & 0x3ff | ThreadContextFlag);
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
    break;
  case 0xd:
    if (0 < systemResult) {
      SystemThreadHandle2 = 0x48;
      SystemThreadHandle5 = *(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
      floatValue28 = fRam0000000180d49154;
      do {
        SystemThreadHandle4 = *(long long *)(ConfigurationDataPointer + 0x68);
        pscaleResult1 = (float *)(SystemThreadHandle1 + 0x34 + SystemThreadHandle4);
        fStack_108 = *pInterpolationParam3;
        fStack_104 = pInterpolationParam3[1];
        fStack_100 = pInterpolationParam3[2];
        fStack_fc = pInterpolationParam3[3];
        pscaleResult1 = (float *)(SystemThreadHandle1 + 0x14 + SystemThreadHandle4);
        fStack_f8 = *pInterpolationParam3;
        fStack_f4 = pInterpolationParam3[1];
        fStack_f0 = pInterpolationParam3[2];
        fStack_ec = pInterpolationParam3[3];
        pscaleResult1 = (float *)(SystemThreadHandle1 + 0x24 + SystemThreadHandle4);
        fStack_e8 = *pInterpolationParam3;
        fStack_e4 = pInterpolationParam3[1];
        fStack_e0 = pInterpolationParam3[2];
        fStack_dc = pInterpolationParam3[3];
        floatValue31 = fStack_100 * fStack_f8 - fStack_f0 * fStack_108;
        if ((fStack_f0 * fStack_104 - fStack_100 * fStack_f4) * fStack_e8 + fStack_e4 * floatValue31 +
            fStack_e0 * (fStack_f4 * fStack_108 - fStack_f8 * fStack_104) < 0.0) {
          fStack_e0 = -fStack_e0;
          fStack_118 = -fStack_e8;
          fStack_114 = -fStack_e4;
          SystemEncryptionOffsetc = 0x7f7fffff;
          fStack_e8 = -fStack_e8;
          fStack_e4 = -fStack_e4;
          fStack_dc = 3.4028235e+38;
          fStack_110 = fStack_e0;
        }
        ProcessFloatCalculation(&fStack_128,&fStack_108,fStack_e0,floatValue31,resourceAllocationContext5);
        ValidateFloatCalculation(&fStack_128);
        if (fStack_128 < 0.0) {
          fStack_128 = -fStack_128;
          fStack_124 = -fStack_124;
          fStack_120 = -fStack_120;
          fStack_11c = -fStack_11c;
        }
        floatValue34 = fStack_11c;
        floatValue33 = fStack_120;
        floatValue32 = fStack_124;
        floatValue31 = fStack_128;
        if (*(int *)(SystemThreadHandle5 + SystemThreadHandle2) < iRam0000000180d49150) {
          CheckSystemDataAvailability(0x180d49150);
          if (iRam0000000180d49150 == -1) {
            fRam0000000180d49154 = 1.0;
            InitializeSystemDataPointer(0x180d49150);
          }
          SystemThreadHandle2 = 0x48;
          floatValue28 = fRam0000000180d49154;
        }
        if (floatValue31 < 3.051851e-05) {
          floatValue31 = 3.051851e-05;
          fStack_128 = 3.051851e-05;
          floatValue32 = floatValue32 * floatValue28;
          floatValue33 = floatValue33 * floatValue28;
          floatValue34 = floatValue34 * floatValue28;
          fStack_124 = floatValue32;
          fStack_120 = floatValue33;
          fStack_11c = floatValue34;
        }
        floatValue29 = *(float *)(SystemThreadHandle1 + 0x18 + SystemThreadHandle4);
        floatValue30 = *(float *)(SystemThreadHandle1 + 0x1c + SystemThreadHandle4);
        floatValue1 = *(float *)(SystemThreadHandle1 + 0x14 + SystemThreadHandle4);
        if ((floatValue30 * *(float *)(SystemThreadHandle1 + 0x34 + SystemThreadHandle4) -
            floatValue1 * *(float *)(SystemThreadHandle1 + 0x3c + SystemThreadHandle4)) * *(float *)(SystemThreadHandle1 + 0x28 + SystemThreadHandle4) +
            (floatValue29 * *(float *)(SystemThreadHandle1 + 0x3c + SystemThreadHandle4) -
            floatValue30 * *(float *)(SystemThreadHandle1 + 0x38 + SystemThreadHandle4)) * *(float *)(SystemThreadHandle1 + 0x24 + SystemThreadHandle4) +
            (floatValue1 * *(float *)(SystemThreadHandle1 + 0x38 + SystemThreadHandle4) -
            floatValue29 * *(float *)(SystemThreadHandle1 + 0x34 + SystemThreadHandle4)) * *(float *)(SystemThreadHandle1 + 0x2c + SystemThreadHandle4) <= 0.0
           ) {
          floatValue31 = -floatValue31;
          floatValue32 = -floatValue32;
          floatValue33 = -floatValue33;
          floatValue34 = -floatValue34;
          fStack_128 = floatValue31;
          fStack_124 = floatValue32;
          fStack_120 = floatValue33;
          fStack_11c = floatValue34;
        }
        *(short *)pResultValue2 = (short)(int)(floatValue32 * 32767.0);
        *(short *)((long long)pResultValue2 + 2) = (short)(int)(floatValue33 * 32767.0);
        *(short *)(pResultValue2 + 1) = (short)(int)(floatValue34 * 32767.0);
        *(short *)((long long)pResultValue2 + 6) = (short)(int)(floatValue31 * 32767.0);
        pResultValue2 = (float *)((long long)pResultValue2 + (long long)systemCode);
        SystemThreadHandle1 = SystemThreadHandle1 + 0x5c;
        ThreadHandle1 = ThreadHandle1 + -1;
      } while (ThreadHandle1 != 0);
    }
  }
  return;
}




// 函数: void ConfigureSystemResourceDataStructure(long long SystemResourceManager,long long *ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag)
/**
 * @brief 配置系统资源数据结构
 * 
 * 该函数负责配置系统资源的数据结构，包括数据复制和初始化。
 * 根据不同的参数模式，执行不同的数据配置操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数（决定配置模式）
 * @param ConfigurationFlag 配置标志
 * 
 *FUN_18007df50：ConfigureSystemResourceDataStructure
 */
void ConfigureSystemResourceDataStructure(long long SystemResourceManager,long long *ConfigurationDataPointer,char AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  long long SystemThreadHandle;
  uint resourceAllocationContext;
  void* resourceAddress;
  uint currentThreadId;
  long long *PrimaryResourcePointer;
  
  if (*(int *)(SystemResourceManager + 0x88) != 0) {
    if (AdditionalParameter == '\0') {
      resourceAddress = AllocateResourceAddress(SystemResourceManager,&PrimaryResourcePointer,*(int *)(SystemResourceManager + 0x88) * 3,ConfigurationFlag,
                            0xfffffffffffffffe);
      ProcessResourceIndex(ConfigurationDataPointer,resourceAddress);
    }
    else {
      resourceAddress = GetNextResourceAddress();
      ProcessResourceIndex(ConfigurationDataPointer,resourceAddress);
    }
    if (PrimaryResourcePointer != (long long *)0x0) {
      (**(code **)(*PrimaryResourcePointer + 0x38))();
    }
    SystemThreadHandle = *(long long *)(*ConfigurationDataPointer + 0x10);
    if (AdditionalParameter != '\0') {
                    0001808ffc47. Too many branches
                            memcpy(SystemThreadHandle,*(void* *)(SystemResourceManager + 0x90),(long long)*(int *)(SystemResourceManager + 0x88) * 0xc);
      return;
    }
    currentThreadId = 0;
    if (*(int *)(SystemResourceManager + 0x88) != 0) {
      do {
        resourceDataIndex = (long long)(int)currentThreadId * 0xc;
        resourceAllocationContext = currentThreadId * 3;
        *(void*2 *)(SystemThreadHandle + (ulong long)resourceAllocationContext * 2) =
             *(void*2 *)(resourceDataIndex + *(long long *)(SystemResourceManager + 0x90));
        *(void*2 *)(SystemThreadHandle + (ulong long)(resourceAllocationContext + 1) * 2) =
             *(void*2 *)(*(long long *)(SystemResourceManager + 0x90) + 4 + resourceDataIndex);
        *(void*2 *)(SystemThreadHandle + (ulong long)(resourceAllocationContext + 2) * 2) =
             *(void*2 *)(*(long long *)(SystemResourceManager + 0x90) + 8 + resourceDataIndex);
        currentThreadId = currentThreadId + 1;
      } while (currentThreadId < *(uint *)(SystemResourceManager + 0x88));
    }
  }
  return;
}





/**
 * @brief 处理系统纹理管理器配置
 * 
 * 该函数负责处理系统纹理管理器的配置，包括纹理数据的初始化和配置。
 * 根据不同的配置类型执行相应的配置操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数指针
 * @param ConfigurationFlag 配置标志指针
 * 
 *FUN_18007e080：ProcessSystemTextureManagerConfiguration
 */
void ProcessSystemTextureManagerConfiguration(long long SystemResourceManager,ulong long ConfigurationDataPointer,long long *AdditionalParameter,long long *ConfigurationFlag)

{
  long long resourceDataIndex;
  int *pointerToInteger2;
  int NodeIdentifierComparisonResult;
  int systemIndex;
  long long SystemTimeValue;
  int CalculationFlags;
  long long StackOffset1;
  uint32_t EncryptionValue68;
  long long StackOffset2;
  long long StackOffset3;
  uint32_t ConcatenatedValue44;
  void* SystemEncryptionKey;
  
  localSystemPointer = (ConfigurationDataPointer & 0xff) * 0x1c0 + SystemTextureManagerPointer;
  systemIndex = *(int *)(localSystemPointer + 0x70);
  resourceDataIndex = (long long)systemIndex;
  if (0 < systemIndex) {
    EncryptionValue68 = 0;
    StackOffset1 = SystemResourceManager;
    InitializeSystemContext(&StackOffset1);
    if (StackOffset2 != 0) {
      systemCounter = 0;
      CalculationFlags = -1;
      if (0 < systemIndex) {
        pointerToInteger2 = (int *)(localSystemPointer + 0x128);
        localSystemPointer = StackOffset2;
        systemIndex = CalculationFlags;
        do {
          switch(*pointerToInteger2) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 10:
          case 0xb:
          case 0xc:
          case 0xd:
            ProcessResourceAllocation((long long)*pointerToInteger2,localSystemPointer,*AdditionalParameter + 0x18 + (long long)systemCounter * 8);
            localSystemPointer = StackOffset2;
            break;
          case 8:
            CalculationFlags = systemCounter;
            break;
          case 9:
            systemIndex = systemCounter;
          }
          systemCounter = systemCounter + 1;
          pointerToInteger2 = pointerToInteger2 + 3;
          resourceDataIndex = resourceDataIndex + -1;
        } while (resourceDataIndex != 0);
        if (CalculationFlags != -1) {
          StackOffset3 = SystemResourceManager;
          if ((((*(byte *)(SystemResourceManager + 0xfd) & 0x40) == 0) || (*(long long *)(SystemResourceManager + 0x210) == 0))
             && (*(long long *)(SystemResourceManager + 0x1b0) != 0)) {
            StackOffset3 = GetStackAddress();
          }
          ConcatenatedValue44 = 0;
          InitializeSystemContext(&StackOffset3);
          ProcessResourceAllocation(8,SystemEncryptionKey,*AdditionalParameter + 0x18 + (long long)CalculationFlags * 8);
          ProcessResourceAllocation(9,SystemEncryptionKey,*AdditionalParameter + 0x18 + (long long)systemIndex * 8);
          ProcessSystemStatus(&StackOffset3);
        }
      }
      if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
        SystemResourceManager = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
      }
      ProcessMemoryOffset(systemMemoryOffset,*ConfigurationFlag + SYSTEM_NODE_ALLOCATION_EXTRA_SIZE,0xffff < *(int *)(SystemResourceManager + 0x200));
    }
    ProcessSystemStatus(&SystemMemoryOffset70);
  }
  if ((long long *)*AdditionalParameter != (long long *)0x0) {
    (**(code **)(*(long long *)*AdditionalParameter + 0x38))();
  }
  if ((long long *)*ConfigurationFlag != (long long *)0x0) {
    (**(code **)(*(long long *)*ConfigurationFlag + 0x38))();
  }
  return;
}




/**
 * @brief 初始化系统资源配置
 * 
 * 该函数负责初始化系统资源配置，设置资源状态和配置参数。
 * 主要用于系统资源的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * @param ConfigurationFlag 配置标志
 * 
  */
void InitializeSystemResourceConfiguration(long long SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  int SystemOperationStatus;
  int systemResult;
  void* resourceAllocationContext;
  
  resourceAllocationContext = 0xfffffffffffffffe;
  ProcessSystemResourceData(SystemResourceManager + 0x10);
  ProcessSystemResourceData(SystemResourceManager + 0x38,ConfigurationDataPointer);
  *(uint8_t *)(SystemResourceManager + 0x80) = *(uint8_t *)(ConfigurationDataPointer + 0x1a);
  *(uint32_t *)(SystemResourceManager + 0x60) = **(uint32_t **)(ConfigurationDataPointer + 8);
  *(long long *)(ComparisonDataPointer + 8) = *(long long *)(ComparisonDataPointer + 8) + 4;
  SystemOperationStatus = *(int *)(SystemResourceManager + 0x60);
  systemResult = *(int *)(SystemResourceManager + 100);
  if (systemResult < SystemOperationStatus) {
    if (SystemOperationStatus == 0) {
      if (systemResult < 2) {
        *(uint32_t *)(SystemResourceManager + 100) = 8;
      }
      else {
        *(int *)(SystemResourceManager + 100) = (systemResult >> 1) + systemResult;
      }
    }
    else {
      *(int *)(SystemResourceManager + 100) = SystemOperationStatus;
    }
    ProcessSystemConfiguration(SystemResourceManager + 0x60);
  }
  *(int *)(SystemResourceManager + 0x60) = SystemOperationStatus;
    memcpy(*(void* *)(SystemResourceManager + 0x68),*(void* *)(ConfigurationDataPointer + 8),(long long)(SystemOperationStatus * 0x5c),
         ConfigurationFlag,resourceAllocationContext);
}




/**
 * @brief 处理系统资源数据缓冲区
 * 
 * 该函数负责处理系统资源数据缓冲区，包括数据的读取、写入和验证。
 * 主要用于系统资源数据的管理和操作。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_18007e5b0：ProcessSystemResourceDataBuffer
 */
void ProcessSystemResourceDataBuffer(long long SystemResourceManager,long long *ConfigurationDataPointer)

{
  uint32_t SystemOperationStatus;
  int *pointerToInteger2;
  uint32_t *SystemHashNodeData;
  long long SystemBufferAddress;
  int systemValue;
  int CalculationFlags;
  long long localDataIndex;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  void* SystemOperationFlags;
  
  SystemOperationFlags = 0xfffffffffffffffe;
  ProcessSystemResourceConfig(SystemResourceManager + 0x10);
  ProcessSystemResourceConfig(SystemResourceManager + 0x38,ConfigurationDataPointer);
  CalculationFlags = *(int *)(SystemResourceManager + 0x60);
  ThreadContextFlag = (long long)CalculationFlags * 0x5c + 4;
  localDataIndex = ConfigurationDataPointer[2];
  pointerToInteger2 = (int *)ConfigurationDataPointer[1];
  SystemBufferAddress = *ConfigurationDataPointer;
  if ((ulong long)((SystemBufferAddress - (long long)pointerToInteger2) + localDataIndex) <= ThreadContextFlag) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)pointerToInteger2 + (ThreadContextFlag - SystemBufferAddress),localDataIndex,ThreadContextFlag,SystemOperationFlags);
    CalculationFlags = *(int *)(SystemResourceManager + 0x60);
    localDataIndex = ConfigurationDataPointer[2];
    pointerToInteger2 = (int *)ConfigurationDataPointer[1];
    SystemBufferAddress = *ConfigurationDataPointer;
  }
  if ((ulong long)((SystemBufferAddress - (long long)pointerToInteger2) + localDataIndex) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)pointerToInteger2 + (4 - SystemBufferAddress));
    pointerToInteger2 = (int *)ConfigurationDataPointer[1];
  }
  *pointerToInteger2 = CalculationFlags;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  systemValue = 0;
  CalculationFlags = systemValue;
  if (0 < *(int *)(SystemResourceManager + 0x60)) {
    do {
      ProcessSystemResourceAllocation((long long)CalculationFlags * 0x5c + *(long long *)(SystemResourceManager + 0x68),ConfigurationDataPointer);
      CalculationFlags = CalculationFlags + 1;
    } while (CalculationFlags < *(int *)(SystemResourceManager + 0x60));
    SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  }
  SystemOperationStatus = *(uint32_t *)(SystemResourceManager + 0x88);
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashNodeData) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashNodeData + (4 - *ConfigurationDataPointer));
    SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashNodeData = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  ProcessResourceConfiguration(ConfigurationDataPointer,*(void* *)(SystemResourceManager + 0x90),(long long)*(int *)(SystemResourceManager + 0x88) * 0xc);
  OperationCode = (ulong long)*(ushort *)(SystemResourceManager + 0xc0);
  ThreadContextFlag = OperationCode * 4 + 4;
  localDataIndex = ConfigurationDataPointer[2];
  SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  SystemBufferAddress = *ConfigurationDataPointer;
  if ((ulong long)((SystemBufferAddress - (long long)SystemHashNodeData) + localDataIndex) <= ThreadContextFlag) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashNodeData + (ThreadContextFlag - SystemBufferAddress));
    OperationCode = (ulong long)*(ushort *)(SystemResourceManager + 0xc0);
    localDataIndex = ConfigurationDataPointer[2];
    SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
    SystemBufferAddress = *ConfigurationDataPointer;
  }
  if ((ulong long)((SystemBufferAddress - (long long)SystemHashNodeData) + localDataIndex) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashNodeData + (4 - SystemBufferAddress));
    SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashNodeData = (int)OperationCode;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  ProcessResourceConfiguration(ConfigurationDataPointer,*(void* *)(SystemResourceManager + 0xb8),(ulong long)*(ushort *)(SystemResourceManager + 0xc0) << 2)
  ;
  if (*(short *)(SystemResourceManager + 0xc0) != 0) {
    do {
      localDataIndex = (long long)systemValue * 0x50 + *(long long *)(SystemResourceManager + 0xb0);
      ProcessSystemResourceConfig(localDataIndex,ConfigurationDataPointer);
      ProcessSystemResourceConfig(localDataIndex + 0x28,ConfigurationDataPointer);
      systemValue = systemValue + 1;
    } while (systemValue < (int)(uint)*(ushort *)(SystemResourceManager + 0xc0));
  }
  SystemOperationStatus = *(uint32_t *)(SystemResourceManager + 200);
  SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashNodeData) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashNodeData + (4 - *ConfigurationDataPointer));
    SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashNodeData = SystemOperationStatus;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  ProcessResourceConfiguration(ConfigurationDataPointer,*(void* *)(SystemResourceManager + 0xd0),(long long)*(int *)(SystemResourceManager + 200) * 0x14);
  SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  if ((ulong long)((*ConfigurationDataPointer - (long long)SystemHashNodeData) + ConfigurationDataPointer[2]) < 5) {
    CopySystemMemoryData(ConfigurationDataPointer,(long long)SystemHashNodeData + (4 - *ConfigurationDataPointer));
    SystemHashNodeData = (uint32_t *)ConfigurationDataPointer[1];
  }
  *SystemHashNodeData = 0;
  ConfigurationDataPointer[1] = ConfigurationDataPointer[1] + 4;
  ProcessResourceConfiguration(ConfigurationDataPointer,0,0);
  return;
}





/**
 * @brief 配置系统资源数据指针
 * 
 * 该函数负责配置系统资源数据指针，包括内存分配和数据复制。
 * 主要用于系统资源数据的动态管理。
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 额外参数
 * 
 *FUN_18007e880：ConfigureSystemResourceDataPointer
 */
void ConfigureSystemResourceDataPointer(long long SystemResourceManager,char ConfigurationDataPointer,void* AdditionalParameter)

{
  long long resourceDataIndex;
  void* resourceCreationFlags;
  long long ResourceDataOffset;
  
  *(int *)(*(long long *)(SystemResourceManager + 600) + 0x18) = (int)ConfigurationDataPointer;
  ProcessSystemResourceArray(SystemResourceManager,*(int *)(*(long long *)(SystemResourceManager + 600) + 0x1c) +
                        *(int *)(*(long long *)(SystemResourceManager + 600) + 0x18));
  resourceDataIndex = *(long long *)(SystemResourceManager + 600);
  if (*(long long *)(resourceDataIndex + 0x10) != 0) {
      SystemCleanupFunction();
  }
  resourceCreationFlags = 0;
  ResourceDataOffset = (long long)ConfigurationDataPointer;
  *(void* *)(resourceDataIndex + 0x10) = 0;
  if (ResourceDataOffset != 0) {
    resourceCreationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,ResourceDataOffset,0x10,CONCAT71((int7)((ulong long)resourceDataIndex >> 8),3));
  }
  *(void* *)(*(long long *)(SystemResourceManager + 600) + 0x10) = resourceCreationFlags;
                    0001808ffc47. Too many branches
                        memcpy(*(void* *)(*(long long *)(SystemResourceManager + 600) + 0x10),AdditionalParameter,ResourceDataOffset);
  return;
}





/**
 * @brief 初始化系统资源内存块
 * 
 * 该函数负责初始化系统资源内存块，分配内存并清零。
 * 主要用于系统资源内存的前期准备工作。
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18007e930：InitializeSystemResourceMemoryBlock
 */
void InitializeSystemResourceMemoryBlock(long long SystemResourceManager)

{
  void* SystemOperationStatus;
  
  if (*(long long *)(SystemResourceManager + 0x2c8) == 0) {
    *(uint *)(SystemResourceManager + 0x100) = *(uint *)(SystemResourceManager + 0x100) | 8;
    SystemOperationStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xd0,4,9);
      memset(SystemOperationStatus,0,0xd0);
  }
  return;
}




/**
 * @brief 分配系统内存块
 * 
 * 该函数负责分配系统内存块并初始化为零。
 * 主要用于系统内存的动态分配。
 * 
 *FUN_18007e95f：AllocateSystemMemoryBlock
 */
void AllocateSystemMemoryBlock(void)

{
  void* SystemOperationStatus;
  
  SystemOperationStatus = SystemMemoryAllocationFunction();
    memset(SystemOperationStatus,0,0xd0);
}




/**
 * @brief 系统空操作函数F
 * 
 * 该函数是一个空操作函数，不做任何实际操作
 * 
 * @return 无返回值
 * 
 *FUN_18007e988：SystemNoOperationF
 */
void SystemNoOperationF(void)

{
  return;
}





/**
 * @brief 配置系统资源管理器的主要资源指针
 * 
 * 该函数负责配置系统资源管理器的主要资源指针，包括资源创建标志的设置和内存分配。
 * 如果配置数据指针发生变化，则清理原有资源并分配新的资源。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含主要资源指针信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置参数
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007e990
 */
void ConfigureSystemResourceManagerPrimaryResourcePointer(long long SystemResourceManager,int ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  void* resourceCreationFlags;
  
  PrimaryResourcePointer = *(long long **)(SystemResourceManager + 600);
  if ((int)PrimaryResourcePointer[1] != ConfigurationDataPointer) {
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
    resourceCreationFlags = 0;
    *PrimaryResourcePointer = 0;
    if (ConfigurationDataPointer != 0) {
      resourceCreationFlags = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)ConfigurationDataPointer << 6,0x10,4);
    }
    **(void* **)(SystemResourceManager + 600) = resourceCreationFlags;
    *(int *)(*(long long *)(SystemResourceManager + 600) + 8) = ConfigurationDataPointer;
  }
  return;
}




// 函数: void ProcessSystemResourceManagerFinal(long long SystemResourceManager,char ConfigurationDataPointer)
void ProcessSystemResourceManagerFinal(long long SystemResourceManager,char ConfigurationDataPointer)

{
  byte isByteValid;
  long long SystemThreadHandle;
  long long *SystemResourceOffsetPointer;
  uint8_t StackBuffer40 [8];
  long long longValue38;
  uint32_t SystemResourceStatusFlag;
  long long *pLocalMemoryAddress;
  
  if (*(char *)(SystemResourceManager + 0xf4) == ConfigurationDataPointer) {
    return;
  }
  SystemThreadHandle = 0;
  if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) != 0) {
    CleanupSystemResources();
    do {
      *(char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x14 + SystemThreadHandle) = ConfigurationDataPointer;
      SystemThreadHandle = SystemThreadHandle + 0x18;
    } while (SystemThreadHandle < 0x180);
  }
  pLocalMemoryAddress = (long long *)0x0;
  StackBuffer40[0] = 0;
  SystemResourceStatusFlag = 1;
  longValue38 = SystemResourceManager;
  InitializeSystemResourceEncryption(StackBuffer40);
  if (pLocalMemoryAddress == (long long *)0x0) goto LAB_18007eb55;
  SystemResourceOffsetPointer = pLocalMemoryAddress;
  if (ConfigurationDataPointer != '\0') {
    if ((ConfigurationDataPointer != '\x01') || ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0)) goto LAB_18007eb55;
    SystemThreadHandle = *(long long *)(SystemResourceManager + 0x1b8);
    isByteValid = *(byte *)(SystemThreadHandle + 0x38c);
    if (isByteValid == 9) {
      isByteValid = func_0x00018022d300();
      *(byte *)(SystemThreadHandle + 0x38c) = isByteValid;
    }
    SystemResourceOffsetPointer = pLocalMemoryAddress;
    if ((*(char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + (ulong long)isByteValid * 0x18) != '\x03') &&
       (*(char *)(*(long long *)(SystemResourceManager + 0x1e0) + 0x15 + (ulong long)isByteValid * 0x18) != '\x02'))
    goto LAB_18007eb55;
  }
  pLocalMemoryAddress = (long long *)0x0;
  if (SystemResourceOffsetPointer != (long long *)0x0) {
    (**(code **)(*SystemResourceOffsetPointer + 0x38))();
  }
LAB_18007eb55:
  *(char *)(SystemResourceManager + 0xf4) = ConfigurationDataPointer;
  CleanupSystemResourceEncryption(StackBuffer40);
  if (pLocalMemoryAddress != (long long *)0x0) {
    (**(code **)(*pLocalMemoryAddress + 0x38))();
  }
  return;
}




/**
 * @brief 系统资源配置函数
 * 
 * 该函数负责配置系统资源，包括内存分配、资源链接和初始化设置
 * 用于系统资源的动态配置和管理
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置结果代码指针
 * 
 *FUN_18007eb80：ConfigureSystemResources
 */
code * ConfigureSystemResources(long long SystemResourceManager,char ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  code *ResultCode;
  void* AllocatedMemory;
  code *ResourcePointer;
  long long* SystemMemoryPointer;
  long long LocalContext;
  uint32_t ConfigurationFlags;
  code *FunctionPointer1;
  code *FunctionPointer2;
  
  ResourcePointer = (code *)(SystemResourceManager + 0x210);
  if (*(long long *)ResourcePointer == 0) {
    if ((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0) {
      LocalContext = func_0x000180085de0(*(void* *)(SystemResourceManager + 0x1b0));
      if (LocalContext != SystemResourceManager) {
        ConfigurationFlags = 0;
        InitializeSystemContext(&LocalContext);
        AllocatedMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xf0,8,3);
        AllocatedMemory = GetMemoryPointer(AllocatedMemory);
        SystemResourceManagerLink(ResourcePointer,AllocatedMemory);
        CopyMemoryData(*(long long *)ResourcePointer + 0x10,(long long)FunctionPointer1 + 0x10);
        CopyMemoryData(*(long long *)ResourcePointer + 0x38,(long long)FunctionPointer1 + 0x38);
        CopyMemoryOffset(*(long long *)ResourcePointer + 0x60,(long long)FunctionPointer1 + 0x60);
        CopyMemorySection(*(long long *)ResourcePointer + 0x88,(long long)FunctionPointer1 + 0x88);
        if (ConfigurationDataPointer != '\0') {
          *(byte *)(SystemResourceManager + 0xfd) = *(byte *)(SystemResourceManager + 0xfd) | 0x40;
          CopyMemoryChunk(*(long long *)ResourcePointer + 200,(long long)FunctionPointer1 + 200);
          CopyMemoryBlock(*(long long *)ResourcePointer + 0xb0,(long long)FunctionPointer1 + 0xb0);
        }
        ResultCode = (code *)ProcessSystemStatus(&LocalContext);
        return ResultCode;
      }
    }
    if (*(long long *)(SystemResourceManager + 0xa8) == 0) {
      if ((*(byte *)(SystemResourceManager + 0xfd) & 4) != 0) {
        AllocatedMemory = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xf0,8,3);
        PrimaryResourcePointer = (long long *)GetMemoryPointer(AllocatedMemory);
        FunctionPointer2 = (code *)0xfffffffffffffffe;
        if (PrimaryResourcePointer != (long long *)0x0) {
          (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
        }
        PrimaryResourcePointer = *(long long **)ResourcePointer;
        *(long long **)ResourcePointer = PrimaryResourcePointer;
        if (PrimaryResourcePointer != (long long *)0x0) {
          (**(code **)(*PrimaryResourcePointer + 0x38))();
        }
        return ResourcePointer;
      }
      InitializeSystemResource(&SystemResourceInitializer);
      ResultCode = (code *)AllocateSystemMemory(&SystemFunctionAllocator);
    }
    else {
      PrimaryResourcePointer = *(long long **)(*(long long *)(SystemResourceManager + 0xa8) + 0x88);
      FunctionPointer1 = (code *)&SystemEntryPoint;
      FunctionPointer2 = SystemMainFunction;
      LocalContext = SystemResourceManager;
      (**(code **)(*PrimaryResourcePointer + 0x60))(PrimaryResourcePointer,&GAME_CORE_SYSTEM_ID,SystemResourceManager + 0xb8,0,&LocalContext);
      ResultCode = FunctionPointer1;
      if (FunctionPointer1 != (code *)0x0) {
        ResourcePointer = (code *)(*FunctionPointer1)(&LocalContext,0,0);
        return ResourcePointer;
      }
    }
  }
  return ResultCode;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，包括内存释放和状态重置
 * 用于系统资源的清理和释放操作
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * 
 *FUN_18007edd0：CleanupSystemResources
 */
void CleanupSystemResources(long long SystemResourceManager,char ConfigurationDataPointer)

{
  long long *ResourceToRelease;
  
  if (*(long long *)(SystemResourceManager + 0x210) != 0) {
    ValidateSystemString();
    if (ConfigurationDataPointer != '\0') {
      *(byte *)(SystemResourceManager + 0xfd) = *(byte *)(SystemResourceManager + 0xfd) | 0x20;
      *(byte *)(SystemResourceManager + 0xfe) = *(byte *)(SystemResourceManager + 0xfe) | 1;
      CleanupSystemResources(SystemResourceManager);
    }
    if (((*(char *)(SystemResourceManager + 0xfc) == '\0') && (*(char *)(SystemResourceManager + 0xf4) == '\0')) &&
       (((*(byte *)(SystemResourceManager + 0xfd) & 0x20) == 0 || ((*(byte *)(SystemResourceManager + 0xfe) & 1) == 0)))) {
      ResourceToRelease = *(long long **)(SystemResourceManager + 0x210);
      *(void* *)(SystemResourceManager + 0x210) = 0;
      if (ResourceToRelease != (long long *)0x0) {
                    00018007ee5b. Too many branches
                            (**(code **)(*ResourceToRelease + 0x38))();
        return;
      }
    }
  }
  return;
}





/**
 * @brief 系统状态检查函数
 * 
 * 该函数负责检查系统状态，验证系统配置和资源状态
 * 用于系统状态监控和验证
 * 
 * @param SystemResourceManager 系统资源指针
 * 
 *FUN_18007ee70：CheckSystemStatus
 */
void CheckSystemStatus(long long SystemResourceManager)

{
  int StatusFlags;
  uint ResourceCount;
  void* ResourcePointer;
  int SystemIndex;
  uint ConfigurationFlags;
  uint MemoryFlags;
  int MemoryOffset;
  uint ValidationFlags;
  long long ResourceHandle;
  long long AllocationContext;
  ulong long SystemTimestamp;
  void* *ResourceArray;
  ulong long SystemOperationStatus3;
  ulong long SystemOperationStatus4;
  long long resourceDataIndex5;
  
  SystemAllocationFlags = *(long long *)(SystemResourceManager + 0x2d0);
  SystemOperationStatus = *(int *)(SystemGlobalStatusFlags + 0x224);
  if (*(int *)(SystemAllocationFlags + 0xc) != SystemOperationStatus) {
    if (*(int *)(SystemAllocationFlags + 8) < 1) {
      if (*(int *)(SystemAllocationFlags + 0xc) == SystemOperationStatus + -1) {
        ResourceHash = *(int *)(SystemDataMemoryContext + 0x9c8) + 1U & 0x80000001;
        if ((int)ResourceHash < 0) {
          ResourceHash = (ResourceHash - 1 | 0xfffffffe) + 1;
        }
        resourceDataIndex5 = (long long)(int)ResourceHash * 0x488 + SystemDataMemoryContext + 0xb8;
        resourceCounter = (long long)*(int *)(SystemDataMemoryContext + 0x9c8) * 0x488 + SystemDataMemoryContext + 0xb8;
        SystemOperationStatus4 = GetResourceIdentifier(resourceCounter,*(uint32_t *)(SystemAllocationFlags + 0x14));
        systemOffset = (int)SystemOperationStatus4;
        SystemOperationStatus1 = SystemOperationStatus4 & MAX_UNSIGNED_32_BIT;
        if (-1 < systemOffset) {
          SystemOperationStatus3 = SystemOperationStatus4 >> 0xb & BIT_MASK_32_BITffff;
          ResourceHash = *(uint *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x14);
          SystemOperationStatus4 = (ulong long)ResourceHash;
          resourceCreationFlags = *(uint *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x18);
          currentThreadId = (uint)SystemOperationStatus3;
          if (currentThreadId == ResourceHash + systemOffset >> 0xb) {
            OperationCode = resourceCreationFlags >> 0xb;
            if (OperationCode == resourceCreationFlags + ResourceHash >> 0xb) {
                memcpy(*(long long *)(resourceCounter + 8 + SystemOperationStatus3 * 8) + (ulong long)(systemOffset + currentThreadId * -0x800) * 8
                     ,*(long long *)(resourceDataIndex5 + 8 + (ulong long)OperationCode * 8) +
                      (ulong long)(resourceCreationFlags + OperationCode * -0x800) * 8,(long long)(int)ResourceHash << 3);
            }
          }
          if (0 < (int)ResourceHash) {
            do {
              systemIndex = (int)SystemOperationStatus1;
              currentThreadId = (resourceCreationFlags - systemOffset) + systemIndex;
              ResourceHash = currentThreadId >> 0xb;
              SystemOperationStatus3 = SystemOperationStatus1 >> 0xb;
              SystemOperationStatus1 = (ulong long)(systemIndex + 1);
              *(void* *)
               (*(long long *)(resourceCounter + 8 + SystemOperationStatus3 * 8) +
               (ulong long)(uint)(systemIndex + (int)SystemOperationStatus3 * -0x800) * 8) =
                   *(void* *)
                    (*(long long *)(resourceDataIndex5 + 8 + (ulong long)ResourceHash * 8) +
                    (ulong long)(currentThreadId + ResourceHash * -0x800) * 8);
              SystemOperationStatus4 = SystemOperationStatus4 - 1;
            } while (SystemOperationStatus4 != 0);
          }
          *(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x18) = systemOffset;
          *(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 0xc) = SystemOperationStatus;
        }
      }
      else {
        *(uint32_t *)(SystemAllocationFlags + 0x14) = 0;
      }
    }
    else {
      SystemAllocationFlags = (long long)*(int *)(SystemDataMemoryContext + 0x9c8) * 0x488 + SystemDataMemoryContext + 0xb8;
      currentThreadId = GetResourceIdentifier(SystemAllocationFlags);
      resourceCreationFlags = currentThreadId >> 0xb;
      ResourceHash = *(uint *)(*(void* **)(SystemResourceManager + 0x2d0) + 1);
      SystemOperationStatus4 = (ulong long)ResourceHash;
      pSystemSecondaryStatus = (void* *)**(void* **)(SystemResourceManager + 0x2d0);
      if (resourceCreationFlags == ResourceHash + currentThreadId >> 0xb) {
          memcpy(*(long long *)(SystemAllocationFlags + 8 + (ulong long)resourceCreationFlags * 8) +
               (ulong long)(currentThreadId + resourceCreationFlags * -0x800) * 8,pSystemSecondaryStatus,(ulong long)ResourceHash << 3);
      }
      resourceCreationFlags = currentThreadId;
      if (ResourceHash != 0) {
        do {
          resourceAllocationContext = *pSystemSecondaryStatus;
          pSystemSecondaryStatus = pSystemSecondaryStatus + 1;
          *(void* *)
           (*(long long *)(SystemAllocationFlags + 8 + (ulong long)(resourceCreationFlags >> 0xb) * 8) +
           (ulong long)(resourceCreationFlags + (resourceCreationFlags >> 0xb) * -0x800) * 8) = resourceAllocationContext;
          SystemOperationStatus4 = SystemOperationStatus4 - 1;
          resourceCreationFlags = resourceCreationFlags + 1;
        } while (SystemOperationStatus4 != 0);
      }
      *(uint32_t *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x14) =
           *(uint32_t *)(*(long long *)(SystemResourceManager + 0x2d0) + 8);
      *(uint *)(*(long long *)(SystemResourceManager + 0x2d0) + 0x18) = currentThreadId;
      *(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 0xc) = SystemOperationStatus;
    }
  }
  return;
}





// 函数: void ProcessSystemResourceManagerExtended(long long SystemResourceManager,int ConfigurationDataPointer,int AdditionalParameter)
void ProcessSystemResourceManagerExtended(long long SystemResourceManager,int ConfigurationDataPointer,int AdditionalParameter)

{
  uint SystemOperationStatus;
  void* resourceCreationFlags;
  int NodeIdentifierComparisonResult;
  uint resourceAddress;
  uint currentThreadId;
  int CalculationFlags;
  uint SystemLoopCounter;
  long long memoryBlockAddress;
  int unaff_EBP;
  long long SystemMemoryAddress;
  ulong long ThreadContextFlag;
  void* *SystemDataPointer0;
  ulong long SystemOperationStatus1;
  ulong long SystemSecondaryStatus;
  long long resourceDataIndex3;
  
  if (ConfigurationDataPointer < 1) {
    if (AdditionalParameter == unaff_EBP + -1) {
      currentThreadId = *(int *)(SystemDataMemoryContext + 0x9c8) + 1U & 0x80000001;
      if ((int)currentThreadId < 0) {
        currentThreadId = (currentThreadId - 1 | 0xfffffffe) + 1;
      }
      resourceDataIndex3 = (long long)(int)currentThreadId * 0x488 + SystemDataMemoryContext + 0xb8;
      SystemMemoryAddress = (long long)*(int *)(SystemDataMemoryContext + 0x9c8) * 0x488 + SystemDataMemoryContext + 0xb8;
      SystemSecondaryStatus = GetResourceIdentifier(SystemMemoryAddress,*(uint32_t *)(SystemResourceManager + 0x14));
      CalculationFlags = (int)SystemSecondaryStatus;
      ThreadContextFlag = SystemSecondaryStatus & MAX_UNSIGNED_32_BIT;
      if (-1 < CalculationFlags) {
        SystemOperationStatus1 = SystemSecondaryStatus >> 0xb & BIT_MASK_32_BITffff;
        currentThreadId = *(uint *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14);
        SystemSecondaryStatus = (ulong long)currentThreadId;
        SystemOperationStatus = *(uint *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x18);
        resourceAddress = (uint)SystemOperationStatus1;
        if (resourceAddress == currentThreadId + CalculationFlags >> 0xb) {
          ThreadContextFlag = SystemOperationStatus >> 0xb;
          if (ThreadContextFlag == SystemOperationStatus + currentThreadId >> 0xb) {
              memcpy(*(long long *)(SystemMemoryAddress + 8 + SystemOperationStatus1 * 8) + (ulong long)(CalculationFlags + resourceAddress * -0x800) * 8,
                   *(long long *)(resourceDataIndex3 + 8 + (ulong long)ThreadContextFlag * 8) +
                   (ulong long)(SystemOperationStatus + ThreadContextFlag * -0x800) * 8,(long long)(int)currentThreadId << 3);
          }
        }
        if (0 < (int)currentThreadId) {
          do {
            systemCounter = (int)ThreadContextFlag;
            resourceAddress = (SystemOperationStatus - CalculationFlags) + systemCounter;
            currentThreadId = resourceAddress >> 0xb;
            SystemOperationStatus1 = ThreadContextFlag >> 0xb;
            ThreadContextFlag = (ulong long)(systemCounter + 1);
            *(void* *)
             (*(long long *)(SystemMemoryAddress + 8 + SystemOperationStatus1 * 8) +
             (ulong long)(uint)(systemCounter + (int)SystemOperationStatus1 * -0x800) * 8) =
                 *(void* *)
                  (*(long long *)(resourceDataIndex3 + 8 + (ulong long)currentThreadId * 8) +
                  (ulong long)(resourceAddress + currentThreadId * -0x800) * 8);
            SystemSecondaryStatus = SystemSecondaryStatus - 1;
          } while (SystemSecondaryStatus != 0);
        }
        *(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x18) = CalculationFlags;
        *(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0xc) = unaff_EBP;
      }
    }
    else {
      *(uint32_t *)(SystemResourceManager + 0x14) = 0;
    }
  }
  else {
    SystemMemoryAddress = (long long)*(int *)(SystemDataMemoryContext + 0x9c8) * 0x488 + SystemDataMemoryContext + 0xb8;
    resourceAddress = GetResourceIdentifier(SystemMemoryAddress);
    SystemOperationStatus = resourceAddress >> 0xb;
    currentThreadId = *(uint *)(*(void* **)(memoryBlockAddress + 0x2d0) + 1);
    SystemSecondaryStatus = (ulong long)currentThreadId;
    SystemDataPointer0 = (void* *)**(void* **)(memoryBlockAddress + 0x2d0);
    if (SystemOperationStatus == currentThreadId + resourceAddress >> 0xb) {
        memcpy(*(long long *)(SystemMemoryAddress + 8 + (ulong long)SystemOperationStatus * 8) +
             (ulong long)(resourceAddress + SystemOperationStatus * -0x800) * 8,SystemDataPointer0,(ulong long)currentThreadId << 3);
    }
    SystemOperationStatus = resourceAddress;
    if (currentThreadId != 0) {
      do {
        resourceCreationFlags = *SystemDataPointer0;
        SystemDataPointer0 = SystemDataPointer0 + 1;
        *(void* *)
         (*(long long *)(SystemMemoryAddress + 8 + (ulong long)(SystemOperationStatus >> 0xb) * 8) +
         (ulong long)(SystemOperationStatus + (SystemOperationStatus >> 0xb) * -0x800) * 8) = resourceCreationFlags;
        SystemSecondaryStatus = SystemSecondaryStatus - 1;
        SystemOperationStatus = SystemOperationStatus + 1;
      } while (SystemSecondaryStatus != 0);
    }
    *(uint32_t *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14) =
         *(uint32_t *)(*(long long *)(memoryBlockAddress + 0x2d0) + 8);
    *(uint *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x18) = resourceAddress;
    *(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0xc) = unaff_EBP;
  }
  return;
}




// 函数: void ProcessSystemResourceManagerConfiguration(long long SystemResourceManager,long long ConfigurationDataPointer)
void ProcessSystemResourceManagerConfiguration(long long SystemResourceManager,long long ConfigurationDataPointer)

{
  uint SystemOperationStatus;
  int systemResult;
  uint resourceAllocationContext;
  int systemIndex;
  ulong long currentThreadId;
  uint ResourceHash;
  uint SystemLoopCounter;
  long long memoryBlockAddress;
  uint32_t unaff_EBP;
  ulong long OperationCode;
  ulong long ThreadContextFlag;
  long long SystemAllocationFlags;
  
  resourceAllocationContext = *(int *)(ConfigurationDataPointer + 0x910) + 1U & 0x80000001;
  if ((int)resourceAllocationContext < 0) {
    resourceAllocationContext = (resourceAllocationContext - 1 | 0xfffffffe) + 1;
  }
  SystemAllocationFlags = (long long)(int)resourceAllocationContext * 0x488 + ConfigurationDataPointer;
  ConfigurationDataPointer = (long long)*(int *)(ConfigurationDataPointer + 0x910) * 0x488 + ConfigurationDataPointer;
  currentThreadId = GetResourceIdentifier(ConfigurationDataPointer,*(uint32_t *)(SystemResourceManager + 0x14));
  systemIndex = (int)currentThreadId;
  OperationCode = currentThreadId & MAX_UNSIGNED_32_BIT;
  if (-1 < systemIndex) {
    ThreadContextFlag = currentThreadId >> 0xb & BIT_MASK_32_BITffff;
    resourceAllocationContext = *(uint *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x14);
    currentThreadId = (ulong long)resourceAllocationContext;
    SystemOperationStatus = *(uint *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x18);
    ThreadContextFlag = (uint)ThreadContextFlag;
    if (ThreadContextFlag == resourceAllocationContext + systemIndex >> 0xb) {
      ResourceHash = SystemOperationStatus >> 0xb;
      if (ResourceHash == SystemOperationStatus + resourceAllocationContext >> 0xb) {
          memcpy(*(long long *)(ConfigurationDataPointer + 8 + ThreadContextFlag * 8) + (ulong long)(systemIndex + ThreadContextFlag * -0x800) * 8,
               *(long long *)(SystemAllocationFlags + 8 + (ulong long)ResourceHash * 8) +
               (ulong long)(SystemOperationStatus + ResourceHash * -0x800) * 8,(long long)(int)resourceAllocationContext << 3);
      }
    }
    if (0 < (int)resourceAllocationContext) {
      do {
        systemResult = (int)OperationCode;
        ThreadContextFlag = (SystemOperationStatus - systemIndex) + systemResult;
        resourceAllocationContext = ThreadContextFlag >> 0xb;
        ThreadContextFlag = OperationCode >> 0xb;
        OperationCode = (ulong long)(systemResult + 1);
        *(void* *)
         (*(long long *)(ConfigurationDataPointer + 8 + ThreadContextFlag * 8) +
         (ulong long)(uint)(systemResult + (int)ThreadContextFlag * -0x800) * 8) =
             *(void* *)
              (*(long long *)(SystemAllocationFlags + 8 + (ulong long)resourceAllocationContext * 8) +
              (ulong long)(ThreadContextFlag + resourceAllocationContext * -0x800) * 8);
        currentThreadId = currentThreadId - 1;
      } while (currentThreadId != 0);
    }
    *(int *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0x18) = systemIndex;
    *(uint32_t *)(*(long long *)(memoryBlockAddress + 0x2d0) + 0xc) = unaff_EBP;
  }
  return;
}




/**
 * @brief 系统空操作函数G
 * 
 * 该函数是一个空操作函数，不做任何实际操作
 * 
 * @return 无返回值
 * 
 *FUN_18007f0b5：SystemNoOperationG
 */
void SystemNoOperationG(void)

{
  return;
}




/**
 * @brief 系统空操作函数H
 * 
 * 该函数是一个空操作函数，不做任何实际操作
 * 
 * @return 无返回值
 * 
 *FUN_18007f0bf：SystemNoOperationH
 */
void SystemNoOperationH(void)

{
  return;
}




/**
 * @brief 重置系统资源管理器状态标志
 * 
 * 该函数负责重置系统资源管理器的状态标志，将状态标志设置为0。
 * 这是一个简单的状态重置操作，用于初始化或清理系统状态。
 * 
 * @param SystemResourceManager 系统资源管理器指针，包含状态标志信息
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007f0ca
 */
void ResetSystemResourceManagerStatusFlags(long long SystemResourceManager)

{
  *(uint32_t *)(SystemResourceManager + 0x14) = 0;
  return;
}





// 函数: void ProcessSystemResourceManagerThread(long long SystemResourceManager,long long ConfigurationDataPointer,int AdditionalParameter)
void ProcessSystemResourceManagerThread(long long SystemResourceManager,long long ConfigurationDataPointer,int AdditionalParameter)

{
  int* SystemIntegerPointer;
  void** SystemDataTable;
  void* *SystemHashNodeData;
  void* *presourceAddress;
  uint currentThreadId;
  int *pointerToInteger7;
  long long SystemMemoryAddress;
  ulong long ThreadContextFlag;
  long long SystemAllocationFlags;
  void** SystemRootNode;
  
  ThreadContextFlag = (ulong long)AdditionalParameter;
  if (**(long long **)(SystemResourceManager + 0x2d0) != 0) {
      SystemCleanupFunction();
  }
  presourceAddress = (void* *)0x0;
  **(long long **)(SystemResourceManager + 0x2d0) = 0;
  if (0 < AdditionalParameter) {
    SystemHashEntryPointer = presourceAddress;
    if (AdditionalParameter != 0) {
      SystemHashEntryPointer = (void* *)CreateSystemThreadObject(SystemMemoryPoolTemplate,ThreadContextFlag * 8,3);
      SystemHashNodeData = SystemHashEntryPointer;
      resourceEntryPointer = presourceAddress;
      do {
        currentThreadId = (int)resourceEntryPointer + 1;
        resourceEntryPointer = (void* *)(ulong long)currentThreadId;
        *SystemHashNodeData = 0;
        SystemHashNodeData = SystemHashNodeData + 1;
      } while ((ulong long)(long long)(int)currentThreadId < ThreadContextFlag);
    }
    **(void* **)(SystemResourceManager + 0x2d0) = SystemHashEntryPointer;
    if (3 < (long long)ThreadContextFlag) {
      SystemAllocationFlags = -8 - ConfigurationDataPointer;
      SystemMemoryAddress = (ThreadContextFlag - 4 >> 2) + 1;
      presourceAddress = (void* *)(SystemMemoryAddress * 4);
      pointerToInteger7 = (int *)(ConfigurationDataPointer + 8);
      do {
        SystemIntegerPointer = pointerToInteger7 + 8;
        *(float *)((long long)pointerToInteger7 + **(long long **)(SystemResourceManager + 0x2d0) + SystemAllocationFlags) = (float)pointerToInteger7[-2]
        ;
        *(int *)((long long)pointerToInteger7 + **(long long **)(SystemResourceManager + 0x2d0) + 4 + SystemAllocationFlags) = pointerToInteger7[-1];
        *(float *)((long long)pointerToInteger7 + **(long long **)(SystemResourceManager + 0x2d0) + 8 + SystemAllocationFlags) =
             (float)*pointerToInteger7;
        *(int *)((long long)pointerToInteger7 + **(long long **)(SystemResourceManager + 0x2d0) + 0xc + SystemAllocationFlags) = pointerToInteger7[1];
        *(float *)((**(long long **)(SystemResourceManager + 0x2d0) - ConfigurationDataPointer) + -0x18 + (long long)SystemIntegerPointer) =
             (float)pointerToInteger7[2];
        *(int *)((long long)pointerToInteger7 + **(long long **)(SystemResourceManager + 0x2d0) + 0x14 + SystemAllocationFlags) = pointerToInteger7[3];
        *(float *)((**(long long **)(SystemResourceManager + 0x2d0) - ConfigurationDataPointer) + -0x10 + (long long)SystemIntegerPointer) =
             (float)pointerToInteger7[4];
        *(int *)((long long)pointerToInteger7 + **(long long **)(SystemResourceManager + 0x2d0) + 0x1c + SystemAllocationFlags) = pointerToInteger7[5];
        SystemMemoryAddress = SystemMemoryAddress + -1;
        pointerToInteger7 = SystemIntegerPointer;
      } while (SystemMemoryAddress != 0);
    }
    for (; (long long)presourceAddress < (long long)ThreadContextFlag; presourceAddress = (void* *)((long long)presourceAddress + 1)) {
      *(float *)(**(long long **)(SystemResourceManager + 0x2d0) + (long long)presourceAddress * 8) =
           (float)*(int *)(ConfigurationDataPointer + (long long)presourceAddress * 8);
      *(uint32_t *)(**(long long **)(SystemResourceManager + 0x2d0) + 4 + (long long)presourceAddress * 8) =
           *(uint32_t *)(ConfigurationDataPointer + 4 + (long long)presourceAddress * 8);
    }
    *(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 8) = AdditionalParameter;
    return;
  }
  *(int *)(*(long long *)(SystemResourceManager + 0x2d0) + 8) = AdditionalParameter;
  return;
}





// 函数: void InitializeSystemResourceManagerData(void)
void InitializeSystemResourceManagerData(void)

{
  int* SystemIntegerPointer;
  ulong long *SystemHashEntryPointer;
  ulong long *SystemHashNodeData;
  ulong long memoryBlockAddress;
  long long systemStackFramePtr;
  long long systemDataIndexPtr;
  uint resourceAddress;
  ulong long currentThreadId;
  int *pointerToInteger6;
  long long localDataIndex;
  ulong long systemResourceCounter;
  long long SystemMemoryAddress;
  bool in_ZF;
  
  if (in_ZF) {
    SystemHashEntryPointer = (ulong long *)(memoryBlockAddress & MAX_UNSIGNED_32_BIT);
  }
  else {
    SystemHashEntryPointer = (ulong long *)CreateSystemThreadObject(SystemMemoryPoolTemplate,systemResourceCounter * 8,3);
    currentThreadId = memoryBlockAddress & MAX_UNSIGNED_32_BIT;
    SystemHashNodeData = SystemHashEntryPointer;
    do {
      resourceAddress = (int)currentThreadId + 1;
      currentThreadId = (ulong long)resourceAddress;
      *SystemHashNodeData = memoryBlockAddress;
      SystemHashNodeData = SystemHashNodeData + 1;
    } while ((ulong long)(long long)(int)resourceAddress < systemResourceCounter);
  }
  **(long long **)(systemDataIndexPtr + 0x2d0) = (long long)SystemHashEntryPointer;
  if (3 < (long long)systemResourceCounter) {
    SystemMemoryAddress = -8 - systemStackFramePtr;
    localDataIndex = (systemResourceCounter - 4 >> 2) + 1;
    memoryBlockAddress = localDataIndex * 4;
    pointerToInteger6 = (int *)(systemStackFramePtr + 8);
    do {
      SystemIntegerPointer = pointerToInteger6 + 8;
      *(float *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + SystemMemoryAddress) = (float)pointerToInteger6[-2];
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 4 + SystemMemoryAddress) = pointerToInteger6[-1];
      *(float *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 8 + SystemMemoryAddress) = (float)*pointerToInteger6
      ;
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0xc + SystemMemoryAddress) = pointerToInteger6[1];
      *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x18 + (long long)SystemIntegerPointer) =
           (float)pointerToInteger6[2];
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x14 + SystemMemoryAddress) = pointerToInteger6[3];
      *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x10 + (long long)SystemIntegerPointer) =
           (float)pointerToInteger6[4];
      *(int *)((long long)pointerToInteger6 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x1c + SystemMemoryAddress) = pointerToInteger6[5];
      localDataIndex = localDataIndex + -1;
      pointerToInteger6 = SystemIntegerPointer;
    } while (localDataIndex != 0);
  }
  for (; (long long)memoryBlockAddress < (long long)systemResourceCounter; memoryBlockAddress = memoryBlockAddress + 1) {
    *(float *)(**(long long **)(systemDataIndexPtr + 0x2d0) + memoryBlockAddress * 8) =
         (float)*(int *)(systemStackFramePtr + memoryBlockAddress * 8);
    *(uint32_t *)(**(long long **)(systemDataIndexPtr + 0x2d0) + 4 + memoryBlockAddress * 8) =
         *(uint32_t *)(systemStackFramePtr + 4 + memoryBlockAddress * 8);
  }
  *(int *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = (int)systemResourceCounter;
  return;
}




// 函数: void ProcessSystemResourceManagerThreadData(void)
void ProcessSystemResourceManagerThreadData(void)

{
  int* SystemIntegerPointer;
  long long SystemThreadHandle;
  long long systemStackFramePtr;
  long long systemDataIndexPtr;
  int *pointerToInteger3;
  long long SystemBufferAddress;
  long long systemResourceCounter;
  long long SystemTimeValue;
  
  localSystemPointer = -8 - systemStackFramePtr;
  SystemBufferAddress = (systemResourceCounter - 4U >> 2) + 1;
  SystemThreadHandle = SystemBufferAddress * 4;
  pointerToInteger3 = (int *)(systemStackFramePtr + 8);
  do {
    SystemIntegerPointer = pointerToInteger3 + 8;
    *(float *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + localSystemPointer) = (float)pointerToInteger3[-2];
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 4 + localSystemPointer) = pointerToInteger3[-1];
    *(float *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 8 + localSystemPointer) = (float)*pointerToInteger3;
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0xc + localSystemPointer) = pointerToInteger3[1];
    *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x18 + (long long)SystemIntegerPointer) =
         (float)pointerToInteger3[2];
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x14 + localSystemPointer) = pointerToInteger3[3];
    *(float *)((**(long long **)(systemDataIndexPtr + 0x2d0) - systemStackFramePtr) + -0x10 + (long long)SystemIntegerPointer) =
         (float)pointerToInteger3[4];
    *(int *)((long long)pointerToInteger3 + **(long long **)(systemDataIndexPtr + 0x2d0) + 0x1c + localSystemPointer) = pointerToInteger3[5];
    SystemBufferAddress = SystemBufferAddress + -1;
    pointerToInteger3 = SystemIntegerPointer;
  } while (SystemBufferAddress != 0);
  for (; SystemThreadHandle < systemResourceCounter; SystemThreadHandle = SystemThreadHandle + 1) {
    *(float *)(**(long long **)(systemDataIndexPtr + 0x2d0) + SystemThreadHandle * 8) =
         (float)*(int *)(systemStackFramePtr + SystemThreadHandle * 8);
    *(uint32_t *)(**(long long **)(systemDataIndexPtr + 0x2d0) + 4 + SystemThreadHandle * 8) =
         *(uint32_t *)(systemStackFramePtr + 4 + SystemThreadHandle * 8);
  }
  *(int *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = (int)systemResourceCounter;
  return;
}




// 函数: void ProcessSystemResourceManagerMemory(void)
void ProcessSystemResourceManagerMemory(void)

{
  long long memoryBlockAddress;
  long long systemStackFramePtr;
  long long systemDataIndexPtr;
  long long systemResourceCounter;
  
  if (memoryBlockAddress < systemResourceCounter) {
    do {
      *(float *)(**(long long **)(systemDataIndexPtr + 0x2d0) + memoryBlockAddress * 8) =
           (float)*(int *)(systemStackFramePtr + memoryBlockAddress * 8);
      *(uint32_t *)(**(long long **)(systemDataIndexPtr + 0x2d0) + 4 + memoryBlockAddress * 8) =
           *(uint32_t *)(systemStackFramePtr + 4 + memoryBlockAddress * 8);
      memoryBlockAddress = memoryBlockAddress + 1;
    } while (memoryBlockAddress < systemResourceCounter);
  }
  *(int *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = (int)systemResourceCounter;
  return;
}




/**
 * @brief 设置系统资源计数器
 * 
 * 该函数负责设置系统资源计数器，将系统数据索引指针中的资源计数器更新为指定值。
 * 这是一个简单的计数器设置操作，用于管理系统资源的数量。
 * 
 * @param 无参数
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007f2cf
 */
void SetSystemResourceCounter(void)

{
  long long systemDataIndexPtr;
  uint32_t SystemResourceCounter;
  
  *(uint32_t *)(*(long long *)(systemDataIndexPtr + 0x2d0) + 8) = systemResourceCounterD;
  return;
}



/**
 * @brief 初始化系统资源管理器模板
 * 
 * 该函数用于初始化系统资源管理器的模板数据结构
 * 设置内存模板和资源管理器的基本配置
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @return 初始化后的系统资源管理器指针
 */
void* * InitializeSystemResourceManagerTemplate(void* *SystemResourceManager)

{
  *SystemResourceManager = &SystemMemoryTemplateA;
  *SystemResourceManager = &SystemMemoryTemplateB;
  *(uint32_t *)(SystemResourceManager + 1) = 0;
  *SystemResourceManager = &SystemResourceManagerTemplateB;
  SystemResourceManager[2] = 0;
  SystemResourceManager[3] = 0;
  *(uint8_t *)(SystemResourceManager + 6) = 3;
  SystemResourceManager[7] = 0;
  SystemResourceManager[8] = 0;
  *(uint8_t *)(SystemResourceManager + 0xb) = 3;
  SystemResourceManager[0xc] = 0;
  SystemResourceManager[0xd] = 0;
  *(uint8_t *)(SystemResourceManager + 0x10) = 3;
  SystemResourceManager[0x11] = 0;
  SystemResourceManager[0x12] = 0;
  *(uint8_t *)(SystemResourceManager + 0x15) = 3;
  *(void*2 *)(SystemResourceManager + 0x18) = 0;
  SystemResourceManager[0x16] = 0;
  SystemResourceManager[0x17] = 0;
  SystemResourceManager[0x19] = 0;
  SystemResourceManager[0x1a] = 0;
  *(uint8_t *)(SystemResourceManager + 0x1d) = 3;
  *(uint8_t *)(SystemResourceManager + 6) = 0xf;
  *(uint8_t *)(SystemResourceManager + 0xb) = 0xf;
  *(uint8_t *)(SystemResourceManager + 0x10) = 0xf;
  *(uint8_t *)(SystemResourceManager + 0x15) = 0xf;
  *(uint8_t *)(SystemResourceManager + 0x1d) = 0xf;
  return SystemResourceManager;
}



/**
 * @brief 配置系统资源管理器数据
 * 
 * 该函数用于配置系统资源管理器的数据结构
 * 根据配置数据指针设置资源管理器的参数
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @return 配置后的系统资源管理器指针
 */
void* * ConfigureSystemResourceManagerData(void* *SystemResourceManager,ulong long ConfigurationDataPointer)

{
  *SystemResourceManager = &SystemResourceManagerTemplateB;
  if (SystemResourceManager[0x1a] != 0) {
      SystemCleanupFunction();
  }
  ProcessSystemResourceIndex(SystemResourceManager[0x16]);
  SystemResourceManager[0x16] = 0;
  if (SystemResourceManager[0x17] != 0) {
      SystemCleanupFunction();
  }
  SystemResourceManager[0x17] = 0;
  if (SystemResourceManager[0x12] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[0xd] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[8] != 0) {
      SystemCleanupFunction();
  }
  if (SystemResourceManager[3] != 0) {
      SystemCleanupFunction();
  }
  *SystemResourceManager = &SystemMemoryTemplateB;
  *SystemResourceManager = &SystemMemoryTemplateA;
  if ((ConfigurationDataPointer & 1) != 0) {
    free(SystemResourceManager,0xf0);
  }
  return SystemResourceManager;
}





// 函数: void InitializeSystemResourceEncryption(uint8_t *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void InitializeSystemResourceEncryption(uint8_t *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  long long *resourcePoolPointer;
  long long *SystemResourceOffsetPointer;
  char SystemOperationStatusFlag;
  int systemValue;
  uint32_t ResourceHash;
  long long localDataIndex;
  void* *SystemThreadStorage;
  bool isSystemBusy;
  void* SystemOperationFlags;
  
  SystemOperationFlags = 0xfffffffffffffffe;
  isSystemBusy = false;
  if ((*(byte *)(*(long long *)(SystemResourceManager + 8) + 0xfd) & 0x20) != 0) {
    CleanupSystemResources();
    localDataIndex = 0;
    do {
      SystemOperationStatusFlag = *(char *)(*(long long *)(*(long long *)(SystemResourceManager + 8) + 0x1e0) + 0x15 + localDataIndex * 0x18);
      if (SystemOperationStatusFlag == '\x01') {
        Sleep(0);
        isSystemBusy = true;
      }
      resourceDataIndex = localDataIndex + 1;
      localDataIndex = 0;
      if (SystemOperationStatusFlag != '\x01') {
        localDataIndex = resourceDataIndex;
      }
    } while (localDataIndex < 0x10);
    if ((isSystemBusy) &&
       ((localDataIndex = *(long long *)(SystemResourceManager + 8), *(char *)(localDataIndex + 0xfa) == '\0' ||
        (*(char *)(localDataIndex + 0xfb) == '\0')))) {
      SystemThreadStorage = &SystemStringTemplate;
      if (*(void* **)(localDataIndex + 0x18) != (void* *)0x0) {
        SystemThreadStorage = *(void* **)(localDataIndex + 0x18);
      }
        UpdateContextManagerSystem(SystemContextManagerPointer,&SystemContextManagerTemplateA,SystemThreadStorage,ConfigurationFlag,SystemOperationFlags);
    }
  }
  localDataIndex = *(long long *)(SystemResourceManager + 8);
  while( true ) {
    LOCK();
    SystemOperationStatusFlag = *(char *)(localDataIndex + 0xec);
    isSystemBusy = SystemOperationStatusFlag == '\0';
    if (isSystemBusy) {
      *(char *)(localDataIndex + 0xec) = '\x01';
      SystemOperationStatusFlag = '\0';
    }
    UNLOCK();
    if (isSystemBusy) break;
    systemValue = _Thrd_id();
    if (*(int *)(localDataIndex + 0xf0) == systemValue) goto LAB_18007f5cb;
    Sleep();
  }
  SystemOperationStatusFlag = '\0';
LAB_18007f5cb:
  ResourceHash = _Thrd_id();
  *(uint32_t *)(localDataIndex + 0xf0) = ResourceHash;
  if (SystemOperationStatusFlag == '\0') {
    *SystemResourceManager = 1;
  }
  while (*(int *)(localDataIndex + 0xe8) != 0) {
    Sleep(0);
  }
  if ((*(uint *)(SystemResourceManager + 0x10) & 1) == 0) {
    ProcessSystemResourceData(*(void* *)(SystemResourceManager + 8),(byte)(*(uint *)(SystemResourceManager + 0x10) >> 2) & 1);
  }
  resourcePoolPointer = *(long long **)(*(long long *)(SystemResourceManager + 8) + 0x210);
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
  }
  SystemResourceOffsetPointer = *(long long **)(SystemResourceManager + 0x18);
  *(long long **)(SystemResourceManager + 0x18) = resourcePoolPointer;
  if (SystemResourceOffsetPointer != (long long *)0x0) {
    (**(code **)(*SystemResourceOffsetPointer + 0x38))();
  }
  return;
}




/**
 * @brief 系统状态更新函数
 * 
 * 该函数负责更新系统状态，处理系统事件和消息
 * 用于游戏运行时的状态管理和事件处理
 * 
 * @param SystemState 系统状态参数
 */
void UpdateSystemState(long long SystemState)

{
  CleanupSystemResourceEncryption();
  if (*(long long **)(SystemResourceManager + 0x18) != (long long *)0x0) {
    (**(code **)(**(long long **)(SystemResourceManager + 0x18) + 0x38))();
  }
  return;
}




// 函数: void CleanupSystemResourceEncryption(char *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)
void CleanupSystemResourceEncryption(char *SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long resourceDataIndex;
  long long *resourcePoolPointer;
  long long *SystemResourceOffsetPointer;
  long long SystemBufferAddress;
  void* currentThreadId;
  
  currentThreadId = 0xfffffffffffffffe;
  resourceDataIndex = *(long long *)(SystemResourceManager + 8);
  if (resourceDataIndex != 0) {
    resourcePoolPointer = *(long long **)(SystemResourceManager + 0x18);
    if (resourcePoolPointer != (long long *)0x0) {
      (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
    }
    SystemResourceOffsetPointer = *(long long **)(resourceDataIndex + 0x210);
    *(long long **)(resourceDataIndex + 0x210) = resourcePoolPointer;
    if (SystemResourceOffsetPointer != (long long *)0x0) {
      (**(code **)(*SystemResourceOffsetPointer + 0x38))();
    }
    resourceDataIndex = *(long long *)(SystemResourceManager + 8);
    if (*SystemResourceManager != '\0') {
      SystemBufferAddress = resourceDataIndex;
      if ((SystemResourceManager[0x10] & 2U) == 0) {
        ExecuteSystemOperation(resourceDataIndex);
        ExecuteSystemOperation(*(void* *)(SystemResourceManager + 8));
        SystemBufferAddress = *(long long *)(SystemResourceManager + 8);
      }
      ProcessSystemDataBuffer(SystemBufferAddress,1,AdditionalParameter,ConfigurationFlag,currentThreadId);
      *(uint32_t *)(resourceDataIndex + 0xf0) = 0;
      LOCK();
      *(uint8_t *)(resourceDataIndex + 0xec) = 0;
      UNLOCK();
    }
  }
  SystemResourceManager[8] = '\0';
  SystemResourceManager[9] = '\0';
  SystemResourceManager[10] = '\0';
  SystemResourceManager[0xb] = '\0';
  SystemResourceManager[0xc] = '\0';
  SystemResourceManager[0xd] = '\0';
  SystemResourceManager[0xe] = '\0';
  SystemResourceManager[0xf] = '\0';
  resourcePoolPointer = *(long long **)(SystemResourceManager + 0x18);
  SystemResourceManager[0x18] = '\0';
  SystemResourceManager[0x19] = '\0';
  SystemResourceManager[0x1a] = '\0';
  SystemResourceManager[0x1b] = '\0';
  SystemResourceManager[0x1c] = '\0';
  SystemResourceManager[0x1d] = '\0';
  SystemResourceManager[0x1e] = '\0';
  SystemResourceManager[0x1f] = '\0';
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))();
  }
  return;
}




/**
 * @brief 初始化系统线程同步器
 * 
 * 该函数负责初始化系统线程同步器，设置线程同步所需的锁和计数器。
 * 主要用于系统线程的同步和管理工作。
 * 
 * @param SystemResourceManager 系统资源指针，指向线程同步器数据结构
 * 
 *FUN_18007f770：InitializeSystemThreadSynchronizer
 */
void InitializeSystemThreadSynchronizer(long long* SystemResourceManager)

{
  long long resourceDataIndex;
  char validationStatusFlag;
  int NodeIdentifierComparisonResult;
  bool isResourceAvailable;
  
  resourceDataIndex = *SystemResourceManager;
  systemCounter = _Thrd_id();
  while( true ) {
    LOCK();
    SystemOperationResult = *(char *)(resourceDataIndex + 0xec);
    isResourceAvailable = SystemOperationResult == '\0';
    if (isResourceAvailable) {
      *(char *)(resourceDataIndex + 0xec) = '\x01';
      validationStatusFlag = '\0';
    }
    UNLOCK();
    if (isResourceAvailable) break;
    if (*(int *)(resourceDataIndex + 0xf0) == systemCounter) goto LAB_18007f7cf;
    Sleep(0);
  }
  validationStatusFlag = '\0';
LAB_18007f7cf:
  LOCK();
  *(int *)(resourceDataIndex + 0xe8) = *(int *)(resourceDataIndex + 0xe8) + 1;
  UNLOCK();
  if ((*(uint *)(SystemResourceManager + 1) & 1) == 0) {
    ProcessSystemResourceData(*SystemResourceManager,(byte)(*(uint *)(SystemResourceManager + 1) >> 2) & 1);
  }
  if (validationStatusFlag == '\0') {
    LOCK();
    *(uint8_t *)(resourceDataIndex + 0xec) = 0;
    UNLOCK();
  }
  SystemResourceManager[2] = *(long long *)(*SystemResourceManager + 0x210);
  return;
}




/**
 * @brief 执行系统资源处理操作
 * 
 * 该函数负责执行系统资源处理操作，调用系统资源处理函数来完成相关操作。
 * 这是一个包装函数，用于简化系统资源处理的调用。
 * 
 * @param 无参数
 * @return 无返回值
 * 
 * 原始函数名：FUN_18007f820
 */
void ExecuteSystemResourceProcessingOperation(void)

{
  ProcessSystemStatus();
  return;
}




/**
 * @brief 系统资源句柄处理函数
 * 
 * 该函数负责处理系统资源句柄的操作，包括句柄的验证、索引和状态检查。
 * 它会遍历资源句柄数组，检查每个句柄的有效性，并进行相应的处理。
 * 
 * @param SystemResourceManager 系统资源指针，包含资源句柄信息
 * 
 *FUN_18007f840：ProcessSystemResourceHandle
 */
void ProcessSystemResourceHandle(long long* SystemResourceManager)

{
  int *ResourceIndexPointer;
  long long SystemHandle;
  char SystemStatus;
  int ResourceIndex;
  bool IsHandleAvailable;
  
  SystemHandle = *SystemResourceManager;
  if (SystemHandle != 0) {
    while( true ) {
      LOCK();
      SystemStatus = *(char *)(SystemHandle + 0xec);
      IsHandleAvailable = SystemStatus == '\0';
      if (IsHandleAvailable) {
        *(char *)(SystemHandle + 0xec) = '\x01';
        SystemStatus = '\0';
      }
      UNLOCK();
      if (IsHandleAvailable) break;
      ResourceIndex = _Thrd_id();
      if ((*(int *)(SystemHandle + 0xf0) == ResourceIndex) || (*(int *)(SystemHandle + 0xf0) != 0)) goto LAB_18007f89f;
      Sleep();
    }
    SystemStatus = '\0';
LAB_18007f89f:
    LOCK();
    ResourceIndexPointer = (int *)(SystemHandle + 0xe8);
    ResourceIndex = *ResourceIndexPointer;
    *ResourceIndexPointer = *ResourceIndexPointer + -1;
    UNLOCK();
    if (SystemStatus == '\0') {
      if (ResourceIndex == 1) {
        ProcessSystemDataBuffer(*SystemResourceManager,0);
      }
      LOCK();
      *(uint8_t *)(SystemHandle + 0xec) = 0;
      UNLOCK();
    }
    *SystemResourceManager = 0;
  }
  return;
}



uint GetSystemResourceStatusFlag(void)

{
  uint *SystemDataPointer;
  byte isSystemActive;
  char characterProcessingFlag;
  int systemIndex;
  uint currentThreadId;
  long long memoryBlockAddress;
  void* *StringIteratorPointer;
  bool isThreadActive;
  
  while( true ) {
    LOCK();
    charFlag = *(char *)(memoryBlockAddress + 0xec);
    isThreadActive = charFlag == '\0';
    if (isThreadActive) {
      *(char *)(memoryBlockAddress + 0xec) = '\x01';
      charFlag = '\0';
    }
    UNLOCK();
    if (isThreadActive) break;
    systemIndex = _Thrd_id();
    if ((*(int *)(memoryBlockAddress + 0xf0) == systemIndex) || (*(int *)(memoryBlockAddress + 0xf0) != 0))
    goto LAB_18007f89f;
    Sleep();
  }
  charFlag = '\0';
LAB_18007f89f:
  LOCK();
  SystemDataPointer = (uint *)(memoryBlockAddress + 0xe8);
  currentThreadId = *SystemDataPointer;
  *SystemDataPointer = *SystemDataPointer - 1;
  UNLOCK();
  if (characterProcessingFlag == '\0') {
    if (currentThreadId == 1) {
      ProcessSystemDataBuffer(*StringIteratorPointer,0);
    }
    LOCK();
    isSystemActive = *(byte *)(memoryBlockAddress + 0xec);
    *(byte *)(memoryBlockAddress + 0xec) = 0;
    currentThreadId = (uint)isSystemActive;
    UNLOCK();
  }
  *StringIteratorPointer = 0;
  return currentThreadId;
}



/**
 * @brief 获取系统操作状态
 * 
 * 该函数用于获取系统的操作状态，并重置状态标志
 * 用于系统状态监控和管理
 * 
 * @return 系统操作状态码
 */
uint8_t GetSystemOperationStatus(void)

{
  uint8_t SystemOperationStatus;
  int in_EAX;
  long long memoryBlockAddress;
  void* *StringIteratorPointer;
  
  if (in_EAX == 1) {
    ProcessSystemDataBuffer(*StringIteratorPointer,0);
  }
  LOCK();
  SystemOperationStatus = *(uint8_t *)(memoryBlockAddress + 0xec);
  *(uint8_t *)(memoryBlockAddress + 0xec) = 0;
  UNLOCK();
  *StringIteratorPointer = 0;
  return SystemOperationStatus;
}





// 函数: void ProcessSystemResourceManagerPointer(long long SystemResourceManager)
void ProcessSystemResourceManagerPointer(long long SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char SystemOperationStatusFlag;
  uint32_t currentThreadId;
  uint ResourceHash;
  long long *plocalDataIndex;
  long long SystemMemoryAddress;
  int systemId;
  int SystemOperationStatus0;
  long long SystemResourceDataIndex;
  ulong long SystemSecondaryStatus;
  char *systemFunctionPointer3;
  uint *SystemThreadLocalStoragePointer;
  int SystemOperationStatus5;
  uint SystemOperationStatusFlags;
  int SystemOperationStatus7;
  int SystemOperationStatus8;
  uint32_t *SystemDataPointer9;
  uint *SystemHashEntryPointer0;
  ulong long ThreadCreationFlags;
  ulong long MemoryAllocationFlags;
  bool isSystemActive3;
  
  if (*(int *)(SystemResourceManager + 0x28) != *(int *)(SystemGlobalStatusFlags + 0x224)) {
    SystemOperationStatus5 = *(int *)(SystemResourceManager + 0x1c) + *(int *)(SystemResourceManager + 0x18);
    *(int *)(SystemResourceManager + 0x28) = *(int *)(SystemGlobalStatusFlags + 0x224);
    if (0 < SystemOperationStatus5) {
      SystemResourceDataIndex = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
      currentThreadId = AcquireResourceHandle(SystemResourceDataIndex,SystemOperationStatus5);
      *(uint32_t *)(SystemResourceManager + 0x30) = currentThreadId;
      ReleaseResourceHandle(SystemResourceDataIndex,currentThreadId);
      if (*(long long *)(SystemResourceManager + 0x10) == 0) {
        if (*(int *)(SystemResourceManager + 0x18) != 0) {
          *(uint32_t *)(SystemResourceManager + 0x2c) = *(uint32_t *)(SystemResourceManager + 0x30);
          return;
        }
      }
      else {
        SystemOperationStatusFlag = *(char *)(SystemResourceManager + 0x44);
        SystemSecondaryStatus = (ulong long)SystemOperationStatusFlag;
        PrimaryResourcePointer = (long long *)(SystemResourceManager + 0x38);
        SystemOperationStatus5 = (int)SystemOperationStatusFlag;
        if (*(int *)(SystemResourceManager + 0x40) == (int)SystemOperationStatusFlag) {
          plocalDataIndex = (long long *)*PrimaryResourcePointer;
        }
        else {
          *(int *)(SystemResourceManager + 0x40) = SystemOperationStatus5;
          if (*PrimaryResourcePointer != 0) {
              SystemCleanupFunction();
          }
          *PrimaryResourcePointer = 0;
          if (SystemOperationStatusFlag == '\0') {
            plocalDataIndex = (long long *)0x0;
            *PrimaryResourcePointer = 0;
          }
          else {
            plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)SystemOperationStatusFlag * 4);
            *PrimaryResourcePointer = (long long)plocalDataIndex;
          }
        }
        if (plocalDataIndex != (long long *)0x0) {
          SystemOperationStatus7 = 0;
          SystemOperationStatusFlags = (uint)SystemOperationStatusFlag;
          SystemOperationStatus8 = SystemOperationStatus7;
          if ((0 < SystemOperationStatus5) && (0xf < SystemOperationStatusFlags)) {
            SystemOperationStatus0 = *(int *)(SystemResourceManager + 0x2c);
            resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(SystemOperationStatusFlag + -1) * 4);
            if ((((long long *)(SystemResourceManager + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(SystemResourceManager + 0x2c)))
               && ((PrimaryResourcePointer < plocalDataIndex || (SystemOperationStatus8 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
              ResourceHash = SystemOperationStatusFlags & 0x8000000f;
              if ((int)ResourceHash < 0) {
                ResourceHash = (ResourceHash - 1 | 0xfffffff0) + 1;
              }
              plocalDataIndex = plocalDataIndex + 4;
              systemId = 8;
              do {
                *(int *)(plocalDataIndex + -4) = SystemOperationStatus7 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + -0x1c) = SystemOperationStatus7 + 1 + SystemOperationStatus0;
                *(int *)(plocalDataIndex + -3) = SystemOperationStatus7 + 2 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + -0x14) = SystemOperationStatus7 + 3 + SystemOperationStatus0;
                SystemOperationStatus7 = SystemOperationStatus7 + 0x10;
                *(int *)(plocalDataIndex + -2) = systemId + -4 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + SystemOperationStatus0;
                *(int *)(plocalDataIndex + -1) = systemId + -2 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + SystemOperationStatus0;
                *(int *)plocalDataIndex = systemId + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + SystemOperationStatus0;
                *(int *)(plocalDataIndex + 1) = systemId + 2 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + SystemOperationStatus0;
                *(int *)(plocalDataIndex + 2) = systemId + 4 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + SystemOperationStatus0;
                *(int *)(plocalDataIndex + 3) = systemId + 6 + SystemOperationStatus0;
                *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + SystemOperationStatus0;
                plocalDataIndex = plocalDataIndex + 8;
                systemId = systemId + 0x10;
                SystemOperationStatus8 = SystemOperationStatus7;
              } while (SystemOperationStatus7 < (int)(SystemOperationStatusFlags - ResourceHash));
            }
          }
          for (SystemResourceDataIndex = (long long)SystemOperationStatus8; SystemResourceDataIndex < (long long)SystemSecondaryStatus; SystemResourceDataIndex = SystemResourceDataIndex + 1) {
            SystemOperationStatus7 = *(int *)(SystemResourceManager + 0x2c) + SystemOperationStatus8;
            SystemOperationStatus8 = SystemOperationStatus8 + 1;
            *(int *)(*PrimaryResourcePointer + SystemResourceDataIndex * 4) = SystemOperationStatus7;
          }
          SystemOperationStatus8 = *(int *)(SystemResourceManager + 0x18);
          SystemOperationStatus7 = 0;
          if (0 < (long long)SystemOperationStatus8) {
            SystemResourceDataIndex = 0;
            do {
              SystemOperationStatus0 = *(int *)(SystemResourceManager + 0x30) + SystemOperationStatus7;
              SystemOperationStatus7 = SystemOperationStatus7 + 1;
              pisOperationComplete = (byte *)(*(long long *)(SystemResourceManager + 0x10) + SystemResourceDataIndex);
              SystemResourceDataIndex = SystemResourceDataIndex + 1;
              *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = SystemOperationStatus0;
            } while (SystemResourceDataIndex < SystemOperationStatus8);
          }
        }
        SystemThreadLocalStoragePointer = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 +
                          SystemDataMemoryContext + 0x9d0);
        if (SystemOperationStatus5 == 0) {
          SystemOperationStatusFlags = (int)SystemOperationStatusFlag - 1;
        }
        else {
          LOCK();
          SystemOperationStatusFlags = *SystemThreadLocalStoragePointer;
          *SystemThreadLocalStoragePointer = *SystemThreadLocalStoragePointer + (int)SystemOperationStatusFlag;
          UNLOCK();
          ThreadCreationFlags = (ulong long)(SystemOperationStatusFlags >> 0xb);
          MemoryAllocationFlags = (ulong long)(SystemOperationStatusFlag + -1 + SystemOperationStatusFlags >> 0xb);
          if (ThreadCreationFlags <= MemoryAllocationFlags) {
            systemFunctionPointer3 = (char *)((long long)SystemThreadLocalStoragePointer + ThreadCreationFlags + 0x108);
            SystemResourceDataIndex = (MemoryAllocationFlags - ThreadCreationFlags) + 1;
            SystemHashEntryPointer0 = SystemThreadLocalStoragePointer + ThreadCreationFlags * 2 + 2;
            do {
              SystemOperationStatus8 = (int)ThreadCreationFlags;
              if (*(long long *)SystemHashEntryPointer0 == 0) {
                SystemMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
                LOCK();
                isSystemActive3 = *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatus8 * 2 + 2) == 0;
                if (isSystemActive3) {
                  *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatus8 * 2 + 2) = SystemMemoryAddress;
                }
                UNLOCK();
                if (isSystemActive3) {
                  LOCK();
                  *(uint8_t *)((long long)SystemOperationStatus8 + 0x108 + (long long)SystemThreadLocalStoragePointer) = 0;
                  UNLOCK();
                }
                else {
                  if (SystemMemoryAddress != 0) {
                      SystemCleanupFunction();
                  }
                  do {
                  } while (*systemFunctionPointer3 != '\0');
                }
              }
              else {
                do {
                } while (*systemFunctionPointer3 != '\0');
              }
              ThreadCreationFlags = (ulong long)(SystemOperationStatus8 + 1);
              SystemHashEntryPointer0 = SystemHashEntryPointer0 + 2;
              systemFunctionPointer3 = systemFunctionPointer3 + 1;
              SystemResourceDataIndex = SystemResourceDataIndex + -1;
            } while (SystemResourceDataIndex != 0);
          }
        }
        SystemDataPointer9 = *(uint32_t **)(SystemResourceManager + 0x38);
        ResourceHash = SystemOperationStatusFlags >> 0xb;
        *(uint *)(SystemResourceManager + 0x2c) = SystemOperationStatusFlags;
        if (ResourceHash == (int)SystemOperationStatusFlag + SystemOperationStatusFlags >> 0xb) {
            memcpy(*(long long *)(SystemThreadLocalStoragePointer + (ulong long)ResourceHash * 2 + 2) +
                 (ulong long)(SystemOperationStatusFlags + ResourceHash * -0x800) * 4,SystemDataPointer9,(SystemSecondaryStatus & MAX_UNSIGNED_32_BIT) << 2);
        }
        if (SystemOperationStatus5 != 0) {
          SystemSecondaryStatus = SystemSecondaryStatus & MAX_UNSIGNED_32_BIT;
          do {
            currentThreadId = *SystemDataPointer9;
            SystemDataPointer9 = SystemDataPointer9 + 1;
            *(uint32_t *)
             (*(long long *)(SystemThreadLocalStoragePointer + (ulong long)(SystemOperationStatusFlags >> 0xb) * 2 + 2) +
             (ulong long)(SystemOperationStatusFlags + (SystemOperationStatusFlags >> 0xb) * -0x800) * 4) = currentThreadId;
            SystemSecondaryStatus = SystemSecondaryStatus - 1;
            SystemOperationStatusFlags = SystemOperationStatusFlags + 1;
          } while (SystemSecondaryStatus != 0);
        }
      }
    }
  }
  return;
}





// 函数: void ProcessSystemResourceManagerExtended(uint32_t SystemResourceManager)
void ProcessSystemResourceManagerExtended(uint32_t SystemResourceManager)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char SystemOperationStatusFlag;
  uint32_t currentThreadId;
  uint ResourceHash;
  long long *plocalDataIndex;
  long long SystemMemoryAddress;
  int systemId;
  int SystemOperationStatus0;
  long long SystemResourceDataIndex;
  ulong long SystemSecondaryStatus;
  char *systemFunctionPointer3;
  uint *SystemThreadLocalStoragePointer;
  int SystemOperationStatus5;
  uint SystemOperationStatusFlags;
  long long systemDataIndexPtr;
  int SystemOperationStatus7;
  int SystemOperationStatus8;
  uint32_t *SystemDataPointer9;
  uint *SystemHashEntryPointer0;
  ulong long ThreadCreationFlags;
  ulong long MemoryAllocationFlags;
  bool isSystemActive3;
  
  SystemOperationStatus5 = *(int *)(systemDataIndexPtr + 0x1c) + *(int *)(systemDataIndexPtr + 0x18);
  *(uint32_t *)(systemDataIndexPtr + 0x28) = SystemResourceManager;
  if (0 < SystemOperationStatus5) {
    SystemResourceDataIndex = (long long)*(int *)(SystemDataMemoryContext + 0xe78) * 0x128 + SystemDataMemoryContext + 0xc28;
    currentThreadId = AcquireResourceHandle(SystemResourceDataIndex,SystemOperationStatus5);
    *(uint32_t *)(systemDataIndexPtr + 0x30) = currentThreadId;
    ReleaseResourceHandle(SystemResourceDataIndex,currentThreadId);
    if (*(long long *)(systemDataIndexPtr + 0x10) == 0) {
      if (*(int *)(systemDataIndexPtr + 0x18) != 0) {
        *(uint32_t *)(systemDataIndexPtr + 0x2c) = *(uint32_t *)(systemDataIndexPtr + 0x30);
        return;
      }
    }
    else {
      SystemOperationStatusFlag = *(char *)(systemDataIndexPtr + 0x44);
      SystemSecondaryStatus = (ulong long)SystemOperationStatusFlag;
      PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
      SystemOperationStatus5 = (int)SystemOperationStatusFlag;
      if (*(int *)(systemDataIndexPtr + 0x40) == (int)SystemOperationStatusFlag) {
        plocalDataIndex = (long long *)*PrimaryResourcePointer;
      }
      else {
        *(int *)(systemDataIndexPtr + 0x40) = SystemOperationStatus5;
        if (*PrimaryResourcePointer != 0) {
            SystemCleanupFunction();
        }
        *PrimaryResourcePointer = 0;
        if (SystemOperationStatusFlag == '\0') {
          plocalDataIndex = (long long *)0x0;
          *PrimaryResourcePointer = 0;
        }
        else {
          plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)SystemOperationStatusFlag * 4);
          *PrimaryResourcePointer = (long long)plocalDataIndex;
        }
      }
      if (plocalDataIndex != (long long *)0x0) {
        SystemOperationStatus7 = 0;
        SystemOperationStatusFlags = (uint)SystemOperationStatusFlag;
        SystemOperationStatus8 = SystemOperationStatus7;
        if ((0 < SystemOperationStatus5) && (0xf < SystemOperationStatusFlags)) {
          SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
          resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(SystemOperationStatusFlag + -1) * 4);
          if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) ||
              (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c))) &&
             ((PrimaryResourcePointer < plocalDataIndex || (SystemOperationStatus8 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
            ResourceHash = SystemOperationStatusFlags & 0x8000000f;
            if ((int)ResourceHash < 0) {
              ResourceHash = (ResourceHash - 1 | 0xfffffff0) + 1;
            }
            plocalDataIndex = plocalDataIndex + 4;
            systemId = 8;
            do {
              *(int *)(plocalDataIndex + -4) = SystemOperationStatus7 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + -0x1c) = SystemOperationStatus7 + 1 + SystemOperationStatus0;
              *(int *)(plocalDataIndex + -3) = SystemOperationStatus7 + 2 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + -0x14) = SystemOperationStatus7 + 3 + SystemOperationStatus0;
              SystemOperationStatus7 = SystemOperationStatus7 + 0x10;
              *(int *)(plocalDataIndex + -2) = systemId + -4 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + SystemOperationStatus0;
              *(int *)(plocalDataIndex + -1) = systemId + -2 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + SystemOperationStatus0;
              *(int *)plocalDataIndex = systemId + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + SystemOperationStatus0;
              *(int *)(plocalDataIndex + 1) = systemId + 2 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + SystemOperationStatus0;
              *(int *)(plocalDataIndex + 2) = systemId + 4 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + SystemOperationStatus0;
              *(int *)(plocalDataIndex + 3) = systemId + 6 + SystemOperationStatus0;
              *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + SystemOperationStatus0;
              plocalDataIndex = plocalDataIndex + 8;
              systemId = systemId + 0x10;
              SystemOperationStatus8 = SystemOperationStatus7;
            } while (SystemOperationStatus7 < (int)(SystemOperationStatusFlags - ResourceHash));
          }
        }
        for (SystemResourceDataIndex = (long long)SystemOperationStatus8; SystemResourceDataIndex < (long long)SystemSecondaryStatus; SystemResourceDataIndex = SystemResourceDataIndex + 1) {
          SystemOperationStatus7 = *(int *)(systemDataIndexPtr + 0x2c) + SystemOperationStatus8;
          SystemOperationStatus8 = SystemOperationStatus8 + 1;
          *(int *)(*PrimaryResourcePointer + SystemResourceDataIndex * 4) = SystemOperationStatus7;
        }
        SystemOperationStatus8 = *(int *)(systemDataIndexPtr + 0x18);
        SystemOperationStatus7 = 0;
        if (0 < (long long)SystemOperationStatus8) {
          SystemResourceDataIndex = 0;
          do {
            SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x30) + SystemOperationStatus7;
            SystemOperationStatus7 = SystemOperationStatus7 + 1;
            pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + SystemResourceDataIndex);
            SystemResourceDataIndex = SystemResourceDataIndex + 1;
            *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = SystemOperationStatus0;
          } while (SystemResourceDataIndex < SystemOperationStatus8);
        }
      }
      SystemThreadLocalStoragePointer = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 + SystemDataMemoryContext + 0x9d0
                        );
      if (SystemOperationStatus5 == 0) {
        SystemOperationStatusFlags = (int)SystemOperationStatusFlag - 1;
      }
      else {
        LOCK();
        SystemOperationStatusFlags = *SystemThreadLocalStoragePointer;
        *SystemThreadLocalStoragePointer = *SystemThreadLocalStoragePointer + (int)SystemOperationStatusFlag;
        UNLOCK();
        ThreadCreationFlags = (ulong long)(SystemOperationStatusFlags >> 0xb);
        MemoryAllocationFlags = (ulong long)(SystemOperationStatusFlag + -1 + SystemOperationStatusFlags >> 0xb);
        if (ThreadCreationFlags <= MemoryAllocationFlags) {
          systemFunctionPointer3 = (char *)((long long)SystemThreadLocalStoragePointer + ThreadCreationFlags + 0x108);
          SystemResourceDataIndex = (MemoryAllocationFlags - ThreadCreationFlags) + 1;
          SystemHashEntryPointer0 = SystemThreadLocalStoragePointer + ThreadCreationFlags * 2 + 2;
          do {
            SystemOperationStatus8 = (int)ThreadCreationFlags;
            if (*(long long *)SystemHashEntryPointer0 == 0) {
              SystemMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
              LOCK();
              isSystemActive3 = *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatus8 * 2 + 2) == 0;
              if (isSystemActive3) {
                *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatus8 * 2 + 2) = SystemMemoryAddress;
              }
              UNLOCK();
              if (isSystemActive3) {
                LOCK();
                *(uint8_t *)((long long)SystemOperationStatus8 + 0x108 + (long long)SystemThreadLocalStoragePointer) = 0;
                UNLOCK();
              }
              else {
                if (SystemMemoryAddress != 0) {
                    SystemCleanupFunction();
                }
                do {
                } while (*systemFunctionPointer3 != '\0');
              }
            }
            else {
              do {
              } while (*systemFunctionPointer3 != '\0');
            }
            ThreadCreationFlags = (ulong long)(SystemOperationStatus8 + 1);
            SystemHashEntryPointer0 = SystemHashEntryPointer0 + 2;
            systemFunctionPointer3 = systemFunctionPointer3 + 1;
            SystemResourceDataIndex = SystemResourceDataIndex + -1;
          } while (SystemResourceDataIndex != 0);
        }
      }
      SystemDataPointer9 = *(uint32_t **)(systemDataIndexPtr + 0x38);
      ResourceHash = SystemOperationStatusFlags >> 0xb;
      *(uint *)(systemDataIndexPtr + 0x2c) = SystemOperationStatusFlags;
      if (ResourceHash == (int)SystemOperationStatusFlag + SystemOperationStatusFlags >> 0xb) {
          memcpy(*(long long *)(SystemThreadLocalStoragePointer + (ulong long)ResourceHash * 2 + 2) +
               (ulong long)(SystemOperationStatusFlags + ResourceHash * -0x800) * 4,SystemDataPointer9,(SystemSecondaryStatus & MAX_UNSIGNED_32_BIT) << 2);
      }
      if (SystemOperationStatus5 != 0) {
        SystemSecondaryStatus = SystemSecondaryStatus & MAX_UNSIGNED_32_BIT;
        do {
          currentThreadId = *SystemDataPointer9;
          SystemDataPointer9 = SystemDataPointer9 + 1;
          *(uint32_t *)
           (*(long long *)(SystemThreadLocalStoragePointer + (ulong long)(SystemOperationStatusFlags >> 0xb) * 2 + 2) +
           (ulong long)(SystemOperationStatusFlags + (SystemOperationStatusFlags >> 0xb) * -0x800) * 4) = currentThreadId;
          SystemSecondaryStatus = SystemSecondaryStatus - 1;
          SystemOperationStatusFlags = SystemOperationStatusFlags + 1;
        } while (SystemSecondaryStatus != 0);
      }
    }
  }
  return;
}





// 函数: void ConfigureSystemResourceManagerExtended(void* SystemResourceManager,long long ConfigurationDataPointer)
void ConfigureSystemResourceManagerExtended(void* SystemResourceManager,long long ConfigurationDataPointer)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  char SystemOperationStatusFlag;
  uint32_t currentThreadId;
  uint ResourceHash;
  long long *plocalDataIndex;
  long long SystemMemoryAddress;
  int systemId;
  int SystemOperationStatus0;
  long long SystemResourceDataIndex;
  ulong long SystemSecondaryStatus;
  char *systemFunctionPointer3;
  uint *SystemThreadLocalStoragePointer;
  uint32_t unaff_ESI;
  uint SystemOperationStatus5;
  long long systemDataIndexPtr;
  int SystemOperationStatusFlags;
  int SystemOperationStatus7;
  uint32_t *SystemDataBufferPointer;
  int SystemContextPointer;
  uint *SystemHashEntryPointer0;
  ulong long ThreadCreationFlags;
  ulong long MemoryAllocationFlags;
  bool isSystemActive3;
  
  ConfigurationDataPointer = (long long)*(int *)(ConfigurationDataPointer + 0x250) * 0x128 + ConfigurationDataPointer;
  currentThreadId = AcquireResourceHandle(ConfigurationDataPointer,unaff_ESI);
  *(uint32_t *)(systemDataIndexPtr + 0x30) = currentThreadId;
  ReleaseResourceHandle(ConfigurationDataPointer,currentThreadId);
  if (*(long long *)(systemDataIndexPtr + 0x10) == 0) {
    if (*(int *)(systemDataIndexPtr + 0x18) != 0) {
      *(uint32_t *)(systemDataIndexPtr + 0x2c) = *(uint32_t *)(systemDataIndexPtr + 0x30);
      return;
    }
  }
  else {
    SystemOperationStatusFlag = *(char *)(systemDataIndexPtr + 0x44);
    SystemSecondaryStatus = (ulong long)SystemOperationStatusFlag;
    PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
    SystemContextPointer = (int)SystemOperationStatusFlag;
    if (*(int *)(systemDataIndexPtr + 0x40) == (int)SystemOperationStatusFlag) {
      plocalDataIndex = (long long *)*PrimaryResourcePointer;
    }
    else {
      *(int *)(systemDataIndexPtr + 0x40) = SystemContextPointer;
      if (*PrimaryResourcePointer != 0) {
          SystemCleanupFunction();
      }
      *PrimaryResourcePointer = 0;
      if (SystemOperationStatusFlag == '\0') {
        plocalDataIndex = (long long *)0x0;
        *PrimaryResourcePointer = 0;
      }
      else {
        plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)SystemOperationStatusFlag * 4);
        *PrimaryResourcePointer = (long long)plocalDataIndex;
      }
    }
    if (plocalDataIndex != (long long *)0x0) {
      SystemOperationStatusFlags = 0;
      SystemOperationStatus5 = (uint)SystemOperationStatusFlag;
      SystemOperationStatus7 = SystemOperationStatusFlags;
      if ((0 < SystemContextPointer) && (0xf < SystemOperationStatus5)) {
        SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
        resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(SystemOperationStatusFlag + -1) * 4);
        if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c)))
           && ((PrimaryResourcePointer < plocalDataIndex || (SystemOperationStatus7 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
          ResourceHash = SystemOperationStatus5 & 0x8000000f;
          if ((int)ResourceHash < 0) {
            ResourceHash = (ResourceHash - 1 | 0xfffffff0) + 1;
          }
          plocalDataIndex = plocalDataIndex + 4;
          systemId = 8;
          do {
            *(int *)(plocalDataIndex + -4) = SystemOperationStatusFlags + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + -0x1c) = SystemOperationStatusFlags + 1 + SystemOperationStatus0;
            *(int *)(plocalDataIndex + -3) = SystemOperationStatusFlags + 2 + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + -0x14) = SystemOperationStatusFlags + 3 + SystemOperationStatus0;
            SystemOperationStatusFlags = SystemOperationStatusFlags + 0x10;
            *(int *)(plocalDataIndex + -2) = systemId + -4 + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + SystemOperationStatus0;
            *(int *)(plocalDataIndex + -1) = systemId + -2 + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + SystemOperationStatus0;
            *(int *)plocalDataIndex = systemId + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + SystemOperationStatus0;
            *(int *)(plocalDataIndex + 1) = systemId + 2 + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + SystemOperationStatus0;
            *(int *)(plocalDataIndex + 2) = systemId + 4 + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + SystemOperationStatus0;
            *(int *)(plocalDataIndex + 3) = systemId + 6 + SystemOperationStatus0;
            *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + SystemOperationStatus0;
            plocalDataIndex = plocalDataIndex + 8;
            systemId = systemId + 0x10;
            SystemOperationStatus7 = SystemOperationStatusFlags;
          } while (SystemOperationStatusFlags < (int)(SystemOperationStatus5 - ResourceHash));
        }
      }
      for (SystemResourceDataIndex = (long long)SystemOperationStatus7; SystemResourceDataIndex < (long long)SystemSecondaryStatus; SystemResourceDataIndex = SystemResourceDataIndex + 1) {
        SystemOperationStatusFlags = *(int *)(systemDataIndexPtr + 0x2c) + SystemOperationStatus7;
        SystemOperationStatus7 = SystemOperationStatus7 + 1;
        *(int *)(*PrimaryResourcePointer + SystemResourceDataIndex * 4) = SystemOperationStatusFlags;
      }
      SystemOperationStatus7 = *(int *)(systemDataIndexPtr + 0x18);
      SystemOperationStatusFlags = 0;
      if (0 < (long long)SystemOperationStatus7) {
        SystemResourceDataIndex = 0;
        do {
          SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x30) + SystemOperationStatusFlags;
          SystemOperationStatusFlags = SystemOperationStatusFlags + 1;
          pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + SystemResourceDataIndex);
          SystemResourceDataIndex = SystemResourceDataIndex + 1;
          *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = SystemOperationStatus0;
        } while (SystemResourceDataIndex < SystemOperationStatus7);
      }
    }
    SystemThreadLocalStoragePointer = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 + SystemDataMemoryContext + 0x9d0);
    if (SystemContextPointer == 0) {
      SystemOperationStatus5 = (int)SystemOperationStatusFlag - 1;
    }
    else {
      LOCK();
      SystemOperationStatus5 = *SystemThreadLocalStoragePointer;
      *SystemThreadLocalStoragePointer = *SystemThreadLocalStoragePointer + (int)SystemOperationStatusFlag;
      UNLOCK();
      ThreadCreationFlags = (ulong long)(SystemOperationStatus5 >> 0xb);
      MemoryAllocationFlags = (ulong long)(SystemOperationStatusFlag + -1 + SystemOperationStatus5 >> 0xb);
      if (ThreadCreationFlags <= MemoryAllocationFlags) {
        systemFunctionPointer3 = (char *)((long long)SystemThreadLocalStoragePointer + ThreadCreationFlags + 0x108);
        SystemResourceDataIndex = (MemoryAllocationFlags - ThreadCreationFlags) + 1;
        SystemHashEntryPointer0 = SystemThreadLocalStoragePointer + ThreadCreationFlags * 2 + 2;
        do {
          SystemOperationStatus7 = (int)ThreadCreationFlags;
          if (*(long long *)SystemHashEntryPointer0 == 0) {
            SystemMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
            LOCK();
            isSystemActive3 = *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatus7 * 2 + 2) == 0;
            if (isSystemActive3) {
              *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatus7 * 2 + 2) = SystemMemoryAddress;
            }
            UNLOCK();
            if (isSystemActive3) {
              LOCK();
              *(uint8_t *)((long long)SystemOperationStatus7 + 0x108 + (long long)SystemThreadLocalStoragePointer) = 0;
              UNLOCK();
            }
            else {
              if (SystemMemoryAddress != 0) {
                  SystemCleanupFunction();
              }
              do {
              } while (*systemFunctionPointer3 != '\0');
            }
          }
          else {
            do {
            } while (*systemFunctionPointer3 != '\0');
          }
          ThreadCreationFlags = (ulong long)(SystemOperationStatus7 + 1);
          SystemHashEntryPointer0 = SystemHashEntryPointer0 + 2;
          systemFunctionPointer3 = systemFunctionPointer3 + 1;
          SystemResourceDataIndex = SystemResourceDataIndex + -1;
        } while (SystemResourceDataIndex != 0);
      }
    }
    SystemDataBufferPointer = *(uint32_t **)(systemDataIndexPtr + 0x38);
    ResourceHash = SystemOperationStatus5 >> 0xb;
    *(uint *)(systemDataIndexPtr + 0x2c) = SystemOperationStatus5;
    if (ResourceHash == (int)SystemOperationStatusFlag + SystemOperationStatus5 >> 0xb) {
        memcpy(*(long long *)(SystemThreadLocalStoragePointer + (ulong long)ResourceHash * 2 + 2) +
             (ulong long)(SystemOperationStatus5 + ResourceHash * -0x800) * 4,SystemDataBufferPointer,(SystemSecondaryStatus & MAX_UNSIGNED_32_BIT) << 2);
    }
    if (SystemContextPointer != 0) {
      SystemSecondaryStatus = SystemSecondaryStatus & MAX_UNSIGNED_32_BIT;
      do {
        currentThreadId = *SystemDataBufferPointer;
        SystemDataBufferPointer = SystemDataBufferPointer + 1;
        *(uint32_t *)
         (*(long long *)(SystemThreadLocalStoragePointer + (ulong long)(SystemOperationStatus5 >> 0xb) * 2 + 2) +
         (ulong long)(SystemOperationStatus5 + (SystemOperationStatus5 >> 0xb) * -0x800) * 4) = currentThreadId;
        SystemSecondaryStatus = SystemSecondaryStatus - 1;
        SystemOperationStatus5 = SystemOperationStatus5 + 1;
      } while (SystemSecondaryStatus != 0);
    }
  }
  return;
}





// 函数: void FinalizeSystemResourceManager(void)
void FinalizeSystemResourceManager(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  uint32_t resourceAddress;
  uint currentThreadId;
  uint ResourceHash;
  long long *plocalDataIndex;
  long long SystemMemoryAddress;
  int systemId;
  int SystemOperationStatus0;
  long long SystemResourceDataIndex;
  uint SystemSecondaryStatus;
  ulong long memoryBlockAddress;
  char *systemFunctionPointer3;
  uint *SystemThreadLocalStoragePointer;
  long long systemDataIndexPtr;
  int SystemOperationStatus5;
  int SystemOperationStatusFlags;
  uint32_t *SystemStringTemplatePointer;
  ulong long SystemOperationStatus8;
  uint *SystemDataPointer9;
  ulong long ResourceCreationFlags;
  bool isSystemActive1;
  
  PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
  SystemSecondaryStatus = (uint)memoryBlockAddress;
  if (*(uint *)(systemDataIndexPtr + 0x40) == SystemSecondaryStatus) {
    plocalDataIndex = (long long *)*PrimaryResourcePointer;
  }
  else {
    *(uint *)(systemDataIndexPtr + 0x40) = SystemSecondaryStatus;
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
    *PrimaryResourcePointer = 0;
    if ((char)memoryBlockAddress == '\0') {
      plocalDataIndex = (long long *)0x0;
      *PrimaryResourcePointer = 0;
    }
    else {
      plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)(char)memoryBlockAddress * 4);
      *PrimaryResourcePointer = (long long)plocalDataIndex;
    }
  }
  if (plocalDataIndex != (long long *)0x0) {
    SystemOperationStatus5 = 0;
    SystemOperationStatusFlags = SystemOperationStatus5;
    if ((0 < (int)SystemSecondaryStatus) && (0xf < SystemSecondaryStatus)) {
      SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
      resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(int)(SystemSecondaryStatus - 1) * 4);
      if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c)))
         && ((PrimaryResourcePointer < plocalDataIndex || (SystemOperationStatusFlags = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
        ResourceHash = SystemSecondaryStatus & 0x8000000f;
        if ((int)ResourceHash < 0) {
          ResourceHash = (ResourceHash - 1 | 0xfffffff0) + 1;
        }
        plocalDataIndex = plocalDataIndex + 4;
        systemId = 8;
        do {
          *(int *)(plocalDataIndex + -4) = SystemOperationStatus5 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -0x1c) = SystemOperationStatus5 + 1 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + -3) = SystemOperationStatus5 + 2 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -0x14) = SystemOperationStatus5 + 3 + SystemOperationStatus0;
          SystemOperationStatus5 = SystemOperationStatus5 + 0x10;
          *(int *)(plocalDataIndex + -2) = systemId + -4 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + -1) = systemId + -2 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + SystemOperationStatus0;
          *(int *)plocalDataIndex = systemId + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + 1) = systemId + 2 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + 2) = systemId + 4 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + 3) = systemId + 6 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + SystemOperationStatus0;
          plocalDataIndex = plocalDataIndex + 8;
          systemId = systemId + 0x10;
          SystemOperationStatusFlags = SystemOperationStatus5;
        } while (SystemOperationStatus5 < (int)(SystemSecondaryStatus - ResourceHash));
      }
    }
    for (SystemResourceDataIndex = (long long)SystemOperationStatusFlags; SystemResourceDataIndex < (long long)memoryBlockAddress; SystemResourceDataIndex = SystemResourceDataIndex + 1) {
      SystemOperationStatus5 = *(int *)(systemDataIndexPtr + 0x2c) + SystemOperationStatusFlags;
      SystemOperationStatusFlags = SystemOperationStatusFlags + 1;
      *(int *)(*PrimaryResourcePointer + SystemResourceDataIndex * 4) = SystemOperationStatus5;
    }
    SystemOperationStatusFlags = *(int *)(systemDataIndexPtr + 0x18);
    SystemOperationStatus5 = 0;
    if (0 < (long long)SystemOperationStatusFlags) {
      SystemResourceDataIndex = 0;
      do {
        SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x30) + SystemOperationStatus5;
        SystemOperationStatus5 = SystemOperationStatus5 + 1;
        pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + SystemResourceDataIndex);
        SystemResourceDataIndex = SystemResourceDataIndex + 1;
        *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = SystemOperationStatus0;
      } while (SystemResourceDataIndex < SystemOperationStatusFlags);
    }
  }
  SystemThreadLocalStoragePointer = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 + SystemDataMemoryContext + 0x9d0);
  if (SystemSecondaryStatus == 0) {
    ResourceHash = 0xffffffff;
  }
  else {
    LOCK();
    ResourceHash = *SystemThreadLocalStoragePointer;
    *SystemThreadLocalStoragePointer = *SystemThreadLocalStoragePointer + SystemSecondaryStatus;
    UNLOCK();
    SystemOperationStatus8 = (ulong long)(ResourceHash >> 0xb);
    ResourceCreationFlags = (ulong long)((SystemSecondaryStatus - 1) + ResourceHash >> 0xb);
    if (SystemOperationStatus8 <= ResourceCreationFlags) {
      systemFunctionPointer3 = (char *)((long long)SystemThreadLocalStoragePointer + SystemOperationStatus8 + 0x108);
      SystemResourceDataIndex = (ResourceCreationFlags - SystemOperationStatus8) + 1;
      SystemDataPointer9 = SystemThreadLocalStoragePointer + SystemOperationStatus8 * 2 + 2;
      do {
        SystemOperationStatusFlags = (int)SystemOperationStatus8;
        if (*(long long *)SystemDataPointer9 == 0) {
          SystemMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
          LOCK();
          isSystemActive1 = *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatusFlags * 2 + 2) == 0;
          if (isSystemActive1) {
            *(long long *)(SystemThreadLocalStoragePointer + (long long)SystemOperationStatusFlags * 2 + 2) = SystemMemoryAddress;
          }
          UNLOCK();
          if (isSystemActive1) {
            LOCK();
            *(uint8_t *)((long long)SystemOperationStatusFlags + 0x108 + (long long)SystemThreadLocalStoragePointer) = 0;
            UNLOCK();
          }
          else {
            if (SystemMemoryAddress != 0) {
                SystemCleanupFunction();
            }
            do {
            } while (*systemFunctionPointer3 != '\0');
          }
        }
        else {
          do {
          } while (*systemFunctionPointer3 != '\0');
        }
        SystemOperationStatus8 = (ulong long)(SystemOperationStatusFlags + 1);
        SystemDataPointer9 = SystemDataPointer9 + 2;
        systemFunctionPointer3 = systemFunctionPointer3 + 1;
        SystemResourceDataIndex = SystemResourceDataIndex + -1;
      } while (SystemResourceDataIndex != 0);
    }
  }
  SystemStringTemplatePointer = *(uint32_t **)(systemDataIndexPtr + 0x38);
  currentThreadId = ResourceHash >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = ResourceHash;
  if (currentThreadId == SystemSecondaryStatus + ResourceHash >> 0xb) {
      memcpy(*(long long *)(SystemThreadLocalStoragePointer + (ulong long)currentThreadId * 2 + 2) +
           (ulong long)(ResourceHash + currentThreadId * -0x800) * 4,SystemStringTemplatePointer,(memoryBlockAddress & MAX_UNSIGNED_32_BIT) << 2);
  }
  if (SystemSecondaryStatus != 0) {
    SystemOperationStatus8 = memoryBlockAddress & MAX_UNSIGNED_32_BIT;
    do {
      resourceAddress = *SystemStringTemplatePointer;
      SystemStringTemplatePointer = SystemStringTemplatePointer + 1;
      *(uint32_t *)
       (*(long long *)(SystemThreadLocalStoragePointer + (ulong long)(ResourceHash >> 0xb) * 2 + 2) +
       (ulong long)(ResourceHash + (ResourceHash >> 0xb) * -0x800) * 4) = resourceAddress;
      SystemOperationStatus8 = SystemOperationStatus8 - 1;
      ResourceHash = ResourceHash + 1;
    } while (SystemOperationStatus8 != 0);
  }
  return;
}





// 函数: void CleanupSystemResourceManagerFinal(void)
void CleanupSystemResourceManagerFinal(void)

{
  long long *PrimaryResourcePointer;
  long long *resourcePoolPointer;
  byte *pisOperationComplete;
  uint32_t resourceAddress;
  uint currentThreadId;
  uint ResourceHash;
  long long *plocalDataIndex;
  long long SystemMemoryAddress;
  int systemId;
  int SystemOperationStatus0;
  long long SystemResourceDataIndex;
  int unaff_EBX;
  char *SystemFunctionPointer;
  uint *SystemDataConfigurationPointer;
  long long systemDataIndexPtr;
  int SystemOperationStatus4;
  int SystemOperationStatus5;
  uint32_t *SystemResourceStringPointer;
  ulong long SystemOperationStatus7;
  uint SystemOperationStatus8;
  ulong long systemAllocationOffset;
  uint *SystemDataPointer9;
  ulong long ResourceCreationFlags;
  bool isSystemActive1;
  
  PrimaryResourcePointer = (long long *)(systemDataIndexPtr + 0x38);
  SystemOperationStatus8 = (uint)systemAllocationOffset;
  if (*(int *)(systemDataIndexPtr + 0x40) == unaff_EBX) {
    plocalDataIndex = (long long *)*PrimaryResourcePointer;
  }
  else {
    *(uint *)(systemDataIndexPtr + 0x40) = SystemOperationStatus8;
    if (*PrimaryResourcePointer != 0) {
        SystemCleanupFunction();
    }
    *PrimaryResourcePointer = 0;
    if ((char)unaff_EBX == '\0') {
      plocalDataIndex = (long long *)0x0;
      *PrimaryResourcePointer = 0;
    }
    else {
      plocalDataIndex = (long long *)SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,(long long)(char)unaff_EBX * 4);
      *PrimaryResourcePointer = (long long)plocalDataIndex;
    }
  }
  if (plocalDataIndex != (long long *)0x0) {
    SystemOperationStatus4 = 0;
    SystemOperationStatus5 = SystemOperationStatus4;
    if ((0 < (int)SystemOperationStatus8) && (0xf < SystemOperationStatus8)) {
      SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x2c);
      resourcePoolPointer = (long long *)((long long)plocalDataIndex + (long long)(int)(SystemOperationStatus8 - 1) * 4);
      if ((((long long *)(systemDataIndexPtr + 0x2c) < plocalDataIndex) || (resourcePoolPointer < (long long *)(systemDataIndexPtr + 0x2c)))
         && ((PrimaryResourcePointer < plocalDataIndex || (SystemOperationStatus5 = 0, resourcePoolPointer < PrimaryResourcePointer)))) {
        ResourceHash = SystemOperationStatus8 & 0x8000000f;
        if ((int)ResourceHash < 0) {
          ResourceHash = (ResourceHash - 1 | 0xfffffff0) + 1;
        }
        plocalDataIndex = plocalDataIndex + 4;
        systemId = 8;
        do {
          *(int *)(plocalDataIndex + -4) = SystemOperationStatus4 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -0x1c) = SystemOperationStatus4 + 1 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + -3) = SystemOperationStatus4 + 2 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -0x14) = SystemOperationStatus4 + 3 + SystemOperationStatus0;
          SystemOperationStatus4 = SystemOperationStatus4 + 0x10;
          *(int *)(plocalDataIndex + -2) = systemId + -4 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -0xc) = systemId + -3 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + -1) = systemId + -2 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + -4) = systemId + -1 + SystemOperationStatus0;
          *(int *)plocalDataIndex = systemId + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 4) = systemId + 1 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + 1) = systemId + 2 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 0xc) = systemId + 3 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + 2) = systemId + 4 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 0x14) = systemId + 5 + SystemOperationStatus0;
          *(int *)(plocalDataIndex + 3) = systemId + 6 + SystemOperationStatus0;
          *(int *)((long long)plocalDataIndex + 0x1c) = systemId + 7 + SystemOperationStatus0;
          plocalDataIndex = plocalDataIndex + 8;
          systemId = systemId + 0x10;
          SystemOperationStatus5 = SystemOperationStatus4;
        } while (SystemOperationStatus4 < (int)(SystemOperationStatus8 - ResourceHash));
      }
    }
    for (SystemResourceDataIndex = (long long)SystemOperationStatus5; SystemResourceDataIndex < (long long)systemAllocationOffset; SystemResourceDataIndex = SystemResourceDataIndex + 1) {
      SystemOperationStatus4 = *(int *)(systemDataIndexPtr + 0x2c) + SystemOperationStatus5;
      SystemOperationStatus5 = SystemOperationStatus5 + 1;
      *(int *)(*PrimaryResourcePointer + SystemResourceDataIndex * 4) = SystemOperationStatus4;
    }
    SystemOperationStatus5 = *(int *)(systemDataIndexPtr + 0x18);
    SystemOperationStatus4 = 0;
    if (0 < (long long)SystemOperationStatus5) {
      SystemResourceDataIndex = 0;
      do {
        SystemOperationStatus0 = *(int *)(systemDataIndexPtr + 0x30) + SystemOperationStatus4;
        SystemOperationStatus4 = SystemOperationStatus4 + 1;
        pisOperationComplete = (byte *)(*(long long *)(systemDataIndexPtr + 0x10) + SystemResourceDataIndex);
        SystemResourceDataIndex = SystemResourceDataIndex + 1;
        *(int *)(*PrimaryResourcePointer + (ulong long)*pisOperationComplete * 4) = SystemOperationStatus0;
      } while (SystemResourceDataIndex < SystemOperationStatus5);
    }
  }
  SystemDataConfigurationPointer = (uint *)((long long)*(int *)(SystemDataMemoryContext + 0xc20) * 0x128 + SystemDataMemoryContext + 0x9d0);
  if (SystemOperationStatus8 == 0) {
    ResourceHash = 0xffffffff;
  }
  else {
    LOCK();
    ResourceHash = *SystemDataConfigurationPointer;
    *SystemDataConfigurationPointer = *SystemDataConfigurationPointer + SystemOperationStatus8;
    UNLOCK();
    SystemOperationStatus7 = (ulong long)(ResourceHash >> 0xb);
    ResourceCreationFlags = (ulong long)((SystemOperationStatus8 - 1) + ResourceHash >> 0xb);
    if (SystemOperationStatus7 <= ResourceCreationFlags) {
      SystemFunctionPointer = (char *)((long long)SystemDataConfigurationPointer + SystemOperationStatus7 + 0x108);
      SystemResourceDataIndex = (ResourceCreationFlags - SystemOperationStatus7) + 1;
      SystemDataPointer9 = SystemDataConfigurationPointer + SystemOperationStatus7 * 2 + 2;
      do {
        SystemOperationStatus5 = (int)SystemOperationStatus7;
        if (*(long long *)SystemDataPointer9 == 0) {
          SystemMemoryAddress = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
          LOCK();
          isSystemActive1 = *(long long *)(SystemDataConfigurationPointer + (long long)SystemOperationStatus5 * 2 + 2) == 0;
          if (isSystemActive1) {
            *(long long *)(SystemDataConfigurationPointer + (long long)SystemOperationStatus5 * 2 + 2) = SystemMemoryAddress;
          }
          UNLOCK();
          if (isSystemActive1) {
            LOCK();
            *(uint8_t *)((long long)SystemOperationStatus5 + 0x108 + (long long)SystemDataConfigurationPointer) = 0;
            UNLOCK();
          }
          else {
            if (SystemMemoryAddress != 0) {
                SystemCleanupFunction();
            }
            do {
            } while (*SystemFunctionPointer != '\0');
          }
        }
        else {
          do {
          } while (*SystemFunctionPointer != '\0');
        }
        SystemOperationStatus7 = (ulong long)(SystemOperationStatus5 + 1);
        SystemDataPointer9 = SystemDataPointer9 + 2;
        SystemFunctionPointer = SystemFunctionPointer + 1;
        SystemResourceDataIndex = SystemResourceDataIndex + -1;
      } while (SystemResourceDataIndex != 0);
    }
  }
  SystemResourceStringPointer = *(uint32_t **)(systemDataIndexPtr + 0x38);
  currentThreadId = ResourceHash >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = ResourceHash;
  if (currentThreadId == SystemOperationStatus8 + ResourceHash >> 0xb) {
      memcpy(*(long long *)(SystemDataConfigurationPointer + (ulong long)currentThreadId * 2 + 2) +
           (ulong long)(ResourceHash + currentThreadId * -0x800) * 4,SystemResourceStringPointer,(systemAllocationOffset & MAX_UNSIGNED_32_BIT) << 2);
  }
  if (SystemOperationStatus8 != 0) {
    SystemOperationStatus7 = systemAllocationOffset & MAX_UNSIGNED_32_BIT;
    do {
      resourceAddress = *SystemResourceStringPointer;
      SystemResourceStringPointer = SystemResourceStringPointer + 1;
      *(uint32_t *)
       (*(long long *)(SystemDataConfigurationPointer + (ulong long)(ResourceHash >> 0xb) * 2 + 2) +
       (ulong long)(ResourceHash + (ResourceHash >> 0xb) * -0x800) * 4) = resourceAddress;
      SystemOperationStatus7 = SystemOperationStatus7 - 1;
      ResourceHash = ResourceHash + 1;
    } while (SystemOperationStatus7 != 0);
  }
  return;
}





/**
 * @brief 初始化系统线程本地存储
 * 
 * 该函数负责初始化系统线程本地存储，包括：
 * - 线程ID的分配和管理
 * - 线程本地存储对象的创建
 * - 系统线程对象的初始化
 * - 线程安全的状态管理
 * 
 * 函数会创建系统线程对象，设置线程本地存储，并管理线程相关的资源
 * 
 * @return 无返回值
 * @note 此函数在系统初始化时调用，用于建立线程本地存储机制
 * @warning 函数内部使用锁机制确保线程安全
 */
void InitializeSystemThreadLocalStorage(void)

{
  uint32_t SystemOperationStatus;
  long long SystemThreadHandle;
  uint resourceAllocationContext;
  char *pSystemOperationStatusFlag;
  uint *systemStackFramePtr;
  uint currentThreadId;
  long long systemDataIndexPtr;
  uint32_t *resourceEntryPointer;
  ulong long ThreadContextFlag;
  uint systemAllocationOffsetD;
  void* *SystemContextPointer;
  uint *SystemThreadStorage;
  int systemId;
  ulong long SystemOperationFlags;
  long long SystemResourceDataIndex;
  bool isByteValid2;
  
  LOCK();
  currentThreadId = *systemStackFramePtr;
  *systemStackFramePtr = *systemStackFramePtr + systemAllocationOffsetD;
  UNLOCK();
  ThreadContextFlag = (ulong long)(currentThreadId >> 0xb);
  SystemOperationFlags = (ulong long)((systemAllocationOffsetD - 1) + currentThreadId >> 0xb);
  if (ThreadContextFlag <= SystemOperationFlags) {
    pSystemOperationStatusFlag = (char *)((long long)systemStackFramePtr + ThreadContextFlag + 0x108);
    SystemResourceDataIndex = (SystemOperationFlags - ThreadContextFlag) + 1;
    SystemThreadStorage = systemStackFramePtr + (ulong long)(currentThreadId >> 0xb) * 2 + 2;
    do {
      systemId = (int)ThreadContextFlag;
      if (*(long long *)SystemThreadStorage == 0) {
        SystemThreadHandle = CreateSystemThreadObject(SystemMemoryPoolTemplate,0x2000,0x25);
        LOCK();
        isByteValid2 = *(long long *)(systemStackFramePtr + (long long)systemId * 2 + 2) == 0;
        if (isByteValid2) {
          *(long long *)(systemStackFramePtr + (long long)systemId * 2 + 2) = SystemThreadHandle;
        }
        UNLOCK();
        if (isByteValid2) {
          LOCK();
          *(uint8_t *)((long long)systemId + 0x108 + (long long)systemStackFramePtr) = 0;
          UNLOCK();
        }
        else {
          if (SystemThreadHandle != 0) {
              SystemCleanupFunction();
          }
          do {
          } while (*pSystemOperationStatusFlag != '\0');
        }
      }
      else {
        do {
        } while (*pSystemOperationStatusFlag != '\0');
      }
      ThreadContextFlag = (ulong long)(systemId + 1);
      SystemThreadStorage = SystemThreadStorage + 2;
      pSystemOperationStatusFlag = pSystemOperationStatusFlag + 1;
      SystemResourceDataIndex = SystemResourceDataIndex + -1;
    } while (SystemResourceDataIndex != 0);
    SystemContextPointer = (void* *)(systemDataIndexPtr + 0x38);
  }
  resourceEntryPointer = (uint32_t *)*SystemContextPointer;
  resourceAllocationContext = currentThreadId >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = currentThreadId;
  if (resourceAllocationContext != systemAllocationOffsetD + currentThreadId >> 0xb) {
    if (systemAllocationOffsetD != 0) {
      ThreadContextFlag = (ulong long)systemAllocationOffsetD;
      do {
        SystemOperationStatus = *resourceEntryPointer;
        resourceEntryPointer = resourceEntryPointer + 1;
        *(uint32_t *)
         (*(long long *)(systemStackFramePtr + (ulong long)(currentThreadId >> 0xb) * 2 + 2) +
         (ulong long)(currentThreadId + (currentThreadId >> 0xb) * -0x800) * 4) = SystemOperationStatus;
        ThreadContextFlag = ThreadContextFlag - 1;
        currentThreadId = currentThreadId + 1;
      } while (ThreadContextFlag != 0);
    }
    return;
  }
    memcpy(*(long long *)(systemStackFramePtr + (ulong long)resourceAllocationContext * 2 + 2) +
         (ulong long)(currentThreadId + resourceAllocationContext * -0x800) * 4,resourceEntryPointer,(ulong long)systemAllocationOffsetD << 2);
}




/**
 * @brief 处理系统哈希节点数据
 * 
 * 该函数负责处理系统哈希节点数据，包括：
 * - 哈希节点数据的读取和处理
 * - 系统资源地址的计算和管理
 * - 哈希表数据的更新和同步
 * - 内存数据的安全复制
 * 
 * 函数会遍历哈希节点，处理每个节点的数据，并将结果写入到系统资源管理器中
 * 
 * @return 无返回值
 * @note 此函数用于哈希表数据的管理和维护
 * @warning 函数涉及指针操作，需要确保内存访问的安全性
 */
void ProcessSystemSystemHashNodeData(void)

{
  uint32_t SystemOperationStatus;
  uint resourceCreationFlags;
  long long systemStackFramePtr;
  uint unaff_ESI;
  long long systemDataIndexPtr;
  uint32_t *SystemHashNodeData;
  ulong long resourceAddress;
  uint systemAllocationOffsetD;
  void* *SystemContextPointer;
  
  SystemHashNodeData = (uint32_t *)*SystemContextPointer;
  resourceCreationFlags = unaff_ESI >> 0xb;
  *(uint *)(systemDataIndexPtr + 0x2c) = unaff_ESI;
  if (resourceCreationFlags != systemAllocationOffsetD + unaff_ESI >> 0xb) {
    if (systemAllocationOffsetD != 0) {
      resourceAddress = (ulong long)systemAllocationOffsetD;
      do {
        SystemOperationStatus = *SystemHashNodeData;
        SystemHashNodeData = SystemHashNodeData + 1;
        *(uint32_t *)
         (*(long long *)(systemStackFramePtr + 8 + (ulong long)(unaff_ESI >> 0xb) * 8) +
         (ulong long)(unaff_ESI + (unaff_ESI >> 0xb) * -0x800) * 4) = SystemOperationStatus;
        resourceAddress = resourceAddress - 1;
        unaff_ESI = unaff_ESI + 1;
      } while (resourceAddress != 0);
    }
    return;
  }
    memcpy(*(long long *)(systemStackFramePtr + 8 + (ulong long)resourceCreationFlags * 8) +
         (ulong long)(unaff_ESI + resourceCreationFlags * -0x800) * 4,SystemHashNodeData,(ulong long)systemAllocationOffsetD << 2);
}




/**
 * @brief 复制系统资源数据到目标内存区域
 * 
 * 该函数负责将系统资源数据从源位置复制到目标内存区域
 * 主要用于系统资源的数据迁移和备份操作
 * 
 * @param SystemResourceManager 系统资源管理器指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * 
 * 原始函数名：FUN_18007fc35
 */
void CopySystemResourceDataToMemory(long long SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,void* ConfigurationFlag)

{
  long long SystemStackFramePointer;
  int ResourceIndex;
  uint DataAllocationSize;
  
    memcpy(*(long long *)(SystemStackFramePointer + 8 + SystemResourceManager * 8) +
         (ulong long)(uint)(ResourceIndex + (int)SystemResourceManager * -0x800) * 4,ConfigurationFlag,(ulong long)DataAllocationSize << 2
        );
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 主要用于系统初始化和清理过程中的占位操作
 * 
 * 原始函数名：FUN_18007fc63
 */
void SystemNullOperationC(void)

{
  return;
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 主要用于系统初始化和清理过程中的占位操作
 * 
 * 原始函数名：FUN_18007fc68
 */
void SystemNullOperationD(void)

{
  return;
}




/**
 * @brief 系统空操作函数
 * 
 * 该函数是一个空操作函数，不执行任何实际操作
 * 主要用于系统初始化和清理过程中的占位操作
 * 
 * 原始函数名：FUN_18007fc6d
 */
void SystemNullOperationE(void)

{
  return;
}




/**
 * @brief 初始化系统偏好设置
 * 
 * 该函数负责初始化系统的偏好设置和配置参数
 * 主要用于系统启动时的配置初始化
 * 
 * 原始函数名：InitializeSystemPreferences
 */
void InitializeSystemPreferences(void)

{
  uint32_t SystemOperationStatusCode;
  long long SystemStackFramePointer;
  uint ResourceIndex;
  uint32_t *PreferenceDataPointer;
  ulong long ConfigurationLoopCounter;
  uint PreferenceAllocationSize;
  
  if (PreferenceAllocationSize != 0) {
    ConfigurationLoopCounter = (ulong long)PreferenceAllocationSize;
    do {
      SystemOperationStatusCode = *PreferenceDataPointer;
      PreferenceDataPointer = PreferenceDataPointer + 1;
      *(uint32_t *)
       (*(long long *)(SystemStackFramePointer + 8 + (ulong long)(ResourceIndex >> 0xb) * 8) +
       (ulong long)(ResourceIndex + (ResourceIndex >> 0xb) * -0x800) * 4) = SystemOperationStatusCode;
      ConfigurationLoopCounter = ConfigurationLoopCounter - 1;
      ResourceIndex = ResourceIndex + 1;
    } while (ConfigurationLoopCounter != 0);
  }
  return;
}




// 函数: void InitializePreferenceManager(void)
void InitializePreferenceManager(void)

{
  long long systemDataIndexPtr;
  
  if (*(int *)(systemDataIndexPtr + 0x18) != 0) {
    *(uint32_t *)(systemDataIndexPtr + 0x2c) = *(uint32_t *)(systemDataIndexPtr + 0x30);
    return;
  }
  return;
}





// 函数: void SystemInitializationFunction(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter)
void SystemInitializationFunction(void* SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter)

{
  void* SystemOperationStatus;
  long long *resourcePoolPointer;
  
  SystemOperationStatus = SystemMemoryAllocationFunction(SystemMemoryPoolTemplate,0xf0,8,3,InvalidHandleValue);
  resourcePoolPointer = (long long *)GetMemoryPointer(SystemOperationStatus);
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x28))(resourcePoolPointer);
  }
  ProcessResourcePoolData(resourcePoolPointer,SystemResourceManager);
  ProcessResourcePoolIndex(resourcePoolPointer,AdditionalParameter);
  if (resourcePoolPointer != (long long *)0x0) {
    (**(code **)(*resourcePoolPointer + 0x38))(resourcePoolPointer);
  }
  return;
}





/**
 * @brief 系统资源数据加密处理函数
 * 
 * 该函数负责处理系统资源数据的加密操作，包括配置数据的处理和加密密钥的应用。
 * 它会调用系统资源分配函数，并对资源数据进行加密处理。
 * 
 * @param SystemResourceManager 系统资源指针，包含需要处理的资源信息
 * @param ConfigurationDataPointer 配置数据指针，包含配置参数和数据
 * @param AdditionalParameter 额外参数，用于扩展功能
 * @param ConfigurationFlag 配置标志，用于控制处理流程
 * 
 *FUN_18007fd60：ProcessSystemResourceDataWithEncryption
 */
void ProcessSystemResourceDataWithEncryption(void* SystemResourceManager,long long ConfigurationDataPointer,void* AdditionalParameter,long long ConfigurationFlag)

{
  long long *PrimaryResourcePointer;
  int systemResult;
  uint8_t EncryptionKeyBuffer [32];
  long long *ResourceHandlePointer;
  long long *ResourceArrayPointer [2];
  void* EncryptionFlag;
  ulong long EncryptedKey;
  
  EncryptionFlag = 0xfffffffffffffffe;
  EncryptedKey = SystemEncryptionKeyTemplate ^ (ulong long)EncryptionKeyBuffer;
  *(long long *)(ConfigurationFlag + 8) = *(long long *)(ConfigurationFlag + 8) + 4;
  systemResult = *(int *)(ConfigurationDataPointer + 0x14) * *(int *)(ConfigurationDataPointer + 0x10);
  PrimaryResourcePointer = (long long *)AllocateResourcePool(SystemResourceManager,ResourceArrayPointer,systemResult);
  PrimaryResourcePointer = (long long *)*PrimaryResourcePointer;
  if (PrimaryResourcePointer != (long long *)0x0) {
    ResourceHandlePointer = PrimaryResourcePointer;
    (**(code **)(*PrimaryResourcePointer + 0x28))(PrimaryResourcePointer);
  }
  ResourceHandlePointer = *(long long **)(ConfigurationDataPointer + 0x20);
  *(long long **)(ConfigurationDataPointer + 0x20) = PrimaryResourcePointer;
  if (ResourceHandlePointer != (long long *)0x0) {
    (**(code **)(*ResourceHandlePointer + 0x38))();
  }
  if (ResourceArrayPointer[0] != (long long *)0x0) {
    (**(code **)(*ResourceArrayPointer[0] + 0x38))();
  }
    memcpy(*(void* *)(*(long long *)(ConfigurationDataPointer + 0x20) + 0x10),*(void* *)(ConfigurationFlag + 8),
         (long long)systemResult);
}





/**
 * @brief 初始化系统入口点
 * 
 * 该函数负责初始化系统的主要入口点
 * 设置系统上下文、入口点数据、内存池和初始化标志
 * 
 * @param systemContext 系统上下文，包含系统运行所需的环境信息
 * @param entryPointData 入口点数据，包含入口点初始化所需的参数
 * @param memoryPool 内存池，用于分配入口点所需的内存资源
 * @param InitializationFlags 初始化标志，控制初始化过程的选项
 */
void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* InitializationFlags);

/**
 * @brief 执行系统入口点
 * 
 * 该函数负责执行指定的系统入口点
 * 调用入口点函数并传递必要的参数
 * 
 * @param entryPointPtr 入口点指针，指向要执行的入口点函数
 */
void ExecuteSystemEntryPoint(void* *entryPointPtr);

// 函数: 系统初始化完成检查函数
void* SystemInitializationCompleteCheck;

// 函数: 系统配置验证函数
void* SystemConfigurationValidation;
uint32_t SystemStatusIndicator;
void* SystemInitializationFlag;
void* SystemConfigurationFlag;

/**
 * @brief 音频数据归一化处理函数
 * 
 * 该函数负责对音频数据进行归一化处理，包括：
 * - 计算音频数据的幅度
 * - 应用归一化系数
 * - 处理多通道音频数据
 * - 批量优化处理以提高性能
 * 
 * @return void* 返回处理结果指针
 * 
 * @note 这是音频处理系统的核心函数，用于音频数据的预处理
 */
void* NormalizeAudioData(void)

{
  float audioChannelSample1;
  float audioChannelSample2;
  float audioChannelSample3;
  float audioChannelSample4;
  float audioChannelSample5;
  float audioChannelSample6;
  float audioChannelSample7;
  float audioChannelSample8;
  uint audioBitMask;
  uint processedAudioBit;
  int audioProcessingLoop;
  float *audioBufferPointer;
  int audioNormalizationFactor;
  float *audioInputData;
  uint audioShiftRegister;
  int audioProcessingIndex;
  uint totalAudioChannels;
  uint currentAudioSample;
  int audioBitDepth;
  long long audioProcessingContext;
  uint audioThresholdFlag1;
  uint audioThresholdFlag2;
  float audioNormalizedValue;
  uint8_t audioCoefficientArray [16];
  float audioIntermediateResult;
  int audioWindowOffset1;
  float audioFilterCoeff1;
  int audioWindowOffset2;
  float audioFilterCoeff2;
  int audioWindowOffset3;
  float audioFilterCoeff3;
  int audioWindowOffset4;
  float audioFilterCoeff4;
  uint8_t audioInverseCoeffArray [16];
  float audioFilterResult;
  float audioAccumulatedSum1;
  float audioAccumulatedSum2;
  float audioAccumulatedSum3;
  float audioAccumulatedSum4;
  float audioWeightedSum1;
  float audioWeightedSum2;
  float audioWeightedSum3;
  float audioWeightedSum4;
  float audioMaxAmplitude;
  float audioChannelSum1;
  float audioChannelSum2;
  float audioChannelSum3;
  float audioChannelSum4;
  int audioWeightFactor1;
  int audioWeightFactor2;
  int audioWeightFactor3;
  int audioWeightFactor4;
  float *audioOutputBufferPtr;
  
  audioBufferPointer = audioInputData;
  do {
    processedAudioBit = 0;
    audioProcessingLoop = audioBitDepth;
    audioShiftRegister = currentAudioSample;
    if (audioBitDepth != 0) {
      do {
        audioBitMask = audioShiftRegister & 1;
        audioShiftRegister = audioShiftRegister >> 1;
        processedAudioBit = processedAudioBit * 2 | audioBitMask;
        audioProcessingLoop = audioProcessingLoop + -1;
      } while (audioProcessingLoop != 0);
    }
    currentAudioSample = currentAudioSample + 1;
    audioNormalizedValue = *(float *)(*(long long *)(audioProcessingContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + (long long)(int)processedAudioBit * 8);
    audioWeightedSum2 = *(float *)(*(long long *)(audioProcessingContext + TRANSFORM_CONTEXT_OFFSET_218) + (long long)(int)processedAudioBit * 8);
    audioNormalizedValue = SQRT(audioWeightedSum2 * audioWeightedSum2 + audioNormalizedValue * audioNormalizedValue) * 2.5;
    if (audioMaxAmplitude <= audioNormalizedValue) {
      audioNormalizedValue = audioMaxAmplitude;
    }
    *audioBufferPointer = audioNormalizedValue;
    audioBufferPointer = audioBufferPointer + 1;
  } while ((int)currentAudioSample < (int)totalAudioChannels);
  if (audioOutputBufferPtr != (float *)0x0) {
    audioProcessingIndex = 0;
    if (0 < (int)totalAudioChannels) {
      audioNormalizedValue = audioAccumulatedSum1;
      if (7 < totalAudioChannels) {
        audioShiftRegister = totalAudioChannels & 0x80000007;
        if ((int)audioShiftRegister < 0) {
          audioShiftRegister = (audioShiftRegister - 1 | 0xfffffff8) + 1;
        }
        audioInverseCoeffArray._0_4_ = audioWindowOffset1 + -1;
        audioInverseCoeffArray._4_4_ = audioWindowOffset2 + -1;
        audioInverseCoeffArray._8_4_ = audioWindowOffset3 + -1;
        audioInverseCoeffArray._12_4_ = audioWindowOffset4 + -1;
        audioCoefficientArray._0_4_ = (float)audioInverseCoeffArray._0_4_;
        audioCoefficientArray._4_4_ = (float)audioInverseCoeffArray._4_4_;
        audioCoefficientArray._8_4_ = (float)audioInverseCoeffArray._8_4_;
        audioCoefficientArray._12_4_ = (float)audioInverseCoeffArray._12_4_;
        audioInverseCoeffArray = rcpps(audioInverseCoeffArray,audioCoefficientArray);
        audioNormalizedValue = 0.0;
        audioWeightedSum2 = 0.0;
        audioWeightedSum3 = 0.0;
        audioIntermediateResult = 0.0;
        audioFilterCoeff1 = audioInverseCoeffArray._0_4_;
        audioFilterCoeff2 = audioInverseCoeffArray._4_4_;
        audioFilterCoeff3 = audioInverseCoeffArray._8_4_;
        audioFilterCoeff4 = audioInverseCoeffArray._12_4_;
        audioWeightedSum1 = 0.0;
        audioWeightedSum4 = 0.0;
        audioChannelSum1 = 0.0;
        audioChannelSum2 = 0.0;
        audioChannelSum3 = 0.0;
        audioChannelSum4 = 0.0;
        audioFilterResult = 0.0;
        audioAccumulatedSum1 = 0.0;
        audioAccumulatedSum2 = 0.0;
        audioAccumulatedSum3 = 0.0;
        audioAccumulatedSum4 = 0.0;
        audioFilterCoeff1 = (audioFilterCoeff1 + audioFilterCoeff1) - audioFilterCoeff1 * audioFilterCoeff1 * audioCoefficientArray._0_4_;
        audioFilterCoeff2 = (audioFilterCoeff2 + audioFilterCoeff2) - audioFilterCoeff2 * audioFilterCoeff2 * audioCoefficientArray._4_4_;
        audioFilterCoeff3 = (audioFilterCoeff3 + audioFilterCoeff3) - audioFilterCoeff3 * audioFilterCoeff3 * audioCoefficientArray._8_4_;
        audioFilterCoeff4 = (audioFilterCoeff4 + audioFilterCoeff4) - audioFilterCoeff4 * audioFilterCoeff4 * audioCoefficientArray._12_4_;
        audioBufferPointer = audioInputData;
        audioProcessingIndex = audioProcessingIndex;
        do {
          audioSampleValue1 = *audioDataPointer;
          audioSampleValue2 = audioDataPointer[1];
          audioSampleValue3 = audioDataPointer[2];
          audioSampleValue4 = audioDataPointer[3];
          audioProcessingFlags = -(uint)(0.0001 < audioSampleValue1);
          audioThresholdFlag9 = -(uint)(0.0001 < audioSampleValue2);
          audioThresholdFlag15 = -(uint)(0.0001 < audioSampleValue3);
          audioThresholdFlag16 = -(uint)(0.0001 < audioSampleValue4);
          audioStatusIndex1 = audioStatusIndex4 + 8;
          audioSampleValue5 = audioDataPointer[4];
          audioSampleValue6 = audioDataPointer[5];
          audioSampleValue7 = audioDataPointer[6];
          audioSampleValue8 = audioDataPointer[7];
          audioDataPointer = audioDataPointer + 8;
          audioWeightedResult17 = (float)((uint)((float)audioStatusIndex4 * (float)audioCoeffA * 0.5 * audioCoeff20 * audioSampleValue1 +
                                 audioWeightedResult17) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult17);
          audioWeightedResult29 = (float)((uint)((float)(audioStatusIndex4 + 1) * (float)audioCoeffB * 0.5 * audioCoeff22 * audioSampleValue2
                                 + audioWeightedResult29) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult29);
          audioWeightedResult31 = (float)((uint)((float)(audioStatusIndex4 + 2) * (float)audioCoeffC * 0.5 * audioCoeff23 * audioSampleValue3
                                 + audioWeightedResult31) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult31);
          audioWeightedResult19 = (float)((uint)((float)(audioStatusIndex4 + 3) * (float)audioCoeffD * 0.5 * audioCoeff24 * audioSampleValue4
                                 + audioWeightedResult19) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult19);
          audioWeightedResult25 = (float)((uint)(audioSampleValue1 + audioWeightedResult25) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult25);
          audioWeightedResult26 = (float)((uint)(audioSampleValue2 + audioWeightedResult26) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult26);
          audioWeightedResult27 = (float)((uint)(audioSampleValue3 + audioWeightedResult27) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult27);
          audioWeightedResult28 = (float)((uint)(audioSampleValue4 + audioWeightedResult28) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult28);
          audioProcessingFlags = -(uint)(0.0001 < audioSampleValue5);
          audioThresholdFlag9 = -(uint)(0.0001 < audioSampleValue6);
          audioThresholdFlag15 = -(uint)(0.0001 < audioSampleValue7);
          audioThresholdFlag16 = -(uint)(0.0001 < audioSampleValue8);
          audioWeightedResult30 = (float)((uint)((float)(audioStatusIndex4 + 4) * (float)audioCoeffA * 0.5 * audioCoeff20 * audioSampleValue5
                                 + audioWeightedResult30) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult30);
          audioWeightedResult32 = (float)((uint)((float)(audioStatusIndex4 + 5) * (float)audioCoeffB * 0.5 * audioCoeff22 * audioSampleValue6
                                 + audioWeightedResult32) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult32);
          audioWeightedResult33 = (float)((uint)((float)(audioStatusIndex4 + 6) * (float)audioCoeffC * 0.5 * audioCoeff23 * audioSampleValue7
                                 + audioWeightedResult33) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult33);
          audioWeightedResult34 = (float)((uint)((float)(audioStatusIndex4 + 7) * (float)audioCoeffD * 0.5 * audioCoeff24 * audioSampleValue8
                                 + audioWeightedResult34) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult34);
          audioWeightedResult35 = (float)((uint)(audioSampleValue5 + audioWeightedResult35) & audioProcessingFlags | ~audioProcessingFlags & (uint)audioWeightedResult35);
          audioWeightedResult36 = (float)((uint)(audioSampleValue6 + audioWeightedResult36) & audioThresholdFlag9 | ~audioThresholdFlag9 & (uint)audioWeightedResult36);
          audioWeightedResult37 = (float)((uint)(audioSampleValue7 + audioWeightedResult37) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioWeightedResult37);
          audioWeightedResult38 = (float)((uint)(audioSampleValue8 + audioWeightedResult38) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioWeightedResult38);
          audioStatusIndex4 = audioStatusIndex1;
        } while (audioStatusIndex1 < (int)(audioTotalChannels - audioThresholdFlag13));
        audioTotalSum = audioWeightedResult27 + audioWeightedResult37 + audioWeightedResult25 + audioWeightedResult35 + audioWeightedResult28 + audioWeightedResult38 + audioWeightedResult26 + audioWeightedResult36;
        audioWeightedResult17 = audioWeightedResult31 + audioWeightedResult33 + audioWeightedResult17 + audioWeightedResult30 + audioWeightedResult19 + audioWeightedResult34 + audioWeightedResult29 + audioWeightedResult32;
      }
      if (audioStatusIndex1 < (int)audioTotalChannels) {
        if (3 < (int)(audioTotalChannels - audioStatusIndex1)) {
          audioStatusIndex4 = audioStatusIndex1 + 2;
          audioWeightedResult29 = (float)audioProcessingFactor;
          audioDataPointer = audioDataIndexPtr + (long long)audioStatusIndex1 + 2;
          audioWeightedResult31 = (float)(int)audioTotalChannels;
          do {
            audioWeightedResult19 = audioDataPointer[-2];
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + ((audioWeightedResult29 * 0.5 * (float)audioStatusIndex1) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioWeightedResult19 = audioDataPointer[-1];
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + (((float)(audioStatusIndex4 + -1) * audioWeightedResult29 * 0.5) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioWeightedResult19 = *audioDataPointer;
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + (((float)audioStatusIndex4 * audioWeightedResult29 * 0.5) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioWeightedResult19 = audioDataPointer[1];
            if (0.0001 < audioWeightedResult19) {
              audioTotalSum = audioTotalSum + audioWeightedResult19;
              audioWeightedResult17 = audioWeightedResult17 + (((float)(audioStatusIndex4 + 1) * audioWeightedResult29 * 0.5) / audioWeightedResult31) * audioWeightedResult19;
            }
            audioDataPointer = audioDataPointer + 4;
            audioStatusIndex1 = audioStatusIndex1 + 4;
            audioStatusIndex4 = audioStatusIndex4 + 4;
          } while (audioStatusIndex1 < (int)(audioTotalChannels - 3));
        }
        if (audioStatusIndex1 < (int)audioTotalChannels) {
          audioDataPointer = audioDataIndexPtr + audioStatusIndex1;
          do {
            audioWeightedResult29 = *audioDataPointer;
            if (0.0001 < audioWeightedResult29) {
              audioTotalSum = audioTotalSum + audioWeightedResult29;
              audioWeightedResult17 = audioWeightedResult17 + (((float)audioProcessingFactor * 0.5 * (float)audioStatusIndex1) / (float)(int)audioTotalChannels) *
                                audioWeightedResult29;
            }
            audioDataPointer = audioDataPointer + 1;
            audioStatusIndex1 = audioStatusIndex1 + 1;
          } while (audioStatusIndex1 < (int)audioTotalChannels);
        }
      }
      if (0.001 < audioTotalSum) {
        *audioResultOutput = audioWeightedResult17 / audioTotalSum;
        return 0;
      }
    }
    *audioResultOutput = 0.0;
  }
  return 0;
}



/**
 * @brief 音频信号处理函数
 * 
 * 该函数负责处理音频信号，包括：
 * - 音频数据的读取和处理
 * - 信号滤波和加权计算
 * - 多通道音频数据的并行处理
 * - 音频信号的统计分析和结果计算
 * 
 * @return void* 返回处理结果指针
 * 
 * @note 这是音频处理系统的重要函数，用于音频信号的深度处理
 */
void* ProcessAudioSignal(void)

{
  float audioSignal1;
  float audioSignal2;
  float audioSignal3;
  float audioSignal4;
  float audioSignal5;
  float audioSignal6;
  float audioSignal7;
  float audioSignal8;
  uint audioProcessingFlag9;
  int audioStatusIndex0;
  float *audioDataPointer11;
  int audioProcessingFactor;
  float *audioDataIndexPtr;
  int audioStatusIndex2;
  uint audioTotalChannels;
  float *audioOutputBuffer;
  uint audioThresholdFlag13;
  uint audioThresholdFlag14;
  uint audioThresholdFlag15;
  uint audioThresholdFlag16;
  uint8_t audioCoefficientArray17 [16];
  float audioSignal18;
  int audioFilterCoeffA;
  float audioSignal19;
  int audioFilterCoeffB;
  float audioSignal21;
  int audioFilterCoeffC;
  float audioSignal22;
  int audioFilterCoeffD;
  uint8_t audioCoefficientArray20 [16];
  float audioSignal23;
  float audioTotalSum;
  float audioSignal24;
  float audioSignal25;
  float audioSignal26;
  float audioSignal27;
  float audioSignal28;
  float audioSignal29;
  float audioSignal30;
  float audioSignal31;
  float audioSignal32;
  float audioSignal33;
  float audioSignal34;
  float audioSignal35;
  float audioSignal36;
  float audioSignal37;
  float audioSignal38;
  int AudioChannelCoefficient1;
  int AudioChannelCoefficient2;
  int AudioChannelCoefficient3;
  int AudioChannelCoefficient4;
  
  audioStatusIndex0 = 0;
  if (0 < (int)audioTotalChannels) {
    audioSignal25 = audioTotalSum;
    if (7 < audioTotalChannels) {
      audioProcessingFlag9 = audioTotalChannels & 0x80000007;
      if ((int)audioProcessingFlag9 < 0) {
        audioProcessingFlag9 = (audioProcessingFlag9 - 1 | 0xfffffff8) + 1;
      }
      audioCoefficientArray20._0_4_ = audioFilterCoeffA + -1;
      audioCoefficientArray20._4_4_ = audioFilterCoeffB + -1;
      audioCoefficientArray20._8_4_ = audioFilterCoeffC + -1;
      audioCoefficientArray20._12_4_ = audioFilterCoeffD + -1;
      audioCoefficientArray17._0_4_ = (float)audioCoefficientArray20._0_4_;
      audioCoefficientArray17._4_4_ = (float)audioCoefficientArray20._4_4_;
      audioCoefficientArray17._8_4_ = (float)audioCoefficientArray20._8_4_;
      audioCoefficientArray17._12_4_ = (float)audioCoefficientArray20._12_4_;
      audioCoefficientArray20 = rcpps(audioCoefficientArray20,audioCoefficientArray17);
      audioSignal25 = 0.0;
      audioSignal29 = 0.0;
      audioSignal31 = 0.0;
      audioSignal18 = 0.0;
      audioSignal19 = audioCoefficientArray20._0_4_;
      audioSignal21 = audioCoefficientArray20._4_4_;
      audioSignal22 = audioCoefficientArray20._8_4_;
      audioSignal23 = audioCoefficientArray20._12_4_;
      audioSignal30 = 0.0;
      audioSignal32 = 0.0;
      audioSignal33 = 0.0;
      audioSignal34 = 0.0;
      audioSignal35 = 0.0;
      audioSignal36 = 0.0;
      audioSignal37 = 0.0;
      audioSignal38 = 0.0;
      audioSignal24 = 0.0;
      audioSignal26 = 0.0;
      audioSignal27 = 0.0;
      audioSignal28 = 0.0;
      audioSignal19 = (audioSignal19 + audioSignal19) - audioSignal19 * audioSignal19 * audioCoefficientArray17._0_4_;
      audioSignal21 = (audioSignal21 + audioSignal21) - audioSignal21 * audioSignal21 * audioCoefficientArray17._4_4_;
      audioSignal22 = (audioSignal22 + audioSignal22) - audioSignal22 * audioSignal22 * audioCoefficientArray17._8_4_;
      audioSignal23 = (audioSignal23 + audioSignal23) - audioSignal23 * audioSignal23 * audioCoefficientArray17._12_4_;
      audioDataPointer11 = audioDataIndexPtr;
      audioStatusIndex2 = audioStatusIndex0;
      do {
        audioSignal1 = *audioDataPointer11;
        audioSignal2 = audioDataPointer11[1];
        audioSignal3 = audioDataPointer11[2];
        audioSignal4 = audioDataPointer11[3];
        audioThresholdFlag13 = -(uint)(0.0001 < audioSignal1);
        audioThresholdFlag14 = -(uint)(0.0001 < audioSignal2);
        audioThresholdFlag15 = -(uint)(0.0001 < audioSignal3);
        audioThresholdFlag16 = -(uint)(0.0001 < audioSignal4);
        audioStatusIndex0 = audioStatusIndex2 + 8;
        audioSignal5 = audioDataPointer11[4];
        audioSignal6 = audioDataPointer11[5];
        audioSignal7 = audioDataPointer11[6];
        audioSignal8 = audioDataPointer11[7];
        audioDataPointer11 = audioDataPointer11 + 8;
        audioSignal25 = (float)((uint)((float)audioStatusIndex2 * (float)AudioChannelCoefficient1 * 0.5 * audioSignal19 * audioSignal1 +
                               audioSignal25) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal25);
        audioSignal29 = (float)((uint)((float)(audioStatusIndex2 + 1) * (float)AudioChannelCoefficient2 * 0.5 * audioSignal21 * audioSignal2 +
                               audioSignal29) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal29);
        audioSignal31 = (float)((uint)((float)(audioStatusIndex2 + 2) * (float)AudioChannelCoefficient3 * 0.5 * audioSignal22 * audioSignal3 +
                               audioSignal31) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal31);
        audioSignal18 = (float)((uint)((float)(audioStatusIndex2 + 3) * (float)AudioChannelCoefficient4 * 0.5 * audioSignal23 * audioSignal4 +
                               audioSignal18) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal18);
        audioSignal24 = (float)((uint)(audioSignal1 + audioSignal24) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal24);
        audioSignal26 = (float)((uint)(audioSignal2 + audioSignal26) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal26);
        audioSignal27 = (float)((uint)(audioSignal3 + audioSignal27) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal27);
        audioSignal28 = (float)((uint)(audioSignal4 + audioSignal28) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal28);
        audioThresholdFlag13 = -(uint)(0.0001 < audioSignal5);
        audioThresholdFlag14 = -(uint)(0.0001 < audioSignal6);
        audioThresholdFlag15 = -(uint)(0.0001 < audioSignal7);
        audioThresholdFlag16 = -(uint)(0.0001 < audioSignal8);
        audioSignal30 = (float)((uint)((float)(audioStatusIndex2 + 4) * (float)unaff_XMM12_Da * 0.5 * audioSignal19 * audioSignal5 +
                               audioSignal30) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal30);
        audioSignal32 = (float)((uint)((float)(audioStatusIndex2 + 5) * (float)unaff_XMM12_Db * 0.5 * audioSignal21 * audioSignal6 +
                               audioSignal32) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal32);
        audioSignal33 = (float)((uint)((float)(audioStatusIndex2 + 6) * (float)unaff_XMM12_Dc * 0.5 * audioSignal22 * audioSignal7 +
                               audioSignal33) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal33);
        audioSignal34 = (float)((uint)((float)(audioStatusIndex2 + 7) * (float)unaff_XMM12_Dd * 0.5 * audioSignal23 * audioSignal8 +
                               audioSignal34) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal34);
        audioSignal35 = (float)((uint)(audioSignal5 + audioSignal35) & audioThresholdFlag13 | ~audioThresholdFlag13 & (uint)audioSignal35);
        audioSignal36 = (float)((uint)(audioSignal6 + audioSignal36) & audioThresholdFlag14 | ~audioThresholdFlag14 & (uint)audioSignal36);
        audioSignal37 = (float)((uint)(audioSignal7 + audioSignal37) & audioThresholdFlag15 | ~audioThresholdFlag15 & (uint)audioSignal37);
        audioSignal38 = (float)((uint)(audioSignal8 + audioSignal38) & audioThresholdFlag16 | ~audioThresholdFlag16 & (uint)audioSignal38);
        audioStatusIndex2 = audioStatusIndex0;
      } while (audioStatusIndex0 < (int)(audioTotalChannels - audioProcessingFlag9));
      audioTotalSum = audioSignal27 + audioSignal37 + audioSignal24 + audioSignal35 + audioSignal28 + audioSignal38 + audioSignal26 + audioSignal36;
      audioSignal25 = audioSignal31 + audioSignal33 + audioSignal25 + audioSignal30 + audioSignal18 + audioSignal34 + audioSignal29 + audioSignal32;
    }
    if (audioStatusIndex0 < (int)audioTotalChannels) {
      if (3 < (int)(audioTotalChannels - audioStatusIndex0)) {
        audioStatusIndex2 = audioStatusIndex0 + 2;
        audioSignal29 = (float)audioProcessingFactor;
        audioDataPointer11 = audioDataIndexPtr + (long long)audioStatusIndex0 + 2;
        audioSignal31 = (float)(int)audioTotalChannels;
        do {
          audioSignal18 = audioDataPointer11[-2];
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + ((audioSignal29 * 0.5 * (float)audioStatusIndex0) / audioSignal31) * audioSignal18;
          }
          audioSignal18 = audioDataPointer11[-1];
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + (((float)(audioStatusIndex2 + -1) * audioSignal29 * 0.5) / audioSignal31) * audioSignal18;
          }
          audioSignal18 = *audioDataPointer11;
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + (((float)audioStatusIndex2 * audioSignal29 * 0.5) / audioSignal31) * audioSignal18;
          }
          audioSignal18 = audioDataPointer11[1];
          if (0.0001 < audioSignal18) {
            audioTotalSum = audioTotalSum + audioSignal18;
            audioSignal25 = audioSignal25 + (((float)(audioStatusIndex2 + 1) * audioSignal29 * 0.5) / audioSignal31) * audioSignal18;
          }
          audioDataPointer11 = audioDataPointer11 + 4;
          audioStatusIndex0 = audioStatusIndex0 + 4;
          audioStatusIndex2 = audioStatusIndex2 + 4;
        } while (audioStatusIndex0 < (int)(audioTotalChannels - 3));
      }
      if (audioStatusIndex0 < (int)audioTotalChannels) {
        audioDataPointer11 = audioDataIndexPtr + audioStatusIndex0;
        do {
          audioSignal29 = *audioDataPointer11;
          if (0.0001 < audioSignal29) {
            audioTotalSum = audioTotalSum + audioSignal29;
            audioSignal25 = audioSignal25 + (((float)audioProcessingFactor * 0.5 * (float)audioStatusIndex0) / (float)(int)audioTotalChannels) *
                              audioSignal29;
          }
          audioDataPointer11 = audioDataPointer11 + 1;
          audioStatusIndex0 = audioStatusIndex0 + 1;
        } while (audioStatusIndex0 < (int)audioTotalChannels);
      }
    }
    if (0.001 < audioTotalSum) {
      *audioOutputBuffer = audioSignal25 / audioTotalSum;
      return 0;
    }
  }
  *audioOutputBuffer = 0.0;
  return 0;
}



/**
 * @brief 系统资源配置处理函数
 * 
 * 该函数负责处理系统资源的配置和管理，包括：
 * - 系统资源的初始化和配置
 * - 配置数据的处理和应用
 * - 系统参数的优化和调整
 * - 资源状态的监控和管理
 * 
 * @param SystemResourceManager 系统资源指针
 * @param ConfigurationDataPointer 配置数据指针
 * @param AdditionalParameter 附加参数
 * @param ConfigurationFlag 配置标志
 * @return void* 返回处理结果指针
 * 
 * @note 这是系统资源管理的核心函数，用于系统配置的深度处理
 */
void* ProcessSystemResourceConfiguration(int SystemResourceManager,void* ConfigurationDataPointer,void* AdditionalParameter,uint ConfigurationFlag)

{
  float AudioSignalChannel1;
  float AudioSignalChannel2;
  float AudioSignalChannel3;
  float AudioSignalChannel4;
  float AudioSignalChannel5;
  float AudioSignalChannel6;
  float AudioSignalChannel7;
  float AudioSignalChannel8;
  uint AudioProcessingStatusFlag;
  float *AudioDataBufferPointer;
  int AudioProcessingFactor;
  float *AudioDataIndexPointer;
  int AudioStatusIndex;
  float *AudioOutputBuffer;
  uint AudioThresholdFlag1;
  uint AudioThresholdFlag2;
  uint AudioThresholdFlag3;
  uint AudioThresholdFlag4;
  uint8_t AudioCoefficientArray1[16];
  float AudioFilterInputSignal;
  int AudioFilterCoefficientA;
  float AudioFilterOutputSignal;
  int AudioFilterCoefficientB;
  float AudioFilterProcessedSignal;
  int AudioFilterCoefficientC;
  float AudioFilterFinalSignal;
  int AudioFilterCoefficientD;
  uint8_t AudioCoefficientArray2[16];
  float AudioAmplifiedSignal;
  float AudioSignalMixed1;
  float AudioSignalMixed2;
  float AudioSignalMixed3;
  float AudioSignalMixed4;
  float AudioSignalMixed5;
  float AudioSignalMixed6;
  float AudioSignalMixed7;
  float AudioSignalMixed8;
  float AudioSignalMixed9;
  float AudioSignalMixed10;
  float AudioSignalMixed11;
  float VolumeControlValue1;
  float VolumeControlValue2;
  float VolumeControlValue3;
  float VolumeControlValue4;
  int AudioInterpolationCoeff1;
  int AudioInterpolationCoeff2;
  int AudioInterpolationCoeff3;
  int AudioInterpolationCoeff4;
  
  ThreadContextFlag = ConfigurationFlag & 0x80000007;
  if ((int)ThreadContextFlag < 0) {
    ThreadContextFlag = (ThreadContextFlag - 1 | 0xfffffff8) + 1;
  }
  aSystemContextPointer._0_4_ = in_XMM5_Da + -1;
  aSystemContextPointer._4_4_ = in_XMM5_Db + -1;
  aSystemContextPointer._8_4_ = in_XMM5_Dc + -1;
  aSystemContextPointer._12_4_ = in_XMM5_Dd + -1;
  aSystemOperationStatusFlags._0_4_ = (float)aSystemContextPointer._0_4_;
  aSystemOperationStatusFlags._4_4_ = (float)aSystemContextPointer._4_4_;
  aSystemOperationStatusFlags._8_4_ = (float)aSystemContextPointer._8_4_;
  aSystemOperationStatusFlags._12_4_ = (float)aSystemContextPointer._12_4_;
  aSystemContextPointer = rcpps(aSystemContextPointer,aSystemOperationStatusFlags);
  floatValue24 = 0.0;
  floatValue28 = 0.0;
  floatValue30 = 0.0;
  InterpolationParam5 = 0.0;
  MagnitudeSquared = aSystemContextPointer._0_4_;
  ResultValue2 = aSystemContextPointer._4_4_;
  floatValue21 = aSystemContextPointer._8_4_;
  floatValue22 = aSystemContextPointer._12_4_;
  floatValue29 = 0.0;
  floatValue31 = 0.0;
  floatValue32 = 0.0;
  floatValue33 = 0.0;
  floatValue34 = 0.0;
  floatValue35 = 0.0;
  floatValue36 = 0.0;
  floatValue37 = 0.0;
  floatValue23 = 0.0;
  floatValue25 = 0.0;
  floatValue26 = 0.0;
  floatValue27 = 0.0;
  MagnitudeSquared = (MagnitudeSquared + MagnitudeSquared) - MagnitudeSquared * MagnitudeSquared * aSystemOperationStatusFlags._0_4_;
  ResultValue2 = (ResultValue2 + ResultValue2) - ResultValue2 * ResultValue2 * aSystemOperationStatusFlags._4_4_;
  floatValue21 = (floatValue21 + floatValue21) - floatValue21 * floatValue21 * aSystemOperationStatusFlags._8_4_;
  floatValue22 = (floatValue22 + floatValue22) - floatValue22 * floatValue22 * aSystemOperationStatusFlags._12_4_;
  pScalingFactor = systemDataIndexPtr;
  do {
    SystemOperationStatus1 = SystemResourceManager;
    floatValue1 = *pScalingFactor;
    floatValue2 = pScalingFactor[1];
    floatValue3 = pScalingFactor[2];
    floatValue4 = pScalingFactor[3];
    SystemSecondaryStatus = -(uint)(0.0001 < floatValue1);
    SystemOperationStatus3 = -(uint)(0.0001 < floatValue2);
    SystemOperationStatus4 = -(uint)(0.0001 < floatValue3);
    SystemOperationStatus5 = -(uint)(0.0001 < floatValue4);
    SystemResourceManager = SystemOperationStatus1 + 8;
    BaseValue = pScalingFactor[4];
    floatValue6 = pScalingFactor[5];
    floatValue7 = pScalingFactor[6];
    floatValue8 = pScalingFactor[7];
    pScalingFactor = pScalingFactor + 8;
    floatValue24 = (float)((uint)((float)SystemOperationStatus1 * (float)InterpolationCoefficient1 * 0.5 * MagnitudeSquared * floatValue1 + floatValue24) &
                     SystemSecondaryStatus | ~SystemSecondaryStatus & (uint)floatValue24);
    floatValue28 = (float)((uint)((float)(SystemOperationStatus1 + 1) * (float)InterpolationCoefficient2 * 0.5 * ResultValue2 * floatValue2 +
                           floatValue28) & SystemOperationStatus3 | ~SystemOperationStatus3 & (uint)floatValue28);
    floatValue30 = (float)((uint)((float)(SystemOperationStatus1 + 2) * (float)InterpolationCoefficient3 * 0.5 * floatValue21 * floatValue3 +
                           floatValue30) & SystemOperationStatus4 | ~SystemOperationStatus4 & (uint)floatValue30);
    InterpolationParam5 = (float)((uint)((float)(SystemOperationStatus1 + 3) * (float)InterpolationCoefficient4 * 0.5 * floatValue22 * floatValue4 +
                           InterpolationParam5) & SystemOperationStatus5 | ~SystemOperationStatus5 & (uint)InterpolationParam5);
    floatValue23 = (float)((uint)(floatValue1 + floatValue23) & SystemSecondaryStatus | ~SystemSecondaryStatus & (uint)floatValue23);
    floatValue25 = (float)((uint)(floatValue2 + floatValue25) & SystemOperationStatus3 | ~SystemOperationStatus3 & (uint)floatValue25);
    floatValue26 = (float)((uint)(floatValue3 + floatValue26) & SystemOperationStatus4 | ~SystemOperationStatus4 & (uint)floatValue26);
    floatValue27 = (float)((uint)(floatValue4 + floatValue27) & SystemOperationStatus5 | ~SystemOperationStatus5 & (uint)floatValue27);
    SystemSecondaryStatus = -(uint)(0.0001 < BaseValue);
    SystemOperationStatus3 = -(uint)(0.0001 < floatValue6);
    SystemOperationStatus4 = -(uint)(0.0001 < floatValue7);
    SystemOperationStatus5 = -(uint)(0.0001 < floatValue8);
    floatValue29 = (float)((uint)((float)(SystemOperationStatus1 + 4) * (float)unaff_XMM12_Da * 0.5 * MagnitudeSquared * BaseValue +
                           floatValue29) & SystemSecondaryStatus | ~SystemSecondaryStatus & (uint)floatValue29);
    floatValue31 = (float)((uint)((float)(SystemOperationStatus1 + 5) * (float)unaff_XMM12_Db * 0.5 * ResultValue2 * floatValue6 +
                           floatValue31) & SystemOperationStatus3 | ~SystemOperationStatus3 & (uint)floatValue31);
    floatValue32 = (float)((uint)((float)(SystemOperationStatus1 + 6) * (float)unaff_XMM12_Dc * 0.5 * floatValue21 * floatValue7 +
                           floatValue32) & SystemOperationStatus4 | ~SystemOperationStatus4 & (uint)floatValue32);
    floatValue33 = (float)((uint)((float)(SystemOperationStatus1 + 7) * (float)unaff_XMM12_Dd * 0.5 * floatValue22 * floatValue8 +
                           floatValue33) & SystemOperationStatus5 | ~SystemOperationStatus5 & (uint)floatValue33);
    floatValue34 = (float)((uint)(BaseValue + floatValue34) & SystemSecondaryStatus | ~SystemSecondaryStatus & (uint)floatValue34);
    floatValue35 = (float)((uint)(floatValue6 + floatValue35) & SystemOperationStatus3 | ~SystemOperationStatus3 & (uint)floatValue35);
    floatValue36 = (float)((uint)(floatValue7 + floatValue36) & SystemOperationStatus4 | ~SystemOperationStatus4 & (uint)floatValue36);
    floatValue37 = (float)((uint)(floatValue8 + floatValue37) & SystemOperationStatus5 | ~SystemOperationStatus5 & (uint)floatValue37);
  } while (SystemResourceManager < (int)(ConfigurationFlag - ThreadContextFlag));
  MagnitudeSquared = floatValue26 + floatValue36 + floatValue23 + floatValue34 + floatValue27 + floatValue37 + floatValue25 + floatValue35;
  floatValue24 = floatValue30 + floatValue32 + floatValue24 + floatValue29 + InterpolationParam5 + floatValue33 + floatValue28 + floatValue31;
  if (SystemResourceManager < (int)ConfigurationFlag) {
    if (3 < (int)(ConfigurationFlag - SystemResourceManager)) {
      SystemOperationStatus1 = SystemOperationStatus1 + 10;
      floatValue28 = (float)unaff_EBX;
      pScalingFactor = systemDataIndexPtr + (long long)SystemResourceManager + 2;
      floatValue30 = (float)(int)ConfigurationFlag;
      do {
        InterpolationParam5 = pScalingFactor[-2];
        if (0.0001 < InterpolationParam5) {
          MagnitudeSquared = MagnitudeSquared + InterpolationParam5;
          floatValue24 = floatValue24 + ((floatValue28 * 0.5 * (float)SystemResourceManager) / floatValue30) * InterpolationParam5;
        }
        InterpolationParam5 = pScalingFactor[-1];
        if (0.0001 < InterpolationParam5) {
          MagnitudeSquared = MagnitudeSquared + InterpolationParam5;
          floatValue24 = floatValue24 + (((float)(SystemOperationStatus1 + -1) * floatValue28 * 0.5) / floatValue30) * InterpolationParam5;
        }
        InterpolationParam5 = *pScalingFactor;
        if (0.0001 < InterpolationParam5) {
          MagnitudeSquared = MagnitudeSquared + InterpolationParam5;
          floatValue24 = floatValue24 + (((float)SystemOperationStatus1 * floatValue28 * 0.5) / floatValue30) * InterpolationParam5;
        }
        InterpolationParam5 = pScalingFactor[1];
        if (0.0001 < InterpolationParam5) {
          MagnitudeSquared = MagnitudeSquared + InterpolationParam5;
          floatValue24 = floatValue24 + (((float)(SystemOperationStatus1 + 1) * floatValue28 * 0.5) / floatValue30) * InterpolationParam5;
        }
        pScalingFactor = pScalingFactor + 4;
        SystemResourceManager = SystemResourceManager + 4;
        SystemOperationStatus1 = SystemOperationStatus1 + 4;
      } while (SystemResourceManager < (int)(ConfigurationFlag - 3));
    }
    if (SystemResourceManager < (int)ConfigurationFlag) {
      pScalingFactor = systemDataIndexPtr + SystemResourceManager;
      do {
        floatValue28 = *pScalingFactor;
        if (0.0001 < floatValue28) {
          MagnitudeSquared = MagnitudeSquared + floatValue28;
          floatValue24 = floatValue24 + (((float)unaff_EBX * 0.5 * (float)SystemResourceManager) / (float)(int)ConfigurationFlag) *
                            floatValue28;
        }
        pScalingFactor = pScalingFactor + 1;
        SystemResourceManager = SystemResourceManager + 1;
      } while (SystemResourceManager < (int)ConfigurationFlag);
    }
  }
  if (MagnitudeSquared <= 0.001) {
    *in_R11 = 0.0;
  }
  else {
    *in_R11 = floatValue24 / MagnitudeSquared;
  }
  return 0;
}



/**
 * @brief 计算浮点数组的加权平均值
 * 
 * 该函数计算一个浮点数组的加权平均值，通过遍历数组元素并应用权重计算。
 * 这是一个用于数学统计和数据分析的函数。
 * 
 * @param startIndex 起始索引，指定数组的开始位置
 * @param arrayBasePointer 数组基址指针，指向浮点数组的起始位置
 * @param resultPointer 结果指针，用于存储计算结果
 * @param weightFactor 权重因子，用于计算加权平均值
 * @return 计算成功返回0，失败返回非零值
 */
void* CalculateWeightedAverageFloatArray(int startIndex, void* arrayBasePointer, void* resultPointer, float weightFactor)

{
  float currentValue;
  float *arrayPointer;
  int stepSize;
  long long baseAddress;
  int endIndex;
  float *resultStorage;
  float weightedSum;
  float rangeFactor;
  int offsetIndex;
  
  if (startIndex < endIndex) {
    if (3 < endIndex - startIndex) {
      offsetIndex = startIndex + 2;
      rangeFactor = (float)stepSize;
      arrayPointer = (float *)(baseAddress + ((long long)startIndex + 2) * 4);
      float totalCount = (float)endIndex;
      do {
        currentValue = arrayPointer[-2];
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + ((rangeFactor * 0.5 * (float)startIndex) / totalCount) * currentValue;
        }
        currentValue = arrayPointer[-1];
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + (((float)(offsetIndex + -1) * rangeFactor * 0.5) / totalCount) * currentValue;
        }
        currentValue = *arrayPointer;
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + (((float)offsetIndex * rangeFactor * 0.5) / totalCount) * currentValue;
        }
        currentValue = arrayPointer[1];
        if (0.0001 < currentValue) {
          weightFactor = weightFactor + currentValue;
          weightedSum = weightedSum + (((float)(offsetIndex + 1) * rangeFactor * 0.5) / totalCount) * currentValue;
        }
        arrayPointer = arrayPointer + 4;
        startIndex = startIndex + 4;
        offsetIndex = offsetIndex + 4;
      } while (startIndex < endIndex + -3);
    }
    if (startIndex < endIndex) {
      arrayPointer = (float *)(baseAddress + (long long)startIndex * 4);
      do {
        rangeFactor = *arrayPointer;
        if (0.0001 < rangeFactor) {
          weightFactor = weightFactor + rangeFactor;
          weightedSum =
               weightedSum + (((float)stepSize * 0.5 * (float)startIndex) / (float)endIndex) * rangeFactor;
        }
        arrayPointer = arrayPointer + 1;
        startIndex = startIndex + 1;
      } while (startIndex < endIndex);
    }
  }
  if (weightFactor <= 0.001) {
    *resultStorage = 0.0;
  }
  else {
    *resultStorage = weightedSum / weightFactor;
  }
  return 0;
}



/**
 * @brief 计算旋转变换矩阵
 * 
 * 该函数根据给定的旋转位数计算变换矩阵，用于3D图形渲染中的旋转操作。
 * 这是一个复杂的数学计算函数，涉及位操作、三角函数和矩阵运算。
 * 
 * @param transformContext 变换上下文指针，包含变换所需的数据
 * @param rotationBits 旋转位数，控制旋转的精度
 * @return 变换结果指针
 * @note 这是一个简化的实现，部分变量名仍需要进一步美化
 */
void* CalculateRotationTransform(long long transformContext, uint rotationBits)

{
  float sineValue;
  float cosineValue;
  float angleValue;
  long long matrixPointer;
  int bitMaskValue;
  uint halfRangeValue;
  ulong long bitValue;
  ulong long maxBits;
  uint bitIndexValue;
  uint reversedBits;
  long long rowIndex;
  int columnIndex;
  int chunkIndexValue;
  uint elementIndexValue;
  ulong long chunkSizeValue;
  long long startRowValue;
  ulong long currentChunkValue;
  ulong long elementOffsetValue;
  ulong long matrixElementValue;
  float rotationSine;
  float rotationCosine;
  float temporaryFloatValue1;
  float temporaryFloatValue2;
  uint32_t loopCounterValue;
  
  maxBits = (ulong long)rotationBits;
  loopCounterValue = 1;
  bitMaskValue = 1 << ((byte)rotationBits & BIT_MASK_32_BIT);
  halfRangeValue = bitMaskValue / 2;
  if (0 < (int)rotationBits) {
    do {
      int rowIndex = 0;
      if (0 < (int)loopCounterValue) {
        ulong long columnCount = (ulong long)loopCounter;
        do {
          ulong long normalizedIndex = (long long)rowIndex / (long long)(int)halfRange & MAX_UNSIGNED_32_BIT;
          uint reversedBits = 0;
          uint bitCount = rotationBits;
          if (rotationBits != 0) {
            do {
              uint currentBit = (uint)normalizedIndex;
              normalizedIndex = normalizedIndex >> 1;
              reversedBits = reversedBits * 2 | currentBit & 1;
              bitCount = bitCount - 1;
            } while (bitCount != 0);
          }
          float angleValue = (float)(int)reversedBits * (1.0 / (float)bitMaskValue);
          uint lookupIndex = (uint)(angleValue * 32768.0);
          if ((int)lookupIndex < 0) {
            lookupIndex = -lookupIndex;
          }
          lookupIndex = lookupIndex & SINE_LOOKUP_TABLE_SIZE;
          ulong long sineLookupIndex = (ulong long)lookupIndex;
          uint quadrant = lookupIndex >> QUADRANT_SHIFT_BITS;
          float sineValue;
          if (lookupIndex >> QUADRANT_SHIFT_BITS == 0) {
            sineValue = *(float *)(transformContext + 0x4cc + sineLookupIndex * 4);
          }
          else if (quadrant == 1) {
            sineValue = -*(float *)(transformContext + (0x4132 - (ulong long)lookupIndex) * 4);
          }
          else if (quadrant == 2) {
            sineValue = -*(float *)(transformContext + -0xfb34 + sineLookupIndex * 4);
          }
          else if (quadrant == 3) {
            sineValue = *(float *)(transformContext + (0x8132 - sineLookupIndex) * 4);
          }
          else {
            sineValue = 0.0;
          }
          lookupIndex = (uint)((angleValue - 0.25) * 32768.0);
          if ((int)lookupIndex < 0) {
            lookupIndex = -lookupIndex;
          }
          lookupIndex = lookupIndex & SINE_LOOKUP_TABLE_SIZE;
          sineLookupIndex = (ulong long)lookupIndex;
          quadrant = lookupIndex >> QUADRANT_SHIFT_BITS;
          float cosineValue;
          if (lookupIndex >> QUADRANT_SHIFT_BITS == 0) {
            cosineValue = *(float *)(transformContext + 0x4cc + sineLookupIndex * 4);
          }
          else if (quadrant == 1) {
            cosineValue = -*(float *)(transformContext + (0x4132 - (ulong long)lookupIndex) * 4);
          }
          else if (quadrant == 2) {
            cosineValue = -*(float *)(transformContext + -0xfb34 + sineLookupIndex * 4);
          }
          else if (quadrant == 3) {
            cosineValue = *(float *)(transformContext + (0x8132 - sineLookupIndex) * 4);
          }
          else {
            cosineValue = 0.0;
          }
          long long startRow = (long long)rowIndex;
          long long endRow = (long long)(int)(rowIndex + halfRangeValue);
          cosineValue = -cosineValue;
          if (startRow < endRow) {
            int currentRow = rowIndex;
            if (3 < endRow - startRow) {
              uint targetRow = rowIndex + halfRange + 3;
              currentRow = rowIndex + ((int)(((endRow + -3) - startRow) - 1U >> 2) + 1) * 4;
              do {
                ulong long fourthRowOffset = (ulong long)targetRow;
                long long matrixPointer = *(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218);
                ulong long thirdRowOffset = (ulong long)(targetRow - 1);
                ulong long secondRowOffset = (ulong long)(targetRow - 2);
                uint firstRowOffset = targetRow - 3;
                float fourthRowSine = *(float *)(matrixPointer + 4 + (ulong long)firstRowOffset * 8);
                float fourthRowCosine = *(float *)(matrixPointer + (ulong long)firstRowOffset * 8);
                float matrixVal1 = *(float *)(matrixPointer + startRow * 8);
                float matrixVal2 = *(float *)(matrixPointer + 4 + startRow * 8);
                float firstResult = fourthRowCosine * sineValue - fourthRowSine * cosineValue;
                float secondResult = fourthRowSine * sineValue + fourthRowCosine * cosineValue;
                *(float *)(matrixPointer + startRow * 8) = firstResult + matrixVal1;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + startRow * 8) = secondResult + matrixVal2;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + (ulong long)firstRowOffset * 8) = matrixVal1 - firstResult;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + (ulong long)firstRowOffset * 8) =
                     matrixVal2 - secondResult;
                matrixPointer = *(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218);
                secondResult = *(float *)(matrixPointer + 4 + secondRowOffset * 8);
                firstResult = *(float *)(matrixPointer + secondRowOffset * 8);
                matrixVal1 = *(float *)(matrixPointer + 8 + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 0xc + startRow * 8);
                float thirdResult = firstResult * sineValue - secondResult * cosineValue;
                secondResult = secondResult * sineValue + firstResult * cosineValue;
                *(float *)(matrixPointer + 8 + startRow * 8) = thirdResult + matrixVal1;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 0xc + startRow * 8) = secondResult + matrixVal2;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + secondRowOffset * 8) = matrixVal1 - thirdResult;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + secondRowOffset * 8) = matrixVal2 - secondResult;
                matrixPointer = *(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218);
                secondResult = *(float *)(matrixPointer + thirdRowOffset * 8);
                firstResult = *(float *)(matrixPointer + 4 + thirdRowOffset * 8);
                matrixVal1 = *(float *)(matrixPointer + 0x10 + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 0x14 + startRow * 8);
                thirdResult = secondResult * sineValue - firstResult * cosineValue;
                secondResult = firstResult * sineValue + secondResult * cosineValue;
                *(float *)(matrixPointer + 0x10 + startRow * 8) = thirdResult + matrixVal1;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 0x14 + startRow * 8) = secondResult + matrixVal2;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + thirdRowOffset * 8) = matrixVal1 - thirdResult;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + thirdRowOffset * 8) = matrixVal2 - secondResult;
                matrixPointer = *(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218);
                secondResult = *(float *)(matrixPointer + fourthRowOffset * 8);
                firstResult = *(float *)(matrixPointer + 4 + fourthRowOffset * 8);
                matrixVal1 = *(float *)(matrixPointer + 0x18 + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 0x1c + startRow * 8);
                thirdResult = secondResult * sineValue - firstResult * cosineValue;
                secondResult = firstResult * sineValue + secondResult * cosineValue;
                *(float *)(matrixPointer + 0x18 + startRow * 8) = thirdResult + matrixVal1;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 0x1c + startRow * 8) = secondResult + matrixVal2;
                startRow = startRow + 4;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + fourthRowOffset * 8) = matrixVal1 - thirdResult;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + fourthRowOffset * 8) = matrixVal2 - secondResult;
                targetRow = targetRow + 4;
              } while (startRow < endRow + -3);
            }
            if (startRow < endRow) {
              targetRow = currentRow + halfRange;
              do {
                ulong long targetRowIndex = (ulong long)targetRow;
                matrixPointer = *(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218);
                secondResult = *(float *)(matrixPointer + targetRowIndex * 8);
                firstResult = *(float *)(matrixPointer + 4 + targetRowIndex * 8);
                matrixVal1 = *(float *)(matrixPointer + startRow * 8);
                matrixVal2 = *(float *)(matrixPointer + 4 + startRow * 8);
                float intermediateResult = secondResult * sineValue - firstResult * cosineValue;
                secondResult = firstResult * sineValue + secondResult * cosineValue;
                *(float *)(matrixPointer + startRow * 8) = intermediateResult + matrixVal1;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + startRow * 8) = secondResult + matrixVal2;
                startRow = startRow + 1;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + targetRowIndex * 8) = matrixVal1 - intermediateResult;
                *(float *)(*(long long *)(transformContext + TRANSFORM_CONTEXT_OFFSET_218) + 4 + targetRowIndex * 8) = matrixVal2 - secondResult;
                targetRow = targetRow + 1;
              } while (startRow < endRow);
            }
          }
          rowIndex = rowIndex + halfRange * 2;
          columnCount = columnCount - 1;
        } while (columnCount != 0);
      }
      loopCounterValue = loopCounter * 2;
      halfRangeValue = halfRange >> 1;
      maxBits = maxBits - 1;
    } while (maxBits != 0);
  }
  return 0;
}



/**
 * @brief 执行快速傅里叶变换
 * 
 * 该函数实现了快速傅里叶变换算法，用于在频域分析信号数据。
 * 主要用于音频处理、图像处理和信号分析等场景。
 * 
 * @param context 上下文指针，包含变换所需的配置数据
 * @param dataBuffer 数据缓冲区，包含要变换的输入数据
 * @param dataSize 数据大小，指定要处理的数据点数
 * @return 执行结果状态码
 */
void* FastFourierTransform(void* context, void* dataBuffer, uint dataSize)

{
  float temporaryFloatValue1;
  float temporaryFloatValue2;
  float temporaryFloatValue3;
  long long matrixPointer;
  ulong long bitValue;
  ulong long maxBits;
  uint reversedBits;
  uint currentBit;
  long long endRow;
  int currentRow;
  int rowIndex;
  uint lookupIndex;
  ulong long targetRow;
  long long startRowValue;
  long long contextData;
  ulong long targetIndex;
  uint bitCount;
  uint halfRangeValue;
  ulong long row4;
  float sineValue;
  float cosineValue;
  float angleValue;
  float resultValue;
  float scaleValue;
  uint stackParameter;
  
  ResourceHash = (ulong long)SystemResourceIndex;
  do {
    SystemOperationStatus1 = 0;
    if (0 < (int)AdditionalParameter) {
      SystemOperationStatus5 = (ulong long)AdditionalParameter;
      do {
        currentThreadId = (long long)SystemOperationStatus1 / (long long)(int)systemResourceCounterD & MAX_UNSIGNED_32_BIT;
        ThreadContextFlag = 0;
        SystemSecondaryStatus = SystemResourceIndex;
        if (SystemResourceIndex != 0) {
          do {
            OperationCode = (uint)currentThreadId;
            currentThreadId = currentThreadId >> 1;
            ThreadContextFlag = ThreadContextFlag * 2 | OperationCode & 1;
            SystemSecondaryStatus = SystemSecondaryStatus - 1;
          } while (SystemSecondaryStatus != 0);
        }
        SystemSecondaryStatus = (uint)((float)(int)ThreadContextFlag * unaff_XMM10_Da * 32768.0);
        if ((int)SystemSecondaryStatus < 0) {
          SystemSecondaryStatus = -SystemSecondaryStatus;
        }
        SystemSecondaryStatus = SystemSecondaryStatus & SINE_LOOKUP_TABLE_SIZE;
        currentThreadId = (ulong long)SystemSecondaryStatus;
        OperationCode = SystemSecondaryStatus >> QUADRANT_SHIFT_BITS;
        if (SystemSecondaryStatus >> QUADRANT_SHIFT_BITS == 0) {
          ResultValue2 = *(float *)(in_R11 + 0x4cc + currentThreadId * 4);
        }
        else if (OperationCode == 1) {
          ResultValue2 = -*(float *)(in_R11 + (0x4132 - (ulong long)SystemSecondaryStatus) * 4);
        }
        else if (OperationCode == 2) {
          ResultValue2 = -*(float *)(in_R11 + -0xfb34 + currentThreadId * 4);
        }
        else if (OperationCode == 3) {
          ResultValue2 = *(float *)(in_R11 + (0x8132 - currentThreadId) * 4);
        }
        else {
          ResultValue2 = 0.0;
        }
        SystemSecondaryStatus = (uint)(((float)(int)ThreadContextFlag * unaff_XMM10_Da - 0.25) * 32768.0);
        if ((int)SystemSecondaryStatus < 0) {
          SystemSecondaryStatus = -SystemSecondaryStatus;
        }
        SystemSecondaryStatus = SystemSecondaryStatus & SINE_LOOKUP_TABLE_SIZE;
        currentThreadId = (ulong long)SystemSecondaryStatus;
        ThreadContextFlag = SystemSecondaryStatus >> QUADRANT_SHIFT_BITS;
        if (SystemSecondaryStatus >> QUADRANT_SHIFT_BITS == 0) {
          ResultValue1 = *(float *)(in_R11 + 0x4cc + currentThreadId * 4);
        }
        else if (ThreadContextFlag == 1) {
          ResultValue1 = -*(float *)(in_R11 + (0x4132 - (ulong long)SystemSecondaryStatus) * 4);
        }
        else if (ThreadContextFlag == 2) {
          ResultValue1 = -*(float *)(in_R11 + -0xfb34 + currentThreadId * 4);
        }
        else if (ThreadContextFlag == 3) {
          ResultValue1 = *(float *)(in_R11 + (0x8132 - currentThreadId) * 4);
        }
        else {
          ResultValue1 = 0.0;
        }
        resourceDataIndex4 = (long long)SystemOperationStatus1;
        resourceCounter = (long long)(int)(SystemOperationStatus1 + systemResourceCounterD);
        ResultValue1 = -ResultValue1;
        if (resourceDataIndex4 < resourceCounter) {
          SystemOperationStatus0 = SystemOperationStatus1;
          if (3 < resourceCounter - resourceDataIndex4) {
            SystemSecondaryStatus = SystemOperationStatus1 + systemResourceCounterD + 3;
            SystemOperationStatus0 = SystemOperationStatus1 + ((int)(((resourceCounter + -3) - resourceDataIndex4) - 1U >> 2) + 1) * 4;
            do {
              SystemOperationStatusFlags = (ulong long)SystemSecondaryStatus;
              SystemBufferAddress = *(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218);
              SystemOperationStatus3 = (ulong long)(SystemSecondaryStatus - 1);
              currentThreadId = (ulong long)(SystemSecondaryStatus - 2);
              ThreadContextFlag = SystemSecondaryStatus - 3;
              MagnitudeSquared = *(float *)(SystemBufferAddress + 4 + (ulong long)ThreadContextFlag * 8);
              floatValue1 = *(float *)(SystemBufferAddress + (ulong long)ThreadContextFlag * 8);
              floatValue2 = *(float *)(SystemBufferAddress + resourceDataIndex4 * 8);
              floatValue3 = *(float *)(SystemBufferAddress + 4 + resourceDataIndex4 * 8);
              InterpolationParam5 = floatValue1 * ResultValue2 - MagnitudeSquared * ResultValue1;
              MagnitudeSquared = MagnitudeSquared * ResultValue2 + floatValue1 * ResultValue1;
              *(float *)(SystemBufferAddress + resourceDataIndex4 * 8) = InterpolationParam5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + resourceDataIndex4 * 8) = MagnitudeSquared + floatValue3;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + (ulong long)ThreadContextFlag * 8) = floatValue2 - InterpolationParam5;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + (ulong long)ThreadContextFlag * 8) = floatValue3 - MagnitudeSquared;
              SystemBufferAddress = *(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218);
              MagnitudeSquared = *(float *)(SystemBufferAddress + 4 + currentThreadId * 8);
              floatValue1 = *(float *)(SystemBufferAddress + currentThreadId * 8);
              floatValue2 = *(float *)(SystemBufferAddress + 8 + resourceDataIndex4 * 8);
              floatValue3 = *(float *)(SystemBufferAddress + 0xc + resourceDataIndex4 * 8);
              InterpolationParam5 = floatValue1 * ResultValue2 - MagnitudeSquared * ResultValue1;
              MagnitudeSquared = MagnitudeSquared * ResultValue2 + floatValue1 * ResultValue1;
              *(float *)(SystemBufferAddress + 8 + resourceDataIndex4 * 8) = InterpolationParam5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 0xc + resourceDataIndex4 * 8) = MagnitudeSquared + floatValue3;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + currentThreadId * 8) = floatValue2 - InterpolationParam5;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + currentThreadId * 8) = floatValue3 - MagnitudeSquared;
              SystemBufferAddress = *(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218);
              MagnitudeSquared = *(float *)(SystemBufferAddress + SystemOperationStatus3 * 8);
              floatValue1 = *(float *)(SystemBufferAddress + 4 + SystemOperationStatus3 * 8);
              floatValue2 = *(float *)(SystemBufferAddress + 0x10 + resourceDataIndex4 * 8);
              floatValue3 = *(float *)(SystemBufferAddress + 0x14 + resourceDataIndex4 * 8);
              InterpolationParam5 = MagnitudeSquared * ResultValue2 - floatValue1 * ResultValue1;
              MagnitudeSquared = floatValue1 * ResultValue2 + MagnitudeSquared * ResultValue1;
              *(float *)(SystemBufferAddress + 0x10 + resourceDataIndex4 * 8) = InterpolationParam5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 0x14 + resourceDataIndex4 * 8) = MagnitudeSquared + floatValue3;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + SystemOperationStatus3 * 8) = floatValue2 - InterpolationParam5;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + SystemOperationStatus3 * 8) = floatValue3 - MagnitudeSquared;
              SystemBufferAddress = *(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218);
              MagnitudeSquared = *(float *)(SystemBufferAddress + SystemOperationStatusFlags * 8);
              floatValue1 = *(float *)(SystemBufferAddress + 4 + SystemOperationStatusFlags * 8);
              floatValue2 = *(float *)(SystemBufferAddress + 0x18 + resourceDataIndex4 * 8);
              floatValue3 = *(float *)(SystemBufferAddress + 0x1c + resourceDataIndex4 * 8);
              InterpolationParam5 = MagnitudeSquared * ResultValue2 - floatValue1 * ResultValue1;
              MagnitudeSquared = floatValue1 * ResultValue2 + MagnitudeSquared * ResultValue1;
              *(float *)(SystemBufferAddress + 0x18 + resourceDataIndex4 * 8) = InterpolationParam5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 0x1c + resourceDataIndex4 * 8) = MagnitudeSquared + floatValue3;
              resourceDataIndex4 = resourceDataIndex4 + 4;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + SystemOperationStatusFlags * 8) = floatValue2 - InterpolationParam5;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + SystemOperationStatusFlags * 8) = floatValue3 - MagnitudeSquared;
              SystemSecondaryStatus = SystemSecondaryStatus + 4;
            } while (resourceDataIndex4 < resourceCounter + -3);
          }
          if (resourceDataIndex4 < resourceCounter) {
            SystemSecondaryStatus = SystemOperationStatus0 + systemResourceCounterD;
            do {
              currentThreadId = (ulong long)SystemSecondaryStatus;
              SystemBufferAddress = *(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218);
              MagnitudeSquared = *(float *)(SystemBufferAddress + currentThreadId * 8);
              floatValue1 = *(float *)(SystemBufferAddress + 4 + currentThreadId * 8);
              floatValue2 = *(float *)(SystemBufferAddress + resourceDataIndex4 * 8);
              floatValue3 = *(float *)(SystemBufferAddress + 4 + resourceDataIndex4 * 8);
              InterpolationParam5 = MagnitudeSquared * ResultValue2 - floatValue1 * ResultValue1;
              MagnitudeSquared = floatValue1 * ResultValue2 + MagnitudeSquared * ResultValue1;
              *(float *)(SystemBufferAddress + resourceDataIndex4 * 8) = InterpolationParam5 + floatValue2;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + resourceDataIndex4 * 8) = MagnitudeSquared + floatValue3;
              resourceDataIndex4 = resourceDataIndex4 + 1;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + currentThreadId * 8) = floatValue2 - InterpolationParam5;
              *(float *)(*(long long *)(in_R11 + TRANSFORM_CONTEXT_OFFSET_218) + 4 + currentThreadId * 8) = floatValue3 - MagnitudeSquared;
              SystemSecondaryStatus = SystemSecondaryStatus + 1;
            } while (resourceDataIndex4 < resourceCounter);
          }
        }
        SystemOperationStatus1 = SystemOperationStatus1 + systemResourceCounterD * 2;
        SystemOperationStatus5 = SystemOperationStatus5 - 1;
        AdditionalParameter = stackParameter;
      } while (SystemOperationStatus5 != 0);
    }
    AdditionalParameter = AdditionalParameter * 2;
    systemResourceCounterD = systemResourceCounterD >> 1;
    ResourceHash = ResourceHash - 1;
    stackParameter = AdditionalParameter;
  } while (ResourceHash != 0);
  return 0;
}



/**
 * @brief 检查系统状态
 * 
 * 该函数是一个简单的状态检查函数，用于检查系统的当前状态。
 * 它返回固定的状态值0，表示系统状态正常。
 * 
 * @return 系统状态码，0表示正常
 * @note 这是一个状态检查函数，用于系统初始化过程中的状态验证
 */
void* CheckSystemStatus(void)

{
  return 0;
}




// 函数: 系统模块加载器 - 负责加载系统模块
void* SystemModuleLoader;

// 函数: 系统接口管理器 - 负责管理系统接口
void* SystemInterfaceManager;
void* SystemModuleLoadFlag;
void* SystemInterfaceHandle;
uint32_t SystemInterfaceVersion;
void* *SystemInterfaceTable;
uint8_t *SystemInterfaceData;
uint32_t SystemInterfaceConfig;
long long SystemInterfaceMemoryBase;
long long SystemInterfaceMemorySize;
long long SystemInterfaceDataOffset;
long long SystemInterfaceDataSize;
uint32_t SystemInterfaceFlags;
uint32_t SystemInterfaceStatus;
void* SystemModuleConfigData;
void* SystemModuleRuntimeData;
void* SystemGlobalConfigFlag;
void* SystemRuntimeDataFlag;
void* SystemModuleLoadStatus;
long long SystemModuleLoadTime;
void* SystemModuleUnloadTime;
long long SystemModuleExecutionTime;
long long *SystemModuleExecutionCounter;

// 系统字符串常量模板
void* SystemStringConstantErrorMessageCritical;
void* SystemStringConstantErrorMessageWarning;
void* SystemStringConstantConfigPathDefault;
void* SystemStringConstantBufferTemplateStandard;
void* SystemStringConstantBufferSizeDefault;
void* SystemStringConstantComputerNameError;
void* SystemStringConstantUserNameError;
void* SystemStringConstantLibraryNameDefault;
void* SystemStringConstantFunctionNameDefault;
void* SystemStringConstantWindowTitleDefault;

// 系统虚拟函数表模板
void* SystemVirtualTableBaseClassPrimary;
void* SystemVirtualTableDerivedClassSecondary;
void* SystemVirtualTableInterfaceStandard;
void* SystemVirtualTableAbstractClassBase;
void* SystemVirtualTableSingletonClassInstance;

// 系统内存管理模板
void* SystemMemoryPoolTemplatePrimary;
void* SystemMemoryPoolTemplateSecondary;
void* SystemMemoryPoolTemplateTertiary;
void* SystemMemoryPoolTemplateQuaternary;
void* SystemMemoryPoolTemplateQuinary;
void* SystemMemoryPoolTemplateSenary;
void* SystemMemoryPoolTemplateSeptenary;

// 系统数据缓冲区模板
void* SystemDataBufferMainTemplatePrimary;
void* SystemDataBufferBackupTemplateSecondary;
void* SystemDataBufferCacheTemplateTertiary;
void* SystemDataBufferTemporaryTemplateQuaternary;
void* SystemDataBufferInputTemplateQuinary;
void* SystemDataBufferOutputTemplateSenary;
void* SystemDataBufferNetworkTemplateSeptenary;
void* SystemDataBufferFileTemplateOctonary;
void* SystemDataBufferMemoryTemplateNonary;
void* SystemDataBufferSystemTemplateDenary;
void* SystemDataBufferUserTemplateUndenary;
void* SystemDataBufferSharedTemplateDuodenary;
void* SystemDataBufferProtectedTemplateTridenary;
void* SystemDataBufferSecureTemplateQuattuordenary;
void* SystemDataBufferDebugTemplateQuindenary;
void* SystemDataBufferTestTemplateSexdenary;
void* SystemDataBufferProductionTemplateSeptendenary;
void* SystemDataBufferDevelopmentTemplateOctodenary;
void* SystemDataBufferStagingTemplateNovendenary;
void* SystemDataBufferArchiveTemplateVigintenary;
void* SystemDataBufferLegacyTemplateUnvigintenary;
void* SystemDataBufferFutureTemplateDuovigintenary;
void* SystemDataBufferExperimentalTemplateTrevigintenary;
void* SystemDataBufferDeprecatedTemplateQuattuorvigintenary;
void* SystemDataBufferReservedTemplateQuinvigintenary;
void* SystemDataBufferEmergencyTemplateSexvigintenary;
void* SystemDataBufferTemplateSeptenvigintenary;
void* SystemDataBufferTemplateOctovigintenary;
void* SystemDataBufferTemplateNovemvigintenary;

/**
 * @brief 获取资源偏移指针函数
 * 
 * 该函数负责获取系统资源的偏移指针，用于资源定位和访问
 * 
 * @param resourcePointer 资源指针
 * @return 资源偏移指针
 * 
 *FUN_18005ff50：GetResourceOffsetPointer
 */
void* GetResourceOffsetPointer(void* resourcePointer);

/**
 * @brief 获取系统资源状态函数
 * 
 * 该函数负责获取系统资源的当前状态，用于资源监控和管理
 * 
 * @return 系统资源状态
 * 
 *FUN_18005f430：GetSystemResourceStatus
 */
long long GetSystemResourceStatus(void);

/**
 * @brief 初始化系统资源处理器函数
 * 
 * 该函数负责初始化系统资源处理器，设置资源处理环境和参数
 * 
 *FUN_180060200：InitializeSystemResourceHandler
 */
void InitializeSystemResourceHandler(void);

/**
 * @brief 验证系统资源上下文函数
 * 
 * 该函数负责验证系统资源上下文的有效性和完整性
 * 
 *FUN_180060420：ValidateSystemResourceContext
 */
void ValidateSystemResourceContext(void);

/**
 * @brief 配置系统资源上下文函数
 * 
 * 该函数负责配置系统资源上下文，设置资源处理参数和属性
 * 
 * @param resourcePointer 资源指针
 * @param configFlag 配置标志
 * @param additionalParameter 额外参数
 * @param configurationFlag 配置标志
 * @param configurationMask 配置掩码
 * @return 配置结果状态
 * 
 *FUN_18020eba0：ConfigureSystemResourceContext
 */
char ConfigureSystemResourceContext(void* resourcePointer, int configFlag, long long additionalParameter, long long configurationFlag, long long configurationMask);

/**
 * @brief 完成系统资源配置函数
 * 
 * 该函数负责完成系统资源的配置过程，进行最终的状态设置
 * 
 *FUN_18020f530：FinalizeSystemResourceConfiguration
 */
void FinalizeSystemResourceConfiguration(void);

/**
 * @brief 清理系统资源处理器函数
 * 
 * 该函数负责清理系统资源处理器，释放相关资源
 * 
 *FUN_18020e6c0：CleanupSystemResourceHandler
 */
void CleanupSystemResourceHandler(void);

/**
 * @brief 释放系统资源句柄函数
 * 
 * 该函数负责释放系统资源句柄，清理相关资源
 * 
 * @param resourceHandle 资源句柄
 * @param releaseFlag 释放标志
 * 
 *FUN_18064e0d0：ReleaseSystemResourceHandle
 */
void ReleaseSystemResourceHandle(void* resourceHandle, int releaseFlag);

/**
 * @brief 处理系统资源数据函数
 * 
 * 该函数负责处理系统资源数据，进行数据的操作和管理
 * 
 * @param resourcePointer 资源指针
 * @param dataPointer 数据指针
 * @param resultPointer 结果指针
 * @param configurationFlag 配置标志
 * @param SystemOperationStatus 系统状态
 * @return 处理结果状态
 * 
 *FUN_180060e40：ProcessSystemResourceData
 */
char ProcessSystemResourceData(void* resourcePointer, void* dataPointer, void* resultPointer, long long configurationFlag, long long SystemOperationStatus);

/**
 * @brief 验证系统资源状态函数
 * 
 * 该函数负责验证系统资源的当前状态
 * 
 * @return 系统资源状态
 * 
 *FUN_180060a50：ValidateSystemResourceStatus
 */
char ValidateSystemResourceStatus(void);

