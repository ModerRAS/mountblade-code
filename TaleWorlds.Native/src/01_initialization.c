#include "TaleWorlds.Native.Split.h"

/**
 * @file 01_initialization.c
 * @brief 系统初始化模块
 */

// 全局函数指针 - 系统初始化相关
void* GameSystemEntryPoint;                    // 游戏系统主入口点
void* GlobalSystemDataReference;              // 全局系统数据引用
void* SystemMemoryPoolPrimary;                 // 主系统内存池
void* SystemDataTableReference;                // 系统数据表引用
void* SystemMemoryPoolSecondary;               // 次级系统内存池
void* SystemDataTableSecondary;                // 次级系统数据表
void* SystemMemoryPoolTertiary;                // 第三级系统内存池
void* SystemDataTableTertiary;                 // 第三级系统数据表
void* SystemMemoryPoolQuaternary;              // 第四级系统内存池
void* SystemDataTableQuaternary;               // 第四级系统数据表
void* SystemMemoryPoolQuinary;                 // 第五级系统内存池
void* SystemDataTableQuinary;                  // 第五级系统数据表
void* SystemMemoryPoolSenary;                  // 第六级系统内存池
void* SystemDataTableSenary;                   // 第六级系统数据表

// 核心系统函数指针和相关数据
void* GameCoreSystemEntryPoint;                 // 游戏核心系统入口点
void* CoreSystemMemoryAllocator;                // 核心系统内存分配器
void* CoreSystemDataTable;                     // 核心系统数据表
void* CoreSystemMemoryBuffer;                  // 核心系统内存缓冲区
void* CoreSystemConfigMain;                    // 核心系统主配置
void* CoreSystemConfigSecondary;                // 核心系统次级配置
void* CoreSystemConfigTertiary;                 // 核心系统第三级配置
void* CoreSystemConfigQuaternary;               // 核心系统第四级配置

// 渲染系统初始化函数
void* GameRenderingEntryPoint;                  // 游戏渲染系统入口点
void* RenderingSystemContext;                   // 渲染系统上下文

// 网络系统初始化函数
void* GameNetworkEntryPoint;                    // 游戏网络系统入口点
void* NetworkSystemContext;                     // 网络系统上下文

// 音频系统初始化函数
void* GameAudioEntryPoint;                      // 游戏音频系统入口点
void* AudioSystemContext;                       // 音频系统上下文

// 输入系统初始化函数和相关数据
void* GameInputEntryPoint;                      // 游戏输入系统入口点
void* InputSystemDataBuffer;
void* InputSystemEventQueue;
void* InputSystemStateData;
void* InputSystemDeviceManager;
void* InputSystemKeyMapping;
void* InputSystemAxisMapping;
void* InputSystemActionBindings;
void* InputSystemConfiguration;
void* GameSubsystemEntryPoint;
void* SubsystemContext;
void* InputSystemDataTable;
uint8_t InputSystemFlags;
void* InputSystemConfigMain;
void* InputSystemDeviceConfig;
void* InputSystemMappingConfig;
void* InputSystemProfileConfig;

// 物理系统初始化函数
void* GamePhysicsEntryPoint;
void* PhysicsSystemContext;

// 文件系统初始化函数
void* GameFileSystemEntryPoint;

// 函数: 系统初始化函数A - 字符串处理系统初始化
void* GameStringProcessingInitializer;
void* StringProcessingDataBuffer;
void* StringProcessingStructurePrimary;
void* StringProcessingStructureSecondary;
void* StringProcessingStructureTertiary;
void* StringProcessingStructureQuaternary;
void* StringProcessingGuardCheckFunction;

// 函数: 系统初始化函数B - 内存管理系统初始化
void* GameMemoryManagementInitializer;

// 函数: 系统初始化函数C - 系统资源管理器初始化
void* GameResourceManagementInitializer;
void* ResourceMemoryRegionPrimary;
void* ResourceMemoryRegionSecondary;
void* ResourceMemoryRegionTertiary;
void* ResourceMemoryRegionQuaternary;
void* ResourceMemoryRegionQuinary;
void* ResourceMemoryRegionSenary;
void* ResourceMemoryRegionSeptenary;
void* ResourceMemoryRegionOctonary;
void* ResourceMemoryRegionNonary;
void* ResourceMemoryRegionDecary;
void* ResourceMemoryRegionUndenary;
void* ResourceMemoryRegionDuodenary;
void* ResourceFunctionPointerPrimary;
void* ResourceFunctionPointerSecondary;
void* ResourceMemoryRegionTridecary;
void* ResourceMemoryRegionQuattuordecary;
void* ResourceMemoryRegionQuindecary;
void* ResourceMemoryRegionSexdecary;
void* ResourceSystemGlobalConstant;
void* ResourceDataBufferSecondary;
void* ResourceDataTableSecondary;
void* ResourceMemoryRegionSeptendecary;
void* ResourceDataTableTertiary;
void* ResourceMemoryRegionOctodecary;
void* ResourceDataTableQuaternary;
void* ResourceEntryPointPrimary;
void* ResourceMemoryRegionNovemdecary;
void* ResourceMemoryRegionVigintary;
void* ResourceMemoryRegionUnvigintary;
void* ResourceMemoryRegionDuovigintary;
int ResourceSystemStatusFlag;
long long ResourceSystemTimestamp;
void* ResourceMemoryRegionTrevigintary;

// 函数: 系统初始化函数D - 数据表管理器初始化
void* GameDataTableManagerInitializer;
void* SystemMemoryRegionQuattuorvigintary;
void* SystemMemoryRegionQuinvigintary;
void* SystemDataTableQuinary;                  // 第五级系统数据表
void* SystemMemoryRegionSexvigintary;
void* SystemMemoryRegionSeptenvigintary;
void* SystemMemoryRegionOctovigintary;
void* SystemMemoryRegionNovemvigintary;
void* SystemMemoryRegionTrigintary;
void* SystemMemoryRegionUntrigintary;
void* SystemDataTableSenary;                   // 第六级系统数据表
void* SystemMemoryRegionDuotrigintary;
void* SystemMemoryRegionTrestrigintary;
void* SystemMemoryRegionQuattuortrigintary;
void* SystemMemoryRegionQuintrigintary;
void* SystemMemoryRegionSextrigintary;
void* SystemMemoryRegionSeptentrigintary;
void* SystemMemoryRegionOctotrigintary;
void* SystemDataTableSeptenary;
void* SystemMemoryRegionNovemtrigintary;
void* SystemMemoryRegionQuadragintary;
void* SystemMemoryRegionUnquadragintary;
void* SystemMemoryRegionDuooquadragintary;
void* SystemMemoryRegionTresquadragintary;
void* SystemMemoryRegionQuattuorquadragintary;
void* SystemMemoryRegionQuinquadragintary;
void* SystemMemoryRegionSexquadragintary;
void* SystemDataPointerPrimary;
void* SystemDataPointerSecondary;
void* SystemDataPointerTertiary;
void* SystemDataPointerQuaternary;
void* SystemDataPointerQuinary;
void* SystemDataPointerSenary;
void* SystemDataTableEntryPrimary;
void* SystemDataTableEntrySecondary;
char SystemStatusFlagPrimary;
char SystemStatusFlagSecondary;
char SystemStatusFlagTertiary;
char SystemStatusFlagQuaternary;
void* SystemMemoryBlockPrimary;
void* SystemMemoryBlockSecondary;
void* SystemMemoryBlockTertiary;
void* SystemMemoryBlockQuaternary;
void* SystemMemoryBlockQuinary;
void* SystemDataTableEntryTertiary;
void* SystemMemoryBlockSenary;
void* SystemMemoryBlockSeptenary;
void* SystemMemoryBlockOctonary;
void* SystemMemoryBlockNonary;
void* SystemMemoryBlockDecary;
void* SystemMemoryBlockUndenary;
void* SystemMemoryBlockDuodenary;
void* SystemMemoryBlockTridecary;
void* SystemMemoryBlockQuattuordecary;
void* SystemMemoryBlockQuindecary;
void* SystemMemoryBlockSexdecary;
void* SystemFunctionPointerTertiary;
void* SystemFunctionPointerQuaternary;
void* SystemMemoryBlockSeptendecary;
void* SystemMemoryBlockOctodecary;
void* SystemMemoryBlockNovemdecary;
void* SystemDataTableEntryQuaternary;
void* SystemDataTableEntryQuinary;
void* SystemMemoryBlockVigintary;
void* SystemMemoryBlockUnvigintary;
long long SystemTimeValuePrimary;
void* SystemDataTableEntrySenary;
void* SystemMemoryBlockDuovigintary;
void* SystemMemoryBlockTrevigintary;
unsigned long long SystemMemorySizePrimary;
unsigned long long SystemMemorySizeSecondary;
unsigned long long SystemMemorySizeTertiary;
uint8_t SystemByteValuePrimary;
uint8_t SystemByteValueSecondary;
uint8_t SystemByteValueTertiary;
long long SystemTimeValueSecondary;
bool SystemFlagPrimary;
void* SystemMemoryBlockQuattuorvigintary;
void* SystemMemoryBlockQuinvigintary;
void* SystemMemoryBlockSexvigintary;
void* SystemMemoryBlockSeptenvigintary;
char SystemStatusFlagQuinary;
void* SystemFunctionPointerQuinary;
void* SystemMemoryBlockOctovigintary;
void* SystemMemoryBlockNovemvigintary;
void* SystemMemoryBlockTrigintary;
bool SystemFlagSecondary;
void* SystemMemoryBlockUntrigintary;
void* SystemMemoryBlockDuotrigintary;
void* SystemMemoryBlockTrestrigintary;
void* SystemMemoryBlockQuattuortrigintary;
char SystemStatusFlagSenary;
void* SystemMemoryBlockQuintrigintary;
void* SystemMemoryBlockSextrigintary;
void* SystemMemoryBlockSeptentrigintary;
void* SystemMemoryBlockOctotrigintary;
void* SystemMemoryBlockNovemtrigintary;
void* SystemMemoryBlockQuadragintary;
void* SystemMemoryBlockUnquadragintary;
char SystemStatusFlagSeptenary;
void* SystemDataTableEntryOctonary;
void* SystemMemoryBlockDuooquadragintary;
void* SystemDataTableEntryNonary;
void* SystemMemoryBlockTresquadragintary;
void* SystemMemoryBlockQuattuorquadragintary;
void* SystemMemoryBlockQuinquadragintary;
void* SystemMemoryBlockSexquadragintary;
void* SystemMemoryBlockSeptenquadragintary;
void* SystemMemoryBlockOctoquadragintary;
void* SystemMemoryBlockNovemquadragintary;
void* SystemMemoryBlockQuinquagintary;
void* SystemMemoryBlockUnquinquagintary;
void* SystemMemoryBlockDuoquinquagintary;
void* SystemMemoryBlockTresquinquagintary;
void* SystemMemoryBlockQuattuorquinquagintary;
void* SystemMemoryBlockQuinquinquagintary;
void* SystemMemoryBlockSexquinquagintary;
void* SystemMemoryBlockSeptenquinquagintary;
void* SystemMemoryBlockOctoquinquagintary;
void* SystemMemoryBlockNovemquinquagintary;
void* SystemFunctionPointerSenary;

// 函数: 系统初始化入口点A
/**
 * @brief 系统初始化入口点A
 * 
 * 该函数是系统初始化的主要入口点之一，负责初始化系统的核心组件
 * 和数据结构，为后续的系统启动做准备
 */
void* SystemInitializationEntryPointAlpha;
void* SystemMemoryRegionCentumUnus;
void* SystemMemoryRegionCentumDuo;
void* SystemMemoryRegionCentumTres;
void* SystemDataTableEntryDecary;
void* SystemMemoryRegionCentumQuattuor;
void* SystemMemoryRegionCentumQuinque;
void* SystemDataTableEntryUndenary;

// 函数: 系统初始化入口点B
/**
 * @brief 系统初始化入口点B
 * 
 * 该函数是系统初始化的另一个入口点，负责处理特定的系统组件
 * 初始化任务，与入口点A协同工作
 */
void* SystemInitializationEntryPointBeta;
void* SystemMemoryRegionCentumSex;

// 函数: 系统初始化入口点C
/**
 * @brief 系统初始化入口点C
 * 
 * 该函数负责系统初始化过程中的特定任务，通常与内存管理
 * 或资源分配相关
 */
void* SystemInitializationEntryPointGamma;

// 函数: 系统初始化入口点D
/**
 * @brief 系统初始化入口点D
 * 
 * 该函数负责系统初始化过程中的设备检测和配置
 */
void* SystemInitializationEntryPointDelta;

// 函数: 系统初始化入口点E
/**
 * @brief 系统初始化入口点E
 * 
 * 该函数负责系统初始化过程中的网络组件配置
 */
void* SystemInitializationEntryPointEpsilon;
void* SystemMemoryRegionCentumSeptem;
void* SystemMemoryRegionCentumOcto;
void* SystemMemoryRegionCentumNovem;
void* SystemMemoryRegionDucenti;
void* SystemMemoryRegionDucentiUnus;
void* SystemMemoryRegionDucentiDuo;

// 函数: 系统初始化入口点F
/**
 * @brief 系统初始化入口点F
 * 
 * 该函数负责系统初始化过程中的音频组件配置
 */
void* SystemInitializationEntryPointZeta;
void* SystemMemoryRegionDucentiTres;
void* SystemMemoryRegionDucentiQuattuor;
void* SystemMemoryRegionDucentiQuinque;
void* SystemMemoryRegionDucentiSex;
char SystemStatusFlagOctonary;
void* SystemMemoryRegionDucentiSeptem;
void* SystemMemoryRegionDucentiOcto;
void* SystemDataTableEntryDuodecary;
void* SystemMemoryRegionDucentiNovem;
void* SystemMemoryRegionTrecenti;
void* SystemMemoryRegionTrecentiUnus;
// 系统全局数据常量块
// 系统配置和状态数据块
undefined SystemGlobalDataConfigBlock1;
undefined SystemGlobalDataConfigBlock2;
undefined SystemGlobalDataConfigBlock3;
undefined SystemGlobalDataConfigBlock4;
undefined SystemGlobalDataConfigBlock5;
undefined SystemMemoryConfigDataTable1;
undefined SystemMemoryConfigDataTable2;
undefined SystemMemoryConfigDataTable3;
undefined SystemMemoryConfigDataTable4;
undefined SystemInitializationStatusBlock1;
undefined SystemInitializationStatusBlock2;
undefined SystemInitializationStatusBlock3;
undefined SystemInitializationStatusBlock4;
undefined SystemPerformanceMetricsBlock1;
undefined SystemPerformanceMetricsBlock2;
undefined SystemPerformanceMetricsBlock3;
uint32_t SystemGlobalConfigurationFlag;
void* SystemMemoryAllocatorState;
uint32_t SystemMemoryPoolSize;
uint32_t SystemMemoryPoolAlignment;
uint32_t SystemMemoryPoolAttributes;
void* SystemMemoryPoolConfiguration;
void* SystemInitializationProgressStatus;

// 系统内存分配器 - 负责动态内存分配和管理

// 系统数据比较模板和节点指针
void* SystemDataComparisonTemplateA;  // DAT_18098c8f0
void* SystemDataComparisonTemplateB;  // DAT_18098c8c8
void* SystemDataComparisonTemplateC;  // DAT_1809fe0d0
void* SystemDataComparisonTemplateD;  // DAT_1809ff9e8
void* SystemDataComparisonTemplateG;  // DAT_1809ff9c0
void* SystemDataComparisonTemplateH;  // DAT_180a010a0
void* SystemDataComparisonTemplateI;  // DAT_180a01078
void* SystemDataComparisonTemplateE;  // DAT_180a00e28
void* SystemDataComparisonTemplateF;  // DAT_180a00d48
void* SystemDataNodeA;                // UNK_180a00430
void* SystemDataNodeB;                // UNK_1809fd0d8
void* SystemDataNodeC;                // UNK_1809ff978
void* SystemDataNodeD;                // UNK_1809ff990
void* SystemDataNodeE;                // UNK_180a00370
void* SystemDataNodeF;                // UNK_180a00388
void* SystemDataNodeG;                // UNK_180a003a0
void* SystemDataNodeH;                // UNK_180a003b8
void* SystemDataComparisonTemplateJ;  // DAT_180a01050
void* SystemDataComparisonTemplateK;  // DAT_180a01028
void* SystemDataComparisonTemplateL;  // DAT_180a01000
void* SystemDataNodeI;                // UNK_180a003d0
void* SystemDataNodeJ;                // UNK_1800868c0
void* SystemDataNodeK;                // UNK_180a003e8
void* SystemDataNodeL;                // UNK_180a00400
void* SystemDataComparisonTemplateM;  // DAT_180a00fd8
void* SystemDataComparisonTemplateN;  // DAT_180a00fb0
void* SystemDataNodeM;                // UNK_180a00460
void* SystemDataNodeN;                // UNK_180a004a8
void* SystemDataNodeO;                // UNK_180a004c0
void* SystemDataComparisonTemplateO;  // DAT_180a00bb0
void* SystemConfigDataPointerG;        // SystemConfigDataPointerG
void* SystemConfigDataPointerH;        // DAT_180bf6768
void* SystemNodeLinkPointerA;        // UNK_18098c880
void* SystemNodeLinkPointerB;        // UNK_18098c898
void* SystemRootNodePointer;         // UNK_18098c870

// 系统初始化状态变量
uint32_t SystemInitializationStatusA;  // SystemInitializationStatusA
uint32_t SystemInitializationStatusB;  // SystemInitializationStatusB
uint32_t SystemInitializationStatusC;  // SystemInitializationStatusC
uint32_t SystemInitializationStatusD;  // SystemInitializationStatusD
uint32_t SystemInitializationStatusE;  // SystemInitializationStatusE
uint32_t SystemInitializationStatusF;  // SystemInitializationStatusF

// 系统回调函数指针
void* SystemEventCallbackPointer;     // SystemEventNotificationHandler
void* SystemInitializationCallbackA;  // SystemInitializationHandlerA
void* SystemInitializationCallbackB;  // SystemInitializationHandlerB
void* SystemDebugCallback;            // SystemDebugMessageHandler
void* SystemEventCallback;            // SystemEventProcessor
void* SystemNetworkCallback;          // SystemNetworkEventHandler
void* SystemGlobalDataProcessor;      // SystemGlobalDataManager

// 系统全局数据指针
void* SystemGlobalDataPointerA;        // SystemGlobalDataReference
void* SystemGlobalDataPointerB;        // SystemGlobalDataSecondary
void* SystemGlobalDataPointerC;        // SystemGlobalDataTertiary

// 系统配置数据指针
void* SystemConfigDataPointerA;        // SystemConfigDataPointerA
void* SystemConfigDataPointerB;        // SystemConfigDataPointerB
void* SystemConfigDataPointerC;        // SystemConfigDataPointerC
void* SystemConfigDataPointerD;        // SystemConfigDataPointerD
void* SystemConfigDataPointerE;        // SystemConfigDataSecondary
void* SystemConfigDataPointerF;        // SystemConfigDataTertiary
void* SystemSemaphoreHandle;            // SystemSemaphoreInstance
/**
 * @brief 系统内存分配器函数
 * 
 * 负责动态内存分配和管理，包括内存分配、释放和重新分配操作
 */
void* SystemMemoryAllocatorFunction;

// 函数: 系统数据初始化器 - 负责初始化系统核心数据结构
/**
 * @brief 系统数据初始化器函数
 * 
 * 负责初始化系统核心数据结构，设置系统运行所需的基本数据
 */
void* SystemDataInitializerFunction;
void* SystemDataBufferPrimary;
void* SystemDataBufferSecondary;
void* SystemDataBufferTertiary;
void* SystemDataBufferQuaternary;
void* SystemDataBufferQuinary;
void* SystemDataBufferSenary;
void* SystemDataTablePrimary;
void* SystemDataTableSecondary;                // 次级系统数据表
void* SystemDataStructurePrimary;
void* SystemDataStructureSecondary;
void* SystemMemoryRegionPrimary;
void* SystemMemoryRegionSecondary;
void* SystemMemoryRegionTertiary;
void* SystemMemoryRegionQuaternary;
void* SystemMemoryRegionQuinary;
void* SystemMemoryRegionSenary;
void* SystemConfigurationDataPrimary;
void* SystemConfigurationDataSecondary;
void* SystemConfigurationDataTertiary;
void* SystemConfigurationDataQuaternary;
void* SystemConfigurationDataQuinary;
void* SystemConfigurationDataSenary;
// 系统数据缓冲区
undefined SystemDataBufferPrimary001;
undefined SystemDataBufferPrimary002;
undefined SystemDataBufferPrimary003;
undefined SystemDataBufferPrimary004;
undefined SystemDataBufferPrimary005;
undefined SystemDataBufferPrimary006;
undefined SystemDataBufferPrimary007;
undefined SystemDataBufferPrimary008;
undefined SystemDataBufferPrimary009;

// 函数: 系统配置加载器 - 负责加载系统配置参数
// 系统配置管理器
undefined SystemConfigurationManager;
undefined SystemDataBufferConfiguration010;
undefined SystemDataBufferConfiguration011;
undefined SystemDataBufferConfiguration012;
undefined SystemDataBufferConfiguration013;
undefined SystemDataBufferConfiguration014;
undefined SystemDataBufferConfiguration015;
undefined SystemDataBufferConfiguration016;

// 系统核心功能组件
undefined SystemErrorHandler;
undefined SystemLogger;
undefined SystemPerformanceMonitor;
undefined SystemResourceCleaner;
// 系统数据缓冲区 - 核心功能组件使用
undefined SystemDataBufferCore017;
undefined SystemDataBufferCore018;
undefined SystemDataBufferCore019;
undefined SystemDataBufferCore020;
undefined SystemDataBufferCore021;
undefined SystemDataBufferCore022;
undefined SystemDataBufferCore023;
undefined SystemDataBufferCore024;
undefined SystemDataBufferCore025;
undefined SystemDataBufferCore026;
undefined SystemDataBufferCore027;
undefined SystemDataBufferCore028;
undefined SystemDataBufferCore029;
undefined SystemDataBufferCore030;
undefined SystemDataBufferCore031;
undefined SystemDataBufferCore032;
undefined SystemDataBufferCore033;
undefined SystemDataBufferCore034;
undefined SystemDataBufferCore035;
undefined SystemDataBufferCore036;
undefined SystemDataBufferCore037;
undefined SystemDataBufferCore038;

// 系统状态管理器
undefined SystemStateManager;
// 系统状态数据缓冲区
undefined SystemDataBufferState039;
undefined SystemDataBufferState040;
undefined SystemDataBufferState041;
undefined SystemDataBufferState042;
undefined SystemDataBufferState043;
undefined SystemDataBufferState044;
// 系统状态标志缓冲区
char SystemStateFlagBuffer045;
char SystemStateFlagBuffer046;
// 系统数据缓冲区 - 状态管理使用
undefined SystemDataBufferState047;
undefined SystemDataBufferState048;
undefined SystemDataBufferState049;
undefined SystemDataBufferState050;
undefined SystemDataBufferState051;
uint8_t SystemDataBufferSpecial052;
undefined SystemDataBufferState053;
undefined SystemDataBufferState054;
undefined SystemDataBufferState055;
undefined SystemDataBufferState056;
undefined SystemDataBufferState057;
undefined SystemDataBufferState058;
uint32_t SystemDataBufferExtended059;
uint32_t SystemDataBufferExtended060;
uint32_t SystemDataBufferExtended061;
undefined SystemDataBufferState062;
// 系统状态和数据缓冲区
char SystemStatusBuffer063;
undefined SystemDataBufferGeneral064;
undefined SystemDataBufferGeneral065;
undefined SystemDataBufferGeneral066;
undefined SystemDataBufferGeneral067;
undefined SystemDataBufferGeneral068;
undefined SystemDataBufferGeneral069;
undefined SystemDataBufferGeneral070;
undefined SystemDataBufferGeneral071;
undefined SystemDataBufferGeneral072;
undefined SystemDataBufferGeneral073;
// 系统通用数据缓冲区
char SystemGeneralFlagBuffer074;
undefined SystemDataBufferCommon075;
undefined SystemDataBufferCommon076;
undefined SystemDataBufferCommon077;
undefined SystemDataBufferCommon078;
undefined SystemDataBufferCommon079;
undefined SystemDataBufferCommon080;
undefined SystemDataBufferCommon081;
// 系统数据缓冲区 - 通用用途
char SystemCommonFlagBuffer082;
undefined SystemDataBufferStandard083;
undefined SystemDataBufferStandard084;
undefined SystemDataBufferStandard085;
undefined SystemDataBufferStandard086;
undefined SystemDataBufferStandard087;
undefined SystemDataBufferStandard088;
undefined SystemDataBufferStandard089;
undefined SystemDataBufferStandard090;
undefined SystemDataBufferStandard091;
undefined SystemDataBufferStandard092;
// 系统数据缓冲区 - 标准化命名
undefined SystemDataBufferStandard093;
undefined SystemDataBufferStandard094;
undefined SystemDataBufferStandard095;
undefined SystemDataBufferStandard096;
undefined SystemDataBufferStandard097;
undefined SystemDataBufferStandard098;
undefined SystemDataBufferStandard099;
undefined SystemDataBufferStandard100;
undefined SystemDataBufferStandard101;
undefined SystemDataBufferStandard102;
undefined SystemDataBufferStandard103;
undefined SystemDataBufferStandard104;
undefined SystemDataBufferStandard105;
undefined SystemDataBufferStandard106;
undefined SystemDataBufferStandard107;
undefined SystemDataBufferStandard108;
undefined SystemDataBufferStandard109;
undefined SystemDataBufferStandard110;
undefined SystemDataBufferStandard111;
undefined SystemDataBufferStandard112;
undefined SystemDataBufferStandard113;
undefined SystemDataBufferStandard114;
undefined SystemDataBufferStandard115;
undefined SystemDataBufferStandard116;
undefined SystemDataBufferStandard117;
undefined SystemDataBufferStandard118;
undefined SystemDataBufferStandard119;
undefined SystemDataBufferStandard120;
undefined SystemDataBufferStandard121;
undefined SystemDataBufferStandard122;
undefined SystemDataBufferStandard123;
undefined SystemDataBufferStandard124;
undefined SystemDataBufferStandard125;
undefined SystemDataBufferStandard126;
undefined SystemDataBufferStandard127;
undefined SystemDataBufferStandard128;
undefined SystemDataBufferStandard129;
undefined SystemDataBufferStandard130;
undefined SystemDataBufferStandard131;
undefined SystemDataBufferStandard132;
undefined SystemDataBufferStandard133;
undefined SystemDataBufferStandard134;
undefined SystemDataBufferStandard135;
undefined SystemDataBufferStandard136;
undefined SystemDataBufferStandard137;
undefined SystemDataBufferStandard138;
undefined SystemDataBufferStandard139;
undefined SystemDataBufferStandard140;
undefined SystemDataBufferStandard141;
undefined SystemDataBufferStandard142;
undefined SystemDataBufferStandard143;
undefined SystemDataBufferStandard144;
undefined SystemDataBufferStandard145;
undefined SystemDataBufferStandard146;
undefined SystemDataBufferStandard147;
undefined SystemDataBufferStandard148;
undefined SystemDataBufferStandard149;
undefined SystemDataBufferStandard150;
undefined SystemDataBufferStandard151;
undefined SystemDataBufferStandard152;
undefined SystemDataBufferStandard153;

// 系统初始化协调器
undefined SystemInitializationCoordinator;
// 系统初始化数据缓冲区
undefined SystemDataBufferInit154;
undefined SystemDataBufferInit155;
undefined SystemDataBufferInit156;
undefined SystemDataBufferInit157;
undefined SystemDataBufferInit158;
undefined SystemDataBufferInit159;
undefined SystemDataBufferInit160;
undefined SystemDataBufferInit161;
undefined SystemDataBufferInit162;
undefined SystemDataBufferInit163;
undefined SystemDataBufferInit164;
undefined SystemDataBufferInit165;
undefined SystemDataBufferInit166;
undefined SystemDataBufferInit167;
undefined SystemDataBufferInit168;
undefined SystemDataBufferInit169;
undefined SystemDataBufferInit170;
undefined SystemDataBufferInit171;
undefined SystemDataBufferInit172;
undefined SystemDataBufferInit173;
undefined SystemDataBufferInit174;
undefined SystemDataBufferInit175;
undefined SystemDataBufferInit176;
undefined SystemDataBufferInit177;
undefined SystemDataBufferInit178;
undefined SystemDataBufferInit179;
undefined SystemDataBufferInit180;
undefined SystemDataBufferInit181;
undefined SystemDataBufferInit182;
undefined SystemDataBufferInit183;
undefined SystemDataBufferInit184;
undefined SystemDataBufferInit185;
undefined SystemDataBufferInit186;
undefined SystemDataBufferInit187;
undefined SystemDataBufferInit188;
undefined SystemDataBufferInit189;
undefined SystemDataBufferInit190;
undefined SystemDataBufferInit191;
undefined SystemDataBufferInit192;
undefined SystemDataBufferInit193;
// 系统配置数据块
undefined SystemConfigurationDataBlock194;
undefined SystemConfigurationDataBlock195;
undefined SystemConfigurationDataBlock196;
undefined SystemConfigurationDataBlock197;
undefined SystemConfigurationDataBlock198;
undefined SystemConfigurationDataBlock199;
undefined SystemConfigurationDataBlock200;
undefined SystemConfigurationDataBlock201;
undefined SystemConfigurationDataBlock202;
undefined SystemConfigurationDataBlock203;
undefined SystemConfigurationDataBlock204;
undefined SystemConfigurationDataBlock205;
undefined SystemConfigurationDataTable;
undefined SystemMemoryAllocatorTable;
undefined SystemThreadControlTable;
undefined SystemProcessControlTable;
undefined SystemNetworkControlTable;
undefined SystemResourceControlTable;
undefined SystemSecurityControlTable;
undefined SystemFileSystemControlTable;
undefined SystemMemoryControlTable;
undefined SystemProcessSchedulerTable;
undefined SystemThreadSchedulerTable;
undefined SystemInterruptControlTable;
undefined SystemSecurityControlTable;
undefined SystemPerformanceControlTable;
undefined SystemDebugControlTable;
// 系统设备控制表
undefined SystemDeviceControlTable;
undefined SystemAudioControlTable;
undefined SystemVideoControlTable;
undefined SystemInputControlTable;
undefined SystemGraphicsControlTable;
undefined SystemDisplayControlTable;
undefined SystemSoundControlTable;
undefined SystemSensorControlTable;
undefined SystemControllerControlTable;
undefined SystemPowerControlTable;
// 系统状态和控制块
undefined SystemStatusControlBlock;
undefined SystemInitializationControlBlock;
undefined SystemShutdownControlBlock;

// 函数: 系统启动验证器 - 负责验证系统启动条件
undefined SystemStartupValidator;

// 函数: 获取系统根指针 - 获取系统根节点指针
undefined GetSystemRootPointer;

// 函数: 获取系统初始化函数 - 获取系统初始化相关函数
undefined GetSystemInitializationFunction;

/**
 * @brief 初始化游戏核心系统
 * 
 * 该函数负责初始化游戏的核心系统组件，包括系统根节点、数据表指针
 * 和内存分配器。它会设置系统的基础数据结构，为游戏运行做准备。
 * 
 * @note 此函数在系统启动时被调用，是初始化流程的关键部分
 */
/**
 * @brief 初始化游戏核心系统
 * 
 * 初始化游戏引擎的核心系统组件，包括内存管理、数据表和系统配置。
 * 设置系统根节点和数据结构，为游戏运行提供基础支持。
 * 
 * @note 该函数在游戏启动时被调用，是系统初始化流程的关键部分
 */
/**
 * @brief 初始化游戏核心系统
 * 
 * 该函数负责初始化游戏的核心系统组件，包括系统数据表的设置、
 * 节点管理和内存分配。它会遍历系统节点树，查找核心系统节点，
 * 如果找不到合适的节点，则分配新的内存空间并初始化核心系统数据。
 * 
 * @note 这是系统启动过程中的关键步骤，确保核心系统正确初始化
 */
/**
 * @brief 初始化游戏核心系统
 * 
 * 该函数负责初始化游戏的核心系统组件，包括系统数据表、内存分配、
 * 节点管理和事件回调设置。这是游戏引擎启动过程中的关键步骤。
 * 
 * @note 该函数会设置核心系统节点的标识符和数据结构
 */
/**
 * @brief 初始化游戏核心系统
 * 
 * 该函数负责初始化游戏的核心系统组件，包括系统节点管理、内存分配和
 * 数据表设置。它会遍历系统节点树，查找或创建游戏核心系统节点，
 * 并设置必要的系统标识符和回调函数。
 * 
 * @note 这是系统启动过程中的关键初始化步骤
 */
/**
 * @brief 初始化游戏核心系统
 * 
 * 该函数负责初始化游戏的核心系统组件，包括系统节点管理、内存分配、
 * 数据表设置等。它会遍历系统节点树，查找并初始化游戏核心系统。
 * 
 * @note 这是系统初始化的关键函数，在游戏启动时被调用
 * @note 函数会设置系统数据表指针并初始化核心系统节点
 */
void InitializeGameCoreSystem(void)
{
  bool isSystemNodeActive;
  void** systemRootNodePointer;
  int memoryCompareResult;
  long long* systemDataTablePointer;
  long long memoryAllocationSize;
  void** currentSystemNode;
  void** previousSystemNode;
  void** nextSystemNode;
  void** allocatedSystemNode;
  void* coreSystemInitFunction;
  
  systemDataTablePointer = (long long*)GetSystemRootPointer();
  systemRootNodePointer = (void**)*systemDataTablePointer;
  isSystemNodeActive = *(bool*)((long long)systemRootNodePointer[1] + 0x19);
  coreSystemInitFunction = GetGameCoreSystemInitializationFunction;
  previousSystemNode = systemRootNodePointer;
  currentSystemNode = (void**)systemRootNodePointer[1];
  
  while (!isSystemNodeActive) {
    memoryCompareResult = memcmp(currentSystemNode + 4, &GAME_CORE_SYSTEM_ID, 0x10);
    if (memoryCompareResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    isSystemNodeActive = *(bool*)((long long)nextSystemNode + 0x19);
  }
  
  if ((previousSystemNode == systemRootNodePointer) || 
      (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID, previousSystemNode + 4, 0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTablePointer);
    AllocateSystemMemory(systemDataTablePointer, &allocatedSystemNode, previousSystemNode, memoryAllocationSize + 0x20, memoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x4fc124d23d41985f;
  previousSystemNode[7] = 0xe2f4a30d6e6ae482;
  previousSystemNode[8] = &GAME_CORE_NODE_DATA;
  previousSystemNode[9] = 0;
  previousSystemNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表基础内存分配器
 * 
 * 该函数负责初始化系统的第一个数据表，专门用于管理基础的内存分配操作。
 * 它会设置数据表的基本结构，包括内存块标识符、分配器指针和状态标志。
 * 
 * @note 这是系统初始化过程中的关键步骤，为后续的内存管理奠定基础
 */
void InitializeSystemDataTableBaseAllocator(void)
{
  char isSystemNodeActive;
  void** systemRootNodePointer;
  int memoryCompareResult;
  long long* systemDataTablePointer;
  long long memoryAllocationSize;
  void** currentSystemNode;
  void** previousSystemNode;
  void** nextSystemNode;
  void** allocatedSystemNode;
  void** tempSystemNode;
  void* baseAllocatorFunctionPointer;
  
  systemDataTablePointer = (long long*)GetSystemRootPointer();
  systemRootNodePointer = (void**)*systemDataTablePointer;
  isSystemNodeActive = *(char*)((long long)systemRootNodePointer[1] + 0x19);
  baseAllocatorFunctionPointer = 0;
  previousSystemNode = systemRootNodePointer;
  currentSystemNode = (void**)systemRootNodePointer[1];
  
  while (isSystemNodeActive == '\0') {
    memoryCompareResult = memcmp(currentSystemNode + 4, &BASE_ALLOCATOR_ID, 0x10);
    if (memoryCompareResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    isSystemNodeActive = *(char*)((long long)nextSystemNode + 0x19);
  }
  
  if ((previousSystemNode == systemRootNodePointer) || 
      (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID, previousSystemNode + 4, 0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTablePointer);
    AllocateSystemMemory(systemDataTablePointer, &allocatedSystemNode, previousSystemNode, memoryAllocationSize + 0x20, memoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x4770584fbb1df897;
  previousSystemNode[7] = 0x47f249e43f66f2ab;
  previousSystemNode[8] = &BaseAllocatorNodeData;
  previousSystemNode[9] = 1;
  previousSystemNode[10] = baseAllocatorFunctionPointer;
  return;
}




/**
 * @brief 初始化系统数据表分配器
 * 
 * 该函数负责初始化系统数据表的内存分配器，
 * 设置内存分配策略和数据结构管理。
 */
void InitializeSystemDataTableAllocator(void)
{
  char isSystemNodeActive;
  void** systemDataTablePointer;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNodePointer;
  void** currentSystemNode;
  void** nextSystemNode;
  void** previousSystemNode;
  void** allocatedSystemNode;
  uint64_t systemInitializationFlag;
  long long memoryAllocationSize;
  
  systemDataTablePointer = (long long*)GetSystemRootPointer();
  systemRootNodePointer = (void**)*systemDataTablePointer;
  isSystemNodeActive = *(char*)((long long)systemRootNodePointer[1] + 0x19);
  systemInitializationFlag = 0;
  previousSystemNode = systemRootNodePointer;
  currentSystemNode = (void**)systemRootNodePointer[1];
  
  while (isSystemNodeActive == '\0') {
    memoryCompareResult = memcmp(currentSystemNode + 4, &SystemDataTableIdentifier, 0x10);
    if (memoryCompareResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    isSystemNodeActive = *(char*)((long long)nextSystemNode + 0x19);
  }
  
  if ((previousSystemNode == systemRootNodePointer) || 
      (memoryCompareResult = memcmp(&SystemDataTableIdentifier, previousSystemNode + 4, 0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTablePointer);
    AllocateSystemMemory(systemDataTablePointer, &allocatedSystemNode, previousSystemNode, memoryAllocationSize + 0x20, memoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x4666df49b97e0f10;
  previousSystemNode[7] = 0x4e4b0d63a6ad1d8f;
  previousSystemNode[8] = &SystemNodeIdentifier;
  previousSystemNode[9] = 0;
  previousSystemNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统核心配置
 * 
 * 该函数负责初始化系统核心配置参数，
 * 设置系统运行的基本配置和状态。
 */
void InitializeSystemCoreConfig(void)
{
  char isSystemNodeActive;
  void** systemDataTablePointer;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNodePointer;
  void** currentSystemNode;
  void** nextSystemNode;
  void** previousSystemNode;
  void** allocatedSystemNode;
  uint64_t systemInitializationFlag;
  long long memoryAllocationSize;
  
  systemDataTablePointer = (long long*)GetSystemRootPointer();
  systemRootNodePointer = (void**)*systemDataTablePointer;
  isSystemNodeActive = *(char*)((long long)systemRootNodePointer[1] + 0x19);
  systemInitializationFlag = 0;
  previousSystemNode = systemRootNodePointer;
  currentSystemNode = (void**)systemRootNodePointer[1];
  
  while (isSystemNodeActive == '\0') {
    memoryCompareResult = memcmp(currentSystemNode + 4, &SystemMemoryIdentifier, 0x10);
    if (memoryCompareResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    isSystemNodeActive = *(char*)((long long)nextSystemNode + 0x19);
  }
  
  if ((previousSystemNode == systemRootNodePointer) || 
      (memoryCompareResult = memcmp(&SystemMemoryIdentifier, previousSystemNode + 4, 0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTablePointer);
    AllocateSystemMemory(systemDataTablePointer, &allocatedSystemNode, previousSystemNode, memoryAllocationSize + 0x20, memoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x46ecbd4daf41613e;
  previousSystemNode[7] = 0xdc42c056bbde8482;
  previousSystemNode[8] = &SystemMemoryNodeId;
  previousSystemNode[9] = 0;
  previousSystemNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存池
 * 
 * 该函数负责初始化系统内存池，
 * 设置内存分配策略和管理机制。
 */
void InitializeSystemMemoryPool(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统线程池
 * 
 * 该函数负责初始化系统线程池，
 * 设置线程创建、同步和管理机制。
 */
void InitializeSystemThreadPool(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，
 * 设置事件创建、分发和处理机制。
 */
void InitializeSystemEventManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，
 * 设置资源加载、释放和管理机制。
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统核心数据结构
 * 设置系统启动所需的基本数据结构和初始化参数
 */
void initializeSystemCoreData(void)

{
  char statusFlag;
  void* *systemRootPointer;
  int comparisonResult;
  long long *systemHandle;
  long long memorySize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *newNode;
  code *initializationCallback;
  
  systemHandle = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemHandle;
  statusFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  initializationCallback = GetSystemInitializationCallback;
  previousNode = systemRootPointer;
  currentNode = (void* *)systemRootPointer[1];
  while (statusFlag == '\0') {
    comparisonResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (comparisonResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    statusFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == systemRootPointer) || (comparisonResult = memcmp(&SystemDataComparisonTemplateA,previousNode + 4,0x10), comparisonResult < 0)) {
    memorySize = GetSystemMemorySize(systemHandle);
    AllocateSystemMemory(systemHandle,&newNode,previousNode,memorySize + 0x20,memorySize);
    previousNode = newNode;
  }
  previousNode[6] = 0x421c3cedd07d816d;
  previousNode[7] = 0xbec25de793b7afa6;
  previousNode[8] = &SystemNodeLinkPointerA;
  previousNode[9] = 0;
  previousNode[10] = initializationCallback;
  return;
}




/**
 * 初始化系统数据表结构
 * 设置系统数据表和相关的内存结构
 */
void initializeSystemDataTable(void)

{
  char statusFlag;
  void* *systemRootPointer;
  int comparisonResult;
  long long *systemHandle;
  long long memorySize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *newNode;
  void* systemFlag;
  
  systemHandle = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemHandle;
  statusFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  systemFlag = 0;
  previousNode = systemRootPointer;
  currentNode = (void* *)systemRootPointer[1];
  while (statusFlag == '\0') {
    comparisonResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (comparisonResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    statusFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == systemRootPointer) || (comparisonResult = memcmp(&SystemDataComparisonTemplateB,previousNode + 4,0x10), comparisonResult < 0)) {
    memorySize = GetSystemMemorySize(systemHandle);
    AllocateSystemMemory(systemHandle,&newNode,previousNode,memorySize + 0x20,memorySize);
    previousNode = newNode;
  }
  previousNode[6] = 0x4c22bb0c326587ce;
  previousNode[7] = 0x5e3cf00ce2978287;
  previousNode[8] = &SystemNodeLinkPointerB;
  previousNode[9] = 1;
  previousNode[10] = systemFlag;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统全局变量
 * 
 * 该函数负责初始化系统的全局变量和配置参数
 * 设置各个系统模块的初始状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemGlobalVariables(void)

{
  long long initializationStatus;
  
  SystemInitializationStatusA = 0;
  SystemInitializationStatusB = 0;
  uRam0000000180bf5278 = 0;
  SystemInitializationStatusC = 3;
  SystemInitializationStatusD = 0;
  SystemInitializationStatusE = 0;
  uRam0000000180bf5298 = 0;
  SystemInitializationStatusF = 3;
  SystemConfigDataPointerA = &SystemGlobalDataPointerA;
  SystemConfigDataPointerB = 0;
  SystemConfigDataPointerC = 0;
  SystemConfigDataPointerD = 0;
  
  initializationStatus = 0;
  return initializationStatus;
}

/**
 * @brief 初始化核心引擎
 * 
 * 该函数负责初始化游戏引擎的核心系统
 * 设置基本的运行环境和管理结构
 */
void InitializeCoreEngine(void)

/**
 * @brief 初始化渲染系统配置
 * 
 * 设置渲染系统的基本配置参数和数据结构
 */
void InitializeRenderingSystemConfig(void)

{
  char systemNodeFlag;
  void* *systemRootPointer;
  int memoryCompareResult;
  long long *systemTablePointer;
  long long memoryAllocationSize;
  void** systemCurrentNode;
  void** systemPreviousNode;
  void** systemNextNode;
  void* *systemAllocatedNode;
  void* renderingInitializationFlag;
  
  systemTablePointer = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemTablePointer;
  systemNodeFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  renderingInitializationFlag = 0;
  systemPreviousNode = systemRootPointer;
  systemCurrentNode = (void* *)systemRootPointer[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootPointer) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateC,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemTablePointer);
    AllocateSystemMemory(systemTablePointer,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42bea5b911d9c4bf;
  systemPreviousNode[7] = 0x1aa83fc0020dc1b6;
  systemPreviousNode[8] = &SystemDataNodeB;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = renderingInitializationFlag;
  return;
}



/**
 * @brief 初始化音频系统资源池
 * 
 * 创建并配置音频系统的资源池，返回初始化状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeAudioSystemResourcePool(void)

{
  long long audioInitializationResult;
  
  RegisterSystemEventHandler(0x180c91700,0x20,8,GetSystemEventCallbackA,GetSystemEventCallbackB);
  audioInitializationResult = InitializeAudioSystem(&AudioSystemConfiguration);
  return (audioInitializationResult != 0) - 1;
}



/**
 * @brief 初始化输入系统资源池
 * 
 * 创建并配置输入系统的资源池，返回初始化状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeInputSystemResourcePool(void)

{
  long long inputInitializationResult;
  
  RegisterSystemEventHandler(0x180c91800,0x20,8,GetSystemEventCallbackC,GetSystemEventCallbackB);
  inputInitializationResult = InitializeInputSystem(&InputSystemConfiguration);
  return (inputInitializationResult != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统信号量
 * 
 * 创建系统级的信号量用于线程同步，返回初始化状态
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemSemaphore(void)

{
  long long semaphoreInitializationResult;
  
  SystemSemaphoreHandle = CreateSemaphoreW(0,1,0x7fffffff,0,0xfffffffffffffffe);
  semaphoreInitializationResult = InitializeSemaphoreSystem(GetSemaphoreSystemConfiguration);
  return (semaphoreInitializationResult != 0) - 1;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统内存管理器，设置内存分配策略
 * 和管理机制，确保系统内存资源的有效利用。
 */
void InitializeSystemMemoryManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateD,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x406be72011d07d37;
  systemPreviousNode[7] = 0x71876af946c867ab;
  systemPreviousNode[8] = &SystemDataNodeC;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存分配器
 * 
 * 该函数负责初始化系统内存分配器，设置内存分配策略
 * 和管理机制，为系统提供高效的内存分配服务。
 */
void InitializeSystemMemoryAllocator(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateG,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40afa5469b6ac06d;
  systemPreviousNode[7] = 0x2f4bab01d34055a5;
  systemPreviousNode[8] = &SystemDataNodeD;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}



/**
 * @brief 初始化系统线程同步机制
 * 
 * 该函数负责初始化系统的线程同步机制，包括互斥锁和信号量
 * 确保多线程环境下的数据安全和同步操作
 * 
 * @param threadPool 线程池指针
 * @param syncConfig 同步配置参数
 * @param mutexSize 互斥锁大小
 * @param semaphoreConfig 信号量配置
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemThreadSynchronization(void* threadPool, void* syncConfig, size_t mutexSize, void* semaphoreConfig)

{
  long long initializationResult;
  
  // 初始化互斥锁和信号量
  InitializeMutexInSitu(SystemMutexPool, 2, mutexSize, semaphoreConfig, MAX_THREAD_COUNT);
  initializationResult = InitializeThreadPool(SystemThreadPoolInstance);
  return (initializationResult != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统字符串处理模块
 * 
 * 该函数负责初始化系统字符串处理模块，设置字符串缓冲区
 * 和处理机制，为系统提供字符串操作支持。
 */
void InitializeSystemStringHandler(void)

{
  uint64_t systemStringParameter;
  void* stringProcessCallbackPointer;
  uint8_t* stringDataBufferPointer;
  uint32_t stringBufferSize;
  uint8_t stringDataBuffer [136];
  
  stringProcessCallbackPointer = &SystemStringProcessorNode;
  stringDataBufferPointer = stringDataBuffer;
  stringDataBuffer[0] = 0;
  stringBufferSize = 7;
  strcpy_s(stringDataBuffer,0x80,&SystemStringProcessorTemplate,systemStringParameter,0xfffffffffffffffe);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&stringProcessCallbackPointer);
  return;
}




/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统线程管理器，设置线程创建和管理机制，
 * 为系统提供多线程支持。
 */
void InitializeSystemThreadManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，设置事件处理机制和事件队列，
 * 为系统提供事件驱动支持。
 */
void InitializeSystemEventManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点结构
 * 设置系统配置的基本参数和数据结构
 */
void InitializeSystemConfigurationNode(void)

{
  char nodeFlag;
  void* *systemRootPointer;
  int comparisonResult;
  long long *systemTablePointer;
  long long allocationSize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *allocatedNode;
  void* initializationFlag;
  
  systemTablePointer = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemTablePointer;
  nodeFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  initializationFlag = 0;
  previousNode = systemRootPointer;
  currentNode = (void* *)systemRootPointer[1];
  while (nodeFlag == '\0') {
    comparisonResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (comparisonResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == systemRootPointer) || (comparisonResult = memcmp(&SystemDataComparisonTemplateJ,previousNode + 4,0x10), comparisonResult < 0)) {
    allocationSize = GetSystemMemorySize(systemTablePointer);
    AllocateSystemMemory(systemTablePointer,&allocatedNode,previousNode,allocationSize + 0x20,allocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x4b2d79e470ee4e2c;
  previousNode[7] = 0x9c552acd3ed5548d;
  previousNode[8] = &SystemDataNodeG;
  previousNode[9] = 0;
  previousNode[10] = initializationFlag;
  return;
}




// 函数: void InitializeSystemResourceNode(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点结构
 * 设置系统资源管理的基本参数和数据结构
 */
void InitializeSystemResourceNode(void)

{
  char nodeFlag;
  void* *systemRootPointer;
  int comparisonResult;
  long long *systemTablePointer;
  long long allocationSize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *allocatedNode;
  void* *initializationCallback;
  
  systemTablePointer = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemTablePointer;
  nodeFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  initializationCallback = GetSystemInitializationCallbackB;
  previousNode = systemRootPointer;
  currentNode = (void* *)systemRootPointer[1];
  while (nodeFlag == '\0') {
    comparisonResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (comparisonResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == systemRootPointer) || (comparisonResult = memcmp(&SystemDataComparisonTemplateK,previousNode + 4,0x10), comparisonResult < 0)) {
    allocationSize = GetSystemMemorySize(systemTablePointer);
    AllocateSystemMemory(systemTablePointer,&allocatedNode,previousNode,allocationSize + 0x20,allocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x49086ba08ab981a7;
  previousNode[7] = 0xa9191d34ad910696;
  previousNode[8] = &SystemDataNodeH;
  previousNode[9] = 0;
  previousNode[10] = initializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryNode(void)
/**
 * @brief 初始化系统内存节点
 * 
 * 该函数负责初始化系统的内存节点结构
 * 设置系统内存管理的基本参数和数据结构
 */
void InitializeSystemMemoryNode(void)

{
  char nodeFlag;
  void* *systemRootPointer;
  int comparisonResult;
  long long *systemTablePointer;
  long long allocationSize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *allocatedNode;
  void* initializationFlag;
  
  systemTablePointer = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemTablePointer;
  nodeFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  initializationFlag = 0;
  previousNode = systemRootPointer;
  currentNode = (void* *)systemRootPointer[1];
  while (nodeFlag == '\0') {
    comparisonResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (comparisonResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == systemRootPointer) || (comparisonResult = memcmp(&SystemDataComparisonTemplateL,previousNode + 4,0x10), comparisonResult < 0)) {
    allocationSize = GetSystemMemorySize(systemTablePointer);
    AllocateSystemMemory(systemTablePointer,&allocatedNode,previousNode,allocationSize + 0x20,allocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x402feffe4481676e;
  previousNode[7] = 0xd4c2151109de93a0;
  previousNode[8] = &SystemDataNodeI;
  previousNode[9] = 0;
  previousNode[10] = initializationFlag;
  return;
}




/**
 * @brief 初始化系统数据表结构A
 * 
 * 该函数负责初始化系统数据表结构A，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureA(void)

{
  char dataTypeFlag;
  void* *dataTablePointer;
  int memoryCompareResult;
  long long *systemRootPointer;
  long long allocationSize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *newNodePointer;
  undefined *systemDataReference;
  
  systemRootPointer = (long long *)GetSystemRootPointer();
  dataTablePointer = (void* *)*systemRootPointer;
  dataTypeFlag = *(char *)((long long)dataTablePointer[1] + 0x19);
  systemDataReference = &SystemDataNodeJ;
  previousNode = dataTablePointer;
  currentNode = (void* *)dataTablePointer[1];
  while (dataTypeFlag == '\0') {
    memoryCompareResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    dataTypeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == dataTablePointer) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,previousNode + 4,0x10), memoryCompareResult < 0)) {
    allocationSize = GetSystemMemorySize(systemRootPointer);
    AllocateSystemMemory(systemRootPointer,&newNodePointer,previousNode,allocationSize + 0x20,allocationSize);
    previousNode = newNodePointer;
  }
  previousNode[6] = 0x4384dcc4b6d3f417;
  previousNode[7] = 0x92a15d52fe2679bd;
  previousNode[8] = &SystemDataNodeK;
  previousNode[9] = 0;
  previousNode[10] = systemDataReference;
  return;
}




/**
 * @brief 初始化系统数据表结构B
 * 
 * 该函数负责初始化系统数据表结构B，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureB(void)

{
  char dataTypeFlag;
  void* *dataTablePointer;
  int memoryCompareResult;
  long long *systemRootPointer;
  long long allocationSize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *newNodePointer;
  void* initializationFlag;
  
  systemRootPointer = (long long *)GetSystemRootPointer();
  dataTablePointer = (void* *)*systemRootPointer;
  dataTypeFlag = *(char *)((long long)dataTablePointer[1] + 0x19);
  initializationFlag = 0;
  previousNode = dataTablePointer;
  currentNode = (void* *)dataTablePointer[1];
  while (dataTypeFlag == '\0') {
    memoryCompareResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    dataTypeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == dataTablePointer) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,previousNode + 4,0x10), memoryCompareResult < 0)) {
    allocationSize = GetSystemMemorySize(systemRootPointer);
    AllocateSystemMemory(systemRootPointer,&newNodePointer,previousNode,allocationSize + 0x20,allocationSize);
    previousNode = newNodePointer;
  }
  previousNode[6] = 0x4140994454d56503;
  previousNode[7] = 0x399eced9bb5517ad;
  previousNode[8] = &SystemDataNodeL;
  previousNode[9] = 0;
  previousNode[10] = initializationFlag;
  return;
}




/**
 * @brief 初始化系统数据表结构C
 * 
 * 该函数负责初始化系统数据表结构C，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureC(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateE,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x449bafe9b77ddd3c;
  systemPreviousNode[7] = 0xc160408bde99e59f;
  systemPreviousNode[8] = &SystemDataNodeA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构D
 * 
 * 该函数负责初始化系统数据表结构D，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureD(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构E
 * 
 * 该函数负责初始化系统数据表结构E，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureE(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateD,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x406be72011d07d37;
  systemPreviousNode[7] = 0x71876af946c867ab;
  systemPreviousNode[8] = &SystemDataNodeC;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构F
 * 
 * 该函数负责初始化系统数据表结构F，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureF(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateG,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40afa5469b6ac06d;
  systemPreviousNode[7] = 0x2f4bab01d34055a5;
  systemPreviousNode[8] = &SystemDataNodeD;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构G
 * 
 * 该函数负责初始化系统数据表结构G，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureG(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateC,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42bea5b911d9c4bf;
  systemPreviousNode[7] = 0x1aa83fc0020dc1b6;
  systemPreviousNode[8] = &SystemDataNodeB;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表结构H
 * 
 * 该函数负责初始化系统数据表结构H，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureH(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateO,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40db4257e97d3df8;
  systemPreviousNode[7] = 0x81d539e33614429f;
  systemPreviousNode[8] = &SystemDataNodeN;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构I
 * 
 * 该函数负责初始化系统数据表结构I，配置数据表的内存布局
 * 和访问模式，为系统提供高效的数据表访问支持。
 * 函数通过遍历和比较数据表项来设置特定的标识符和指针。
 */
void InitializeSystemDataTableStructureI(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemEventCallbackPointer;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemMemoryComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4e33c4803e67a08f;
  systemPreviousNode[7] = 0x703a29a844ce399;
  systemPreviousNode[8] = &SystemDataNodeO;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统字符串处理全局变量
 * 
 * 初始化游戏引擎字符串处理系统的全局变量和数据结构。
 * 该函数负责设置字符串处理系统的基础配置和引用。
 * 
 * @return 初始化状态，成功返回0，失败返回非零值
 */
int InitializeSystemStringProcessingGlobals(void)

{
  long long systemInitializationStatus;
  void* systemConfigurationValue;
  
  SystemStringProcessingPrimaryBuffer = &SystemStringProcessingReferenceTable;
  SystemStringProcessingSecondaryBuffer = &SystemStringProcessingConfigurationTable;
  
  return systemInitializationStatus;
}

/**
 * @brief 初始化系统字符串处理功能
 * 
 * 初始化游戏引擎的字符串处理子系统，设置字符串缓冲区和处理函数。
 * 该函数负责配置字符串操作的基础设施，为后续的文本处理提供支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是文本处理系统的基础
 */
void InitializeSystemStringProcessor(void)

{
  uint64_t systemStringParameter;
  void* stringProcessCallbackPointer;
  uint8_t* stringDataBufferPointer;
  uint32_t stringBufferSize;
  uint8_t stringDataBuffer [136];
  
  stringProcessCallbackPointer = &SystemStringProcessorNode;
  stringDataBufferPointer = stringDataBuffer;
  stringDataBuffer[0] = 0;
  stringBufferSize = 0xb;
  strcpy_s(stringDataBuffer,0x80,&SystemStringProcessorTemplate,systemStringParameter,0xfffffffffffffffe);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&stringProcessCallbackPointer);
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 初始化游戏引擎的内存管理子系统，设置内存分配策略和管理机制。
 * 该函数负责配置内存池、分配器和回收机制，为系统运行提供内存管理支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是内存管理系统的核心组件
 */
void InitializeSystemMemoryManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据结构
 * 
 * 初始化游戏引擎的数据结构子系统，设置数据表和管理节点。
 * 该函数负责配置数据结构的基础设施，为系统数据管理提供支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是数据管理系统的核心组件
 */
void InitializeSystemDataStructure(void)

{
  char nodeFlag;
  void* *systemRootPointer;
  int comparisonResult;
  long long *systemTablePointer;
  long long allocationSize;
  void* *currentNode;
  void* *previousNode;
  void* *nextNode;
  void* *allocatedNode;
  void* *initializationFunction;
  
  systemTablePointer = (long long *)GetSystemRootPointer();
  systemRootPointer = (void* *)*systemTablePointer;
  nodeFlag = *(char *)((long long)systemRootPointer[1] + 0x19);
  initializationFunction = (void* *)SystemInitializationCallbackA;
  previousNode = systemRootPointer;
  currentNode = (void* *)systemRootPointer[1];
  while (nodeFlag == '\0') {
    comparisonResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (comparisonResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == systemRootPointer) || (comparisonResult = memcmp(&SystemDataComparisonTemplateI,previousNode + 4,0x10), comparisonResult < 0)) {
    allocationSize = GetSystemMemorySize(systemTablePointer);
    AllocateSystemMemory(systemTablePointer,&allocatedNode,previousNode,allocationSize + 0x20,allocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x431d7c8d7c475be2;
  previousNode[7] = 0xb97f048d2153e1b0;
  previousNode[8] = &SystemDataNodeF;
  previousNode[9] = 4;
  previousNode[10] = initializationFunction;
  return;
}




// 函数: 初始化系统数据表
// 负责创建和配置系统的主数据表结构
void InitializeSystemDataTable(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化系统节点树
// 负责创建和管理系统的节点树结构
void InitializeSystemNodeTree(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: 初始化内存分配器
// 负责设置和管理系统的内存分配机制
void InitializeMemoryAllocator(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化资源池
// 负责创建和管理系统的资源池结构
void InitializeResourcePool(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* resourcePoolCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  resourcePoolCallbackPointer = &ResourcePoolCallbackNode;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: 初始化配置管理器
// 负责设置和管理系统的配置参数
void InitializeConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 初始化事件系统
// 负责设置和管理系统的事件处理机制
void InitializeEventSystem(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理器，设置内存分配策略
 * 和内存池管理结构，确保系统内存的有效利用
 */
void InitializeSystemMemoryManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统线程池管理器
 * 
 * 该函数负责初始化系统的线程池管理器，设置线程池的
 * 基本参数和线程管理策略，优化系统并发处理能力
 */
void InitializeSystemThreadPoolManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器，设置资源的分配、
 * 释放和监控机制，确保系统资源的合理使用
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统节点树结构
 * 
 * 初始化游戏引擎的系统节点树，构建节点之间的链接关系。
 * 该函数负责设置系统节点的内存分配和初始化节点数据结构。
 * 
 * @note 该函数在系统初始化阶段被调用，用于构建系统树形结构
 */
void InitializeSystemNodeTree(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表结构
 * 
 * 初始化游戏引擎的数据表结构，设置数据表的基本配置和内存分配。
 * 该函数负责创建数据表的基本框架，为后续的数据存储和访问做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立数据表的基础结构
 */
void InitializeSystemDataTable(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件处理器
 * 
 * 该函数负责初始化系统的事件处理器，设置事件的监听、
 * 分发和处理机制，确保系统事件的及时响应
 */
void InitializeSystemEventHandler(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理器，设置网络连接、
 * 数据传输和协议处理机制，确保系统网络功能的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统安全管理器
 * 
 * 该函数负责初始化系统的安全管理器，设置安全策略、
 * 权限控制和防护机制，确保系统的安全性
 */
void InitializeSystemSecurityManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控器，设置性能指标的
 * 收集、分析和报告机制，确保系统性能的实时监控
 */
void InitializeSystemPerformanceMonitor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理器，设置调试信息的
 * 收集、存储和分析机制，便于系统问题的诊断和解决
 */
void InitializeSystemDebugManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存分配器
 * 
 * 初始化游戏引擎的内存分配器，设置内存池和分配策略。
 * 该函数负责配置内存管理的基础设施，为系统运行提供内存支持。
 * 
 * @note 该函数在系统初始化阶段被调用，是内存管理的核心组件
 */
void InitializeSystemMemoryAllocator(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源池
 * 
 * 初始化游戏引擎的资源池，设置资源管理和分配的基础设施。
 * 该函数负责创建资源池的基本结构，为系统资源的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立资源管理的基础
 */
void InitializeSystemResourcePool(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 初始化游戏引擎的配置管理器，设置系统配置的基础设施。
 * 该函数负责创建配置管理的基本结构，为系统配置的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立配置管理的基础
 */
void InitializeSystemConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 初始化游戏引擎的资源管理器，设置系统资源的基础设施。
 * 该函数负责创建资源管理的基本结构，为系统资源的存储和管理做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立资源管理的基础
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* *resourceInitializationCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  resourceInitializationCallback = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 初始化游戏引擎的性能监控器，设置性能监控和统计的基础设施。
 * 该函数负责创建性能监控的基本结构，为系统性能的监控和统计做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立性能监控的基础
 */
void InitializeSystemPerformanceMonitor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateC,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42bea5b911d9c4bf;
  systemPreviousNode[7] = 0x1aa83fc0020dc1b6;
  systemPreviousNode[8] = &SystemDataNodeB;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 初始化游戏引擎的调试管理器，设置系统调试的基础设施。
 * 该函数负责创建调试管理的基本结构，为系统调试和日志记录做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立调试管理的基础
 */
void InitializeSystemDebugManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *debugInitializationCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  debugInitializationCallback = SystemDebugCallback;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件处理器
 * 
 * 初始化游戏引擎的事件处理器，设置事件处理的基础设施。
 * 该函数负责创建事件处理的基本结构，为系统事件的管理和分发做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立事件处理的基础
 */
void InitializeSystemEventHandler(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 初始化游戏引擎的网络管理器，设置网络通信的基础设施。
 * 该函数负责创建网络管理的基本结构，为系统网络通信做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立网络管理的基础
 */
void InitializeSystemNetworkManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统安全管理器
 * 
 * 初始化游戏引擎的安全管理器，设置系统安全的基础设施。
 * 该函数负责创建安全管理的基本结构，为系统安全验证和权限控制做准备。
 * 
 * @note 该函数在系统初始化阶段被调用，用于建立安全管理的基础
 */
void InitializeSystemSecurityManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表结构A
 * 
 * 该函数负责初始化系统数据表的基本结构，设置数据表的根节点和初始状态。
 * 它会在系统中创建一个新的数据表结构，用于存储系统运行时的数据。
 * 
 * @note 该函数在系统启动时被调用，是系统初始化过程的重要组成部分。
 */
void InitializeSystemDataTableStructureA(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器组件，设置资源分配的基础结构。
 * 它会创建资源管理节点，配置资源分配回调函数，并建立资源标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* systemCallbackData;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackData = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *systemAllocatedNode;
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能数据收集的基础结构。
 * 它会创建性能监控节点，配置性能数据回调函数，并建立性能监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemPerformanceCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemPerformanceCallback = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *systemAllocatedNode;
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemPerformanceCallback;
  return;
}




/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理组件，设置调试功能的基础结构。
 * 它会创建调试管理节点，配置调试回调函数，并建立调试功能标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试系统的正常运行
 */
void InitializeSystemDebugManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* systemDebugData;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemDebugData = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *systemAllocatedNode;
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理组件，设置字符串操作的基础结构。
 * 它会创建字符串处理缓冲区，配置字符串复制操作，并建立字符串处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessor(void)

{
  long long stringParameter;
  void* *callbackPointer;
  uint8_t *dataBufferPointer;
  int bufferSize;
  uint8_t dataBuffer [136];
  
  callbackPointer = &SystemStringProcessorNode;
  dataBufferPointer = dataBuffer;
  dataBuffer[0] = 0;
  bufferSize = 8;
  strcpy_s(dataBuffer,0x80,&SystemStringProcessorTemplate,stringParameter,0xfffffffffffffffe);
  SystemStringProcessorHandle = InitializeStringProcessorCallback(&callbackPointer);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统的数据管理组件，设置数据处理的基础结构。
 * 它会创建数据管理节点，配置数据操作回调函数，并建立数据管理标识符。
 * 
 * @return 初始化结果状态码
 * @note 这是系统初始化过程中的重要组成部分，确保数据管理系统的正常运行
 */
int InitializeSystemDataManager(void)

{
  long long systemDataOffset;
  void* systemParameter;
  
  SystemConfigDataPointerE = &SystemGlobalDataPointerB;
  SystemConfigDataPointerG = &SystemConfigDataPointerH;

// 函数: void InitializeSystemEventManager(void)
/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理组件，设置事件处理的基础结构。
 * 它会创建事件管理节点，配置事件处理回调函数，并建立事件管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char nodeFlag;
  void* *dataTable;
  int memoryCompareResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void* *currentNode;
  void* *nextNode;
  void* *previousNode;
  code *eventCallbackPointer;
  
  dataTable = (long long *)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  nodeFlag = *(char *)((long long)rootNode[1] + 0x19);
  eventCallbackPointer = SystemEventCallback;
  previousNode = rootNode;
  currentNode = (void* *)rootNode[1];
  while (nodeFlag == '\0') {
    memoryCompareResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (memoryCompareResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateD,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *systemAllocatedNode;
    memoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&systemAllocatedNode,previousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    previousNode = systemAllocatedNode;
  }
  previousNode[6] = 0x406be72011d07d37;
  previousNode[7] = 0x71876af946c867ab;
  previousNode[8] = &SystemDataNodeC;
  previousNode[9] = 0;
  previousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络通信的基础结构。
 * 它会创建网络管理节点，配置网络通信回调函数，并建立网络管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char nodeFlag;
  void* *dataTable;
  int memoryCompareResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void* *currentNode;
  void* *nextNode;
  void* *previousNode;
  code *networkCallbackPointer;
  
  dataTable = (long long *)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  nodeFlag = *(char *)((long long)rootNode[1] + 0x19);
  networkCallbackPointer = SystemNetworkCallback;
  previousNode = rootNode;
  currentNode = (void* *)rootNode[1];
  while (nodeFlag == '\0') {
    memoryCompareResult = memcmp(currentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (memoryCompareResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == rootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateG,previousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *allocatedNode;
    memoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&allocatedNode,previousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x40afa5469b6ac06d;
  previousNode[7] = 0x2f4bab01d34055a5;
  previousNode[8] = &SystemDataNodeD;
  previousNode[9] = 3;
  previousNode[10] = networkCallbackPointer;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理器节点，用于管理系统配置信息。
 * 它会在系统数据表中查找或创建配置管理器节点，并设置相关的配置参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理器正确建立
 */
void InitializeSystemConfigurationManager(void)

{
  char nodeFlag;
  void* *dataTable;
  int memoryCompareResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void* *currentNode;
  void* *nextNode;
  void* *previousNode;
  code *initializationFunction;
  
  dataTable = (long long *)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  nodeFlag = *(char *)((long long)rootNode[1] + 0x19);
  initializationFunction = GetSystemConfigurationManagerFunction;
  previousNode = rootNode;
  currentNode = (void* *)rootNode[1];
  while (nodeFlag == '\0') {
    memoryCompareResult = memcmp(currentNode + 4,&CONFIGURATION_MANAGER_ID,0x10);
    if (memoryCompareResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == rootNode) || (memoryCompareResult = memcmp(&CONFIGURATION_MANAGER_ID,previousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *allocatedNode;
    memoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&allocatedNode,previousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x406be72011d07d37;
  previousNode[7] = 0x71876af946c867ab;
  previousNode[8] = &ConfigurationManagerNodeData;
  previousNode[9] = 0;
  previousNode[10] = initializationFunction;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理器节点，用于管理系统资源分配和释放。
 * 它会在系统数据表中查找或创建资源管理器节点，并设置相关的资源管理参数。
 * 
 * @note 这是系统初始化过程中的关键组成部分，确保资源管理器正确建立
 */
void InitializeSystemResourceManager(void)

{
  char nodeFlag;
  void* *dataTable;
  int memoryCompareResult;
  long long *memoryPointer;
  long long timeValue;
  void* *rootNode;
  void* *currentNode;
  void* *nextNode;
  void* *previousNode;
  code *initializationFunction;
  
  dataTable = (long long *)GetSystemRootPointer();
  rootNode = (void* *)*dataTable;
  nodeFlag = *(char *)((long long)rootNode[1] + 0x19);
  initializationFunction = GetSystemResourceManagerFunction;
  previousNode = rootNode;
  currentNode = (void* *)rootNode[1];
  while (nodeFlag == '\0') {
    memoryCompareResult = memcmp(currentNode + 4,&RESOURCE_MANAGER_ID,0x10);
    if (memoryCompareResult < 0) {
      nextNode = (void* *)currentNode[2];
      currentNode = previousNode;
    }
    else {
      nextNode = (void* *)*currentNode;
    }
    previousNode = currentNode;
    currentNode = nextNode;
    nodeFlag = *(char *)((long long)nextNode + 0x19);
  }
  if ((previousNode == rootNode) || (memoryCompareResult = memcmp(&RESOURCE_MANAGER_ID,previousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize;
    void* *allocatedNode;
    memoryAllocationSize = GetSystemMemorySize(dataTable);
    AllocateSystemMemory(dataTable,&allocatedNode,previousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    previousNode = allocatedNode;
  }
  previousNode[6] = 0x40afa5469b6ac06d;
  previousNode[7] = 0x2f4bab01d34055a5;
  previousNode[8] = &ResourceManagerNodeData;
  previousNode[9] = 3;
  previousNode[10] = initializationFunction;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理器节点，用于管理系统事件的分发和处理。
 * 它会在系统数据表中查找或创建事件管理器节点，并设置相关的事件处理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理器正确建立
 */
void InitializeSystemEventManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemInitializationFunction;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = GetSystemEventManagerFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&EVENT_MANAGER_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&EVENT_MANAGER_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &EventManagerNodeData;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据管理器
 * 
 * 该函数负责初始化系统的数据管理器节点，用于管理系统数据的存储和检索。
 * 它会在系统数据表中查找或创建数据管理器节点，并设置相关的数据管理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据管理器正确建立
 */
void InitializeSystemDataManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemInitializationFunction;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = GetSystemDataManagerFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DATA_MANAGER_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DATA_MANAGER_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &DataManagerNodeData;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点，用于管理系统资源的分配和释放。
 * 它会在系统数据表中查找或创建资源节点，并设置相关的资源管理参数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源节点正确建立
 */
void InitializeSystemResourceNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* systemResourceFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemResourceFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&RESOURCE_NODE_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&RESOURCE_NODE_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &ResourceNodeData;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统节点管理器
 * 
 * 该函数负责初始化系统的节点管理组件，设置节点操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点管理系统的正常运行
 */
void InitializeSystemNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* nodeManagerCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  nodeManagerCallbackPointer = SystemNodeManagerCallback;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
/**
 * @brief 初始化系统数据节点管理器
 * 
 * 该函数负责初始化系统的数据节点管理组件，设置数据节点操作的基础结构。
 * 它会遍历系统数据节点树，进行内存比较，分配必要的内存，并设置数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据节点管理系统的正常运行
 */
void InitializeSystemDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统资源节点管理器
 * 
 * 该函数负责初始化系统的资源节点管理组件，设置资源节点操作的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源节点管理系统的正常运行
 */
void InitializeSystemResourceNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理组件，设置内存节点操作的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存节点管理系统的正常运行
 */
void InitializeSystemMemoryNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStorageManager(void)
/**
 * @brief 初始化系统字符串配置管理器
 * 
 * 该函数负责初始化系统的字符串配置管理组件，设置字符串配置操作的基础结构。
 * 它会创建字符串配置缓冲区，配置字符串复制操作，并建立字符串配置标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串配置管理系统的正常运行
 */
void InitializeSystemStringConfigurationManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0xb;
  strcpy_s(stackBuffer,0x80,&SystemConfigurationTemplateA,in_R9,0xfffffffffffffffe);
  SystemGlobalDataProcessorResult = SystemGlobalDataProcessor(&stackParameterA);
  return;
}




/**
 * @brief 初始化系统配置节点管理器
 * 
 * 该函数负责初始化系统的配置节点管理组件，设置配置节点操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置节点管理系统的正常运行
 */
void InitializeSystemConfigurationNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件节点管理器
 * 
 * 该函数负责初始化系统的事件节点管理组件，设置事件节点操作的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件节点管理系统的正常运行
 */
void InitializeSystemEventNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统资源管理器的节点结构，包括内存分配、
 * 节点链接和回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的资源节点。
 */
void InitializeSystemResourceNode(void)

{
  char systemNodeFlag;
  void *systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void *systemRootNode;
  void *systemCurrentNode;
  void *systemNextNode;
  void *systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (void *)GetSystemRootPointer();
  systemRootNode = (void *)*(long long *)systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp((void *)((long long)systemCurrentNode + 4),&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemCurrentNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,(void *)((long long)systemCurrentNode + 4),0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    void *systemAllocatedNode;
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemCurrentNode[6] = 0x4b2d79e470ee4e2c;
  systemCurrentNode[7] = 0x9c552acd3ed5548d;
  systemCurrentNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemCurrentNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统事件管理器的节点结构，包括内存分配、
 * 节点链接和事件回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的事件节点。
 */
void InitializeSystemEventNode(void)

{
  char systemNodeFlag;
  void *systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void *systemRootNode;
  void *systemCurrentNode;
  void *systemNextNode;
  void *systemPreviousNode;
  void *systemValidationCallback;
  
  systemDataTable = (void *)GetSystemRootPointer();
  systemRootNode = (void *)*(long long *)systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemValidationCallback = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp((void *)((long long)systemCurrentNode + 4),&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemCurrentNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,(void *)((long long)systemCurrentNode + 4),0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    void *systemAllocatedNode;
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemCurrentNode[6] = 0x49086ba08ab981a7;
  systemCurrentNode[7] = 0xa9191d34ad910696;
  systemCurrentNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存节点
 * 
 * 该函数负责初始化系统内存管理器的节点结构，包括内存分配、
 * 节点链接和内存管理回调函数设置。通过遍历系统节点树来找到合适的
 * 位置插入新的内存节点。
 */
void InitializeSystemMemoryNode(void)

{
  char systemNodeFlag;
  void *systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void *systemRootNode;
  void *systemCurrentNode;
  void *systemNextNode;
  void *systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (void *)GetSystemRootPointer();
  systemRootNode = (void *)*(long long *)systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp((void *)((long long)systemCurrentNode + 4),&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemCurrentNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,(void *)((long long)systemCurrentNode + 4),0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    void *systemAllocatedNode;
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemCurrentNode[6] = 0x402feffe4481676e;
  systemCurrentNode[7] = 0xd4c2151109de93a0;
  systemCurrentNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemCurrentNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeRenderingSystem(void)
/**
 * @brief 初始化渲染系统
 * 
 * 该函数负责初始化游戏渲染系统，设置渲染相关的系统节点和数据结构。
 * 通过遍历系统节点链表来配置渲染系统的初始化参数。
 */
void InitializeRenderingSystem(void)

{
  bool systemNodeIsActive;
  void** systemDataTable;
  int memoryComparisonResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* renderingInitializationCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统消息处理器
 * 
 * 该函数负责初始化系统的消息处理组件，设置消息操作的基础结构。
 * 它会创建消息处理缓冲区，配置消息回调函数，并建立消息处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保消息处理系统的正常运行
 */
void InitializeSystemMessageProcessor(void)

{
  void* systemContextParameter;
  void* *messageProcessorReference;
  uint8_t *messageConfigurationBuffer;
  uint32_t configurationBufferSize;
  uint8_t messageConfigurationBuffer [136];
  
  messageProcessorReference = &SystemMessageProcessorNode;
  messageConfigurationBuffer = messageConfigurationBuffer;
  messageConfigurationBuffer[0] = 0;
  configurationBufferSize = 10;
  strcpy_s(messageConfigurationBuffer,0x80,&SystemMessageProcessorTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemMessageProcessorHandle = InitializeMessageProcessorCallback(&messageProcessorReference);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统调试管理器
 * 
 * 该函数负责初始化系统的调试管理组件，设置调试操作的基础结构。
 * 它会创建调试管理节点，配置调试回调函数，并建立调试管理标识符。
 * 
 * @return 初始化结果状态码
 * @note 这是系统初始化过程中的重要组成部分，确保调试管理系统的正常运行
 */
int InitializeSystemDebugManager(void)

{
  long long lVar1;
  void* in_R9;
  
  SystemConfigDataPointerF = &SystemGlobalDataPointerB;
  _DAT_180bf7e98 = &DAT_180bf7ea8;

/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志操作的基础结构。
 * 它会创建日志处理缓冲区，配置日志回调函数，并建立日志处理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  void* systemContextParameter;
  void* *logManagerReference;
  uint8_t *logConfigurationBuffer;
  uint32_t configurationBufferSize;
  uint8_t logConfigurationBuffer [136];
  
  logManagerReference = &SystemLogManagerNode;
  logConfigurationBuffer = logConfigurationBuffer;
  logConfigurationBuffer[0] = 0;
  configurationBufferSize = 9;
  strcpy_s(logConfigurationBuffer,0x80,&SystemLogManagerTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemLogManagerHandle = InitializeLogManagerCallback(&logManagerReference);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控的基础结构。
 * 它会创建性能监控缓冲区，配置性能回调函数，并建立性能监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  void* systemContextParameter;
  void* *performanceMonitorReference;
  uint8_t *performanceConfigurationBuffer;
  uint32_t configurationBufferSize;
  uint8_t performanceConfigurationBuffer [136];
  
  performanceMonitorReference = &SystemPerformanceMonitorNode;
  performanceConfigurationBuffer = performanceConfigurationBuffer;
  performanceConfigurationBuffer[0] = 0;
  configurationBufferSize = 0xf;
  strcpy_s(performanceConfigurationBuffer,0x80,&SystemPerformanceMonitorTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemPerformanceMonitorHandle = InitializePerformanceMonitorCallback(&performanceMonitorReference);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统安全监控器
 * 
 * 该函数负责初始化系统的安全监控组件，设置安全监控的基础结构。
 * 它会创建安全监控缓冲区，配置安全回调函数，并建立安全监控标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保安全监控系统的正常运行
 */
void InitializeSystemSecurityMonitor(void)

{
  void* systemContextParameter;
  void* *securityMonitorReference;
  uint8_t *securityConfigurationBuffer;
  uint32_t configurationBufferSize;
  uint8_t securityConfigurationBuffer [136];
  
  securityMonitorReference = &SystemSecurityMonitorNode;
  securityConfigurationBuffer = securityConfigurationBuffer;
  securityConfigurationBuffer[0] = 0;
  configurationBufferSize = 0xc;
  strcpy_s(securityConfigurationBuffer,0x80,&SystemSecurityMonitorTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemSecurityMonitorHandle = InitializeSecurityMonitorCallback(&securityMonitorReference);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源管理的基础结构。
 * 它会创建资源管理缓冲区，配置资源回调函数，并建立资源管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  void* systemContextParameter;
  void* *resourceManagerReference;
  uint8_t *resourceConfigurationBuffer;
  uint32_t configurationBufferSize;
  uint8_t resourceConfigurationBuffer [136];
  
  resourceManagerReference = &SystemResourceManagerNode;
  resourceConfigurationBuffer = resourceConfigurationBuffer;
  resourceConfigurationBuffer[0] = 0;
  configurationBufferSize = 7;
  strcpy_s(resourceConfigurationBuffer,0x80,&SystemResourceManagerTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemResourceManagerHandle = InitializeResourceManagerCallback(&resourceManagerReference);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络管理的基础结构。
 * 它会创建网络管理缓冲区，配置网络回调函数，并建立网络管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  void* systemContextParameter;
  void* *networkManagerReference;
  uint8_t *networkConfigurationBuffer;
  uint32_t configurationBufferSize;
  uint8_t networkConfigurationBuffer [136];
  
  networkManagerReference = &SystemNetworkManagerNode;
  networkConfigurationBuffer = networkConfigurationBuffer;
  networkConfigurationBuffer[0] = 0;
  configurationBufferSize = 0x13;
  strcpy_s(networkConfigurationBuffer,0x80,&SystemNetworkManagerTemplate,systemContextParameter,0xfffffffffffffffe);
  SystemNetworkManagerHandle = InitializeNetworkManagerCallback(&networkManagerReference);
  return;
}




/**
 * @brief 初始化系统存储管理器
 * 
 * 该函数负责初始化系统的存储管理组件，设置存储管理的基础结构。
 * 它会遍历系统存储节点树，进行内存比较，分配必要的内存，并设置存储节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保存储管理系统的正常运行
 */
void InitializeSystemStorageManager(void)

{
  char systemNodeTraversalFlag;
  void* *systemDataTableReference;
  int memoryComparisonResult;
  long long *systemMemoryAllocationPointer;
  long long systemTimestamp;
  void* *systemRootStorageNode;
  void* *systemCurrentStorageNode;
  void* *systemNextStorageNode;
  void* *systemPreviousStorageNode;
  void* storageManagerCallbackFunction;
  
  systemDataTableReference = (long long *)GetSystemRootPointer();
  systemRootStorageNode = (void* *)*systemDataTableReference;
  systemNodeTraversalFlag = *(char *)((long long)systemRootStorageNode[1] + 0x19);
  storageManagerCallbackFunction = SystemStorageManagerCallback;
  systemPreviousStorageNode = systemRootStorageNode;
  systemCurrentStorageNode = (void* *)systemRootStorageNode[1];
  while (systemNodeTraversalFlag == '\0') {
    memoryComparisonResult = memcmp(systemCurrentStorageNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (memoryComparisonResult < 0) {
      systemNextStorageNode = (void* *)systemCurrentStorageNode[2];
      systemCurrentStorageNode = systemPreviousStorageNode;
    }
    else {
      systemNextStorageNode = (void* *)*systemCurrentStorageNode;
    }
    systemPreviousStorageNode = systemCurrentStorageNode;
    systemCurrentStorageNode = systemNextStorageNode;
    systemNodeTraversalFlag = *(char *)((long long)systemNextStorageNode + 0x19);
  }
  if ((systemCurrentStorageNode == systemRootStorageNode) || (memoryComparisonResult = memcmp(&SystemDataComparisonTemplateO,systemCurrentStorageNode + 4,0x10), memoryComparisonResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTableReference);
    void* *systemAllocatedStorageNode;
    AllocateSystemMemory(systemDataTableReference,&systemAllocatedStorageNode,systemPreviousStorageNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousStorageNode = systemAllocatedStorageNode;
  }
  systemCurrentStorageNode[6] = 0x40db4257e97d3df8;
  systemCurrentStorageNode[7] = 0x81d539e33614429f;
  systemCurrentStorageNode[8] = &SystemDataNodeN;
  systemCurrentStorageNode[9] = 4;
  systemPreviousStorageNode[10] = storageManagerCallbackFunction;
  return;
}




// 函数: void InitializeSystemMemoryManagerNode(void)
/**
 * @brief 初始化系统内存管理器节点
 * 
 * 该函数负责初始化系统的内存管理器节点，设置内存管理的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManagerNode(void)

{
  char systemNodeTraversalFlag;
  void* *systemDataTableReference;
  int memoryComparisonResult;
  long long *systemMemoryAllocationPointer;
  long long systemTimestamp;
  void* *systemRootMemoryNode;
  void* *systemCurrentMemoryNode;
  void* *systemNextMemoryNode;
  void* *systemPreviousMemoryNode;
  void* memoryManagerCallbackFunction;
  
  systemDataTableReference = (long long *)GetSystemRootPointer();
  systemRootMemoryNode = (void* *)*systemDataTableReference;
  systemNodeTraversalFlag = *(char *)((long long)systemRootMemoryNode[1] + 0x19);
  memoryManagerCallbackFunction = SystemMemoryManagerCallback;
  systemPreviousMemoryNode = systemRootMemoryNode;
  systemCurrentMemoryNode = (void* *)systemRootMemoryNode[1];
  while (systemNodeTraversalFlag == '\0') {
    memoryComparisonResult = memcmp(systemCurrentMemoryNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (memoryComparisonResult < 0) {
      systemNextMemoryNode = (void* *)systemCurrentMemoryNode[2];
      systemCurrentMemoryNode = systemPreviousMemoryNode;
    }
    else {
      systemNextMemoryNode = (void* *)*systemCurrentMemoryNode;
    }
    systemPreviousMemoryNode = systemCurrentMemoryNode;
    systemCurrentMemoryNode = systemNextMemoryNode;
    systemNodeTraversalFlag = *(char *)((long long)systemNextMemoryNode + 0x19);
  }
  if ((systemCurrentMemoryNode == systemRootMemoryNode) || (memoryComparisonResult = memcmp(&SystemMemoryComparisonTemplate,systemCurrentMemoryNode + 4,0x10), memoryComparisonResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTableReference);
    void* *systemAllocatedMemoryNode;
    AllocateSystemMemory(systemDataTableReference,&systemAllocatedMemoryNode,systemPreviousMemoryNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousMemoryNode = systemAllocatedMemoryNode;
  }
  systemCurrentMemoryNode[6] = 0x4e33c4803e67a08f;
  systemCurrentMemoryNode[7] = 0x703a29a844ce399;
  systemCurrentMemoryNode[8] = &SystemDataNodeO;
  systemCurrentMemoryNode[9] = 3;
  systemPreviousMemoryNode[10] = memoryManagerCallbackFunction;
  return;
}




// 函数: void InitializeSystemDataTableNode(void)
/**
 * @brief 初始化系统数据表节点
 * 
 * 该函数负责初始化系统的数据表节点，设置数据表操作的基础结构。
 * 它会遍历系统数据表节点树，进行内存比较，分配必要的内存，并设置数据表节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据表系统的正常运行
 */
void InitializeSystemDataTableNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点，设置配置操作的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置系统的正常运行
 */
void InitializeSystemConfigurationNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventNode(void)
/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统的事件节点，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件系统的正常运行
 */
void InitializeSystemEventNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNodeTreeProcessor(void)
/**
 * @brief 初始化系统节点树处理器
 * 
 * 该函数负责初始化系统的节点树处理组件，设置节点操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点树处理系统的正常运行
 */
void InitializeSystemNodeTreeProcessor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryPoolManager(void)
/**
 * @brief 初始化系统内存池管理器
 * 
 * 该函数负责初始化系统的内存池管理组件，设置内存池操作的基础结构。
 * 它会遍历系统内存池节点树，进行内存比较，分配必要的内存，并设置内存池属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存池管理系统的正常运行
 */
void InitializeSystemMemoryPoolManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemServiceManager(void)
/**
 * @brief 初始化系统服务管理器
 * 
 * 该函数负责初始化系统的服务管理组件，设置服务操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置服务节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保服务管理系统的正常运行
 */
void InitializeSystemServiceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventHandler(void)
/**
 * @brief 初始化系统事件处理器
 * 
 * 该函数负责初始化系统的事件处理组件，设置事件处理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置事件处理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件处理系统的正常运行
 */
void InitializeSystemEventHandler(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemTaskManager(void)
/**
 * @brief 初始化系统任务管理器
 * 
 * 该函数负责初始化系统的任务管理组件，设置任务操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置任务管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保任务管理系统的正常运行
 */
void InitializeSystemTaskManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDataProcessor(void)
/**
 * @brief 初始化系统数据处理器
 * 
 * 该函数负责初始化系统的数据处理组件，设置数据处理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置数据处理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据处理系统的正常运行
 */
void InitializeSystemDataProcessor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemCommunicationManager(void)
/**
 * @brief 初始化系统通信管理器
 * 
 * 该函数负责初始化系统的通信管理组件，设置通信操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置通信管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保通信管理系统的正常运行
 */
void InitializeSystemCommunicationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerEx(void)
/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理组件，设置内存操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置内存管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理组件，设置线程操作的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置线程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保线程管理系统的正常运行
 */
void InitializeSystemThreadManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统资源管理器，设置资源管理的基础数据结构。
 * 它会遍历系统节点树，查找资源管理器节点，并进行相应的初始化操作。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    void* *systemAllocatedNode;
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统浮点数计算器
 * 
 * 该函数负责初始化系统的浮点数计算组件，设置浮点运算的基础结构。
 * 它会计算浮点数的平方根值，进行数值归一化处理，并设置浮点计算表。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保浮点计算系统的正常运行
 */
void InitializeSystemFloatingPointCalculator(void)

{
  ulong long uVar1;
  float *pfVar2;
  int memoryCompareResult;
  ulong long uVar4;
  uint uVar5;
  ulong long uVar6;
  int iVar7;
  float *pfVar8;
  float fVar9;
  
  pfVar8 = (float *)0x180c8aa70;
  uVar6 = 0;
  iVar7 = -3;
  uVar4 = uVar6;
  do {
    if (0 < (long long)uVar4) {
      iVar3 = -3;
      uVar1 = uVar6;
      pfVar2 = pfVar8;
      do {
        fVar9 = 0.0;
        if (-1 < (long long)uVar1) {
          if ((long long)uVar1 < 3) {
            fVar9 = 0.75;
          }
          else {
            fVar9 = 1.0 - (float)iVar3 / (float)iVar7;
            fVar9 = SQRT(fVar9) * fVar9;
          }
        }
        *pfVar2 = fVar9;
        iVar3 = iVar3 + 1;
        pfVar2 = pfVar2 + 1;
        uVar1 = uVar1 + 1;
      } while ((long long)uVar1 < (long long)uVar4);
    }
    iVar7 = iVar7 + 1;
    uVar4 = uVar4 + 1;
    pfVar8 = pfVar8 + 0x40;
  } while ((long long)pfVar8 < 0x180c8ea71);
  pfVar8 = (float *)0x180c8eb70;
  do {
    uVar5 = (int)uVar6 + 1;
    *pfVar8 = 1.0 / SQRT((float)uVar6) + 1.0 / SQRT((float)uVar6);
    pfVar8 = pfVar8 + 1;
    uVar6 = (ulong long)uVar5;
  } while (uVar5 < 0x40);
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统事件管理器，设置事件处理的基础数据结构。
 * 它会遍历系统节点树，查找事件管理器节点，并进行相应的初始化操作。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *eventHandlerFunction;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  eventHandlerFunction = FUN_18025e330;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    long long memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    void* *systemAllocatedNode;
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSearchManager(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理组件，设置搜索功能的基础结构。
 * 它会遍历系统搜索节点树，进行内存比较，分配必要的内存，并设置搜索节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索管理系统的正常运行
 */
void InitializeSystemSearchManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateE,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x449bafe9b77ddd3c;
  systemPreviousNode[7] = 0xc160408bde99e59f;
  systemPreviousNode[8] = &SystemDataNodeA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemIndexManager(void)
/**
 * @brief 初始化系统索引管理器
 * 
 * 该函数负责初始化系统的索引管理组件，设置索引功能的基础结构。
 * 它会遍历系统索引节点树，进行内存比较，分配必要的内存，并设置索引节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保索引管理系统的正常运行
 */
void InitializeSystemIndexManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateD,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x406be72011d07d37;
  systemPreviousNode[7] = 0x71876af946c867ab;
  systemPreviousNode[8] = &SystemDataNodeC;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemCacheManager(void)
/**
 * @brief 初始化系统缓存管理器
 * 
 * 该函数负责初始化系统的缓存管理组件，设置缓存功能的基础结构。
 * 它会遍历系统缓存节点树，进行内存比较，分配必要的内存，并设置缓存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保缓存管理系统的正常运行
 */
void InitializeSystemCacheManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateG,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40afa5469b6ac06d;
  systemPreviousNode[7] = 0x2f4bab01d34055a5;
  systemPreviousNode[8] = &SystemDataNodeD;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLogManager(void)
/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志功能的基础结构。
 * 它会遍历系统日志节点树，进行内存比较，分配必要的内存，并设置日志节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemPerformanceMonitor(void)
/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控的基础结构。
 * 它会遍历系统性能监控节点树，进行内存比较，分配必要的内存，并设置性能监控节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保性能监控系统的正常运行
 */
void InitializeSystemPerformanceMonitor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源管理的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventDispatcher(void)
/**
 * @brief 初始化系统事件分发器
 * 
 * 该函数负责初始化系统的事件分发组件，设置事件分发的基础结构。
 * 它会遍历系统事件分发节点树，进行内存比较，分配必要的内存，并设置事件分发节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件分发系统的正常运行
 */
void InitializeSystemEventDispatcher(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSecurityManager(void)
/**
 * @brief 初始化系统安全管理器
 * 
 * 该函数负责初始化系统的安全管理组件，设置安全管理的基础结构。
 * 它会遍历系统安全节点树，进行内存比较，分配必要的内存，并设置安全管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保安全管理系统的正常运行
 */
void InitializeSystemSecurityManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置管理的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemNetworkManager(void)
/**
 * @brief 初始化系统网络管理器
 * 
 * 该函数负责初始化系统的网络管理组件，设置网络管理的基础结构。
 * 它会遍历系统网络节点树，进行内存比较，分配必要的内存，并设置网络管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络管理系统的正常运行
 */
void InitializeSystemNetworkManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStorageManager(void)
/**
 * @brief 初始化系统存储管理器
 * 
 * 该函数负责初始化系统的存储管理组件，设置存储管理的基础结构。
 * 它会遍历系统存储节点树，进行内存比较，分配必要的内存，并设置存储管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保存储管理系统的正常运行
 */
void InitializeSystemStorageManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateO,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40db4257e97d3df8;
  systemPreviousNode[7] = 0x81d539e33614429f;
  systemPreviousNode[8] = &SystemDataNodeN;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统进程管理器
 * 
 * 该函数负责初始化系统的进程管理组件，设置进程管理的基础结构。
 * 它会遍历系统进程节点树，进行内存比较，分配必要的内存，并设置进程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保进程管理系统的正常运行
 */
void InitializeSystemProcessManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemEventCallbackPointer;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemMemoryComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4e33c4803e67a08f;
  systemPreviousNode[7] = 0x703a29a844ce399;
  systemPreviousNode[8] = &SystemDataNodeO;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统线程管理器
 * 
 * 该函数负责初始化系统的线程管理组件，设置线程管理的基础结构。
 * 它会遍历系统线程节点树，进行内存比较，分配必要的内存，并设置线程管理节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保线程管理系统的正常运行
 */
void InitializeSystemThreadManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventProcessor(void)
// 系统事件处理器初始化函数
// 初始化系统事件处理相关的数据结构和回调函数
void InitializeSystemEventProcessor(void)

{
  char eventNodeFlag;
  void* *eventSystemDataTable;
  int memoryCompareResult;
  long long *eventMemoryPointer;
  long long eventSystemTimeValue;
  void* *eventRootNode;
  void* *eventCurrentNode;
  void* *eventNextNode;
  void* *eventPreviousNode;
  code *eventStackPointer;
  
  eventSystemDataTable = (long long *)GetSystemRootPointer();
  eventRootNode = (void* *)*eventSystemDataTable;
  eventNodeFlag = *(char *)((long long)eventRootNode[1] + 0x19);
  eventSearchFunctionPointer = GetSystemSearchFunctionD;
  eventPreviousNode = eventRootNode;
  eventCurrentNode = (void* *)eventRootNode[1];
  while (eventNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      eventNextNode = (void* *)eventCurrentNode[2];
      eventCurrentNode = eventPreviousNode;
    }
    else {
      eventNextNode = (void* *)*eventCurrentNode;
    }
    eventPreviousNode = eventCurrentNode;
    eventCurrentNode = eventNextNode;
    eventNodeFlag = *(char *)((long long)eventNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(eventSystemDataTable);
    AllocateSystemMemory(eventSystemDataTable,&eventAllocatedNode,eventPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    eventPreviousNode = eventAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  eventPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManager(void)
// 功能: 初始化系统资源管理器，负责管理系统资源的分配和释放
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManager(void)
// 功能: 初始化系统内存管理器，负责内存分配、释放和管理
void InitializeSystemMemoryManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLogManager(void)
// 功能: 初始化系统日志管理器，负责系统日志的记录和管理
void InitializeSystemLogManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemPerformanceMonitor(void)
// 功能: 初始化系统性能监视器，负责监控系统性能指标
void InitializeSystemPerformanceMonitor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemSecurityMonitor(void)
// 功能: 初始化系统安全监视器，负责系统安全监控和防护
void InitializeSystemSecurityMonitor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNetworkManager(void)
// 功能: 初始化系统网络管理器，负责网络连接和通信管理
void InitializeSystemNetworkManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateE,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x449bafe9b77ddd3c;
  systemPreviousNode[7] = 0xc160408bde99e59f;
  systemPreviousNode[8] = &SystemDataNodeA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStorageManager(void)
// 功能: 初始化系统存储管理器，负责数据存储和文件系统管理
void InitializeSystemStorageManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerNode(void)
// 功能: 初始化系统内存管理器节点，负责内存管理节点的初始化
void InitializeSystemMemoryManagerNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionG;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateO,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateO,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40db4257e97d3df8;
  systemPreviousNode[7] = 0x81d539e33614429f;
  systemPreviousNode[8] = &SystemDataNodeN;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemConfigurationManager(void)
// 功能: 初始化系统配置管理器，负责系统配置的加载和管理
void InitializeSystemConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemEventCallbackPointer;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemMemoryComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4e33c4803e67a08f;
  systemPreviousNode[7] = 0x703a29a844ce399;
  systemPreviousNode[8] = &SystemDataNodeO;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
// 功能: 初始化系统线程管理器，负责线程的创建、调度和管理
void InitializeSystemThreadManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateC,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42bea5b911d9c4bf;
  systemPreviousNode[7] = 0x1aa83fc0020dc1b6;
  systemPreviousNode[8] = &SystemDataNodeB;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
// 功能: 初始化系统进程管理器，负责进程的创建、调度和管理
void InitializeSystemProcessManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDeviceManager(void)
// 功能: 初始化系统设备管理器，负责硬件设备的检测和管理
void InitializeSystemDeviceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemServiceManager(void)
// 功能: 初始化系统服务管理器，负责系统服务的启动和管理
void InitializeSystemServiceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDriverManager(void)
// 功能: 初始化系统驱动管理器，负责设备驱动的加载和管理
void InitializeSystemDriverManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemModuleManager(void)
// 功能: 初始化系统模块管理器，负责系统模块的加载和管理
void InitializeSystemModuleManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemComponentManager(void)
// 功能: 初始化系统组件管理器，负责系统组件的注册和管理
void InitializeSystemComponentManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemPluginManager(void)
// 功能: 初始化系统插件管理器，负责系统插件的加载和管理
void InitializeSystemPluginManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置配置参数的基础结构。
 * 它会创建配置缓冲区，设置配置字符串，并建立配置管理标识符。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0xc;
  strcpy_s(stackBuffer,0x80,&SystemConfigurationTemplateB,in_R9,0xfffffffffffffffe);
  _DAT_180c91da4 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统模块加载器
 * 
 * 该函数负责初始化系统的模块加载器组件，设置系统模块加载的基础指针和配置。
 * 它会初始化系统模块相关的全局变量，为后续的模块加载做准备。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化过程中的重要组成部分，确保模块加载系统的正常运行
 */
int InitializeSystemModuleLoader(void)

{
  long long systemModuleStatus;
  void* systemModuleConfig;
  
  SystemModuleLoaderPrimary = &SystemModuleLoaderConfig;
  SystemModuleLoaderSecondary = &SystemModuleLoaderStatus;

// 函数: void InitializeSystemExtensionManager(void)
// 功能: 初始化系统扩展管理器，负责系统扩展的加载和管理
void InitializeSystemExtensionManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x16;
  strcpy_s(stackBuffer,0x80,&DAT_180a16c50,in_R9,0xfffffffffffffffe);
  _DAT_180c91da8 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemLibraryManager(void)
// 功能: 初始化系统库管理器，负责系统库的加载和管理
void InitializeSystemLibraryManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x16;
  strcpy_s(stackBuffer,0x80,&DAT_180a16c38,in_R9,0xfffffffffffffffe);
  _DAT_180c91dac = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemFrameworkManager(void)
// 功能: 初始化系统框架管理器，负责系统框架的初始化和管理
void InitializeSystemFrameworkManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统搜索管理器D
 * 
 * 该函数负责初始化系统的搜索管理器组件，设置搜索相关的
 * 数据结构和回调函数。
 */
void InitializeSystemSearchManagerD(void)
{
  char isSystemNodeActive;
  void** systemDataTablePointer;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNodePointer;
  void** currentSystemNode;
  void** nextSystemNode;
  void** previousSystemNode;
  void** allocatedSystemNode;
  void* systemSearchFunctionPointer;
  long long memoryAllocationSize;
  
  systemDataTablePointer = (long long*)GetSystemRootPointer();
  systemRootNodePointer = (void**)*systemDataTablePointer;
  isSystemNodeActive = *(char*)((long long)systemRootNodePointer[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  previousSystemNode = systemRootNodePointer;
  currentSystemNode = (void**)systemRootNodePointer[1];
  
  while (isSystemNodeActive == '\0') {
    memoryCompareResult = memcmp(currentSystemNode + 4, &SystemDataComparisonTemplateI, 0x10);
    if (memoryCompareResult < 0) {
      nextSystemNode = (void**)currentSystemNode[2];
      currentSystemNode = previousSystemNode;
    }
    else {
      nextSystemNode = (void**)*currentSystemNode;
    }
    previousSystemNode = currentSystemNode;
    currentSystemNode = nextSystemNode;
    isSystemNodeActive = *(char*)((long long)nextSystemNode + 0x19);
  }
  
  if ((previousSystemNode == systemRootNodePointer) || 
      (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI, previousSystemNode + 4, 0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTablePointer);
    AllocateSystemMemory(systemDataTablePointer, &allocatedSystemNode, previousSystemNode, memoryAllocationSize + 0x20, memoryAllocationSize);
    previousSystemNode = allocatedSystemNode;
  }
  
  previousSystemNode[6] = 0x431d7c8d7c475be2;
  previousSystemNode[7] = 0xb97f048d2153e1b0;
  previousSystemNode[8] = &SystemDataNodeF;
  previousSystemNode[9] = 4;
  previousSystemNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEntryPoint(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 初始化系统资源管理器中的资源节点，设置资源节点的配置和回调函数
 */
void InitializeSystemResourceNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统内存节点
 * 
 * 初始化系统内存管理器中的内存节点，设置内存节点的配置和回调函数
 */
void InitializeSystemMemoryNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemInitializationCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationCallback = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统数据表节点
 * 
 * 初始化系统数据表管理器中的数据表节点，设置数据表节点的配置和回调函数
 */
void InitializeSystemDataTableNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置节点
 * 
 * 初始化系统配置管理器中的配置节点，设置配置节点的配置数据和回调函数
 */
void InitializeSystemConfigurationNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  void* systemConfigurationData;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemConfigurationData = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemConfigurationData;
  return;
}




// 函数: void InitializeSystemEventNode(void)
void InitializeSystemEventNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadNode(void)
void InitializeSystemThreadNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateC,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42bea5b911d9c4bf;
  systemPreviousNode[7] = 0x1aa83fc0020dc1b6;
  systemPreviousNode[8] = &SystemDataNodeB;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemPerformanceNode(void)
void InitializeSystemPerformanceNode(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x1c;
  strcpy_s(stackBuffer,0x80,&UNK_180a17e48,in_R9,0xfffffffffffffffe);
  _DAT_180c91ee8 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemSecurityNode(void)
void InitializeSystemSecurityNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4fc124d23d41985f;
  systemPreviousNode[7] = 0xe2f4a30d6e6ae482;
  systemPreviousNode[8] = &GAME_CORE_NODE_DATA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemNetworkNode(void)
void InitializeSystemNetworkNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4770584fbb1df897;
  systemPreviousNode[7] = 0x47f249e43f66f2ab;
  systemPreviousNode[8] = &UNK_18098c7a0;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemAudioNode(void)
void InitializeSystemAudioNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c9b8,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c9b8,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4666df49b97e0f10;
  systemPreviousNode[7] = 0x4e4b0d63a6ad1d8f;
  systemPreviousNode[8] = &UNK_18098c7b8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemInputNode(void)
void InitializeSystemInputNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c940,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c940,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46ecbd4daf41613e;
  systemPreviousNode[7] = 0xdc42c056bbde8482;
  systemPreviousNode[8] = &UNK_18098c7c8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemPhysicsNode(void)
void InitializeSystemPhysicsNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemFileSystemNode(void)
void InitializeSystemFileSystemNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDatabaseNode(void)
void InitializeSystemDatabaseNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeStringProcessingSystem(void)
/**
 * @brief 初始化系统配置管理器
 * 
 * 该函数负责初始化系统的配置管理组件，设置系统配置节点的基础结构。
 * 它会遍历系统配置节点树，进行内存比较，分配必要的内存，并设置配置节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置管理系统的正常运行
 */
void InitializeSystemConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeMemoryManagementSystem(void)
/**
 * @brief 初始化系统事件配置管理器
 * 
 * 该函数负责初始化系统的事件配置管理组件，设置事件配置节点的基础结构。
 * 它会遍历系统事件配置节点树，进行内存比较，分配必要的内存，并设置事件配置节点属性。
 * 该函数还负责配置系统事件的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件配置管理系统的正常运行
 */
void InitializeSystemEventConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c8f0,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x421c3cedd07d816d;
  systemPreviousNode[7] = 0xbec25de793b7afa6;
  systemPreviousNode[8] = &UNK_18098c880;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeResourceManagementSystem(void)
/**
 * @brief 初始化系统网络配置管理器
 * 
 * 该函数负责初始化系统的网络配置管理组件，设置网络配置节点的基础结构。
 * 它会遍历系统网络配置节点树，进行内存比较，分配必要的内存，并设置网络配置节点属性。
 * 该函数还负责配置系统网络资源的初始化回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保网络配置管理系统的正常运行
 */
void InitializeSystemNetworkConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateB,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c22bb0c326587ce;
  systemPreviousNode[7] = 0x5e3cf00ce2978287;
  systemPreviousNode[8] = &UNK_18098c898;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeDataTableManager(void)
/**
 * @brief 初始化系统搜索配置管理器
 * 
 * 该函数负责初始化系统的搜索配置管理组件，设置搜索配置节点的基础结构。
 * 它会遍历系统搜索配置节点树，进行内存比较，分配必要的内存，并设置搜索配置节点属性。
 * 该函数还负责配置系统搜索功能的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索配置管理系统的正常运行
 */
void InitializeSystemSearchConfigurationManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemConfiguration(void)
/**
 * @brief 初始化系统调试信息管理器
 * 
 * 该函数负责初始化系统的调试信息管理组件，设置调试信息的基础结构。
 * 它会配置调试信息的字符串缓冲区，设置调试信息的处理函数，并建立调试信息的管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试信息管理系统的正常运行
 */
void InitializeSystemDebugInfoManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 9;
  strcpy_s(stackBuffer,0x80,&UNK_180a194f0,in_R9,0xfffffffffffffffe);
  _DAT_180c91ef8 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemMemoryAllocator(void)
/**
 * @brief 初始化系统日志管理器
 * 
 * 该函数负责初始化系统的日志管理组件，设置日志处理的基础结构。
 * 它会配置日志信息的字符串缓冲区，设置日志信息的处理函数，并建立日志信息的管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保日志管理系统的正常运行
 */
void InitializeSystemLogManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 8;
  strcpy_s(stackBuffer,0x80,&UNK_180a19588,in_R9,0xfffffffffffffffe);
  _DAT_180c91efc = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorA(void)
/**
 * @brief 初始化系统字符串处理器A
 * 
 * 该函数负责初始化系统的字符串处理组件A，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorA(void)

{
  void* systemRegisterR9;
  undefined *systemStringPointer;
  uint8_t *systemBufferPointer;
  uint32_t systemConfigValue;
  uint8_t systemStringBuffer [136];
  
  systemStringPointer = &SystemStringConstant;
  systemBufferPointer = systemStringBuffer;
  systemStringBuffer[0] = 0;
  systemConfigValue = 0xb;
  strcpy_s(systemStringBuffer,0x80,&SystemStringTemplate,systemRegisterR9,0xfffffffffffffffe);
  SystemStringProcessorA = SystemStringProcessingCallback(&systemStringPointer);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorB(void)
/**
 * @brief 初始化系统字符串处理器B
 * 
 * 该函数负责初始化系统的字符串处理组件B，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorB(void)

{
  void* systemRegisterR9;
  undefined *systemStringPointer;
  uint8_t *systemBufferPointer;
  uint32_t systemConfigValue;
  uint8_t systemStringBuffer [136];
  
  systemStringPointer = &SystemStringConstant;
  systemBufferPointer = systemStringBuffer;
  systemStringBuffer[0] = 0;
  systemConfigValue = 0xd;
  strcpy_s(systemStringBuffer,0x80,&SystemStringTemplateB,systemRegisterR9,0xfffffffffffffffe);
  SystemStringProcessorB = SystemStringProcessingCallback(&systemStringPointer);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorC(void)
/**
 * @brief 初始化系统字符串处理器C
 * 
 * 该函数负责初始化系统的字符串处理组件C，设置字符串处理的基础结构。
 * 它会配置字符串缓冲区，设置处理参数，并建立字符串处理的回调机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessorC(void)

{
  void* systemRegisterR9;
  undefined *systemStringPointer;
  uint8_t *systemBufferPointer;
  uint32_t systemConfigValue;
  uint8_t systemStringBuffer [136];
  
  systemStringPointer = &SystemStringConstant;
  systemBufferPointer = systemStringBuffer;
  systemStringBuffer[0] = 0;
  systemConfigValue = 0x1c;
  strcpy_s(systemStringBuffer,0x80,&SystemStringTemplateC,systemRegisterR9,0xfffffffffffffffe);
  SystemStringProcessorC = SystemStringProcessingCallback(&systemStringPointer);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorA(void)
void InitializeSystemStringProcessorA(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x15;
  strcpy_s(stackBuffer,0x80,&UNK_180a1a6c8,in_R9,0xfffffffffffffffe);
  _DAT_180c91f0c = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorB(void)
void InitializeSystemStringProcessorB(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0xe;
  strcpy_s(stackBuffer,0x80,&UNK_180a1afd8,in_R9,0xfffffffffffffffe);
  _DAT_180c91f10 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorC(void)
void InitializeSystemStringProcessorC(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x1a;
  strcpy_s(stackBuffer,0x80,&UNK_180a1cc28,in_R9,0xfffffffffffffffe);
  _DAT_180c91f14 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemStringProcessorD(void)
void InitializeSystemStringProcessorD(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x13;
  strcpy_s(stackBuffer,0x80,&UNK_180a1eb30,in_R9,0xfffffffffffffffe);
  _DAT_180c91f30 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemStringProcessorE(void)
void InitializeSystemStringProcessorE(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorF(void)
void InitializeSystemStringProcessorF(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorG(void)
void InitializeSystemStringProcessorG(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorH(void)
void InitializeSystemStringProcessorH(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorI(void)
void InitializeSystemStringProcessorI(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorJ(void)
void InitializeSystemStringProcessorJ(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorK(void)
void InitializeSystemStringProcessorK(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorL(void)
void InitializeSystemStringProcessorL(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorM(void)
void InitializeSystemStringProcessorM(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorN(void)
void InitializeSystemStringProcessorN(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorO(void)
void InitializeSystemStringProcessorO(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorP(void)
void InitializeSystemStringProcessorP(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorQ(void)
void InitializeSystemStringProcessorQ(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorR(void)
void InitializeSystemStringProcessorR(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorS(void)
void InitializeSystemStringProcessorS(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorT(void)
void InitializeSystemStringProcessorT(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorU(void)
void InitializeSystemStringProcessorU(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorV(void)
void InitializeSystemStringProcessorV(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorW(void)
void InitializeSystemStringProcessorW(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorX(void)
void InitializeSystemStringProcessorX(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessorY(void)
void InitializeSystemStringProcessorY(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemStringProcessorZ(void)
void InitializeSystemStringProcessorZ(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerA(void)
void InitializeSystemMemoryManagerA(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerB(void)
void InitializeSystemMemoryManagerB(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerC(void)
void InitializeSystemMemoryManagerC(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerD(void)
void InitializeSystemMemoryManagerD(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerE(void)
void InitializeSystemMemoryManagerE(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemMemoryManagerF(void)
void InitializeSystemMemoryManagerF(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 系统初始化函数 - 内存分配器设置
 * 
 * 该函数负责初始化系统内存分配器，设置内存池和数据结构
 * 用于管理游戏运行时的内存分配和释放
 */
void InitializeSystemMemoryAllocatorSetup(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4fc124d23d41985f;
  systemPreviousNode[7] = 0xe2f4a30d6e6ae482;
  systemPreviousNode[8] = &GAME_CORE_NODE_DATA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 系统初始化函数 - 数据表配置器
 * 
 * 该函数负责初始化系统数据表配置器，设置数据结构和索引
 * 用于管理游戏运行时的数据存储和检索
 */
void InitializeSystemDataTableConfigurator(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4770584fbb1df897;
  systemPreviousNode[7] = 0x47f249e43f66f2ab;
  systemPreviousNode[8] = &UNK_18098c7a0;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerG(void)
void InitializeSystemMemoryManagerG(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c9b8,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c9b8,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4666df49b97e0f10;
  systemPreviousNode[7] = 0x4e4b0d63a6ad1d8f;
  systemPreviousNode[8] = &UNK_18098c7b8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerH(void)
void InitializeSystemMemoryManagerH(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c940,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c940,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46ecbd4daf41613e;
  systemPreviousNode[7] = 0xdc42c056bbde8482;
  systemPreviousNode[8] = &UNK_18098c7c8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryManagerI(void)
void InitializeSystemMemoryManagerI(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadManager(void)
/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理组件，设置配置数据节点操作的基础结构。
 * 它会遍历系统配置数据节点树，进行内存比较，分配必要的内存，并设置配置数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保配置数据节点管理系统的正常运行
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemProcessManager(void)
/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理组件，设置事件数据节点操作的基础结构。
 * 它会遍历系统事件数据节点树，进行内存比较，分配必要的内存，并设置事件数据节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件数据节点管理系统的正常运行
 */
void InitializeSystemEventDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventSystem(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统资源节点，设置资源节点的相关配置和回调函数。
 * 它会遍历系统资源树，找到合适的位置插入新的资源节点，并设置节点的属性。
 * 
 * @note 这是一个系统资源管理的核心函数，确保资源节点的正确初始化
 */
void InitializeSystemResourceNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemTimerManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理组件，设置内存节点操作的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存节点管理系统的正常运行
 */
void InitializeSystemMemoryNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c8f0,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x421c3cedd07d816d;
  systemPreviousNode[7] = 0xbec25de793b7afa6;
  systemPreviousNode[8] = &UNK_18098c880;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void FUN_18003abb0(void)
/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理组件，设置设备节点操作的基础结构。
 * 它会遍历系统设备节点树，进行内存比较，分配必要的内存，并设置设备节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保设备节点管理系统的正常运行
 */
void InitializeSystemDeviceNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateB,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c22bb0c326587ce;
  systemPreviousNode[7] = 0x5e3cf00ce2978287;
  systemPreviousNode[8] = &UNK_18098c898;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理组件，设置字符串处理的相关配置。
 * 它会初始化字符串处理所需的数据结构和缓冲区。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保字符串处理系统的正常运行
 */
void InitializeSystemStringProcessor(void)

{
  void* systemRegisterR9;
  undefined *systemStackPointerA0;
  uint8_t *systemStackPointer98;
  uint32_t systemStackValue90;
  uint8_t systemStackBuffer88 [136];
  
  systemStackPointerA0 = &UNK_1809fcc28;
  systemStackPointer98 = systemStackBuffer88;
  systemStackBuffer88[0] = 0;
  systemStackValue90 = 0x16;
  strcpy_s(systemStackBuffer88,0x80,&UNK_180a22538,systemRegisterR9,0xfffffffffffffffe);
  _DAT_180c91f68 = SystemMemoryAllocationFunction(&systemStackPointerA0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统服务管理器
 * 
 * 该函数负责初始化系统的服务管理器组件，设置系统服务管理的基础指针和配置。
 * 它会初始化系统服务相关的全局变量，为后续的服务管理做准备。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化过程中的重要组成部分，确保服务管理系统的正常运行
 */
int InitializeSystemServiceManager(void)

{
  long long systemServiceStatus;
  void* systemServiceConfig;
  
  SystemServiceManagerPrimary = &SystemServiceManagerConfig;
  SystemServiceManagerSecondary = &SystemServiceManagerStatus;

/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理器，设置内存节点的相关配置和状态。
 * 它会初始化内存管理所需的数据结构和节点信息。
 * 
 * @note 这是系统内存管理的重要组成部分，确保内存节点的正确管理
 */
void InitializeSystemMemoryNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4fc124d23d41985f;
  systemPreviousNode[7] = 0xe2f4a30d6e6ae482;
  systemPreviousNode[8] = &GAME_CORE_NODE_DATA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理器，设置设备节点的相关配置和状态。
 * 它会初始化设备管理所需的数据结构和节点信息。
 * 
 * @note 这是系统设备管理的重要组成部分，确保设备节点的正确管理
 */
void InitializeSystemDeviceNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4770584fbb1df897;
  systemPreviousNode[7] = 0x47f249e43f66f2ab;
  systemPreviousNode[8] = &UNK_18098c7a0;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理器，设置配置节点的相关配置和状态。
 * 它会初始化配置管理所需的数据结构和节点信息。
 * 
 * @note 这是系统配置管理的重要组成部分，确保配置节点的正确管理
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c9b8,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c9b8,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4666df49b97e0f10;
  systemPreviousNode[7] = 0x4e4b0d63a6ad1d8f;
  systemPreviousNode[8] = &UNK_18098c7b8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理器，设置事件节点的相关配置和状态。
 * 它会初始化事件管理所需的数据结构和节点信息。
 * 
 * @note 这是系统事件管理的重要组成部分，确保事件节点的正确管理
 */
void InitializeSystemEventDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c940,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c940,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46ecbd4daf41613e;
  systemPreviousNode[7] = 0xdc42c056bbde8482;
  systemPreviousNode[8] = &UNK_18098c7c8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryAllocatorNode(void)
/**
 * @brief 初始化系统内存分配器节点
 * 
 * 该函数负责初始化系统的内存分配器节点，设置内存分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入内存分配器节点，
 * 并设置节点的标识符和回调函数。
 */
void InitializeSystemMemoryAllocatorNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemConfigurationNode(void)
/**
 * @brief 初始化系统配置节点
 * 
 * 该函数负责初始化系统的配置节点，设置系统配置的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入配置节点，
 * 并设置节点的标识符和配置数据。
 */
void InitializeSystemConfigurationNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventNode(void)
/**
 * @brief 初始化系统事件节点
 * 
 * 该函数负责初始化系统的事件节点，设置系统事件处理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入事件节点，
 * 并设置节点的标识符和事件数据。
 */
void InitializeSystemEventNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceNode(void)
/**
 * @brief 初始化系统资源节点
 * 
 * 该函数负责初始化系统的资源节点，设置系统资源管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源节点，
 * 并设置节点的标识符和资源数据。
 */
void InitializeSystemResourceNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDataNode(void)
/**
 * @brief 初始化系统数据节点
 * 
 * 该函数负责初始化系统的数据节点，设置系统数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据节点，
 * 并设置节点的标识符和数据指针。
 */
void InitializeSystemDataNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c8f0,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x421c3cedd07d816d;
  systemPreviousNode[7] = 0xbec25de793b7afa6;
  systemPreviousNode[8] = &UNK_18098c880;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringProcessor(void)
/**
 * @brief 初始化系统字符串处理器
 * 
 * 该函数负责初始化系统的字符串处理器，设置字符串处理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入字符串处理器节点，
 * 并设置节点的标识符和字符串处理回调函数。
 */
void InitializeSystemStringProcessor(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateB,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c22bb0c326587ce;
  systemPreviousNode[7] = 0x5e3cf00ce2978287;
  systemPreviousNode[8] = &UNK_18098c898;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemMemoryNodeManager(void)
/**
 * @brief 初始化系统内存节点管理器
 * 
 * 该函数负责初始化系统的内存节点管理器，设置内存节点管理的基础结构。
 * 它会创建内存节点的标识符，并设置相关的内存管理回调函数。
 */
void InitializeSystemMemoryNodeManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x12;
  strcpy_s(stackBuffer,0x80,&UNK_180a24340,in_R9,0xfffffffffffffffe);
  _DAT_180c91f6c = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemDeviceNodeManager(void)
/**
 * @brief 初始化系统设备节点管理器
 * 
 * 该函数负责初始化系统的设备节点管理器，设置设备节点管理的基础结构。
 * 它会创建设备节点的标识符，并设置相关的设备管理回调函数。
 */
void InitializeSystemDeviceNodeManager(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 8;
  strcpy_s(stackBuffer,0x80,&UNK_180a24828,in_R9,0xfffffffffffffffe);
  _DAT_180c91fcc = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}




// 函数: void InitializeSystemConfigurationDataNodeManager(void)
/**
 * @brief 初始化系统配置数据节点管理器
 * 
 * 该函数负责初始化系统的配置数据节点管理器，设置配置数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入配置数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemConfigurationDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventDataNodeManager(void)
/**
 * @brief 初始化系统事件数据节点管理器
 * 
 * 该函数负责初始化系统的事件数据节点管理器，设置事件数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入事件数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemEventDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceDataNodeManager(void)
/**
 * @brief 初始化系统资源数据节点管理器
 * 
 * 该函数负责初始化系统的资源数据节点管理器，设置资源数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemResourceDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemDataNodeManager(void)
/**
 * @brief 初始化系统数据节点管理器
 * 
 * 该函数负责初始化系统的数据节点管理器，设置数据节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemStringDataNodeManager(void)
/**
 * @brief 初始化系统字符串数据节点管理器
 * 
 * 该函数负责初始化系统的字符串数据节点管理器，设置字符串数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入字符串数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemStringDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemMemoryDataNodeManager(void)
/**
 * @brief 初始化系统内存数据节点管理器
 * 
 * 该函数负责初始化系统的内存数据节点管理器，设置内存数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入内存数据节点，
 * 并设置节点的标识符和内存管理回调函数。
 */
void InitializeSystemMemoryDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemDeviceDataNodeManager(void)
/**
 * @brief 初始化系统设备数据节点管理器
 * 
 * 该函数负责初始化系统的设备数据节点管理器，设置设备数据管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入设备数据节点，
 * 并设置节点的标识符和资源初始化回调函数。
 */
void InitializeSystemDeviceDataNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统全局数据表
 * 
 * 该函数负责初始化系统的全局数据表指针，设置系统数据访问的入口点。
 * 它会配置全局数据表的引用，确保其他系统组件可以正确访问系统数据。
 * 
 * @return 返回初始化状态码
 * @note 这是系统初始化的基础步骤，为后续的系统组件初始化提供数据访问支持
 */
int InitializeSystemGlobalDataTable(void)

{
  long long lVar1;
  void* in_R9;
  
  _DAT_180bfa350 = &UNK_1809fcc28;
  _DAT_180bfa358 = &DAT_180bfa368;

// 函数: void InitializeSystemSearchNodeManager(void)
/**
 * @brief 初始化系统搜索节点管理器
 * 
 * 该函数负责初始化系统的搜索节点管理器，设置搜索节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入搜索节点，
 * 并设置节点的标识符和事件回调函数。
 */
void InitializeSystemSearchNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemDebugNodeManager(void)
/**
 * @brief 初始化系统调试节点管理器
 * 
 * 该函数负责初始化系统的调试节点管理器，设置调试节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入调试节点，
 * 并设置节点的标识符和调试回调函数。
 */
void InitializeSystemDebugNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemLoggingNodeManager(void)
/**
 * @brief 初始化系统日志节点管理器
 * 
 * 该函数负责初始化系统的日志节点管理器，设置日志节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入日志节点，
 * 并设置节点的标识符和日志回调函数。
 */
void InitializeSystemLoggingNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemPerformanceNodeManager(void)
/**
 * @brief 初始化系统性能节点管理器
 * 
 * 该函数负责初始化系统的性能节点管理器，设置性能节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入性能节点，
 * 并设置节点的标识符和性能监控回调函数。
 */
void InitializeSystemPerformanceNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSecurityNodeManager(void)
/**
 * @brief 初始化系统安全节点管理器
 * 
 * 该函数负责初始化系统的安全节点管理器，设置安全节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入安全节点，
 * 并设置节点的标识符和安全检查回调函数。
 */
void InitializeSystemSecurityNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemNetworkNodeManager(void)
/**
 * @brief 初始化系统网络节点管理器
 * 
 * 该函数负责初始化系统的网络节点管理器，设置网络节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入网络节点，
 * 并设置节点的标识符和网络回调函数。
 */
void InitializeSystemNetworkNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemThreadNodeManager(void)
/**
 * @brief 初始化系统线程节点管理器
 * 
 * 该函数负责初始化系统的线程节点管理器，设置线程节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入线程节点，
 * 并设置节点的标识符和线程管理回调函数。
 */
void InitializeSystemThreadNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemProcessNodeManager(void)
/**
 * @brief 初始化系统进程节点管理器
 * 
 * 该函数负责初始化系统的进程节点管理器，设置进程节点管理的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入进程节点，
 * 并设置节点的标识符和进程管理回调函数。
 */
void InitializeSystemProcessNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void FUN_18003e610(void)
/**
 * @brief 初始化系统事件管理器G
 * 
 * 该函数负责初始化系统的第七个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerG(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void FUN_18003e710(void)
/**
 * @brief 初始化系统事件管理器H
 * 
 * 该函数负责初始化系统的第八个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerH(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void FUN_18003e810(void)
/**
 * @brief 初始化系统事件管理器I
 * 
 * 该函数负责初始化系统的第九个事件管理组件，设置事件处理的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件回调指针。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManagerI(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventManagerJ(void)
// 功能: 初始化系统事件管理器J，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置事件回调指针
void InitializeSystemEventManagerJ(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemEventManagerK(void)
// 功能: 初始化系统事件管理器K，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置资源初始化回调
void InitializeSystemEventManagerK(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemEventManagerL(void)
// 功能: 初始化系统事件管理器L，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置系统回调指针
void InitializeSystemEventManagerL(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemEventManagerM(void)
// 功能: 初始化系统事件管理器M，用于管理特定类型的事件处理
// 该函数会创建系统节点并设置相关系统配置
void InitializeSystemEventManagerM(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemEventManagerN(void)
// 功能: 初始化系统事件管理器N，用于管理特定类型的事件处理
// 该函数会设置系统字符串配置并初始化相关系统组件
void InitializeSystemEventManagerN(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x1b;
  strcpy_s(stackBuffer,0x80,&UNK_180a2ac10,in_R9,0xfffffffffffffffe);
  _DAT_180c9246c = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



int InitializeSystemModuleA(void)

{
  long long systemStatus;
  
  ExecuteSystemPreInitialization();
  systemStatus = FUN_1808fc7d0(FUN_180942890);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleB(void)

{
  long long systemStatus;
  uint8_t systemConfigBuffer [32];
  
  systemConfigBuffer[0] = 1;
  FUN_180477890(&DAT_180c92490,systemConfigBuffer);
  systemStatus = FUN_1808fc7d0(FUN_1809428e0);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleC(void)

{
  long long systemStatus;
  uint8_t systemConfigBuffer [32];
  
  systemConfigBuffer[0] = 0;
  FUN_180477890(&DAT_180c92480,systemConfigBuffer);
  systemStatus = FUN_1808fc7d0(FUN_180942930);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleD(void)

{
  long long systemStatus;
  
  systemStatus = FUN_1808fc7d0(FUN_180942a20);
  return (systemStatus != 0) - 1;
}



int InitializeSystemModuleE(void)

{
  long long systemStatus;
  
  FUN_1803f2eb0(0x180d49d50);
  systemStatus = FUN_1808fc7d0(FUN_1809429f0);
  return (systemStatus != 0) - 1;
}




// 函数: void InitializeSystemResourceManagerA(void)
// 功能: 初始化系统资源管理器A，用于管理游戏核心系统资源
// 该函数会创建系统节点并设置游戏核心系统ID和初始化函数
void InitializeSystemResourceManagerA(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4fc124d23d41985f;
  systemPreviousNode[7] = 0xe2f4a30d6e6ae482;
  systemPreviousNode[8] = &GAME_CORE_NODE_DATA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemResourceManagerB(void)
// 功能: 初始化系统资源管理器B，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的回调函数
void InitializeSystemResourceManagerB(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4770584fbb1df897;
  systemPreviousNode[7] = 0x47f249e43f66f2ab;
  systemPreviousNode[8] = &UNK_18098c7a0;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerC(void)
// 功能: 初始化系统资源管理器C，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的配置参数
void InitializeSystemResourceManagerC(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c9b8,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c9b8,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4666df49b97e0f10;
  systemPreviousNode[7] = 0x4e4b0d63a6ad1d8f;
  systemPreviousNode[8] = &UNK_18098c7b8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerD(void)
// 功能: 初始化系统资源管理器D，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的处理函数
void InitializeSystemResourceManagerD(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c940,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c940,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46ecbd4daf41613e;
  systemPreviousNode[7] = 0xdc42c056bbde8482;
  systemPreviousNode[8] = &UNK_18098c7c8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemResourceManagerE(void)
// 功能: 初始化系统资源管理器E，用于管理特定类型的系统资源
// 该函数会创建系统节点并设置资源管理相关的初始化参数
void InitializeSystemResourceManagerE(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统配置资源管理器
 * 设置系统配置标识符和相关数据结构
 */
void InitializeSystemResourceManagerF(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统事件资源管理器
 * 设置系统事件标识符和相关数据结构
 */
void InitializeSystemResourceManagerG(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统资源管理器
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerH(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统资源管理器I
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerI(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c8f0,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x421c3cedd07d816d;
  systemPreviousNode[7] = 0xbec25de793b7afa6;
  systemPreviousNode[8] = &UNK_18098c880;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * 初始化系统资源管理器J
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerJ(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateB,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c22bb0c326587ce;
  systemPreviousNode[7] = 0x5e3cf00ce2978287;
  systemPreviousNode[8] = &UNK_18098c898;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化系统资源管理器K
 * 设置系统资源标识符和相关数据结构
 */
void InitializeSystemResourceManagerK(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x10;
  strcpy_s(stackBuffer,0x80,&UNK_180a2bf10,in_R9,0xfffffffffffffffe);
  _DAT_180c924ac = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化系统资源管理器L
 * 处理系统资源字符串初始化
 */
void InitializeSystemResourceManagerL(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0xf;
  strcpy_s(stackBuffer,0x80,&DAT_180a2c1d0,in_R9,0xfffffffffffffffe);
  _DAT_180c924b0 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化系统资源管理器M
 * 处理系统资源字符串初始化
 */
void InitializeSystemResourceManagerM(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x19;
  strcpy_s(stackBuffer,0x80,&DAT_180a2c338,in_R9,0xfffffffffffffffe);
  _DAT_180c924b4 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化系统资源管理器N
 * 处理系统资源初始化
 */
void InitializeSystemResourceManagerN(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x14;
  strcpy_s(stackBuffer,0x80,&DAT_180a2c510,in_R9,0xfffffffffffffffe);
  _DAT_180c924b8 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int InitializeSystemModuleF(void)

{
  long long systemStatus;
  void* systemRegister;
  
  _DAT_180bf6048 = &UNK_18098bc80;
  _DAT_180bf6050 = &DAT_180bf6060;

/**
 * 初始化系统调试管理器A
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerA(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d660,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d660,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46c54bc98fc3fc2a;
  systemPreviousNode[7] = 0x727b256e3af32585;
  systemPreviousNode[8] = &UNK_180a2ca90;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统调试管理器B
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerB(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d590,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d590,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x41ffd0b76c1e136f;
  systemPreviousNode[7] = 0x25db30365f277abb;
  systemPreviousNode[8] = &UNK_180a2cab0;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * 初始化系统调试管理器C
 * 设置系统调试标识符和相关数据结构
 */
void InitializeSystemDebugManagerC(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4fc124d23d41985f;
  systemPreviousNode[7] = 0xe2f4a30d6e6ae482;
  systemPreviousNode[8] = &GAME_CORE_NODE_DATA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源分配器
 * 
 * 该函数负责初始化系统的资源分配器组件，设置资源分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入资源分配器节点，
 * 并设置节点的标识符和回调函数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源分配系统的正常运行
 */
void InitializeSystemResourceAllocator(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4770584fbb1df897;
  systemPreviousNode[7] = 0x47f249e43f66f2ab;
  systemPreviousNode[8] = &UNK_18098c7a0;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表分配器
 * 
 * 该函数负责初始化系统的数据表分配器组件，设置数据表分配的基础结构。
 * 它会遍历系统节点树，查找合适的位置插入数据表分配器节点，
 * 并设置节点的标识符和回调函数。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保数据表分配系统的正常运行
 */
void InitializeSystemDataTableAllocator(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c9b8,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c9b8,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4666df49b97e0f10;
  systemPreviousNode[7] = 0x4e4b0d63a6ad1d8f;
  systemPreviousNode[8] = &UNK_18098c7b8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemResourceComponent
// 初始化系统资源组件，负责管理系统资源的分配和释放
void InitializeSystemResourceComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c940,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c940,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46ecbd4daf41613e;
  systemPreviousNode[7] = 0xdc42c056bbde8482;
  systemPreviousNode[8] = &UNK_18098c7c8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemAllocatorComponent
// 初始化系统内存分配器组件，负责管理内存分配策略
void InitializeSystemAllocatorComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemConfigurationComponent
// 初始化系统配置组件，负责管理系统配置信息
void InitializeSystemConfigurationComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemCoreComponent
// 初始化系统核心组件，负责管理核心系统功能
void InitializeSystemCoreComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemMemoryComponent
// 初始化系统内存管理组件，负责内存池管理
void InitializeSystemMemoryComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemThreadComponent
// 初始化系统线程组件，负责线程管理和同步
void InitializeSystemThreadComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c8f0,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x421c3cedd07d816d;
  systemPreviousNode[7] = 0xbec25de793b7afa6;
  systemPreviousNode[8] = &UNK_18098c880;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemEventComponent
// 初始化系统事件组件，负责事件处理和分发
void InitializeSystemEventComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateB,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c22bb0c326587ce;
  systemPreviousNode[7] = 0x5e3cf00ce2978287;
  systemPreviousNode[8] = &UNK_18098c898;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemSecurityComponent
// 初始化系统安全组件，负责系统安全策略
void InitializeSystemSecurityComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d660,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d660,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46c54bc98fc3fc2a;
  systemPreviousNode[7] = 0x727b256e3af32585;
  systemPreviousNode[8] = &UNK_180a2ca90;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemNetworkComponent
// 初始化系统网络组件，负责网络通信
void InitializeSystemNetworkComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d590,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d590,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x41ffd0b76c1e136f;
  systemPreviousNode[7] = 0x25db30365f277abb;
  systemPreviousNode[8] = &UNK_180a2cab0;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: InitializeSystemDatabaseComponent
// 初始化系统数据库组件，负责数据存储
void InitializeSystemDatabaseComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionF;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateF,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateF,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45425dc186a5d575;
  systemPreviousNode[7] = 0xfab48faa65382fa5;
  systemPreviousNode[8] = &SystemDataNodeM;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemLoggingComponent
// 初始化系统日志组件，负责日志记录
void InitializeSystemLoggingComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionE;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateE,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateE,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x449bafe9b77ddd3c;
  systemPreviousNode[7] = 0xc160408bde99e59f;
  systemPreviousNode[8] = &SystemDataNodeA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemPerformanceComponent
// 初始化系统性能监控组件，负责性能分析
void InitializeSystemPerformanceComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateD,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x406be72011d07d37;
  systemPreviousNode[7] = 0x71876af946c867ab;
  systemPreviousNode[8] = &SystemDataNodeC;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemDiagnosticComponent
// 初始化系统诊断组件，负责系统诊断
void InitializeSystemDiagnosticComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateG,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40afa5469b6ac06d;
  systemPreviousNode[7] = 0x2f4bab01d34055a5;
  systemPreviousNode[8] = &SystemDataNodeD;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemDebugComponent
// 初始化系统调试组件，负责调试功能
void InitializeSystemDebugComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: InitializeSystemPluginComponent
// 初始化系统插件组件，负责插件管理
void InitializeSystemPluginComponent(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateI,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateI,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemDataNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentA(void)
// 功能: 初始化系统子组件A - 负责系统资源初始化回调的设置
// 该函数通过系统根指针遍历系统节点，设置资源初始化相关的回调函数和系统标识
void InitializeSystemSubcomponentA(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateJ,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateJ,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemDataNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentB(void)
// 功能: 初始化系统子组件B - 负责系统事件回调的设置
// 该函数通过系统根指针遍历系统节点，设置事件处理相关的回调函数和系统标识
void InitializeSystemSubcomponentB(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateK,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateK,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDataNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentC(void)
// 功能: 初始化系统子组件C - 负责系统内存管理组件的初始化
// 该函数初始化系统内存管理相关的数据结构和配置参数
void InitializeSystemSubcomponentC(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateL,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateL,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemDataNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentD(void)
// 功能: 初始化系统子组件D - 负责系统线程管理组件的初始化
// 该函数初始化系统线程管理相关的数据结构和同步机制
void InitializeSystemSubcomponentD(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




// 函数: void InitializeSystemSubcomponentE(void)
// 功能: 初始化系统子组件E - 负责系统文件管理组件的初始化
// 该函数初始化系统文件管理相关的数据结构和文件句柄
void InitializeSystemSubcomponentE(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentF(void)
// 功能: 初始化系统子组件F - 负责系统网络管理组件的初始化
// 该函数初始化系统网络管理相关的数据结构和网络配置
void InitializeSystemSubcomponentF(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateC,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateC,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42bea5b911d9c4bf;
  systemPreviousNode[7] = 0x1aa83fc0020dc1b6;
  systemPreviousNode[8] = &SystemDataNodeB;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentG(void)
// 功能: 初始化系统子组件G - 负责系统安全管理组件的初始化
// 该函数初始化系统安全管理相关的数据结构和访问控制
void InitializeSystemSubcomponentG(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d660,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d660,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46c54bc98fc3fc2a;
  systemPreviousNode[7] = 0x727b256e3af32585;
  systemPreviousNode[8] = &UNK_180a2ca90;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentH(void)
// 功能: 初始化系统子组件H - 负责系统日志管理组件的初始化
// 该函数初始化系统日志管理相关的数据结构和日志配置
void InitializeSystemSubcomponentH(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d590,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d590,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x41ffd0b76c1e136f;
  systemPreviousNode[7] = 0x25db30365f277abb;
  systemPreviousNode[8] = &UNK_180a2cab0;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// 函数: int InitializeSystemSynchronizationMechanism(void)
/**
 * @brief 初始化系统同步机制
 * 
 * 该函数负责初始化系统的同步机制，包括互斥锁初始化、
 * 同步数据结构设置和系统同步状态管理。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemSynchronizationMechanism(void)

{
  long long systemInitializationResult;
  
  InitializeSystemSynchronizationData(&SystemSynchronizationDataPrimary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemSynchronizationData(&SystemSynchronizationDataSecondary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemSynchronizationData(&SystemSynchronizationDataTertiary,8,5,&SystemSynchronizationCallback,InitializeSystemSynchronizationHandler);
  InitializeSystemMutex(&SystemSynchronizationMutex,2);
  SystemSynchronizationStatusPrimary = 0;
  SystemSynchronizationStatusSecondary = 0;
  SystemSynchronizationStatusTertiary = 0;
  SystemSynchronizationFlagPrimary = 3;
  SystemSynchronizationStatusQuaternary = 0;
  SystemSynchronizationStatusQuinary = 0;
  SystemSynchronizationStatusSenary = 0;
  SystemSynchronizationFlagSecondary = 3;
  SystemSynchronizationStatusSeptenary = 0;
  SystemSynchronizationStatusOctonary = 0;
  SystemSynchronizationFlagTertiary = 3;
  InitializeSystemSynchronizationCore();
  systemInitializationResult = CheckSystemSynchronizationStatus(&SystemSynchronizationControlData);
  return (systemInitializationResult != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

// 函数: int InitializeSystemPerformanceMonitor(void)
/**
 * @brief 初始化系统性能监控器
 * 
 * 该函数负责初始化系统的性能监控组件，设置性能监控数据结构
 * 和性能计数器，为系统性能分析提供基础支持。
 * 
 * @return 初始化成功返回0，失败返回-1
 */
int InitializeSystemPerformanceMonitor(void)

{
  long long systemInitializationResult;
  void* systemParameter;
  
  SystemPerformanceMonitorData = &SystemPerformanceMonitorConfiguration;
  SystemPerformanceMonitorStatus = &SystemPerformanceMonitorStatusData;

// 函数: void InitializeSystemSubcomponentI(void)
// 功能: 初始化系统子组件I - 负责系统性能监控组件的初始化
// 该函数初始化系统性能监控相关的数据结构和性能计数器
void InitializeSystemSubcomponentI(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d660,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d660,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46c54bc98fc3fc2a;
  systemPreviousNode[7] = 0x727b256e3af32585;
  systemPreviousNode[8] = &UNK_180a2ca90;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentJ(void)
// 功能: 初始化系统子组件J - 负责系统配置管理组件的初始化
// 该函数初始化系统配置管理相关的数据结构和配置参数
void InitializeSystemSubcomponentJ(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d590,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d590,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x41ffd0b76c1e136f;
  systemPreviousNode[7] = 0x25db30365f277abb;
  systemPreviousNode[8] = &UNK_180a2cab0;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentK(void)
// 功能: 初始化系统子组件K - 负责系统插件管理组件的初始化
// 该函数初始化系统插件管理相关的数据结构和插件接口
void InitializeSystemSubcomponentK(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d660,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d660,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46c54bc98fc3fc2a;
  systemPreviousNode[7] = 0x727b256e3af32585;
  systemPreviousNode[8] = &UNK_180a2ca90;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSubcomponentL(void)
// 功能: 初始化系统子组件L - 负责系统调试管理组件的初始化
// 该函数初始化系统调试管理相关的数据结构和调试工具
void InitializeSystemSubcomponentL(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d590,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d590,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x41ffd0b76c1e136f;
  systemPreviousNode[7] = 0x25db30365f277abb;
  systemPreviousNode[8] = &UNK_180a2cab0;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemSubcomponentM(void)
// 功能: 初始化系统子组件M - 负责系统备份管理组件的初始化
// 该函数初始化系统备份管理相关的数据结构和备份策略
void InitializeSystemSubcomponentM(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0xd;
  strcpy_s(stackBuffer,0x80,&UNK_180a33fb0,in_R9,0xfffffffffffffffe);
  _DAT_180c95ecc = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



/**
 * @brief 初始化系统互斥锁
 * 
 * 该函数负责初始化系统的互斥锁机制，确保多线程环境下的资源同步访问。
 * 它使用 mtx_init_in_situ 函数来初始化互斥锁，并设置适当的同步参数。
 * 
 * @param param_1 互斥锁标识符
 * @param param_2 互斥锁类型
 * @param param_3 同步参数1
 * @param param_4 同步参数2
 * @return int 初始化成功返回0，失败返回-1
 */
int InitializeSystemMutex(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long initializationResult;
  
  _Mtx_init_in_situ(0x180c96690,2,param_3,param_4,0xfffffffffffffffe);
  initializationResult = InitializeSystemSyncMechanism(FUN_180943070);
  return (initializationResult != 0) - 1;
}




// 函数: void InitializeSystemSubcomponentN(void)
// 功能: 初始化系统子组件N - 负责系统更新管理组件的初始化
// 该函数初始化系统更新管理相关的数据结构和更新机制
void InitializeSystemSubcomponentN(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d660,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d660,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46c54bc98fc3fc2a;
  systemPreviousNode[7] = 0x727b256e3af32585;
  systemPreviousNode[8] = &UNK_180a2ca90;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemNodeManagerPrimary(void)
/**
 * @brief 初始化系统节点管理器（主节点）
 * 
 * 该函数负责初始化系统的节点管理器主节点，设置节点树结构，
 * 进行内存比较和节点插入操作，确保系统节点管理器的正常运行。
 */
void InitializeSystemNodeManagerPrimary(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_180a2d590,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_180a2d590,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x41ffd0b76c1e136f;
  systemPreviousNode[7] = 0x25db30365f277abb;
  systemPreviousNode[8] = &UNK_180a2cab0;
  systemPreviousNode[9] = 2;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: void InitializeSystemSearchManager(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理器，设置搜索相关的数据结构和
 * 搜索函数指针，为系统提供搜索功能支持。
 */
void InitializeSystemSearchManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemSearchCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateD,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateD,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x406be72011d07d37;
  systemPreviousNode[7] = 0x71876af946c867ab;
  systemPreviousNode[8] = &SystemDataNodeC;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统节点管理器
 * 
 * 该函数负责初始化系统的节点管理组件，设置节点管理的基础结构。
 * 它会遍历系统节点树，进行内存比较，分配必要的内存，并设置节点属性。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保节点管理系统的正常运行
 */
void InitializeSystemNodeManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateG,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateG,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40afa5469b6ac06d;
  systemPreviousNode[7] = 0x2f4bab01d34055a5;
  systemPreviousNode[8] = &SystemDataNodeD;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: void FUN_1800423d0(void)
/**
 * @brief 初始化系统搜索管理器
 * 
 * 该函数负责初始化系统的搜索管理组件，设置搜索节点的基础结构。
 * 它会遍历系统搜索节点树，进行内存比较，分配必要的内存，并设置搜索节点属性。
 * 该函数还负责配置系统搜索的回调函数和内存管理。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保搜索管理系统的正常运行
 */
void InitializeSystemSearchManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemSearchFunctionPointer = GetSystemSearchFunctionC;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateH,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateH,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x43330a43fcdb3653;
  systemPreviousNode[7] = 0xdcfdc333a769ec93;
  systemPreviousNode[8] = &SystemDataNodeE;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统事件管理器
 * 
 * 该函数负责初始化系统的事件管理组件，设置事件处理节点的基础结构。
 * 它会遍历系统事件节点树，进行内存比较，分配必要的内存，并设置事件节点属性。
 * 该函数还负责配置系统事件的回调函数和事件管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保事件管理系统的正常运行
 */
void InitializeSystemEventManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *eventSearchFunctionPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  eventSearchFunctionPointer = GetSystemSearchFunctionD;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x431d7c8d7c475be2;
  systemPreviousNode[7] = 0xb97f048d2153e1b0;
  systemPreviousNode[8] = &SystemEventNodeF;
  systemPreviousNode[9] = 4;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统资源管理器
 * 
 * 该函数负责初始化系统的资源管理组件，设置资源节点的基础结构。
 * 它会遍历系统资源节点树，进行内存比较，分配必要的内存，并设置资源节点属性。
 * 该函数还负责配置系统资源的初始化回调函数和资源管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保资源管理系统的正常运行
 */
void InitializeSystemResourceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4b2d79e470ee4e2c;
  systemPreviousNode[7] = 0x9c552acd3ed5548d;
  systemPreviousNode[8] = &SystemResourceNodeG;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统设备管理器
 * 
 * 该函数负责初始化系统的设备管理组件，设置设备节点的基础结构。
 * 它会遍历系统设备节点树，进行内存比较，分配必要的内存，并设置设备节点属性。
 * 该函数还负责配置系统设备的回调函数和设备管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保设备管理系统的正常运行
 */
void InitializeSystemDeviceManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *deviceInitializationCallback;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  deviceInitializationCallback = SystemInitializationCallbackB;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDeviceComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDeviceComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x49086ba08ab981a7;
  systemPreviousNode[7] = 0xa9191d34ad910696;
  systemPreviousNode[8] = &SystemDeviceNodeH;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = deviceEventCallbackPointer;
  return;
}




/**
 * @brief 初始化系统内存管理器
 * 
 * 该函数负责初始化系统的内存管理组件，设置内存节点的基础结构。
 * 它会遍历系统内存节点树，进行内存比较，分配必要的内存，并设置内存节点属性。
 * 该函数还负责配置系统内存的初始化回调函数和内存管理机制。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保内存管理系统的正常运行
 */
void InitializeSystemMemoryManager(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemMemoryComparisonTemplate,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemMemoryComparisonTemplate,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x402feffe4481676e;
  systemPreviousNode[7] = 0xd4c2151109de93a0;
  systemPreviousNode[8] = &SystemMemoryNodeI;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = memoryInitializationCallback;
  return;
}




// 函数: 系统数据节点初始化器M
/**
 * @brief 系统数据节点初始化器M
 * 
 * 该函数负责初始化系统数据节点M，在系统数据表中创建和配置
 * 特定的数据节点结构，用于存储系统运行时数据
 */
void SystemDataNodeInitializerM(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  undefined *systemStackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemStackPointer = &SystemDataNodeJ;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateM,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateM,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4384dcc4b6d3f417;
  systemPreviousNode[7] = 0x92a15d52fe2679bd;
  systemPreviousNode[8] = &SystemDataNodeK;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = systemStackPointer;
  return;
}




/**
 * @brief 初始化系统资源初始化节点
 * 
 * 该函数负责初始化系统资源初始化节点，在系统节点树中查找合适的位置
 * 插入资源初始化节点，并设置节点的标识符和回调函数。
 * 这是系统资源管理的重要组成部分。
 */
void InitializeSystemResourceInitializationNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateN,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateN,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4140994454d56503;
  systemPreviousNode[7] = 0x399eced9bb5517ad;
  systemPreviousNode[8] = &SystemDataNodeL;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化游戏核心系统节点
 * 
 * 该函数负责初始化游戏核心系统节点，在系统节点树中查找合适的位置
 * 插入游戏核心系统节点，并设置节点的标识符和事件回调函数。
 * 这是游戏核心系统管理的重要组成部分。
 */
void InitializeGameCoreSystemNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFunction = SystemInitializationFunction;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&GAME_CORE_SYSTEM_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&GAME_CORE_SYSTEM_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4fc124d23d41985f;
  systemPreviousNode[7] = 0xe2f4a30d6e6ae482;
  systemPreviousNode[8] = &GAME_CORE_NODE_DATA;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




/**
 * @brief 初始化基础分配器节点
 * 
 * 该函数负责初始化基础分配器节点，在系统节点树中查找合适的位置
 * 插入基础分配器节点，并设置节点的标识符和回调函数。
 * 这是系统内存管理的重要组成部分。
 */
void InitializeBaseAllocatorNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&BASE_ALLOCATOR_ID,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&BASE_ALLOCATOR_ID,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4770584fbb1df897;
  systemPreviousNode[7] = 0x47f249e43f66f2ab;
  systemPreviousNode[8] = &UNK_18098c7a0;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




/**
 * @brief 初始化系统数据表节点
 * 
 * 该函数负责初始化系统数据表节点，在系统节点树中查找合适的位置
 * 插入数据表节点，并设置节点的标识符和回调函数。
 * 这是系统数据管理的重要组成部分。
 */
void InitializeSystemDataTableNode(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c9b8,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c9b8,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4666df49b97e0f10;
  systemPreviousNode[7] = 0x4e4b0d63a6ad1d8f;
  systemPreviousNode[8] = &UNK_18098c7b8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 资源初始化回调设置器
/**
 * @brief 资源初始化回调设置器
 * 
 * 该函数负责设置资源初始化的回调函数，配置系统资源管理
 * 的初始化流程，确保资源能够正确加载和初始化
 */
void ResourceInitializationCallbackSetter(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&DAT_18098c940,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c940,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x46ecbd4daf41613e;
  systemPreviousNode[7] = 0xdc42c056bbde8482;
  systemPreviousNode[8] = &UNK_18098c7c8;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统分配器节点初始化器
/**
 * @brief 系统分配器节点初始化器
 * 
 * 该函数负责初始化系统分配器节点，配置内存分配器的
 * 基础数据结构，为系统内存管理提供支持
 */
void SystemAllocatorNodeInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemAllocatorIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemAllocatorIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c868a42644030f6;
  systemPreviousNode[7] = 0xc29193aa9d9b35b9;
  systemPreviousNode[8] = &SystemAllocatorNodeId;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统配置节点初始化器
/**
 * @brief 系统配置节点初始化器
 * 
 * 该函数负责初始化系统配置节点，创建和配置系统的
 * 配置数据结构，用于存储系统运行时的配置信息
 */
void SystemConfigurationNodeInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemConfigurationIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemConfigurationIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x40ea3a798283cbbb;
  systemPreviousNode[7] = 0x7f74eb2c5a7fadae;
  systemPreviousNode[8] = &SystemConfigurationData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统事件节点初始化器
/**
 * @brief 系统事件节点初始化器
 * 
 * 该函数负责初始化系统事件节点，创建和配置系统的
 * 事件处理数据结构，用于管理系统事件的分发和处理
 */
void SystemEventNodeInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemEventIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemEventIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x45b8d074df27d12f;
  systemPreviousNode[7] = 0x8d98f4c06880eda4;
  systemPreviousNode[8] = &SystemEventData;
  systemPreviousNode[9] = 3;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统内存管理节点初始化器
/**
 * @brief 系统内存管理节点初始化器
 * 
 * 该函数负责初始化系统内存管理节点，创建和配置系统的
 * 内存管理数据结构，用于优化内存分配和回收
 */
void SystemMemoryManagementNodeInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemResourceIdentifier,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemResourceIdentifier,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x42d293584c8cf3e5;
  systemPreviousNode[7] = 0x355ffeb2d29e668a;
  systemPreviousNode[8] = &SystemRootNodePointer;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}




// 函数: 系统线程管理器初始化器
/**
 * @brief 系统线程管理器初始化器
 * 
 * 该函数负责初始化系统线程管理器，创建和配置系统的
 * 线程管理数据结构，用于管理多线程环境下的任务调度
 */
void SystemThreadManagerInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  code *systemCallbackPointer;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemCallbackPointer = SystemCallbackManager;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateA,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&DAT_18098c8f0,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x421c3cedd07d816d;
  systemPreviousNode[7] = 0xbec25de793b7afa6;
  systemPreviousNode[8] = &UNK_18098c880;
  systemPreviousNode[9] = 0;
  systemPreviousNode[10] = eventCallbackPointer;
  return;
}




// 函数: 系统资源跟踪器初始化器
/**
 * @brief 系统资源跟踪器初始化器
 * 
 * 该函数负责初始化系统资源跟踪器，创建和配置系统的
 * 资源跟踪数据结构，用于监控和管理系统资源的使用情况
 */
void SystemResourceTrackerInitializer(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void** systemPreviousNode;
  uint64_t systemInitializationFlag;
  
  systemDataTable = (long long *)GetSystemRootPointer();
  systemRootNode = (void* *)*systemDataTable;
  systemNodeFlag = *(char *)((long long)systemRootNode[1] + 0x19);
  systemInitializationFlag = 0;
  systemPreviousNode = systemRootNode;
  systemCurrentNode = (void* *)systemRootNode[1];
  while (systemNodeFlag == '\0') {
    memoryCompareResult = memcmp(systemCurrentNode + 4,&SystemDataComparisonTemplateB,0x10);
    if (memoryCompareResult < 0) {
      systemNextNode = (void* *)systemCurrentNode[2];
      systemCurrentNode = systemPreviousNode;
    }
    else {
      systemNextNode = (void* *)*systemCurrentNode;
    }
    systemPreviousNode = systemCurrentNode;
    systemCurrentNode = systemNextNode;
    systemNodeFlag = *(char *)((long long)systemNextNode + 0x19);
  }
  if ((systemPreviousNode == systemRootNode) || (memoryCompareResult = memcmp(&SystemDataComparisonTemplateB,systemPreviousNode + 4,0x10), memoryCompareResult < 0)) {
    memoryAllocationSize = GetSystemMemorySize(systemDataTable);
    AllocateSystemMemory(systemDataTable,&systemAllocatedNode,systemPreviousNode,memoryAllocationSize + 0x20,memoryAllocationSize);
    systemPreviousNode = systemAllocatedNode;
  }
  systemPreviousNode[6] = 0x4c22bb0c326587ce;
  systemPreviousNode[7] = 0x5e3cf00ce2978287;
  systemPreviousNode[8] = &UNK_18098c898;
  systemPreviousNode[9] = 1;
  systemPreviousNode[10] = resourceInitializationCallback;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: 系统性能监控器初始化器
/**
 * @brief 系统性能监控器初始化器
 * 
 * 该函数负责初始化系统性能监控器，创建和配置系统的
 * 性能监控数据结构，用于收集和分析系统性能数据
 */
void SystemPerformanceMonitorInitializer(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x1b;
  strcpy_s(stackBuffer,0x80,&UNK_180a3c028,in_R9,0xfffffffffffffffe);
  _DAT_180c9606c = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: 系统安全管理器初始化器
/**
 * @brief 系统安全管理器初始化器
 * 
 * 该函数负责初始化系统安全管理器，获取当前进程信息，
 * 为系统安全功能提供基础的进程上下文
 */
void SystemSecurityManagerInitializer(void)

{
  _DAT_180c96218 = GetCurrentProcess();
  return;
}



/**
 * @brief 初始化系统性能计数器
 * 
 * 该函数负责初始化系统的性能计数器组件，设置性能监控的基础结构。
 * 它会调用性能计数器初始化函数，并返回初始化状态。
 * 
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemPerformanceCounters(void)

{
  long long initializationStatus;
  
  InitializeSystemPerformanceCounters();
  initializationStatus = FUN_1808fc7d0(&UNK_180943130);
  return (initializationStatus != 0) - 1;
}



/**
 * @brief 初始化系统互斥锁
 * 
 * 该函数负责初始化系统的互斥锁组件，设置线程同步的基础结构。
 * 它会初始化互斥锁，并返回初始化状态。
 * 
 * @param param_1 互斥锁参数1
 * @param param_2 互斥锁参数2
 * @param param_3 互斥锁参数3
 * @param param_4 互斥锁参数4
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemMutex(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long initializationStatus;
  
  _Mtx_init_in_situ(0x180c966f0,2,param_3,param_4,0xfffffffffffffffe);
  initializationStatus = FUN_1808fc7d0(FUN_180943140);
  return (initializationStatus != 0) - 1;
}



/**
 * @brief 初始化系统信号量
 * 
 * 该函数负责初始化系统的信号量组件，设置线程同步的基础结构。
 * 它会初始化信号量，并返回初始化状态。
 * 
 * @param param_1 信号量参数1
 * @param param_2 信号量参数2
 * @param param_3 信号量参数3
 * @param param_4 信号量参数4
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemSemaphore(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long initializationStatus;
  
  _Mtx_init_in_situ(0x180c96740,2,param_3,param_4,0xfffffffffffffffe);
  initializationStatus = FUN_1808fc7d0(FUN_180943160);
  return (initializationStatus != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * @brief 初始化系统线程池
 * 
 * 该函数负责初始化系统的线程池组件，设置线程池的基础结构。
 * 它会初始化线程池的全局变量，并返回初始化状态。
 * 
 * @return 初始化状态，成功返回0，失败返回-1
 */
int InitializeSystemThreadPool(void)

{
  long long initializationStatus;
  
  _DAT_180c967b8 = 3;
  _DAT_180c96790 = &DAT_180c96790;
  _DAT_180c96798 = &DAT_180c96790;
  _DAT_180c967a0 = 0;
  _DAT_180c967a8 = 0;
  _DAT_180c967b0 = 0;
  initializationStatus = FUN_1808fc7d0(FUN_180943180);
  return (initializationStatus != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: 系统网络管理器初始化器
/**
 * @brief 系统网络管理器初始化器
 * 
 * 该函数负责初始化系统网络管理器，设置网络相关的
 * 基础数据结构和配置，为网络通信功能提供支持
 */
void SystemNetworkManagerInitializer(void)

{
  void* in_R9;
  undefined *stackParameterA;
  uint8_t *stackParameterB;
  uint32_t stackParameterC;
  uint8_t stackBuffer [136];
  
  stackParameterA = &SystemGlobalDataPointerC;
  stackParameterB = stackBuffer;
  stackBuffer[0] = 0;
  stackParameterC = 0x10;
  strcpy_s(stackBuffer,0x80,&UNK_180a3def0,in_R9,0xfffffffffffffffe);
  _DAT_180c967d0 = SystemMemoryAllocationFunction(&stackParameterA);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * 初始化线程本地存储的回调函数表
 * 设置线程本地存储中的函数指针和回调表
 * 
 * @return 成功返回0，失败返回-1
 */
uint64_t InitializeThreadLocalStorageCallbackTable(void)

{
  uint64_t threadLocalStoragePtr;
  int *callbackTable;
  
  threadLocalStoragePtr = *(uint64_t *)((uint64_t)ThreadLocalStoragePointer + (uint64_t)__tls_index * 8);
  *(uint64_t *)(threadLocalStoragePtr + 0x18) = &SystemMemoryAllocatorReference;
  *(uint64_t *)(threadLocalStoragePtr + 0x20) = 0;
  *(uint32_t *)(threadLocalStoragePtr + 0x28) = 0;
  *(uint64_t *)(threadLocalStoragePtr + 0x18) = &SystemGlobalDataReference;
  *(uint64_t *)(threadLocalStoragePtr + 0x30) = 0;
  *(uint64_t *)(threadLocalStoragePtr + 0x20) = 0;
  *(uint32_t *)(threadLocalStoragePtr + 0x28) = 0;
  threadLocalStoragePtr = *(uint64_t *)((uint64_t)ThreadLocalStoragePointer + (uint64_t)__tls_index * 8);
  callbackTable = *(int **)(threadLocalStoragePtr + 0x50);
  if (callbackTable == (int *)0x0) {
    callbackTable = (int *)(threadLocalStoragePtr + 0x60);
  }
  else {
    if (*callbackTable != 0x1e) goto LAB_1808fd14a;
    callbackTable = (int *)malloc(0x100);
    free(0);
    if (callbackTable == (int *)0x0) {
      return 0xffffffff;
    }
    *(uint64_t *)(callbackTable + 2) = *(uint64_t *)(threadLocalStoragePtr + 0x50);
  }
  *callbackTable = 0;
  *(int **)(threadLocalStoragePtr + 0x50) = callbackTable;
LAB_1808fd14a:
  *(code **)(callbackTable + (uint64_t)*callbackTable * 2 + 4) = FUN_1809431a0;
  *callbackTable = *callbackTable + 1;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化引擎模块A
 * 设置引擎初始化参数和配置
 */
void InitializeEngineModuleA(void)

{
  uint64_t registerR9;
  void *paramStackPtr;
  uint8_t *bufferPtr;
  uint32_t bufferSize;
  uint8_t stringBuffer [136];
  
  paramStackPtr = &UNK_1809fcc28;
  bufferPtr = stringBuffer;
  stringBuffer[0] = 0;
  bufferSize = 0x17;
  strcpy_s(stringBuffer,0x80,&UNK_180a3e3d8,registerR9,0xfffffffffffffffe);
  _DAT_180c967d4 = SystemMemoryAllocationFunction(&paramStackPtr);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化引擎模块B
 * 设置引擎初始化参数和配置
 */
void InitializeEngineModuleB(void)

{
  uint64_t registerR9;
  void *paramStackPtr;
  uint8_t *bufferPtr;
  uint32_t bufferSize;
  uint8_t stringBuffer [136];
  
  paramStackPtr = &UNK_1809fcc28;
  bufferPtr = stringBuffer;
  stringBuffer[0] = 0;
  bufferSize = 0x11;
  strcpy_s(stringBuffer,0x80,&UNK_180a3e3f0,registerR9,0xfffffffffffffffe);
  _DAT_180c967d8 = SystemMemoryAllocationFunction(&paramStackPtr);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * 初始化引擎核心系统
 * 设置引擎核心系统的全局变量和初始状态
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeEngineCoreSystem(void)

{
  uint64_t result;
  
  _DAT_180c96808 = 3;
  _DAT_180c967e0 = &DAT_180c967e0;
  _DAT_180c967e8 = &DAT_180c967e0;
  _DAT_180c967f0 = 0;
  _DAT_180c967f8 = 0;
  _DAT_180c96800 = 0;
  result = FUN_1808fc7d0(FUN_180943200);
  return (result != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * 初始化系统配置和权限设置
 * 设置系统标志位、初始化权限配置，并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeSystemConfiguration(void)

{
  long long callbackResult;
  int configIndex;
  
  _DAT_180c0c6c0 = 0x100;
  configIndex = 0;
  do {
    FUN_180767e20(configIndex,0x4000000000000000,0xffff7fff,0);
    configIndex = configIndex + 1;
  } while (configIndex < 0xd);
  *(uint *)(_DAT_180be14a0 + 0x330) = *(uint *)(_DAT_180be14a0 + 0x330) | 4;
  _DAT_180be1324 = 0xffffffff;
  callbackResult = FUN_1808fc7d0(&UNK_180943250);
  return (callbackResult != 0) - 1;
}



/**
 * 初始化引擎模块B
 * 调用引擎初始化函数并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeEngineModuleB(void)

{
  long long callbackResult;
  
  func_0x000180741c80(0x180c0c340);
  callbackResult = FUN_1808fc7d0(&UNK_180943260);
  return (callbackResult != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置系统指针A
 * 根据系统配置设置适当的系统指针地址
 * 检查系统状态并选择合适的指针地址
 */
void SetSystemPointerA(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(0);
  _DAT_180c0c6d0 = 0x180be14a8;
  if (systemStatus != 0) {
    _DAT_180c0c6d0 = 0x180be14c0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置系统指针B
 * 根据系统配置设置复杂的系统指针地址
 * 首先检查高级配置，然后回退到基础配置
 */
void SetSystemPointerB(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(1);
  if (systemStatus != 0) {
    _DAT_180c0c6d8 = 0x180be15c0;
    return;
  }
  systemStatus = FUN_1807681a0(0);
  _DAT_180c0c6d8 = 0x180be14e0;
  if (systemStatus != 0) {
    _DAT_180c0c6d8 = 0x180be1550;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置渲染系统指针
 * 根据系统配置设置渲染相关的系统指针地址
 */
void SetRenderSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(0);
  _DAT_180c0d100 = 0x180be1c00;
  if (systemStatus != 0) {
    _DAT_180c0d100 = 0x180be1c08;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置音频系统指针
 * 根据系统配置设置音频相关的系统指针地址
 */
void SetAudioSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(0);
  _DAT_180c0e170 = 0x180be23a0;
  if (systemStatus != 0) {
    _DAT_180c0e170 = 0x180be23c0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置输入系统指针
 * 根据系统配置设置输入相关的系统指针地址
 */
void SetInputSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(0);
  _DAT_180c108d0 = 0x180be2ad8;
  if (systemStatus != 0) {
    _DAT_180c108d0 = 0x180be2af8;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置物理系统指针
 * 根据系统配置设置物理相关的系统指针地址
 */
void SetPhysicsSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(0);
  _DAT_180c2bca0 = 0x180be4710;
  if (systemStatus != 0) {
    _DAT_180c2bca0 = 0x180be4728;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置网络系统指针
 * 根据系统配置设置网络相关的系统指针地址
 * 首先检查高级配置，然后回退到基础配置
 */
void SetNetworkSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(1);
  if (systemStatus != 0) {
    _DAT_180c31148 = 0x180be6078;
    return;
  }
  systemStatus = FUN_1807681a0(0);
  _DAT_180c31148 = 0x180be6068;
  if (systemStatus != 0) {
    _DAT_180c31148 = 0x180be6070;
  }
  return;
}



/**
 * 初始化虚拟函数表数组
 * 初始化一个包含16个元素的虚拟函数表数组，并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeVirtualFunctionTableArray(void)

{
  void* *vtablePointer;
  long long loopCounter;
  
  vtablePointer = (void* *)0x180c35590;
  loopCounter = 0x10;
  do {
    func_0x000180767970(vtablePointer);
    *vtablePointer = &UNK_18097e888;
    vtablePointer = vtablePointer + 0x2b;
    loopCounter = loopCounter + -1;
  } while (loopCounter != 0);
  loopCounter = FUN_1808fc7d0(&UNK_180943270);
  return (loopCounter != 0) - 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置游戏逻辑系统指针
 * 根据系统配置设置游戏逻辑相关的系统指针地址
 */
void SetGameLogicSystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(0);
  _DAT_180c4ea58 = 0x180bebac8;
  if (systemStatus != 0) {
    _DAT_180c4ea58 = 0x180bebad8;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 设置UI系统指针
 * 根据系统配置设置UI相关的系统指针地址
 * 按优先级检查不同的系统配置级别
 */
void SetUISystemPointer(void)

{
  int systemStatus;
  
  systemStatus = FUN_1807681a0(3);
  if (systemStatus != 0) {
    _DAT_180c4ea60 = 0x180bebc10;
    return;
  }
  systemStatus = FUN_1807681a0(2);
  if (systemStatus != 0) {
    _DAT_180c4ea60 = 0x180bebbb0;
    return;
  }
  systemStatus = FUN_1807681a0(0);
  _DAT_180c4ea60 = 0x180bebaf0;
  if (systemStatus != 0) {
    _DAT_180c4ea60 = 0x180bebb50;
  }
  return;
}



/**
 * 初始化调试系统
 * 初始化调试相关的系统组件并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeDebugSystem(void)

{
  long long callbackResult;
  
  FUN_1808dbcd0(0x180c4f510);
  callbackResult = FUN_1808fc7d0(&UNK_180943310);
  return (callbackResult != 0) - 1;
}



/**
 * 初始化线程安全互斥锁
 * 初始化线程安全的互斥锁机制并注册系统回调
 * 
 * @return 成功返回0，失败返回-1
 */
int InitializeThreadSafetyMutex(void)

{
  long long callbackResult;
  
  _Mtx_init_in_situ(0x180c82170,2);
  callbackResult = FUN_1808fc7d0(&UNK_180943320);
  return (callbackResult != 0) - 1;
}



void WotsMainSDLL(void* param_1)

{
  void* auStackX_18 [2];
  
                    // 0x43d20  31  WotsMainSDLL

/**
 * 初始化主系统控制器
 * 初始化游戏主系统控制器，处理系统状态和事件管理
 * 
 * @param param_1 系统参数
 */
void InitializeMainSystemController(long long param_1)

{
  long long systemObject;
  long long *controllerPtr;
  char isActiveFlag;
  long long *tempStackPtr8;
  long long **tempStackPtr10;
  long long *tempStackPtr18;
  long long *tempStackPtr20;
  void* allocationFlags;
  
  allocationFlags = 0xfffffffffffffffe;
  FUN_180046e20();
  _DAT_180c82864 = _DAT_180c82864 + 1;
  FUN_180050b00();
  if (_DAT_180c91048 != (long long *)0x0) {
    if ((undefined *)*_DAT_180c91048 == &UNK_1809fe100) {
      isActiveFlag = (char)_DAT_180c91048[2] != '\0';
    }
    else {
      isActiveFlag = (**(code **)((undefined *)*_DAT_180c91048 + 0x68))();
    }
    if (isActiveFlag == '\0') goto LAB_180043e47;
  }
  controllerPtr = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0xc0,8,3,allocationFlags);
  tempStackPtr20 = controllerPtr;
  FUN_180049830(controllerPtr);
  *controllerPtr = (long long)&UNK_1809fe100;
  controllerPtr[3] = -4;
  tempStackPtr10 = (long long **)controllerPtr;
  (**(code **)(*controllerPtr + 0x28))(controllerPtr);
  tempStackPtr10 = (long long **)_DAT_180c91048;
  if (_DAT_180c91048 != (long long *)0x0) {
    systemObject = *_DAT_180c91048;
    _DAT_180c91048 = controllerPtr;
    (**(code **)(systemObject + 0x38))();
    controllerPtr = _DAT_180c91048;
  }
  _DAT_180c91048 = controllerPtr;
  if ((undefined *)*_DAT_180c91048 == &UNK_1809fe100) {
    if (_DAT_180c86948 != 0) {
      FUN_18006e990();
    }
  }
  else {
    (**(code **)((undefined *)*_DAT_180c91048 + 0x60))();
  }
  controllerPtr = _DAT_180c91048;
  tempStackPtr18 = _DAT_180c91048;
  _DAT_180c91048 = (long long *)0x0;
  if (controllerPtr != (long long *)0x0) {
    (**(code **)(*controllerPtr + 0x38))();
  }
LAB_180043e47:
  SystemThreadSyncBroadcast(*(void* *)(param_1 + 0x20));
  if (*(char *)(_DAT_180c86870 + 0x1ed) != '\0') {
    controllerPtr = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x28,8,3);
    *controllerPtr = (long long)&UNK_180a21690;
    *controllerPtr = (long long)&UNK_180a21720;
    *(uint32_t *)(controllerPtr + 1) = 0;
    *controllerPtr = (long long)&UNK_18098bdc8;
    LOCK();
    *(uint8_t *)(controllerPtr + 2) = 0;
    UNLOCK();
    controllerPtr[3] = -1;
    *controllerPtr = (long long)&UNK_18098bd40;
    controllerPtr[4] = 0x180c91060;
    tempStackPtr20 = controllerPtr;
    (**(code **)(*controllerPtr + 0x28))(controllerPtr);
    allocationFlags = _DAT_180c82868;
    tempStackPtr10 = &tempStackPtr8;
    tempStackPtr8 = controllerPtr;
    (**(code **)(*controllerPtr + 0x28))(controllerPtr);
    FUN_18005e300(allocationFlags,&tempStackPtr8);
    (**(code **)(*controllerPtr + 0x38))(controllerPtr);
  }
  return;
}



/**
 * 内存管理器清理函数
 * 清理内存管理器相关的指针和资源
 * 
 * @param param_1 内存管理器指针
 * @param param_2 清理标志
 * @param param_3 保留参数
 * @param param_4 保留参数
 * @return 返回内存管理器指针
 */
void* *
CleanupMemoryManager(void* *memoryManager,ulong long cleanupFlags,void* reservedParam3,void* reservedParam4)

{
  *memoryManager = &UNK_18098bd40;
  *memoryManager = &UNK_18098bdc8;
  *memoryManager = &UNK_180a21720;
  *memoryManager = &UNK_180a21690;
  if ((cleanupFlags & 1) != 0) {
    free(memoryManager,0x28,reservedParam3,reservedParam4,0xfffffffffffffffe);
  }
  return memoryManager;
}




/**
 * 系统终止函数
 * 终止系统运行，此函数不会返回
 */
void TerminateSystem(void)

{
                    // WARNING: Subroutine does not return
  FUN_1808fd200();
}




/**
 * 设置默认系统指针
 * 设置系统默认的指针地址
 * 
 * @param param_1 系统指针
 */
void SetDefaultSystemPointer(void* *systemPointer)

{
  *systemPointer = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 初始化系统信息和用户环境
 * 初始化系统信息，获取计算机名和用户名，设置系统环境
 */
void InitializeSystemInfoAndUserEnvironment(void)

{
  void* *systemInfoPtr;
  code *systemCallback;
  long long systemHandle;
  int operationResult;
  void* allocationFlags;
  long long *controllerPtr;
  uint8_t auStack_248 [32];
  undefined *puStack_228;
  undefined *puStack_220;
  undefined *puStack_218;
  long long *plStack_208;
  uint32_t uStack_200;
  undefined *puStack_1f8;
  undefined *puStack_1f0;
  uint32_t uStack_1e8;
  ulong long uStack_1e0;
  undefined *puStack_1d8;
  undefined *puStack_1d0;
  uint32_t uStack_1c8;
  ulong long uStack_1c0;
  undefined *puStack_1b8;
  long long lStack_1b0;
  uint32_t uStack_1a0;
  void* uStack_198;
  long long *plStack_190;
  undefined *puStack_188;
  undefined *puStack_180;
  uint32_t uStack_178;
  undefined auStack_170 [32];
  long long **applStack_150 [3];
  uint8_t auStack_138 [272];
  ulong long uStack_28;
  
  uStack_198 = 0xfffffffffffffffe;
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_248;
  uStack_200 = 0;
  if (*(char *)(_DAT_180c86928 + 0x18) == '\0') {
    FUN_18004b560(&puStack_1b8);
    (**(code **)(**(long long **)(_DAT_180c86870 + 0x2b0) + 0x98))
              (*(long long **)(_DAT_180c86870 + 0x2b0),&puStack_1b8);
    FUN_180061380();
    lVar3 = _DAT_180c86928;
    uVar5 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
    plVar6 = (long long *)FUN_1800636f0(uVar5,8,lVar3);
    plStack_190 = plVar6;
    if (plVar6 != (long long *)0x0) {
      (**(code **)(*plVar6 + 0x28))(plVar6);
    }
    *(uint32_t *)(plVar6 + 0xd) = 0xbb80073;
    puVar1 = *(void* **)(lVar3 + 400);
    pcVar2 = *(code **)*puVar1;
    applStack_150[0] = &plStack_208;
    plStack_208 = plVar6;
    (**(code **)(*plVar6 + 0x28))(plVar6);
    (*pcVar2)(puVar1,&plStack_208);
    (**(code **)(*plVar6 + 0x38))(plVar6);
    FUN_1800624c0();
    puStack_1d8 = &SystemGlobalDataReference;
    uStack_1c0 = 0;
    puStack_1d0 = (undefined *)0x0;
    uStack_1c8 = 0;
    puStack_1f8 = &SystemGlobalDataReference;
    uStack_1e0 = 0;
    puStack_1f0 = (undefined *)0x0;
    uStack_1e8 = 0;
    plStack_208 = (long long *)CONCAT44(plStack_208._4_4_,0x10);
    iVar4 = GetComputerNameA(applStack_150,&plStack_208);
    if (iVar4 == 0) {
      FUN_180627160(&UNK_180a3c110);
    }
    else {
      if (0xf < ((ulong long)plStack_208 & 0xffffffff)) goto LAB_180044db8;
      *(uint8_t *)((long long)applStack_150 + ((ulong long)plStack_208 & 0xffffffff)) = 0;
      (**(code **)(puStack_1d8 + 0x10))(&puStack_1d8,applStack_150);
    }
    plStack_208 = (long long *)CONCAT44(plStack_208._4_4_,0x101);
    iVar4 = GetUserNameA(auStack_138,&plStack_208);
    if (iVar4 == 0) {
      FUN_180627160(&UNK_180a3c138);
    }
    else {
      if (0x100 < ((ulong long)plStack_208 & 0xffffffff)) {
        FUN_1808fcdc8();
LAB_180044db8:
        FUN_1808fcdc8();
        pcVar2 = (code *)swi(3);
        (*pcVar2)();
        return;
      }
      auStack_138[(ulong long)plStack_208 & 0xffffffff] = 0;
      (**(code **)(puStack_1f8 + 0x10))(&puStack_1f8,auStack_138);
    }
    puStack_218 = &SystemStringTemplate;
    if (puStack_1f0 != (undefined *)0x0) {
      puStack_218 = puStack_1f0;
    }
    puStack_220 = &SystemStringTemplate;
    if (puStack_1d0 != (undefined *)0x0) {
      puStack_220 = puStack_1d0;
    }
    puStack_228 = &UNK_18098bab0;
    FUN_1800623b0(_DAT_180c86928,5,0xffffffffffffffff,4);
    puStack_188 = &UNK_18098bc80;
    puStack_180 = auStack_170;
    uStack_178 = 0;
    auStack_170[0] = 0;
    uStack_200 = 2;
    FUN_18004b860(&puStack_188,&UNK_1809fd0a0,0x130a7);
    puStack_220 = &SystemStringTemplate;
    if (puStack_180 != (undefined *)0x0) {
      puStack_220 = puStack_180;
    }
    puStack_228 = &UNK_18098bac8;
    FUN_1800623b0(_DAT_180c86928,5,0xffffffffffffffff,4);
    uStack_200 = 0;
    puStack_188 = &SystemMemoryAllocatorReference;
    puStack_1f8 = &SystemGlobalDataReference;
    if (puStack_1f0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_1f0 = (undefined *)0x0;
    uStack_1e0 = uStack_1e0 & 0xffffffff00000000;
    puStack_1f8 = &SystemMemoryAllocatorReference;
    puStack_1d8 = &SystemGlobalDataReference;
    if (puStack_1d0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_1d0 = (undefined *)0x0;
    uStack_1c0 = uStack_1c0 & 0xffffffff00000000;
    puStack_1d8 = &SystemMemoryAllocatorReference;
    puStack_1b8 = &SystemGlobalDataReference;
    if (lStack_1b0 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_1b0 = 0;
    uStack_1a0 = 0;
    puStack_1b8 = &SystemMemoryAllocatorReference;
  }
  uStack_200 = 0;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_28 ^ (ulong long)auStack_248);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180044dc0(void* param_1,long long param_2)
/**
 * @brief 初始化系统调试符号管理器
 * 
 * 该函数负责初始化系统的调试符号处理组件，包括符号表的初始化、
 * 动态库加载、符号搜索路径设置和性能计数器配置。它还会初始化
 * 线程管理器和时间相关功能。
 * 
 * @param systemContext 系统上下文参数
 * @param initializationFlag 初始化标志
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保调试功能的正常运行
 */
void InitializeSystemDebugSymbolManager(void* systemContext,long long initializationFlag)

{
  long long **symbolTablePointer;
  int initializationResult;
  uint symbolFlags;
  uint32_t symbolOptions;
  void* systemHandle;
  long long *libraryHandle;
  long long performanceFrequency;
  void* *symbolNextNode;
  void* *debugContextPointer;
  void* *threadContextPointer;
  uint8_t *memoryAllocationFlag;
  char *searchPathPointer;
  undefined *stackPointer;
  ulong long systemTimestamp;
  uint stackFlags;
  char threadState;
  long long *threadLocalData;
  long long **threadManagerPointer;
  long long performanceCounter;
  undefined *stackBufferLarge1;
  undefined *stackBufferLarge2;
  uint32_t stackParameter1;
  undefined *stackBufferMedium1;
  long long stackParameter2;
  uint stackParameter3;
  undefined *stackBufferSmall1;
  undefined *stackBufferSmall2;
  uint32_t stackParameter4;
  void* stackParameter5;
  long long **mutexPointer;
  long long *threadLocalStorage;
  
  stackParameter5 = 0xfffffffffffffffe;
  systemHandle = GetSystemDebugHandle();
  InitializeSystemCore();
  libraryHandle = (long long *)AllocateSystemMemory(_DAT_180c8ed18,0x68,8,3);
  symbolTablePointer = (long long **)(libraryHandle + 1);
  threadLocalData = libraryHandle;
  threadManagerPointer = symbolTablePointer;
  InitializeMutex(symbolTablePointer,2);
  libraryHandle[0xb] = 0;
  libraryHandle[0xc] = 0;
  *(undefined2 *)libraryHandle = 0;
  _DAT_180c8ed10 = libraryHandle;
  if ((char)*libraryHandle != '\0') goto LAB_180044faf;
  mutexPointer = symbolTablePointer;
  initializationResult = LockMutex(symbolTablePointer);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  SymSetOptions(0x2017);
  InitializeSystemLogging(&puStack_b8);
  puVar13 = &SystemStringTemplate;
  if (puStack_b0 != (undefined *)0x0) {
    puVar13 = puStack_b0;
  }
  SymSetSearchPath(_DAT_180c96218,puVar13);
  lVar7 = plVar6[0xb];
  if (lVar7 == 0) {
    lVar7 = LoadLibraryA(&UNK_180a3c428);
    plVar6[0xb] = lVar7;
    if (lVar7 != 0) goto LAB_180044ee3;
    puStack_b8 = &SystemGlobalDataReference;
    if (puStack_b0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  else {
LAB_180044ee3:
    if (plVar6[0xc] == 0) {
      lVar7 = GetProcAddress(lVar7,&UNK_180a3c410);
      plVar6[0xc] = lVar7;
      if (lVar7 == 0) {
        puStack_b8 = &SystemGlobalDataReference;
        if (puStack_b0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        goto LAB_180044f8f;
      }
    }
    puVar13 = &SystemStringTemplate;
    if (puStack_b0 != (undefined *)0x0) {
      puVar13 = puStack_b0;
    }
    iVar2 = SymInitialize(_DAT_180c96218,puVar13,1);
    if (iVar2 == 0) {
      puStack_b8 = &SystemGlobalDataReference;
      if (puStack_b0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
    }
    else {
      *(char *)plVar6 = '\x01';
      puStack_b8 = &SystemGlobalDataReference;
      if (puStack_b0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
    }
  }
LAB_180044f8f:
  uStack_a0 = 0;
  puStack_b0 = (undefined *)0x0;
  puStack_b8 = &SystemMemoryAllocatorReference;
  iVar2 = _Mtx_unlock(pplVar1);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
LAB_180044faf:
  puVar8 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,8,8,3);
  *puVar8 = 0;
  puVar9 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,8,8,3);
  *puVar8 = &UNK_18098bb60;
  *puVar9 = &UNK_18098bb88;
  puVar10 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x20,8,3);
  puVar11 = (uint8_t *)FUN_18062b1e0(_DAT_180c8ed18,1,1,3);
  *puVar11 = 0;
  puVar10[2] = puVar11;
  _DAT_180c8ed08 = puVar10;
  *puVar10 = puVar9;
  puVar10[1] = puVar8;
  puVar10[3] = uVar5;
  uVar5 = FUN_18062b1e0(_DAT_180c8ed18,0x198,8,3);
  _DAT_180c8ed68 = CreateSystemTimer(uVar5);
  uVar5 = FUN_18062b1e0(_DAT_180c8ed18,0xa8,8,3);
  _DAT_180c8ed00 = CreateSystemCounter(uVar5);
  FUN_18062b1e0(_DAT_180c8ed18,1,1,3);
  iVar2 = QueryPerformanceFrequency(&pplStackX_18);
  if (iVar2 == 0) {
    InitializeSystemSemaphores(&UNK_180a3c090);
  }
  _DAT_180c8ed50 = 1.0 / (double)(long long)pplStackX_18;
  timeBeginPeriod(1);
  QueryPerformanceCounter(&lStackX_20);
  if (DAT_180bf0102 != '\0') {
    _DAT_180c8ed48 = _DAT_180c8ed48 + (lStackX_20 - _DAT_180c8ed58);
  }
  _DAT_180c8ed58 = 0;
  _DAT_180c8ed40 = lStackX_20;

/**
 * 初始化线程管理器
 * 初始化线程管理器并设置线程相关信息
 * 此函数不会返回
 */
void InitializeThreadManager(void)

{
  void* currentThread;
  uint32_t threadResult;
  void* *threadManager;
  void* registerR9;
  undefined *errorPtr;
  void* *tempStack60;
  uint32_t stack58;
  void* stack50;
  
  errorPtr = &SystemGlobalDataReference;
  stack50 = 0;
  tempStack60 = (void* *)0x0;
  stack58 = 0;
  threadManager = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13,registerR9,0xfffffffffffffffe);
  *(uint8_t *)threadManager = 0;
  tempStack60 = threadManager;
  threadResult = StartSystemThread(threadManager);
  stack50 = CONCAT44(stack50._4_4_,threadResult);
  *threadManager = 0x72657472617453;
  stack58 = 7;
  currentThread = GetCurrentThread();
  InitializeSystemThreadContext(currentThread,&errorPtr);
  errorPtr = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(threadManager);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * 最终系统初始化函数
 * 执行最终的系统初始化，等待系统就绪，清理系统资源
 * 
 * @return 初始化结果
 */
uint32_t FinalSystemInitialization(void)

{
  void* *systemPtr;
  code *systemCallback;
  long long **systemController;
  uint32_t initResult;
  int waitResult;
  long long ****systemManager;
  void* allocationFlags;
  long long ****tempManager8;
  long long ***tempManager9;
  long long systemObject;
  char isActiveFlag;
  long long ****stackManager8;
  long long ***stackManager10;
  long long **stackController18;
  long long ***stackManager20;
  void* systemFlags;
  long long *****systemSuperManager;
  long long ****tempManager14;
  
  systemFlags = 0xfffffffffffffffe;
  if (_DAT_180c91048 != (void* *)0x0) {
    while( true ) {
      if ((undefined *)*_DAT_180c91048 == &UNK_1809fe100) {
        isActiveFlag = *(char *)(_DAT_180c91048 + 2) != '\0';
      }
      else {
        isActiveFlag = (**(code **)((undefined *)*_DAT_180c91048 + 0x68))();
      }
      if (isActiveFlag != '\0') break;
      Sleep(1);
    }
  }
  systemManager = (long long ****)FUN_18062b1e0(_DAT_180c8ed18,0xc0,8,3,systemFlags);
  stackManager8 = systemManager;
  FUN_180049830(systemManager);
  *systemManager = (long long ***)&UNK_1809ff2f8;
  stackManager20 = (long long ***)systemManager;
  (*(code *)(*systemManager)[5])(systemManager);
  systemObject = _DAT_180c82868;
  systemSuperManager = &stackManager8;
  stackManager8 = systemManager;
  (*(code *)(*systemManager)[5])(systemManager);
  FUN_18005e300(systemObject,&stackManager8);
  while( true ) {
    if (*systemManager == (long long ***)&UNK_1809ff2f8) {
      isActiveFlag = *(char *)(systemManager + 2) != '\0';
    }
    else {
      isActiveFlag = (*(code *)(*systemManager)[0xd])(systemManager);
    }
    if (isActiveFlag != '\0') break;
    Sleep(1);
  }
  FUN_1800623e0();
  systemObject = _DAT_180c86928;
  allocationFlags = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
  tempManager8 = (long long ****)FUN_1800636f0(allocationFlags,2,systemObject);
  tempManager14 = tempManager8;
  if (tempManager8 != (long long ****)0x0) {
    (*(code *)(*tempManager8)[5])(tempManager8);
  }
  systemPtr = *(void* **)(systemObject + 400);
  systemCallback = *(code **)*systemPtr;
  stackManager8 = &stackManager10;
  stackManager10 = (long long ***)tempManager8;
  if (tempManager8 != (long long ****)0x0) {
    (*(code *)(*tempManager8)[5])(tempManager8);
  }
  (*systemCallback)(systemPtr,&stackManager10);
  systemFlags = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3,systemFlags,systemSuperManager,tempManager14);
  tempManager9 = (long long ***)FUN_1800636f0(systemFlags,0,systemObject);
  if (tempManager9 != (long long ***)0x0) {
    (*(code *)(*tempManager9)[5])(tempManager9);
  }
  systemPtr = *(void* **)(systemObject + 400);
  systemCallback = *(code **)*systemPtr;
  stackManager8 = (long long ****)&stackController18;
  stackController18 = (long long **)tempManager9;
  if (tempManager9 != (long long ***)0x0) {
    (*(code *)(*tempManager9)[5])(tempManager9);
  }
  (*systemCallback)(systemPtr,&stackController18);
  FUN_18020f150(*(void* *)(systemObject + 400));
  if (tempManager9 != (long long ***)0x0) {
    (*(code *)(*tempManager9)[7])(tempManager9);
  }
  if (tempManager8 != (long long ****)0x0) {
    (*(code *)(*tempManager8)[7])(tempManager8);
  }
  tempManager14 = _DAT_180c86940;
  *(uint8_t *)(_DAT_180c86940[1] + 0x80) = 1;
  while( true ) {
    systemController = *tempManager14[1];
    if (systemController == (long long **)&UNK_1809ff3f8) {
      isActiveFlag = *(char *)(tempManager14[1] + 2) != '\0';
    }
    else {
      isActiveFlag = (*(code *)systemController[0xd])();
    }
    tempManager8 = _DAT_180c86940;
    if (isActiveFlag != '\0') break;
    Sleep(1);
  }
  stackManager8 = _DAT_180c86940;
  if (_DAT_180c86940 != (long long ****)0x0) {
    lVar10 = __RTCastToVoid(_DAT_180c86940);
    *pppplVar8 = (long long ***)&UNK_1809fee70;
    PostQueuedCompletionStatus(pppplVar8[0x42686],0,0xffffffffffffffff);
    CloseHandle(pppplVar8[0x42686]);
    ppplStackX_10 = (long long ***)(pppplVar8 + 0x42687);
    if ((long long ***)*ppplStackX_10 != (long long ***)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    ppplStackX_10 = (long long ***)(pppplVar8 + 0x4267c);
    _Mtx_destroy_in_situ();
    ppplStackX_10 = (long long ***)(pppplVar8 + 0x40070);
    _Mtx_destroy_in_situ();
    FUN_18006bfe0(pppplVar8);
    if (lVar10 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar10);
    }
  }
  pppplVar14 = _DAT_180c86948;
  lVar10 = _DAT_180c82868;
  _DAT_180c86940 = (long long ****)0x0;
  if (_DAT_180c82868 != 0) {
    FUN_18005d790(_DAT_180c82868);
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar10);
  }
  _DAT_180c82868 = 0;
  *(uint32_t *)(_DAT_180c86948 + 0x2d) = 2;
  pppplStackX_8 = pppplVar14;
  if (pppplVar14 == (long long ****)0x0) {
    _DAT_180c86948 = (long long ****)0x0;
    WaitForSingleObject(SystemSemaphoreHandle,0xffffffff);
    do {
      iVar5 = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (iVar5 == 0);
    uVar12 = __acrt_iob_func(1);
    fflush(uVar12);
    uVar12 = __acrt_iob_func(2);
    fflush(uVar12);
    uVar4 = _DAT_180c82854;
    (*(code *)(*pppplVar6)[7])(pppplVar6);
    return uVar4;
  }
  FUN_18006ef20(pppplVar14 + 0x1e);
  FUN_18006ef20(pppplVar14 + 0xf);
  FUN_18006ef20(pppplVar14);
                    // WARNING: Subroutine does not return
  FUN_18064e900(pppplVar14);
}



void WotsMain(void* param_1)

{
  void* auStackX_18 [2];
  
                    // 0x45a00  27  WotsMain

// 函数: void FUN_180045af0(long long *param_1)
/**
 * @brief 执行系统回调函数
 * 
 * 该函数负责执行系统的回调函数，检查参数指针是否有效，然后调用相应的回调函数。
 * 
 * @param param_1 指向回调函数参数的指针
 * @note 这是系统回调机制的重要组成部分，确保回调函数的正确执行
 */
void ExecuteSystemCallback(long long *param_1)

{
  if ((long long *)*param_1 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_1 + 0x38))();
  }
  return;
}




// 函数: void FUN_180045b20(long long param_1,long long param_2)
/**
 * @brief 处理系统字符串复制
 * 
 * 该函数负责处理系统字符串的复制操作，检查源字符串长度，执行字符串复制，
 * 并设置相应的长度标志。
 * 
 * @param param_1 目标缓冲区指针
 * @param param_2 源字符串指针
 * @note 这是系统字符串处理的重要组成部分，确保字符串复制的安全性
 */
void ProcessSystemStringCopy(long long param_1,long long param_2)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x1000) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x000180045b59. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x1000);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x1000,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




// 函数: void FUN_180045ba0(long long param_1,void* param_2,int param_3)
/**
 * @brief 处理系统内存复制
 * 
 * 该函数负责处理系统内存的复制操作，检查复制长度是否安全，执行内存复制，
 * 并设置相应的结束标志。
 * 
 * @param param_1 目标缓冲区指针
 * @param param_2 源数据指针
 * @param param_3 要复制的字节数
 * @note 这是系统内存处理的重要组成部分，确保内存复制的安全性
 */
void ProcessSystemMemoryCopy(long long param_1,void* param_2,int param_3)

{
  if (param_3 + 1 < 0x1000) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




// 函数: void FUN_180045bc1(void)
/**
 * @brief 系统内存拷贝操作
 * 
 * 该函数执行系统内存拷贝操作，用于在系统初始化过程中复制内存数据。
 * 
 * @note 这是一个低级别的系统操作函数
 */
void ExecuteSystemMemoryCopyOperation(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




/**
 * @brief 重置系统缓冲区
 * 
 * 该函数负责重置系统缓冲区，将缓冲区内容清零，
 * 并重置相关的偏移量计数器。
 * 
 * @param bufferPointer 指向需要重置的缓冲区的指针
 * @note 这是一个辅助函数，用于清理和重置系统缓冲区状态
 */
void ResetSystemBuffer(uint8_t *bufferPointer)

{
  long long bufferOffset;
  
  *bufferPointer = 0;
  *(uint32_t *)(bufferOffset + 0x10) = 0;
  return;
}




/**
 * @brief 系统初始化完成处理函数
 * 
 * 该函数在系统初始化完成后执行，调用系统的完成处理函数。
 * 
 * @note 这是一个系统完成处理函数，通常在初始化过程结束时调用
 */
void FinalizeSystemInitialization(void)

{
                    // WARNING: Subroutine does not return
  FUN_1808fd200();
}



/**
 * @brief 初始化系统指针池
 * 
 * 该函数负责初始化系统指针池，设置默认的指针地址，
 * 并根据清理标志决定是否释放相关内存资源
 * 
 * @param systemPointerPool 系统指针池指针
 * @param initializationFlags 初始化标志，用于控制内存清理行为
 * @param reservedParam3 保留参数3
 * @param reservedParam4 保留参数4
 * @return 返回系统指针池指针
 */
void* *
InitializeSystemPointerPool(void* *systemPointerPool,ulong long initializationFlags,void* reservedParam3,void* reservedParam4)

{
  *systemPointerPool = &SystemMemoryAllocatorReference;
  if ((initializationFlags & 1) != 0) {
    free(systemPointerPool,0x1018,reservedParam3,reservedParam4,0xfffffffffffffffe);
  }
  return systemPointerPool;
}



/**
 * @brief 清理系统完成端口资源
 * 
 * 该函数负责清理系统的完成端口资源，关闭句柄，销毁互斥体，
 * 并根据标志释放相关内存。这是系统资源清理的重要组成部分。
 * 
 * @param systemResourcePointer 系统资源指针
 * @param cleanupFlags 清理标志，用于控制是否释放内存
 * @return 返回清理后的系统资源指针
 */
void* CleanupSystemCompletionPortResources(void* systemResourcePointer, uint32_t cleanupFlags)

{
  *systemResourcePointer = &SystemCompletionPortTemplate;
  PostQueuedCompletionStatus(systemResourcePointer[0x42686],0,0xffffffffffffffff,0,0xfffffffffffffffe);
  CloseHandle(systemResourcePointer[0x42686]);
  if (systemResourcePointer[0x42687] != 0) {
                    // WARNING: Subroutine does not return
    TerminateSystemProcess();
  }
  _Mtx_destroy_in_situ();
  _Mtx_destroy_in_situ();
  CleanupSystemResourceData(systemResourcePointer);
  if ((cleanupFlags & 1) != 0) {
    free(systemResourcePointer,0x213458);
  }
  return systemResourcePointer;
}



void _guard_check_icall(void)

{
  return;
}



void* *
FUN_180045ea0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x418,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180045ee0(long long param_1,long long param_2)
/**
 * @brief 系统字符串复制处理器
 * 
 * 该函数处理系统字符串复制操作，包括长度验证和安全复制。
 * 当源字符串长度小于0x400时，直接复制；否则调用安全处理函数。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceString 源字符串指针
 */
void ProcessSystemStringCopy(long long targetBuffer,long long sourceString)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x400) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x000180045f19. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x400);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x400,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




// 函数: void FUN_180045f60(long long param_1,void* param_2,int param_3)
/**
 * @brief 系统内存复制处理器
 * 
 * 该函数处理系统内存复制操作，包括边界检查和安全复制。
 * 当复制长度小于0x400时，执行内存复制操作。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 */
void ProcessSystemMemoryCopy(long long targetBuffer,void* sourceData,int copyLength)

{
  if (param_3 + 1 < 0x400) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




// 函数: void FUN_180045f81(void)
/**
 * @brief 执行系统内存复制操作
 * 
 * 该函数执行系统内存复制操作，是一个内存复制的辅助函数。
 */
void ExecuteSystemMemoryCopyOperation(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




// 函数: void FUN_180045fa6(uint8_t *param_1)
/**
 * @brief 重置系统缓冲区
 * 
 * 该函数重置系统缓冲区，将缓冲区内容清零并重置相关计数器。
 * 
 * @param bufferPointer 缓冲区指针
 */
void ResetSystemBuffer(uint8_t *bufferPointer)

{
  long long unaff_RDI;
  
  *param_1 = 0;
  *(uint32_t *)(unaff_RDI + 0x10) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180045fc0(long long param_1,long long param_2,long long param_3)
/**
 * @brief 处理系统三参数缓冲区操作
 * 
 * 该函数负责处理需要三个参数的系统缓冲区操作，包括内存分配、
 * 数据复制和缓冲区管理。它使用栈缓冲区来处理临时数据，
 * 并执行相应的系统操作。
 * 
 * @param param_1 主操作参数
 * @param param_2 辅助操作参数
 * @param param_3 配置参数
 * 
 * @note 这是一个通用的系统缓冲区处理函数
 */
void ProcessSystemThreeParameterBuffer(long long param_1,long long param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  uint8_t auStack_498 [32];
  void* uStack_478;
  undefined *puStack_468;
  uint8_t *puStack_460;
  uint32_t uStack_458;
  uint8_t auStack_450 [1032];
  ulong long uStack_48;
  
  uStack_478 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_498;
  puStack_468 = &UNK_18098bb30;
  puStack_460 = auStack_450;
  uStack_458 = 0;
  auStack_450[0] = 0;
  lVar1 = strstr(*(void* *)(param_1 + 8));
  if (lVar1 != 0) {
    lVar2 = -1;
    lVar3 = -1;
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    do {
      lVar2 = lVar2 + 1;
    } while (*(char *)(lVar2 + param_3) != '\0');
                    // WARNING: Subroutine does not return
    memcpy(puStack_460,*(long long *)(param_1 + 8),lVar1 - *(long long *)(param_1 + 8));
  }
  puStack_468 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_498);
}




// 函数: void FUN_180046130(void* *param_1,uint32_t param_2)
/**
 * @brief 释放系统信号量
 * 
 * 该函数负责释放系统信号量，它会重复调用ReleaseSemaphore函数
 * 直到成功释放为止。这确保了信号量的正确释放和系统同步。
 * 
 * @param param_1 信号量句柄指针
 * @param param_2 释放计数
 * 
 * @note 这是系统同步机制的重要组成部分，确保信号量的正确释放
 */
void ReleaseSystemSemaphore(void* *param_1,uint32_t param_2)

{
  int iVar1;
  
  do {
    iVar1 = ReleaseSemaphore(*param_1,param_2,0);
  } while (iVar1 == 0);
  return;
}




// 函数: void FUN_180046160(void* *param_1)
/**
 * @brief 解锁系统互斥锁
 * 
 * 该函数负责解锁系统互斥锁，它会检查互斥锁的状态，
 * 然后调用_Mtx_unlock函数进行解锁操作。如果解锁失败，
 * 会抛出相应的错误。
 * 
 * @param param_1 互斥锁指针
 * 
 * @note 这是系统线程同步的重要组成部分，确保互斥锁的正确解锁
 */
void UnlockSystemMutex(void* *param_1)

{
  int iVar1;
  
  if (*(char *)(param_1 + 1) != '\0') {
    iVar1 = _Mtx_unlock(*param_1);
    if (iVar1 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar1);
    }
  }
  return;
}



/**
 * @brief 等待系统节点就绪
 * 
 * 该函数负责等待系统节点就绪状态，使用互斥锁和条件变量来同步
 * 系统节点的状态变化。这是系统初始化过程中的同步机制。
 * 
 * @param systemNodePointer 系统节点指针
 * @param timeoutParameter 超时参数
 * @param conditionVariable 条件变量
 * @param syncFlag 同步标志
 * @return 成功返回1，失败返回错误代码
 */
uint64_t WaitForSystemNodeReady(long long systemNodePointer, uint64_t timeoutParameter, uint64_t conditionVariable, uint64_t syncFlag)

{
  bool systemNodeReady;
  int mutexLockResult;
  long long mutexHandle;
  uint64_t waitTimeout;
  bool waitFlag;
  
  waitTimeout = 0xfffffffffffffffe;
  mutexHandle = systemNodePointer + 0x48;
  mutexLockResult = _Mtx_lock();
  if (mutexLockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexLockResult);
  }
  waitFlag = true;
  if (*(char *)(systemNodePointer + 0x98) != '\x01') {
    char nodeStatus = *(char *)(systemNodePointer + 0x98);
    while (systemNodeReady == false) {
      mutexLockResult = _Cnd_wait(systemNodePointer,mutexHandle,conditionVariable,syncFlag,waitTimeout,mutexHandle,waitFlag);
      if (mutexLockResult != 0) {
        __Throw_C_error_std__YAXH_Z(mutexLockResult);
      }
      nodeStatus = *(char *)(systemNodePointer + 0x98);
    }
  }
  *(char *)(systemNodePointer + 0x98) = 0;
  mutexLockResult = _Mtx_unlock(mutexHandle);
  if (mutexLockResult != 0) {
    __Throw_C_error_std__YAXH_Z(mutexLockResult);
  }
  return 1;
}



/**
 * @brief 处理系统节点配置
 * 
 * 该函数负责处理系统节点的配置信息，包括节点回调、参数验证
 * 和配置更新。这是系统配置管理的重要组成部分。
 * 
 * @param nodeConfigPointer 节点配置指针
 * @param parameterBuffer 参数缓冲区
 * @return 返回处理结果状态码
 */
long long ProcessSystemNodeConfiguration(uint32_t* nodeConfigPointer, uint32_t* parameterBuffer)

{
  uint32_t configValue;
  char callbackResult;
  void* errorStringPointer;
  
  if (*(long long *)(nodeConfigPointer + 0x18) != 0) {
    callbackResult = (**(code **)(nodeConfigPointer + 0x1a))(parameterBuffer,nodeConfigPointer + 0x14);
    if (callbackResult == '\0') {
      if (SystemDebugModeEnabled == '\0') {
        errorStringPointer = &SystemErrorMessageTemplate;
        if (*(void **)(nodeConfigPointer + 4) != (void *)0x0) {
          errorStringPointer = *(void **)(nodeConfigPointer + 4);
        }
        LogSystemErrorMessage(&SystemErrorLogBuffer,errorStringPointer);
      }
      *nodeConfigPointer = nodeConfigPointer[0x12];
      return (ulong long)(uint3)((uint)nodeConfigPointer[0x12] >> 8) << 8;
    }
  }
  configValue = *parameterBuffer;
  *nodeConfigPointer = configValue;
  return CONCAT71((uint7)(uint3)((uint)configValue >> 8),1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 更新系统配置参数
 * 
 * 该函数负责更新系统的配置参数，执行配置验证回调，
 * 并根据验证结果决定是否应用配置更改。这是系统配置管理的核心功能。
 * 
 * @param configHandle 配置句柄
 * @param configValue 配置值
 */
void UpdateSystemConfigurationParameter(uint64_t configHandle, uint32_t configValue)

{
  long long systemConfigBase;
  char validationResult;
  void* errorMessagePointer;
  uint32_t parameterStack [6];
  
  systemConfigBase = SystemConfigurationDataBase;
  if ((*(long long *)(SystemConfigurationDataBase + 0x22f0) != 0) &&
     (parameterStack[0] = configValue, validationResult = (**(code **)(SystemConfigurationDataBase + 0x22f8))(parameterStack),
     configValue = parameterStack[0], validationResult == '\0')) {
    if (SystemDebugModeEnabled == '\0') {
      errorMessagePointer = &SystemErrorMessageTemplate;
      if (*(void **)(systemConfigBase + 0x22a0) != (void *)0x0) {
        errorMessagePointer = *(void **)(systemConfigBase + 0x22a0);
      }
      LogSystemErrorMessage(&SystemErrorLogBuffer,errorMessagePointer);
    }
    *(uint32_t *)(systemConfigBase + 0x2290) = *(uint32_t *)(systemConfigBase + 0x22d8);
    return;
  }
  *(uint32_t *)(systemConfigBase + 0x2290) = configValue;
  return;
}



/**
 * @brief 释放系统内存资源
 * 
 * 该函数负责释放系统的内存资源，设置资源模板，并根据标志位
 * 决定是否执行内存释放操作。这是系统内存管理的重要组成部分。
 * 
 * @param resourcePointer 资源指针
 * @param freeFlags 释放标志，用于控制是否释放内存
 * @param freeParameter1 释放参数1
 * @param freeParameter2 释放参数2
 * @return 返回处理后的资源指针
 */
void*
FreeSystemMemoryResource(void* resourcePointer, uint64_t freeFlags, uint64_t freeParameter1, uint64_t freeParameter2)

{
  *resourcePointer = &SystemMemoryResourceTemplate;
  if ((freeFlags & 1) != 0) {
    free(resourcePointer,0x38,freeParameter1,freeParameter2,0xfffffffffffffffe);
  }
  return resourcePointer;
}




/**
 * @brief 系统字符串复制函数（带长度限制）
 * 
 * 该函数用于将字符串从源地址复制到目标地址，有长度限制。
 * 如果源字符串为空，则清空目标字符串；如果字符串长度超过限制，
 * 则调用系统错误处理函数。
 * 
 * @param param_1 目标字符串结构体指针
 * @param param_2 源字符串指针
 * @note 最大字符串长度限制为0x20字节
 */
void ProcessSystemStringCopyWithLimit(long long param_1,long long param_2)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x20) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x0001800463b7. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x20);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x20,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




// 函数: void FUN_180046400(long long param_1,void* param_2,int param_3)
/**
 * @brief 系统内存复制操作（带长度限制）
 * 
 * 该函数执行系统内存复制操作，限制最大复制长度为0x20字节。
 * 
 * @param targetBuffer 目标缓冲区指针
 * @param sourceData 源数据指针
 * @param copyLength 复制长度
 */
void ExecuteSystemMemoryCopyWithLimit(long long targetBuffer,void* sourceData,int copyLength)

{
  if (param_3 + 1 < 0x20) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




/**
 * @brief 系统内存复制操作
 * 
 * 该函数执行系统内存复制操作，用于初始化过程中的数据复制。
 * 
 * @note 这是一个低级别的系统操作函数
 */
void ExecuteSystemMemoryCopy(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




/**
 * @brief 重置系统数据缓冲区
 * 
 * 该函数负责重置系统数据缓冲区，将缓冲区内容清零，
 * 并重置相关的偏移量计数器。
 * 
 * @param dataBufferPointer 指向需要重置的数据缓冲区的指针
 */
void ResetSystemDataBuffer(uint8_t *dataBufferPointer)

{
  long long bufferOffset;
  
  *dataBufferPointer = 0;
  *(uint32_t *)(bufferOffset + 0x10) = 0;
  return;
}



/**
 * @brief 初始化系统内存分配器引用
 * 
 * 该函数负责初始化系统内存分配器的引用，设置内存分配器的
 * 基础结构和相关参数。这是内存管理系统的重要组成部分。
 * 
 * @param memoryAllocatorPointer 内存分配器指针的指针
 * @return 返回初始化后的内存分配器指针
 */
void* * InitializeSystemMemoryAllocatorReference(void* *memoryAllocatorPointer)

{
  *memoryAllocatorPointer = &SystemMemoryAllocatorReference;
  memoryAllocatorPointer[1] = 0;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *memoryAllocatorPointer = &UNK_18098bc80;
  memoryAllocatorPointer[1] = memoryAllocatorPointer + 3;
  *(uint32_t *)(memoryAllocatorPointer + 2) = 0;
  *(uint8_t *)(memoryAllocatorPointer + 3) = 0;
  return memoryAllocatorPointer;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800464f0(long long param_1,long long param_2,long long param_3)
/**
 * @brief 系统三参数数据处理函数
 * 
 * 该函数处理需要三个参数的系统数据操作，包括内存分配、
 * 数据处理和缓冲区管理。
 * 
 * @param param1 第一个参数
 * @param param2 第二个参数
 * @param param3 第三个参数
 */
void ProcessSystemThreeParameterData(long long param1,long long param2,long long param3)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  uint8_t auStack_a8 [32];
  void* uStack_88;
  undefined *puStack_80;
  uint8_t *puStack_78;
  uint32_t uStack_70;
  uint8_t auStack_68 [32];
  ulong long uStack_48;
  
  uStack_88 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_a8;
  puStack_80 = &UNK_18098bc80;
  puStack_78 = auStack_68;
  uStack_70 = 0;
  auStack_68[0] = 0;
  lVar1 = strstr(*(void* *)(param_1 + 8));
  if (lVar1 != 0) {
    lVar2 = -1;
    lVar3 = -1;
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    do {
      lVar2 = lVar2 + 1;
    } while (*(char *)(lVar2 + param_3) != '\0');
                    // WARNING: Subroutine does not return
    memcpy(puStack_78,*(long long *)(param_1 + 8),lVar1 - *(long long *)(param_1 + 8));
  }
  puStack_80 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_a8);
}



void* * GetSystemMemoryAllocatorReference(void* *param_1,ulong long param_2)

{
  *param_1 = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x18);
  }
  return param_1;
}




// 函数: void UnlockSystemMutex(void* *param_1)
void UnlockSystemMutex(void* *param_1)

{
  int iVar1;
  
  iVar1 = _Mtx_unlock(*param_1);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}




// 函数: void LockSystemMutexAndBroadcast(long long param_1)
void LockSystemMutexAndBroadcast(long long param_1)

{
  int iVar1;
  
  iVar1 = _Mtx_lock(param_1 + 0x48);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  *(uint8_t *)(param_1 + 0x98) = 1;
  iVar1 = _Cnd_broadcast(param_1);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  iVar1 = _Mtx_unlock(param_1 + 0x48);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}




// 函数: void InitializeSystemReferencePointers(void* *param_1)
void InitializeSystemReferencePointers(void* *param_1)

{
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  return;
}



void* *
InitializeSystemReferencePointersWithCleanup(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0x20,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void ProcessSystemMemoryRange(long long *param_1)
void ProcessSystemMemoryRange(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x100) {
    FUN_180046b10(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void InitializeSystemDataPointers(long long *param_1)
void InitializeSystemDataPointers(long long *param_1)

{
  void* *puVar1;
  void** systemDataTable;
  
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 5) {
    *puVar2 = &SystemGlobalDataReference;
    if (puVar2[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar2[1] = 0;
    *(uint32_t *)(puVar2 + 3) = 0;
    *puVar2 = &SystemMemoryAllocatorReference;
  }
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}




/**
 * 内存管理器 - 释放内存块引用
 * 管理内存块的引用计数，当引用计数为0时释放内存
 * 
 * @param param_1 内存块指针的指针
 */
void ReleaseMemoryBlockReference(ulong long *param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = (void* *)*param_1;
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
 * 系统初始化管理器 - 核心初始化函数
 * 负责初始化游戏引擎的核心系统和组件
 * 
 * @param param_1 系统配置参数
 * @param param_2 初始化选项标志
 * @return 初始化结果状态码
 */
int InitializeSystemCoreComponents(long long param_1,long long param_2)

{
  void* ***pppuVar1;
  long long lVar2;
  undefined *puVar3;
  long long lVar4;
  int iVar5;
  long long lVar6;
  long long lVar7;
  ulong long uVar8;
  void* ****ppppuVar9;
  void* ***pppuStackX_8;
  void* *puStack_138;
  long long lStack_130;
  uint32_t uStack_128;
  void* uStack_120;
  void* uStack_118;
  void* uStack_110;
  void* uStack_108;
  void* uStack_100;
  void* uStack_f8;
  void* uStack_f0;
  void* uStack_e8;
  void* uStack_e0;
  void* uStack_d8;
  void* uStack_d0;
  void* uStack_c8;
  void* uStack_c0;
  void* uStack_b8;
  void* uStack_b0;
  void* uStack_a8;
  void* uStack_a0;
  void* uStack_98;
  void* stackParameterC;
  void* uStack_88;
  void* uStack_80;
  void* uStack_78;
  void* uStack_70;
  void* ***pppuStack_68;
  void* ***pppuStack_60;
  void* uStack_58;
  void* uStack_50;
  void* uStack_48;
  uint32_t uStack_40;
  void* uStack_38;
  
  uStack_38 = 0xfffffffffffffffe;
  lVar2 = 0;
  puStack_138 = (void* *)&SystemGlobalDataReference;
  uStack_120 = 0;
  lStack_130 = 0;
  uStack_128 = 0;
  uStack_108 = 0;
  uStack_100 = 0;
  uStack_f8 = 0;
  uStack_f0 = 0;
  uStack_e8 = 0;
  uStack_e0 = 0;
  uStack_d8 = 0;
  uStack_d0 = 0;
  uStack_c8 = 0;
  uStack_40 = 3;
  uStack_58 = 0;
  uStack_50 = 0;
  uStack_48 = 0;
  puVar3 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar3 = *(undefined **)(param_2 + 8);
  }
  pppuStackX_8 = &pppuStack_68;
  pppuStack_68 = &pppuStack_68;
  pppuStack_60 = &pppuStack_68;
  FUN_180627c50(&puStack_138,puVar3);
  uStack_118 = 0;
  uStack_110 = 0;
  uStack_c0 = 0;
  uStack_b8 = 0;
  uStack_b0 = 0;
  uStack_a8 = 0;
  uStack_a0 = 0;
  uStack_98 = 0;
  stackParameterC = 0;
  uStack_88 = 0;
  uStack_80 = 0;
  uStack_78 = 0;
  uStack_70 = 0;
  uVar8 = *(ulong long *)(param_1 + 0x10);
  if (uVar8 < *(ulong long *)(param_1 + 0x18)) {
    *(ulong long *)(param_1 + 0x10) = uVar8 + 0x100;
    FUN_180048a90(uVar8,&puStack_138);
    ppppuVar9 = *(void* *****)(param_1 + 0x10);
    goto LAB_180046a90;
  }
  lVar4 = *(long long *)(param_1 + 8);
  lVar7 = (long long)(uVar8 - lVar4) >> 8;
  if (lVar7 == 0) {
    lVar7 = 1;
LAB_1800469fd:
    lVar2 = CreateSystemThreadObject(_DAT_180c8ed18,lVar7 << 8,*(uint8_t *)(param_1 + 0x20));
    uVar8 = *(ulong long *)(param_1 + 0x10);
    lVar4 = *(long long *)(param_1 + 8);
  }
  else {
    lVar7 = lVar7 * 2;
    if (lVar7 != 0) goto LAB_1800469fd;
  }
  FUN_1800491b0(&pppuStackX_8,lVar4,uVar8,lVar2);
  pppuVar1 = pppuStackX_8;
  FUN_180048a90(pppuStackX_8,&puStack_138);
  ppppuVar9 = (void* ****)(pppuVar1 + 0x20);
  lVar4 = *(long long *)(param_1 + 0x10);
  lVar6 = *(long long *)(param_1 + 8);
  if (lVar6 != lVar4) {
    do {
      FUN_180046b10(lVar6);
      lVar6 = lVar6 + 0x100;
    } while (lVar6 != lVar4);
    lVar6 = *(long long *)(param_1 + 8);
  }
  if (lVar6 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar6);
  }
  *(long long *)(param_1 + 8) = lVar2;
  *(void* *****)(param_1 + 0x10) = ppppuVar9;
  *(long long *)(param_1 + 0x18) = lVar7 * 0x100 + lVar2;
LAB_180046a90:
  iVar5 = (int)((ulong long)((long long)ppppuVar9 - *(long long *)(param_1 + 8)) >> 8) + -1;
  *(int *)(param_1 + 0x68) = iVar5;
  pppuStackX_8 = &pppuStack_68;
  FUN_180049fd0(&pppuStack_68,uStack_58);
  pppuStackX_8 = (void* ***)&puStack_138;
  puStack_138 = (void* *)&SystemGlobalDataReference;
  if (lStack_130 == 0) {
    return iVar5;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void InitializeSystemDataBlock(void* *param_1,void* param_2,void* param_3,void* param_4)
void InitializeSystemDataBlock(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180049fd0(param_1 + 0x1a,param_1[0x1c],param_3,param_4,0xfffffffffffffffe);
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}



ulong long CompareSystemDataBlocks(long long param_1,long long param_2)

{
  byte *pbVar1;
  int iVar2;
  long long lVar3;
  byte *pbVar4;
  int iVar5;
  int iVar6;
  ulong long uVar7;
  long long lVar8;
  uint uVar9;
  ulong long uVar10;
  ulong long uVar11;
  
  uVar10 = (ulong long)*(int *)(param_1 + 0x68);
  lVar3 = *(long long *)(param_1 + 8);
  if (uVar10 < (ulong long)(*(long long *)(param_1 + 0x10) - lVar3 >> 8)) {
    iVar5 = *(int *)(param_2 + 0x10);
    iVar2 = *(int *)(uVar10 * 0x100 + 0x10 + lVar3);
    if (iVar2 == iVar5) {
      if (iVar2 != 0) {
        pbVar4 = *(byte **)(uVar10 * 0x100 + 8 + lVar3);
        lVar8 = *(long long *)(param_2 + 8) - (long long)pbVar4;
        do {
          pbVar1 = pbVar4 + lVar8;
          iVar5 = (uint)*pbVar4 - (uint)*pbVar1;
          if (iVar5 != 0) break;
          pbVar4 = pbVar4 + 1;
        } while (*pbVar1 != 0);
      }
    }
    else if (iVar2 != 0) goto LAB_180046c03;
    if (iVar5 == 0) {
LAB_180046c90:
      return uVar10 & 0xffffffff;
    }
  }
LAB_180046c03:
  uVar10 = 0;
  uVar7 = *(long long *)(param_1 + 0x10) - lVar3 >> 8;
  if (uVar7 != 0) {
    iVar5 = *(int *)(param_2 + 0x10);
    uVar11 = uVar10;
    do {
      iVar2 = *(int *)(uVar11 + 0x10 + lVar3);
      iVar6 = iVar5;
      if (iVar2 == iVar5) {
        if (iVar2 != 0) {
          pbVar4 = *(byte **)(uVar11 + 8 + lVar3);
          lVar8 = *(long long *)(param_2 + 8) - (long long)pbVar4;
          do {
            pbVar1 = pbVar4 + lVar8;
            iVar6 = (uint)*pbVar4 - (uint)*pbVar1;
            if (iVar6 != 0) break;
            pbVar4 = pbVar4 + 1;
          } while (*pbVar1 != 0);
        }
LAB_180046c5e:
        if (iVar6 == 0) {
          *(int *)(param_1 + 0x68) = (int)uVar10;
          goto LAB_180046c90;
        }
      }
      else if (iVar2 == 0) goto LAB_180046c5e;
      uVar9 = (int)uVar10 + 1;
      uVar10 = (ulong long)uVar9;
      uVar11 = uVar11 + 0x100;
    } while ((ulong long)(long long)(int)uVar9 < uVar7);
  }
  return 0xffffffff;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180046ca0(long long *param_1,void* *param_2)
void FUN_180046ca0(long long *param_1,void* *param_2)

{
  long long *plVar1;
  long long *plStackX_8;
  void** systemPreviousNode;
  long long *plStackX_18;
  long long **pplStackX_20;
  uint32_t uVar2;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  uVar2 = 0;
  plStackX_8 = param_1;
  puStackX_10 = param_2;
  FUN_180047fc0();
  plVar1 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,200,8,3,uVar2,uVar3);
  plStackX_8 = plVar1;
  FUN_180049830(plVar1);
  *plVar1 = (long long)&UNK_1809fcb00;
  plVar1[0x18] = (long long)&UNK_180046dd0;
  plStackX_18 = plVar1;
  (**(code **)(*plVar1 + 0x28))(plVar1);
  uVar3 = _DAT_180c82868;
  pplStackX_20 = &plStackX_8;
  plStackX_8 = plVar1;
  (**(code **)(*plVar1 + 0x28))(plVar1);
  FUN_18005e300(uVar3,&plStackX_8);
  (**(code **)(*plVar1 + 0x38))(plVar1);
  _DAT_180bf52b0 = (long long)*(int *)(_DAT_180c86870 + 0x224);
  FUN_180627be0(&DAT_180bf52c0,param_2);
  *param_2 = &SystemGlobalDataReference;
  if (param_2[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[1] = 0;
  *(uint32_t *)(param_2 + 3) = 0;
  *param_2 = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Removing unreachable block (ram,0x0001800472a0)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 初始化系统核心引擎
 * 
 * 该函数负责初始化系统的核心引擎组件，设置系统启动所需的基础结构。
 * 它会配置内存管理器、初始化系统参数、设置核心服务，并建立系统状态监控。
 * 这是系统初始化过程中的核心函数，确保引擎组件正确启动和运行。
 * 
 * @note 这是系统初始化过程中的关键函数，负责整个引擎的初始化工作
 */
void InitializeSystemCoreEngine(void)

{
  void* systemStatusFlag;
  char initializationStatus;
  int memoryCompareResult;
  long long ***systemMemoryManager;
  ulong long systemConfigValue;
  long long systemTimeValue;
  void** systemCurrentNode;
  uint32_t *systemParameterPointer;
  uint8_t *systemDataBuffer;
  uint32_t systemControlFlag;
  float systemPerformanceValue1;
  float systemPerformanceValue2;
  uint8_t systemSecurityBuffer [32];
  long long systemMemoryHandle;
  long long systemResourceHandle;
  int systemInitStatus;
  undefined *systemCallbackPointer;
  uint8_t *systemEventBuffer;
  uint systemEventCounter;
  ulong long systemTimestamp;
  uint32_t systemOperationFlag;
  long long ***systemMemoryPool;
  long long **systemMemoryTable;
  long long ****systemMemoryRoot;
  undefined *systemErrorHandler;
  void* systemContext;
  uint32_t systemPriority;
  void* systemSemaphore;
  undefined *systemLock;
  long long systemThreadId;
  int systemThreadStatus;
  uint32_t systemThreadFlag;
  undefined *systemThreadContext;
  long long systemHeapHandle;
  uint32_t systemHeapSize;
  long long ***systemHeapArray [2];
  undefined *systemHeapManager;
  code *systemEntryPoint;
  void* systemEntryPointParam;
  long long **systemTablePointer;
  undefined *systemTableLock;
  uint8_t *systemTableBuffer;
  uint32_t systemTableFlag;
  uint8_t systemTableData [72];
  undefined *systemCacheManager;
  uint8_t *systemCacheBuffer;
  uint32_t systemCacheFlag;
  uint8_t systemCacheData [72];
  undefined *systemIoManager;
  uint8_t *systemIoBuffer;
  uint32_t systemIoFlag;
  uint8_t systemIoData [72];
  undefined *systemNetworkManager;
  uint8_t *systemNetworkBuffer;
  uint32_t systemNetworkFlag;
  uint8_t systemNetworkData [72];
  undefined *systemRenderManager;
  uint8_t *systemRenderBuffer;
  uint32_t systemRenderFlag;
  uint8_t systemRenderData [72];
  undefined *systemAudioManager;
  uint8_t *systemAudioBuffer;
  uint32_t systemAudioFlag;
  uint8_t systemAudioData [72];
  undefined *systemInputManager;
  uint8_t *systemInputBuffer;
  uint32_t systemInputFlag;
  uint8_t systemInputData [648];
  ulong long systemSecurityHash;
  
  uStack_4f8 = 0xfffffffffffffffe;
  uStack_68 = _DAT_180bf00a8 ^ (ulong long)auStack_698;
  uStack_5b8 = 0;
  if (*(int *)(_DAT_180c86870 + 0x224) - _DAT_180bf52b0 < 0xfb) {
                    // WARNING: Subroutine does not return
    FUN_1808fc050(uStack_68 ^ (ulong long)auStack_698);
  }
  *(uint8_t *)(_DAT_180c86960 + 0x39) = 1;
  ppplVar4 = (long long ***)FUN_18062b1e0(_DAT_180c8ed18,200,8,3);
  ppplStack_590 = ppplVar4;
  FUN_180049830(ppplVar4);
  *ppplVar4 = (long long **)&UNK_1809fcb00;
  ppplVar4[0x18] = (long long **)&UNK_180047d20;
  pplStack_4f0 = (long long **)ppplVar4;
  (*(code *)(*ppplVar4)[5])(ppplVar4);
  uVar1 = _DAT_180c82868;
  uStack_5b8 = 1;
  ppplStack_590 = &pplStack_588;
  pplStack_588 = (long long **)ppplVar4;
  (*(code *)(*ppplVar4)[5])(ppplVar4);
  FUN_18005e300(uVar1,&pplStack_588);
  uStack_5b8 = 0;
  (*(code *)(*ppplVar4)[7])(ppplVar4);
  FUN_180627ae0(&lStack_678,&DAT_180bf52c0);
  if (iStack_668 == 0) {
    (**(code **)(lStack_678 + 0x10))(&lStack_678,&UNK_1809fc7a0);
    cVar2 = FUN_180624a00(&lStack_678);
    if (cVar2 == '\0') {
      FUN_180624910(&lStack_678);
    }
  }
  cVar2 = FUN_180624a00(&lStack_678);
  if (cVar2 == '\0') {
    FUN_180624910(&lStack_678);
  }
  puStack_4e8 = &UNK_1809fcc58;
  puStack_4e0 = auStack_4d0;
  auStack_4d0[0] = 0;
  uStack_4d8 = 0x18;
  strcpy_s(auStack_4d0,0x40,&UNK_1809fc7b8);
  FUN_180097d40(_DAT_180c86960,&puStack_4e8,&lStack_678);
  puStack_4e8 = &SystemMemoryAllocatorReference;
  puStack_488 = &UNK_1809fcc58;
  puStack_480 = auStack_470;
  auStack_470[0] = 0;
  uStack_478 = 0xb;
  strcpy_s(auStack_470,0x40,&UNK_1809fc790);
  FUN_180097d40(_DAT_180c86960,&puStack_488,&lStack_678);
  puStack_488 = &SystemMemoryAllocatorReference;
  puStack_428 = &UNK_1809fcc58;
  puStack_420 = auStack_410;
  auStack_410[0] = 0;
  uStack_418 = 0x18;
  uVar10 = strcpy_s(auStack_410,0x40,&UNK_1809fc7b8);
  _DAT_180bf52b8 = (float)FUN_180095480(uVar10,&puStack_428);
  _DAT_180bf52b8 = 1.0 / _DAT_180bf52b8;
  puStack_428 = &SystemMemoryAllocatorReference;
  puStack_3c8 = &UNK_1809fcc58;
  puStack_3c0 = auStack_3b0;
  auStack_3b0[0] = 0;
  uStack_3b8 = 0xb;
  uVar10 = strcpy_s(auStack_3b0,0x40,&UNK_1809fc790);
  _DAT_180bf52bc = (float)FUN_180095480(uVar10,&puStack_3c8);
  _DAT_180bf52bc = 1.0 / _DAT_180bf52bc;
  puStack_3c8 = &SystemMemoryAllocatorReference;
  puStack_368 = &UNK_1809fcc58;
  puStack_360 = auStack_350;
  auStack_350[0] = 0;
  uStack_358 = 0xb;
  uVar10 = strcpy_s(auStack_350,0x40,&UNK_1809fc790);
  fVar11 = (float)FUN_180095720(uVar10,&puStack_368);
  puStack_368 = &SystemMemoryAllocatorReference;
  puStack_308 = &UNK_1809fcc58;
  puStack_300 = auStack_2f0;
  auStack_2f0[0] = 0;
  uStack_2f8 = 0x18;
  uVar10 = strcpy_s(auStack_2f0,0x40,&UNK_1809fc7b8);
  fVar12 = (float)FUN_180095720(uVar10,&puStack_308);
  puStack_308 = &SystemMemoryAllocatorReference;
  uVar5 = FUN_180623ce0();
  if (0 < SystemConfigDataPointerD) {
    FUN_180629a40(&DAT_180bf52c0,&puStack_558,0,SystemConfigDataPointerD + -1);
    iStack_548 = iStack_548 + -1;
    lVar6 = (long long)iStack_548;
    iVar3 = -1;
    if (-1 < iStack_548) {
      do {
        iVar3 = iStack_548;
        if (*(char *)(lStack_550 + lVar6) == '/') break;
        iStack_548 = iStack_548 + -1;
        lVar6 = lVar6 + -1;
        iVar3 = -1;
      } while (-1 < lVar6);
    }
    FUN_180629a40(&puStack_558,&puStack_538,iVar3 + 1,0xffffffff);
    iVar3 = FUN_180046b80(&DAT_180bf5240,&puStack_538);
    if (iVar3 == -1) {
      iVar3 = FUN_180046890(&DAT_180bf5240,&puStack_538);
    }
    lVar6 = (long long)iVar3 * 0x100;
    ppplStack_590 = (long long ***)(SystemInitializationDataStart + 0x30 + lVar6);
    pppplStack_580 = appplStack_518;
    puStack_508 = &UNK_1800adc10;
    pcStack_500 = FUN_1800adba0;
    appplStack_518[0] = (long long ***)&ppplStack_590;
    FUN_18005c650(appplStack_518);
    *(double *)(lVar6 + 0xa0 + SystemInitializationDataStart) = (double)(1.0 / fVar12);
    *(double *)(lVar6 + 0xb8 + SystemInitializationDataStart) = (double)(1.0 / fVar11);
    *(int *)(lVar6 + 0xb0 + SystemInitializationDataStart) = (int)(long long)_DAT_180bf52b8;
    *(int *)(lVar6 + 200 + SystemInitializationDataStart) = (int)(long long)_DAT_180bf52bc;
    *(double *)(lVar6 + 0x20 + SystemInitializationDataStart) = (double)(uVar5 >> 0x14);
    puStack_538 = &SystemGlobalDataReference;
    if (lStack_530 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_530 = 0;
    uStack_520 = 0;
    puStack_538 = &SystemMemoryAllocatorReference;
    puStack_558 = &SystemGlobalDataReference;
    if (lStack_550 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_550 = 0;
    uStack_540 = 0;
    puStack_558 = &SystemMemoryAllocatorReference;
  }
  puStack_578 = &SystemGlobalDataReference;
  uStack_560 = 0;
  uStack_570 = 0;
  uStack_568 = 0;
  puStack_618 = &SystemGlobalDataReference;
  uStack_600 = 0;
  puStack_610 = (uint8_t *)0x0;
  uStack_608 = 0;
  FUN_1806277c0(&puStack_618,iStack_668);
  if (iStack_668 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(puStack_610,lStack_670,iStack_668 + 1);
  }
  if (lStack_670 != 0) {
    uStack_608 = 0;
    if (puStack_610 != (uint8_t *)0x0) {
      *puStack_610 = 0;
    }
    uStack_600 = uStack_600 & 0xffffffff;
  }
  FUN_18062c1e0(&lStack_678,1);
  iVar3 = uStack_608 + 0x11;
  FUN_1806277c0(&puStack_618,iVar3);
  puVar8 = (uint32_t *)(puStack_610 + uStack_608);
  *puVar8 = 0x69676e65;
  puVar8[1] = 0x635f656e;
  puVar8[2] = 0x69666e6f;
  puVar8[3] = 0x78742e67;
  *(undefined2 *)(puVar8 + 4) = 0x74;
  uStack_608 = iVar3;
  systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x18,8,3);
  puVar9 = &SystemStringTemplate;
  if (puStack_610 != (uint8_t *)0x0) {
    puVar9 = puStack_610;
  }
  *systemPreviousNode = 0;
  *(uint8_t *)(systemPreviousNode + 2) = 0;
  FUN_18062dee0(systemPreviousNode,puVar9,&DAT_1809fc7ec);
  FUN_1800ae730(_DAT_180c86920,systemPreviousNode);
  if (systemPreviousNode[1] != 0) {
    fclose();
    systemPreviousNode[1] = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
    if (systemPreviousNode[1] != 0) {
      fclose();
      systemPreviousNode[1] = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
      UNLOCK();
    }
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(systemPreviousNode);
}



void* *
FUN_180047d40(void* *param_1,void* *param_2,void* param_3,void* param_4)

{
  *param_1 = *param_2;
  *(uint32_t *)(param_1 + 1) = *(uint32_t *)(param_2 + 1);
  FUN_180049b30(param_1 + 2,param_2 + 2,param_3,param_4,0xfffffffffffffffe);
  *(uint32_t *)(param_1 + 0x15) = *(uint32_t *)(param_2 + 0x15);
  *(uint32_t *)((long long)param_1 + 0xac) = *(uint32_t *)((long long)param_2 + 0xac);
  param_1[0x16] = param_2[0x16];
  param_1[0x17] = param_2[0x17];
  param_1[0x18] = param_2[0x18];
  *(uint8_t *)(param_1 + 0x19) = *(uint8_t *)(param_2 + 0x19);
  *(uint8_t *)((long long)param_1 + 0xc9) = *(uint8_t *)((long long)param_2 + 0xc9);
  *(uint8_t *)((long long)param_1 + 0xca) = *(uint8_t *)((long long)param_2 + 0xca);
  *(uint8_t *)((long long)param_1 + 0xcb) = *(uint8_t *)((long long)param_2 + 0xcb);
  *(uint8_t *)((long long)param_1 + 0xcc) = *(uint8_t *)((long long)param_2 + 0xcc);
  return param_1;
}




// 函数: void SetSystemMemoryAllocatorReference(long long param_1)
/**
 * @brief 设置系统内存分配器引用
 * 
 * 该函数负责在指定对象的偏移量0x10处设置系统内存分配器的引用。
 * 这是一个简单的指针设置操作，用于初始化对象的内存分配器引用。
 * 
 * @param systemObject 系统对象指针
 */
void SetSystemMemoryAllocatorReference(long long systemObject)

{
  *(undefined **)(systemObject + 0x10) = &SystemMemoryAllocatorReference;
  return;
}




/**
 * @brief 设置系统内存分配器指针
 * 
 * 该函数负责在指定指针位置设置系统内存分配器的指针。
 * 这是一个简单的指针赋值操作，用于初始化内存分配器指针。
 * 
 * @param allocatorPointer 内存分配器指针的指针
 */
void SetSystemMemoryAllocatorPointer(void* *allocatorPointer)

{
  *allocatorPointer = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 系统数据查找和匹配
 * 
 * 该函数负责在系统初始化数据中查找和匹配指定的数据项。
 * 它会遍历系统数据节点，进行字符串比较和数据匹配，找到合适的
 * 数据项后设置相应的参数和回调函数。
 * 
 * @param searchContext 搜索上下文
 * @param searchData 搜索数据
 * @param matchData 匹配数据
 * @param callbackData 回调数据
 */
void SystemDataSearchAndMatch(void* searchContext,void* searchData,long long matchData,void* callbackData)

{
  byte bVar1;
  bool bVar2;
  int memoryCompareResult;
  void* *puVar4;
  uint uVar5;
  byte *pbVar6;
  void** systemCurrentNode;
  void** systemNextNode;
  void* *puVar9;
  long long lVar10;
  void* uStackX_8;
  
  uStackX_8 = param_1;
  iVar3 = FUN_180046b80(&DAT_180bf5240);
  if (iVar3 == -1) {
    iVar3 = FUN_180046890(&DAT_180bf5240,param_2);
  }
  systemPreviousNode = (void* *)(SystemInitializationDataStart + 0xd0 + (long long)iVar3 * 0x100);
  puVar4 = systemPreviousNode;
  if ((void* *)systemPreviousNode[2] != (void* *)0x0) {
    puVar8 = (void* *)systemPreviousNode[2];
    do {
      if (*(int *)(param_3 + 0x10) == 0) {
        puVar9 = (void* *)puVar8[1];
        bVar2 = false;
      }
      else {
        if (*(int *)(puVar8 + 6) == 0) {
          bVar2 = true;
        }
        else {
          pbVar6 = *(byte **)(param_3 + 8);
          lVar10 = puVar8[5] - (long long)pbVar6;
          do {
            uVar5 = (uint)pbVar6[lVar10];
            iVar3 = *pbVar6 - uVar5;
            if (*pbVar6 != uVar5) break;
            pbVar6 = pbVar6 + 1;
          } while (uVar5 != 0);
          bVar2 = 0 < iVar3;
          if (iVar3 < 1) {
            puVar9 = (void* *)puVar8[1];
            goto LAB_180047f2c;
          }
        }
        puVar9 = (void* *)*puVar8;
      }
LAB_180047f2c:
      if (bVar2) {
        puVar8 = puVar4;
      }
      puVar4 = puVar8;
      puVar8 = puVar9;
    } while (puVar9 != (void* *)0x0);
  }
  if (puVar4 != systemPreviousNode) {
    if (*(int *)(puVar4 + 6) == 0) goto LAB_180047f93;
    if (*(int *)(param_3 + 0x10) != 0) {
      pbVar6 = (byte *)puVar4[5];
      lVar10 = *(long long *)(param_3 + 8) - (long long)pbVar6;
      do {
        bVar1 = *pbVar6;
        uVar5 = (uint)pbVar6[lVar10];
        if (bVar1 != uVar5) break;
        pbVar6 = pbVar6 + 1;
      } while (uVar5 != 0);
      if ((int)(bVar1 - uVar5) < 1) goto LAB_180047f93;
    }
  }
  puVar4 = (void* *)FUN_180048cc0(systemPreviousNode,&uStackX_8);
  puVar4 = (void* *)*puVar4;
LAB_180047f93:
  FUN_180627be0(puVar4 + 8,param_3);
  puVar4[0xc] = param_4;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180047fc0(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_180047fc0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  double dVar1;
  char cVar2;
  double dVar3;
  uint uVar4;
  void* *puVar5;
  long long lVar6;
  long long lVar7;
  uint32_t *puVar8;
  undefined *puVar9;
  ulong long uVar10;
  long long lVar11;
  ulong long uVar12;
  long long lVar13;
  char *pcVar14;
  undefined *puVar15;
  uint uVar16;
  int iVar17;
  undefined *puStack_c8;
  undefined *puStack_c0;
  uint uStack_b8;
  void* uStack_b0;
  undefined *puStack_a8;
  char *pcStack_a0;
  uint32_t uStack_98;
  ulong long stackParameterC;
  undefined *puStack_88;
  char *pcStack_80;
  uint32_t uStack_78;
  ulong long uStack_70;
  
  lVar11 = _DAT_180c86870;
  uVar12 = 0;
  if (DAT_180bf5240 == '\0') {
    return;
  }
  puStack_c8 = &SystemGlobalDataReference;
  uStack_b0 = 0;
  puStack_c0 = (undefined *)0x0;
  uStack_b8 = 0;
  uVar16 = *(uint *)(_DAT_180c86870 + 0x180);
  uVar10 = (ulong long)uVar16;
  if (*(long long *)(_DAT_180c86870 + 0x178) != 0) {
    FUN_1806277c0(&puStack_c8,uVar10,param_3,param_4,1,0xfffffffffffffffe);
  }
  if (uVar16 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(puStack_c0,*(void* *)(lVar11 + 0x178),uVar10);
  }
  if (puStack_c0 != (undefined *)0x0) {
    puStack_c0[uVar10] = 0;
  }
  uStack_b0 = CONCAT44(*(uint32_t *)(lVar11 + 0x18c),(uint32_t)uStack_b0);
  uStack_b8 = uVar16;
  FUN_1806277c0(&puStack_c8,5);
  *(uint32_t *)(puStack_c0 + uStack_b8) = 0x73676f6c;
  *(undefined2 *)((long long)(puStack_c0 + uStack_b8) + 4) = 0x2f;
  uStack_b8 = 5;
  FUN_1806277c0(&puStack_c8,0x18);
  puVar8 = (uint32_t *)(puStack_c0 + uStack_b8);
  *puVar8 = 0x66726570;
  puVar8[1] = 0x616d726f;
  puVar8[2] = 0x5f65636e;
  puVar8[3] = 0x2e676f6c;
  puVar8[4] = 0x747874;
  uStack_b8 = 0x18;
  puVar5 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x18,8,3);
  puVar9 = &SystemStringTemplate;
  if (puStack_c0 != (undefined *)0x0) {
    puVar9 = puStack_c0;
  }
  *puVar5 = 0;
  *(uint8_t *)(puVar5 + 2) = 0;
  FUN_18062dee0(puVar5,puVar9,&DAT_1809fc7ec);
  uVar16 = 0;
  uVar10 = uVar12;
  if (SystemInitializationDataEnd - SystemInitializationDataStart >> 8 != 0) {
    do {
      lVar13 = SystemInitializationDataStart;
      lVar11 = 0;
      puStack_88 = &SystemGlobalDataReference;
      uStack_70 = 0;
      pcStack_80 = (char *)0x0;
      uStack_78 = 0;
      FUN_1806277c0(&puStack_88,*(uint32_t *)(SystemInitializationDataStart + 0x10 + uVar10));
      iVar17 = *(int *)(lVar13 + 0x10 + uVar10);
      if (iVar17 != 0) {
                    // WARNING: Subroutine does not return
        memcpy(pcStack_80,*(void* *)(lVar13 + 8 + uVar10),iVar17 + 1);
      }
      if (*(long long *)(lVar13 + 8 + uVar10) != 0) {
        uStack_78 = 0;
        if (pcStack_80 != (char *)0x0) {
          *pcStack_80 = '\0';
        }
        uStack_70 = uStack_70 & 0xffffffff;
      }
      cVar2 = *pcStack_80;
      while (cVar2 != '\0') {
        lVar6 = strchr(&SystemCharacterReplacementTable,(int)pcStack_80[lVar11]);
        if (lVar6 != 0) {
          pcStack_80[lVar11] = '_';
        }
        lVar11 = lVar11 + 1;
        cVar2 = pcStack_80[lVar11];
      }
      pcVar14 = "";
      if (pcStack_80 != (char *)0x0) {
        pcVar14 = pcStack_80;
      }
      FUN_18062e0f0(puVar5,&UNK_1809fc8e8,pcVar14);
      dVar1 = *(double *)(lVar13 + 0xa0 + uVar10);
      dVar3 = (double)*(uint *)(lVar13 + 0xb0 + uVar10);
      if (dVar3 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fc8f8,dVar3);
      }
      if (dVar1 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fc918,dVar1);
      }
      dVar1 = *(double *)(lVar13 + 0xb8 + uVar10);
      dVar3 = (double)*(uint *)(lVar13 + 200 + uVar10);
      if (dVar3 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fc928,dVar3);
      }
      if (dVar1 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fc940,dVar1);
      }
      dVar1 = *(double *)(lVar13 + 0x20 + uVar10);
      if (dVar1 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fc958,dVar1);
      }
      dVar1 = *(double *)(lVar13 + 0x28 + uVar10);
      if (dVar1 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fc970,dVar1);
      }
      lVar11 = *(long long *)(lVar13 + 0x30 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fc990,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x38 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fc9b0,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x40 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fc9d0,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x48 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fc9f8,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x50 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fca20,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x58 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fca48,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x60 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fca60,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x68 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fca88,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      lVar11 = *(long long *)(lVar13 + 0x70 + uVar10);
      dVar1 = (double)lVar11;
      if (lVar11 < 0) {
        dVar1 = dVar1 + 1.8446744073709552e+19;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTemplate,&UNK_1809fcaa8,
                    (double)(float)(dVar1 * 9.5367431640625e-07));
      dVar1 = *(double *)(lVar13 + 0x78 + uVar10);
      if (dVar1 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fcac8,dVar1);
      }
      dVar1 = *(double *)(lVar13 + 0x80 + uVar10);
      if (dVar1 != 0.0) {
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,&UNK_1809fcad8,dVar1);
      }
      lVar13 = uVar10 + 0xd0 + lVar13;
      lVar11 = *(long long *)(lVar13 + 8);
      uVar4 = (uint)uVar12;
      while (lVar11 != lVar13) {
        lVar6 = 0;
        puStack_a8 = &SystemGlobalDataReference;
        stackParameterC = 0;
        pcStack_a0 = (char *)0x0;
        uStack_98 = 0;
        FUN_1806277c0(&puStack_a8,*(uint32_t *)(lVar11 + 0x50));
        if (*(int *)(lVar11 + 0x50) != 0) {
                    // WARNING: Subroutine does not return
          memcpy(pcStack_a0,*(void* *)(lVar11 + 0x48),*(int *)(lVar11 + 0x50) + 1);
        }
        if (*(long long *)(lVar11 + 0x48) != 0) {
          uStack_98 = 0;
          if (pcStack_a0 != (char *)0x0) {
            *pcStack_a0 = '\0';
          }
          stackParameterC = stackParameterC & 0xffffffff;
        }
        cVar2 = *pcStack_a0;
        while (cVar2 != '\0') {
          lVar7 = strchr(&SystemCharacterReplacementTable,(int)pcStack_a0[lVar6]);
          if (lVar7 != 0) {
            pcStack_a0[lVar6] = '_';
          }
          lVar6 = lVar6 + 1;
          cVar2 = pcStack_a0[lVar6];
        }
        pcVar14 = "";
        if (pcStack_a0 != (char *)0x0) {
          pcVar14 = pcStack_a0;
        }
        FUN_18062e0f0(puVar5,&SystemPropertyTemplate,pcVar14,*(void* *)(lVar11 + 0x60));
        puStack_a8 = &SystemGlobalDataReference;
        if (pcStack_a0 != (char *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        pcStack_a0 = (char *)0x0;
        stackParameterC = stackParameterC & 0xffffffff00000000;
        puStack_a8 = &SystemMemoryAllocatorReference;
        lVar11 = func_0x00018066bd70(lVar11);
        uVar4 = uVar16;
      }
      FUN_18062e0f0(puVar5,&SystemConfigurationTerminator);
      puStack_88 = &SystemGlobalDataReference;
      if (pcStack_80 != (char *)0x0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      pcStack_80 = (char *)0x0;
      uStack_70 = uStack_70 & 0xffffffff00000000;
      puStack_88 = &SystemMemoryAllocatorReference;
      uVar16 = uVar4 + 1;
      uVar12 = (ulong long)uVar16;
      uVar10 = uVar10 + 0x100;
    } while ((ulong long)(long long)(int)uVar16 < (ulong long)(SystemInitializationDataEnd - SystemInitializationDataStart >> 8));
  }
  iVar17 = 0;
  FUN_18062e0f0(puVar5,&SystemConfigurationTerminatorPointer);
  if ((SystemInitializationStatusB - SystemInitializationStatusA) / 0x28 != 0) {
    lVar11 = 0;
    do {
      lVar6 = SystemInitializationStatusA;
      lVar13 = 0;
      pcVar14 = *(char **)(SystemInitializationStatusA + 8 + lVar11);
      cVar2 = *pcVar14;
      while (cVar2 != '\0') {
        lVar7 = strchr(&SystemCharacterReplacementTable,(int)pcVar14[lVar13]);
        if (lVar7 != 0) {
          *(uint8_t *)(lVar13 + *(long long *)(lVar6 + 8 + lVar11)) = 0x5f;
        }
        lVar13 = lVar13 + 1;
        pcVar14 = *(char **)(lVar6 + 8 + lVar11);
        cVar2 = pcVar14[lVar13];
      }
      puVar9 = *(undefined **)(SystemInitializationStatusA + 8 + lVar11);
      puVar15 = &SystemStringTemplate;
      if (puVar9 != (undefined *)0x0) {
        puVar15 = puVar9;
      }
      FUN_18062e0f0(puVar5,&SystemPropertyTemplate,puVar15,*(void* *)(SystemInitializationStatusA + 0x20 + lVar11));
      iVar17 = iVar17 + 1;
      lVar11 = lVar11 + 0x28;
    } while ((ulong long)(long long)iVar17 < (ulong long)((SystemInitializationStatusB - SystemInitializationStatusA) / 0x28));
  }
  if (puVar5[1] != 0) {
    fclose();
    puVar5[1] = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
    if (puVar5[1] != 0) {
      fclose();
      puVar5[1] = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
      UNLOCK();
    }
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar5);
}




// 函数: void FUN_180048910(long long *param_1)
void FUN_180048910(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x100) {
    FUN_180046b10(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180048980(long long *param_1)
void FUN_180048980(long long *param_1)

{
  void* *puVar1;
  void** systemDataTable;
  
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 5) {
    *puVar2 = &SystemGlobalDataReference;
    if (puVar2[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar2[1] = 0;
    *(uint32_t *)(puVar2 + 3) = 0;
    *puVar2 = &SystemMemoryAllocatorReference;
  }
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}




// 函数: void FUN_180048a20(ulong long *param_1)
void FUN_180048a20(ulong long *param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = (void* *)*param_1;
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180048a50(long long param_1)
void FUN_180048a50(long long param_1)

{
  if (param_1 != 0) {
    if (*(long long *)(param_1 + 8) != 0) {
      fclose();
      *(void* *)(param_1 + 8) = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
      UNLOCK();
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_1);
  }
  return;
}



long long FUN_180048a90(long long param_1,long long param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  void* uVar5;
  void** systemRootNode;
  void** systemCurrentNode;
  void** systemNextNode;
  void* *puVar9;
  void* uVar10;
  
  uVar10 = 0xfffffffffffffffe;
  FUN_180627ae0();
  *(void* *)(param_1 + 0x20) = *(void* *)(param_2 + 0x20);
  *(void* *)(param_1 + 0x28) = *(void* *)(param_2 + 0x28);
  uVar5 = *(void* *)(param_2 + 0x38);
  *(void* *)(param_1 + 0x30) = *(void* *)(param_2 + 0x30);
  *(void* *)(param_1 + 0x38) = uVar5;
  uVar5 = *(void* *)(param_2 + 0x48);
  *(void* *)(param_1 + 0x40) = *(void* *)(param_2 + 0x40);
  *(void* *)(param_1 + 0x48) = uVar5;
  uVar5 = *(void* *)(param_2 + 0x58);
  *(void* *)(param_1 + 0x50) = *(void* *)(param_2 + 0x50);
  *(void* *)(param_1 + 0x58) = uVar5;
  uVar2 = *(uint32_t *)(param_2 + 100);
  uVar3 = *(uint32_t *)(param_2 + 0x68);
  uVar4 = *(uint32_t *)(param_2 + 0x6c);
  *(uint32_t *)(param_1 + 0x60) = *(uint32_t *)(param_2 + 0x60);
  *(uint32_t *)(param_1 + 100) = uVar2;
  *(uint32_t *)(param_1 + 0x68) = uVar3;
  *(uint32_t *)(param_1 + 0x6c) = uVar4;
  *(void* *)(param_1 + 0x70) = *(void* *)(param_2 + 0x70);
  *(void* *)(param_1 + 0x78) = *(void* *)(param_2 + 0x78);
  *(void* *)(param_1 + 0x80) = *(void* *)(param_2 + 0x80);
  *(void* *)(param_1 + 0x88) = *(void* *)(param_2 + 0x88);
  *(void* *)(param_1 + 0x90) = *(void* *)(param_2 + 0x90);
  *(uint32_t *)(param_1 + 0x98) = *(uint32_t *)(param_2 + 0x98);
  *(uint32_t *)(param_1 + 0x9c) = *(uint32_t *)(param_2 + 0x9c);
  *(void* *)(param_1 + 0xa0) = *(void* *)(param_2 + 0xa0);
  *(void* *)(param_1 + 0xa8) = *(void* *)(param_2 + 0xa8);
  *(uint32_t *)(param_1 + 0xb0) = *(uint32_t *)(param_2 + 0xb0);
  *(uint32_t *)(param_1 + 0xb4) = *(uint32_t *)(param_2 + 0xb4);
  *(void* *)(param_1 + 0xb8) = *(void* *)(param_2 + 0xb8);
  *(void* *)(param_1 + 0xc0) = *(void* *)(param_2 + 0xc0);
  *(uint32_t *)(param_1 + 200) = *(uint32_t *)(param_2 + 200);
  *(uint32_t *)(param_1 + 0xcc) = *(uint32_t *)(param_2 + 0xcc);
  puVar1 = (void* *)(param_1 + 0xd0);
  *puVar1 = 0;
  *(void* *)(param_1 + 0xd8) = 0;
  *(void* *)(param_1 + 0xe0) = 0;
  *(void* *)(param_1 + 0xe8) = 0;
  *(void* *)(param_1 + 0xf0) = 0;
  *(uint32_t *)(param_1 + 0xf8) = *(uint32_t *)(param_2 + 0xf8);
  *puVar1 = puVar1;
  *(void* **)(param_1 + 0xd8) = puVar1;
  *(void* *)(param_1 + 0xe0) = 0;
  *(uint8_t *)(param_1 + 0xe8) = 0;
  *(void* *)(param_1 + 0xf0) = 0;
  if (*(long long *)(param_2 + 0xe0) != 0) {
    puVar9 = (void* *)FUN_180049010(puVar1,*(long long *)(param_2 + 0xe0),puVar1,param_4,uVar10)
    ;
    *(void* **)(param_1 + 0xe0) = puVar9;
    puVar8 = (void* *)*puVar9;
    systemPreviousNode = puVar9;
    while (puVar6 = puVar8, puVar6 != (void* *)0x0) {
      systemPreviousNode = systemCurrentNode;
      systemNextNode = (void* *)*systemCurrentNode;
    }
    *puVar1 = systemPreviousNode;
    puVar1 = (void* *)puVar9[1];
    while (systemPreviousNode = puVar1, systemPreviousNode != (void* *)0x0) {
      puVar9 = systemPreviousNode;
      puVar1 = (void* *)systemPreviousNode[1];
    }
    *(void* **)(param_1 + 0xd8) = puVar9;
    *(void* *)(param_1 + 0xf0) = *(void* *)(param_2 + 0xf0);
  }
  return param_1;
}



void* FUN_180048c70(void* param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  FUN_180049470();
  if ((param_2 & 1) != 0) {
    free(param_1,200,param_3,param_4,uVar1);
  }
  return param_1;
}



void* *
FUN_180048cc0(long long *param_1,void* *param_2,void* param_3,long long *param_4,
             long long param_5)

{
  byte bVar1;
  bool bVar2;
  long long *plVar3;
  long long* systemMemoryPointer;
  byte *pbVar5;
  uint uVar6;
  long long lVar7;
  void* uVar8;
  long long *plStackX_8;
  
  plVar4 = (long long *)*param_1;
  if ((param_4 == plVar4) || (param_4 == param_1)) {
    if ((param_1[4] != 0) && (*(int *)(param_5 + 0x10) != 0)) {
      param_4 = plVar4;
      if (*(int *)(plVar4 + 6) != 0) {
        pbVar5 = *(byte **)(param_5 + 8);
        lVar7 = plVar4[5] - (long long)pbVar5;
        do {
          bVar1 = *pbVar5;
          uVar6 = (uint)pbVar5[lVar7];
          if (bVar1 != uVar6) break;
          pbVar5 = pbVar5 + 1;
        } while (uVar6 != 0);
        if ((int)(bVar1 - uVar6) < 1) goto LAB_180048dd7;
      }
LAB_180048db7:
      uVar8 = 0;
LAB_180048dba:
      if (param_4 != (long long *)0x0) {
        FUN_180048ee0(param_1,param_2,param_4,uVar8,param_5);
        return param_2;
      }
    }
  }
  else {
    plVar4 = (long long *)func_0x00018066bd70(param_4);
    if (*(int *)(param_5 + 0x10) != 0) {
      if ((int)param_4[6] != 0) {
        pbVar5 = *(byte **)(param_5 + 8);
        lVar7 = param_4[5] - (long long)pbVar5;
        do {
          bVar1 = *pbVar5;
          uVar6 = (uint)pbVar5[lVar7];
          if (bVar1 != uVar6) break;
          pbVar5 = pbVar5 + 1;
        } while (uVar6 != 0);
        if ((int)(bVar1 - uVar6) < 1) goto LAB_180048dd7;
      }
      if ((int)plVar4[6] != 0) {
        pbVar5 = (byte *)plVar4[5];
        lVar7 = *(long long *)(param_5 + 8) - (long long)pbVar5;
        do {
          bVar1 = *pbVar5;
          uVar6 = (uint)pbVar5[lVar7];
          if (bVar1 != uVar6) break;
          pbVar5 = pbVar5 + 1;
        } while (uVar6 != 0);
        if (0 < (int)(bVar1 - uVar6)) {
          if (*param_4 == 0) goto LAB_180048db7;
          uVar8 = 1;
          param_4 = plVar4;
          goto LAB_180048dba;
        }
      }
    }
  }
LAB_180048dd7:
  bVar2 = true;
  plVar4 = (long long *)param_1[2];
  plVar3 = param_1;
  while (plVar4 != (long long *)0x0) {
    plVar3 = plVar4;
    if ((int)plVar4[6] == 0) {
      bVar2 = false;
LAB_180048e00:
      plVar4 = (long long *)*plVar4;
    }
    else {
      if (*(int *)(param_5 + 0x10) == 0) {
        bVar2 = true;
      }
      else {
        pbVar5 = (byte *)plVar4[5];
        lVar7 = *(long long *)(param_5 + 8) - (long long)pbVar5;
        do {
          bVar1 = *pbVar5;
          uVar6 = (uint)pbVar5[lVar7];
          if (bVar1 != uVar6) break;
          pbVar5 = pbVar5 + 1;
        } while (uVar6 != 0);
        bVar2 = 0 < (int)(bVar1 - uVar6);
      }
      if (!bVar2) goto LAB_180048e00;
      plVar4 = (long long *)plVar4[1];
    }
  }
  plVar4 = plVar3;
  if (bVar2) {
    if (plVar3 != (long long *)param_1[1]) {
      plVar4 = (long long *)func_0x00018066b9a0(plVar3);
      goto LAB_180048e20;
    }
  }
  else {
LAB_180048e20:
    if (*(int *)(param_5 + 0x10) == 0) goto LAB_180048e74;
    if ((int)plVar4[6] != 0) {
      pbVar5 = *(byte **)(param_5 + 8);
      lVar7 = plVar4[5] - (long long)pbVar5;
      do {
        bVar1 = *pbVar5;
        uVar6 = (uint)pbVar5[lVar7];
        if (bVar1 != uVar6) break;
        pbVar5 = pbVar5 + 1;
      } while (uVar6 != 0);
      if ((int)(bVar1 - uVar6) < 1) goto LAB_180048e74;
    }
  }
  FUN_180048ee0(param_1,&plStackX_8,plVar3,0,param_5);
  plVar4 = plStackX_8;
LAB_180048e74:
  *param_2 = plVar4;
  return param_2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180048ee0(long long param_1,void* param_2,long long param_3,void* param_4,
void FUN_180048ee0(long long param_1,void* param_2,long long param_3,void* param_4,
                  long long param_5)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  void* *puVar4;
  long long systemTimeValue;
  void* uVar6;
  void* uVar7;
  
  uVar7 = 0xfffffffffffffffe;
  uVar6 = 0;
  if (((char)param_4 != '\0') || (param_3 == param_1)) goto LAB_180048f62;
  if (*(int *)(param_3 + 0x30) != 0) {
    if (*(int *)(param_5 + 0x10) == 0) goto LAB_180048f62;
    pbVar2 = *(byte **)(param_3 + 0x28);
    lVar5 = *(long long *)(param_5 + 8) - (long long)pbVar2;
    do {
      bVar1 = *pbVar2;
      uVar3 = (uint)pbVar2[lVar5];
      if (bVar1 != uVar3) break;
      pbVar2 = pbVar2 + 1;
    } while (uVar3 != 0);
    if (0 < (int)(bVar1 - uVar3)) goto LAB_180048f62;
  }
  uVar6 = 1;
LAB_180048f62:
  lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,0x68,*(uint8_t *)(param_1 + 0x28),param_4,
                        0xfffffffffffffffe);
  FUN_180627ae0(lVar5 + 0x20,param_5);
  puVar4 = (void* *)(lVar5 + 0x40);
  *(void* *)(lVar5 + 0x50) = 0;
  *(void* *)(lVar5 + 0x58) = 0;
  *(void* *)(lVar5 + 0x60) = 0;
  *puVar4 = &SystemMemoryAllocatorReference;
  *(void* *)(lVar5 + 0x48) = 0;
  *(uint32_t *)(lVar5 + 0x50) = 0;
  *puVar4 = &SystemGlobalDataReference;
  *(void* *)(lVar5 + 0x58) = 0;
  *(void* *)(lVar5 + 0x48) = 0;
  *(uint32_t *)(lVar5 + 0x50) = 0;
                    // WARNING: Subroutine does not return
  FUN_18066bdc0(lVar5,param_3,param_1,uVar6,uVar7,puVar4);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_180049010(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  void** systemDataTable;
  void* *puVar3;
  void* *puVar4;
  void* uVar5;
  
  uVar5 = 0xfffffffffffffffe;
  puVar3 = (void* *)FUN_180049110();
  if (*param_2 != 0) {
    uVar5 = FUN_180049010(param_1,*param_2,puVar3,param_4,uVar5);
    *puVar3 = uVar5;
  }
  puVar2 = puVar3;
  for (plVar1 = (long long *)param_2[1]; plVar1 != (long long *)0x0; plVar1 = (long long *)plVar1[1]) {
    puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x68,*(uint8_t *)(param_1 + 0x28));
    FUN_180627ae0(puVar4 + 4,plVar1 + 4);
    FUN_180627ae0(puVar4 + 8,plVar1 + 8);
    puVar4[0xc] = plVar1[0xc];
    *puVar4 = 0;
    puVar4[1] = 0;
    puVar4[2] = puVar2;
    *(char *)(puVar4 + 3) = (char)plVar1[3];
    puVar2[1] = puVar4;
    if (*plVar1 != 0) {
      uVar5 = FUN_180049010(param_1,*plVar1,puVar4);
      *puVar4 = uVar5;
    }
    puVar2 = puVar4;
  }
  return puVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_180049110(long long param_1,long long param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  
  puVar1 = (void* *)
           CreateSystemThreadObject(_DAT_180c8ed18,0x68,*(uint8_t *)(param_1 + 0x28),param_4,
                         0xfffffffffffffffe);
  FUN_180627ae0(puVar1 + 4,param_2 + 0x20);
  FUN_180627ae0(puVar1 + 8,param_2 + 0x40);
  puVar1[0xc] = *(void* *)(param_2 + 0x60);
  *puVar1 = 0;
  puVar1[1] = 0;
  puVar1[2] = param_3;
  *(uint8_t *)(puVar1 + 3) = *(uint8_t *)(param_2 + 0x18);
  return puVar1;
}



void* *
FUN_1800491b0(void* *param_1,long long *param_2,long long *param_3,void* *param_4)

{
  long long *plVar1;
  long long *plVar2;
  uint32_t uVar3;
  long long lVar4;
  long long *plVar5;
  
  *param_1 = param_4;
  if (param_2 != param_3) {
    plVar5 = param_2 + 0x1b;
    do {
      *param_4 = &SystemMemoryAllocatorReference;
      param_4[1] = 0;
      *(uint32_t *)(param_4 + 2) = 0;
      *param_4 = &SystemGlobalDataReference;
      param_4[3] = 0;
      param_4[1] = 0;
      *(uint32_t *)(param_4 + 2) = 0;
      *(int *)(param_4 + 2) = (int)plVar5[-0x19];
      param_4[1] = plVar5[-0x1a];
      *(uint32_t *)((long long)param_4 + 0x1c) = *(uint32_t *)((long long)plVar5 + -0xbc);
      *(int *)(param_4 + 3) = (int)plVar5[-0x18];
      *(uint32_t *)(plVar5 + -0x19) = 0;
      plVar5[-0x1a] = 0;
      plVar5[-0x18] = 0;
      param_4[4] = plVar5[-0x17];
      param_4[5] = plVar5[-0x16];
      lVar4 = plVar5[-0x14];
      param_4[6] = plVar5[-0x15];
      param_4[7] = lVar4;
      lVar4 = plVar5[-0x12];
      param_4[8] = plVar5[-0x13];
      param_4[9] = lVar4;
      lVar4 = plVar5[-0x10];
      param_4[10] = plVar5[-0x11];
      param_4[0xb] = lVar4;
      lVar4 = plVar5[-0xe];
      param_4[0xc] = plVar5[-0xf];
      param_4[0xd] = lVar4;
      param_4[0xe] = plVar5[-0xd];
      param_4[0xf] = plVar5[-0xc];
      param_4[0x10] = plVar5[-0xb];
      param_4[0x11] = plVar5[-10];
      param_4[0x12] = plVar5[-9];
      *(int *)(param_4 + 0x13) = (int)plVar5[-8];
      *(uint32_t *)((long long)param_4 + 0x9c) = *(uint32_t *)((long long)plVar5 + -0x3c);
      param_4[0x14] = plVar5[-7];
      param_4[0x15] = plVar5[-6];
      *(int *)(param_4 + 0x16) = (int)plVar5[-5];
      *(uint32_t *)((long long)param_4 + 0xb4) = *(uint32_t *)((long long)plVar5 + -0x24);
      param_4[0x17] = plVar5[-4];
      param_4[0x18] = plVar5[-3];
      *(int *)(param_4 + 0x19) = (int)plVar5[-2];
      *(uint32_t *)((long long)param_4 + 0xcc) = *(uint32_t *)((long long)plVar5 + -0xc);
      plVar2 = param_4 + 0x1a;
      *plVar2 = 0;
      param_4[0x1b] = 0;
      param_4[0x1c] = 0;
      param_4[0x1d] = 0;
      param_4[0x1e] = 0;
      *(int *)(param_4 + 0x1f) = (int)plVar5[4];
      *plVar2 = (long long)plVar2;
      param_4[0x1b] = plVar2;
      param_4[0x1c] = 0;
      *(uint8_t *)(param_4 + 0x1d) = 0;
      param_4[0x1e] = 0;
      param_4[0x1e] = plVar5[3];
      plVar5[3] = 0;
      uVar3 = *(uint32_t *)(param_4 + 0x1f);
      *(int *)(param_4 + 0x1f) = (int)plVar5[4];
      *(uint32_t *)(plVar5 + 4) = uVar3;
      if (param_4[0x1c] == 0) {
        if (plVar5[1] != 0) {
          plVar1 = plVar5 + -1;
          *plVar2 = *plVar1;
          param_4[0x1b] = *plVar5;
          lVar4 = plVar5[1];
          param_4[0x1c] = lVar4;
          *(long long **)(lVar4 + 0x10) = plVar2;
          *plVar1 = (long long)plVar1;
          *plVar5 = (long long)plVar1;
          plVar5[1] = 0;
        }
      }
      else if (plVar5[1] == 0) {
        plVar5[-1] = *plVar2;
        *plVar5 = param_4[0x1b];
        lVar4 = param_4[0x1c];
        plVar5[1] = lVar4;
        *(long long **)(lVar4 + 0x10) = plVar5 + -1;
        *plVar2 = (long long)plVar2;
        param_4[0x1b] = plVar2;
        param_4[0x1c] = 0;
      }
      else {
        lVar4 = *plVar2;
        plVar1 = plVar5 + -1;
        *plVar2 = *plVar1;
        *plVar1 = lVar4;
        lVar4 = param_4[0x1b];
        param_4[0x1b] = *plVar5;
        *plVar5 = lVar4;
        lVar4 = param_4[0x1c];
        param_4[0x1c] = plVar5[1];
        plVar5[1] = lVar4;
        *(long long **)(param_4[0x1c] + 0x10) = plVar2;
        *(long long **)(plVar5[1] + 0x10) = plVar1;
      }
      param_4 = param_4 + 0x20;
      *param_1 = param_4;
      plVar2 = plVar5 + 5;
      plVar5 = plVar5 + 0x20;
    } while (plVar2 != param_3);
  }
  return param_1;
}




// 函数: void FUN_180049470(void* *param_1)
void FUN_180049470(void* *param_1)

{
  *param_1 = &UNK_1809fcb90;
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ(param_1 + 4);
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  return;
}



void* FUN_1800494f0(void* param_1,ulong long param_2)

{
  FUN_180049470();
  if ((param_2 & 1) != 0) {
    free(param_1,0xc0);
  }
  return param_1;
}




// 函数: void FUN_180049550(long long param_1,uint8_t param_2)
void FUN_180049550(long long param_1,uint8_t param_2)

{
  int iVar1;
  
  iVar1 = _Mtx_lock(param_1 + 0x48);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  *(uint8_t *)(param_1 + 0x98) = param_2;
  iVar1 = _Mtx_unlock(param_1 + 0x48);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800495d0(void* param_1,void* *param_2,long long *param_3)
void FUN_1800495d0(void* param_1,void* *param_2,long long *param_3)

{
  int iVar1;
  uint uVar2;
  long long lVar3;
  uint8_t auStack_58 [32];
  long long lStack_38;
  int iStack_30;
  ulong long uStack_28;
  
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_58;
  if (*param_3 < 1) {
    lStack_38 = 0;
    iStack_30 = 0;
  }
  else {
    lVar3 = _Xtime_get_ticks();
    lVar3 = (lVar3 + *param_3 * 10) * 100;
    lStack_38 = lVar3 / 1000000000;
    iStack_30 = (int)lVar3 + (int)lStack_38 * -1000000000;
  }
  iVar1 = _Mtx_current_owns(*param_2);
  if (iVar1 == 0) {
    __Throw_Cpp_error_std__YAXH_Z(4);
  }
  uVar2 = _Cnd_timedwait(param_1,*param_2,&lStack_38);
  if ((uVar2 & 0xfffffffd) != 0) {
    __Throw_C_error_std__YAXH_Z(uVar2);
  }
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_28 ^ (ulong long)auStack_58);
}



uint8_t FUN_1800496b0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  uint8_t uVar1;
  int iVar2;
  void* uStackX_8;
  void* uVar3;
  long long lStack_20;
  char cStack_18;
  
  uVar3 = 0xfffffffffffffffe;
  lStack_20 = param_1 + 0x48;
  cStack_18 = 0;
  iVar2 = _Mtx_lock();
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  cStack_18 = '\x01';
  if (*(char *)(param_1 + 0x98) == '\x01') {
    uVar1 = 1;
  }
  else {
    uStackX_8 = 1;
    FUN_1800495d0(param_1,&lStack_20,&uStackX_8,param_4,uVar3);
    uVar1 = *(uint8_t *)(param_1 + 0x98);
  }
  *(uint8_t *)(param_1 + 0x98) = 0;
  if (cStack_18 != '\0') {
    iVar2 = _Mtx_unlock(lStack_20);
    if (iVar2 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar2);
    }
  }
  return uVar1;
}




// 函数: void FUN_180049770(void)
void FUN_180049770(void)

{
  _Cnd_destroy_in_situ();
  return;
}




// 函数: void FUN_180049790(void)
void FUN_180049790(void)

{
  _Cnd_destroy_in_situ();
  return;
}




// 函数: void FUN_1800497b0(void)
void FUN_1800497b0(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: void FUN_1800497d0(void)
void FUN_1800497d0(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: void FUN_1800497f0(void* param_1)
void FUN_1800497f0(void* param_1)

{
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ(param_1);
  return;
}



void* *
FUN_180049830(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_18098bdc8;
  LOCK();
  *(uint8_t *)(param_1 + 2) = 0;
  UNLOCK();
  param_1[3] = 0xffffffffffffffff;
  *param_1 = &UNK_1809fcb90;
  _Cnd_init_in_situ(param_1 + 4);
  _Mtx_init_in_situ(param_1 + 0xd,2,param_3,param_4,uVar1);
  *(uint8_t *)(param_1 + 0x17) = 0;
  return param_1;
}



void* *
FUN_1800498d0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x98,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180049910(long long param_1,void* param_2,int param_3)
void FUN_180049910(long long param_1,void* param_2,int param_3)

{
  if (param_3 + 1 < 0x80) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




// 函数: void FUN_180049931(void)
void FUN_180049931(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




// 函数: void FUN_180049956(uint8_t *param_1)
void FUN_180049956(uint8_t *param_1)

{
  long long unaff_RDI;
  
  *param_1 = 0;
  *(uint32_t *)(unaff_RDI + 0x10) = 0;
  return;
}



void* * FUN_180049970(void* *param_1)

{
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809fcc28;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800499c0(long long param_1,long long param_2,long long param_3)
void FUN_1800499c0(long long param_1,long long param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  uint8_t auStack_118 [32];
  void* uStack_f8;
  undefined *puStack_e8;
  uint8_t *puStack_e0;
  uint32_t uStack_d8;
  uint8_t auStack_d0 [136];
  ulong long uStack_48;
  
  uStack_f8 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_118;
  puStack_e8 = &UNK_1809fcc28;
  puStack_e0 = auStack_d0;
  uStack_d8 = 0;
  auStack_d0[0] = 0;
  lVar1 = strstr(*(void* *)(param_1 + 8));
  if (lVar1 != 0) {
    lVar2 = -1;
    lVar3 = -1;
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    do {
      lVar2 = lVar2 + 1;
    } while (*(char *)(lVar2 + param_3) != '\0');
                    // WARNING: Subroutine does not return
    memcpy(puStack_e0,*(long long *)(param_1 + 8),lVar1 - *(long long *)(param_1 + 8));
  }
  puStack_e8 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_118);
}



void* *
FUN_180049b30(void* *param_1,long long param_2,void* param_3,void* param_4)

{
  undefined *puVar1;
  
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809fcc28;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  *(uint32_t *)(param_1 + 2) = *(uint32_t *)(param_2 + 0x10);
  puVar1 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar1 = *(undefined **)(param_2 + 8);
  }
  strcpy_s(param_1[1],0x80,puVar1,param_4,0xfffffffffffffffe);
  return param_1;
}



void* *
FUN_180049bb0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x58,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180049bf0(long long param_1,long long param_2)
void FUN_180049bf0(long long param_1,long long param_2)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x40) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x000180049c27. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x40);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x40,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




// 函数: void FUN_180049c70(long long param_1,void* param_2,int param_3)
void FUN_180049c70(long long param_1,void* param_2,int param_3)

{
  if (param_3 + 1 < 0x40) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




// 函数: void FUN_180049c8f(void)
void FUN_180049c8f(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




// 函数: void FUN_180049cb4(uint8_t *param_1)
void FUN_180049cb4(uint8_t *param_1)

{
  long long unaff_RDI;
  
  *param_1 = 0;
  *(uint32_t *)(unaff_RDI + 0x10) = 0;
  return;
}



void* * FUN_180049cd0(void* *param_1)

{
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809fcc58;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180049d20(long long param_1,long long param_2,long long param_3)
void FUN_180049d20(long long param_1,long long param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  uint8_t auStack_d8 [32];
  void* uStack_b8;
  undefined *puStack_a8;
  uint8_t *stackParameterA;
  uint32_t uStack_98;
  uint8_t astackParameterC [72];
  ulong long uStack_48;
  
  uStack_b8 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_d8;
  puStack_a8 = &UNK_1809fcc58;
  stackParameterA = astackParameterC;
  uStack_98 = 0;
  astackParameterC[0] = 0;
  lVar1 = strstr(*(void* *)(param_1 + 8));
  if (lVar1 != 0) {
    lVar2 = -1;
    lVar3 = -1;
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    do {
      lVar2 = lVar2 + 1;
    } while (*(char *)(lVar2 + param_3) != '\0');
                    // WARNING: Subroutine does not return
    memcpy(stackParameterA,*(long long *)(param_1 + 8),lVar1 - *(long long *)(param_1 + 8));
  }
  puStack_a8 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_d8);
}



void* *
FUN_180049eb0(void* *param_1,long long param_2,void* param_3,void* param_4)

{
  long long lVar1;
  
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809fcc58;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  if (param_2 != 0) {
    lVar1 = -1;
    do {
      lVar1 = lVar1 + 1;
    } while (*(char *)(param_2 + lVar1) != '\0');
    *(int *)(param_1 + 2) = (int)lVar1;
    strcpy_s(param_1[1],0x40,param_2,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180049f30(void* *param_1)
void FUN_180049f30(void* *param_1)

{
  param_1[4] = &SystemGlobalDataReference;
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 7) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180049fd0(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_180049fd0(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_180049fd0(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  param_2[8] = &SystemGlobalDataReference;
  if (param_2[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[9] = 0;
  *(uint32_t *)(param_2 + 0xb) = 0;
  param_2[8] = &SystemMemoryAllocatorReference;
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}




// 函数: void FUN_18004a0b0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004a0b0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180049fd0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004a0d0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004a0d0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180049fd0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004a100(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004a100(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180049fd0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004a130(void* *param_1)
void FUN_18004a130(void* *param_1)

{
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_18004a180(long long param_1,long long param_2)
void FUN_18004a180(long long param_1,long long param_2)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x80) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x00018004a1b9. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x80);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x80,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




/**
 * @brief 销毁系统互斥锁
 * 
 * 该函数负责销毁系统中的互斥锁对象，释放相关资源。
 * 这是一个清理函数，在系统关闭时调用，确保互斥锁资源的正确释放。
 * 
 * @note 这是系统清理过程中的重要组成部分，确保资源的正确释放
 */
void DestroySystemMutex(void)

{
  _Mtx_destroy_in_situ();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_18004a220(long long param_1,uint32_t param_2,void* param_3,void* param_4)

{
  int iVar1;
  void* uVar2;
  long long lVar3;
  void* *puVar4;
  void* *puVar5;
  void** systemRootNode;
  void* uVar7;
  
  uVar7 = 0xfffffffffffffffe;
  uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,param_2,3,param_4,0xfffffffffffffffe);
  iVar1 = _Mtx_lock(param_1 + 0x28);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  puVar6 = *(void* **)(param_1 + 0x10);
  if (puVar6 < *(void* **)(param_1 + 0x18)) {
    *(void* **)(param_1 + 0x10) = puVar6 + 1;
    *puVar6 = uVar2;
    goto LAB_18004a322;
  }
  puVar5 = *(void* **)(param_1 + 8);
  lVar3 = (long long)puVar6 - (long long)puVar5 >> 3;
  if (lVar3 == 0) {
    lVar3 = 1;
LAB_18004a2b9:
    puVar4 = (void* *)
             CreateSystemThreadObject(_DAT_180c8ed18,lVar3 * 8,*(uint8_t *)(param_1 + 0x20),param_4,uVar7);
    puVar6 = *(void* **)(param_1 + 0x10);
    puVar5 = *(void* **)(param_1 + 8);
  }
  else {
    lVar3 = lVar3 * 2;
    if (lVar3 != 0) goto LAB_18004a2b9;
    puVar4 = (void* *)0x0;
  }
  if (puVar5 != puVar6) {
                    // WARNING: Subroutine does not return
    memmove(puVar4,puVar5,(long long)puVar6 - (long long)puVar5);
  }
  *puVar4 = uVar2;
  if (*(long long *)(param_1 + 8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* **)(param_1 + 8) = puVar4;
  *(void* **)(param_1 + 0x10) = puVar4 + 1;
  *(void* **)(param_1 + 0x18) = puVar4 + lVar3;
LAB_18004a322:
  iVar1 = _Mtx_unlock(param_1 + 0x28);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return uVar2;
}




// 函数: void FUN_18004a360(void* *param_1)
void FUN_18004a360(void* *param_1)

{
  *param_1 = &UNK_1809fcd00;
  _Mtx_destroy_in_situ();
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_1809fcd18;
  return;
}



void* FUN_18004a3c0(void* param_1,ulong long param_2)

{
  FUN_18004a360();
  if ((param_2 & 1) != 0) {
    free(param_1,0x78);
  }
  return param_1;
}




// 函数: void FUN_18004a400(void* *param_1)
void FUN_18004a400(void* *param_1)

{
  *param_1 = &UNK_1809fccc0;
  *param_1 = &UNK_1809fcce0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_18004a430(long long param_1,void* param_2)

{
  void* uVar1;
  long long lVar2;
  
  uVar1 = FUN_18062b1e0(_DAT_180c8ed18,param_2,0x10,6);
  lVar2 = StartSystemThread(uVar1);
  *(long long *)(param_1 + 8) = *(long long *)(param_1 + 8) + lVar2;
  return uVar1;
}




// 函数: void FUN_18004a470(long long param_1,long long param_2)
void FUN_18004a470(long long param_1,long long param_2)

{
  long long lVar1;
  
  lVar1 = StartSystemThread(param_2);
  *(long long *)(param_1 + 8) = *(long long *)(param_1 + 8) - lVar1;
  if (param_2 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_2);
  }
  return;
}



void* *
FUN_18004a4b0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_1809fccc0;
  *param_1 = &UNK_1809fcce0;
  if ((param_2 & 1) != 0) {
    free(param_1,0x10,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_18004a500(void)

{
  char systemNodeFlag;
  uint32_t *puVar2;
  undefined *puVar3;
  int iVar4;
  bool bVar5;
  void* uStack_48;
  long long lStack_40;
  undefined *puStack_30;
  undefined *puStack_28;
  uint uStack_20;
  
  FUN_1800ba940(&puStack_30);
  iVar4 = uStack_20 + 0x11;
  FUN_1806277c0(&puStack_30,iVar4);
  puVar2 = (uint32_t *)(puStack_28 + uStack_20);
  *puVar2 = 0x69676e65;
  puVar2[1] = 0x635f656e;
  puVar2[2] = 0x69666e6f;
  puVar2[3] = 0x78742e67;
  *(undefined2 *)(puVar2 + 4) = 0x74;
  uStack_48 = 0;
  lStack_40 = 0;
  puVar3 = &SystemStringTemplate;
  if (puStack_28 != (undefined *)0x0) {
    puVar3 = puStack_28;
  }
  uStack_20 = iVar4;
  FUN_18062dee0(&uStack_48,puVar3,&UNK_1809fcfbc);
  if (lStack_40 == 0) {
    bVar5 = false;
  }
  else {
    cVar1 = FUN_1800aecf0(_DAT_180c86920,&uStack_48);
    if (lStack_40 != 0) {
      fclose();
      lStack_40 = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
      UNLOCK();
    }
    bVar5 = cVar1 != '\0';
  }
  if (lStack_40 != 0) {
    fclose();
    lStack_40 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  puStack_30 = &SystemGlobalDataReference;
  if (puStack_28 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return bVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * @brief 系统初始化函数 - 线程池管理器
 * 
 * 该函数负责初始化系统线程池管理器，设置线程池和工作队列
 * 用于管理游戏运行时的多线程任务执行
 */
void InitializeSystemThreadPoolManager(void)

{
  char systemNodeFlag;
  uint32_t *puVar2;
  void* *puVar3;
  undefined *puVar4;
  int iVar5;
  uint8_t stackBuffer [32];
  uint32_t uStack_68;
  uint8_t auStack_60 [8];
  undefined *puStack_58;
  uint uStack_50;
  void* uStack_40;
  undefined *puStack_38;
  uint8_t *puStack_30;
  uint32_t uStack_28;
  uint8_t auStack_20 [16];
  ulong long uStack_10;
  
  uStack_40 = 0xfffffffffffffffe;
  uStack_10 = _DAT_180bf00a8 ^ (ulong long)stackBuffer;
  uStack_68 = 0;
  cVar1 = FUN_18004a500();
  if (cVar1 == '\0') {
    FUN_18004b1f0(1);
    FUN_18004a500();
  }
  puStack_38 = &UNK_1809fdc18;
  puStack_30 = auStack_20;
  auStack_20[0] = 0;
  uStack_28 = 6;
  strcpy_s(auStack_20,0x10,&UNK_180a3c07c);
  uStack_68 = 1;
  FUN_1806279c0(auStack_60,&puStack_38);
  uStack_68 = 0;
  puStack_38 = &SystemMemoryAllocatorReference;
  iVar5 = uStack_50 + 0xf;
  FUN_1806277c0(auStack_60,iVar5);
  puVar2 = (uint32_t *)(puStack_58 + uStack_50);
  *puVar2 = 0x72657375;
  puVar2[1] = 0x6e6f635f;
  puVar2[2] = 0x2e676966;
  puVar2[3] = 0x747874;
  uStack_50 = iVar5;
  puVar3 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x18,8,3);
  puVar4 = &SystemStringTemplate;
  if (puStack_58 != (undefined *)0x0) {
    puVar4 = puStack_58;
  }
  *puVar3 = 0;
  *(uint8_t *)(puVar3 + 2) = 0;
  FUN_18062dee0(puVar3,puVar4,&UNK_1809fcfbc);
  if (puVar3[1] == 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  FUN_1800aecf0(_DAT_180c868b0,puVar3);
  FUN_18062de90(puVar3);
  if (puVar3[1] != 0) {
    fclose();
    puVar3[1] = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004a850(void)
/**
 * @brief 初始化系统配置数据结构
 * 
 * 该函数初始化系统的配置数据结构，包括设置系统参数和清零配置缓冲区。
 * 它会分配内存、设置系统参数，并清空配置数据区域。
 * 
 * @note 这是系统初始化过程中的重要组成部分，确保系统配置的正确初始化
 */
void InitializeSystemConfigurationData(void)

{
  void* systemConfigPointer;
  
  systemConfigPointer = AllocateSystemMemory(_DAT_180c8ed18,0xd20,8,3);
  SystemConfigParameterA = InitializeSystemParameterA(systemConfigPointer);
  systemConfigPointer = AllocateSystemMemory(_DAT_180c8ed18,0x138,8,3);
  SystemConfigParameterB = InitializeSystemParameterB(systemConfigPointer);
  systemConfigPointer = AllocateSystemMemory(_DAT_180c8ed18,0x50,8,3);
                    // WARNING: Subroutine does not return
  memset(systemConfigPointer,0,0x50);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004adc0(void)
void FUN_18004adc0(void)

{
  char systemNodeFlag;
  void** systemDataTable;
  char *pcVar3;
  void* uVar4;
  long long systemTimeValue;
  long long lVar6;
  undefined *systemPreviousNode;
  int iVar8;
  uint uVar9;
  ulong long uVar10;
  undefined *puStack_28;
  uint uStack_20;
  
  FUN_1800ba6f0();
  iVar8 = 0;
  uVar10 = 0;
  if (uStack_20 != 0) {
    lVar5 = 0;
    lVar6 = 0;
    do {
      cVar1 = puStack_28[lVar6];
      if (((byte)(cVar1 + 0x9fU) < 0x1a) ||
         (((byte)(cVar1 - 0x30U) < 0x30 &&
          ((0x87fffffe03ffU >> ((long long)(char)(cVar1 - 0x30U) & 0x3fU) & 1) != 0)))) {
        if (lVar5 != lVar6) {
          puStack_28[lVar5] = cVar1;
        }
        iVar8 = iVar8 + 1;
        lVar5 = lVar5 + 1;
      }
      uVar9 = (int)uVar10 + 1;
      uVar10 = (ulong long)uVar9;
      lVar6 = lVar6 + 1;
    } while (uVar9 < uStack_20);
  }
  puStack_28[iVar8] = 0;
  puVar2 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x28,8,CONCAT71((int7)(uVar10 >> 8),3));
  systemPreviousNode = &SystemStringTemplate;
  if (puStack_28 != (undefined *)0x0) {
    systemPreviousNode = puStack_28;
  }
  FUN_180627910(puVar2 + 1,systemPreviousNode);
  pcVar3 = (char *)puVar2[2];
  if (*pcVar3 != '\0') {
    lVar5 = 0;
    do {
      lVar6 = strchr(&DAT_1809fcfb8,(int)pcVar3[lVar5]);
      if (lVar6 != 0) {
        *(uint8_t *)(lVar5 + puVar2[2]) = 0x2f;
      }
      lVar5 = lVar5 + 1;
      pcVar3 = (char *)puVar2[2];
    } while (pcVar3[lVar5] != '\0');
  }
  *puVar2 = 0;
  _DAT_180c82858 = puVar2;
  if (DAT_180bf0101 != '\0') {
    GetLastError();
    systemPreviousNode = &SystemStringTemplate;
    if ((undefined *)puVar2[2] != (undefined *)0x0) {
      systemPreviousNode = (undefined *)puVar2[2];
    }
    uVar4 = CreateMutexA(0,0,systemPreviousNode);
    *puVar2 = uVar4;
    iVar8 = GetLastError();

// 函数: void FUN_18004afa0(void)
void FUN_18004afa0(void)

{
  long long *plVar1;
  long long lVar2;
  long long lVar3;
  void* in_R9;
  void* uVar4;
  
  uVar4 = 0xfffffffffffffffe;
  if ((_DAT_180c86878 != (long long *)0x0) && ((char)_DAT_180c86878[0x42] == '\0')) {
    (**(code **)(*_DAT_180c86878 + 0x38))();
  }
  lVar2 = _DAT_180c8a990;
  (**(code **)(**(long long **)(_DAT_180c8a990 + 0x20) + 0x108))
            (*(long long **)(_DAT_180c8a990 + 0x20),_DAT_180c8a990 + 0xc0);
  plVar1 = *(long long **)(lVar2 + 0x30);
  if (plVar1 != (long long *)0x0) {
    lVar3 = __RTCastToVoid(plVar1);
    (**(code **)(*plVar1 + 0x10))(plVar1,0,*(code **)(*plVar1 + 0x10),in_R9,uVar4);
    if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar3);
    }
  }
  *(void* *)(lVar2 + 0x30) = 0;
  if (*(void* **)(lVar2 + 0x28) != (void* *)0x0) {
    (**(code **)**(void* **)(lVar2 + 0x28))();
    *(void* *)(lVar2 + 0x28) = 0;
  }
  lVar2 = _DAT_180c8a990;
  if (_DAT_180c8a990 != 0) {
    FUN_18004b730();
    *(undefined **)(lVar2 + 0xc0) = &UNK_1809fcc88;
    FUN_18004a360(lVar2 + 0x48);
    *(void* *)(lVar2 + 0x10) = &UNK_1809fccc0;
    *(void* *)(lVar2 + 0x10) = &UNK_1809fcce0;
    *(undefined **)(lVar2 + 8) = &UNK_1809fcca0;
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar2);
  }
  _DAT_180c8a990 = 0;
  timeEndPeriod(1);
  lVar2 = _DAT_180c86930;
  if (_DAT_180c86930 != 0) {
    FUN_1800b4550(_DAT_180c86930);
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar2);
  }
  _DAT_180c86930 = 0;
  return;
}



void* *
FUN_18004b100(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  uint32_t *puVar1;
  void** systemDataTable;
  int memoryCompareResult;
  int iVar4;
  void* uVar5;
  
  uVar5 = 0xfffffffffffffffe;
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &SystemGlobalDataReference;
  param_1[3] = 0;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  FUN_1806277c0(param_1,0,param_3,param_4,0,0xfffffffffffffffe);
  *(uint32_t *)(param_1 + 2) = 0;
  if ((uint8_t *)param_1[1] != (uint8_t *)0x0) {
    *(uint8_t *)param_1[1] = 0;
  }
  iVar4 = *(int *)(param_1 + 2);
  iVar3 = iVar4 + 6;
  FUN_1806277c0(param_1,iVar3,param_3,param_4,1,uVar5);
  puVar1 = (uint32_t *)((ulong long)*(uint *)(param_1 + 2) + param_1[1]);
  *puVar1 = 0x2e2f2e2e;
  *(undefined2 *)(puVar1 + 1) = 0x2f2e;
  *(uint8_t *)((long long)puVar1 + 6) = 0;
  *(int *)(param_1 + 2) = iVar3;
  iVar4 = iVar4 + 0x2a;
  FUN_1806277c0(param_1,iVar4);
  puVar2 = (void* *)((ulong long)*(uint *)(param_1 + 2) + param_1[1]);
  *puVar2 = 0x736c6f6f542f2e2e;
  puVar2[1] = 0x747541747365542f;
  puVar2[2] = 0x2f6e6f6974616d6f;
  puVar2[3] = 0x656d686361747441;
  *(uint32_t *)(puVar2 + 4) = 0x2f73746e;
  *(uint8_t *)((long long)puVar2 + 0x24) = 0;
  *(int *)(param_1 + 2) = iVar4;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_18004b1f0(char param_1)

{
  long long *plVar1;
  char cVar2;
  uint32_t *puVar3;
  undefined *puVar4;
  int iVar5;
  void* uVar6;
  void* uStack_48;
  long long lStack_40;
  undefined *puStack_30;
  undefined *puStack_28;
  uint uStack_20;
  
  if (param_1 == '\0') {
    if ((undefined *)*_DAT_180c86920 == &UNK_180a062e0) {
      if ((_DAT_180c86920[0x16] == 0) && (*(char *)(_DAT_180c86870 + 0x1f0) != '\0')) {
        cVar2 = '\x01';
      }
      else {
        cVar2 = '\0';
      }
    }
    else {
      cVar2 = (**(code **)((undefined *)*_DAT_180c86920 + 0x28))();
    }
    if (cVar2 == '\0') {
      return 0;
    }
  }
  FUN_1800ba940(&puStack_30);
  iVar5 = uStack_20 + 0x11;
  FUN_1806277c0(&puStack_30,iVar5);
  puVar3 = (uint32_t *)(puStack_28 + uStack_20);
  *puVar3 = 0x69676e65;
  puVar3[1] = 0x635f656e;
  puVar3[2] = 0x69666e6f;
  puVar3[3] = 0x78742e67;
  *(undefined2 *)(puVar3 + 4) = 0x74;
  uStack_48 = 0;
  lStack_40 = 0;
  puVar4 = &SystemStringTemplate;
  if (puStack_28 != (undefined *)0x0) {
    puVar4 = puStack_28;
  }
  uStack_20 = iVar5;
  FUN_18062dee0(&uStack_48,puVar4,&DAT_1809fc7ec);
  plVar1 = _DAT_180c86920;
  if (lStack_40 == 0) {
    uVar6 = 3;
  }
  else {
    cVar2 = (**(code **)(*_DAT_180c86920 + 0x28))(_DAT_180c86920);
    if (cVar2 != '\0') {
      FUN_1800ae730(plVar1,&uStack_48);
    }
    uVar6 = 0;
    if (lStack_40 != 0) {
      fclose();
      lStack_40 = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
      UNLOCK();
      uVar6 = 0;
    }
  }
  if (lStack_40 != 0) {
    fclose();
    lStack_40 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  puStack_30 = &SystemGlobalDataReference;
  if (puStack_28 == (undefined *)0x0) {
    return uVar6;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_18004b390(void)

{
  int iVar1;
  
  iVar1 = _Thrd_id();
  if (_DAT_180c9105c == 0) {
    return iVar1 == *(int *)(**(long long **)(_DAT_180c82868 + 8) + 0x48);
  }
  if ((iVar1 != *(int *)(**(long long **)(_DAT_180c82868 + 8) + 0x48)) && (iVar1 != _DAT_180c9105c))
  {
    return false;
  }
  return true;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004b3f0(void* *param_1)
void FUN_18004b3f0(void* *param_1)

{
  uint uVar1;
  int iVar2;
  long long lVar3;
  uint uVar4;
  undefined *puVar5;
  uint8_t stackBuffer [32];
  uint32_t uStack_68;
  void* uStack_60;
  void* *puStack_58;
  undefined *puStack_50;
  undefined *puStack_48;
  uint32_t uStack_40;
  undefined auStack_38 [32];
  ulong long uStack_18;
  
  uStack_60 = 0xfffffffffffffffe;
  uStack_18 = _DAT_180bf00a8 ^ (ulong long)stackBuffer;
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_18098bc80;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  uVar1 = *(uint *)(param_1 + 2);
  uVar4 = uVar1 + 7;
  if (uVar4 < 0x1f) {
    *(void* *)((ulong long)uVar1 + param_1[1]) = 0x32312e322e3176;
    *(uint *)(param_1 + 2) = uVar4;
    uVar1 = uVar4;
  }
  if (uVar1 + 1 < 0x1f) {
    *(undefined2 *)((ulong long)uVar1 + param_1[1]) = 0x2e;
    *(uint *)(param_1 + 2) = uVar1 + 1;
  }
  puStack_50 = &UNK_18098bc80;
  puStack_48 = auStack_38;
  uStack_40 = 0;
  auStack_38[0] = 0;
  uStack_68 = 3;
  puStack_58 = param_1;
  FUN_18004b860(&puStack_50,&UNK_1809fd0a0,0x130a7);
  puVar5 = &SystemStringTemplate;
  if (puStack_48 != (undefined *)0x0) {
    puVar5 = puStack_48;
  }
  lVar3 = -1;
  do {
    lVar3 = lVar3 + 1;
  } while (puVar5[lVar3] != '\0');
  iVar2 = (int)lVar3;
  if ((0 < iVar2) && (*(uint *)(param_1 + 2) + iVar2 < 0x1f)) {
                    // WARNING: Subroutine does not return
    memcpy((ulong long)*(uint *)(param_1 + 2) + param_1[1],puVar5,(long long)(iVar2 + 1));
  }
  uStack_68 = 1;
  puStack_50 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_18 ^ (ulong long)stackBuffer);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long * FUN_18004b560(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  *param_1 = (long long)&SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = (long long)&SystemGlobalDataReference;
  param_1[3] = 0;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  if (*(char *)(_DAT_180c8a9a0 + 0x22) != '\0') {
    FUN_180627be0(param_1,_DAT_180c8a9a0 + 0x28);
    return param_1;
  }
  (**(code **)(*param_1 + 0x10))(param_1,&UNK_1809fd0a8,param_3,param_4,1,0xfffffffffffffffe);
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004b5f0(uint32_t *param_1)
void FUN_18004b5f0(uint32_t *param_1)

{
  int iVar1;
  int iVar2;
  
  iVar1 = *(int *)(**(long long **)(_DAT_180c82868 + 8) + 0x48);
  iVar2 = _Thrd_id();
  if (iVar2 != iVar1) {
    _DAT_180c9105c = *param_1;
  }
  return;
}



void* *
FUN_18004b640(void* *param_1,long long param_2,void* param_3,void* param_4)

{
  undefined *puVar1;
  
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_18098bc80;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  *(uint32_t *)(param_1 + 2) = *(uint32_t *)(param_2 + 0x10);
  puVar1 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar1 = *(undefined **)(param_2 + 8);
  }
  strcpy_s(param_1[1],0x20,puVar1,param_4,0xfffffffffffffffe);
  return param_1;
}




/**
 * @brief 设置系统字符串处理器入口点
 * 
 * 该函数设置系统字符串处理器的入口点指针，
 * 用于初始化字符串处理子系统。
 * 
 * @param stringProcessorPointer 字符串处理器指针的指针
 */
void SetSystemStringProcessorEntryPoint(void **stringProcessorPointer)

{
  *stringProcessorPointer = &UNK_1809fcca0;
  return;
}




/**
 * @brief 设置系统内存管理器入口点
 * 
 * 该函数设置系统内存管理器的入口点指针，
 * 用于初始化内存管理子系统。
 * 
 * @param memoryManagerPointer 内存管理器指针的指针
 */
void SetSystemMemoryManagerEntryPoint(void **memoryManagerPointer)

{
  *memoryManagerPointer = &UNK_1809fcc88;
  return;
}




// 函数: void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* initializationFlags)
/**
 * @brief 初始化系统入口点
 * 
 * 该函数负责初始化系统的主要入口点，设置系统上下文和入口点数据。
 * 它会检查系统上下文中的入口点指针，如果存在则调用相应的初始化函数。
 * 
 * @param systemContext 系统上下文指针，包含系统状态和配置信息
 * @param entryPointData 入口点数据指针，包含入口点相关的配置
 * @param memoryPool 内存池指针，用于系统内存分配
 * @param initializationFlags 初始化标志，控制初始化过程的行为
 */
void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* initializationFlags)

{
  void* *entryPointPtr;
  
  entryPointPtr = *(void* **)(systemContext + 0x10);
  if (entryPointPtr != (void* *)0x0) {
    FUN_18004b790(systemContext,*entryPointPtr,memoryPool,initializationFlags,0xfffffffffffffffe);
                    // WARNING: Subroutine does not return
    FUN_18064e900(entryPointPtr);
  }
  return;
}




// 函数: void FUN_18004b710(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004b710(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  
  puVar1 = *(void* **)(param_1 + 0x10);
  if (puVar1 != (void* *)0x0) {
    FUN_18004b790(param_1,*puVar1,param_3,param_4,0xfffffffffffffffe);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  return;
}




// 函数: void FUN_18004b730(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004b730(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  
  puVar1 = *(void* **)(param_1 + 0x10);
  if (puVar1 != (void* *)0x0) {
    FUN_18004b790(param_1,*puVar1,param_3,param_4,0xfffffffffffffffe);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  return;
}




// 函数: void FUN_18004b790(void* param_1,void* *param_2)
void FUN_18004b790(void* param_1,void* *param_2)

{
  if (param_2 != (void* *)0x0) {
    FUN_18004b790(param_1,*param_2);
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_2);
  }
  return;
}




// 函数: void FUN_18004b7a2(void* param_1)
void FUN_18004b7a2(void* param_1)

{
  void* *unaff_RBX;
  
  FUN_18004b790(param_1,*unaff_RBX);
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18004b7de(void)
void FUN_18004b7de(void)

{
  return;
}



void* * FUN_18004b7e0(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fcc88;
  if ((param_2 & 1) != 0) {
    free(param_1,8);
  }
  return param_1;
}



void* * FUN_18004b820(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fcca0;
  if ((param_2 & 1) != 0) {
    free(param_1,8);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004b860(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004b860(long long param_1,void* param_2,void* param_3,void* param_4)

{
  long long lVar1;
  int iVar2;
  ulong long *puVar3;
  long long lVar4;
  uint64_t systemInitializationFlag;
  void* uStackX_20;
  uint8_t auStack_78 [32];
  void* uStack_58;
  void* *puStack_50;
  char acStack_48 [32];
  ulong long uStack_28;
  
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_78;
  uStackX_18 = param_3;
  uStackX_20 = param_4;
  puVar3 = (ulong long *)func_0x00018004b9a0();
  uStack_58 = 0;
  puStack_50 = &uStackX_18;
  __stdio_common_vsprintf(*puVar3 | 1,acStack_48,0x20,param_2);
  lVar1 = -1;
  do {
    lVar4 = lVar1;
    lVar1 = lVar4 + 1;
  } while (acStack_48[lVar4 + 1] != '\0');
  iVar2 = (int)(lVar4 + 1);
  if ((0 < iVar2) && (*(uint *)(param_1 + 0x10) + iVar2 < 0x1f)) {
                    // WARNING: Subroutine does not return
    memcpy((ulong long)*(uint *)(param_1 + 0x10) + *(long long *)(param_1 + 8),acStack_48,
           (long long)((int)lVar4 + 2));
  }
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_28 ^ (ulong long)auStack_78);
}



void* * FUN_18004b920(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fcce0;
  if ((param_2 & 1) != 0) {
    free(param_1,8);
  }
  return param_1;
}



void* * FUN_18004b960(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fcd18;
  if ((param_2 & 1) != 0) {
    free(param_1,8);
  }
  return param_1;
}



int FUN_18004b9b0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  int iVar1;
  ulong long *puVar2;
  
  puVar2 = (ulong long *)func_0x00018004b9a0();
  iVar1 = __stdio_common_vsprintf(*puVar2 | 1,param_1,param_2,param_3,0,param_4);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  return iVar1;
}




// 函数: void FUN_18004ba30(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004ba30(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_1800582b0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004ba60(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004ba60(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_1800582b0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004ba90(void* *param_1)
void FUN_18004ba90(void* *param_1)

{
  int iVar1;
  
  _DAT_180c8a9b0 = *param_1;
  iVar1 = _Mtx_unlock(0x180c91970);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}




// 函数: void FUN_18004bad0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004bad0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058370(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004bb00(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004bb00(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058370(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004bb30(long long param_1)
void FUN_18004bb30(long long param_1)

{
  FUN_180057010(param_1 + 0x60);
  return;
}




// 函数: void FUN_18004bb60(long long param_1)
void FUN_18004bb60(long long param_1)

{
  FUN_180057010(param_1 + 0x60);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004bb90(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004bb90(void* param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  long long lVar2;
  int memoryCompareResult;
  long long lVar4;
  
  lVar2 = _DAT_180c8a9f0;
  iVar3 = (int)(*(long long *)(_DAT_180c8a9f0 + 0x38) - *(long long *)(_DAT_180c8a9f0 + 0x30) >> 3);
  lVar4 = 0;
  if (0 < iVar3) {
    do {
      puVar1 = *(void* **)(*(long long *)(lVar2 + 0x30) + lVar4 * 8);
      if (puVar1 != (void* *)0x0) {
        puVar1[4] = &SystemGlobalDataReference;
        if (puVar1[5] != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        puVar1[5] = 0;
        *(uint32_t *)(puVar1 + 7) = 0;
        puVar1[4] = &SystemMemoryAllocatorReference;
        *puVar1 = &SystemGlobalDataReference;
        if (puVar1[1] == 0) {
          puVar1[1] = 0;
          *(uint32_t *)(puVar1 + 3) = 0;
          *puVar1 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
          FUN_18064e900(puVar1);
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(*(long long *)(lVar2 + 0x30) + lVar4 * 8) = 0;
      lVar4 = lVar4 + 1;
    } while (lVar4 < iVar3);
  }
  *(void* *)(lVar2 + 0x38) = *(void* *)(lVar2 + 0x30);
  lVar4 = lVar2 + 0x50;
  FUN_180058370(lVar4,*(void* *)(lVar2 + 0x60),param_3,param_4,0xfffffffffffffffe);
  *(long long *)lVar4 = lVar4;
  *(long long *)(lVar2 + 0x58) = lVar4;
  *(void* *)(lVar2 + 0x60) = 0;
  *(uint8_t *)(lVar2 + 0x68) = 0;
  *(void* *)(lVar2 + 0x70) = 0;
  return;
}




// 函数: void FUN_18004bcb0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004bcb0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058420(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18004bce0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004bce0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058420(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}



void* * FUN_18004bd10(void* *param_1)

{
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809fcc58;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  FUN_180142b20(param_1 + 0xb);
  param_1[0x74] = 0;
  param_1[0x75] = 0;
  param_1[0x76] = 0;
  *(uint32_t *)(param_1 + 0x77) = 3;
  param_1[0x78] = 0;
  param_1[0x79] = 0;
  param_1[0x7a] = 0;
  *(uint32_t *)(param_1 + 0x7b) = 3;
  param_1[0x7c] = 0;
  param_1[0x7d] = 0;
  param_1[0x7e] = 0;
  *(uint32_t *)(param_1 + 0x7f) = 3;
  param_1[0x80] = 0;
  param_1[0x81] = 0;
  param_1[0x82] = 0;
  *(uint32_t *)(param_1 + 0x83) = 3;
  param_1[0x84] = 0;
  param_1[0x85] = 0;
  param_1[0x86] = 0;
  *(uint32_t *)(param_1 + 0x87) = 3;
  param_1[0x88] = 0;
  param_1[0x89] = 0;
  param_1[0x8a] = 0;
  *(uint32_t *)(param_1 + 0x8b) = 3;
  param_1[0x8c] = 0;
  param_1[0x8d] = 0;
  param_1[0x8e] = 0;
  *(uint32_t *)(param_1 + 0x8f) = 3;
  return param_1;
}




// 函数: void FUN_18004be50(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004be50(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 0x69) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18004be70(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004be70(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 0xb) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18004be90(long long param_1)
void FUN_18004be90(long long param_1)

{
  int iVar1;
  long long lVar2;
  uint uVar3;
  ulong long uVar5;
  ulong long uVar4;
  
  iVar1 = _Mtx_lock(param_1 + 0x28);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  uVar4 = 0;
  lVar2 = *(long long *)(param_1 + 8);
  uVar5 = uVar4;
  if (*(long long *)(param_1 + 0x10) - lVar2 >> 3 != 0) {
    do {
      if (*(long long *)(uVar5 + lVar2) != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(uVar5 + *(long long *)(param_1 + 8)) = 0;
      uVar3 = (int)uVar4 + 1;
      uVar4 = (ulong long)uVar3;
      lVar2 = *(long long *)(param_1 + 8);
      uVar5 = uVar5 + 8;
    } while ((ulong long)(long long)(int)uVar3 <
             (ulong long)(*(long long *)(param_1 + 0x10) - lVar2 >> 3));
  }
  *(long long *)(param_1 + 0x10) = lVar2;
  iVar1 = _Mtx_unlock(param_1 + 0x28);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}




// 函数: void FUN_18004bf50(long long *param_1)
void FUN_18004bf50(long long *param_1)

{
  long long lVar1;
  
  lVar1 = *param_1;
  if (lVar1 == 0) {
    *param_1 = 0;
    if ((long long *)param_1[2] != (long long *)0x0) {
      (**(code **)(*(long long *)param_1[2] + 0x38))();
    }
    if ((long long *)param_1[1] != (long long *)0x0) {
      (**(code **)(*(long long *)param_1[1] + 0x38))();
    }
    return;
  }
  if (*(long long *)(lVar1 + 8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  _Mtx_destroy_in_situ();
                    // WARNING: Subroutine does not return
  FUN_18064e900(lVar1);
}




// 函数: void FUN_18004bff0(long long param_1)
void FUN_18004bff0(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_18004c010(long long *param_1)
void FUN_18004c010(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x18) {
    FUN_18004bf50(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18004c030(long long *param_1)
void FUN_18004c030(long long *param_1)

{
  long long *plVar1;
  long long *plVar2;
  
  plVar1 = (long long *)param_1[1];
  for (plVar2 = (long long *)*param_1; plVar2 != plVar1; plVar2 = plVar2 + 1) {
    if ((long long *)*plVar2 != (long long *)0x0) {
      (**(code **)(*(long long *)*plVar2 + 0x38))();
    }
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



void* * FUN_18004c050(void* *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 3) = 3;
  return param_1;
}




// 函数: void ProcessSystemInitializationQueue(long long *queueHeader)
/**
 * @brief 处理系统初始化队列
 * 
 * 该函数负责处理系统初始化队列中的所有项目。它会遍历队列中的每个项目，
 * 调用相应的处理函数，直到所有项目都被处理完毕。
 * 
 * @param queueHeader 队列头指针，包含队列的起始和结束信息
 */
void ProcessSystemInitializationQueue(long long *queueHeader)

{
  long long queueEnd;
  long long currentQueueItem;
  
  queueEnd = queueHeader[1];
  for (currentQueueItem = *queueHeader; currentQueueItem != queueEnd; currentQueueItem = currentQueueItem + 0x18) {
    FUN_18004bf50(currentQueueItem);
  }
  if (*queueHeader == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18004c0b0(long long param_1)
void FUN_18004c0b0(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_18004c0d0(long long param_1)
void FUN_18004c0d0(long long param_1)

{
  undefined *puVar1;
  uint8_t auStack_a8 [8];
  undefined *stackParameterA;
  uint uStack_98;
  void* uStack_88;
  void* uStack_80;
  void* uStack_78;
  uint32_t uStack_70;
  void* uStack_68;
  void* uStack_60;
  void* uStack_58;
  uint32_t uStack_50;
  undefined *puStack_48;
  long long lStack_40;
  uint32_t uStack_30;
  void* uStack_28;
  
  uStack_28 = 0xfffffffffffffffe;
  if (param_1 == 0) {

// 函数: void FUN_18004c260(ulong long *param_1)
void FUN_18004c260(ulong long *param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = (void* *)*param_1;
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18004c290(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004c290(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 4) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18004c2b0(long long param_1)
void FUN_18004c2b0(long long param_1)

{
  uint uVar1;
  long long lVar2;
  
  if (param_1 == 0) {

// 函数: void FUN_18004c2c4(long long param_1)
void FUN_18004c2c4(long long param_1)

{
  uint uVar1;
  long long lVar2;
  
  lVar2 = -1;
  do {
    lVar2 = lVar2 + 1;
  } while (*(char *)(param_1 + lVar2) != '\0');
  uVar1 = (uint)lVar2;
  if (0x1fff < uVar1) {
    uVar1 = 0x1fff;
  }
                    // WARNING: Subroutine does not return
  memcpy(&DAT_180c84870,param_1,(long long)(int)uVar1);
}




// 函数: void FUN_18004c31f(void)
void FUN_18004c31f(void)

{
  code *pcVar1;
  
  FUN_1808fcdc8();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



uint8_t *
FUN_18004c330(uint8_t *param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  long long *plVar2;
  long long *plVar3;
  
  plVar3 = (long long *)(param_1 + 8);
  *plVar3 = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  *plVar3 = (long long)&SystemGlobalDataReference;
  *(void* *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  *(undefined **)(param_1 + 0x38) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x40) = 0;
  *(uint32_t *)(param_1 + 0x48) = 0;
  *(undefined **)(param_1 + 0x38) = &SystemGlobalDataReference;
  *(void* *)(param_1 + 0x50) = 0;
  *(void* *)(param_1 + 0x40) = 0;
  *(uint32_t *)(param_1 + 0x48) = 0;
  *(undefined **)(param_1 + 0x58) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x60) = 0;
  *(uint32_t *)(param_1 + 0x68) = 0;
  *(undefined **)(param_1 + 0x58) = &SystemGlobalDataReference;
  *(void* *)(param_1 + 0x70) = 0;
  *(void* *)(param_1 + 0x60) = 0;
  *(uint32_t *)(param_1 + 0x68) = 0;
  plVar1 = (long long *)(param_1 + 0x80);
  *plVar1 = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x88) = 0;
  *(uint32_t *)(param_1 + 0x90) = 0;
  *plVar1 = (long long)&SystemGlobalDataReference;
  *(void* *)(param_1 + 0x98) = 0;
  *(void* *)(param_1 + 0x88) = 0;
  *(uint32_t *)(param_1 + 0x90) = 0;
  plVar2 = (long long *)(param_1 + 0xa0);
  *plVar2 = (long long)&SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0xa8) = 0;
  *(uint32_t *)(param_1 + 0xb0) = 0;
  *plVar2 = (long long)&SystemGlobalDataReference;
  *(void* *)(param_1 + 0xb8) = 0;
  *(void* *)(param_1 + 0xa8) = 0;
  *(uint32_t *)(param_1 + 0xb0) = 0;
  *param_1 = 0;
  (**(code **)(*plVar3 + 0x10))(plVar3,&UNK_1809fd118,&SystemMemoryAllocatorReference,param_4,0xfffffffffffffffe);
  *(void* *)(param_1 + 0x28) = 0;
  *(uint32_t *)(param_1 + 0x30) = 0;
  param_1[0x7c] = 0;
  param_1[0xc9] = 1;
  (**(code **)(*plVar1 + 0x10))(plVar1,&DAT_1809fd128);
  (**(code **)(*plVar2 + 0x10))(plVar2,&SystemStringTemplate);
  *(uint32_t *)(param_1 + 0xc0) = 0x461c4000;
  *(uint32_t *)(param_1 + 0xc4) = 0x461c4000;
  param_1[200] = 0;
  *(void* *)(param_1 + 0xd0) = 0;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_18004c480(void* *param_1)

{
  long long *plVar1;
  long long *plVar2;
  long long *plVar3;
  long long lVar4;
  uint32_t *puVar5;
  void** systemRootNode;
  long long *plVar7;
  uint32_t *puVar8;
  uint32_t *puVar9;
  long long lVar10;
  void* *apuStackX_10 [3];
  
  *(uint8_t *)((long long)param_1 + 0x1c) = 0;
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  param_1[8] = 0;
  param_1[9] = 0;
  param_1[0xf] = 0;
  param_1[0x10] = 0;
  param_1[0x11] = 0;
  *(uint32_t *)(param_1 + 0x12) = 3;
  param_1[0x17] = &SystemMemoryAllocatorReference;
  param_1[0x18] = 0;
  *(uint32_t *)(param_1 + 0x19) = 0;
  param_1[0x17] = &SystemGlobalDataReference;
  param_1[0x1a] = 0;
  param_1[0x18] = 0;
  *(uint32_t *)(param_1 + 0x19) = 0;
  param_1[0x1b] = 0;
  param_1[0x1c] = 0;
  param_1[0x1d] = 0;
  *(uint32_t *)(param_1 + 0x1e) = 3;
  plVar1 = param_1 + 0x21;
  *plVar1 = 0;
  param_1[0x22] = 0;
  param_1[0x23] = 0;
  *(uint32_t *)(param_1 + 0x24) = 3;
  param_1[0x29] = &SystemMemoryAllocatorReference;
  param_1[0x2a] = 0;
  *(uint32_t *)(param_1 + 0x2b) = 0;
  param_1[0x29] = &SystemGlobalDataReference;
  param_1[0x2c] = 0;
  param_1[0x2a] = 0;
  *(uint32_t *)(param_1 + 0x2b) = 0;
  plVar2 = param_1 + 0x2e;
  *plVar2 = (long long)&SystemMemoryAllocatorReference;
  param_1[0x2f] = 0;
  *(uint32_t *)(param_1 + 0x30) = 0;
  *plVar2 = (long long)&SystemGlobalDataReference;
  param_1[0x31] = 0;
  param_1[0x2f] = 0;
  *(uint32_t *)(param_1 + 0x30) = 0;
  plVar3 = param_1 + 0x32;
  *plVar3 = (long long)&SystemMemoryAllocatorReference;
  param_1[0x33] = 0;
  *(uint32_t *)(param_1 + 0x34) = 0;
  *plVar3 = (long long)&UNK_18098bc80;
  param_1[0x33] = param_1 + 0x35;
  *(uint32_t *)(param_1 + 0x34) = 0;
  *(uint8_t *)(param_1 + 0x35) = 0;
  plVar7 = param_1 + 0x39;
  *plVar7 = (long long)&SystemMemoryAllocatorReference;
  param_1[0x3a] = 0;
  *(uint32_t *)(param_1 + 0x3b) = 0;
  *plVar7 = (long long)&SystemGlobalDataReference;
  param_1[0x3c] = 0;
  param_1[0x3a] = 0;
  *(uint32_t *)(param_1 + 0x3b) = 0;
  *(void* *)((long long)param_1 + 0x254) = 0;
  *(void* *)((long long)param_1 + 0x25c) = 0;
  param_1[0x4e] = &SystemMemoryAllocatorReference;
  param_1[0x4f] = 0;
  *(uint32_t *)(param_1 + 0x50) = 0;
  param_1[0x4e] = &SystemGlobalDataReference;
  param_1[0x51] = 0;
  param_1[0x4f] = 0;
  *(uint32_t *)(param_1 + 0x50) = 0;
  param_1[0x52] = &SystemMemoryAllocatorReference;
  param_1[0x53] = 0;
  *(uint32_t *)(param_1 + 0x54) = 0;
  param_1[0x52] = &SystemGlobalDataReference;
  param_1[0x55] = 0;
  param_1[0x53] = 0;
  *(uint32_t *)(param_1 + 0x54) = 0;
  param_1[0x58] = &SystemMemoryAllocatorReference;
  param_1[0x59] = 0;
  *(uint32_t *)(param_1 + 0x5a) = 0;
  param_1[0x58] = &SystemGlobalDataReference;
  param_1[0x5b] = 0;
  param_1[0x59] = 0;
  *(uint32_t *)(param_1 + 0x5a) = 0;
  puVar6 = param_1 + 0x5c;
  param_1[0x5f] = 0;
  *(uint32_t *)(param_1 + 0x61) = 3;
  *puVar6 = puVar6;
  param_1[0x5d] = puVar6;
  param_1[0x5e] = 0;
  *(uint8_t *)(param_1 + 0x5f) = 0;
  param_1[0x60] = 0;
  param_1[100] = 0;
  param_1[0x65] = 0;
  param_1[0x66] = 0;
  *(uint32_t *)(param_1 + 0x67) = 3;
  param_1[0x69] = &SystemMemoryAllocatorReference;
  param_1[0x6a] = 0;
  *(uint32_t *)(param_1 + 0x6b) = 0;
  param_1[0x69] = &SystemGlobalDataReference;
  param_1[0x6c] = 0;
  param_1[0x6a] = 0;
  *(uint32_t *)(param_1 + 0x6b) = 0;
  apuStackX_10[0] = param_1 + 0x6d;
  *apuStackX_10[0] = &SystemMemoryAllocatorReference;
  param_1[0x6e] = 0;
  *(uint32_t *)(param_1 + 0x6f) = 0;
  *apuStackX_10[0] = &SystemGlobalDataReference;
  param_1[0x70] = 0;
  param_1[0x6e] = 0;
  *(uint32_t *)(param_1 + 0x6f) = 0;
  *(uint32_t *)(param_1 + 4) = 0;
  *param_1 = 0;
  *(uint32_t *)(param_1 + 99) = 0;
  (**(code **)(*plVar7 + 0x10))
            (plVar7,&UNK_1809fd130,&SystemGlobalDataReference,&SystemMemoryAllocatorReference,0xfffffffffffffffe);
  *(uint32_t *)(param_1 + 0x3d) = 0;
  *(uint32_t *)((long long)param_1 + 0x1ed) = 0x1000001;
  param_1[0x62] = 0;
  *(uint8_t *)(param_1 + 0xc) = 0;
  *(uint32_t *)(param_1 + 0x20) = 0xffffffff;
  *(uint8_t *)(param_1 + 0x14) = 0;
  param_1[0x15] = 0;
  param_1[0x16] = 0;
  *(uint8_t *)((long long)param_1 + 0x1ec) = 0;
  LOCK();
  *(uint8_t *)(param_1 + 0x79) = 0;
  UNLOCK();
  (**(code **)(*plVar3 + 0x10))(plVar3,&UNK_1809fd140);
  (**(code **)(*plVar2 + 0x10))(plVar2,&SystemStringTemplate);
  *(uint8_t *)(param_1 + 0x2d) = 0;
  param_1[0x13] = 0;
  *(uint32_t *)(param_1 + 0x1f) = 0x1010101;
  *(undefined2 *)((long long)param_1 + 0xfc) = 0x101;
  *(uint32_t *)((long long)param_1 + 0x104) = 0xffffffff;
  lVar10 = 8;
  do {
    puVar9 = (uint32_t *)param_1[0x22];
    if (puVar9 < (uint32_t *)param_1[0x23]) {
      param_1[0x22] = puVar9 + 1;
      *puVar9 = 0;
    }
    else {
      puVar8 = (uint32_t *)*plVar1;
      lVar4 = (long long)puVar9 - (long long)puVar8 >> 2;
      if (lVar4 == 0) {
        lVar4 = 1;
LAB_18004c7ef:
        puVar5 = (uint32_t *)
                 CreateSystemThreadObject(_DAT_180c8ed18,lVar4 * 4,*(uint8_t *)(param_1 + 0x24));
        puVar9 = (uint32_t *)param_1[0x22];
        puVar8 = (uint32_t *)*plVar1;
      }
      else {
        lVar4 = lVar4 * 2;
        puVar5 = (uint32_t *)0x0;
        if (lVar4 != 0) goto LAB_18004c7ef;
      }
      if (puVar8 != puVar9) {
                    // WARNING: Subroutine does not return
        memmove(puVar5,puVar8,(long long)puVar9 - (long long)puVar8);
      }
      *puVar5 = 0;
      if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *plVar1 = (long long)puVar5;
      param_1[0x22] = puVar5 + 1;
      param_1[0x23] = puVar5 + lVar4;
    }
    lVar10 = lVar10 + -1;
    if (lVar10 == 0) {
      *(uint32_t *)((long long)param_1 + 0x24) = 0;
      *(uint32_t *)((long long)param_1 + 0x29) = 0x1010101;
      *(uint8_t *)(param_1 + 5) = 1;
      *(uint32_t *)(param_1 + 0x71) = 0x3f800000;
      *(uint8_t *)(param_1 + 0x76) = 1;
      *(uint32_t *)(param_1 + 0x25) = 0;
      param_1[0x56] = 0;
      *(void* *)((long long)param_1 + 0x224) = 0;
      *(uint8_t *)((long long)param_1 + 0x22c) = 0;
      *(uint32_t *)(param_1 + 0x40) = 0;
      param_1[0x41] = 0;
      puVar6 = _DAT_180c8ed58;
      if (_DAT_180c8ed58 == (void* *)0x0) {
        QueryPerformanceCounter(apuStackX_10);
        puVar6 = apuStackX_10[0];
      }
      param_1[0x42] = (double)((long long)puVar6 - _DAT_180c8ed48) * _DAT_180c8ed50;
      *(uint32_t *)(param_1 + 0x44) = 0;
      *(uint8_t *)((long long)param_1 + 0x264) = 0;
      *(uint32_t *)(param_1 + 0x4d) = 0;
      *(void* *)((long long)param_1 + 500) = 0;
      *(uint8_t *)(param_1 + 0x28) = 0;
      *(uint8_t *)((long long)param_1 + 0x1fc) = 0;
      param_1[0x7b] = 0;
      param_1[0x57] = 0;
      lVar10 = FUN_18062b1e0(_DAT_180c8ed18,0xc,4,3);
      *(uint8_t *)(lVar10 + 8) = 0;
      param_1[6] = lVar10;
      param_1[0x27] = 0;
      *(uint8_t *)(param_1 + 7) = 0;
      *(uint32_t *)((long long)param_1 + 0x3c) = 0xffffffff;
      param_1[0x43] = 0;
      *(uint32_t *)(param_1 + 0x26) = 0xffffffff;
      puVar6 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x30,8,3);
      puVar6[1] = 0;
      puVar6[2] = 0;
      puVar6[3] = 0;
      puVar6[4] = 0;
      puVar6[5] = 0;
      *puVar6 = &UNK_180a21690;
      *puVar6 = &UNK_180a21720;
      *(uint32_t *)(puVar6 + 1) = 0;
      *puVar6 = &UNK_1809fe070;
      puVar6[2] = 0;
      puVar6[3] = 0;
      puVar6[4] = 0;
      *(uint32_t *)(puVar6 + 5) = 3;
      param_1[0x78] = puVar6;
      return param_1;
    }
  } while( true );
}




/**
 * 系统组件初始化器 - 初始化核心系统组件
 * 负责调用系统组件的初始化函数指针
 * 
 * @param param_1 系统组件指针的指针
 */
void FUN_18004ca00(long long *param_1)

{
  if ((long long *)*param_1 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_1 + 0x38))();
  }
  return;
}



void* *
FUN_18004ca30(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  if (param_1[2] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0x30,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_18004caa0(void* *param_1)
void FUN_18004caa0(void* *param_1)

{
  if (param_1[2] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004caf0(long long param_1)
void FUN_18004caf0(long long param_1)

{
  long long lVar1;
  int iVar2;
  int memoryCompareResult;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  
  lVar1 = _DAT_180c86920;
  iVar2 = *(int *)(_DAT_180c86920 + 0xd90) + -1;
  iVar3 = 0;
  if ((-1 < iVar2) && (iVar3 = iVar2, 3 < iVar2)) {
    iVar3 = 3;
  }
  fVar8 = (float)iVar3;
  fVar7 = fVar8 * 1.6750001 + 2.4750001;
  fVar5 = fVar8 * 4.4666667 + 6.6000004;
  fVar6 = fVar8 * 3.3500001 + 4.9500003;
  fVar4 = fVar7 + fVar6;
  *(float *)(param_1 + 0x38c) = fVar6 * fVar6;
  fVar7 = fVar7 + fVar4;
  *(float *)(param_1 + 0x390) = fVar4 * fVar4;
  fVar4 = fVar5 + fVar7;
  *(float *)(param_1 + 0x394) = fVar7 * fVar7;
  fVar5 = fVar5 + fVar4;
  *(float *)(param_1 + 0x398) = fVar4 * fVar4;
  fVar4 = fVar8 * 13.400001 + 19.800001 + fVar5;
  *(float *)(param_1 + 0x39c) = fVar5 * fVar5;
  fVar5 = fVar8 * 17.866667 + 26.400002 + fVar4;
  *(float *)(param_1 + 0x3a0) = fVar4 * fVar4;
  *(float *)(param_1 + 0x3a4) = fVar5 * fVar5;
  *(uint32_t *)(param_1 + 0x3a8) = 0x7f7fffff;
  *(uint *)(param_1 + 0x3ac) = (uint)(*(int *)(lVar1 + 0xd90) == 0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004cc20(long long *param_1)
void FUN_18004cc20(long long *param_1)

{
  void* *puVar1;
  long long lVar2;
  
  puVar1 = (void* *)param_1[0x7c];
  if (puVar1 != (void* *)0x0) {
    puVar1[0x14] = &SystemGlobalDataReference;
    if (puVar1[0x15] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar1[0x15] = 0;
    *(uint32_t *)(puVar1 + 0x17) = 0;
    puVar1[0x14] = &SystemMemoryAllocatorReference;
    puVar1[0x10] = &SystemGlobalDataReference;
    if (puVar1[0x11] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar1[0x11] = 0;
    *(uint32_t *)(puVar1 + 0x13) = 0;
    puVar1[0x10] = &SystemMemoryAllocatorReference;
    if (puVar1[0xc] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    FUN_180057170();
    FUN_180057170();
    *puVar1 = &SystemGlobalDataReference;
    if (puVar1[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar1[1] = 0;
    *(uint32_t *)(puVar1 + 3) = 0;
    *puVar1 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  param_1[0x7c] = 0;
  puVar1 = (void* *)param_1[1];
  if (puVar1 != (void* *)0x0) {
    lVar2 = __RTCastToVoid(puVar1);
    *puVar1 = &UNK_180a08db0;
    FUN_18005e570(_DAT_180c82868,puVar1[0x28]);
    puVar1[0x28] = 0;
    puVar1[0x29] = &SystemGlobalDataReference;
    if (puVar1[0x2a] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar1[0x2a] = 0;
    *(uint32_t *)(puVar1 + 0x2c) = 0;
    puVar1[0x29] = &SystemMemoryAllocatorReference;
    FUN_180174950();
    if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar2);
    }
  }
  param_1[1] = 0;
  lVar2 = *param_1;
  if (lVar2 != 0) {
    FUN_180057d70(lVar2);
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar2);
  }
  *param_1 = 0;
  lVar2 = _DAT_180c86918;
  if (_DAT_180c86918 != 0) {
    FUN_180057550();
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar2);
  }
  _DAT_180c86918 = 0;
  FUN_1800578a0();
  _DAT_180c86950 = 0;
  if (param_1[6] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[6] = 0;
  param_1[0x6d] = (long long)&SystemGlobalDataReference;
  if (param_1[0x6e] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x6e] = 0;
  *(uint32_t *)(param_1 + 0x70) = 0;
  param_1[0x6d] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x69] = (long long)&SystemGlobalDataReference;
  if (param_1[0x6a] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x6a] = 0;
  *(uint32_t *)(param_1 + 0x6c) = 0;
  param_1[0x69] = (long long)&SystemMemoryAllocatorReference;
  FUN_180057830();
  FUN_18005d260(param_1 + 0x5c,param_1[0x5e]);
  param_1[0x58] = (long long)&SystemGlobalDataReference;
  if (param_1[0x59] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x59] = 0;
  *(uint32_t *)(param_1 + 0x5b) = 0;
  param_1[0x58] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x52] = (long long)&SystemGlobalDataReference;
  if (param_1[0x53] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x53] = 0;
  *(uint32_t *)(param_1 + 0x55) = 0;
  param_1[0x52] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x4e] = (long long)&SystemGlobalDataReference;
  if (param_1[0x4f] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x4f] = 0;
  *(uint32_t *)(param_1 + 0x51) = 0;
  param_1[0x4e] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x39] = (long long)&SystemGlobalDataReference;
  if (param_1[0x3a] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x3a] = 0;
  *(uint32_t *)(param_1 + 0x3c) = 0;
  param_1[0x39] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x32] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x2e] = (long long)&SystemGlobalDataReference;
  if (param_1[0x2f] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x2f] = 0;
  *(uint32_t *)(param_1 + 0x31) = 0;
  param_1[0x2e] = (long long)&SystemMemoryAllocatorReference;
  param_1[0x29] = (long long)&SystemGlobalDataReference;
  if (param_1[0x2a] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x2a] = 0;
  *(uint32_t *)(param_1 + 0x2c) = 0;
  param_1[0x29] = (long long)&SystemMemoryAllocatorReference;
  if (param_1[0x21] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  FUN_18005d580();
  param_1[0x17] = (long long)&SystemGlobalDataReference;
  if (param_1[0x18] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x18] = 0;
  *(uint32_t *)(param_1 + 0x1a) = 0;
  param_1[0x17] = (long long)&SystemMemoryAllocatorReference;
  if (param_1[0xf] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if ((long long *)param_1[9] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[9] + 0x38))();
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x00018004d2c7)
// WARNING: Removing unreachable block (ram,0x00018004d2d0)
// WARNING: Removing unreachable block (ram,0x00018004d2da)
// WARNING: Removing unreachable block (ram,0x00018004d2df)
// WARNING: Removing unreachable block (ram,0x00018004d2f2)
// WARNING: Removing unreachable block (ram,0x00018004d30d)
// WARNING: Removing unreachable block (ram,0x00018004d328)
// WARNING: Removing unreachable block (ram,0x00018004d343)
// WARNING: Removing unreachable block (ram,0x00018004d35e)
// WARNING: Removing unreachable block (ram,0x00018004d379)
// WARNING: Removing unreachable block (ram,0x00018004d4a0)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004d020(void* param_1,long long param_2)
void FUN_18004d020(void* param_1,long long param_2)

{
  byte bVar1;
  uint8_t uVar2;
  void* *puVar3;
  void* *puVar4;
  char cVar5;
  int iVar6;
  uint32_t uVar7;
  uint uVar8;
  long long lVar9;
  long long lVar10;
  uint8_t *puVar11;
  char *pcVar12;
  uint32_t *puVar13;
  uint8_t *puVar14;
  byte *pbVar15;
  uint8_t *puVar16;
  undefined *puVar17;
  undefined *puVar18;
  int iVar19;
  long long lVar20;
  ulong long uVar21;
  void* *puVar22;
  uint uVar23;
  long long lVar24;
  ulong long uVar25;
  uint uVar26;
  void* uVar27;
  ulong long uVar28;
  ulong long uVar29;
  uint uVar30;
  bool bVar31;
  uint32_t extraout_XMM0_Da;
  uint32_t extraout_XMM0_Da_00;
  uint8_t auStack_368 [32];
  uint8_t uStack_348;
  char cStack_338;
  char cStack_337;
  char acStack_336 [2];
  uint uStack_334;
  undefined *puStack_330;
  char *pcStack_328;
  uint uStack_320;
  void* uStack_318;
  undefined *puStack_310;
  uint8_t *puStack_308;
  uint uStack_300;
  void* uStack_2f8;
  ulong long uStack_2f0;
  undefined *puStack_2e8;
  uint8_t *puStack_2e0;
  uint uStack_2d8;
  ulong long uStack_2d0;
  undefined *puStack_2c8;
  uint8_t *puStack_2c0;
  uint32_t uStack_2b8;
  ulong long uStack_2b0;
  undefined *puStack_2a8;
  undefined *puStack_2a0;
  uint uStack_298;
  uint32_t uStack_290;
  uint32_t uStack_28c;
  undefined *puStack_288;
  uint32_t *puStack_280;
  uint32_t uStack_278;
  void* uStack_270;
  undefined *puStack_268;
  long long lStack_260;
  undefined *puStack_258;
  long long lStack_250;
  uint uStack_248;
  uint32_t uStack_240;
  uint32_t uStack_23c;
  undefined *puStack_238;
  long long lStack_230;
  uint uStack_228;
  uint32_t uStack_220;
  undefined *puStack_218;
  long long lStack_210;
  uint uStack_208;
  uint32_t uStack_200;
  undefined *puStack_1f8;
  long long lStack_1f0;
  uint uStack_1e8;
  uint32_t uStack_1e0;
  undefined *puStack_1d8;
  long long lStack_1d0;
  uint uStack_1c8;
  uint32_t uStack_1c0;
  undefined *puStack_1b8;
  undefined *puStack_1b0;
  int iStack_1a8;
  uint32_t uStack_1a0;
  undefined *puStack_198;
  undefined *puStack_190;
  int iStack_188;
  uint32_t uStack_180;
  undefined *puStack_178;
  long long lStack_170;
  uint32_t uStack_160;
  void* uStack_158;
  ulong long uStack_150;
  undefined *puStack_148;
  long long lStack_140;
  uint32_t uStack_130;
  undefined *puStack_128;
  long long lStack_120;
  uint32_t uStack_110;
  undefined *puStack_108;
  long long lStack_100;
  uint32_t uStack_f0;
  void* *puStack_e8;
  void* *puStack_e0;
  void* uStack_d8;
  uint32_t uStack_d0;
  undefined *puStack_c8;
  long long lStack_c0;
  uint32_t uStack_b0;
  void* uStack_a8;
  undefined *stackParameterB;
  uint8_t *pstackParameterC;
  uint32_t uStack_88;
  uint8_t auStack_80 [72];
  ulong long uStack_38;
  
  lVar24 = _DAT_180c86870;
  uStack_a8 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_368;
  puVar11 = (uint8_t *)0x0;
  uStack_334 = 0;
  lStack_260 = _DAT_180c86870;
  cStack_338 = '\0';
  puVar17 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar17 = *(undefined **)(param_2 + 8);
  }
  lVar20 = -1;
  do {
    lVar9 = lVar20;
    lVar20 = lVar9 + 1;
  } while (puVar17[lVar20] != '\0');
  uVar21 = lVar9 + 2;
  puStack_310 = &SystemGlobalDataReference;
  uStack_2f8 = 0;
  puStack_308 = (uint8_t *)0x0;
  uStack_300 = 0;
  puStack_268 = puVar17;
  uStack_150 = uVar21;
  (**(code **)(*(long long *)(_DAT_180c86870 + 0x2c0) + 0x10))
            ((long long *)(_DAT_180c86870 + 0x2c0),puVar17);
  uStack_2f0 = 0;
  puVar14 = puVar11;
  if (uVar21 != 0) {
    do {
      bVar1 = puVar17[uStack_2f0];
      uVar8 = (uint)puVar14;
      if ((bVar1 & 0xdf) == 0) {
        lVar20 = lVar24 + 0x2e0;
        lVar9 = CreateSystemThreadObject(_DAT_180c8ed18,0x40,*(uint8_t *)(lVar24 + 0x308));
        FUN_180627ae0(lVar9 + 0x20,&puStack_310);
        lVar10 = FUN_1800590b0(lVar20,&cStack_337,lVar9 + 0x20);
        if (cStack_337 != '\0') {
          if (lVar10 == lVar20) goto LAB_18004d1c1;
          if (*(int *)(lVar10 + 0x30) == 0) goto LAB_18004d1b9;
          if (*(int *)(lVar9 + 0x30) == 0) goto LAB_18004d1c1;
          pbVar15 = *(byte **)(lVar10 + 0x28);
          lVar24 = *(long long *)(lVar9 + 0x28) - (long long)pbVar15;
          goto LAB_18004d1a2;
        }
        FUN_18005d1f0(extraout_XMM0_Da,lVar9);
        if (uVar8 == 8) {
          iVar6 = strcmp(puVar11,&UNK_1809fd150);
          bVar31 = iVar6 == 0;
        }
        else {
          bVar31 = false;
        }
        if (bVar31) {

// 函数: void FUN_18004e5f0(long long param_1)
void FUN_18004e5f0(long long param_1)

{
  int *piVar1;
  uint32_t uVar2;
  int memoryCompareResult;
  bool bVar4;
  void* uVar5;
  bool bVar6;
  
  piVar1 = (int *)(param_1 + 0x3d0);
  if (((int)*(float *)(_DAT_180c86950 + 0x17ec) == *(int *)(param_1 + 0x3cc)) &&
     ((int)*(float *)(_DAT_180c86950 + 0x17f0) == *piVar1)) {
    bVar4 = false;
  }
  else {
    bVar4 = true;
    FUN_180092820(_DAT_180c86950,*(int *)(param_1 + 0x3cc),*piVar1);
  }
  if (*(int *)(*(long long *)(param_1 + 8) + 0x38) == 2) {
    if ((*(char *)(param_1 + 0x3d4) != '\0') || (*(char *)(param_1 + 0x3d5) != '\0')) {
      uVar2 = *(uint32_t *)(_DAT_180c86920 + 0x1ea0);
      FUN_18005ca20(_DAT_180c86920,0);
      FUN_1801725e0(*(void* *)(param_1 + 8),*(uint32_t *)(param_1 + 0x3cc),*piVar1,
                    *(uint8_t *)(param_1 + 0x3d5));
      FUN_1800a3880(_DAT_180c86938,*(uint32_t *)(param_1 + 0x3cc),*piVar1,1);
      FUN_18005ca20(_DAT_180c86920,uVar2);
      FUN_1801725e0(*(void* *)(param_1 + 8),*(uint32_t *)(param_1 + 0x3cc),*piVar1,
                    *(uint8_t *)(param_1 + 0x3d5));
      bVar6 = true;
      goto LAB_18004e721;
    }
  }
  else {
    if (*(char *)(param_1 + 0x3d4) != '\0') {
      iVar3 = *(int *)(_DAT_180c86920 + 0x1ea0);
      if ((*(char *)(param_1 + 0x3d5) != '\0') || (bVar4)) {
        uVar5 = 1;
      }
      else {
        uVar5 = 0;
      }
      FUN_1801725e0(*(long long *)(param_1 + 8),*(uint32_t *)(param_1 + 0x3cc),*piVar1,uVar5);
      bVar6 = iVar3 == 2;
      goto LAB_18004e721;
    }
    if (!bVar4) {
      return;
    }
  }
  bVar6 = false;
LAB_18004e721:
  FUN_1800a3880(_DAT_180c86938,*(uint32_t *)(param_1 + 0x3cc),*piVar1,bVar6);
  if (!bVar4) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_180062300(_DAT_180c86928,&UNK_1809fd4d8,*(uint32_t *)(param_1 + 0x3cc),*piVar1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t FUN_18004e7a0(void)

{
  uint8_t auVar1 [16];
  long long lVar2;
  long long lVar3;
  void* *puVar4;
  uint uVar5;
  int iVar6;
  undefined *puStack_c8;
  long long lStack_c0;
  uint uStack_b8;
  ulong long uStack_b0;
  undefined *puStack_a8;
  long long lStack_a0;
  uint uStack_98;
  void* stackParameterC;
  void* uStack_88;
  uint8_t auStack_80 [32];
  uint8_t auStack_60 [40];
  
  lVar3 = _DAT_180c86870;
  uStack_88 = 0xfffffffffffffffe;
  auVar1 = *(uint8_t (*) [16])
            (*(long long *)(_DAT_180c86870 + 8) + 0xcc +
            (ulong long)(*(uint *)(*(long long *)(_DAT_180c86870 + 8) + 0x13c) & 1) * 0x48);
  if ((auVar1._12_4_ != 0) && (auVar1._8_4_ != 0)) {
    puStack_c8 = &SystemGlobalDataReference;
    uStack_b0 = 0;
    lStack_c0 = 0;
    uStack_b8 = 0;
    FUN_180628380(&puStack_c8,auVar1._0_4_);
    uVar5 = uStack_b8 + 1;
    FUN_1806277c0(&puStack_c8,uVar5);
    *(undefined2 *)((ulong long)uStack_b8 + lStack_c0) = 0x2c;
    uStack_b8 = uVar5;
    FUN_180628380(&puStack_c8,auVar1._0_8_ >> 0x20);
    uVar5 = uStack_b8 + 1;
    FUN_1806277c0(&puStack_c8,uVar5);
    *(undefined2 *)((ulong long)uStack_b8 + lStack_c0) = 0x2c;
    uStack_b8 = uVar5;
    FUN_180628380(&puStack_c8,auVar1._8_8_ & 0xffffffff);
    iVar6 = uStack_b8 + 1;
    FUN_1806277c0(&puStack_c8,iVar6);
    *(undefined2 *)((ulong long)uStack_b8 + lStack_c0) = 0x2c;
    uStack_b8 = iVar6;
    FUN_180628380(&puStack_c8,auVar1._8_8_ >> 0x20);
    puVar4 = (void* *)FUN_180627ae0(auStack_80,&puStack_c8);
    FUN_18005c8a0(_DAT_180c868b0 + 0xe30,puVar4);
    *puVar4 = &SystemGlobalDataReference;
    if (puVar4[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar4[1] = 0;
    *(uint32_t *)(puVar4 + 3) = 0;
    *puVar4 = &SystemMemoryAllocatorReference;
    puStack_c8 = &SystemGlobalDataReference;
    if (lStack_c0 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_c0 = 0;
    uStack_b0 = uStack_b0 & 0xffffffff00000000;
    puStack_c8 = &SystemMemoryAllocatorReference;
  }
  lVar2 = *(long long *)(lVar3 + 8);
  auVar1 = *(uint8_t (*) [16])(lVar2 + 0xdc + (ulong long)(*(uint *)(lVar2 + 0x13c) & 1) * 0x48);
  if ((auVar1._12_4_ != 0) && (auVar1._8_4_ != 0)) {
    puStack_a8 = &SystemGlobalDataReference;
    stackParameterC = 0;
    lStack_a0 = 0;
    uStack_98 = 0;
    FUN_180628380(&puStack_a8,auVar1._0_4_);
    uVar5 = uStack_98 + 1;
    FUN_1806277c0(&puStack_a8,uVar5);
    *(undefined2 *)((ulong long)uStack_98 + lStack_a0) = 0x2c;
    uStack_98 = uVar5;
    FUN_180628380(&puStack_a8,auVar1._0_8_ >> 0x20);
    uVar5 = uStack_98 + 1;
    FUN_1806277c0(&puStack_a8,uVar5);
    *(undefined2 *)((ulong long)uStack_98 + lStack_a0) = 0x2c;
    uStack_98 = uVar5;
    FUN_180628380(&puStack_a8,auVar1._8_8_ & 0xffffffff);
    iVar6 = uStack_98 + 1;
    FUN_1806277c0(&puStack_a8,iVar6);
    *(undefined2 *)((ulong long)uStack_98 + lStack_a0) = 0x2c;
    uStack_98 = iVar6;
    FUN_180628380(&puStack_a8,auVar1._8_8_ >> 0x20);
    puVar4 = (void* *)FUN_180627ae0(auStack_60,&puStack_a8);
    FUN_18005c8a0(_DAT_180c868b0 + 0xef0,puVar4);
    *puVar4 = &SystemGlobalDataReference;
    if (puVar4[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar4[1] = 0;
    *(uint32_t *)(puVar4 + 3) = 0;
    *puVar4 = &SystemMemoryAllocatorReference;
    puStack_a8 = &SystemGlobalDataReference;
    if (lStack_a0 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return *(uint32_t *)(*(long long *)(lVar3 + 8) + 0x13c);
}



// WARNING: Removing unreachable block (ram,0x00018004ed08)
// WARNING: Removing unreachable block (ram,0x00018004ed22)
// WARNING: Removing unreachable block (ram,0x00018004ed36)
// WARNING: Removing unreachable block (ram,0x00018004ed44)
// WARNING: Removing unreachable block (ram,0x00018004ed48)
// WARNING: Removing unreachable block (ram,0x00018004ed5b)
// WARNING: Removing unreachable block (ram,0x00018004ed5f)
// WARNING: Removing unreachable block (ram,0x00018004ed72)
// WARNING: Removing unreachable block (ram,0x00018004ed76)
// WARNING: Removing unreachable block (ram,0x00018004ed89)
// WARNING: Removing unreachable block (ram,0x00018004ed8d)
// WARNING: Removing unreachable block (ram,0x00018004edbc)
// WARNING: Removing unreachable block (ram,0x00018004edc0)
// WARNING: Removing unreachable block (ram,0x00018004edd3)
// WARNING: Removing unreachable block (ram,0x00018004ee38)
// WARNING: Removing unreachable block (ram,0x00018004ee52)
// WARNING: Removing unreachable block (ram,0x00018004ee66)
// WARNING: Removing unreachable block (ram,0x00018004ee74)
// WARNING: Removing unreachable block (ram,0x00018004ee78)
// WARNING: Removing unreachable block (ram,0x00018004ee8b)
// WARNING: Removing unreachable block (ram,0x00018004ee8f)
// WARNING: Removing unreachable block (ram,0x00018004eea2)
// WARNING: Removing unreachable block (ram,0x00018004eea6)
// WARNING: Removing unreachable block (ram,0x00018004eeb6)
// WARNING: Removing unreachable block (ram,0x00018004eeba)
// WARNING: Removing unreachable block (ram,0x00018004eeec)
// WARNING: Removing unreachable block (ram,0x00018004eef0)
// WARNING: Removing unreachable block (ram,0x00018004ef03)
// WARNING: Removing unreachable block (ram,0x00018004ebd5)
// WARNING: Removing unreachable block (ram,0x00018004ebef)
// WARNING: Removing unreachable block (ram,0x00018004ec03)
// WARNING: Removing unreachable block (ram,0x00018004ec11)
// WARNING: Removing unreachable block (ram,0x00018004ec15)
// WARNING: Removing unreachable block (ram,0x00018004ec28)
// WARNING: Removing unreachable block (ram,0x00018004ec2c)
// WARNING: Removing unreachable block (ram,0x00018004ec3f)
// WARNING: Removing unreachable block (ram,0x00018004ec43)
// WARNING: Removing unreachable block (ram,0x00018004ec56)
// WARNING: Removing unreachable block (ram,0x00018004ec5a)
// WARNING: Removing unreachable block (ram,0x00018004ec88)
// WARNING: Removing unreachable block (ram,0x00018004ec90)
// WARNING: Removing unreachable block (ram,0x00018004eca3)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004eb00(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18004eb00(void* param_1,void* param_2,void* param_3,void* param_4)

{
  uint uVar1;
  uint uVar2;
  long long lVar3;
  long long lVar4;
  ulong long uVar5;
  undefined *puStack_68;
  long long lStack_60;
  uint uStack_58;
  void* uStack_50;
  
  lVar3 = _DAT_180c868b0;
  puStack_68 = &SystemGlobalDataReference;
  uStack_50 = 0;
  lStack_60 = 0;
  uStack_58 = 0;
  if (*(int *)(_DAT_180c86920 + 0x1ea0) == 0) {
    uVar1 = *(uint *)(_DAT_180c868b0 + 0xe40);
    uVar5 = (ulong long)uVar1;
    if (*(long long *)(_DAT_180c868b0 + 0xe38) != 0) {
      FUN_1806277c0(&puStack_68,uVar5,param_3,param_4,0xfffffffffffffffe);
    }
    if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
      memcpy(lStack_60,*(void* *)(lVar3 + 0xe38),uVar5);
    }
    if (lStack_60 != 0) {
      *(uint8_t *)(uVar5 + lStack_60) = 0;
    }
    uStack_50 = CONCAT44(*(uint32_t *)(lVar3 + 0xe4c),(uint32_t)uStack_50);
  }
  lVar3 = _DAT_180c868b0;
  uStack_58 = 0;
  uVar1 = *(uint *)(_DAT_180c868b0 + 0xf00);
  uVar5 = (ulong long)uVar1;
  if (*(long long *)(_DAT_180c868b0 + 0xef8) != 0) {
    FUN_1806277c0(&puStack_68,uVar5);
  }
  if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(lStack_60,*(void* *)(lVar3 + 0xef8),uVar5);
  }
  if (lStack_60 != 0) {
    *(uint8_t *)(uVar5 + lStack_60) = 0;
  }
  lVar4 = _DAT_180c868b0;
  uStack_50 = CONCAT44(*(uint32_t *)(lVar3 + 0xf0c),(uint32_t)uStack_50);
  uVar2 = *(uint *)(_DAT_180c868b0 + 0xfc0);
  uVar5 = (ulong long)uVar2;
  uStack_58 = uVar1;
  if (*(long long *)(_DAT_180c868b0 + 0xfb8) != 0) {
    FUN_1806277c0(&puStack_68,uVar5);
  }
  if (uVar2 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(lStack_60,*(void* *)(lVar4 + 0xfb8),uVar5);
  }
  if (lStack_60 != 0) {
    *(uint8_t *)(uVar5 + lStack_60) = 0;
  }
  uStack_50 = CONCAT44(*(uint32_t *)(lVar4 + 0xfcc),(uint32_t)uStack_50);
  puStack_68 = &SystemGlobalDataReference;
  if (lStack_60 != 0) {
    uStack_58 = uVar2;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


/**
 * 系统清理器 - 执行系统清理操作
 * 负责在系统关闭时清理内存和资源
 * 
 */
void FUN_18004ef60(void)

{
  int iVar1;
  long long lVar2;
  long long lVar3;
  long long lVar4;
  int *piVar5;
  void** systemRootNode;
  uint32_t *systemPreviousNode;
  undefined *puVar8;
  char cVar9;
  float fVar10;
  uint32_t uVar11;
  float fVar12;
  uint8_t auStack_208 [32];
  long long lStack_1e8;
  long long lStack_1d8;
  long long lStack_1d0;
  void* *apuStack_1c8 [10];
  void* uStack_178;
  uint8_t auStack_170 [8];
  undefined *puStack_168;
  uint8_t *puStack_160;
  uint32_t uStack_158;
  uint8_t auStack_150 [264];
  ulong long uStack_48;
  
  lVar3 = _DAT_180c86870;
  uStack_178 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_208;
  if (*(undefined **)*_DAT_180c8ed08 == &UNK_18098bb88) {
    cVar9 = *(int *)(_DAT_180c8a9c8 + 0xe0) != 0;
  }
  else {
    cVar9 = (**(code **)(*(undefined **)*_DAT_180c8ed08 + 0x48))();
  }
  if (cVar9 == '\0') {
    _DAT_180bf65b8 = timeGetTime();
  }
  else {
    _DAT_180bf65b8 = 0xb061;
  }
  lVar2 = _DAT_180c86920;
  _DAT_180bf65b8 = _DAT_180bf65b8 ^ 0x41c64e6d;
  if ((*(long long *)(_DAT_180c86890 + 0x7ab8) == 0) || (*(int *)(_DAT_180c86920 + 0x540) < 1)) {
    if (*(int *)(_DAT_180c86920 + 0x2140) == 0) {
      fVar10 = *(float *)(_DAT_180c86920 + 0x20d0);
    }
    else {
      fVar10 = 100.0;
    }
    fVar10 = fVar10 * 0.01;
  }
  else {
    fVar10 = 1.0;
  }
  *(float *)(lVar3 + 0x234) = fVar10;
  *(uint32_t *)(lVar3 + 0x238) = 0x3f800000;
  fVar12 = 1.0;
  if (*(int *)(lVar2 + 0x1ea0) == 1) {
    iVar1 = *(int *)(lVar2 + 0x1d50);
    piVar5 = (int *)FUN_180171f10(*(void* *)(_DAT_180c86870 + 8),auStack_170);
    fVar12 = (float)iVar1 / (float)*piVar5;
    fVar10 = fVar12 * *(float *)(lVar3 + 0x234);
    fVar12 = fVar12 * *(float *)(lVar3 + 0x238);
  }
  if (0.2 <= fVar10) {
    if (1.0 <= fVar10) {
      fVar10 = 1.0;
    }
  }
  else {
    fVar10 = 0.2;
  }
  *(float *)(lVar3 + 0x234) = fVar10;
  fVar10 = 0.2;
  if ((0.2 <= fVar12) && (fVar10 = fVar12, 1.0 <= fVar12)) {
    fVar10 = 1.0;
  }
  *(float *)(lVar3 + 0x238) = fVar10;
  *(uint8_t *)(lVar3 + 0x22d) = 0;
  uVar11 = log2f();
  *(uint32_t *)(lVar3 + 0x230) = uVar11;
  uVar11 = log2f();
  *(uint32_t *)(lVar3 + 0x240) = uVar11;
  uVar11 = log2f();
  *(uint32_t *)(lVar3 + 0x244) = uVar11;
  uVar11 = log2f();
  *(uint32_t *)(lVar3 + 0x248) = uVar11;
  uVar11 = log2f();
  *(uint32_t *)(lVar3 + 0x24c) = uVar11;
  uVar11 = log2f(*(float *)(_DAT_180c86920 + 0x2220) * 0.01);
  *(uint32_t *)(lVar3 + 0x23c) = uVar11;
  *(void* *)(lVar3 + 0x254) = 0x3f8000003f800000;
  lStack_1d8 = 0x3f8000003f800000;
  *(void* *)(lVar3 + 0x25c) = 0x3f8000003f800000;
  lVar4 = _DAT_180c86890;
  lVar2 = _DAT_180c82868;
  puStack_168 = &UNK_1809fdc18;
  puStack_160 = auStack_150;
  auStack_150[0] = 0;
  uStack_158 = 0xd;
  strcpy_s(auStack_150,0x10,&UNK_180a04130);
  puVar6 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
  lStack_1e8 = lVar2 + 0x70;
  apuStack_1c8[0] = puVar6;
  FUN_18020e0e0(puVar6,&puStack_168,3,lVar2 + 0x2e0);
  *puVar6 = &UNK_1809fe220;
  apuStack_1c8[0] = puVar6;
  FUN_18020e840(puVar6);
  FUN_18005ea90(lVar2 + 0x48,apuStack_1c8);
  *(void* **)(lVar4 + 0x18) = puVar6;
  puStack_168 = &SystemMemoryAllocatorReference;
  puVar8 = &SystemStringTemplate;
  if (*(undefined **)(lVar3 + 0x278) != (undefined *)0x0) {
    puVar8 = *(undefined **)(lVar3 + 0x278);
  }
  (**(code **)(*(long long *)(_DAT_180c86930 + 0x560) + 0x10))
            ((long long *)(_DAT_180c86930 + 0x560),puVar8);
  lVar3 = _DAT_180c868a8;
  lStack_1d8 = FUN_18062b1e0(_DAT_180c8ed18,0x30,8,3);
  *(void* *)(lStack_1d8 + 0x28) = 3;
  *(uint32_t *)(lStack_1d8 + 0x19) = 0;
  *(undefined2 *)(lStack_1d8 + 0x1d) = 0;
  *(uint8_t *)(lStack_1d8 + 0x1f) = 0;
  *(long long *)lStack_1d8 = lStack_1d8;
  *(long long *)(lStack_1d8 + 8) = lStack_1d8;
  *(void* *)(lStack_1d8 + 0x10) = 0;
  *(uint8_t *)(lStack_1d8 + 0x18) = 0;
  *(void* *)(lStack_1d8 + 0x20) = 0;
  *(long long *)(lVar3 + 0xa8) = lStack_1d8;
  lStack_1d0 = lStack_1d8;
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a012e0,&UNK_180a00350,FUN_180086670);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a002e0,&DAT_180a00410,FUN_1800868d0);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a012f0,&UNK_180a00340,FUN_180086600);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a00ef8,&UNK_180a00420,FUN_180086960);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&UNK_180a00e18,&UNK_180a00450,FUN_180086a00);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a01228,&DAT_180a00360,FUN_180086740);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a00c90,&UNK_180a00480,FUN_180086aa0);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&UNK_180a00ab8,&UNK_180a00ac8,FUN_1800900c0);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&UNK_180a01170,&UNK_180a00368,FUN_180086830);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a009f0,&UNK_180a00a00,FUN_180090020);
  FUN_1802567b0(*(void* *)(_DAT_180c868a8 + 0xa8),&DAT_180a00c80,&UNK_180a00490,FUN_180086b40);
  systemPreviousNode = (uint32_t *)FUN_18008d660(lVar3 + 0xe0,&DAT_180a009f0);
  *systemPreviousNode = 1;
  systemPreviousNode = (uint32_t *)FUN_18008d660(lVar3 + 0xe0,&DAT_180a012f0);
  *systemPreviousNode = 1;
  lStack_1d0 = FUN_18062b1e0(_DAT_180c8ed18,0x3878,8,3);
                    // WARNING: Subroutine does not return
  memset(lStack_1d0,0,0x3878);
}




// 函数: void FUN_18004f8e0(long long param_1)
void FUN_18004f8e0(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_18004f900(long long param_1)
void FUN_18004f900(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18004f920(void)
void FUN_18004f920(void)

{
  void* *puVar1;
  char *pcVar2;
  void* uVar3;
  long long lVar4;
  char cVar5;
  int iVar6;
  uint32_t uVar7;
  long long lVar8;
  long long *plVar9;
  uint32_t *puVar10;
  uint8_t auStack_a8 [32];
  long long *plStack_88;
  long long **pplStack_80;
  undefined *puStack_78;
  uint32_t *puStack_70;
  uint32_t uStack_68;
  void* uStack_60;
  void* uStack_58;
  undefined *puStack_50;
  uint8_t *puStack_48;
  uint32_t uStack_40;
  uint8_t auStack_38 [16];
  ulong long uStack_28;
  
  lVar4 = _DAT_180c86870;
  uStack_58 = 0xfffffffffffffffe;
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_a8;
  FUN_18005e630(_DAT_180c82868);
  do {
    uVar3 = _DAT_180c82868;
    lVar8 = FUN_18005e890(_DAT_180c82868);
    if (lVar8 == 0) break;
    plVar9 = (long long *)FUN_18005e890(uVar3);
    cVar5 = (**(code **)(*plVar9 + 0x20))(plVar9,1);
  } while (cVar5 != '\0');
  FUN_18005e630(_DAT_180c82868);
  puVar1 = _DAT_180c86960;
  if (*(char *)(_DAT_180c86960 + 7) != '\0') {
    plStack_88 = (long long *)0x180c91970;
    iVar6 = _Mtx_lock(0x180c91970);
    if (iVar6 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar6);
    }
    FUN_180126380(*(void* *)*puVar1);
    FUN_180126380(*(void* *)puVar1[1]);
    FUN_180095420(*puVar1);
    FUN_180095420(puVar1[1]);
    *(uint8_t *)(puVar1 + 7) = 0;
    iVar6 = _Mtx_unlock(0x180c91970);
    if (iVar6 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar6);
    }
  }
  puVar1 = (void* *)*_DAT_180c8a9e0;
  if (puVar1 != (void* *)0x0) {
    *_DAT_180c8a9e0 = 0;
    (**(code **)*puVar1)(puVar1,1);
  }
  plVar9 = _DAT_180c868f8;
  uVar3 = _DAT_180c82868;
  plStack_88 = _DAT_180c868f8;
  if (_DAT_180c868f8 != (long long *)0x0) {
    FUN_18016cef0(*_DAT_180c868f8);
    *plVar9 = 0;
    plStack_88 = plVar9 + 1;
    FUN_18005d580();
                    // WARNING: Subroutine does not return
    FUN_18064e900(plVar9);
  }
  _DAT_180c868f8 = (long long *)0x0;
  if (_DAT_180c91048 != (long long *)0x0) {
    pplStack_80 = &plStack_88;
    plStack_88 = _DAT_180c91048;
    (**(code **)(*_DAT_180c91048 + 0x28))();
    FUN_18005e6a0(uVar3,&plStack_88,0);
  }
  FUN_18005e630(_DAT_180c82868);
  if (_DAT_180c86948 != 0) {
    FUN_18006eb30();
  }
  FUN_18005e630(_DAT_180c82868);
  if (*(long long **)(lVar4 + 0x2b0) != (long long *)0x0) {
    (**(code **)(**(long long **)(lVar4 + 0x2b0) + 0x20))();
  }
  pcVar2 = *(char **)(_DAT_180c8ed08 + 0x10);
  if (*pcVar2 != '\0') {
    WSACleanup();
    *pcVar2 = '\0';
  }
  uVar3 = _DAT_180c82868;
  if (_DAT_180c91048 != (long long *)0x0) {
    pplStack_80 = &plStack_88;
    plStack_88 = _DAT_180c91048;
    (**(code **)(*_DAT_180c91048 + 0x28))();
    FUN_18005e6a0(uVar3,&plStack_88,0);
  }
  FUN_18005e630(_DAT_180c82868);
  if (_DAT_180c86948 != 0) {
    FUN_18006eb30();
  }
  FUN_18005e630(_DAT_180c82868);
  uVar3 = _DAT_180c82868;
  if (_DAT_180c91048 != (long long *)0x0) {
    pplStack_80 = &plStack_88;
    plStack_88 = _DAT_180c91048;
    (**(code **)(*_DAT_180c91048 + 0x28))();
    FUN_18005e6a0(uVar3,&plStack_88,0);
  }
  FUN_18005e630(_DAT_180c82868);
  if (_DAT_180c86948 != 0) {
    FUN_18006eb30();
  }
  FUN_18005e630(_DAT_180c82868);
  puStack_50 = &UNK_1809fdc18;
  puStack_48 = auStack_38;
  auStack_38[0] = 0;
  uStack_40 = 3;
  strcpy_s(auStack_38,0x10,&UNK_1809fd534);
  puStack_78 = &SystemGlobalDataReference;
  uStack_60 = 0;
  puStack_70 = (uint32_t *)0x0;
  uStack_68 = 0;
  puVar10 = (uint32_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x14,0x13);
  *(uint8_t *)puVar10 = 0;
  puStack_70 = puVar10;
  uVar7 = StartSystemThread(puVar10);
  *puVar10 = 0x706d6554;
  puVar10[1] = 0x7261726f;
  puVar10[2] = 0x73655279;
  puVar10[3] = 0x6372756f;
  puVar10[4] = 0x2f7365;
  uStack_68 = 0x13;
  uStack_60._0_4_ = uVar7;
  FUN_18062bd50(&puStack_78,&puStack_50);
  puStack_78 = &SystemGlobalDataReference;
  if (puStack_70 != (uint32_t *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_70 = (uint32_t *)0x0;
  uStack_60 = (ulong long)uStack_60._4_4_ << 0x20;
  puStack_78 = &SystemMemoryAllocatorReference;
  puStack_50 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_180062300(_DAT_180c86928,&UNK_1809fd550);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180050b00(void)
void FUN_180050b00(void)

{
  long long *plVar1;
  void** systemDataTable;
  code *pcVar3;
  uint8_t *puVar4;
  void* uVar5;
  long long lVar6;
  int iVar7;
  long long lVar8;
  long long **pplVar9;
  undefined2 *puVar10;
  uint uVar11;
  ulong long uVar13;
  float fVar14;
  double dVar15;
  double dVar16;
  long long **pplStackX_8;
  long long *plStackX_10;
  long long *plStackX_18;
  long long lStackX_20;
  long long lStack_90;
  long long lStack_88;
  long long lStack_80;
  long long lStack_78;
  long long ***ppplStack_70;
  void* uStack_68;
  long long **pplStack_60;
  void* uStack_58;
  ulong long uVar12;
  
  lVar8 = _DAT_180c868d0;
  lVar6 = _DAT_180c86870;
  if (DAT_180c82860 != '\0') {
    FUN_180050b30();
    return;
  }
  uStack_68 = 0xfffffffffffffffe;
  *(void* *)(_DAT_180c868d0 + 0x2038) = *(void* *)(_DAT_180c868d0 + 0x2030);
  puVar10 = (undefined2 *)(lVar8 + 0x14);
  lVar8 = 0x100;
  uVar12 = 0;
  do {
    *puVar10 = 0;
    puVar10 = puVar10 + 0xc;
    lVar8 = lVar8 + -1;
  } while (lVar8 != 0);
  FUN_18004be90(_DAT_180c8a990 + 0x48);
  _DAT_180c8ed28 = 0;
  _DAT_180bf3ffc = 0;
  if (DAT_180c82851 != '\0') {
    plVar1 = *(long long **)(lVar6 + 8);
    pplVar9 = (long long **)FUN_18062b1e0(_DAT_180c8ed18,0x48,8,3);
    *pplVar9 = (long long *)&UNK_180a21690;
    *pplVar9 = (long long *)&UNK_180a21720;
    *(uint32_t *)(pplVar9 + 1) = 0;
    *pplVar9 = (long long *)&UNK_18098bdc8;
    LOCK();
    *(uint8_t *)(pplVar9 + 2) = 0;
    UNLOCK();
    pplVar9[3] = (long long *)0xffffffffffffffff;
    *pplVar9 = (long long *)&UNK_180a08c60;
    *(uint32_t *)(pplVar9 + 5) = 4;
    pplVar9[4] = plVar1;
    ppplStack_70 = (long long ***)pplVar9;
    pplStack_60 = pplVar9;
    (*(code *)(*pplVar9)[5])(pplVar9);
    puVar2 = (void* *)plVar1[0x28];
    pcVar3 = *(code **)*puVar2;
    ppplStack_70 = &pplStackX_8;
    pplStackX_8 = pplVar9;
    (*(code *)(*pplVar9)[5])(pplVar9);
    (*pcVar3)(puVar2,&pplStackX_8);
    FUN_18020f150(plVar1[0x28]);
    (*(code *)(*pplVar9)[7])(pplVar9);
  }
  lVar8 = *(long long *)(_DAT_180c86950 + 0x18) - *(long long *)(_DAT_180c86950 + 0x10);
  uVar13 = uVar12;
  if (lVar8 / 0x1c != 0) {
    do {
      FUN_1801edeb0(lVar8,uVar13 * 0x1c + *(long long *)(_DAT_180c86950 + 0x10));
      uVar11 = (int)uVar12 + 1;
      uVar12 = (ulong long)uVar11;
      lVar8 = *(long long *)(_DAT_180c86950 + 0x18) - *(long long *)(_DAT_180c86950 + 0x10);
      uVar13 = (long long)(int)uVar11;
    } while ((ulong long)(long long)(int)uVar11 < (ulong long)(lVar8 / 0x1c));
  }
  *(void* *)(_DAT_180c86950 + 0x18) = *(void* *)(_DAT_180c86950 + 0x10);
  *(uint8_t *)(*(long long *)(*(long long *)(lVar6 + 8) + 0x140) + 0x208) = 1;
  if (*(char *)(lVar6 + 0x3c8) != '\0') {
    FUN_18004e5f0(lVar6);
    LOCK();
    *(uint8_t *)(lVar6 + 0x3c8) = 0;
    UNLOCK();
  }
  lVar8 = _DAT_180c8a9d8;
  *(void* *)(_DAT_180c8a9d8 + 4) = 0;
  *(void* *)(lVar8 + 0xc) = 0;
  *(void* *)(lVar8 + 0x14) = 0;
  FUN_1800572d0(lVar8 + 0x20);
  FUN_1800572d0(lVar8 + 0x50);
  LOCK();
  *(uint32_t *)(lVar8 + 0x80) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(lVar8 + 0x84) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(lVar8 + 0x88) = 0;
  UNLOCK();
  lVar8 = _DAT_180c8ed58;
  if (_DAT_180c8ed58 == 0) {
    QueryPerformanceCounter(&lStackX_20);
    lVar8 = lStackX_20;
  }
  *(double *)(lVar6 + 0x68) = (double)(lVar8 - _DAT_180c8ed48) * _DAT_180c8ed50;
  if (DAT_180c82863 != '\0') {
    uStack_58 = 0x180c91288;
    iVar7 = _Mtx_lock(0x180c91288);
    if (iVar7 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar7);
    }

// 函数: void FUN_180050b30(long long param_1)
void FUN_180050b30(long long param_1)

{
  long long *plVar1;
  void** systemDataTable;
  code *pcVar3;
  uint8_t *puVar4;
  void* uVar5;
  int iVar6;
  long long lVar7;
  long long **pplVar8;
  undefined2 *puVar9;
  uint uVar10;
  ulong long uVar12;
  float fVar13;
  double dVar14;
  double dVar15;
  long long **pplStackX_8;
  long long *plStackX_10;
  long long *plStackX_18;
  long long lStackX_20;
  long long lStack_90;
  long long lStack_88;
  long long lStack_80;
  long long lStack_78;
  long long ***ppplStack_70;
  void* uStack_68;
  long long **pplStack_60;
  void* uStack_58;
  ulong long uVar11;
  
  lVar7 = _DAT_180c868d0;
  uStack_68 = 0xfffffffffffffffe;
  *(void* *)(_DAT_180c868d0 + 0x2038) = *(void* *)(_DAT_180c868d0 + 0x2030);
  puVar9 = (undefined2 *)(lVar7 + 0x14);
  lVar7 = 0x100;
  uVar11 = 0;
  do {
    *puVar9 = 0;
    puVar9 = puVar9 + 0xc;
    lVar7 = lVar7 + -1;
  } while (lVar7 != 0);
  FUN_18004be90(_DAT_180c8a990 + 0x48);
  _DAT_180c8ed28 = 0;
  _DAT_180bf3ffc = 0;
  if (DAT_180c82851 != '\0') {
    plVar1 = *(long long **)(param_1 + 8);
    pplVar8 = (long long **)FUN_18062b1e0(_DAT_180c8ed18,0x48,8,3);
    *pplVar8 = (long long *)&UNK_180a21690;
    *pplVar8 = (long long *)&UNK_180a21720;
    *(uint32_t *)(pplVar8 + 1) = 0;
    *pplVar8 = (long long *)&UNK_18098bdc8;
    LOCK();
    *(uint8_t *)(pplVar8 + 2) = 0;
    UNLOCK();
    pplVar8[3] = (long long *)0xffffffffffffffff;
    *pplVar8 = (long long *)&UNK_180a08c60;
    *(uint32_t *)(pplVar8 + 5) = 4;
    pplVar8[4] = plVar1;
    ppplStack_70 = (long long ***)pplVar8;
    pplStack_60 = pplVar8;
    (*(code *)(*pplVar8)[5])(pplVar8);
    puVar2 = (void* *)plVar1[0x28];
    pcVar3 = *(code **)*puVar2;
    ppplStack_70 = &pplStackX_8;
    pplStackX_8 = pplVar8;
    (*(code *)(*pplVar8)[5])(pplVar8);
    (*pcVar3)(puVar2,&pplStackX_8);
    FUN_18020f150(plVar1[0x28]);
    (*(code *)(*pplVar8)[7])(pplVar8);
  }
  lVar7 = *(long long *)(_DAT_180c86950 + 0x18) - *(long long *)(_DAT_180c86950 + 0x10);
  uVar12 = uVar11;
  if (lVar7 / 0x1c != 0) {
    do {
      FUN_1801edeb0(lVar7,uVar12 * 0x1c + *(long long *)(_DAT_180c86950 + 0x10));
      uVar10 = (int)uVar11 + 1;
      uVar11 = (ulong long)uVar10;
      lVar7 = *(long long *)(_DAT_180c86950 + 0x18) - *(long long *)(_DAT_180c86950 + 0x10);
      uVar12 = (long long)(int)uVar10;
    } while ((ulong long)(long long)(int)uVar10 < (ulong long)(lVar7 / 0x1c));
  }
  *(void* *)(_DAT_180c86950 + 0x18) = *(void* *)(_DAT_180c86950 + 0x10);
  *(uint8_t *)(*(long long *)(*(long long *)(param_1 + 8) + 0x140) + 0x208) = 1;
  if (*(char *)(param_1 + 0x3c8) != '\0') {
    FUN_18004e5f0(param_1);
    LOCK();
    *(uint8_t *)(param_1 + 0x3c8) = 0;
    UNLOCK();
  }
  lVar7 = _DAT_180c8a9d8;
  *(void* *)(_DAT_180c8a9d8 + 4) = 0;
  *(void* *)(lVar7 + 0xc) = 0;
  *(void* *)(lVar7 + 0x14) = 0;
  FUN_1800572d0(lVar7 + 0x20);
  FUN_1800572d0(lVar7 + 0x50);
  LOCK();
  *(uint32_t *)(lVar7 + 0x80) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(lVar7 + 0x84) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(lVar7 + 0x88) = 0;
  UNLOCK();
  lVar7 = _DAT_180c8ed58;
  if (_DAT_180c8ed58 == 0) {
    QueryPerformanceCounter(&lStackX_20);
    lVar7 = lStackX_20;
  }
  *(double *)(param_1 + 0x68) = (double)(lVar7 - _DAT_180c8ed48) * _DAT_180c8ed50;
  if (DAT_180c82863 != '\0') {
    uStack_58 = 0x180c91288;
    iVar6 = _Mtx_lock(0x180c91288);
    if (iVar6 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar6);
    }

// 函数: void FUN_180051150(long long param_1,void* param_2)
void FUN_180051150(long long param_1,void* param_2)

{
  long long *plVar1;
  char cVar2;
  char cVar3;
  int iVar4;
  uint32_t uVar5;
  uint8_t *puVar6;
  void** systemCurrentNode;
  void** systemNextNode;
  long long lVar9;
  uint uVar10;
  long long lVar12;
  ulong long uVar13;
  long long *plVar14;
  float fVar15;
  void* uVar16;
  float fVar17;
  uint8_t auStack_348 [32];
  long long **pplStack_328;
  undefined *puStack_320;
  uint32_t uStack_318;
  void* uStack_308;
  char cStack_300;
  char acStack_2ff [7];
  long long *plStack_2f8;
  uint32_t uStack_2f0;
  undefined *puStack_2e8;
  void* *puStack_2e0;
  uint32_t uStack_2d8;
  void* uStack_2d0;
  uint32_t auStack_2c8 [2];
  long long *plStack_2c0;
  void* uStack_2b8;
  void* auStack_2a8 [67];
  long long alStack_90 [3];
  uint32_t uStack_78;
  ulong long uStack_68;
  ulong long uVar11;
  
  uStack_2b8 = 0xfffffffffffffffe;
  uStack_68 = _DAT_180bf00a8 ^ (ulong long)auStack_348;
  fVar15 = (float)param_2;
  _DAT_180c8ed20 = (long long)(fVar15 * 100000.0);
  _DAT_180c8ed30 = _DAT_180c8ed30 + _DAT_180c8ed20;
  _DAT_180bf3ff8 = fVar15;
  uVar16 = FUN_180091020();
  uVar16 = FUN_1801ed510(uVar16,param_2);
  cVar2 = FUN_180160500(uVar16,0x52);
  cVar3 = FUN_180160500(1,0x51);
  lVar12 = 0xe0;
  if (cVar3 == '\0') {
    if (cVar2 == '\0') goto LAB_18005122d;
  }
  else {

// 函数: void FUN_180051d00(long long param_1)
void FUN_180051d00(long long param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = *(void* **)(param_1 + 0x218);
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_180051d40(void* *param_1,void* *param_2)

{
  long long *plVar1;
  long long lVar2;
  long long lVar3;
  long long lVar4;
  ulong long uVar5;
  long long lVar6;
  uint8_t *systemPreviousNode;
  long long lVar8;
  ulong long uVar9;
  
  systemPreviousNode = (uint8_t *)((long long)param_1 + 0xf);
  *param_1 = *param_2;
  *(uint32_t *)(param_1 + 1) = *(uint32_t *)(param_2 + 1);
  *(uint8_t *)((long long)param_1 + 0xc) = *(uint8_t *)((long long)param_2 + 0xc);
  *(uint8_t *)((long long)param_1 + 0xd) = *(uint8_t *)((long long)param_2 + 0xd);
  *(uint8_t *)((long long)param_1 + 0xe) = *(uint8_t *)((long long)param_2 + 0xe);
  lVar6 = 0x100;
  do {
    *systemPreviousNode = systemPreviousNode[(long long)param_2 - (long long)param_1];
    systemPreviousNode[1] = systemPreviousNode[((long long)param_2 - (long long)param_1) + 1];
    systemPreviousNode = systemPreviousNode + 2;
    lVar6 = lVar6 + -1;
  } while (lVar6 != 0);
  *(uint8_t *)((long long)param_1 + 0x20f) = *(uint8_t *)((long long)param_2 + 0x20f);
  plVar1 = param_1 + 0x43;
  *(uint8_t *)(param_1 + 0x42) = *(uint8_t *)(param_2 + 0x42);
  *(uint8_t *)((long long)param_1 + 0x211) = *(uint8_t *)((long long)param_2 + 0x211);
  if (plVar1 != param_2 + 0x43) {
    lVar6 = *plVar1;
    lVar2 = param_2[0x44];
    lVar3 = param_2[0x43];
    lVar8 = lVar2 - lVar3;
    uVar9 = lVar8 >> 2;
    if ((ulong long)(param_1[0x45] - lVar6 >> 2) < uVar9) {
      if (uVar9 == 0) {
        lVar6 = 0;
      }
      else {
        lVar6 = CreateSystemThreadObject(_DAT_180c8ed18,uVar9 * 4,*(uint8_t *)(param_1 + 0x46));
      }
      if (lVar3 != lVar2) {
                    // WARNING: Subroutine does not return
        memmove(lVar6,lVar3,lVar8);
      }
      if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lVar2 = lVar6 + uVar9 * 4;
      *plVar1 = lVar6;
      param_1[0x44] = lVar2;
      param_1[0x45] = lVar2;
    }
    else {
      lVar4 = param_1[0x44];
      uVar5 = lVar4 - lVar6 >> 2;
      if (uVar5 < uVar9) {
        lVar8 = uVar5 * 4 + lVar3;
        if (lVar3 != lVar8) {
                    // WARNING: Subroutine does not return
          memmove(lVar6,lVar3);
        }
        if (lVar8 != lVar2) {
                    // WARNING: Subroutine does not return
          memmove(lVar4,lVar8,lVar2 - lVar8);
        }
        param_1[0x44] = lVar4;
      }
      else {
        if (lVar3 != lVar2) {
                    // WARNING: Subroutine does not return
          memmove(lVar6,lVar3,lVar8);
        }
        param_1[0x44] = lVar6;
      }
    }
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180051de4(long long param_1)
void FUN_180051de4(long long param_1)

{
  long long lVar1;
  long long lVar2;
  long long in_RAX;
  long long lVar3;
  ulong long uVar4;
  long long *unaff_RSI;
  long long *unaff_RDI;
  long long systemTimeValue;
  ulong long uVar6;
  
  lVar1 = unaff_RSI[1];
  lVar2 = *unaff_RSI;
  lVar5 = lVar1 - lVar2;
  uVar6 = lVar5 >> 2;
  if ((ulong long)(in_RAX - param_1 >> 2) < uVar6) {
    if (uVar6 == 0) {
      lVar3 = 0;
    }
    else {
      lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 * 4,(char)unaff_RDI[3]);
    }
    if (lVar2 != lVar1) {
                    // WARNING: Subroutine does not return
      memmove(lVar3,lVar2,lVar5);
    }
    if (*unaff_RDI != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lVar1 = lVar3 + uVar6 * 4;
    *unaff_RDI = lVar3;
    unaff_RDI[1] = lVar1;
    unaff_RDI[2] = lVar1;
  }
  else {
    lVar3 = unaff_RDI[1];
    uVar4 = lVar3 - param_1 >> 2;
    if (uVar4 < uVar6) {
      lVar5 = uVar4 * 4 + lVar2;
      if (lVar2 != lVar5) {
                    // WARNING: Subroutine does not return
        memmove(param_1,lVar2);
      }
      if (lVar5 != lVar1) {
                    // WARNING: Subroutine does not return
        memmove(lVar3,lVar5,lVar1 - lVar5);
      }
      unaff_RDI[1] = lVar3;
    }
    else {
      if (lVar2 != lVar1) {
                    // WARNING: Subroutine does not return
        memmove(param_1,lVar2,lVar5);
      }
      unaff_RDI[1] = param_1;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180051e13(void)
void FUN_180051e13(void)

{
  long long lVar1;
  long long lVar2;
  long long unaff_RBP;
  long long unaff_RSI;
  long long *unaff_RDI;
  long long unaff_R14;
  
  if (unaff_R14 == 0) {
    lVar2 = 0;
  }
  else {
    lVar2 = CreateSystemThreadObject(_DAT_180c8ed18,unaff_R14 * 4,(char)unaff_RDI[3]);
  }
  if (unaff_RSI != unaff_RBP) {
                    // WARNING: Subroutine does not return
    memmove(lVar2);
  }
  if (*unaff_RDI != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar1 = lVar2 + unaff_R14 * 4;
  *unaff_RDI = lVar2;
  unaff_RDI[1] = lVar1;
  unaff_RDI[2] = lVar1;
  return;
}




// 函数: void FUN_180051e74(long long param_1)
void FUN_180051e74(long long param_1)

{
  long long lVar1;
  long long lVar2;
  ulong long uVar3;
  long long unaff_RBP;
  long long unaff_RSI;
  long long unaff_RDI;
  ulong long unaff_R14;
  
  lVar2 = *(long long *)(unaff_RDI + 8);
  uVar3 = lVar2 - param_1 >> 2;
  if (uVar3 < unaff_R14) {
    lVar1 = uVar3 * 4 + unaff_RSI;
    if (unaff_RSI != lVar1) {
                    // WARNING: Subroutine does not return
      memmove();
    }
    if (lVar1 != unaff_RBP) {
                    // WARNING: Subroutine does not return
      memmove(lVar2,lVar1,unaff_RBP - lVar1);
    }
    *(long long *)(unaff_RDI + 8) = lVar2;
  }
  else {
    if (unaff_RSI != unaff_RBP) {
                    // WARNING: Subroutine does not return
      memmove();
    }
    *(long long *)(unaff_RDI + 8) = param_1;
  }
  return;
}




// 函数: void FUN_180051eef(void)
void FUN_180051eef(void)

{
  return;
}



bool FUN_180051f00(long long param_1)

{
  void* *puVar1;
  byte bVar2;
  bool bVar3;
  byte *pbVar4;
  uint uVar5;
  int iVar6;
  long long lVar7;
  void** systemNextNode;
  void* *puVar9;
  void* *puVar10;
  void* *puVar11;
  undefined *puStack_30;
  byte *pbStack_28;
  int iStack_20;
  
  puVar1 = (void* *)(param_1 + 0x2e0);
  FUN_1806279c0(&puStack_30);
  puVar8 = *(void* **)(param_1 + 0x2f0);
  puVar11 = puVar1;
  if (puVar8 != (void* *)0x0) {
    do {
      if (iStack_20 == 0) {
        bVar3 = false;
        puVar9 = (void* *)puVar8[1];
      }
      else {
        if (*(int *)(puVar8 + 6) == 0) {
          bVar3 = true;
        }
        else {
          pbVar4 = pbStack_28;
          do {
            uVar5 = (uint)pbVar4[puVar8[5] - (long long)pbStack_28];
            iVar6 = *pbVar4 - uVar5;
            if (*pbVar4 != uVar5) break;
            pbVar4 = pbVar4 + 1;
          } while (uVar5 != 0);
          bVar3 = 0 < iVar6;
          if (iVar6 < 1) {
            puVar9 = (void* *)puVar8[1];
            goto LAB_180051f8b;
          }
        }
        puVar9 = (void* *)*puVar8;
      }
LAB_180051f8b:
      puVar10 = puVar8;
      if (bVar3) {
        puVar10 = puVar11;
      }
      puVar8 = puVar9;
      puVar11 = puVar10;
    } while (puVar9 != (void* *)0x0);
    if (puVar10 != puVar1) {
      if (*(int *)(puVar10 + 6) == 0) goto LAB_180051fc9;
      if (iStack_20 != 0) {
        pbVar4 = (byte *)puVar10[5];
        lVar7 = (long long)pbStack_28 - (long long)pbVar4;
        do {
          bVar2 = *pbVar4;
          uVar5 = (uint)pbVar4[lVar7];
          if (bVar2 != uVar5) break;
          pbVar4 = pbVar4 + 1;
        } while (uVar5 != 0);
        if ((int)(bVar2 - uVar5) < 1) goto LAB_180051fc9;
      }
    }
  }
  puVar10 = puVar1;
LAB_180051fc9:
  puStack_30 = &SystemGlobalDataReference;
  if (pbStack_28 == (byte *)0x0) {
    return puVar10 != puVar1;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void*
FUN_180052020(void* param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180627ae0(param_2,_DAT_180c86870 + 0x2c0,param_3,param_4,0,0xfffffffffffffffe);
  return param_2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180052070(long long param_1)
void FUN_180052070(long long param_1)

{
  void* *puVar1;
  int iVar2;
  uint8_t auStack_108 [32];
  uint32_t uStack_e8;
  void* uStack_b8;
  long long lStack_b0;
  uint8_t auStack_a8 [128];
  ulong long uStack_28;
  
  uStack_b8 = 0xfffffffffffffffe;
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_108;
  uStack_e8 = 0;
  lStack_b0 = param_1;
  FUN_180627ae0(param_1,_DAT_180c86870 + 0x170);
  uStack_e8 = 1;
  iVar2 = *(int *)(param_1 + 0x10) + 8;
  FUN_1806277c0(param_1,iVar2);
  puVar1 = (void* *)((ulong long)*(uint *)(param_1 + 0x10) + *(long long *)(param_1 + 8));
  *puVar1 = 0x2f73656873617263;
  *(uint8_t *)(puVar1 + 1) = 0;
  *(int *)(param_1 + 0x10) = iVar2;
                    // WARNING: Subroutine does not return
  memset(auStack_a8,0,0x80);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180052200(long long param_1,long long param_2,void* param_3,void* param_4)
void FUN_180052200(long long param_1,long long param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  uint32_t uVar2;
  int memoryCompareResult;
  void* *puVar4;
  ulong long uVar5;
  long long lVar6;
  void* uVar7;
  undefined *pstackParameterC;
  void* *puStack_88;
  uint32_t uStack_80;
  void* uStack_78;
  undefined *puStack_70;
  void* *puStack_68;
  uint32_t uStack_60;
  void* uStack_58;
  
  uVar7 = 0xfffffffffffffffe;
  plVar1 = (long long *)(param_1 + 0xd8);
  lVar6 = 0;
  if ((*(long long *)(param_1 + 0xe0) - *plVar1 & 0xffffffffffffffe0U) != 0) {
    FUN_180057110(param_2);
    uVar5 = *(long long *)(param_1 + 0xe0) - *plVar1 >> 5;
    if (0 < (int)uVar5) {
      uVar5 = uVar5 & 0xffffffff;
      do {
        if (*(ulong long *)(param_2 + 8) < *(ulong long *)(param_2 + 0x10)) {
          *(ulong long *)(param_2 + 8) = *(ulong long *)(param_2 + 8) + 0x20;
          FUN_180627ae0();
        }
        else {
          FUN_180059820(param_2,*plVar1 + lVar6);
        }
        lVar6 = lVar6 + 0x20;
        uVar5 = uVar5 - 1;
      } while (uVar5 != 0);
    }
    return;
  }
  puStack_70 = &SystemGlobalDataReference;
  uStack_58 = 0;
  puStack_68 = (void* *)0x0;
  uStack_60 = 0;
  puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13,param_4,0xfffffffffffffffe);
  *(uint8_t *)puVar4 = 0;
  puStack_68 = puVar4;
  uVar2 = StartSystemThread(puVar4);
  uStack_58 = CONCAT44(uStack_58._4_4_,uVar2);
  *puVar4 = 0x53454c55444f4d5f;
  *(undefined2 *)(puVar4 + 1) = 0x2a5f;
  *(uint8_t *)((long long)puVar4 + 10) = 0;
  uStack_60 = 10;
  iVar3 = FUN_180628d60(param_1 + 0x2c0,&puStack_70);
  if (-1 < iVar3) {
    pstackParameterC = &SystemGlobalDataReference;
    uStack_78 = 0;
    puStack_88 = (void* *)0x0;
    uStack_80 = 0;
    puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13,param_4,uVar7);
    *(uint8_t *)puVar4 = 0;
    puStack_88 = puVar4;
    uVar2 = StartSystemThread(puVar4);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar2);
    *puVar4 = 0x454c55444f4d5f2a;
    *(undefined2 *)(puVar4 + 1) = 0x5f53;
    *(uint8_t *)((long long)puVar4 + 10) = 0;
    uStack_80 = 10;
    FUN_180628d60(param_1 + 0x2c0,&pstackParameterC);
    pstackParameterC = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar4);
  }
  puStack_70 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar4);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_1800524c0(void* param_1,void* param_2)

{
  long long lVar1;
  uint32_t uVar2;
  int memoryCompareResult;
  void* *puVar4;
  undefined *puStack_88;
  void* *puStack_80;
  uint32_t uStack_78;
  void* uStack_70;
  undefined *puStack_68;
  void* *puStack_60;
  uint32_t uStack_58;
  void* uStack_50;
  
  lVar1 = _DAT_180c86870;
  if (*(int *)(_DAT_180c86870 + 200) != 0) {
    FUN_180627ae0(param_2,_DAT_180c86870 + 0xb8);
    return param_2;
  }
  puStack_68 = &SystemGlobalDataReference;
  uStack_50 = 0;
  puStack_60 = (void* *)0x0;
  uStack_58 = 0;
  puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
  *(uint8_t *)puVar4 = 0;
  puStack_60 = puVar4;
  uVar2 = StartSystemThread(puVar4);
  uStack_50 = CONCAT44(uStack_50._4_4_,uVar2);
  *puVar4 = 0x53454c55444f4d5f;
  *(undefined2 *)(puVar4 + 1) = 0x2a5f;
  *(uint8_t *)((long long)puVar4 + 10) = 0;
  uStack_58 = 10;
  iVar3 = FUN_180628d60(lVar1 + 0x2c0,&puStack_68);
  if (-1 < iVar3) {
    puStack_88 = &SystemGlobalDataReference;
    uStack_70 = 0;
    puStack_80 = (void* *)0x0;
    uStack_78 = 0;
    puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
    *(uint8_t *)puVar4 = 0;
    puStack_80 = puVar4;
    uVar2 = StartSystemThread(puVar4);
    uStack_70 = CONCAT44(uStack_70._4_4_,uVar2);
    *puVar4 = 0x454c55444f4d5f2a;
    *(undefined2 *)(puVar4 + 1) = 0x5f53;
    *(uint8_t *)((long long)puVar4 + 10) = 0;
    uStack_78 = 10;
    FUN_180628d60(lVar1 + 0x2c0,&puStack_88);
    puStack_88 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar4);
  }
  puStack_68 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar4);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180052940(long long param_1,float param_2,void* param_3,void* param_4)
void FUN_180052940(long long param_1,float param_2,void* param_3,void* param_4)

{
  ulong long uVar1;
  float fVar2;
  float fVar3;
  ulong long uVar4;
  ulong long uVar5;
  int iVar6;
  uint uVar7;
  long long lVar8;
  uint uVar9;
  void* in_RDX;
  long long lVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  bool bVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  uint32_t uVar21;
  float fVar22;
  float fStackX_8;
  float fStackX_c;
  
  lVar8 = _DAT_180c86920;
  if ((*(long long *)(_DAT_180c86890 + 0x7ab8) == 0) || (*(int *)(_DAT_180c86920 + 0x540) < 1)) {
    bVar14 = *(int *)(_DAT_180c86920 + 0x2140) != 0;
  }
  else {
    bVar14 = false;
  }
  if (bVar14) {
    fVar15 = (float)exp2f(_DAT_180c86920,in_RDX,param_3,param_4,0xfffffffffffffffe);
    if (*(char *)(param_1 + 0x22d) == '\0') {
      lVar8 = *(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
      if ((*(int *)(lVar8 + 0x48) < _DAT_180d49140) &&
         (FUN_1808fcb90(&DAT_180d49140), _DAT_180d49140 == -1)) {
        _DAT_180d49144 = param_2;
        FUN_1808fcb30(&DAT_180d49140);
      }
      fVar16 = (float)exp2f();
      fVar17 = (float)exp2f();
      fVar18 = (float)exp2f();
      fVar19 = (float)exp2f();
      fVar20 = (float)exp2f();
      _DAT_180d49144 = (1.0 - fVar16) * _DAT_180d49144 + fVar16 * param_2;
      fVar2 = (float)*(int *)(_DAT_180c86920 + 0x21b0);
      if (*(float *)(_DAT_180c86870 + 0x1f8) <= (float)*(int *)(_DAT_180c86920 + 0x21b0)) {
        fVar2 = *(float *)(_DAT_180c86870 + 0x1f8);
      }
      fVar22 = *(float *)(_DAT_180c86920 + 0x1e30);
      if (0 < *(int *)(_DAT_180c86920 + 0x1f80)) {
        fVar22 = fVar22 / (float)*(int *)(_DAT_180c86920 + 0x1f80);
      }
      fVar3 = (float)((int)fVar22 + -1);
      if (fVar2 <= (float)((int)fVar22 + -1)) {
        fVar3 = fVar2;
      }
      if ((*(int *)(lVar8 + 0x48) < _DAT_180d49148) &&
         (FUN_1808fcb90(&DAT_180d49148), _DAT_180d49148 == -1)) {
        _DAT_180d4914c = fVar3;
        FUN_1808fcb30(&DAT_180d49148);
      }
      _DAT_180d4914c = (1.0 - fVar16) * _DAT_180d4914c + fVar3 * fVar16;
      fVar18 = ((float)(int)((_DAT_180d49144 / _DAT_180d4914c) / fVar17) * fVar17 - 1.0) * fVar18 *
               fVar19 + fVar18;
      if (fVar18 <= fVar15) {
        fVar18 = fVar15;
      }
      if (1.0 <= fVar18) {
        fVar18 = 1.0;
      }
      fVar20 = (float)(int)((fVar18 + 0.05) / fVar20) * fVar20;
      if ((fVar15 <= fVar20) && (fVar15 = fVar20, 1.0 <= fVar20)) {
        fVar15 = 1.0;
      }
      *(float *)(param_1 + 0x238) = fVar15;
      uVar21 = log2f();
      *(uint32_t *)(param_1 + 0x248) = uVar21;
      *(float *)(param_1 + 0x250) = _DAT_180d49144;
      lVar10 = _DAT_180c86950;
      *(uint8_t *)(_DAT_180c86950 + 0x162b) = 1;
      lVar8 = _DAT_180c86920;
    }
    else {
      *(float *)(param_1 + 0x238) = fVar15;
      lVar8 = _DAT_180c86920;
      lVar10 = _DAT_180c86950;
    }
  }
  else {
    *(uint32_t *)(param_1 + 0x238) = 0x3f800000;
    lVar10 = _DAT_180c86950;
  }
  if ((*(long long *)(_DAT_180c86890 + 0x7ab8) == 0) || (*(int *)(lVar8 + 0x540) < 1)) {
    if (*(int *)(lVar8 + 0x2140) == 0) {
      fVar15 = *(float *)(lVar8 + 0x20d0);
    }
    else {
      fVar15 = 100.0;
    }
    fVar15 = fVar15 * 0.01;
  }
  else {
    fVar15 = 1.0;
  }
  *(float *)(param_1 + 0x234) = fVar15;
  uVar11 = (uint)*(float *)(lVar10 + 0x17ec);
  uVar13 = (uint)*(float *)(lVar10 + 0x17f0);
  uVar12 = uVar11;
  uVar7 = uVar13;
  if (1.0 <= fVar15) {
    fStackX_8 = 1.0;
    fStackX_c = 1.0;
  }
  else {
    while (0 < (int)uVar7) {
      uVar9 = (int)uVar12 % (int)uVar7;
      uVar12 = uVar7;
      uVar7 = uVar9;
    }
    iVar6 = (int)uVar11 / (int)uVar12;
    fStackX_8 = (float)(int)uVar11;
    do {
      uVar11 = (uint)(fStackX_8 * fVar15);
      if (1 < iVar6) {
        uVar11 = ((uVar11 - 1) - (int)(uVar11 - 1) % iVar6) + iVar6;
      }
      uVar1 = (long long)(int)(((int)uVar13 / (int)uVar12) * uVar11) / (long long)iVar6;
      uVar7 = (uint)uVar1;
      if (((uVar11 & 1) == 0) && ((uVar1 & 1) == 0)) goto LAB_180052ce3;
      fVar15 = fVar15 + 0.01;
      *(float *)(param_1 + 0x234) = fVar15;
    } while (fVar15 <= 1.0);
    *(uint32_t *)(param_1 + 0x234) = 0x3f800000;
LAB_180052ce3:
    fStackX_8 = (float)(int)uVar11 / fStackX_8;
    fStackX_c = (float)(int)uVar7 / (float)(int)uVar13;
    uVar13 = uVar7;
  }
  *(ulong long *)(param_1 + 0x254) = CONCAT44(fStackX_c,fStackX_8);
  fVar15 = *(float *)(param_1 + 0x238);
  if (1.0 <= fVar15) {
    fStackX_8 = 1.0;
    fStackX_c = 1.0;
  }
  else {
    uVar5 = (ulong long)uVar13;
    uVar1 = (ulong long)uVar11;
    uVar12 = uVar11;
    uVar7 = uVar13;
    while (uVar4 = uVar5, 0 < (int)uVar7) {
      uVar12 = (uint)uVar4;
      uVar1 = (long long)(int)uVar1 % (long long)(int)uVar12;
      uVar7 = (uint)uVar1;
      uVar5 = uVar1 & 0xffffffff;
      uVar1 = uVar4;
    }
    iVar6 = (int)uVar11 / (int)uVar12;
    do {
      uVar7 = (uint)(fVar15 * (float)(int)uVar11);
      if (1 < iVar6) {
        uVar7 = ((uVar7 - 1) - (int)(uVar7 - 1) % iVar6) + iVar6;
      }
      uVar1 = (long long)(int)(((int)uVar13 / (int)uVar12) * uVar7) / (long long)iVar6;
      if (((uVar7 & 1) == 0) && ((uVar1 & 1) == 0)) goto LAB_180052de5;
      fVar15 = fVar15 + 0.01;
      *(float *)(param_1 + 0x238) = fVar15;
    } while (fVar15 <= 1.0);
    *(uint32_t *)(param_1 + 0x238) = 0x3f800000;
LAB_180052de5:
    fStackX_8 = (float)(int)uVar7 / (float)(int)uVar11;
    fStackX_c = (float)(int)uVar1 / (float)(int)uVar13;
  }
  *(ulong long *)(param_1 + 0x25c) = CONCAT44(fStackX_c,fStackX_8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180052ef0(long long *param_1,void* param_2,void* param_3,uint8_t param_4)
void FUN_180052ef0(long long *param_1,void* param_2,void* param_3,uint8_t param_4)

{
  int iVar1;
  long long lVar2;
  long long lVar3;
  void* uVar4;
  long long *plVar5;
  int *piVar6;
  long long lVar7;
  ulong long uVar8;
  uint uVar9;
  ulong long uVar10;
  float fVar11;
  float fVar12;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  long long alStack_70 [2];
  undefined *puStack_60;
  undefined *puStack_58;
  long long alStack_50 [2];
  undefined *puStack_40;
  undefined *puStack_38;
  
  lVar2 = _DAT_180c86870;
  plStackX_8 = param_1;
  if (*(int *)(_DAT_180c86920 + 0xd94) != *(int *)(_DAT_180c86920 + 0xd90)) {
    FUN_18004caf0(_DAT_180c86870,param_2,param_3,param_4,0xfffffffffffffffe);
  }
  lVar3 = _DAT_180c86950;
  if (_DAT_180c86950 != 0) {
    uVar8 = 0;
    lVar7 = *(long long *)(_DAT_180c86950 + 0x1868);
    uVar10 = uVar8;
    if (*(long long *)(_DAT_180c86950 + 0x1870) - lVar7 >> 3 != 0) {
      do {
        if (*(long long **)(uVar8 + lVar7) != (long long *)0x0) {
          (**(code **)(**(long long **)(uVar8 + lVar7) + 0x108))();
        }
        uVar9 = (int)uVar10 + 1;
        uVar8 = uVar8 + 8;
        lVar7 = *(long long *)(lVar3 + 0x1868);
        uVar10 = (ulong long)uVar9;
      } while ((ulong long)(long long)(int)uVar9 <
               (ulong long)(*(long long *)(lVar3 + 0x1870) - lVar7 >> 3));
    }
    (**(code **)(_DAT_180c8a9c0 + 0x40))();
  }
  (**(code **)(**(long long **)(lVar2 + 0x2b0) + 0xd0))();
  if (((*(int *)(_DAT_180c86920 + 0x4d4) != *(int *)(_DAT_180c86920 + 0x4d0)) ||
      (*(int *)(_DAT_180c86920 + 0x314) != *(int *)(_DAT_180c86920 + 0x310))) ||
     (*(int *)(_DAT_180c86920 + 0x544) != *(int *)(_DAT_180c86920 + 0x540))) {
    plStackX_8 = alStack_70;
    puStack_60 = &UNK_180058f90;
    puStack_58 = &UNK_180058f80;
    FUN_18005c650(alStack_70);
  }
  if ((_DAT_180c8a9d0 != 0) &&
     ((*(int *)(_DAT_180c86920 + 900) != *(int *)(_DAT_180c86920 + 0x380) ||
      (*(int *)(_DAT_180c86920 + 0x3f4) != *(int *)(_DAT_180c86920 + 0x3f0))))) {
    uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x40,8,3);
    plStackX_8 = alStack_50;
    puStack_40 = &UNK_180058f60;
    puStack_38 = &UNK_180058f50;
    plVar5 = (long long *)FUN_18005c2a0(uVar4,alStack_50);
    plStackX_10 = plVar5;
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x28))(plVar5);
    }
    uVar4 = _DAT_180c82868;
    pplStackX_18 = &plStackX_8;
    plStackX_8 = plVar5;
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x28))(plVar5);
    }
    FUN_18005e370(uVar4,&plStackX_8);
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x38))(plVar5);
    }
  }
  lVar3 = _DAT_180c86920;
  if ((*(long long *)(_DAT_180c86890 + 0x7ab8) == 0) || (*(int *)(_DAT_180c86920 + 0x540) < 1)) {
    if (*(int *)(_DAT_180c86920 + 0x2140) == 0) {
      fVar11 = *(float *)(_DAT_180c86920 + 0x20d0);
    }
    else {
      fVar11 = 100.0;
    }
    fVar11 = fVar11 * 0.01;
  }
  else {
    fVar11 = 1.0;
  }
  *(float *)(lVar2 + 0x234) = fVar11;
  *(uint32_t *)(lVar2 + 0x238) = 0x3f800000;
  fVar12 = 1.0;
  if (*(int *)(lVar3 + 0x1ea0) == 1) {
    iVar1 = *(int *)(lVar3 + 0x1d50);
    piVar6 = (int *)FUN_180171f10(*(void* *)(_DAT_180c86870 + 8),&plStackX_10);
    fVar12 = (float)iVar1 / (float)*piVar6;
    fVar11 = fVar12 * *(float *)(lVar2 + 0x234);
    fVar12 = fVar12 * *(float *)(lVar2 + 0x238);
  }
  if (0.2 <= fVar11) {
    if (1.0 <= fVar11) {
      fVar11 = 1.0;
    }
  }
  else {
    fVar11 = 0.2;
  }
  *(float *)(lVar2 + 0x234) = fVar11;
  if (0.2 <= fVar12) {
    if (1.0 <= fVar12) {
      fVar12 = 1.0;
    }
    *(float *)(lVar2 + 0x238) = fVar12;
  }
  else {
    *(uint32_t *)(lVar2 + 0x238) = 0x3e4ccccd;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180053200(void* param_1,long long param_2)
void FUN_180053200(void* param_1,long long param_2)

{
  uint32_t *puVar1;
  int iVar2;
  int memoryCompareResult;
  uint8_t auStack_1c8 [32];
  undefined **ppuStack_1a8;
  void* uStack_1a0;
  undefined *puStack_198;
  void* uStack_190;
  int iStack_188;
  uint8_t auStack_e8 [16];
  undefined *puStack_d8;
  void* uStack_d0;
  int iStack_c8;
  ulong long uStack_18;
  
  uStack_1a0 = 0xfffffffffffffffe;
  uStack_18 = _DAT_180bf00a8 ^ (ulong long)auStack_1c8;
  FUN_180047d40(auStack_e8,
                (long long)*(int *)(_DAT_180c86938 + 0x1d40) * 0xd0 +
                *(long long *)(_DAT_180c86938 + 0x1d20));
  FUN_180623de0(&puStack_198);
  iVar2 = 0;
  *(uint32_t *)(param_2 + 0x10) = 0;
  if (*(uint8_t **)(param_2 + 8) != (uint8_t *)0x0) {
    **(uint8_t **)(param_2 + 8) = 0;
    iVar2 = *(int *)(param_2 + 0x10);
  }
  iVar3 = iVar2 + 5;
  FUN_1806277c0(param_2,iVar3);
  puVar1 = (uint32_t *)((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8));
  *puVar1 = 0x3a757067;
  *(undefined2 *)(puVar1 + 1) = 0x20;
  *(int *)(param_2 + 0x10) = iVar3;
  if (0 < iStack_c8) {
    FUN_1806277c0(param_2,iVar3 + iStack_c8);
                    // WARNING: Subroutine does not return
    memcpy((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8),uStack_d0,
           (long long)(iStack_c8 + 1));
  }
  FUN_1806277c0(param_2,iVar2 + 6);
  *(undefined2 *)((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8)) = 10;
  *(int *)(param_2 + 0x10) = iVar2 + 6;
  iVar3 = iVar2 + 0xb;
  FUN_1806277c0(param_2,iVar3);
  puVar1 = (uint32_t *)((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8));
  *puVar1 = 0x3a757063;
  *(undefined2 *)(puVar1 + 1) = 0x20;
  *(int *)(param_2 + 0x10) = iVar3;
  if (0 < iStack_188) {
    FUN_1806277c0(param_2,iVar3 + iStack_188);
                    // WARNING: Subroutine does not return
    memcpy((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8),uStack_190,
           (long long)(iStack_188 + 1));
  }
  FUN_1806277c0(param_2,iVar2 + 0xc);
  *(undefined2 *)((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8)) = 10;
  *(int *)(param_2 + 0x10) = iVar2 + 0xc;
  puStack_198 = &SystemMemoryAllocatorReference;
  ppuStack_1a8 = &puStack_d8;
  puStack_d8 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_18 ^ (ulong long)auStack_1c8);
}



// WARNING: Removing unreachable block (ram,0x000180053668)
// WARNING: Removing unreachable block (ram,0x0001800536a5)
// WARNING: Removing unreachable block (ram,0x0001800536a9)
// WARNING: Removing unreachable block (ram,0x0001800536b4)
// WARNING: Removing unreachable block (ram,0x0001800536b7)
// WARNING: Removing unreachable block (ram,0x0001800536e1)
// WARNING: Removing unreachable block (ram,0x0001800536e5)
// WARNING: Removing unreachable block (ram,0x0001800536f3)
// WARNING: Removing unreachable block (ram,0x0001800536fb)
// WARNING: Removing unreachable block (ram,0x000180053702)
// WARNING: Removing unreachable block (ram,0x00018005370c)
// WARNING: Removing unreachable block (ram,0x00018005373c)
// WARNING: Removing unreachable block (ram,0x000180053744)
// WARNING: Removing unreachable block (ram,0x000180053747)
// WARNING: Removing unreachable block (ram,0x000180053714)
// WARNING: Removing unreachable block (ram,0x000180053719)
// WARNING: Removing unreachable block (ram,0x000180053760)
// WARNING: Removing unreachable block (ram,0x00018005376e)
// WARNING: Removing unreachable block (ram,0x0001800537b1)
// WARNING: Removing unreachable block (ram,0x0001800537b5)
// WARNING: Removing unreachable block (ram,0x0001800537c0)
// WARNING: Removing unreachable block (ram,0x0001800537c3)
// WARNING: Removing unreachable block (ram,0x0001800537ed)
// WARNING: Removing unreachable block (ram,0x0001800537f1)
// WARNING: Removing unreachable block (ram,0x0001800537ff)
// WARNING: Removing unreachable block (ram,0x000180053807)
// WARNING: Removing unreachable block (ram,0x00018005380c)
// WARNING: Removing unreachable block (ram,0x00018005381c)
// WARNING: Removing unreachable block (ram,0x00018005384b)
// WARNING: Removing unreachable block (ram,0x000180053853)
// WARNING: Removing unreachable block (ram,0x000180053856)
// WARNING: Removing unreachable block (ram,0x000180053824)
// WARNING: Removing unreachable block (ram,0x000180053828)
// WARNING: Removing unreachable block (ram,0x00018005386f)
// WARNING: Removing unreachable block (ram,0x00018005387d)
// WARNING: Removing unreachable block (ram,0x0001800538c8)
// WARNING: Removing unreachable block (ram,0x0001800538cc)
// WARNING: Removing unreachable block (ram,0x0001800538d7)
// WARNING: Removing unreachable block (ram,0x0001800538da)
// WARNING: Removing unreachable block (ram,0x000180053906)
// WARNING: Removing unreachable block (ram,0x00018005390a)
// WARNING: Removing unreachable block (ram,0x000180053918)
// WARNING: Removing unreachable block (ram,0x000180053921)
// WARNING: Removing unreachable block (ram,0x000180053925)
// WARNING: Removing unreachable block (ram,0x000180053931)
// WARNING: Removing unreachable block (ram,0x000180053962)
// WARNING: Removing unreachable block (ram,0x00018005396a)
// WARNING: Removing unreachable block (ram,0x00018005396d)
// WARNING: Removing unreachable block (ram,0x000180053939)
// WARNING: Removing unreachable block (ram,0x00018005393e)
// WARNING: Removing unreachable block (ram,0x000180053987)
// WARNING: Removing unreachable block (ram,0x000180053996)
// WARNING: Removing unreachable block (ram,0x0001800539f8)
// WARNING: Removing unreachable block (ram,0x0001800539fc)
// WARNING: Removing unreachable block (ram,0x000180053a07)
// WARNING: Removing unreachable block (ram,0x000180053a0a)
// WARNING: Removing unreachable block (ram,0x000180053a34)
// WARNING: Removing unreachable block (ram,0x000180053a38)
// WARNING: Removing unreachable block (ram,0x000180053a46)
// WARNING: Removing unreachable block (ram,0x000180053a4e)
// WARNING: Removing unreachable block (ram,0x000180053a53)
// WARNING: Removing unreachable block (ram,0x000180053ad8)
// WARNING: Removing unreachable block (ram,0x000180053a61)
// WARNING: Removing unreachable block (ram,0x000180053aa2)
// WARNING: Removing unreachable block (ram,0x000180053aab)
// WARNING: Removing unreachable block (ram,0x000180053aaf)
// WARNING: Removing unreachable block (ram,0x000180053a69)
// WARNING: Removing unreachable block (ram,0x000180053a74)
// WARNING: Removing unreachable block (ram,0x000180053ade)
// WARNING: Removing unreachable block (ram,0x000180053b28)
// WARNING: Removing unreachable block (ram,0x000180053b2c)
// WARNING: Removing unreachable block (ram,0x000180053b32)
// WARNING: Removing unreachable block (ram,0x000180053b36)
// WARNING: Removing unreachable block (ram,0x000180053b60)
// WARNING: Removing unreachable block (ram,0x000180053b64)
// WARNING: Removing unreachable block (ram,0x000180053b72)
// WARNING: Removing unreachable block (ram,0x000180053b7a)
// WARNING: Removing unreachable block (ram,0x000180053b7e)
// WARNING: Removing unreachable block (ram,0x000180053b8e)
// WARNING: Removing unreachable block (ram,0x000180053bbe)
// WARNING: Removing unreachable block (ram,0x000180053bc6)
// WARNING: Removing unreachable block (ram,0x000180053bc9)
// WARNING: Removing unreachable block (ram,0x000180053b97)
// WARNING: Removing unreachable block (ram,0x000180053b9b)
// WARNING: Removing unreachable block (ram,0x000180053be2)
// WARNING: Removing unreachable block (ram,0x000180053bf0)
// WARNING: Removing unreachable block (ram,0x000180053c4c)
// WARNING: Removing unreachable block (ram,0x000180053c51)
// WARNING: Removing unreachable block (ram,0x000180053c5d)
// WARNING: Removing unreachable block (ram,0x000180053c60)
// WARNING: Removing unreachable block (ram,0x000180053c8e)
// WARNING: Removing unreachable block (ram,0x000180053c93)
// WARNING: Removing unreachable block (ram,0x000180053ca1)
// WARNING: Removing unreachable block (ram,0x000180053caa)
// WARNING: Removing unreachable block (ram,0x000180053caf)
// WARNING: Removing unreachable block (ram,0x000180053cbe)
// WARNING: Removing unreachable block (ram,0x000180053cf1)
// WARNING: Removing unreachable block (ram,0x000180053cf9)
// WARNING: Removing unreachable block (ram,0x000180053cfc)
// WARNING: Removing unreachable block (ram,0x000180053cc6)
// WARNING: Removing unreachable block (ram,0x000180053cce)
// WARNING: Removing unreachable block (ram,0x000180053d15)
// WARNING: Removing unreachable block (ram,0x000180053d23)
// WARNING: Removing unreachable block (ram,0x000180053d8b)
// WARNING: Removing unreachable block (ram,0x000180053d8f)
// WARNING: Removing unreachable block (ram,0x000180053d9a)
// WARNING: Removing unreachable block (ram,0x000180053d9d)
// WARNING: Removing unreachable block (ram,0x000180053dcd)
// WARNING: Removing unreachable block (ram,0x000180053dd1)
// WARNING: Removing unreachable block (ram,0x000180053ddf)
// WARNING: Removing unreachable block (ram,0x000180053de8)
// WARNING: Removing unreachable block (ram,0x000180053ded)
// WARNING: Removing unreachable block (ram,0x000180053dfc)
// WARNING: Removing unreachable block (ram,0x000180053e2f)
// WARNING: Removing unreachable block (ram,0x000180053e37)
// WARNING: Removing unreachable block (ram,0x000180053e3a)
// WARNING: Removing unreachable block (ram,0x000180053e03)
// WARNING: Removing unreachable block (ram,0x000180053e0b)
// WARNING: Removing unreachable block (ram,0x000180053e54)
// WARNING: Removing unreachable block (ram,0x000180053e63)
// WARNING: Removing unreachable block (ram,0x000180053ead)
// WARNING: Removing unreachable block (ram,0x000180053eb5)
// WARNING: Removing unreachable block (ram,0x000180053ee6)
// WARNING: Removing unreachable block (ram,0x000180053ef5)
// WARNING: Removing unreachable block (ram,0x000180053f18)
// WARNING: Removing unreachable block (ram,0x000180053f20)
// WARNING: Removing unreachable block (ram,0x000180053f43)
// WARNING: Removing unreachable block (ram,0x000180053f4b)
// WARNING: Removing unreachable block (ram,0x000180053f74)
// WARNING: Removing unreachable block (ram,0x000180053f79)
// WARNING: Removing unreachable block (ram,0x000180053f98)
// WARNING: Removing unreachable block (ram,0x000180053fa0)
// WARNING: Removing unreachable block (ram,0x000180053fbc)
// WARNING: Removing unreachable block (ram,0x000180053fc4)
// WARNING: Removing unreachable block (ram,0x000180053fe5)
// WARNING: Removing unreachable block (ram,0x000180053fea)
// WARNING: Removing unreachable block (ram,0x000180054035)
// WARNING: Removing unreachable block (ram,0x000180054062)
// WARNING: Removing unreachable block (ram,0x000180054075)
// WARNING: Removing unreachable block (ram,0x00018005407a)
// WARNING: Removing unreachable block (ram,0x0001800540b2)
// WARNING: Removing unreachable block (ram,0x0001800540b7)
// WARNING: Removing unreachable block (ram,0x0001800540d9)
// WARNING: Removing unreachable block (ram,0x0001800540e1)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800533d0(void* param_1,void* param_2,long long param_3)
void FUN_1800533d0(void* param_1,void* param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  uint32_t uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint8_t *systemPreviousNode;
  ulong long uVar8;
  undefined *puVar9;
  long long lVar10;
  uint uVar11;
  uint8_t auStack_228 [32];
  uint8_t uStack_208;
  uint32_t uStack_1f8;
  uint32_t uStack_1f4;
  undefined *puStack_1b0;
  uint8_t *puStack_1a8;
  uint uStack_1a0;
  void* uStack_198;
  undefined *puStack_f0;
  long long lStack_e8;
  uint uStack_e0;
  void* uStack_d8;
  void* uStack_d0;
  undefined *puStack_c8;
  void* uStack_c0;
  uint32_t uStack_b8;
  void* uStack_b0;
  uint8_t stackBuffer [32];
  void* uStack_68;
  void* uStack_60;
  char acStack_58 [16];
  ulong long uStack_48;
  
  uStack_68 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_228;
  systemPreviousNode = (uint8_t *)0x0;
  uStack_1f8 = 0;
  uStack_d0 = param_2;
  uStack_60 = param_2;
  uVar3 = GetCurrentProcessId();
  puStack_f0 = &SystemGlobalDataReference;
  uStack_d8 = 0;
  lStack_e8 = 0;
  uStack_e0 = 0;
  FUN_1806277c0(&puStack_f0,6);
  lVar1 = lStack_e8;
  uVar8 = (ulong long)uStack_e0;
  *(uint32_t *)(uVar8 + lStack_e8) = 0x44495020;
  *(undefined2 *)(uVar8 + 4 + lStack_e8) = 0x203a;
  *(uint8_t *)(uVar8 + 6 + lStack_e8) = 0;
  uStack_e0 = 6;
  FUN_180060680(acStack_58,&UNK_1809fd0a0,uVar3);
  lVar2 = -1;
  do {
    lVar10 = lVar2;
    lVar2 = lVar10 + 1;
  } while (acStack_58[lVar10 + 1] != '\0');
  if (0 < (int)(lVar10 + 1)) {
    FUN_1806277c0(&puStack_f0,(int)lVar10 + 7);
                    // WARNING: Subroutine does not return
    memcpy((ulong long)uStack_e0 + lStack_e8,acStack_58,(long long)((int)lVar10 + 2));
  }
  puVar9 = &DAT_1809fd128;
  if (DAT_180c82841 != '\0') {
    puVar9 = &UNK_1809fd730;
  }
  FUN_180627910(stackBuffer,puVar9);
  puStack_c8 = &SystemGlobalDataReference;
  uStack_b0 = 0;
  uStack_c0 = 0;
  uStack_b8 = 0;
  puStack_1b0 = &SystemGlobalDataReference;
  uVar11 = 0;
  uStack_198 = 0;
  puStack_1a8 = (uint8_t *)0x0;
  uStack_1a0 = 0;
  uStack_1f8 = 2;
  uVar6 = *(uint *)(param_3 + 0x10);
  uVar8 = (ulong long)uVar6;
  uVar5 = 0;
  if (*(long long *)(param_3 + 8) == 0) {
LAB_1800535b0:
    uVar11 = uVar5;
    if (uVar6 != 0) {
                    // WARNING: Subroutine does not return
      memcpy(systemPreviousNode,*(void* *)(param_3 + 8),uVar8);
    }
  }
  else if (uVar6 != 0) {
    iVar4 = uVar6 + 1;
    if (iVar4 < 0x10) {
      iVar4 = 0x10;
    }
    systemPreviousNode = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar4,0x13);
    *systemPreviousNode = 0;
    puStack_1a8 = systemPreviousNode;
    uVar5 = StartSystemThread(systemPreviousNode);
    uStack_198 = CONCAT44(uStack_198._4_4_,uVar5);
    goto LAB_1800535b0;
  }
  if (systemPreviousNode != (uint8_t *)0x0) {
    systemPreviousNode[uVar8] = 0;
  }
  uStack_1f4 = *(uint32_t *)(param_3 + 0x1c);
  uStack_198 = CONCAT44(uStack_1f4,(uint32_t)uStack_198);
  uStack_1a0 = uVar6;
  if (uVar6 != 0xfffffffa) {
    uVar6 = uVar6 + 7;
    if (systemPreviousNode == (uint8_t *)0x0) {
      if ((int)uVar6 < 0x10) {
        uVar6 = 0x10;
      }
      systemPreviousNode = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar6,0x13);
      *systemPreviousNode = 0;
    }
    else {
      if (uVar6 <= uVar11) goto LAB_18005364c;
      uStack_208 = 0x13;
      systemPreviousNode = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,systemPreviousNode,uVar6,0x10);
    }
    puStack_1a8 = systemPreviousNode;
    uVar3 = StartSystemThread(systemPreviousNode);
    uStack_198 = CONCAT44(uStack_198._4_4_,uVar3);
  }
LAB_18005364c:
                    // WARNING: Subroutine does not return
  memcpy(systemPreviousNode + uVar8,lVar1,7);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void*
FUN_180054120(void* param_1,void* param_2,void* param_3,void* param_4)

{
  char systemNodeFlag;
  char cVar2;
  void* *puVar3;
  void* *puVar4;
  void* *puVar5;
  long long lVar6;
  char *pcVar7;
  uint uVar8;
  int *piVar10;
  ulong long uVar11;
  void* uVar12;
  ulong long uVar13;
  ulong long uVar14;
  long long lVar15;
  void* *puVar16;
  ulong long uVar17;
  undefined *puStack_70;
  uint8_t *puStack_68;
  uint uStack_60;
  void* uStack_58;
  void* *puStack_50;
  void* *puStack_48;
  void* uStack_40;
  uint32_t uStack_38;
  ulong long uVar9;
  
  puStack_50 = (void* *)0x0;
  puStack_48 = (void* *)0x0;
  uVar17 = 0;
  uStack_40 = 0;
  uStack_38 = 3;
  FUN_180052200(_DAT_180c86870,&puStack_50,param_3,param_4,0xfffffffffffffffe);
  puVar5 = puStack_48;
  puVar4 = puStack_50;
  uVar11 = (long long)puStack_48 - (long long)puStack_50 >> 5;
  puVar3 = puVar4;
  if (uVar11 == 0) {
LAB_180054302:
    uVar12 = 0;
joined_r0x00018005430b:
    for (; puVar3 != puVar5; puVar3 = puVar3 + 4) {
      (**(code **)*puVar3)(puVar3,0);
    }
    if (puVar4 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar4);
    }
    return uVar12;
  }
  piVar10 = (int *)(puStack_50 + 2);
  uVar13 = uVar17;
LAB_18005419d:
  puStack_70 = &SystemGlobalDataReference;
  uStack_58 = 0;
  puStack_68 = (uint8_t *)0x0;
  uStack_60 = 0;
  FUN_1806277c0(&puStack_70,*piVar10);
  if (*piVar10 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(puStack_68,*(void* *)(piVar10 + -2),*piVar10 + 1);
  }
  if (*(long long *)(piVar10 + -2) != 0) {
    uStack_60 = 0;
    if (puStack_68 != (uint8_t *)0x0) {
      *puStack_68 = 0;
    }
    uStack_58 = uStack_58 & 0xffffffff;
  }
  uVar9 = uVar17;
  uVar14 = uVar17;
  if (uStack_60 != 0) {
    do {
      if ((byte)(puStack_68[uVar14] + 0xbf) < 0x1a) {
        puStack_68[uVar14] = puStack_68[uVar14] + ' ';
      }
      uVar8 = (int)uVar9 + 1;
      uVar9 = (ulong long)uVar8;
      uVar14 = uVar14 + 1;
    } while (uVar8 < uStack_60);
  }
  lVar6 = func_0x0001800464d0(&puStack_70);
  puVar16 = (void* *)&UNK_1809fde40;
  do {
    pcVar7 = (char *)*puVar16;
    lVar15 = lVar6 - (long long)pcVar7;
    do {
      cVar1 = *pcVar7;
      cVar2 = pcVar7[lVar15];
      if (cVar1 != cVar2) break;
      pcVar7 = pcVar7 + 1;
    } while (cVar2 != '\0');
    if (cVar1 == cVar2) break;
    puVar16 = puVar16 + 1;
    if (0x1809fde87 < (long long)puVar16) {
      puStack_70 = &SystemGlobalDataReference;
      if (puStack_68 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      puStack_68 = (uint8_t *)0x0;
      uStack_58 = (ulong long)uStack_58._4_4_ << 0x20;
      puStack_70 = &SystemMemoryAllocatorReference;
      uVar12 = 1;
      goto joined_r0x00018005430b;
    }
  } while( true );
  puStack_70 = &SystemGlobalDataReference;
  if (puStack_68 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_68 = (uint8_t *)0x0;
  uStack_58 = (ulong long)uStack_58._4_4_ << 0x20;
  puStack_70 = &SystemMemoryAllocatorReference;
  uVar8 = (int)uVar13 + 1;
  uVar13 = (ulong long)uVar8;
  piVar10 = piVar10 + 8;
  if (uVar11 <= (ulong long)(long long)(int)uVar8) goto LAB_180054302;
  goto LAB_18005419d;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180054360(long long *param_1,long long param_2)
void FUN_180054360(long long *param_1,long long param_2)

{
  uint uVar1;
  int iVar2;
  void* uVar3;
  long long* systemMemoryPointer;
  undefined *puVar5;
  long long lVar6;
  ulong long uVar7;
  uint8_t auStack_238 [32];
  uint32_t uStack_218;
  undefined *puStack_208;
  long long lStack_200;
  uint uStack_1f8;
  void* uStack_1f0;
  uint32_t uStack_1e8;
  undefined *puStack_1e0;
  long long lStack_1d8;
  uint uStack_1d0;
  void* uStack_1c8;
  undefined *puStack_1c0;
  long long lStack_1b8;
  uint32_t uStack_1b0;
  ulong long uStack_1a8;
  uint32_t uStack_1a0;
  uint uStack_19c;
  uint8_t uStack_198;
  uint32_t uStack_194;
  undefined *puStack_190;
  long long lStack_188;
  int iStack_180;
  uint32_t uStack_178;
  undefined **ppuStack_170;
  undefined *puStack_168;
  long long lStack_160;
  uint32_t uStack_150;
  uint32_t uStack_148;
  uint32_t uStack_144;
  uint32_t uStack_140;
  uint32_t uStack_13c;
  uint32_t uStack_138;
  uint32_t uStack_134;
  uint32_t uStack_130;
  uint32_t uStack_12c;
  uint32_t uStack_128;
  uint32_t uStack_124;
  uint32_t uStack_120;
  uint32_t uStack_11c;
  uint32_t uStack_118;
  uint32_t uStack_114;
  uint32_t uStack_110;
  uint32_t uStack_10c;
  uint8_t uStack_108;
  uint32_t uStack_107;
  uint32_t uStack_103;
  void* uStack_f8;
  undefined **ppuStack_f0;
  undefined *puStack_e8;
  uint8_t *puStack_e0;
  uint32_t uStack_d8;
  uint8_t auStack_d0 [136];
  ulong long uStack_48;
  
  uStack_f8 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_238;
  uStack_1e8 = 0;
  ppuStack_f0 = &puStack_1c0;
  puStack_1c0 = &SystemGlobalDataReference;
  uStack_1a8 = 0;
  lStack_1b8 = 0;
  uStack_1b0 = 0;
  uStack_19c = 0x100;
  uStack_198 = 0;
  uStack_194 = 0;
  puVar5 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar5 = *(undefined **)(param_2 + 8);
  }
  FUN_180627c50(&puStack_1c0,puVar5);
  uStack_1a0 = 0;
  uStack_19c = uStack_19c & 0xffffff00;
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x60d30,0x10,0x1f);
  plVar4 = (long long *)FUN_1801954d0(uVar3,&puStack_1c0);
  ppuStack_170 = (undefined **)plVar4;
  if (plVar4 != (long long *)0x0) {
    (**(code **)(*plVar4 + 0x28))(plVar4);
  }
  uStack_148 = 0x3f800000;
  uStack_144 = 0;
  uStack_140 = 0;
  uStack_13c = 0;
  uStack_138 = 0;
  uStack_134 = 0x3f800000;
  uStack_130 = 0;
  uStack_12c = 0;
  uStack_128 = 0;
  uStack_124 = 0;
  uStack_120 = 0x3f800000;
  uStack_11c = 0;
  uStack_118 = 0;
  uStack_114 = 0;
  uStack_110 = 0;
  uStack_10c = 0x3f800000;
  uStack_107 = 0x1010101;
  uStack_103 = 1;
  uStack_108 = 1;
  puStack_e8 = &UNK_1809fcc28;
  puStack_e0 = auStack_d0;
  auStack_d0[0] = 0;
  uStack_d8 = *(uint32_t *)(param_2 + 0x10);
  puVar5 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar5 = *(undefined **)(param_2 + 8);
  }
  strcpy_s(auStack_d0,0x80,puVar5);
  FUN_18019e140(&puStack_190,&puStack_e8);
  puStack_e8 = &SystemMemoryAllocatorReference;
  puStack_1e0 = &SystemGlobalDataReference;
  uStack_1c8 = 0;
  lStack_1d8 = 0;
  uStack_1d0 = 0;
  lVar6 = *param_1;
  FUN_1806279c0(&puStack_168,param_2);
  iVar2 = FUN_1801426a0(lVar6,&puStack_168);
  puStack_168 = &SystemGlobalDataReference;
  if (lStack_160 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_160 = 0;
  uStack_150 = 0;
  puStack_168 = &SystemMemoryAllocatorReference;
  if ((iVar2 < 0) ||
     (lVar6 = *(long long *)(*param_1 + 0x888),
     (ulong long)(*(long long *)(*param_1 + 0x890) - lVar6 >> 5) <= (ulong long)(long long)iVar2)) {
    lVar6 = FUN_180628ca0();
  }
  else {
    lVar6 = (long long)iVar2 * 0x20 + lVar6;
  }
  puStack_208 = &SystemGlobalDataReference;
  uStack_1f0 = 0;
  lStack_200 = 0;
  uStack_1f8 = 0;
  uStack_1e8 = 1;
  uVar1 = *(uint *)(lVar6 + 0x10);
  uVar7 = (ulong long)uVar1;
  if (*(long long *)(lVar6 + 8) != 0) {
    FUN_1806277c0(&puStack_208,uVar7);
  }
  if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(lStack_200,*(void* *)(lVar6 + 8),uVar7);
  }
  if (lStack_200 != 0) {
    *(uint8_t *)(uVar7 + lStack_200) = 0;
  }
  uStack_1f0 = CONCAT44(*(uint *)(lVar6 + 0x1c),(uint32_t)uStack_1f0);
  if (0 < iStack_180) {
    uStack_1f8 = uVar1;
    FUN_1806277c0(&puStack_208,iStack_180);
                    // WARNING: Subroutine does not return
    memcpy((ulong long)uStack_1f8 + lStack_200,lStack_188,(long long)(iStack_180 + 1));
  }
  lStack_1d8 = lStack_200;
  uStack_1c8._0_4_ = (uint32_t)uStack_1f0;
  uStack_1f8 = 0;
  uStack_1e8 = 0;
  lStack_200 = 0;
  uStack_1f0 = 0;
  puStack_208 = &SystemMemoryAllocatorReference;
  uStack_218 = 0xffffffff;
  uStack_1d0 = uVar1;
  uStack_1c8._4_4_ = *(uint *)(lVar6 + 0x1c);
  FUN_1801a6440(plVar4,_DAT_180c868e8,&puStack_1e0,&uStack_148);
  FUN_18019e260(plVar4);
  (**(code **)(*(long long *)param_1[0x56] + 0x138))((long long *)param_1[0x56],plVar4);
  FUN_180199500(plVar4,0x3d072b02,1);
  FUN_1801a2ea0(plVar4);
  (**(code **)(*(long long *)param_1[0x56] + 0x140))((long long *)param_1[0x56],plVar4);
  Sleep(1000);
  puStack_1e0 = &SystemGlobalDataReference;
  if (lStack_1d8 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_1d8 = 0;
  uStack_1c8 = (ulong long)uStack_1c8._4_4_ << 0x20;
  puStack_1e0 = &SystemMemoryAllocatorReference;
  puStack_190 = &SystemGlobalDataReference;
  if (lStack_188 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_188 = 0;
  uStack_178 = 0;
  puStack_190 = &SystemMemoryAllocatorReference;
  if (plVar4 != (long long *)0x0) {
    (**(code **)(*plVar4 + 0x38))(plVar4);
  }
  ppuStack_170 = &puStack_1c0;
  puStack_1c0 = &SystemGlobalDataReference;
  if (lStack_1b8 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_1b8 = 0;
  uStack_1a8 = uStack_1a8 & 0xffffffff00000000;
  puStack_1c0 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_238);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800547b0(void)
void FUN_1800547b0(void)

{
  uint uVar1;
  long long *plVar2;
  void* *puVar3;
  char cVar4;
  void* *puVar5;
  uint8_t *puVar6;
  uint32_t *systemPreviousNode;
  int iVar8;
  int iVar9;
  long long lVar10;
  ulong long uVar11;
  void* *puVar12;
  int iVar13;
  long long lVar14;
  uint *puVar15;
  undefined *puVar16;
  uint32_t uVar17;
  uint8_t auStack_178 [32];
  undefined *puStack_158;
  uint8_t *puStack_150;
  uint uStack_148;
  void* uStack_140;
  undefined *puStack_138;
  uint8_t *puStack_130;
  uint uStack_128;
  ulong long uStack_120;
  undefined *puStack_118;
  uint8_t *puStack_110;
  uint32_t uStack_108;
  ulong long uStack_100;
  int iStack_f8;
  undefined *puStack_f0;
  uint8_t *puStack_e8;
  uint32_t uStack_e0;
  ulong long uStack_d8;
  undefined *puStack_d0;
  long long lStack_c8;
  int iStack_c0;
  uint32_t uStack_b8;
  long long *plStack_a8;
  long long lStack_a0;
  undefined *stackParameterB;
  undefined *pstackParameterC;
  uint32_t uStack_80;
  undefined *puStack_78;
  long long lStack_70;
  uint32_t uStack_60;
  void* *puStack_58;
  void* *puStack_50;
  void* uStack_48;
  uint32_t uStack_40;
  void* uStack_38;
  ulong long uStack_30;
  
  uStack_38 = 0xfffffffffffffffe;
  uStack_30 = _DAT_180bf00a8 ^ (ulong long)auStack_178;
  plStack_a8 = _DAT_180c86870;
  lVar14 = *(long long *)(*_DAT_180c86870 + 0x890) - *(long long *)(*_DAT_180c86870 + 0x888) >> 5;
  iStack_f8 = 0;
  lStack_a0 = lVar14;
  if (0 < (int)lVar14) {
    do {
      iVar9 = iStack_f8;
      iVar13 = 0;
      if (iStack_f8 < 0) {
LAB_18005485e:
        lVar10 = FUN_180628ca0();
      }
      else {
        lVar10 = *(long long *)(*_DAT_180c86870 + 0x888);
        if ((ulong long)(*(long long *)(*_DAT_180c86870 + 0x890) - lVar10 >> 5) <=
            (ulong long)(long long)iStack_f8) goto LAB_18005485e;
        lVar10 = (long long)iStack_f8 * 0x20 + lVar10;
      }
      puStack_138 = &SystemGlobalDataReference;
      uStack_120 = 0;
      puStack_130 = (uint8_t *)0x0;
      uStack_128 = 0;
      FUN_1806277c0(&puStack_138,*(uint32_t *)(lVar10 + 0x10));
      if (*(int *)(lVar10 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
        memcpy(puStack_130,*(void* *)(lVar10 + 8),*(int *)(lVar10 + 0x10) + 1);
      }
      if (*(long long *)(lVar10 + 8) != 0) {
        uStack_128 = 0;
        if (puStack_130 != (uint8_t *)0x0) {
          *puStack_130 = 0;
        }
        uStack_120 = uStack_120 & 0xffffffff;
      }
      if (iVar9 < 0) {
LAB_180054912:
        lVar10 = FUN_180628ca0();
      }
      else {
        lVar10 = *(long long *)(*_DAT_180c86870 + 0x8a8);
        if ((ulong long)(*(long long *)(*_DAT_180c86870 + 0x8b0) - lVar10 >> 5) <
            (ulong long)(long long)iVar9) goto LAB_180054912;
        lVar10 = (long long)iVar9 * 0x20 + lVar10;
      }
      puStack_118 = &SystemGlobalDataReference;
      uStack_100 = 0;
      puStack_110 = (uint8_t *)0x0;
      uStack_108 = 0;
      FUN_1806277c0(&puStack_118,*(uint32_t *)(lVar10 + 0x10));
      if (*(int *)(lVar10 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
        memcpy(puStack_110,*(void* *)(lVar10 + 8),*(int *)(lVar10 + 0x10) + 1);
      }
      if (*(long long *)(lVar10 + 8) != 0) {
        uStack_108 = 0;
        if (puStack_110 != (uint8_t *)0x0) {
          *puStack_110 = 0;
        }
        uStack_100 = uStack_100 & 0xffffffff;
      }
      iVar8 = uStack_128 + 8;
      FUN_1806277c0(&puStack_138,iVar8);
      *(void* *)(puStack_130 + uStack_128) = 0x6a624f656e656353;
      *(uint8_t *)((long long)(puStack_130 + uStack_128) + 8) = 0;
      uStack_128 = iVar8;
      cVar4 = FUN_180624a00(&puStack_138);
      if (cVar4 == '\0') {
        puStack_118 = &SystemGlobalDataReference;
        if (puStack_110 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        puStack_110 = (uint8_t *)0x0;
        uStack_100 = uStack_100 & 0xffffffff00000000;
        puStack_118 = &SystemMemoryAllocatorReference;
        puStack_138 = &SystemGlobalDataReference;
        if (puStack_130 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
      }
      else {
        puStack_58 = (void* *)0x0;
        puStack_50 = (void* *)0x0;
        uStack_48 = 0;
        uStack_40 = 3;
        FUN_18062c5f0(&puStack_138,&puStack_58);
        puVar5 = puStack_50;
        puVar3 = puStack_58;
        lVar10 = (long long)puStack_50 - (long long)puStack_58;
        FUN_18004b100(&puStack_d0);
        puVar6 = &SystemStringTemplate;
        if (puStack_110 != (uint8_t *)0x0) {
          puVar6 = puStack_110;
        }
        FUN_180628040(&puStack_d0,&UNK_1809fd7c4,puVar6);
        cVar4 = FUN_180624a00(&puStack_d0);
        if (cVar4 == '\0') {
          FUN_180624910(&puStack_d0);
        }
        plVar2 = plStack_a8;
        iVar8 = (int)(lVar10 >> 5);
        lVar10 = (long long)iVar8;
        if (0 < iVar8) {
          puVar15 = (uint *)(puVar3 + 2);
          do {
            FUN_180061db0();
            FUN_180061be0();
            puStack_158 = &SystemGlobalDataReference;
            uStack_140._0_4_ = 0;
            uStack_140._4_4_ = 0;
            puStack_150 = (uint8_t *)0x0;
            uStack_148 = 0;
            FUN_1806277c0(&puStack_158,*puVar15);
            if (*puVar15 != 0) {
                    // WARNING: Subroutine does not return
              memcpy(puStack_150,*(void* *)(puVar15 + -2),*puVar15 + 1);
            }
            if (*(long long *)(puVar15 + -2) != 0) {
              uStack_148 = 0;
              if (puStack_150 != (uint8_t *)0x0) {
                *puStack_150 = 0;
              }
              uStack_140._4_4_ = 0;
            }
            iVar9 = uStack_148 + 0xd;
            FUN_1806277c0(&puStack_158,iVar9);
            puVar5 = (void* *)(puStack_150 + uStack_148);
            *puVar5 = 0x782e656e6563732f;
            *(uint32_t *)(puVar5 + 1) = 0x6e656373;
            *(undefined2 *)((long long)puVar5 + 0xc) = 0x65;
            puVar6 = &SystemStringTemplate;
            if (puStack_150 != (uint8_t *)0x0) {
              puVar6 = puStack_150;
            }
            uStack_148 = iVar9;
            lVar14 = strstr(puVar6,&UNK_1809fd7d8);
            if (lVar14 == 0) {
              puVar6 = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                puVar6 = puStack_150;
              }
              lVar14 = strstr(puVar6,&UNK_1809fd7f8);
              if (lVar14 != 0) goto LAB_180054ec9;
              puVar6 = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                puVar6 = puStack_150;
              }
              lVar14 = strstr(puVar6,&UNK_1809fd810);
              if (lVar14 != 0) goto LAB_180054ec9;
              puVar6 = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                puVar6 = puStack_150;
              }
              lVar14 = strstr(puVar6,&UNK_1809fd828);
              if (lVar14 != 0) goto LAB_180054ec9;
              puVar6 = &SystemStringTemplate;
              if (puStack_150 != (uint8_t *)0x0) {
                puVar6 = puStack_150;
              }
              lVar14 = strstr(puVar6,&UNK_1809fd848);
              if (lVar14 != 0) goto LAB_180054ec9;
              cVar4 = FUN_180624af0(&puStack_158);
              if (cVar4 == '\0') {
                uStack_148 = 0;
                if (puStack_150 != (uint8_t *)0x0) {
                  *puStack_150 = 0;
                }
                uVar1 = *puVar15;
                uVar11 = (ulong long)uVar1;
                if (*(long long *)(puVar15 + -2) != 0) {
                  FUN_1806277c0(&puStack_158,uVar11);
                }
                if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
                  memcpy(puStack_150,*(void* *)(puVar15 + -2),uVar11);
                }
                if (puStack_150 != (uint8_t *)0x0) {
                  puStack_150[uVar11] = 0;
                }
                uStack_140._4_4_ = puVar15[3];
                uStack_148 = uVar1;
                FUN_1806277c0(&puStack_158,0x12);
                systemPreviousNode = (uint32_t *)(puStack_150 + uStack_148);
                *systemPreviousNode = 0x6563732f;
                systemPreviousNode[1] = 0x782e656e;
                systemPreviousNode[2] = 0x2e6f6373;
                systemPreviousNode[3] = 0x65637378;
                *(undefined2 *)(systemPreviousNode + 4) = 0x656e;
                *(uint8_t *)((long long)systemPreviousNode + 0x12) = 0;
                uStack_148 = 0x12;
                cVar4 = FUN_180624af0(&puStack_158);
                if (cVar4 != '\0') goto LAB_180054d28;
                puStack_158 = &SystemGlobalDataReference;
                if (puStack_150 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900();
                }
                uStack_140 = (ulong long)uStack_140._4_4_ << 0x20;
              }
              else {
LAB_180054d28:
                iVar9 = *puVar15 - 1;
                if (-1 < iVar9) {
                  lVar14 = (long long)iVar9;
                  do {
                    if (*(char *)(lVar14 + *(long long *)(puVar15 + -2)) == '/') goto LAB_180054d57;
                    iVar9 = iVar9 + -1;
                    lVar14 = lVar14 + -1;
                  } while (-1 < lVar14);
                }
                iVar9 = -1;
LAB_180054d57:
                FUN_180629a40(puVar3 + (long long)iVar13 * 4,&stackParameterB,iVar9 + 1,0xffffffff);
                uVar17 = FUN_180054360(plVar2,&stackParameterB);
                if (_DAT_180c82854 != 0) {
                  FUN_18005c1c0(uVar17,&puStack_78);
                  puStack_f0 = &SystemGlobalDataReference;
                  uStack_d8 = 0;
                  puStack_e8 = (uint8_t *)0x0;
                  uStack_e0 = 0;
                  FUN_1806277c0(&puStack_f0,iStack_c0);
                  if (iStack_c0 != 0) {
                    // WARNING: Subroutine does not return
                    memcpy(puStack_e8,lStack_c8,iStack_c0 + 1);
                  }
                  if (lStack_c8 != 0) {
                    uStack_e0 = 0;
                    if (puStack_e8 != (uint8_t *)0x0) {
                      *puStack_e8 = 0;
                    }
                    uStack_d8 = uStack_d8 & 0xffffffff;
                  }
                  puVar16 = &SystemStringTemplate;
                  if (pstackParameterC != (undefined *)0x0) {
                    puVar16 = pstackParameterC;
                  }
                  FUN_180628040(&puStack_f0,&UNK_1809fd870,puVar16);
                  FUN_18062db60(&puStack_f0,&puStack_78);
                  _DAT_180c82854 = 0;
                  puStack_f0 = &SystemGlobalDataReference;
                  if (puStack_e8 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  puStack_e8 = (uint8_t *)0x0;
                  uStack_d8 = uStack_d8 & 0xffffffff00000000;
                  puStack_f0 = &SystemMemoryAllocatorReference;
                  puStack_78 = &SystemGlobalDataReference;
                  if (lStack_70 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  lStack_70 = 0;
                  uStack_60 = 0;
                  puStack_78 = &SystemMemoryAllocatorReference;
                }
                stackParameterB = &SystemGlobalDataReference;
                if (pstackParameterC != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900();
                }
                pstackParameterC = (undefined *)0x0;
                uStack_80 = 0;
                stackParameterB = &SystemMemoryAllocatorReference;
                puStack_158 = &SystemGlobalDataReference;
                if (puStack_150 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900();
                }
                uStack_140 = (ulong long)uStack_140._4_4_ << 0x20;
              }
            }
            else {
LAB_180054ec9:
              puStack_158 = &SystemGlobalDataReference;
              if (puStack_150 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
                FUN_18064e900();
              }
              uStack_140 = (ulong long)uStack_140._4_4_ << 0x20;
            }
            puStack_150 = (uint8_t *)0x0;
            puStack_158 = &SystemMemoryAllocatorReference;
            iVar13 = iVar13 + 1;
            puVar15 = puVar15 + 8;
            lVar10 = lVar10 + -1;
            lVar14 = lStack_a0;
            puVar5 = puStack_50;
            iVar9 = iStack_f8;
          } while (lVar10 != 0);
        }
        puStack_d0 = &SystemGlobalDataReference;
        if (lStack_c8 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        lStack_c8 = 0;
        uStack_b8 = 0;
        puStack_d0 = &SystemMemoryAllocatorReference;
        for (puVar12 = puVar3; puVar12 != puVar5; puVar12 = puVar12 + 4) {
          (**(code **)*puVar12)(puVar12,0);
        }
        if (puVar3 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(puVar3);
        }
        puStack_118 = &SystemGlobalDataReference;
        if (puStack_110 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        puStack_110 = (uint8_t *)0x0;
        uStack_100 = uStack_100 & 0xffffffff00000000;
        puStack_118 = &SystemMemoryAllocatorReference;
        puStack_138 = &SystemGlobalDataReference;
        if (puStack_130 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
      }
      puStack_110 = (uint8_t *)0x0;
      puStack_118 = &SystemMemoryAllocatorReference;
      uStack_120 = uStack_120 & 0xffffffff00000000;
      puStack_130 = (uint8_t *)0x0;
      puStack_138 = &SystemMemoryAllocatorReference;
      iStack_f8 = iVar9 + 1;
    } while (iStack_f8 < (int)lVar14);
  }
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_30 ^ (ulong long)auStack_178);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180055050(void)
void FUN_180055050(void)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  long long lVar4;
  
  puVar2 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x198,8,3);
  puVar1 = puVar2 + 4;
  CreateSystemCounter(puVar1);
  *puVar1 = &UNK_180a3cf50;
  *(undefined2 *)(puVar2 + 0x1a) = 1;
  *(uint32_t *)(puVar2 + 9) = 0;
  *(uint8_t *)((long long)puVar2 + 0x54) = 0;
  *puVar1 = &UNK_1809fe6d8;
  puVar1 = puVar2 + 0x1b;
  CreateSystemCounter(puVar1);
  *puVar1 = &UNK_180a3cf50;
  *(undefined2 *)(puVar2 + 0x31) = 1;
  *(uint32_t *)(puVar2 + 0x20) = 0;
  *(uint8_t *)((long long)puVar2 + 0x10c) = 0;
  *puVar1 = &UNK_1809fe6d8;
  *puVar2 = 0;
  *(uint8_t *)(puVar2 + 3) = 0;
  puVar2[2] = 0xffffffff00000000;
  *(uint32_t *)(puVar2 + 1) = 0xe;
  _DAT_180c86928 = puVar2;
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x480,8,3);
  _DAT_180c8a9f8 = FUN_18004bd10(uVar3);
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x10420,8,3);
  _DAT_180c868c0 = FUN_18005c090(uVar3);
  _DAT_180c868d8 = FUN_18062b1e0(_DAT_180c8ed18,0x30,8,3);
  *(uint32_t *)(_DAT_180c868d8 + 0x19) = 0;
  *(undefined2 *)(_DAT_180c868d8 + 0x1d) = 0;
  *(uint8_t *)(_DAT_180c868d8 + 0x1f) = 0;
  *(uint32_t *)(_DAT_180c868d8 + 0x28) = 3;
  *(long long *)_DAT_180c868d8 = _DAT_180c868d8;
  *(long long *)(_DAT_180c868d8 + 8) = _DAT_180c868d8;
  *(void* *)(_DAT_180c868d8 + 0x10) = 0;
  *(uint8_t *)(_DAT_180c868d8 + 0x18) = 0;
  *(void* *)(_DAT_180c868d8 + 0x20) = 0;
  _DAT_180c86910 = FUN_18062b1e0(_DAT_180c8ed18,8,4,3);
  *(uint32_t *)(_DAT_180c86910 + 4) = 0;
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x80,8,3);
  _DAT_180c86900 = FUN_18015c450(uVar3);
  lVar4 = FUN_18062b1e0(_DAT_180c8ed18,0xe8,8,3);
  _Mtx_init_in_situ(lVar4,2);
  _Mtx_init_in_situ(lVar4 + 0x50,2);
  *(void* *)(lVar4 + 0xa0) = 0;
  *(void* *)(lVar4 + 0xa8) = 0;
  *(void* *)(lVar4 + 0xb0) = 0;
  *(uint32_t *)(lVar4 + 0xb8) = 3;
  *(void* *)(lVar4 + 0xc0) = 0;
  *(void* *)(lVar4 + 200) = 0;
  *(void* *)(lVar4 + 0xd0) = 0;
  *(uint32_t *)(lVar4 + 0xd8) = 0x20;
  *(uint32_t *)(lVar4 + 0xe0) = 0;
  _DAT_180c8a998 = lVar4;
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
                    // WARNING: Subroutine does not return
  memset(uVar3,0,0x70);
}




// 函数: void FUN_180055e10(long long *param_1)
void FUN_180055e10(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x48) {
    FUN_180058c20(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180055e30(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180055e30(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058210(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180055e60(long long param_1)
void FUN_180055e60(long long param_1)

{
  long long lVar1;
  long long lVar2;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar3 = *(ulong long *)(param_1 + 0x10);
  lVar1 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar3 != 0) {
    do {
      lVar2 = *(long long *)(lVar1 + uVar4 * 8);
      if (lVar2 != 0) {
        if (*(long long **)(lVar2 + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(lVar2 + 0x10) + 0x38))();
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar1 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar3);
    uVar3 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar3) && (*(long long *)(param_1 + 8) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



long long FUN_180055e80(long long param_1)

{
  *(void* *)(param_1 + 8) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  *(void* *)(param_1 + 8) = &SystemGlobalDataReference;
  *(void* *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  return param_1;
}




// 函数: void FUN_180055ed0(long long param_1)
void FUN_180055ed0(long long param_1)

{
  *(void* *)(param_1 + 8) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 8) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180055f20(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180055f20(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058210(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180055f50(long long param_1)
void FUN_180055f50(long long param_1)

{
  long long lVar1;
  long long lVar2;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar3 = *(ulong long *)(param_1 + 0x10);
  lVar1 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar3 != 0) {
    do {
      lVar2 = *(long long *)(lVar1 + uVar4 * 8);
      if (lVar2 != 0) {
        if (*(long long **)(lVar2 + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(lVar2 + 0x10) + 0x38))();
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar1 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar3);
    uVar3 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar3) && (*(long long *)(param_1 + 8) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180055f70(void* param_1,uint32_t param_2)
void FUN_180055f70(void* param_1,uint32_t param_2)

{
  code *pcVar1;
  
  if (_DAT_180c8f008 != 0) {
    func_0x00018005a410(_DAT_180c8f008 + 8);
  }
  Sleep(2000);
  _Exit(param_2);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180055fa0(void)
void FUN_180055fa0(void)

{
  void* *puVar1;
  void* uVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  void* in_R9;
  void* uVar6;
  
  pcVar3 = _DAT_180c8a9d8;
  uVar6 = 0xfffffffffffffffe;
  if (*_DAT_180c8a9d8 != '\0') {
    puVar1 = (void* *)*_DAT_180c86960;
    iVar4 = _Mtx_lock(0x180c91970);
    if (iVar4 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar4);
    }
    uVar2 = _DAT_180c8a9b0;
    _DAT_180c8a9b0 = *puVar1;
    FUN_1801299b0(&UNK_1809fd9a0,0,0,in_R9,uVar6);
    FUN_18010f010(&UNK_1809fd9b0,*(uint32_t *)(pcVar3 + 4));
    FUN_18010f010(&UNK_1809fd9d0,*(uint32_t *)(pcVar3 + 8));
    FUN_18010f010(&UNK_1809fd9f0,*(uint32_t *)(pcVar3 + 0xc));
    FUN_18010f010(&UNK_1809fda10,*(uint32_t *)(pcVar3 + 0x10));
    FUN_18010f010(&UNK_1809fda30,*(uint32_t *)(pcVar3 + 0x14));
    FUN_18010f010(&UNK_1809fda58,*(uint32_t *)(pcVar3 + 0x18));
    for (pcVar5 = *(char **)(pcVar3 + 0x28); pcVar5 != pcVar3 + 0x20;
        pcVar5 = (char *)func_0x00018066bd70(pcVar5)) {
      FUN_18010f010(&UNK_1809fda80,*(uint32_t *)(pcVar5 + 0x20),*(uint32_t *)(pcVar5 + 0x24));
    }
    for (pcVar5 = *(char **)(pcVar3 + 0x58); pcVar5 != pcVar3 + 0x50;
        pcVar5 = (char *)func_0x00018066bd70(pcVar5)) {
      FUN_18010f010(&UNK_1809fdaa8,*(uint32_t *)(pcVar5 + 0x20),*(uint32_t *)(pcVar5 + 0x24));
    }
    FUN_18010f010(&UNK_1809fdad0,*(uint32_t *)(pcVar3 + 0x80));
    FUN_18010f010(&UNK_1809fdaf8,*(uint32_t *)(pcVar3 + 0x84));
    FUN_18010f010(&UNK_1809fdb20,*(uint32_t *)(pcVar3 + 0x88));
    FUN_18012cfe0();
    _DAT_180c8a9b0 = uVar2;
    iVar4 = _Mtx_unlock(0x180c91970);
    if (iVar4 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar4);
    }
  }
  return;
}




// 函数: void FUN_180056150(long long param_1)
void FUN_180056150(long long param_1)

{
  char systemNodeFlag;
  char cVar2;
  int memoryCompareResult;
  void* *puVar4;
  ulong long uVar5;
  int iVar6;
  char *pcVar7;
  long long *plVar8;
  long long lVar9;
  ulong long uVar10;
  long long lVar11;
  long long lVar12;
  int iVar13;
  long long lVar14;
  int iVar15;
  long long lVar16;
  int iVar17;
  ulong long uVar18;
  int iVar19;
  bool bVar20;
  
  uVar10 = 0;
  lVar9 = *(long long *)(param_1 + 0x50);
  lVar12 = *(long long *)(param_1 + 0x48);
  if (lVar9 - lVar12 >> 3 != 0) {
    iVar19 = 1;
    lVar16 = 8;
    uVar18 = uVar10;
    do {
      iVar17 = (int)uVar10;
      iVar6 = -1;
      if ((ulong long)(long long)iVar19 < (ulong long)(lVar9 - lVar12 >> 3)) {
        lVar9 = *(long long *)(param_1 + 0x50);
        lVar14 = lVar16;
        iVar13 = iVar19;
        iVar15 = -1;
        do {
          iVar6 = *(int *)(*(long long *)(lVar14 + lVar12) + 0x10);
          iVar3 = *(int *)(*(long long *)(uVar18 + lVar12) + 0x10);
          if (iVar6 == iVar3) {
            if (iVar6 == 0) {
LAB_180056220:
              if (iVar3 != 0) goto LAB_180056228;
              bVar20 = true;
            }
            else {
              pcVar7 = *(char **)(*(long long *)(lVar14 + lVar12) + 8);
              lVar11 = *(long long *)(*(long long *)(uVar18 + lVar12) + 8) - (long long)pcVar7;
              do {
                cVar1 = *pcVar7;
                cVar2 = pcVar7[lVar11];
                if (cVar1 != cVar2) break;
                pcVar7 = pcVar7 + 1;
              } while (cVar2 != '\0');
              bVar20 = cVar1 == cVar2;
            }
          }
          else {
            if (iVar6 == 0) goto LAB_180056220;
LAB_180056228:
            bVar20 = false;
          }
          iVar6 = iVar13;
          if (!bVar20) {
            iVar6 = iVar15;
          }
          iVar13 = iVar13 + 1;
          lVar14 = lVar14 + 8;
          iVar15 = iVar6;
        } while ((ulong long)(long long)iVar13 < (ulong long)(lVar9 - lVar12 >> 3));
      }
      if (iVar6 != -1) {
        lVar14 = (long long)iVar6;
        lVar9 = *(long long *)(lVar12 + lVar14 * 8);
        *(double *)(*(long long *)(uVar18 + lVar12) + 0x40) =
             *(double *)(lVar9 + 0x40) + *(double *)(*(long long *)(uVar18 + lVar12) + 0x40);
        plVar8 = *(long long **)(lVar9 + 0x48);
        if (plVar8 != *(long long **)(lVar9 + 0x50)) {
          lVar12 = *(long long *)(param_1 + 0x48);
          do {
            *(void* *)(*plVar8 + 0x68) = *(void* *)(uVar18 + lVar12);
            plVar8 = plVar8 + 1;
            lVar12 = *(long long *)(param_1 + 0x48);
          } while (plVar8 != *(long long **)(*(long long *)(lVar12 + lVar14 * 8) + 0x50));
        }
        lVar9 = *(long long *)(lVar12 + lVar14 * 8);
        FUN_180058a20(*(long long *)(uVar18 + lVar12) + 0x48,
                      *(void* *)(*(long long *)(uVar18 + lVar12) + 0x50),
                      *(void* *)(lVar9 + 0x48),*(void* *)(lVar9 + 0x50));
        lVar9 = *(long long *)(*(long long *)(param_1 + 0x48) + lVar14 * 8);
        *(void* *)(lVar9 + 0x50) = *(void* *)(lVar9 + 0x48);
        FUN_180056150(*(void* *)(uVar18 + *(long long *)(param_1 + 0x48)));
        FUN_180056410(*(void* *)(*(long long *)(param_1 + 0x48) + lVar14 * 8));
        puVar4 = *(void* **)(*(long long *)(param_1 + 0x48) + lVar14 * 8);
        if (puVar4 != (void* *)0x0) {
          if (puVar4[9] != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          puVar4[4] = &SystemGlobalDataReference;
          if (puVar4[5] == 0) {
            puVar4[5] = 0;
            *(uint32_t *)(puVar4 + 7) = 0;
            puVar4[4] = &SystemMemoryAllocatorReference;
            *puVar4 = &SystemGlobalDataReference;
            if (puVar4[1] == 0) {
              puVar4[1] = 0;
              *(uint32_t *)(puVar4 + 3) = 0;
              *puVar4 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
              FUN_18064e900(puVar4);
            }
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)(*(long long *)(param_1 + 0x48) + lVar14 * 8) = 0;
        lVar9 = *(long long *)(param_1 + 0x48) + lVar14 * 8;
        uVar10 = lVar9 + 8;
        uVar5 = *(ulong long *)(param_1 + 0x50);
        if (uVar10 < uVar5) {
                    // WARNING: Subroutine does not return
          memmove(lVar9,uVar10,uVar5 - uVar10);
        }
        lVar9 = uVar5 - 8;
        *(long long *)(param_1 + 0x50) = lVar9;
        iVar17 = iVar17 + -1;
        iVar19 = iVar19 + -1;
        uVar18 = uVar18 - 8;
        lVar16 = lVar16 + -8;
      }
      uVar10 = (ulong long)(iVar17 + 1U);
      iVar19 = iVar19 + 1;
      uVar18 = uVar18 + 8;
      lVar16 = lVar16 + 8;
      lVar12 = *(long long *)(param_1 + 0x48);
    } while ((ulong long)(long long)(int)(iVar17 + 1U) < (ulong long)(lVar9 - lVar12 >> 3));
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180056410(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180056410(long long param_1,void* param_2,void* param_3,void* param_4)

{
  ulong long *puVar1;
  void** systemDataTable;
  ulong long uVar3;
  ulong long uVar4;
  ulong long uVar5;
  long long lVar6;
  uint uVar7;
  ulong long uVar8;
  long long lVar9;
  void* uVar10;
  
  uVar10 = 0xfffffffffffffffe;
  uVar3 = 0;
  puVar1 = (ulong long *)(param_1 + 0x48);
  uVar4 = *puVar1;
  uVar5 = uVar3;
  uVar8 = uVar3;
  if ((long long)(*(long long *)(param_1 + 0x50) - uVar4) >> 3 != 0) {
    do {
      FUN_180056410(*(void* *)(uVar4 + uVar5));
      puVar2 = *(void* **)(*puVar1 + uVar5);
      if (puVar2 != (void* *)0x0) {
        if (puVar2[9] != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        puVar2[4] = &SystemGlobalDataReference;
        if (puVar2[5] == 0) {
          puVar2[5] = 0;
          *(uint32_t *)(puVar2 + 7) = 0;
          puVar2[4] = &SystemMemoryAllocatorReference;
          *puVar2 = &SystemGlobalDataReference;
          if (puVar2[1] == 0) {
            puVar2[1] = 0;
            *(uint32_t *)(puVar2 + 3) = 0;
            *puVar2 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
            FUN_18064e900(puVar2);
          }
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(*puVar1 + uVar5) = 0;
      uVar7 = (int)uVar8 + 1;
      uVar4 = *puVar1;
      uVar5 = uVar5 + 8;
      uVar8 = (ulong long)uVar7;
    } while ((ulong long)(long long)(int)uVar7 <
             (ulong long)((long long)(*(long long *)(param_1 + 0x50) - uVar4) >> 3));
  }
  FUN_180057340(puVar1,0);
  uVar4 = *(ulong long *)(param_1 + 0x50);
  uVar5 = *puVar1;
  uVar7 = *(uint *)(param_1 + 0x60);
  lVar9 = uVar4 - uVar5;
  lVar6 = lVar9 >> 3;
  if (lVar6 != 0) {
    uVar3 = CreateSystemThreadObject(_DAT_180c8ed18,lVar6 * 8,uVar7 & 0xff,param_4,uVar10,0,0,0,uVar7);
  }
  lVar6 = uVar3 + lVar6 * 8;
  if (uVar5 == uVar4) {
    uVar4 = *puVar1;
    *puVar1 = uVar3;
    *(long long *)(param_1 + 0x50) = lVar6;
    *(long long *)(param_1 + 0x58) = lVar6;
    *(uint *)(param_1 + 0x60) = uVar7;
    if (uVar4 == 0) {
      return;
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
                    // WARNING: Subroutine does not return
  memmove(uVar3,uVar5,lVar9,param_4,uVar10,uVar3,lVar6,lVar6);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800565f0(long long *param_1)
void FUN_1800565f0(long long *param_1)

{
  void* *puVar1;
  code *pcVar2;
  long long lVar3;
  long long* systemMemoryPointer;
  uint8_t auStack_98 [32];
  long long lStack_78;
  long long *plStack_68;
  long long **pplStack_60;
  void* uStack_58;
  undefined *puStack_50;
  uint8_t *puStack_48;
  uint32_t uStack_40;
  uint8_t auStack_38 [16];
  ulong long uStack_28;
  
  uStack_58 = 0xfffffffffffffffe;
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_98;
  plVar4 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0xd0,8,3);
  pplStack_60 = (long long **)plVar4;
  FUN_180049830(plVar4);
  *plVar4 = (long long)&UNK_1809fdcd8;
  plVar4[0x18] = 0;
  *(uint32_t *)(plVar4 + 0x19) = 0;
  plStack_68 = plVar4;
  (**(code **)(*plVar4 + 0x28))(plVar4);
  plStack_68 = (long long *)*param_1;
  *param_1 = (long long)plVar4;
  if (plStack_68 != (long long *)0x0) {
    (**(code **)(*plStack_68 + 0x38))();
  }
  lVar3 = _DAT_180c82868;
  puStack_50 = &UNK_1809fdc18;
  puStack_48 = auStack_38;
  auStack_38[0] = 0;
  uStack_40 = 0xc;
  strcpy_s(auStack_38,0x10,&UNK_1809fdb40);
  plVar4 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
  lStack_78 = lVar3 + 0x70;
  pplStack_60 = (long long **)plVar4;
  FUN_18020e0e0(plVar4,&puStack_50,3,lVar3 + 0x2e0);
  *plVar4 = (long long)&UNK_1809fe220;
  plStack_68 = plVar4;
  FUN_18020e840(plVar4);
  FUN_18005ea90(lVar3 + 0x48,&plStack_68);
  param_1[1] = (long long)plVar4;
  puStack_50 = &SystemMemoryAllocatorReference;
  puVar1 = (void* *)param_1[1];
  pcVar2 = *(code **)*puVar1;
  pplStack_60 = &plStack_68;
  plStack_68 = (long long *)*param_1;
  if (plStack_68 != (long long *)0x0) {
    (**(code **)(*plStack_68 + 0x28))();
  }
  (*pcVar2)(puVar1,&plStack_68);
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_28 ^ (ulong long)auStack_98);
}



void* FUN_1800567c0(void* param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  FUN_180049470();
  if ((param_2 & 1) != 0) {
    free(param_1,0xd0,param_3,param_4,uVar1);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180056810(long long param_1)
void FUN_180056810(long long param_1)

{
  uint uVar1;
  double dVar2;
  uint uVar3;
  long long lVar4;
  uint32_t *puVar5;
  void** systemRootNode;
  int iVar7;
  long long lVar8;
  undefined *puVar9;
  uint8_t auStack_c8 [32];
  uint8_t uStack_a8;
  uint8_t uStack_a0;
  undefined *stackParameterB;
  undefined *pstackParameterC;
  uint uStack_88;
  ulong long uStack_80;
  long long lStack_78;
  long long alStack_70 [2];
  char acStack_60 [16];
  ulong long uStack_50;
  
  alStack_70[1] = 0xfffffffffffffffe;
  uStack_50 = _DAT_180bf00a8 ^ (ulong long)auStack_c8;
  lVar4 = _DAT_180c8ed58;
  if (_DAT_180c8ed58 == 0) {
    QueryPerformanceCounter(&lStack_78);
    lVar4 = lStack_78;
  }
  *(double *)(param_1 + 0xc0) = (double)(lVar4 - _DAT_180c8ed48) * _DAT_180c8ed50;
  LOCK();
  *(uint32_t *)(param_1 + 200) = 0;
  UNLOCK();
  LOCK();
  *(uint32_t *)(param_1 + 0xcc) = 1;
  UNLOCK();
  while( true ) {
    do {
      if (*(int *)(param_1 + 0xcc) == 0) {
                    // WARNING: Subroutine does not return
        FUN_1808fc050(uStack_50 ^ (ulong long)auStack_c8);
      }
      Sleep(10);
      lVar4 = _DAT_180c8ed58;
      if (_DAT_180c8ed58 == 0) {
        QueryPerformanceCounter(alStack_70);
        lVar4 = alStack_70[0];
      }
      dVar2 = (double)(lVar4 - _DAT_180c8ed48) * _DAT_180c8ed50;
    } while ((DAT_180c82853 == '\0') || (dVar2 - *(double *)(param_1 + 0xc0) <= 900.0));
    LOCK();
    *(uint32_t *)(param_1 + 200) = 1;
    UNLOCK();
    stackParameterB = &SystemGlobalDataReference;
    uStack_80 = 0;
    pstackParameterC = (undefined *)0x0;
    uStack_88 = 0;
    FUN_1806277c0(&stackParameterB,0x1c);
    puVar5 = (uint32_t *)(pstackParameterC + uStack_88);
    *puVar5 = 0x73736f50;
    puVar5[1] = 0x656c6269;
    puVar5[2] = 0x61656420;
    puVar5[3] = 0x636f6c64;
    *(void* *)(puVar5 + 4) = 0x746365746564206b;
    puVar5[6] = 0x202c6465;
    *(uint8_t *)(puVar5 + 7) = 0;
    uStack_88 = 0x1c;
    FUN_1806277c0(&stackParameterB,0x3e);
    puVar5 = (uint32_t *)(pstackParameterC + uStack_88);
    *puVar5 = 0x69676e65;
    puVar5[1] = 0x6420656e;
    puVar5[2] = 0x6e206469;
    puVar5[3] = 0x7220746f;
    puVar5[4] = 0x65646e65;
    puVar5[5] = 0x20612072;
    puVar5[6] = 0x6d617266;
    puVar5[7] = 0x6f662065;
    *(undefined2 *)(puVar5 + 8) = 0x2072;
    *(uint8_t *)((long long)puVar5 + 0x22) = 0;
    uStack_88 = 0x3e;
    FUN_180060680(acStack_60,&UNK_1809fd0a0,900);
    uVar3 = uStack_88;
    lVar4 = -1;
    do {
      lVar8 = lVar4;
      lVar4 = lVar8 + 1;
    } while (acStack_60[lVar8 + 1] != '\0');
    iVar7 = (int)(lVar8 + 1);
    if (0 < iVar7) break;
    uVar1 = uStack_88 + 10;
    FUN_1806277c0(&stackParameterB,uVar1);
    puVar6 = (void* *)(pstackParameterC + uStack_88);
    *puVar6 = 0x73646e6f63657320;
    *(undefined2 *)(puVar6 + 1) = 0x2021;
    *(uint8_t *)((long long)puVar6 + 10) = 0;
    uStack_88 = uVar1;
    FUN_1806277c0(&stackParameterB,uVar3 + 0x2b);
    puVar5 = (uint32_t *)(pstackParameterC + uStack_88);
    *puVar5 = 0x65766544;
    puVar5[1] = 0x65706f6c;
    puVar5[2] = 0x6e692072;
    puVar5[3] = 0x76726574;
    puVar5[4] = 0x69746e65;
    puVar5[5] = 0x73206e6f;
    puVar5[6] = 0x65676775;
    puVar5[7] = 0x64657473;
    *(undefined2 *)(puVar5 + 8) = 0x2e;
    puVar9 = &SystemStringTemplate;
    if (pstackParameterC != (undefined *)0x0) {
      puVar9 = pstackParameterC;
    }
    uStack_a0 = 0;
    uStack_a8 = 0;
    uStack_88 = uVar3 + 0x2b;
    (**(code **)(*(long long *)*_DAT_180c8ed08 + 0x20))
              ((long long *)*_DAT_180c8ed08,&UNK_1809fdbd0,0x175c,puVar9);
    *(double *)(param_1 + 0xc0) = dVar2;
    stackParameterB = &SystemGlobalDataReference;
    if (pstackParameterC != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    pstackParameterC = (undefined *)0x0;
    uStack_80 = uStack_80 & 0xffffffff00000000;
    stackParameterB = &SystemMemoryAllocatorReference;
  }
  FUN_1806277c0(&stackParameterB,uStack_88 + iVar7);
                    // WARNING: Subroutine does not return
  memcpy(pstackParameterC + uStack_88,acStack_60,(long long)((int)lVar8 + 2));
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180056b30(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_180056b30(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long lVar1;
  char cVar2;
  uint8_t auStack_30 [16];
  undefined *puStack_20;
  undefined *puStack_18;
  
  FUN_1800b4ec0(param_1,1,1,param_4,0xfffffffffffffffe);
  if (_DAT_180c8f008 != (long long *)0x0) {
    cVar2 = (**(code **)(*_DAT_180c8f008 + 0x48))();
    if ((cVar2 != '\0') && (_DAT_180c8f008[2] != 0)) {
      (*(code *)_DAT_180c8f008[0x11])(0);
    }
  }
  puStack_20 = &UNK_180058ee0;
  puStack_18 = &UNK_180058ec0;
  FUN_18005c650(auStack_30);
  *(uint8_t *)(_DAT_180c8a980 + 0x3a0) = 1;
  FUN_18005e630(_DAT_180c82868);
  FUN_18005e630(_DAT_180c82868);
  if (_DAT_180c86948 != 0) {
    FUN_18006eb30();
  }
  FUN_18005e630(_DAT_180c82868);
  FUN_18005e630(_DAT_180c82868);
  FUN_18005e630(_DAT_180c82868);
  if (_DAT_180c86948 != 0) {
    FUN_18006eb30();
  }
  FUN_18005e630(_DAT_180c82868);
  FUN_1800b4ec0();
  lVar1 = _DAT_180c86890;
  *(uint8_t *)(_DAT_180c86890 + 0x1504) = 0;
  *(uint8_t *)(lVar1 + 0x1506) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180056c50(void* param_1,void* *param_2,uint32_t param_3)
void FUN_180056c50(void* param_1,void* *param_2,uint32_t param_3)

{
  void* uVar1;
  undefined **ppuVar2;
  uint8_t auStack_158 [32];
  undefined **ppuStack_138;
  undefined ***pppuStack_130;
  void* uStack_128;
  void* *puStack_120;
  undefined **ppuStack_118;
  undefined *puStack_108;
  uint8_t *puStack_100;
  uint32_t uStack_f8;
  uint8_t auStack_f0 [128];
  uint32_t uStack_70;
  void* uStack_58;
  uint32_t uStack_50;
  ulong long uStack_28;
  
  uStack_128 = 0xfffffffffffffffe;
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_158;
  ppuStack_138 = &puStack_108;
  puStack_108 = &UNK_1809fcc28;
  puStack_100 = auStack_f0;
  uStack_f8 = 0;
  auStack_f0[0] = 0;
  uStack_70 = 0x17;
  puStack_120 = param_2;
  uVar1 = FUN_18062b1e0(_DAT_180c8ed18,0x20,8,3);
  uStack_58 = FUN_180627ae0(uVar1,param_2);
  uStack_50 = param_3;
  uVar1 = FUN_18062b1e0(_DAT_180c8ed18,0x100,8,3);
  ppuVar2 = (undefined **)FUN_18005ce30(uVar1,&puStack_108);
  ppuStack_118 = ppuVar2;
  if (ppuVar2 != (undefined **)0x0) {
    (**(code **)(*ppuVar2 + 0x28))(ppuVar2);
  }
  uVar1 = _DAT_180c82868;
  pppuStack_130 = &ppuStack_138;
  ppuStack_138 = ppuVar2;
  if (ppuVar2 != (undefined **)0x0) {
    (**(code **)(*ppuVar2 + 0x28))(ppuVar2);
  }
  FUN_18005e370(uVar1,&ppuStack_138);
  if (ppuVar2 != (undefined **)0x0) {
    (**(code **)(*ppuVar2 + 0x38))(ppuVar2);
  }
  pppuStack_130 = (undefined ***)&puStack_108;
  puStack_108 = &SystemMemoryAllocatorReference;
  *param_2 = &SystemGlobalDataReference;
  if (param_2[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[1] = 0;
  *(uint32_t *)(param_2 + 3) = 0;
  *param_2 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_28 ^ (ulong long)auStack_158);
}



void* * FUN_180056de0(void* *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 3) = 3;
  return param_1;
}



void* * FUN_180056e10(void* *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 3) = 3;
  return param_1;
}




// 函数: void FUN_180056e40(void)
void FUN_180056e40(void)

{
  FUN_180057010();
  return;
}



void* * FUN_180056e60(void* *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 3) = 10;
  return param_1;
}



void* * FUN_180056e90(void* *param_1)

{
  void* *puVar1;
  
  *param_1 = 0;
  param_1[1] = 0;
  param_1[4] = 0;
  *(uint32_t *)(param_1 + 5) = 0;
  param_1[6] = 0;
  param_1[8] = 0;
  param_1[0x60f] = 0;
  param_1[0x610] = 0;
  puVar1 = param_1 + 0xf;
  param_1[0xc] = puVar1;
  param_1[0xd] = (ulong long)(-(int)puVar1 & 7) + (long long)puVar1;
  param_1[0xe] = param_1 + 0x60f;
  param_1[0x60f] = &UNK_180059b80;
  param_1[0x610] = FUN_180059ba0;
  return param_1;
}



long long * FUN_180056f10(long long *param_1,long long *param_2)

{
  long long *plVar1;
  
  if (param_2 != (long long *)0x0) {
    (**(code **)(*param_2 + 0x28))(param_2);
  }
  plVar1 = (long long *)*param_1;
  *param_1 = (long long)param_2;
  if (plVar1 != (long long *)0x0) {
    (**(code **)(*plVar1 + 0x38))();
  }
  return param_1;
}




// 函数: void FUN_180056f70(long long param_1,long long param_2)
void FUN_180056f70(long long param_1,long long param_2)

{
  long long lVar1;
  undefined *puVar2;
  
  puVar2 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar2 = *(undefined **)(param_2 + 8);
  }
  if (puVar2 == (undefined *)0x0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (puVar2[lVar1] != '\0');
  if ((int)lVar1 < 0x400) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x000180056fc2. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x400);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x400);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




// 函数: void FUN_180057010(long long *param_1)
void FUN_180057010(long long *param_1)

{
  long long *plVar1;
  long long lVar2;
  
  plVar1 = param_1 + 3;
  lVar2 = *param_1;
  while ((long long *)lVar2 != plVar1) {
    lVar2 = *(long long *)((ulong long)(-(int)lVar2 & 7) + lVar2);
    if ((code *)param_1[0x604] == (code *)0x0) {
      free();
    }
    else {
      (*(code *)param_1[0x604])();
    }
    *param_1 = lVar2;
  }
  *param_1 = (long long)plVar1;
  param_1[1] = (ulong long)(-(int)plVar1 & 7) + (long long)plVar1;
  param_1[2] = (long long)(param_1 + 0x603);
  return;
}




// 函数: void FUN_180057029(long long param_1)
void FUN_180057029(long long param_1)

{
  long long unaff_RSI;
  long long *unaff_RDI;
  
  do {
    param_1 = *(long long *)((ulong long)(-(int)param_1 & 7) + param_1);
    if ((code *)unaff_RDI[0x604] == (code *)0x0) {
      free();
    }
    else {
      (*(code *)unaff_RDI[0x604])();
    }
    *unaff_RDI = param_1;
  } while (param_1 != unaff_RSI);
  *unaff_RDI = unaff_RSI;
  unaff_RDI[1] = (ulong long)(-(int)unaff_RSI & 7) + unaff_RSI;
  unaff_RDI[2] = (long long)(unaff_RDI + 0x603);
  return;
}




// 函数: void FUN_180057062(void)
void FUN_180057062(void)

{
  long long unaff_RSI;
  long long *unaff_RDI;
  
  *unaff_RDI = unaff_RSI;
  unaff_RDI[1] = (ulong long)(-(int)unaff_RSI & 7) + unaff_RSI;
  unaff_RDI[2] = (long long)(unaff_RDI + 0x603);
  return;
}



void* *
FUN_180057090(void* *param_1,long long param_2,void* param_3,void* param_4)

{
  long long lVar1;
  
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809fdc18;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  if (param_2 != 0) {
    lVar1 = -1;
    do {
      lVar1 = lVar1 + 1;
    } while (*(char *)(param_2 + lVar1) != '\0');
    *(int *)(param_1 + 2) = (int)lVar1;
    strcpy_s(param_1[1],0x10,param_2,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180057110(long long *param_1)
void FUN_180057110(long long *param_1)

{
  void* *puVar1;
  void** systemDataTable;
  
  puVar1 = (void* *)param_1[1];
  puVar2 = (void* *)*param_1;
  if (puVar2 != puVar1) {
    do {
      (**(code **)*puVar2)(puVar2,0);
      puVar2 = puVar2 + 4;
    } while (puVar2 != puVar1);
    param_1[1] = *param_1;
    return;
  }
  param_1[1] = (long long)puVar2;
  return;
}




// 函数: void FUN_180057170(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057170(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 0xb) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800571e0(long long *param_1,uint32_t *param_2)
void FUN_1800571e0(long long *param_1,uint32_t *param_2)

{
  long long lVar1;
  uint32_t *puVar2;
  uint32_t *puVar3;
  uint32_t *puVar4;
  
  puVar4 = (uint32_t *)param_1[1];
  if (puVar4 < (uint32_t *)param_1[2]) {
    param_1[1] = (long long)(puVar4 + 1);
    *puVar4 = *param_2;
    return;
  }
  puVar3 = (uint32_t *)*param_1;
  lVar1 = (long long)puVar4 - (long long)puVar3 >> 2;
  if (lVar1 == 0) {
    lVar1 = 1;
  }
  else {
    lVar1 = lVar1 * 2;
    if (lVar1 == 0) {
      puVar2 = (uint32_t *)0x0;
      goto LAB_18005726e;
    }
  }
  puVar2 = (uint32_t *)CreateSystemThreadObject(_DAT_180c8ed18,lVar1 * 4,(char)param_1[3]);
  puVar3 = (uint32_t *)*param_1;
  puVar4 = (uint32_t *)param_1[1];
LAB_18005726e:
  if (puVar3 != puVar4) {
                    // WARNING: Subroutine does not return
    memmove(puVar2,puVar3,(long long)puVar4 - (long long)puVar3);
  }
  *puVar2 = *param_2;
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = (long long)puVar2;
  param_1[1] = (long long)(puVar2 + 1);
  param_1[2] = (long long)(puVar2 + lVar1);
  return;
}




// 函数: void FUN_1800572d0(long long param_1)
void FUN_1800572d0(long long param_1)

{
  void* *puVar1;
  
  puVar1 = *(void* **)(param_1 + 0x10);
  if (puVar1 != (void* *)0x0) {
    FUN_18004b790(param_1,*puVar1);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  *(long long *)param_1 = param_1;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint8_t *)(param_1 + 0x18) = 0;
  *(void* *)(param_1 + 0x20) = 0;
  *(long long *)(param_1 + 8) = param_1;
  return;
}




// 函数: void FUN_1800572e6(void)
void FUN_1800572e6(void)

{
  FUN_18004b790();
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180057314(void)
void FUN_180057314(void)

{
  long long unaff_RBX;
  
  *(long long *)unaff_RBX = unaff_RBX;
  *(void* *)(unaff_RBX + 0x10) = 0;
  *(uint8_t *)(unaff_RBX + 0x18) = 0;
  *(void* *)(unaff_RBX + 0x20) = 0;
  *(long long *)(unaff_RBX + 8) = unaff_RBX;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180057340(long long *param_1,ulong long param_2)
void FUN_180057340(long long *param_1,ulong long param_2)

{
  long long lVar1;
  ulong long uVar2;
  ulong long uVar3;
  ulong long uVar4;
  long long systemTimeValue;
  long long lVar6;
  
  lVar5 = param_1[1];
  lVar6 = *param_1;
  uVar2 = lVar5 - lVar6 >> 3;
  if (param_2 <= uVar2) {
    param_1[1] = lVar6 + param_2 * 8;
    return;
  }
  uVar4 = param_2 - uVar2;
  if (uVar4 <= (ulong long)(param_1[2] - lVar5 >> 3)) {
    if (uVar4 != 0) {
                    // WARNING: Subroutine does not return
      memset(lVar5,0,uVar4 * 8);
    }
    param_1[1] = lVar5;
    return;
  }
  uVar3 = uVar2 * 2;
  if (uVar2 == 0) {
    uVar3 = 1;
  }
  if (uVar3 < param_2) {
    uVar3 = param_2;
  }
  if (uVar3 == 0) {
    lVar1 = 0;
  }
  else {
    lVar1 = CreateSystemThreadObject(_DAT_180c8ed18,uVar3 * 8,(char)param_1[3]);
    lVar6 = *param_1;
    lVar5 = param_1[1];
  }
  if (lVar6 != lVar5) {
                    // WARNING: Subroutine does not return
    memmove(lVar1,lVar6,lVar5 - lVar6);
  }
  if (uVar4 != 0) {
                    // WARNING: Subroutine does not return
    memset(lVar1,0,uVar4 * 8);
  }
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = lVar1;
  param_1[2] = lVar1 + uVar3 * 8;
  param_1[1] = lVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005736b(long long param_1,ulong long param_2,void* param_3,long long param_4)
void FUN_18005736b(long long param_1,ulong long param_2,void* param_3,long long param_4)

{
  long long in_RAX;
  long long lVar1;
  long long *unaff_RBX;
  ulong long uVar2;
  ulong long uVar3;
  long long unaff_RDI;
  
  uVar3 = param_2 - param_1;
  if (uVar3 <= (ulong long)(in_RAX - unaff_RDI >> 3)) {
    if (uVar3 != 0) {
                    // WARNING: Subroutine does not return
      memset();
    }
    unaff_RBX[1] = unaff_RDI;
    return;
  }
  uVar2 = param_1 * 2;
  if (param_1 == 0) {
    uVar2 = 1;
  }
  if (uVar2 < param_2) {
    uVar2 = param_2;
  }
  if (uVar2 == 0) {
    lVar1 = 0;
  }
  else {
    lVar1 = CreateSystemThreadObject(_DAT_180c8ed18,uVar2 * 8,(char)unaff_RBX[3]);
    param_4 = *unaff_RBX;
    unaff_RDI = unaff_RBX[1];
  }
  if (param_4 != unaff_RDI) {
                    // WARNING: Subroutine does not return
    memmove(lVar1,param_4,unaff_RDI - param_4);
  }
  if (uVar3 != 0) {
                    // WARNING: Subroutine does not return
    memset(lVar1,0,uVar3 * 8);
  }
  if (*unaff_RBX != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *unaff_RBX = lVar1;
  unaff_RBX[2] = lVar1 + uVar2 * 8;
  unaff_RBX[1] = lVar1;
  return;
}




// 函数: void FUN_180057446(void)
void FUN_180057446(void)

{
  long long unaff_RBX;
  long long unaff_RSI;
  void* unaff_RDI;
  
  if (unaff_RSI != 0) {
                    // WARNING: Subroutine does not return
    memset();
  }
  *(void* *)(unaff_RBX + 8) = unaff_RDI;
  return;
}




// 函数: void FUN_180057479(void* param_1,long long param_2,void* param_3,long long param_4)
void FUN_180057479(void* param_1,long long param_2,void* param_3,long long param_4)

{
  long long unaff_RBX;
  
  *(long long *)(unaff_RBX + 8) = param_4 + param_2 * 8;
  return;
}




// 函数: void FUN_180057490(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057490(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058210(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_1800574b0(long long *param_1)
void FUN_1800574b0(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x48) {
    FUN_180058c20(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180057510(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057510(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_1800582b0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180057530(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057530(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058370(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180057550(long long param_1)
void FUN_180057550(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_180057556(long long param_1)
void FUN_180057556(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_180057580(void)
void FUN_180057580(void)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  long long unaff_RBP;
  ulong long unaff_RSI;
  ulong long unaff_RDI;
  ulong long uVar4;
  long long unaff_R14;
  void* unaff_R15;
  
  do {
    lVar3 = *(long long *)(unaff_R14 + unaff_RDI * 8);
    if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar3);
    }
    *(void* *)(unaff_R14 + unaff_RDI * 8) = unaff_R15;
    unaff_RDI = unaff_RDI + 1;
  } while (unaff_RDI < unaff_RSI);
  *(void* *)(unaff_RBP + 0x18) = unaff_R15;
  if ((1 < *(ulong long *)(unaff_RBP + 0x10)) &&
     (puVar2 = *(void* **)(unaff_RBP + 8), puVar2 != (void* *)0x0)) {
    uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
    if (uVar4 != 0) {
      lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
      lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
      if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
        *puVar2 = *(void* *)(lVar3 + 0x20);
        *(void* **)(lVar3 + 0x20) = puVar2;
        piVar1 = (int *)(lVar3 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                            puVar2,uVar4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_1800575b6(void)
void FUN_1800575b6(void)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  long long unaff_RBP;
  ulong long unaff_RSI;
  ulong long uVar4;
  void* unaff_R15;
  
  *(void* *)(unaff_RBP + 0x18) = unaff_R15;
  if ((1 < unaff_RSI) && (puVar2 = *(void* **)(unaff_RBP + 8), puVar2 != (void* *)0x0)) {
    uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
    if (uVar4 != 0) {
      lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
      lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
      if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
        *puVar2 = *(void* *)(lVar3 + 0x20);
        *(void* **)(lVar3 + 0x20) = puVar2;
        piVar1 = (int *)(lVar3 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                            puVar2,uVar4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_1800575d4(void)
void FUN_1800575d4(void)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  long long unaff_RBP;
  ulong long uVar4;
  
  puVar2 = *(void* **)(unaff_RBP + 8);
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_1800575f0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_1800575f0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058420(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180057610(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057610(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 0x69) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180057680(long long param_1)
void FUN_180057680(long long param_1)

{
  long long lVar1;
  long long lVar2;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar3 = *(ulong long *)(param_1 + 0x10);
  lVar1 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar3 != 0) {
    do {
      lVar2 = *(long long *)(lVar1 + uVar4 * 8);
      if (lVar2 != 0) {
        if (*(long long **)(lVar2 + 0x10) != (long long *)0x0) {
          (**(code **)(**(long long **)(lVar2 + 0x10) + 0x38))();
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar1 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar3);
    uVar3 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar3) && (*(long long *)(param_1 + 8) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}




// 函数: void FUN_180057730(long long *param_1)
void FUN_180057730(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x18) {
    FUN_18004bf50(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180057790(long long param_1)
void FUN_180057790(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_180057796(long long param_1)
void FUN_180057796(long long param_1)

{
  int *piVar1;
  long long lVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  
  uVar6 = *(ulong long *)(param_1 + 0x10);
  lVar4 = *(long long *)(param_1 + 8);
  uVar5 = 0;
  if (uVar6 != 0) {
    do {
      lVar2 = *(long long *)(lVar4 + uVar5 * 8);
      if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
      *(void* *)(lVar4 + uVar5 * 8) = 0;
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar6);
    uVar6 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar6) && (puVar3 = *(void* **)(param_1 + 8), puVar3 != (void* *)0x0)) {
    uVar6 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar6 != 0) {
      lVar4 = uVar6 + 0x80 + ((long long)puVar3 - uVar6 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar6 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar6,CONCAT71(0xff000000,*(void ***)(uVar6 + 0x70) == &ExceptionList),
                            puVar3,uVar6,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: 系统内存清理器 - 负责清理系统内存
/**
 * @brief 系统内存清理器
 * 
 * 该函数负责清理系统内存中的无效指针和资源。它会遍历内存块，
 * 检查每个内存块的状态，并清理不再需要的内存资源。
 * 
 * @note 这是系统内存管理的重要组成部分，确保系统内存的有效利用
 */
void SystemMemoryCleanup(void)

{
  int *memoryReferenceCount;
  void** systemDataTable;
  long long memoryBlockAddress;
  long long memoryBlockBase;
  ulong long memoryBlockCount;
  ulong long memoryBlockIndex;
  ulong long memoryBlockFlags;
  long long memoryBlockPointer;
  void* memoryBlockValue;
  
  do {
    memoryBlockAddress = *(long long *)(memoryBlockPointer + memoryBlockIndex * 8);
    if (memoryBlockAddress != 0) {
                    // WARNING: Subroutine does not return
      ReleaseMemoryBlock(memoryBlockAddress);
    }
    *(void* *)(memoryBlockPointer + memoryBlockIndex * 8) = memoryBlockValue;
    memoryBlockIndex = memoryBlockIndex + 1;
  } while (memoryBlockIndex < memoryBlockCount);
  *(void* *)(memoryBlockBase + 0x18) = memoryBlockValue;
  if ((1 < *(ulong long *)(memoryBlockBase + 0x10)) &&
     (systemMemoryBlock = *(void* **)(memoryBlockBase + 8), systemMemoryBlock != (void* *)0x0)) {
    memoryBlockFlags = (ulong long)systemMemoryBlock & 0xffffffffffc00000;
    if (memoryBlockFlags != 0) {
      memoryBlockAddress = memoryBlockFlags + 0x80 + ((long long)systemMemoryBlock - memoryBlockFlags >> 0x10) * 0x50;
      memoryBlockAddress = memoryBlockAddress - (ulong long)*(uint *)(memoryBlockAddress + 4);
      if ((*(void ***)(memoryBlockFlags + 0x70) == &ExceptionList) && (*(char *)(memoryBlockAddress + 0xe) == '\0')) {
        *systemMemoryBlock = *(void* *)(memoryBlockAddress + 0x20);
        *(void* **)(memoryBlockAddress + 0x20) = systemMemoryBlock;
        memoryReferenceCount = (int *)(memoryBlockAddress + 0x18);
        *memoryReferenceCount = *memoryReferenceCount + -1;
        if (*memoryReferenceCount == 0) {
          CleanupMemoryManager();
          return;
        }
      }
      else {
        ProcessMemoryBlockException(memoryBlockFlags,CONCAT71(0xff000000,*(void ***)(memoryBlockFlags + 0x70) == &ExceptionList),
                            systemMemoryBlock,memoryBlockFlags,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: 系统资源释放器 - 负责释放系统资源
/**
 * @brief 系统资源释放器
 * 
 * 该函数负责释放系统中的资源，包括内存块、文件句柄、网络连接等。
 * 它会检查资源的使用状态，并安全地释放不再需要的资源。
 * 
 * @note 这是系统资源管理的重要组成部分，确保系统资源的正确释放
 */
void SystemResourceRelease(void)

{
  int *resourceReferenceCount;
  void** systemDataTable;
  long long resourceAddress;
  long long resourceBase;
  ulong long resourceCount;
  ulong long resourceFlags;
  void* resourceValue;
  
  *(void* *)(resourceBase + 0x18) = resourceValue;
  if ((1 < resourceCount) && (systemResource = *(void* **)(resourceBase + 8), systemResource != (void* *)0x0)) {
    resourceFlags = (ulong long)systemResource & 0xffffffffffc00000;
    if (resourceFlags != 0) {
      resourceAddress = resourceFlags + 0x80 + ((long long)systemResource - resourceFlags >> 0x10) * 0x50;
      resourceAddress = resourceAddress - (ulong long)*(uint *)(resourceAddress + 4);
      if ((*(void ***)(resourceFlags + 0x70) == &ExceptionList) && (*(char *)(resourceAddress + 0xe) == '\0')) {
        *systemResource = *(void* *)(resourceAddress + 0x20);
        *(void* **)(resourceAddress + 0x20) = systemResource;
        resourceReferenceCount = (int *)(resourceAddress + 0x18);
        *resourceReferenceCount = *resourceReferenceCount + -1;
        if (*resourceReferenceCount == 0) {
          CleanupResourceManager();
          return;
        }
      }
      else {
        ProcessResourceException(resourceFlags,CONCAT71(0xff000000,*(void ***)(resourceFlags + 0x70) == &ExceptionList),
                            systemResource,resourceFlags,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_180057814(void)
void FUN_180057814(void)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  long long unaff_RBP;
  ulong long uVar4;
  
  puVar2 = *(void* **)(unaff_RBP + 8);
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_180057830(long long *param_1)
void FUN_180057830(long long *param_1)

{
  long long *plVar1;
  long long *plVar2;
  
  plVar1 = (long long *)param_1[1];
  for (plVar2 = (long long *)*param_1; plVar2 != plVar1; plVar2 = plVar2 + 1) {
    if ((long long *)*plVar2 != (long long *)0x0) {
      (**(code **)(*(long long *)*plVar2 + 0x38))();
    }
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800578a0(void)
void FUN_1800578a0(void)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = _DAT_180c86950;
  if (_DAT_180c86950 == (void* *)0x0) {
    return;
  }
  FUN_180057830();
  if ((long long *)puVar2[0x30b] != (long long *)0x0) {
    (**(code **)(*(long long *)puVar2[0x30b] + 0x38))();
  }
  _Mtx_destroy_in_situ();
  if ((long long *)puVar2[0x300] != (long long *)0x0) {
    (**(code **)(*(long long *)puVar2[0x300] + 0x38))();
  }
  if ((long long *)puVar2[0x2d3] != (long long *)0x0) {
    (**(code **)(*(long long *)puVar2[0x2d3] + 0x38))();
  }
  if ((long long *)puVar2[0x2c0] != (long long *)0x0) {
    (**(code **)(*(long long *)puVar2[0x2c0] + 0x38))();
  }
  FUN_180090420(puVar2 + 0x116);
  FUN_180090380(puVar2 + 6);
  if (puVar2[2] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_180057980(long long param_1,long long param_2,void* param_3,void* param_4)
void FUN_180057980(long long param_1,long long param_2,void* param_3,void* param_4)

{
  char systemNodeFlag;
  long long lVar2;
  char *pcVar3;
  char *pcVar4;
  void* uVar5;
  undefined *puStack_50;
  long long lStack_48;
  uint32_t uStack_40;
  ulong long uStack_38;
  
  uVar5 = 0xfffffffffffffffe;
  pcVar3 = *(char **)(param_1 + 8);
  cVar1 = *pcVar3;
  pcVar4 = pcVar3;
  if (cVar1 != '\0') {
    do {
      lVar2 = strchr(param_3,(int)cVar1);
      if ((lVar2 != 0) && (pcVar4 != pcVar3)) {
        puStack_50 = &SystemGlobalDataReference;
        uStack_38 = 0;
        lStack_48 = 0;
        uStack_40 = 0;
        FUN_180628210(&puStack_50,pcVar4,(int)pcVar3 - (int)pcVar4,param_4,uVar5);
        pcVar4 = pcVar3 + 1;
        if (*(ulong long *)(param_2 + 8) < *(ulong long *)(param_2 + 0x10)) {
          *(ulong long *)(param_2 + 8) = *(ulong long *)(param_2 + 8) + 0x20;
          FUN_180627ae0();
        }
        else {
          FUN_180059820(param_2,&puStack_50);
        }
        puStack_50 = &SystemGlobalDataReference;
        if (lStack_48 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        lStack_48 = 0;
        uStack_38 = uStack_38 & 0xffffffff00000000;
        puStack_50 = &SystemMemoryAllocatorReference;
      }
      pcVar3 = pcVar3 + 1;
      cVar1 = *pcVar3;
    } while (cVar1 != '\0');
    if (pcVar4 != pcVar3) {
      puStack_50 = &SystemGlobalDataReference;
      uStack_38 = 0;
      lStack_48 = 0;
      uStack_40 = 0;
      FUN_180628210(&puStack_50,pcVar4,(int)pcVar3 - (int)pcVar4,param_4,uVar5);
      if (*(ulong long *)(param_2 + 8) < *(ulong long *)(param_2 + 0x10)) {
        *(ulong long *)(param_2 + 8) = *(ulong long *)(param_2 + 8) + 0x20;
        FUN_180627ae0();
      }
      else {
        FUN_180059820(param_2,&puStack_50);
      }
      puStack_50 = &SystemGlobalDataReference;
      if (lStack_48 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long * FUN_180057b00(long long param_1,long long *param_2,void* param_3)

{
  byte bVar1;
  uint uVar2;
  long long lVar3;
  long long lVar4;
  byte *pbVar5;
  long long lVar6;
  void* uVar7;
  char acStackX_8 [8];
  
  lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,0x40,*(uint8_t *)(param_1 + 0x28));
  FUN_180627ae0(lVar3 + 0x20,param_3);
  lVar4 = FUN_1800590b0(param_1,acStackX_8,lVar3 + 0x20);
  if (acStackX_8[0] == '\0') {
    FUN_18005d1f0();
    *param_2 = lVar4;
    *(uint8_t *)(param_2 + 1) = 0;
    return param_2;
  }
  if (lVar4 != param_1) {
    if (*(int *)(lVar4 + 0x30) == 0) {
LAB_180057b97:
      uVar7 = 1;
      goto LAB_180057ba2;
    }
    if (*(int *)(lVar3 + 0x30) != 0) {
      pbVar5 = *(byte **)(lVar4 + 0x28);
      lVar6 = *(long long *)(lVar3 + 0x28) - (long long)pbVar5;
      do {
        bVar1 = *pbVar5;
        uVar2 = (uint)pbVar5[lVar6];
        if (bVar1 != uVar2) break;
        pbVar5 = pbVar5 + 1;
      } while (uVar2 != 0);
      if ((int)(bVar1 - uVar2) < 1) goto LAB_180057b97;
    }
  }
  uVar7 = 0;
LAB_180057ba2:
                    // WARNING: Subroutine does not return
  FUN_18066bdc0(lVar3,lVar4,param_1,uVar7);
}




// 函数: void FUN_180057bf0(void* *param_1)
void FUN_180057bf0(void* *param_1)

{
  if (param_1 == (void* *)0x0) {
    return;
  }
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[4] = &SystemGlobalDataReference;
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 7) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_180057cb0(void* *param_1,uint param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_180a08db0;
  FUN_18005e570(_DAT_180c82868,param_1[0x28],param_3,param_4,0xfffffffffffffffe);
  param_1[0x28] = 0;
  param_1[0x29] = &SystemGlobalDataReference;
  if (param_1[0x2a] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x2a] = 0;
  *(uint32_t *)(param_1 + 0x2c) = 0;
  param_1[0x29] = &SystemMemoryAllocatorReference;
  FUN_180174950();
  if ((param_2 & 1) != 0) {
    free(param_1,0x170);
  }
  return param_1;
}




// 函数: void FUN_180057d70(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057d70(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  FUN_180058020();
  FUN_180058020();
  param_1[0x123] = (long long)&SystemGlobalDataReference;
  if (param_1[0x124] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x124] = 0;
  *(uint32_t *)(param_1 + 0x126) = 0;
  param_1[0x123] = (long long)&SystemMemoryAllocatorReference;
  FUN_180058370(param_1 + 0x11d,param_1[0x11f],param_3,param_4,uVar3);
  if (param_1[0x119] == 0) {
    FUN_18005d580();
    FUN_18005d580();
    FUN_180058710(param_1 + 0x10b,param_1[0x10d]);
    param_1[0x87] = (long long)&SystemMemoryAllocatorReference;
    param_1[4] = (long long)&SystemMemoryAllocatorReference;
    uVar3 = 0xfffffffffffffffe;
    puVar1 = (void* *)param_1[1];
    for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 4) {
      (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
    }
    if (*param_1 == 0) {
      return;
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180057e90(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057e90(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058710(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180057ec0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057ec0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  
  puVar1 = *(void* **)(param_1 + 0x10);
  if (puVar1 != (void* *)0x0) {
    FUN_1800587d0(param_1,*puVar1,param_3,param_4,0xfffffffffffffffe);
    FUN_18005cb60(puVar1);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  return;
}




// 函数: void FUN_180057ee0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057ee0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058710(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180057f10(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180057f10(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  
  puVar1 = *(void* **)(param_1 + 0x10);
  if (puVar1 != (void* *)0x0) {
    FUN_1800587d0(param_1,*puVar1,param_3,param_4,0xfffffffffffffffe);
    FUN_18005cb60(puVar1);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  return;
}




// 函数: void FUN_180057f30(long long *param_1)
void FUN_180057f30(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  void* *puVar4;
  void* *puVar5;
  long long lVar6;
  void** systemCurrentNode;
  
  FUN_180057110();
  lVar1 = *param_1;
  *param_1 = 0;
  lVar2 = param_1[1];
  param_1[1] = 0;
  lVar3 = param_1[2];
  param_1[2] = 0;
  lVar6 = param_1[3];
  *(int *)(param_1 + 3) = (int)param_1[3];
  puVar4 = (void* *)*param_1;
  *param_1 = lVar1;
  puVar5 = (void* *)param_1[1];
  param_1[1] = lVar2;
  param_1[2] = lVar3;
  *(int *)(param_1 + 3) = (int)lVar6;
  for (systemPreviousNode = puVar4; systemPreviousNode != puVar5; systemPreviousNode = systemPreviousNode + 4) {
    (**(code **)*systemPreviousNode)(systemPreviousNode,0);
  }
  if (puVar4 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar4);
  }
  return;
}




// 函数: void FUN_180058000(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180058000(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180058710(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180058020(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180058020(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  
  puVar1 = *(void* **)(param_1 + 0x10);
  if (puVar1 != (void* *)0x0) {
    FUN_1800587d0(param_1,*puVar1,param_3,param_4,0xfffffffffffffffe);
    FUN_18005cb60(puVar1);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar1);
  }
  return;
}



void* * FUN_180058080(void* *param_1,void* *param_2,long long param_3)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  uint uVar4;
  int iVar5;
  long long lVar6;
  void** systemCurrentNode;
  void** systemNextNode;
  void* *puVar9;
  void* *puVar10;
  
  if ((void* *)param_1[2] != (void* *)0x0) {
    systemPreviousNode = (void* *)param_1[2];
    puVar10 = param_1;
    do {
      if (*(int *)(param_3 + 0x10) == 0) {
        puVar8 = (void* *)systemPreviousNode[1];
        bVar2 = false;
      }
      else {
        if (*(int *)(systemPreviousNode + 6) == 0) {
          bVar2 = true;
        }
        else {
          pbVar3 = *(byte **)(param_3 + 8);
          lVar6 = systemPreviousNode[5] - (long long)pbVar3;
          do {
            uVar4 = (uint)pbVar3[lVar6];
            iVar5 = *pbVar3 - uVar4;
            if (*pbVar3 != uVar4) break;
            pbVar3 = pbVar3 + 1;
          } while (uVar4 != 0);
          bVar2 = 0 < iVar5;
          if (iVar5 < 1) {
            puVar8 = (void* *)systemPreviousNode[1];
            goto LAB_1800580f9;
          }
        }
        puVar8 = (void* *)*systemPreviousNode;
      }
LAB_1800580f9:
      puVar9 = systemPreviousNode;
      if (bVar2) {
        puVar9 = puVar10;
      }
      systemPreviousNode = puVar8;
      puVar10 = puVar9;
    } while (puVar8 != (void* *)0x0);
    if (puVar9 != param_1) {
      if (*(int *)(puVar9 + 6) == 0) {
LAB_180058138:
        *param_2 = puVar9;
        return param_2;
      }
      if (*(int *)(param_3 + 0x10) != 0) {
        pbVar3 = (byte *)puVar9[5];
        lVar6 = *(long long *)(param_3 + 8) - (long long)pbVar3;
        do {
          bVar1 = *pbVar3;
          uVar4 = (uint)pbVar3[lVar6];
          if (bVar1 != uVar4) break;
          pbVar3 = pbVar3 + 1;
        } while (uVar4 != 0);
        if ((int)(bVar1 - uVar4) < 1) goto LAB_180058138;
      }
    }
  }
  *param_2 = param_1;
  return param_2;
}




// 函数: void FUN_180058160(ulong long *param_1)
void FUN_180058160(ulong long *param_1)

{
  int *piVar1;
  ulong long uVar2;
  ulong long uVar3;
  void* *puVar4;
  ulong long uVar5;
  long long lVar6;
  ulong long uVar7;
  
  param_1[1] = *param_1;
  uVar7 = *param_1;
  *param_1 = 0;
  uVar2 = param_1[1];
  param_1[1] = 0;
  uVar3 = param_1[2];
  param_1[2] = 0;
  uVar5 = param_1[3];
  *(int *)(param_1 + 3) = (int)param_1[3];
  puVar4 = (void* *)*param_1;
  *param_1 = uVar7;
  param_1[1] = uVar2;
  param_1[2] = uVar3;
  *(int *)(param_1 + 3) = (int)uVar5;
  if (puVar4 == (void* *)0x0) {
    return;
  }
  uVar7 = (ulong long)puVar4 & 0xffffffffffc00000;
  if (uVar7 != 0) {
    lVar6 = uVar7 + 0x80 + ((long long)puVar4 - uVar7 >> 0x10) * 0x50;
    lVar6 = lVar6 - (ulong long)*(uint *)(lVar6 + 4);
    if ((*(void ***)(uVar7 + 0x70) == &ExceptionList) && (*(char *)(lVar6 + 0xe) == '\0')) {
      *puVar4 = *(void* *)(lVar6 + 0x20);
      *(void* **)(lVar6 + 0x20) = puVar4;
      piVar1 = (int *)(lVar6 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar7,CONCAT71(0xff000000,*(void ***)(uVar7 + 0x70) == &ExceptionList),
                          puVar4,uVar7,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_180058210(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_180058210(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 != (void* *)0x0) {
    FUN_180058210(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
    if ((long long *)param_2[0x17] != (long long *)0x0) {
      (**(code **)(*(long long *)param_2[0x17] + 0x38))();
    }
    param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_2);
  }
  return;
}




// 函数: void FUN_1800582b0(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_1800582b0(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_1800582b0(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  FUN_180058db0(param_2 + 8);
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}




// 函数: void FUN_180058370(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_180058370(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_180058370(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}




// 函数: void FUN_180058420(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_180058420(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_180058420(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  if (param_2[8] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800584e0(void* *param_1,long long param_2)
void FUN_1800584e0(void* *param_1,long long param_2)

{
  void* *puVar1;
  void** systemDataTable;
  void* *puVar3;
  void* *puVar4;
  long long systemTimeValue;
  long long lVar6;
  void** systemCurrentNode;
  
  systemPreviousNode = (void* *)param_1[1];
  puVar4 = (void* *)*param_1;
  lVar5 = ((long long)systemPreviousNode - (long long)puVar4) / 0x28;
  puVar2 = (void* *)0x0;
  if (lVar5 == 0) {
    lVar5 = 1;
  }
  else {
    lVar5 = lVar5 * 2;
    if (lVar5 == 0) goto LAB_18005856a;
  }
  puVar2 = (void* *)
           CreateSystemThreadObject(_DAT_180c8ed18,lVar5 * 0x28,*(uint8_t *)(param_1 + 3),puVar4,
                         0xfffffffffffffffe);
  systemPreviousNode = (void* *)param_1[1];
  puVar4 = (void* *)*param_1;
LAB_18005856a:
  puVar3 = puVar2;
  if (puVar4 != systemPreviousNode) {
    lVar6 = (long long)puVar2 - (long long)puVar4;
    puVar4 = puVar4 + 1;
    do {
      *puVar3 = &SystemMemoryAllocatorReference;
      *(void* *)(lVar6 + (long long)puVar4) = 0;
      *(uint32_t *)(lVar6 + 8 + (long long)puVar4) = 0;
      *puVar3 = &SystemGlobalDataReference;
      *(void* *)(lVar6 + 0x10 + (long long)puVar4) = 0;
      *(void* *)(lVar6 + (long long)puVar4) = 0;
      *(uint32_t *)(lVar6 + 8 + (long long)puVar4) = 0;
      *(uint32_t *)(lVar6 + 8 + (long long)puVar4) = *(uint32_t *)(puVar4 + 1);
      *(void* *)(lVar6 + (long long)puVar4) = *puVar4;
      *(uint32_t *)(lVar6 + 0x14 + (long long)puVar4) = *(uint32_t *)((long long)puVar4 + 0x14);
      *(uint32_t *)(lVar6 + 0x10 + (long long)puVar4) = *(uint32_t *)(puVar4 + 2);
      *(uint32_t *)(puVar4 + 1) = 0;
      *puVar4 = 0;
      puVar4[2] = 0;
      *(uint32_t *)(lVar6 + 0x18 + (long long)puVar4) = *(uint32_t *)(puVar4 + 3);
      puVar3 = puVar3 + 5;
      puVar1 = puVar4 + 4;
      puVar4 = puVar4 + 5;
    } while (puVar1 != systemPreviousNode);
  }
  *puVar3 = &SystemMemoryAllocatorReference;
  puVar3[1] = 0;
  *(uint32_t *)(puVar3 + 2) = 0;
  *puVar3 = &SystemGlobalDataReference;
  puVar3[3] = 0;
  puVar3[1] = 0;
  *(uint32_t *)(puVar3 + 2) = 0;
  *(uint32_t *)(puVar3 + 2) = *(uint32_t *)(param_2 + 0x10);
  puVar3[1] = *(void* *)(param_2 + 8);
  *(uint32_t *)((long long)puVar3 + 0x1c) = *(uint32_t *)(param_2 + 0x1c);
  *(uint32_t *)(puVar3 + 3) = *(uint32_t *)(param_2 + 0x18);
  *(uint32_t *)(param_2 + 0x10) = 0;
  *(void* *)(param_2 + 8) = 0;
  *(void* *)(param_2 + 0x18) = 0;
  *(uint32_t *)(puVar3 + 4) = *(uint32_t *)(param_2 + 0x20);
  systemPreviousNode = (void* *)param_1[1];
  puVar4 = (void* *)*param_1;
  if (puVar4 != systemPreviousNode) {
    do {
      *puVar4 = &SystemGlobalDataReference;
      if (puVar4[1] != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      puVar4[1] = 0;
      *(uint32_t *)(puVar4 + 3) = 0;
      *puVar4 = &SystemMemoryAllocatorReference;
      puVar4 = puVar4 + 5;
    } while (puVar4 != systemPreviousNode);
    puVar4 = (void* *)*param_1;
  }
  if (puVar4 == (void* *)0x0) {
    *param_1 = puVar2;
    param_1[1] = puVar3 + 5;
    param_1[2] = puVar2 + lVar5 * 5;
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar4);
}




// 函数: void FUN_1800586e0(long long param_1)
void FUN_1800586e0(long long param_1)

{
  if (*(long long **)(param_1 + 0x10) != (long long *)0x0) {
    (**(code **)(**(long long **)(param_1 + 0x10) + 0x38))();
  }
  return;
}




// 函数: void FUN_180058710(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_180058710(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_180058710(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  if (param_2[8] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}




// 函数: void FUN_1800587d0(void* param_1,void* *param_2)
void FUN_1800587d0(void* param_1,void* *param_2)

{
  if (param_2 != (void* *)0x0) {
    FUN_1800587d0(param_1,*param_2);
    FUN_18005cb60(param_2);
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_2);
  }
  return;
}




// 函数: void FUN_1800587e2(void* param_1)
void FUN_1800587e2(void* param_1)

{
  void* *unaff_RBX;
  
  FUN_1800587d0(param_1,*unaff_RBX);
  FUN_18005cb60();
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180058826(void)
void FUN_180058826(void)

{
  return;
}




// 函数: void FUN_180058830(void* param_1,long long param_2)
void FUN_180058830(void* param_1,long long param_2)

{
  if (*(long long *)(param_2 + 0x40) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_2 + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(param_2 + 0x28) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_2 + 0x28) = 0;
  *(uint32_t *)(param_2 + 0x38) = 0;
  *(void* *)(param_2 + 0x20) = &SystemMemoryAllocatorReference;
  if (param_2 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_2);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800588c0(long long *param_1,long long param_2,long long param_3)
void FUN_1800588c0(long long *param_1,long long param_2,long long param_3)

{
  void* *puVar1;
  long long lVar2;
  void* *puVar3;
  void* *puVar4;
  ulong long uVar5;
  ulong long uVar6;
  long long lVar7;
  
  uVar6 = param_3 - param_2 >> 5;
  if ((ulong long)(param_1[2] - *param_1 >> 5) < uVar6) {
    if (uVar6 == 0) {
      lVar2 = 0;
    }
    else {
      lVar2 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 5,(char)param_1[3]);
    }
    if (param_2 != param_3) {
      lVar7 = lVar2 - param_2;
      do {
        FUN_180627ae0(lVar7 + param_2,param_2);
        param_2 = param_2 + 0x20;
      } while (param_2 != param_3);
    }
    puVar1 = (void* *)param_1[1];
    puVar4 = (void* *)*param_1;
    if (puVar4 != puVar1) {
      do {
        (**(code **)*puVar4)(puVar4,0);
        puVar4 = puVar4 + 4;
      } while (puVar4 != puVar1);
      puVar4 = (void* *)*param_1;
    }
    if (puVar4 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar4);
    }
    *param_1 = lVar2;
    lVar2 = uVar6 * 0x20 + lVar2;
    param_1[2] = lVar2;
    param_1[1] = lVar2;
  }
  else {
    uVar5 = param_1[1] - *param_1 >> 5;
    if (uVar5 < uVar6) {
      lVar2 = uVar5 * 0x20 + param_2;
      FUN_180059250(param_2,lVar2);
      lVar2 = FUN_180059300(lVar2,param_3,param_1[1]);
      param_1[1] = lVar2;
    }
    else {
      puVar3 = (void* *)FUN_180059250(param_2,param_3);
      puVar1 = (void* *)param_1[1];
      for (puVar4 = puVar3; puVar4 != puVar1; puVar4 = puVar4 + 4) {
        (**(code **)*puVar4)(puVar4,0);
      }
      param_1[1] = (long long)puVar3;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800588fc(long long param_1)
void FUN_1800588fc(long long param_1)

{
  void* *puVar1;
  long long lVar2;
  long long unaff_RBX;
  void* *puVar3;
  long long unaff_RSI;
  long long *unaff_RDI;
  long long lVar4;
  long long unaff_R15;
  
  if (unaff_RSI == 0) {
    lVar2 = 0;
  }
  else {
    lVar2 = CreateSystemThreadObject(_DAT_180c8ed18,unaff_RSI << 5,*(uint8_t *)(param_1 + 0x18));
  }
  if (unaff_RBX != unaff_R15) {
    lVar4 = lVar2 - unaff_RBX;
    do {
      FUN_180627ae0(lVar4 + unaff_RBX,unaff_RBX);
      unaff_RBX = unaff_RBX + 0x20;
    } while (unaff_RBX != unaff_R15);
  }
  puVar1 = (void* *)unaff_RDI[1];
  puVar3 = (void* *)*unaff_RDI;
  if (puVar3 != puVar1) {
    do {
      (**(code **)*puVar3)(puVar3,0);
      puVar3 = puVar3 + 4;
    } while (puVar3 != puVar1);
    puVar3 = (void* *)*unaff_RDI;
  }
  if (puVar3 == (void* *)0x0) {
    *unaff_RDI = lVar2;
    lVar2 = unaff_RSI * 0x20 + lVar2;
    unaff_RDI[2] = lVar2;
    unaff_RDI[1] = lVar2;
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar3);
}




// 函数: void FUN_18005892b(void)
void FUN_18005892b(void)

{
  void* *puVar1;
  long long unaff_RBX;
  void** systemDataTable;
  long long unaff_RSI;
  long long *unaff_RDI;
  long long unaff_R12;
  long long lVar3;
  long long unaff_R15;
  
  lVar3 = unaff_R12 - unaff_RBX;
  do {
    FUN_180627ae0(lVar3 + unaff_RBX,unaff_RBX);
    unaff_RBX = unaff_RBX + 0x20;
  } while (unaff_RBX != unaff_R15);
  puVar1 = (void* *)unaff_RDI[1];
  puVar2 = (void* *)*unaff_RDI;
  if (puVar2 != puVar1) {
    do {
      (**(code **)*puVar2)(puVar2,0);
      puVar2 = puVar2 + 4;
    } while (puVar2 != puVar1);
    puVar2 = (void* *)*unaff_RDI;
  }
  if (puVar2 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar2);
  }
  *unaff_RDI = unaff_R12;
  lVar3 = unaff_RSI * 0x20 + unaff_R12;
  unaff_RDI[2] = lVar3;
  unaff_RDI[1] = lVar3;
  return;
}




// 函数: void FUN_18005895a(void)
void FUN_18005895a(void)

{
  long long lVar1;
  void** systemDataTable;
  void* *puVar3;
  long long unaff_RSI;
  long long *unaff_RDI;
  long long unaff_R12;
  
  puVar2 = (void* *)unaff_RDI[1];
  puVar3 = (void* *)*unaff_RDI;
  if (puVar3 != puVar2) {
    do {
      (**(code **)*puVar3)(puVar3,0);
      puVar3 = puVar3 + 4;
    } while (puVar3 != puVar2);
    puVar3 = (void* *)*unaff_RDI;
  }
  if (puVar3 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  *unaff_RDI = unaff_R12;
  lVar1 = unaff_RSI * 0x20 + unaff_R12;
  unaff_RDI[2] = lVar1;
  unaff_RDI[1] = lVar1;
  return;
}




// 函数: void FUN_1800589a3(long long param_1,void* param_2,long long param_3)
void FUN_1800589a3(long long param_1,void* param_2,long long param_3)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  long long unaff_RBX;
  void* *puVar4;
  ulong long uVar5;
  ulong long unaff_RSI;
  long long unaff_RDI;
  
  uVar5 = *(long long *)(param_1 + 8) - param_3 >> 5;
  if (uVar5 < unaff_RSI) {
    FUN_180059250();
    uVar3 = FUN_180059300(uVar5 * 0x20 + unaff_RBX);
    *(void* *)(unaff_RDI + 8) = uVar3;
  }
  else {
    puVar2 = (void* *)FUN_180059250();
    puVar1 = *(void* **)(unaff_RDI + 8);
    for (puVar4 = puVar2; puVar4 != puVar1; puVar4 = puVar4 + 4) {
      (**(code **)*puVar4)(puVar4,0);
    }
    *(void* **)(unaff_RDI + 8) = puVar2;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180058a20(long long *param_1,long long param_2,long long param_3,long long param_4)
void FUN_180058a20(long long *param_1,long long param_2,long long param_3,long long param_4)

{
  void* uVar1;
  long long lVar2;
  long long lVar3;
  ulong long uVar4;
  ulong long uVar5;
  
  if (param_3 == param_4) {
    return;
  }
  lVar2 = param_1[1];
  uVar5 = param_4 - param_3 >> 3;
  if ((ulong long)(param_1[2] - lVar2 >> 3) < uVar5) {
    lVar3 = *param_1;
    lVar2 = lVar2 - lVar3 >> 3;
    uVar4 = lVar2 * 2;
    if (lVar2 == 0) {
      uVar4 = 1;
    }
    if (uVar4 <= lVar2 + uVar5) {
      uVar4 = lVar2 + uVar5;
    }
    if (uVar4 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = CreateSystemThreadObject(_DAT_180c8ed18,uVar4 * 8,(char)param_1[3]);
      lVar3 = *param_1;
    }
    if (lVar3 != param_2) {
                    // WARNING: Subroutine does not return
      memmove(uVar1,lVar3,param_2 - lVar3);
    }
                    // WARNING: Subroutine does not return
    memmove(uVar1,param_3,param_4 - param_3);
  }
  uVar4 = lVar2 - param_2 >> 3;
  if (uVar5 < uVar4) {
    lVar3 = lVar2 + uVar5 * -8;
    if (lVar3 != lVar2) {
                    // WARNING: Subroutine does not return
      memmove(lVar2,lVar3,uVar5 * 8);
    }
                    // WARNING: Subroutine does not return
    memmove(lVar2 - ((lVar2 + uVar5 * -8) - param_2 & 0xfffffffffffffff8),param_2);
  }
  lVar3 = param_3 + uVar4 * 8;
  if (lVar3 != param_4) {
                    // WARNING: Subroutine does not return
    memmove(lVar2,lVar3,param_4 - lVar3);
  }
  if (param_2 != lVar2) {
                    // WARNING: Subroutine does not return
    memmove(lVar2 + (uVar5 - uVar4) * 8,param_2,lVar2 - param_2);
  }
                    // WARNING: Subroutine does not return
  memmove(param_2 + (uVar4 - (lVar3 - param_3 >> 3)) * 8,param_3,lVar3 - param_3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180058a31(long long *param_1,long long param_2,long long param_3,long long param_4)
void FUN_180058a31(long long *param_1,long long param_2,long long param_3,long long param_4)

{
  void* uVar1;
  long long lVar2;
  long long lVar3;
  ulong long uVar4;
  ulong long uVar5;
  
  lVar2 = param_1[1];
  uVar5 = param_4 - param_3 >> 3;
  if ((ulong long)(param_1[2] - lVar2 >> 3) < uVar5) {
    lVar3 = *param_1;
    lVar2 = lVar2 - lVar3 >> 3;
    uVar4 = lVar2 * 2;
    if (lVar2 == 0) {
      uVar4 = 1;
    }
    if (uVar4 <= lVar2 + uVar5) {
      uVar4 = lVar2 + uVar5;
    }
    if (uVar4 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = CreateSystemThreadObject(_DAT_180c8ed18,uVar4 * 8,(char)param_1[3]);
      lVar3 = *param_1;
    }
    if (lVar3 != param_2) {
                    // WARNING: Subroutine does not return
      memmove(uVar1,lVar3,param_2 - lVar3);
    }
                    // WARNING: Subroutine does not return
    memmove(uVar1,param_3,param_4 - param_3);
  }
  uVar4 = lVar2 - param_2 >> 3;
  if (uVar5 < uVar4) {
    lVar3 = lVar2 + uVar5 * -8;
    if (lVar3 != lVar2) {
                    // WARNING: Subroutine does not return
      memmove(lVar2,lVar3,uVar5 * 8);
    }
                    // WARNING: Subroutine does not return
    memmove(lVar2 - ((lVar2 + uVar5 * -8) - param_2 & 0xfffffffffffffff8),param_2);
  }
  lVar3 = param_3 + uVar4 * 8;
  if (lVar3 != param_4) {
                    // WARNING: Subroutine does not return
    memmove(lVar2,lVar3,param_4 - lVar3);
  }
  if (param_2 != lVar2) {
                    // WARNING: Subroutine does not return
    memmove(lVar2 + (uVar5 - uVar4) * 8,param_2,lVar2 - param_2);
  }
                    // WARNING: Subroutine does not return
  memmove(param_2 + (uVar4 - (lVar3 - param_3 >> 3)) * 8,param_3,lVar3 - param_3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180058b3e(long long param_1,long long param_2)
void FUN_180058b3e(long long param_1,long long param_2)

{
  void* uVar1;
  long long unaff_RBP;
  long long unaff_RSI;
  long long *unaff_RDI;
  ulong long uVar2;
  
  param_1 = param_1 >> 3;
  uVar2 = param_1 * 2;
  if (param_1 == 0) {
    uVar2 = 1;
  }
  if (uVar2 <= (ulong long)(param_1 + unaff_RBP)) {
    uVar2 = param_1 + unaff_RBP;
  }
  if (uVar2 == 0) {
    uVar1 = 0;
  }
  else {
    uVar1 = CreateSystemThreadObject(_DAT_180c8ed18,uVar2 * 8,(char)unaff_RDI[3]);
    param_2 = *unaff_RDI;
  }
  if (param_2 != unaff_RSI) {
                    // WARNING: Subroutine does not return
    memmove(uVar1,param_2,unaff_RSI - param_2);
  }
                    // WARNING: Subroutine does not return
  memmove(uVar1);
}




// 函数: void FUN_180058bfa(void)
void FUN_180058bfa(void)

{
  return;
}




// 函数: void FUN_180058c16(void)
void FUN_180058c16(void)

{
  return;
}




// 函数: void FUN_180058c20(long long param_1)
void FUN_180058c20(long long param_1)

{
  FUN_1800591c0();
  *(void* *)(param_1 + 8) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 8) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180058c80(void* *param_1)
void FUN_180058c80(void* *param_1)

{
  if ((long long *)param_1[0x13] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x13] + 0x38))();
  }
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180058cc0(void* *param_1)
void FUN_180058cc0(void* *param_1)

{
  FUN_180058db0(param_1 + 4);
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180058d20(void* *param_1)
void FUN_180058d20(void* *param_1)

{
  if (param_1[4] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180058d90(long long *param_1)
void FUN_180058d90(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x548) {
    FUN_1800594b0(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180058db0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180058db0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  _Mtx_destroy_in_situ();
  FUN_180058370(param_1 + 0xf0,*(void* *)(param_1 + 0x100),param_3,param_4,uVar1);
  FUN_180058370(param_1 + 0xc0,*(void* *)(param_1 + 0xd0));
  FUN_180058370(param_1 + 0x90,*(void* *)(param_1 + 0xa0));
  FUN_1800593f0(param_1 + 0x60,*(void* *)(param_1 + 0x70));
  FUN_180058710(param_1 + 0x30,*(void* *)(param_1 + 0x40));
  FUN_1800593f0(param_1,*(void* *)(param_1 + 0x10));
  return;
}




// 函数: void FUN_180058e60(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180058e60(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_1800593f0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180058e90(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180058e90(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_1800593f0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_180058f00(void* param_1,void* *param_2)
void FUN_180058f00(void* param_1,void* *param_2)

{
  (*(code *)*param_2)();
  return;
}



// WARNING: Removing unreachable block (ram,0x00018017747d)
// WARNING: Removing unreachable block (ram,0x000180177a18)
// WARNING: Removing unreachable block (ram,0x000180177a22)
// WARNING: Removing unreachable block (ram,0x000180177a2e)
// WARNING: Removing unreachable block (ram,0x000180177a35)
// WARNING: Removing unreachable block (ram,0x000180177581)
// WARNING: Removing unreachable block (ram,0x000180177590)
// WARNING: Removing unreachable block (ram,0x00018017759c)
// WARNING: Removing unreachable block (ram,0x0001801775a3)
// WARNING: Removing unreachable block (ram,0x0001801775b3)
// WARNING: Removing unreachable block (ram,0x0001801775c0)
// WARNING: Removing unreachable block (ram,0x0001801775cc)
// WARNING: Removing unreachable block (ram,0x0001801775d3)
// WARNING: Removing unreachable block (ram,0x000180177263)
// WARNING: Removing unreachable block (ram,0x000180177296)
// WARNING: Removing unreachable block (ram,0x00018017726a)
// WARNING: Removing unreachable block (ram,0x000180177274)
// WARNING: Removing unreachable block (ram,0x000180177280)
// WARNING: Removing unreachable block (ram,0x000180177287)
// WARNING: Removing unreachable block (ram,0x000180177290)
// WARNING: Removing unreachable block (ram,0x000180177298)
// WARNING: Removing unreachable block (ram,0x00018017753a)
// WARNING: Removing unreachable block (ram,0x000180177540)
// WARNING: Removing unreachable block (ram,0x000180177550)
// WARNING: Removing unreachable block (ram,0x00018017755c)
// WARNING: Removing unreachable block (ram,0x000180177563)
// WARNING: Removing unreachable block (ram,0x0001801772c2)
// WARNING: Removing unreachable block (ram,0x0001801772d0)
// WARNING: Removing unreachable block (ram,0x0001801772dc)
// WARNING: Removing unreachable block (ram,0x0001801772e3)
// WARNING: Removing unreachable block (ram,0x00018017764c)
// WARNING: Removing unreachable block (ram,0x00018017749a)
// WARNING: Removing unreachable block (ram,0x0001801774a8)
// WARNING: Removing unreachable block (ram,0x0001801774aa)
// WARNING: Removing unreachable block (ram,0x000180176fc3)
// WARNING: Removing unreachable block (ram,0x000180177722)
// WARNING: Removing unreachable block (ram,0x00018017729d)
// WARNING: Removing unreachable block (ram,0x00018017766b)
// WARNING: Removing unreachable block (ram,0x000180177677)
// WARNING: Removing unreachable block (ram,0x000180177679)
// WARNING: Removing unreachable block (ram,0x00018017739f)
// WARNING: Removing unreachable block (ram,0x0001801773a6)
// WARNING: Removing unreachable block (ram,0x0001801773b0)
// WARNING: Removing unreachable block (ram,0x0001801773bc)
// WARNING: Removing unreachable block (ram,0x0001801773c3)
// WARNING: Removing unreachable block (ram,0x00018017731b)
// WARNING: Removing unreachable block (ram,0x000180177321)
// WARNING: Removing unreachable block (ram,0x000180177330)
// WARNING: Removing unreachable block (ram,0x00018017733c)
// WARNING: Removing unreachable block (ram,0x000180177343)
// WARNING: Removing unreachable block (ram,0x00018017734b)
// WARNING: Removing unreachable block (ram,0x000180177356)
// WARNING: Removing unreachable block (ram,0x000180177360)
// WARNING: Removing unreachable block (ram,0x00018017736c)
// WARNING: Removing unreachable block (ram,0x000180177373)
// WARNING: Removing unreachable block (ram,0x00018017737b)
// WARNING: Removing unreachable block (ram,0x000180177385)
// WARNING: Removing unreachable block (ram,0x0001801773cb)
// WARNING: Removing unreachable block (ram,0x000180177381)
// WARNING: Removing unreachable block (ram,0x0001801773cd)
// WARNING: Removing unreachable block (ram,0x0001801773d6)
// WARNING: Removing unreachable block (ram,0x0001801773da)
// WARNING: Removing unreachable block (ram,0x0001801773e4)
// WARNING: Removing unreachable block (ram,0x0001801773eb)
// WARNING: Removing unreachable block (ram,0x000180177400)
// WARNING: Removing unreachable block (ram,0x00018017740c)
// WARNING: Removing unreachable block (ram,0x000180177413)
// WARNING: Removing unreachable block (ram,0x00018017741e)
// WARNING: Removing unreachable block (ram,0x000180177417)
// WARNING: Removing unreachable block (ram,0x000180177420)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180059000(long long *param_1)
void FUN_180059000(long long *param_1)

{
  void* *******pppppppuVar1;
  void** systemDataTable;
  void* *puVar3;
  void* *puVar4;
  void* *puVar5;
  void** systemRootNode;
  uint32_t uVar7;
  int iVar8;
  void* uVar9;
  long long lVar10;
  uint8_t *puVar11;
  long long lVar12;
  undefined *puVar13;
  void* *******pppppppuVar14;
  long long *plVar15;
  uint uVar16;
  undefined *puVar17;
  long long lVar18;
  void* ******ppppppuVar19;
  int iVar20;
  uint *puVar21;
  ulong long uVar22;
  ulong long uVar23;
  ulong long uVar24;
  ulong long uVar25;
  bool bVar26;
  uint8_t auStack_3b8 [32];
  undefined *puStack_398;
  uint8_t *puStack_390;
  uint32_t uStack_388;
  ulong long uStack_380;
  uint uStack_378;
  int iStack_374;
  int iStack_370;
  long long lStack_368;
  void* ******ppppppuStack_360;
  void* ******ppppppuStack_358;
  void* ******ppppppuStack_350;
  void* uStack_348;
  void* uStack_340;
  uint32_t uStack_338;
  undefined *puStack_330;
  undefined *puStack_328;
  uint32_t uStack_320;
  ulong long uStack_318;
  long long lStack_310;
  void* *puStack_308;
  void* *puStack_300;
  void* uStack_2f8;
  uint32_t uStack_2f0;
  undefined *puStack_2e8;
  long long lStack_2e0;
  uint32_t uStack_2d0;
  long long lStack_2c8;
  ulong long uStack_2c0;
  long long lStack_2b8;
  void* *puStack_2b0;
  void* *puStack_2a8;
  void* *puStack_2a0;
  void* uStack_298;
  undefined *puStack_290;
  uint8_t *puStack_288;
  uint32_t uStack_280;
  uint8_t auStack_278 [16];
  void* uStack_268;
  void* uStack_48;
  uint32_t uStack_40;
  uint32_t uStack_3c;
  ulong long uStack_38;
  void* uStack_30;
  
  uStack_30 = 0x180059023;
  uVar9 = FUN_18062b1e0(_DAT_180c8ed18,0x270,8,3);
  uStack_30 = 0x18005902b;
  lVar10 = FUN_180175aa0(uVar9);
  uVar7 = *(uint32_t *)(_DAT_180c86920 + 0x1dc0);
  _DAT_180c8a9d0 = lVar10;
  *(uint32_t *)(lVar10 + 0x1e0) = *(uint32_t *)(_DAT_180c86920 + 0x1d50);
  *(uint32_t *)(lVar10 + 0x1e4) = uVar7;
  uStack_30 = 0x180059066;
  (**(code **)(**(long long **)(*param_1 + 0x2b0) + 0xf8))();
  uStack_298 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_3b8;
  uStack_378 = 0;
  lStack_310 = _DAT_180c8a9d0;
  *(void* *)(_DAT_180c8a9d0 + 0xf0) = 0;
  uStack_338 = 3;
  ppppppuStack_360 = &ppppppuStack_360;
  ppppppuStack_358 = &ppppppuStack_360;
  ppppppuStack_350 = (void* *******)0x0;
  uStack_348 = 0;
  uStack_340 = 0;
  lStack_2b8 = *_DAT_180c86870;
  iStack_370 = 0;
  lVar10 = *(long long *)(lStack_2b8 + 0x8a8);
  if (*(long long *)(lStack_2b8 + 0x8b0) - lVar10 >> 5 != 0) {
    lStack_368 = 0;
    do {
      lVar12 = lStack_368;
      iVar8 = iStack_370;
      puVar17 = *(undefined **)(lStack_368 * 0x20 + 8 + lVar10);
      puVar13 = &SystemStringTemplate;
      if (puVar17 != (undefined *)0x0) {
        puVar13 = puVar17;
      }
      puStack_398 = &SystemGlobalDataReference;
      uStack_380 = 0;
      puStack_390 = (uint8_t *)0x0;
      uStack_388 = 0;
      if (puVar13 != (undefined *)0x0) {
        lVar10 = -1;
        do {
          lVar18 = lVar10;
          lVar10 = lVar18 + 1;
        } while (puVar13[lVar10] != '\0');
        if ((int)lVar10 != 0) {
          iVar20 = (int)lVar18 + 2;
          iVar8 = iVar20;
          if (iVar20 < 0x10) {
            iVar8 = 0x10;
          }
          puVar11 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar8,0x13);
          *puVar11 = 0;
          puStack_390 = puVar11;
          uVar7 = StartSystemThread(puVar11);
          uStack_380 = CONCAT44(uStack_380._4_4_,uVar7);
                    // WARNING: Subroutine does not return
          memcpy(puVar11,puVar13,iVar20);
        }
      }
      uStack_388 = 0;
      FUN_180175f80(&SystemGlobalDataReference,&puStack_2e8,&puStack_398);
      puStack_390 = (uint8_t *)0x0;
      uStack_380 = uStack_380 & 0xffffffff00000000;
      puStack_398 = &SystemMemoryAllocatorReference;
      puStack_308 = (void* *)0x0;
      puStack_300 = (void* *)0x0;
      uStack_2f8 = 0;
      uStack_2f0 = 3;
      puStack_290 = &UNK_1809fdc18;
      puStack_288 = auStack_278;
      auStack_278[0] = 0;
      uStack_280 = 4;
      strcpy_s(auStack_278,0x10,&UNK_180a092c4);
      FUN_18062cb00(&puStack_2e8,&puStack_308,&puStack_290);
      puStack_290 = &SystemMemoryAllocatorReference;
      iStack_374 = 0;
      lStack_2c8 = 0;
      uStack_2c0 = (long long)puStack_300 - (long long)puStack_308 >> 5;
      puVar2 = puStack_308;
      puVar3 = puStack_308;
      puVar4 = puStack_300;
      if (uStack_2c0 != 0) {
        do {
          lVar10 = lStack_2c8;
          puVar2 = puStack_308;
          iVar8 = iStack_374;
          puVar17 = &SystemStringTemplate;
          if ((undefined *)puStack_308[lStack_2c8 * 4 + 1] != (undefined *)0x0) {
            puVar17 = (undefined *)puStack_308[lStack_2c8 * 4 + 1];
          }
          lVar12 = strrchr(puVar17,0x2f);
          if (lVar12 == 0) {
            puVar17 = &SystemStringTemplate;
            if ((undefined *)puVar2[lVar10 * 4 + 1] != (undefined *)0x0) {
              puVar17 = (undefined *)puVar2[lVar10 * 4 + 1];
            }
          }
          else {
            puVar17 = (undefined *)(lVar12 + 1);
          }
          puVar13 = (undefined *)strchr(puVar17,0x2e);
          if (puVar13 == (undefined *)0x0) {
            puVar13 = &SystemStringTemplate;
            if ((undefined *)puVar2[lVar10 * 4 + 1] != (undefined *)0x0) {
              puVar13 = (undefined *)puVar2[lVar10 * 4 + 1];
            }
            puVar13 = puVar13 + *(int *)(puVar2 + lVar10 * 4 + 2);
          }
          if ((long long)puVar13 - (long long)puVar17 != 0) {
                    // WARNING: Subroutine does not return
            memcpy(&uStack_268,puVar17,(long long)puVar13 - (long long)puVar17);
          }
                    // WARNING: Ignoring partial resolution of indirect
          uStack_268._0_1_ = 0;
          uVar16 = 0;
          uVar7 = 0;
          puStack_330 = &SystemGlobalDataReference;
          uStack_318 = 0;
          puStack_328 = (undefined *)0x0;
          uStack_320 = 0;
          lVar12 = -1;
          do {
            lVar18 = lVar12;
            lVar12 = lVar18 + 1;
          } while (*(char *)((long long)&uStack_268 + lVar18 + 1) != '\0');
          if ((int)(lVar18 + 1) != 0) {
            iVar20 = (int)lVar18 + 2;
            iVar8 = iVar20;
            if (iVar20 < 0x10) {
              iVar8 = 0x10;
            }
            puStack_328 = (undefined *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar8,0x13);
            *puStack_328 = 0;
            uVar22 = (ulong long)puStack_328 & 0xffffffffffc00000;
            if (uVar22 != 0) {
              lVar10 = ((long long)puStack_328 - uVar22 >> 0x10) * 0x50 + 0x80 + uVar22;
              puVar21 = (uint *)(lVar10 - (ulong long)*(uint *)(lVar10 + 4));
              if ((*(byte *)((long long)puVar21 + 0xe) & 2) == 0) {
                uVar16 = puVar21[7];
                if (0x3ffffff < uVar16) {
                  uVar16 = *puVar21 << 0x10;
                }
              }
              else {
                uVar16 = puVar21[7];
                if (uVar16 < 0x4000000) {
                  uVar23 = (ulong long)uVar16;
                }
                else {
                  uVar23 = (ulong long)*puVar21 << 0x10;
                }
                if (0x3ffffff < uVar16) {
                  uVar16 = *puVar21 << 0x10;
                }
                uVar16 = uVar16 - (int)(((long long)puStack_328 -
                                        (((long long)((long long)puVar21 + (-0x80 - uVar22)) / 0x50) *
                                         0x10000 + uVar22)) % uVar23);
              }
            }
            uStack_318 = CONCAT44(uStack_318._4_4_,uVar16);
                    // WARNING: Subroutine does not return
            memcpy(puStack_328,&uStack_268,iVar20);
          }
          uStack_320 = 0;
          pppppppuVar14 = &ppppppuStack_360;
          for (pppppppuVar1 = (void* *******)ppppppuStack_350;
              pppppppuVar1 != (void* *******)0x0;
              pppppppuVar1 = (void* *******)pppppppuVar1[1]) {
            pppppppuVar14 = pppppppuVar1;
          }
          if ((pppppppuVar14 == &ppppppuStack_360) ||
             (lVar12 = lVar10, *(int *)(pppppppuVar14 + 6) != 0)) {
            if ((pppppppuVar14 != (void* *******)ppppppuStack_360) &&
               (pppppppuVar14 != &ppppppuStack_360)) {
              func_0x00018066bd70(pppppppuVar14);
            }
            bVar26 = true;
            pppppppuVar14 = &ppppppuStack_360;
            pppppppuVar1 = (void* *******)ppppppuStack_350;
            while (pppppppuVar1 != (void* *******)0x0) {
              bVar26 = *(int *)(pppppppuVar1 + 6) != 0;
              pppppppuVar14 = pppppppuVar1;
              if (bVar26) {
                pppppppuVar1 = (void* *******)pppppppuVar1[1];
              }
              else {
                pppppppuVar1 = (void* *******)*pppppppuVar1;
              }
            }
            lVar12 = lStack_2c8;
            iVar8 = iStack_374;
            if (bVar26) {
              if (pppppppuVar14 == (void* *******)ppppppuStack_358) {
                if ((pppppppuVar14 != &ppppppuStack_360) && (*(int *)(pppppppuVar14 + 6) == 0)) {
                  uVar7 = 1;
                }
                lVar10 = CreateSystemThreadObject(_DAT_180c8ed18,0x60,(uint8_t)uStack_338);
                puStack_2b0 = (void* *)(lVar10 + 0x20);
                *puStack_2b0 = &SystemMemoryAllocatorReference;
                *(void* *)(lVar10 + 0x28) = 0;
                *(uint32_t *)(lVar10 + 0x30) = 0;
                *puStack_2b0 = &SystemGlobalDataReference;
                *(void* *)(lVar10 + 0x38) = 0;
                *(void* *)(lVar10 + 0x28) = 0;
                *(uint32_t *)(lVar10 + 0x30) = 0;
                puStack_2a8 = puStack_2b0;
                FUN_1806277c0(puStack_2b0,0);
                puStack_2a0 = (void* *)(lVar10 + 0x40);
                *puStack_2a0 = &SystemMemoryAllocatorReference;
                *(void* *)(lVar10 + 0x48) = 0;
                *(uint32_t *)(lVar10 + 0x50) = 0;
                *puStack_2a0 = &SystemGlobalDataReference;
                *(void* *)(lVar10 + 0x58) = 0;
                *(void* *)(lVar10 + 0x48) = 0;
                *(uint32_t *)(lVar10 + 0x50) = 0;
                    // WARNING: Subroutine does not return
                FUN_18066bdc0(lVar10,pppppppuVar14,&ppppppuStack_360,uVar7);
              }
              pppppppuVar14 = (void* *******)func_0x00018066b9a0(pppppppuVar14);
              lVar12 = lStack_2c8;
              iVar8 = iStack_374;
            }
          }
          uVar16 = *(uint *)(puVar2 + lVar10 * 4 + 2);
          uVar22 = (ulong long)uVar16;
          if (puVar2[lVar10 * 4 + 1] != 0) {
            FUN_1806277c0(pppppppuVar14 + 8,uVar22);
          }
          if (uVar16 != 0) {
                    // WARNING: Subroutine does not return
            memcpy(pppppppuVar14[9],puVar2[lVar10 * 4 + 1],uVar22);
          }
          *(uint32_t *)(pppppppuVar14 + 10) = 0;
          if (pppppppuVar14[9] != (void* ******)0x0) {
            *(uint8_t *)(uVar22 + (long long)pppppppuVar14[9]) = 0;
          }
          *(uint32_t *)((long long)pppppppuVar14 + 0x5c) =
               *(uint32_t *)((long long)puVar2 + lVar10 * 0x20 + 0x1c);
          puStack_328 = (undefined *)0x0;
          uStack_318 = uStack_318 & 0xffffffff00000000;
          puStack_330 = &SystemMemoryAllocatorReference;
          iStack_374 = iVar8 + 1;
          lStack_2c8 = lVar12 + 1;
          puVar2 = puStack_308;
          puVar3 = puStack_308;
          puVar4 = puStack_300;
          iVar8 = iStack_370;
          lVar12 = lStack_368;
        } while ((ulong long)(long long)iStack_374 < uStack_2c0);
      }
      for (; puVar6 = puStack_300, puVar5 = puStack_308, puVar2 != puStack_300; puVar2 = puVar2 + 4)
      {
        puStack_308 = puVar3;
        puStack_300 = puVar4;
        (**(code **)*puVar2)(puVar2,0);
        puVar3 = puStack_308;
        puVar4 = puStack_300;
        puStack_300 = puVar6;
        puStack_308 = puVar5;
      }
      if (puStack_308 != (void* *)0x0) {
        puStack_308 = puVar3;
        puStack_300 = puVar4;
                    // WARNING: Subroutine does not return
        FUN_18064e900(puVar5);
      }
      puStack_2e8 = &SystemGlobalDataReference;
      if (lStack_2e0 != 0) {
        puStack_308 = puVar3;
        puStack_300 = puVar4;
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lStack_2e0 = 0;
      uStack_2d0 = 0;
      puStack_2e8 = &SystemMemoryAllocatorReference;
      iStack_370 = iVar8 + 1;
      lStack_368 = lVar12 + 1;
      lVar10 = *(long long *)(lStack_2b8 + 0x8a8);
      puStack_308 = puVar3;
      puStack_300 = puVar4;
    } while ((ulong long)(long long)iStack_370 <
             (ulong long)(*(long long *)(lStack_2b8 + 0x8b0) - lVar10 >> 5));
  }
  uStack_48 = 0x3f8000003f800000;
  uStack_40 = 0x3f000000;
  uStack_3c = 0;
  if ((void* *******)ppppppuStack_358 != &ppppppuStack_360) {
    lVar10 = lStack_310 + 0x150;
    pppppppuVar14 = (void* *******)ppppppuStack_358;
    lVar12 = lStack_310;
    lStack_368 = lVar10;
    do {
      plVar15 = (long long *)FUN_180058080(lVar10,&puStack_2a0,pppppppuVar14 + 4);
      if (*plVar15 != lVar10) {
        bVar26 = false;
        uVar23 = 0;
        lVar18 = *(long long *)(lVar12 + 0xc0);
        uVar22 = uVar23;
        if (*(long long *)(lVar12 + 200) - lVar18 >> 3 != 0) {
          do {
            lVar10 = *(long long *)(lVar18 + uVar23);
            puStack_398 = &SystemGlobalDataReference;
            uStack_380 = 0;
            puStack_390 = (uint8_t *)0x0;
            uStack_388 = 0;
            if (*(int *)(lVar10 + 0xb8) != 0) {
              iVar8 = *(int *)(lVar10 + 0xb8) + 1;
              if (iVar8 < 0x10) {
                iVar8 = 0x10;
              }
              puStack_390 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar8,0x13);
              *puStack_390 = 0;
              uVar24 = (ulong long)puStack_390 & 0xffffffffffc00000;
              if (uVar24 == 0) {
                uVar16 = 0;
              }
              else {
                lVar12 = ((long long)puStack_390 - uVar24 >> 0x10) * 0x50 + 0x80 + uVar24;
                puVar21 = (uint *)(lVar12 - (ulong long)*(uint *)(lVar12 + 4));
                if ((*(byte *)((long long)puVar21 + 0xe) & 2) == 0) {
                  uVar16 = puVar21[7];
                  if (0x3ffffff < uVar16) {
                    uVar16 = *puVar21 << 0x10;
                  }
                }
                else {
                  uVar16 = puVar21[7];
                  if (uVar16 < 0x4000000) {
                    uVar25 = (ulong long)uVar16;
                  }
                  else {
                    uVar25 = (ulong long)*puVar21 << 0x10;
                  }
                  if (0x3ffffff < uVar16) {
                    uVar16 = *puVar21 << 0x10;
                  }
                  uVar16 = uVar16 - (int)(((long long)puStack_390 -
                                          (((long long)((long long)puVar21 + (-0x80 - uVar24)) / 0x50)
                                           * 0x10000 + uVar24)) % uVar25);
                }
              }
              uStack_380 = CONCAT44(uStack_380._4_4_,uVar16);
              if (*(int *)(lVar10 + 0xb8) != 0) {
                    // WARNING: Subroutine does not return
                memcpy(puStack_390,*(void* *)(lVar10 + 0xb0),*(int *)(lVar10 + 0xb8) + 1);
              }
            }
            if (*(long long *)(lVar10 + 0xb0) != 0) {
              uStack_388 = 0;
              if (puStack_390 != (uint8_t *)0x0) {
                *puStack_390 = 0;
              }
              uStack_380 = uStack_380 & 0xffffffff;
            }
            uStack_378 = uStack_378 & 0xfffffffd;
            puStack_398 = &SystemGlobalDataReference;
            if (puStack_390 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
              FUN_18064e900(puStack_390);
            }
            puStack_390 = (uint8_t *)0x0;
            uStack_380 = uStack_380 & 0xffffffff00000000;
            puStack_398 = &SystemMemoryAllocatorReference;
            lVar12 = lStack_310;
            lVar10 = lStack_368;
            if (*(int *)(pppppppuVar14 + 6) == 0) {
              bVar26 = true;
              break;
            }
            uVar16 = (int)uVar22 + 1;
            uVar22 = (ulong long)uVar16;
            uVar23 = uVar23 + 8;
            lVar18 = *(long long *)(lStack_310 + 0xc0);
          } while ((ulong long)(long long)(int)uVar16 <
                   (ulong long)(*(long long *)(lStack_310 + 200) - lVar18 >> 3));
        }
        if (!bVar26) {
          uVar9 = FUN_180624440(&uStack_268,pppppppuVar14 + 8);
          FUN_1806279c0(&puStack_330,uVar9);
          uStack_268 = &SystemMemoryAllocatorReference;
          ppppppuVar19 = (void* ******)&SystemStringTemplate;
          if (pppppppuVar14[5] != (void* ******)0x0) {
            ppppppuVar19 = pppppppuVar14[5];
          }
          FUN_180627910(&puStack_308,ppppppuVar19);
          puVar17 = &SystemStringTemplate;
          if (puStack_328 != (undefined *)0x0) {
            puVar17 = puStack_328;
          }
          FUN_180627910(&puStack_2e8,puVar17);
          FUN_1801762b0(lVar12,&puStack_2e8,&puStack_308,&uStack_48);
          puStack_2e8 = &SystemGlobalDataReference;
          if (lStack_2e0 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          lStack_2e0 = 0;
          uStack_2d0 = 0;
          puStack_2e8 = &SystemMemoryAllocatorReference;
          puStack_308 = (void* *)&SystemGlobalDataReference;
          if (puStack_300 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          puStack_300 = (void* *)0x0;
          uStack_2f0 = 0;
          puStack_308 = (void* *)&SystemMemoryAllocatorReference;
          puStack_330 = &SystemGlobalDataReference;
          if (puStack_328 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          puStack_328 = (undefined *)0x0;
          uStack_318 = uStack_318 & 0xffffffff00000000;
          puStack_330 = &SystemMemoryAllocatorReference;
        }
      }
      pppppppuVar14 = (void* *******)func_0x00018066bd70(pppppppuVar14);
    } while (pppppppuVar14 != &ppppppuStack_360);
  }
  FUN_180058020(&ppppppuStack_360);
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_38 ^ (ulong long)auStack_3b8);
}



void* * FUN_1800590b0(void* *param_1,uint8_t *param_2,long long param_3)

{
  byte bVar1;
  bool bVar2;
  void* *puVar3;
  void* *puVar4;
  uint uVar5;
  byte *pbVar6;
  long long lVar7;
  
  bVar2 = true;
  puVar4 = (void* *)param_1[2];
  puVar3 = param_1;
  while (puVar4 != (void* *)0x0) {
    puVar3 = puVar4;
    if (*(int *)(puVar4 + 6) == 0) {
      bVar2 = false;
LAB_1800590e2:
      puVar4 = (void* *)*puVar4;
    }
    else {
      if (*(int *)(param_3 + 0x10) == 0) {
        bVar2 = true;
      }
      else {
        pbVar6 = (byte *)puVar4[5];
        lVar7 = *(long long *)(param_3 + 8) - (long long)pbVar6;
        do {
          bVar1 = *pbVar6;
          uVar5 = (uint)pbVar6[lVar7];
          if (bVar1 != uVar5) break;
          pbVar6 = pbVar6 + 1;
        } while (uVar5 != 0);
        bVar2 = 0 < (int)(bVar1 - uVar5);
      }
      if (!bVar2) goto LAB_1800590e2;
      puVar4 = (void* *)puVar4[1];
    }
  }
  puVar4 = puVar3;
  if (bVar2) {
    if (puVar3 == (void* *)param_1[1]) {
      *param_2 = 1;
      return puVar3;
    }
    puVar4 = (void* *)func_0x00018066b9a0(puVar3);
  }
  if (*(int *)(param_3 + 0x10) != 0) {
    if (*(int *)(puVar4 + 6) != 0) {
      pbVar6 = *(byte **)(param_3 + 8);
      lVar7 = puVar4[5] - (long long)pbVar6;
      do {
        bVar1 = *pbVar6;
        uVar5 = (uint)pbVar6[lVar7];
        if (bVar1 != uVar5) break;
        pbVar6 = pbVar6 + 1;
      } while (uVar5 != 0);
      if ((int)(bVar1 - uVar5) < 1) goto LAB_1800591a6;
    }
    *param_2 = 1;
    return puVar3;
  }
LAB_1800591a6:
  *param_2 = 0;
  return puVar4;
}




// 函数: void FUN_1800591c0(long long *param_1)
void FUN_1800591c0(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x548) {
    FUN_1800594b0(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180059230(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180059230(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_1800593f0(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}



long long FUN_180059250(long long param_1,long long param_2,long long param_3)

{
  uint uVar1;
  long long *plVar2;
  long long lVar3;
  ulong long uVar4;
  
  lVar3 = param_2 - param_1 >> 5;
  if (0 < lVar3) {
    plVar2 = (long long *)(param_1 + 8);
    param_1 = param_3 - param_1;
    do {
      uVar1 = *(uint *)(plVar2 + 1);
      uVar4 = (ulong long)uVar1;
      if (*plVar2 != 0) {
        FUN_1806277c0(param_3,uVar4);
      }
      if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
        memcpy(*(void* *)(param_1 + (long long)plVar2),*plVar2,uVar4);
      }
      *(uint32_t *)(param_1 + 8 + (long long)plVar2) = 0;
      if (*(long long *)(param_1 + (long long)plVar2) != 0) {
        *(uint8_t *)(uVar4 + *(long long *)(param_1 + (long long)plVar2)) = 0;
      }
      lVar3 = lVar3 + -1;
      *(uint32_t *)(param_1 + 0x14 + (long long)plVar2) = *(uint32_t *)((long long)plVar2 + 0x14);
      param_3 = param_3 + 0x20;
      plVar2 = plVar2 + 4;
    } while (0 < lVar3);
  }
  return param_3;
}



long long FUN_18005926c(long long param_1,void* param_2,long long param_3)

{
  uint uVar1;
  long long *plVar2;
  long long unaff_RBP;
  long long unaff_RSI;
  ulong long uVar3;
  
  plVar2 = (long long *)(param_1 + 8);
  param_3 = param_3 - param_1;
  do {
    uVar1 = *(uint *)(plVar2 + 1);
    uVar3 = (ulong long)uVar1;
    if (*plVar2 != 0) {
      FUN_1806277c0(unaff_RSI,uVar3);
    }
    if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
      memcpy(*(void* *)(param_3 + (long long)plVar2),*plVar2,uVar3);
    }
    *(uint32_t *)(param_3 + 8 + (long long)plVar2) = 0;
    if (*(long long *)(param_3 + (long long)plVar2) != 0) {
      *(uint8_t *)(uVar3 + *(long long *)(param_3 + (long long)plVar2)) = 0;
    }
    unaff_RBP = unaff_RBP + -1;
    *(uint32_t *)(param_3 + 0x14 + (long long)plVar2) = *(uint32_t *)((long long)plVar2 + 0x14);
    unaff_RSI = unaff_RSI + 0x20;
    plVar2 = plVar2 + 4;
  } while (0 < unaff_RBP);
  return unaff_RSI;
}




// 函数: void FUN_1800592e4(void)
void FUN_1800592e4(void)

{
  return;
}



long long FUN_180059300(long long param_1,long long param_2,long long param_3)

{
  if (param_1 != param_2) {
    do {
      FUN_180627ae0(param_3,param_1);
      param_1 = param_1 + 0x20;
      param_3 = param_3 + 0x20;
    } while (param_1 != param_2);
  }
  return param_3;
}




// 函数: void FUN_180059350(long long param_1,long long param_2,void* param_3)
void FUN_180059350(long long param_1,long long param_2,void* param_3)

{
  if (param_1 != param_2) {
                    // WARNING: Subroutine does not return
    memmove(param_3,param_1,param_2 - param_1);
  }
  return;
}




// 函数: void FUN_180059380(void* *param_1)
void FUN_180059380(void* *param_1)

{
  if (param_1[4] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_1800593f0(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_1800593f0(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_1800593f0(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  FUN_18004b730();
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}




// 函数: void FUN_1800594b0(void* *param_1)
void FUN_1800594b0(void* *param_1)

{
  FUN_1808fc8a8(param_1 + 0x7d,0x58,4,FUN_180044a30,0xfffffffffffffffe);
  FUN_1808fc8a8(param_1 + 0x51,0x58,4,FUN_180044a30);
  FUN_1808fc8a8(param_1 + 0x11,0x20,0x10,FUN_180059620);
  param_1[8] = &SystemGlobalDataReference;
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[9] = 0;
  *(uint32_t *)(param_1 + 0xb) = 0;
  param_1[8] = &SystemMemoryAllocatorReference;
  param_1[4] = &SystemGlobalDataReference;
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 7) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_1800595c0(void* *param_1)
void FUN_1800595c0(void* *param_1)

{
  FUN_18004b730();
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180059620(long long *param_1)
void FUN_180059620(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x50) {
    FUN_1800596a0(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180059640(long long *param_1)
void FUN_180059640(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x50) {
    FUN_1800596a0(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_1800596a0(void* *param_1)
void FUN_1800596a0(void* *param_1)

{
  param_1[4] = &SystemGlobalDataReference;
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 7) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180059730(long long param_1)
void FUN_180059730(long long param_1)

{
  if (*(long long *)(param_1 + 8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  _Mtx_destroy_in_situ();
  return;
}



void* * FUN_180059780(void* *param_1,void* *param_2,void* *param_3)

{
  void* *puVar1;
  void** systemDataTable;
  long long lVar3;
  
  if (param_1 != param_2) {
    lVar3 = (long long)param_3 - (long long)param_1;
    puVar2 = param_1 + 1;
    do {
      *param_3 = &SystemMemoryAllocatorReference;
      *(void* *)(lVar3 + (long long)puVar2) = 0;
      *(uint32_t *)(lVar3 + 8 + (long long)puVar2) = 0;
      *param_3 = &SystemGlobalDataReference;
      *(void* *)(lVar3 + 0x10 + (long long)puVar2) = 0;
      *(void* *)(lVar3 + (long long)puVar2) = 0;
      *(uint32_t *)(lVar3 + 8 + (long long)puVar2) = 0;
      *(uint32_t *)(lVar3 + 8 + (long long)puVar2) = *(uint32_t *)(puVar2 + 1);
      *(void* *)(lVar3 + (long long)puVar2) = *puVar2;
      *(uint32_t *)(lVar3 + 0x14 + (long long)puVar2) = *(uint32_t *)((long long)puVar2 + 0x14);
      *(uint32_t *)(lVar3 + 0x10 + (long long)puVar2) = *(uint32_t *)(puVar2 + 2);
      *(uint32_t *)(puVar2 + 1) = 0;
      *puVar2 = 0;
      puVar2[2] = 0;
      param_3 = param_3 + 4;
      puVar1 = puVar2 + 3;
      puVar2 = puVar2 + 4;
    } while (puVar1 != param_2);
  }
  return param_3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180059820(long long *param_1,void* param_2)
void FUN_180059820(long long *param_1,void* param_2)

{
  void* *puVar1;
  long long lVar2;
  long long lVar3;
  long long lVar4;
  void* *puVar5;
  long long lVar6;
  
  lVar3 = param_1[1];
  lVar4 = *param_1;
  lVar6 = lVar3 - lVar4 >> 5;
  if (lVar6 == 0) {
    lVar6 = 1;
  }
  else {
    lVar6 = lVar6 * 2;
    if (lVar6 == 0) {
      lVar2 = 0;
      goto LAB_180059885;
    }
  }
  lVar2 = CreateSystemThreadObject(_DAT_180c8ed18,lVar6 << 5,(char)param_1[3]);
  lVar3 = param_1[1];
  lVar4 = *param_1;
LAB_180059885:
  lVar3 = FUN_180059780(lVar4,lVar3,lVar2);
  FUN_180627ae0(lVar3,param_2);
  puVar1 = (void* *)param_1[1];
  puVar5 = (void* *)*param_1;
  if (puVar5 != puVar1) {
    do {
      (**(code **)*puVar5)(puVar5,0);
      puVar5 = puVar5 + 4;
    } while (puVar5 != puVar1);
    puVar5 = (void* *)*param_1;
  }
  if (puVar5 == (void* *)0x0) {
    *param_1 = lVar2;
    param_1[2] = lVar6 * 0x20 + lVar2;
    param_1[1] = lVar3 + 0x20;
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar5);
}



void* *
FUN_180059900(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x28,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180059940(long long param_1,long long param_2)
void FUN_180059940(long long param_1,long long param_2)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x10) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x000180059977. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x10);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x10,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}




// 函数: void FUN_1800599c0(long long param_1,void* param_2,int param_3)
void FUN_1800599c0(long long param_1,void* param_2,int param_3)

{
  if (param_3 + 1 < 0x10) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




// 函数: void FUN_1800599df(void)
void FUN_1800599df(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




// 函数: void FUN_180059a04(uint8_t *param_1)
void FUN_180059a04(uint8_t *param_1)

{
  long long unaff_RDI;
  
  *param_1 = 0;
  *(uint32_t *)(unaff_RDI + 0x10) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180059a20(long long param_1,long long param_2,long long param_3)
void FUN_180059a20(long long param_1,long long param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  uint8_t auStack_98 [32];
  void* uStack_78;
  undefined *puStack_70;
  uint8_t *puStack_68;
  uint32_t uStack_60;
  uint8_t auStack_58 [16];
  ulong long uStack_48;
  
  uStack_78 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_98;
  puStack_70 = &UNK_1809fdc18;
  puStack_68 = auStack_58;
  uStack_60 = 0;
  auStack_58[0] = 0;
  lVar1 = strstr(*(void* *)(param_1 + 8));
  if (lVar1 != 0) {
    lVar2 = -1;
    lVar3 = -1;
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    do {
      lVar2 = lVar2 + 1;
    } while (*(char *)(lVar2 + param_3) != '\0');
                    // WARNING: Subroutine does not return
    memcpy(puStack_68,*(long long *)(param_1 + 8),lVar1 - *(long long *)(param_1 + 8));
  }
  puStack_70 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_98);
}




// 函数: void FUN_180059ba0(void* *param_1)
void FUN_180059ba0(void* *param_1)

{
  int *piVar1;
  long long lVar2;
  ulong long uVar3;
  
  if (param_1 == (void* *)0x0) {
    return;
  }
  uVar3 = (ulong long)param_1 & 0xffffffffffc00000;
  if (uVar3 != 0) {
    lVar2 = uVar3 + 0x80 + ((long long)param_1 - uVar3 >> 0x10) * 0x50;
    lVar2 = lVar2 - (ulong long)*(uint *)(lVar2 + 4);
    if ((*(void ***)(uVar3 + 0x70) == &ExceptionList) && (*(char *)(lVar2 + 0xe) == '\0')) {
      *param_1 = *(void* *)(lVar2 + 0x20);
      *(void* **)(lVar2 + 0x20) = param_1;
      piVar1 = (int *)(lVar2 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar3,CONCAT71(0xff000000,*(void ***)(uVar3 + 0x70) == &ExceptionList),
                          param_1,uVar3,0xfffffffffffffffe);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180059bc0(void)
void FUN_180059bc0(void)

{
  long long lVar1;
  
  lVar1 = CreateSystemThreadObject(_DAT_180c8ed18,0x1ae8,10);
  if (lVar1 == 0) {
    return;
  }
  *(void* *)(lVar1 + 0x100) = 0;
  *(void* *)(lVar1 + 0x108) = 0;
  *(uint32_t *)(lVar1 + 0x130) = 0;
  *(void* *)(lVar1 + 0x138) = 0;
  *(undefined2 *)(lVar1 + 0x140) = 0x100;
  *(void* *)(lVar1 + 0x248) = 0;
  *(void* *)(lVar1 + 0x250) = 0;
  *(uint32_t *)(lVar1 + 0x278) = 0;
  *(void* *)(lVar1 + 0x280) = 0;
  *(undefined2 *)(lVar1 + 0x288) = 0x100;
  *(void* *)(lVar1 + 0x390) = 0;
  *(void* *)(lVar1 + 0x398) = 0;
  *(uint32_t *)(lVar1 + 0x3c0) = 0;
  *(void* *)(lVar1 + 0x3c8) = 0;
  *(undefined2 *)(lVar1 + 0x3d0) = 0x100;
  *(void* *)(lVar1 + 0x4d8) = 0;
  *(void* *)(lVar1 + 0x4e0) = 0;
  *(uint32_t *)(lVar1 + 0x508) = 0;
  *(void* *)(lVar1 + 0x510) = 0;
  *(undefined2 *)(lVar1 + 0x518) = 0x100;
  *(void* *)(lVar1 + 0x620) = 0;
  *(void* *)(lVar1 + 0x628) = 0;
  *(uint32_t *)(lVar1 + 0x650) = 0;
  *(void* *)(lVar1 + 0x658) = 0;
  *(undefined2 *)(lVar1 + 0x660) = 0x100;
  *(void* *)(lVar1 + 0x768) = 0;
  *(void* *)(lVar1 + 0x770) = 0;
  *(uint32_t *)(lVar1 + 0x798) = 0;
  *(void* *)(lVar1 + 0x7a0) = 0;
  *(undefined2 *)(lVar1 + 0x7a8) = 0x100;
  *(void* *)(lVar1 + 0x8b0) = 0;
  *(void* *)(lVar1 + 0x8b8) = 0;
  *(uint32_t *)(lVar1 + 0x8e0) = 0;
  *(void* *)(lVar1 + 0x8e8) = 0;
  *(undefined2 *)(lVar1 + 0x8f0) = 0x100;
  *(void* *)(lVar1 + 0x9f8) = 0;
  *(void* *)(lVar1 + 0xa00) = 0;
  *(uint32_t *)(lVar1 + 0xa28) = 0;
  *(void* *)(lVar1 + 0xa30) = 0;
  *(undefined2 *)(lVar1 + 0xa38) = 0x100;
  *(void* *)(lVar1 + 0xb40) = 0;
  *(void* *)(lVar1 + 0xb48) = 0;
  *(uint32_t *)(lVar1 + 0xb70) = 0;
  *(void* *)(lVar1 + 0xb78) = 0;
  *(undefined2 *)(lVar1 + 0xb80) = 0x100;
  *(void* *)(lVar1 + 0xc88) = 0;
  *(void* *)(lVar1 + 0xc90) = 0;
  *(uint32_t *)(lVar1 + 0xcb8) = 0;
  *(void* *)(lVar1 + 0xcc0) = 0;
  *(undefined2 *)(lVar1 + 0xcc8) = 0x100;
  *(void* *)(lVar1 + 0xdd0) = 0;
  *(void* *)(lVar1 + 0xdd8) = 0;
  *(uint32_t *)(lVar1 + 0xe00) = 0;
  *(void* *)(lVar1 + 0xe08) = 0;
  *(undefined2 *)(lVar1 + 0xe10) = 0x100;
  *(void* *)(lVar1 + 0xf18) = 0;
  *(void* *)(lVar1 + 0xf20) = 0;
  *(uint32_t *)(lVar1 + 0xf48) = 0;
  *(void* *)(lVar1 + 0xf50) = 0;
  *(undefined2 *)(lVar1 + 0xf58) = 0x100;
  *(void* *)(lVar1 + 0x1060) = 0;
  *(void* *)(lVar1 + 0x1068) = 0;
  *(uint32_t *)(lVar1 + 0x1090) = 0;
  *(void* *)(lVar1 + 0x1098) = 0;
  *(undefined2 *)(lVar1 + 0x10a0) = 0x100;
  *(void* *)(lVar1 + 0x11a8) = 0;
  *(void* *)(lVar1 + 0x11b0) = 0;
  *(uint32_t *)(lVar1 + 0x11d8) = 0;
  *(void* *)(lVar1 + 0x11e0) = 0;
  *(undefined2 *)(lVar1 + 0x11e8) = 0x100;
  *(void* *)(lVar1 + 0x12f0) = 0;
  *(void* *)(lVar1 + 0x12f8) = 0;
  *(uint32_t *)(lVar1 + 0x1320) = 0;
  *(void* *)(lVar1 + 0x1328) = 0;
  *(undefined2 *)(lVar1 + 0x1330) = 0x100;
  *(void* *)(lVar1 + 0x1438) = 0;
  *(void* *)(lVar1 + 0x1440) = 0;
  *(uint32_t *)(lVar1 + 0x1468) = 0;
  *(void* *)(lVar1 + 0x1470) = 0;
  *(undefined2 *)(lVar1 + 0x1478) = 0x100;
  *(void* *)(lVar1 + 0x1580) = 0;
  *(void* *)(lVar1 + 0x1588) = 0;
  *(uint32_t *)(lVar1 + 0x15b0) = 0;
  *(void* *)(lVar1 + 0x15b8) = 0;
  *(undefined2 *)(lVar1 + 0x15c0) = 0x100;
  *(void* *)(lVar1 + 0x16c8) = 0;
  *(void* *)(lVar1 + 0x16d0) = 0;
  *(uint32_t *)(lVar1 + 0x16f8) = 0;
  *(void* *)(lVar1 + 0x1700) = 0;
  *(undefined2 *)(lVar1 + 0x1708) = 0x100;
  *(void* *)(lVar1 + 0x1810) = 0;
  *(void* *)(lVar1 + 0x1818) = 0;
  *(uint32_t *)(lVar1 + 0x1840) = 0;
  *(void* *)(lVar1 + 0x1848) = 0;
  *(undefined2 *)(lVar1 + 0x1850) = 0x100;
  *(void* *)(lVar1 + 0x1958) = 0;
  *(void* *)(lVar1 + 0x1960) = 0;
  *(uint32_t *)(lVar1 + 0x1988) = 0;
  *(void* *)(lVar1 + 0x1990) = 0;
  *(undefined2 *)(lVar1 + 0x1998) = 0x100;
  *(void* *)(lVar1 + 0x1aa0) = 0;
  *(void* *)(lVar1 + 0x1aa8) = 0;
  *(uint32_t *)(lVar1 + 0x1ad0) = 0;
  *(void* *)(lVar1 + 0x1ad8) = 0;
  *(undefined2 *)(lVar1 + 0x1ae0) = 0x100;
  return;
}




/**
 * @brief 系统资源清理函数
 * 
 * 该函数负责清理系统资源，释放内存和关闭文件句柄
 * 用于游戏退出时的资源回收和系统清理
 * 
 * @param ResourceHandle 资源句柄指针
 */
void CleanupSystemResources(long long *ResourceHandle)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  
  puVar3 = (void* *)*param_1;
  if (puVar3 != (void* *)0x0) {
    if ((void* *)puVar3[3] != (void* *)0x0) {
      *(void* *)puVar3[3] = 0;
    }
    (**(code **)*puVar3)(puVar3,0);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  if ((param_1[6] != 0) && (*(long long *)(param_1[6] + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = param_1[5];
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x141);
    lVar4 = *(long long *)(lVar4 + 0x138);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = (void* *)param_1[3];
  if (puVar3 == (void* *)0x0) {
    return;
  }
  uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
  if (uVar5 != 0) {
    lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
    lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
    if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
      *puVar3 = *(void* *)(lVar4 + 0x20);
      *(void* **)(lVar4 + 0x20) = puVar3;
      piVar1 = (int *)(lVar4 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                          puVar3,uVar5,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_180059ee4(long long *param_1)
void FUN_180059ee4(long long *param_1)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  
  puVar3 = (void* *)*param_1;
  if (puVar3 != (void* *)0x0) {
    if ((void* *)puVar3[3] != (void* *)0x0) {
      *(void* *)puVar3[3] = 0;
    }
    (**(code **)*puVar3)(puVar3,0);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  if ((param_1[6] != 0) && (*(long long *)(param_1[6] + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = param_1[5];
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x141);
    lVar4 = *(long long *)(lVar4 + 0x138);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = (void* *)param_1[3];
  if (puVar3 == (void* *)0x0) {
    return;
  }
  uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
  if (uVar5 != 0) {
    lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
    lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
    if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
      *puVar3 = *(void* *)(lVar4 + 0x20);
      *(void* **)(lVar4 + 0x20) = puVar3;
      piVar1 = (int *)(lVar4 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                          puVar3,uVar5,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_180059ef9(void)
void FUN_180059ef9(void)

{
  void* *unaff_RBX;
  
  if ((void* *)unaff_RBX[3] != (void* *)0x0) {
    *(void* *)unaff_RBX[3] = 0;
  }
  (**(code **)*unaff_RBX)();
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180059f4f(void)
void FUN_180059f4f(void)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  long long unaff_RSI;
  ulong long uVar5;
  
  if ((*(long long *)(unaff_RSI + 0x30) != 0) &&
     (*(long long *)(*(long long *)(unaff_RSI + 0x30) + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = *(long long *)(unaff_RSI + 0x28);
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x141);
    lVar4 = *(long long *)(lVar4 + 0x138);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = *(void* **)(unaff_RSI + 0x18);
  if (puVar3 != (void* *)0x0) {
    uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar5 != 0) {
      lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                            puVar3,uVar5,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_180059fb0(void* *param_1)
void FUN_180059fb0(void* *param_1)

{
  int *piVar1;
  long long lVar2;
  ulong long uVar3;
  
  uVar3 = (ulong long)param_1 & 0xffffffffffc00000;
  if (uVar3 != 0) {
    lVar2 = uVar3 + 0x80 + ((long long)param_1 - uVar3 >> 0x10) * 0x50;
    lVar2 = lVar2 - (ulong long)*(uint *)(lVar2 + 4);
    if ((*(void ***)(uVar3 + 0x70) == &ExceptionList) && (*(char *)(lVar2 + 0xe) == '\0')) {
      *param_1 = *(void* *)(lVar2 + 0x20);
      *(void* **)(lVar2 + 0x20) = param_1;
      piVar1 = (int *)(lVar2 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar3,CONCAT71(0xff000000,*(void ***)(uVar3 + 0x70) == &ExceptionList),
                          param_1,uVar3,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_180059fc0(long long *param_1)
void FUN_180059fc0(long long *param_1)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  puVar3 = (void* *)*param_1;
  if (puVar3 != (void* *)0x0) {
    if ((void* *)puVar3[3] != (void* *)0x0) {
      *(void* *)puVar3[3] = 0;
    }
    (**(code **)*puVar3)(puVar3,0);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  if ((param_1[6] != 0) && (*(long long *)(param_1[6] + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = param_1[5];
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x141);
    lVar4 = *(long long *)(lVar4 + 0x138);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = (void* *)param_1[3];
  if (puVar3 == (void* *)0x0) {
    return;
  }
  uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
  if (uVar5 != 0) {
    lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
    lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
    if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
      *puVar3 = *(void* *)(lVar4 + 0x20);
      *(void* **)(lVar4 + 0x20) = puVar3;
      piVar1 = (int *)(lVar4 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                          puVar3,uVar5,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18005a010(long long param_1)
void FUN_18005a010(long long param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = *(void* **)(param_1 + 0x18);
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18005a050(long long param_1)
void FUN_18005a050(long long param_1)

{
  ulong long uVar1;
  long long lVar2;
  long long lVar3;
  ulong long uVar4;
  
  uVar1 = *(ulong long *)(param_1 + 0x10);
  lVar2 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar1 == 0) {
    *(void* *)(param_1 + 0x18) = 0;
  }
  else {
    do {
      lVar3 = *(long long *)(lVar2 + uVar4 * 8);
      if (lVar3 != 0) {
        if (*(long long *)(lVar3 + 0x18) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar3);
      }
      *(void* *)(lVar2 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar1);
    *(void* *)(param_1 + 0x18) = 0;
  }
  return;
}




// 函数: void FUN_18005a100(long long param_1)
void FUN_18005a100(long long param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  FUN_18005a050();
  if ((1 < *(ulong long *)(param_1 + 0x10)) &&
     (puVar2 = *(void* **)(param_1 + 8), puVar2 != (void* *)0x0)) {
    uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
    if (uVar4 != 0) {
      lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
      lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
      if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
        *puVar2 = *(void* *)(lVar3 + 0x20);
        *(void* **)(lVar3 + 0x20) = puVar2;
        piVar1 = (int *)(lVar3 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                            puVar2,uVar4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_18005a130(long long param_1)
void FUN_18005a130(long long param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  FUN_18005a050();
  if ((1 < *(ulong long *)(param_1 + 0x10)) &&
     (puVar2 = *(void* **)(param_1 + 8), puVar2 != (void* *)0x0)) {
    uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
    if (uVar4 != 0) {
      lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
      lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
      if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
        *puVar2 = *(void* *)(lVar3 + 0x20);
        *(void* **)(lVar3 + 0x20) = puVar2;
        piVar1 = (int *)(lVar3 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                            puVar2,uVar4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_18005a170(long long param_1)
void FUN_18005a170(long long param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  FUN_18005a050();
  if ((1 < *(ulong long *)(param_1 + 0x10)) &&
     (puVar2 = *(void* **)(param_1 + 8), puVar2 != (void* *)0x0)) {
    uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
    if (uVar4 != 0) {
      lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
      lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
      if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
        *puVar2 = *(void* *)(lVar3 + 0x20);
        *(void* **)(lVar3 + 0x20) = puVar2;
        piVar1 = (int *)(lVar3 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                            puVar2,uVar4,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}



void* FUN_18005a1b0(void* param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  FUN_180049470();
  if ((param_2 & 1) != 0) {
    free(param_1,0xc0,param_3,param_4,uVar1);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005a200(void* *param_1)
void FUN_18005a200(void* *param_1)

{
  ulong long uVar1;
  void* uVar2;
  ulong long uVar3;
  ulong long uVar4;
  void* *puVar5;
  long long lVar6;
  void** systemCurrentNode;
  long long lVar8;
  
  uVar3 = 0;
  *param_1 = 0;
  *(uint32_t *)(param_1 + 1) = 0;
  param_1[2] = 0;
  param_1[5] = 0;
  puVar5 = param_1 + 0xb;
  lVar8 = 0x20;
  lVar6 = 0x20;
  systemPreviousNode = puVar5;
  do {
    func_0x000180059bb0(systemPreviousNode);
    systemPreviousNode = systemPreviousNode + 2;
    lVar6 = lVar6 + -1;
  } while (lVar6 != 0);
  *(void* *)((long long)param_1 + 0x25c) = 0;
  *(uint32_t *)(param_1 + 0x4b) = 0;
  param_1[7] = 0;
  param_1[8] = 0x20;
  param_1[9] = puVar5;
  do {
    *(uint32_t *)puVar5 = 0;
    puVar5 = puVar5 + 2;
    lVar8 = lVar8 + -1;
  } while (lVar8 != 0);
  param_1[10] = 0;
  param_1[6] = param_1 + 8;
  param_1[4] = 0x15;
  lVar6 = FUN_180059bc0();
  param_1[3] = lVar6;
  if (lVar6 == 0) {
    param_1[4] = 0;
    uVar1 = uVar3;
  }
  else {
    uVar1 = param_1[4];
  }
  uVar4 = uVar3;
  if (uVar1 != 0) {
    do {
      *(uint8_t *)(uVar4 + 0x141 + param_1[3]) = 0;
      uVar3 = uVar3 + 1;
      uVar4 = uVar4 + 0x148;
    } while (uVar3 < (ulong long)param_1[4]);
  }
  _Cnd_init_in_situ();
  _Mtx_init_in_situ(param_1 + 0x56,2);
  param_1[0x60] = 0;
  param_1[0x61] = 0;
  param_1[0x62] = 0;
  *(uint32_t *)(param_1 + 99) = 3;
  param_1[0x65] = 0;
  *(uint32_t *)(param_1 + 0x6a) = 0x3f800000;
  *(void* *)((long long)param_1 + 0x354) = 0x40000000;
  *(uint32_t *)((long long)param_1 + 0x35c) = 3;
  param_1[0x68] = 1;
  param_1[0x67] = &DAT_180be0000;
  param_1[0x69] = 0;
  *(uint32_t *)(param_1 + 0x6b) = 0;
  uVar2 = FUN_18062b1e0(_DAT_180c8ed18,0xc0,8,4);
                    // WARNING: Subroutine does not return
  memset(uVar2,0,0xc0);
}



void* * FUN_18005a420(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fdd78;
  FUN_18005b7c0(param_1 + 0xa4);
  FUN_18005b960(param_1 + 0x8c);
  FUN_18005b7c0(param_1 + 0x7e);
  FUN_18005b7c0(param_1 + 0x70);
  FUN_18005b7c0(param_1 + 0x62);
  FUN_18005b7c0(param_1 + 0x54);
  FUN_18005b7c0(param_1 + 0x46);
  FUN_18005b7c0(param_1 + 0x38);
  FUN_18005b7c0(param_1 + 0x2a);
  FUN_18005b7c0(param_1 + 0x1c);
  FUN_1800ae640(param_1);
  if ((param_2 & 1) != 0) {
    free(param_1,0x590);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005a500(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005a500(void* param_1,void* param_2,void* param_3,void* param_4)

{
  uint32_t uVar1;
  void** systemDataTable;
  undefined *puStack_50;
  void* *puStack_48;
  uint32_t uStack_40;
  void* uStack_38;
  
  puStack_50 = &SystemGlobalDataReference;
  uStack_38 = 0;
  puStack_48 = (void* *)0x0;
  uStack_40 = 0;
  puVar2 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13,param_4,0xfffffffffffffffe);
  *(uint8_t *)puVar2 = 0;
  puStack_48 = puVar2;
  uVar1 = StartSystemThread(puVar2);
  uStack_38 = CONCAT44(uStack_38._4_4_,uVar1);
  *puVar2 = 0x6320726f74696445;
  *(uint32_t *)(puVar2 + 1) = 0x69666e6f;
  *(undefined2 *)((long long)puVar2 + 0xc) = 0x67;
  uStack_40 = 0xd;
  FUN_1800ae520(param_1,&puStack_50);
  puStack_50 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar2);
}



void* FUN_18005a960(void* param_1,ulong long param_2)

{
  FUN_18005a9a0();
  if ((param_2 & 1) != 0) {
    free(param_1,0xa90);
  }
  return param_1;
}




// 函数: void FUN_18005a9a0(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005a9a0(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_1809fddc8;
  FUN_18005ab50(param_1 + 0x143);
  FUN_18005ab50(param_1 + 0x134);
  FUN_18005b7c0(param_1 + 0x126);
  FUN_18005b7c0(param_1 + 0x118);
  FUN_18005b7c0(param_1 + 0x10a);
  FUN_18005b7c0(param_1 + 0xfc);
  FUN_18005b7c0(param_1 + 0xee);
  FUN_18005b7c0(param_1 + 0xe0);
  FUN_18005b7c0(param_1 + 0xd2);
  FUN_18005b7c0(param_1 + 0xc4);
  FUN_18005b7c0(param_1 + 0xb6);
  FUN_18005b7c0(param_1 + 0xa8);
  FUN_18005b7c0(param_1 + 0x9a);
  FUN_18005b7c0(param_1 + 0x8c);
  FUN_18005b7c0(param_1 + 0x7e);
  FUN_18005b7c0(param_1 + 0x70);
  FUN_18005b7c0(param_1 + 0x62);
  FUN_18005b7c0(param_1 + 0x54);
  FUN_18005b7c0(param_1 + 0x46);
  FUN_18005b7c0(param_1 + 0x38);
  FUN_18005b7c0(param_1 + 0x2a);
  FUN_18005b7c0(param_1 + 0x1c);
  *param_1 = &UNK_180a02968;
  param_1[0x18] = &SystemGlobalDataReference;
  if (param_1[0x19] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x19] = 0;
  *(uint32_t *)(param_1 + 0x1b) = 0;
  param_1[0x18] = &SystemMemoryAllocatorReference;
  FUN_18005d260(param_1 + 0x12,param_1[0x14],param_3,param_4,0xfffffffffffffffe);
  if (param_1[0xd] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}




// 函数: void FUN_18005aaf0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005aaf0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0x10) != (code *)0x0) {
    (**(code **)(param_1 + 0x10))(param_1,0,0,param_4,0xfffffffffffffffe);
  }
  return;
}




// 函数: void FUN_18005ab20(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005ab20(long long param_1,void* param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0x10) != (code *)0x0) {
    (**(code **)(param_1 + 0x10))(param_1,0,0,param_4,0xfffffffffffffffe);
  }
  return;
}




// 函数: void FUN_18005ab50(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005ab50(long long param_1,void* param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0x68) != (code *)0x0) {
    (**(code **)(param_1 + 0x68))(param_1 + 0x58,0,0,param_4,0xfffffffffffffffe);
  }
  *(void* *)(param_1 + 0x30) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x38) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x38) = 0;
  *(uint32_t *)(param_1 + 0x48) = 0;
  *(void* *)(param_1 + 0x30) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x10) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x18) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x18) = 0;
  *(uint32_t *)(param_1 + 0x28) = 0;
  *(void* *)(param_1 + 0x10) = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005ac00(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005ac00(void* param_1,void* param_2,void* param_3,void* param_4)

{
  uint32_t uVar1;
  uint32_t *puVar2;
  undefined *puStack_50;
  uint32_t *puStack_48;
  uint32_t uStack_40;
  void* uStack_38;
  
  puStack_50 = &SystemGlobalDataReference;
  uStack_38 = 0;
  puStack_48 = (uint32_t *)0x0;
  uStack_40 = 0;
  puVar2 = (uint32_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x13,0x13,param_4,0xfffffffffffffffe);
  *(uint8_t *)puVar2 = 0;
  puStack_48 = puVar2;
  uVar1 = StartSystemThread(puVar2);
  uStack_38 = CONCAT44(uStack_38._4_4_,uVar1);
  *puVar2 = 0x65766544;
  puVar2[1] = 0x6d706f6c;
  puVar2[2] = 0x20746e65;
  puVar2[3] = 0x666e6f63;
  *(undefined2 *)(puVar2 + 4) = 0x6769;
  *(uint8_t *)((long long)puVar2 + 0x12) = 0;
  uStack_40 = 0x12;
  FUN_1800ae520(param_1,&puStack_50);
  puStack_50 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar2);
}



void* FUN_18005b520(void* param_1,ulong long param_2)

{
  FUN_18005b560();
  if ((param_2 & 1) != 0) {
    free(param_1,0x13c0);
  }
  return param_1;
}




// 函数: void FUN_18005b560(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005b560(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_1809fde10;
  FUN_18005d580();
  FUN_18005d580();
  FUN_18005b7c0(param_1 + 0x262);
  FUN_18005b7c0(param_1 + 0x254);
  FUN_18005b7c0(param_1 + 0x246);
  FUN_18005b7c0(param_1 + 0x238);
  FUN_18005b7c0(param_1 + 0x22a);
  FUN_18005b7c0(param_1 + 0x21c);
  FUN_18005b7c0(param_1 + 0x20e);
  FUN_18005b960(param_1 + 0x1f6);
  FUN_18005b960(param_1 + 0x1de);
  FUN_18005b960(param_1 + 0x1c6);
  FUN_18005b7c0(param_1 + 0x1b8);
  FUN_18005b7c0(param_1 + 0x1aa);
  FUN_18005b7c0(param_1 + 0x19c);
  FUN_18005b960(param_1 + 0x184);
  FUN_18005b960(param_1 + 0x16c);
  FUN_18005b960(param_1 + 0x154);
  FUN_18005b960(param_1 + 0x13c);
  FUN_18005b960(param_1 + 0x124);
  FUN_18005b960(param_1 + 0x10c);
  FUN_18005b960(param_1 + 0xf4);
  FUN_18005b960(param_1 + 0xdc);
  FUN_18005b960(param_1 + 0xc4);
  FUN_18005b960(param_1 + 0xac);
  FUN_18005b960(param_1 + 0x94);
  FUN_18005b960(param_1 + 0x7c);
  FUN_18005b960(param_1 + 100);
  FUN_18005b960(param_1 + 0x4c);
  FUN_18005b960(param_1 + 0x34);
  FUN_18005b960(param_1 + 0x1c);
  *param_1 = &UNK_180a02968;
  param_1[0x18] = &SystemGlobalDataReference;
  if (param_1[0x19] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x19] = 0;
  *(uint32_t *)(param_1 + 0x1b) = 0;
  param_1[0x18] = &SystemMemoryAllocatorReference;
  FUN_18005d260(param_1 + 0x12,param_1[0x14],param_3,param_4,0xfffffffffffffffe);
  if (param_1[0xd] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



long long FUN_18005b730(long long param_1)

{
  *(void* *)(param_1 + 8) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  *(void* *)(param_1 + 8) = &SystemGlobalDataReference;
  *(void* *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  *(void* *)(param_1 + 0x28) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x30) = 0;
  *(uint32_t *)(param_1 + 0x38) = 0;
  *(void* *)(param_1 + 0x28) = &SystemGlobalDataReference;
  *(void* *)(param_1 + 0x40) = 0;
  *(void* *)(param_1 + 0x30) = 0;
  *(uint32_t *)(param_1 + 0x38) = 0;
  *(void* *)(param_1 + 0x60) = 0;
  *(code **)(param_1 + 0x68) = _guard_check_icall;
  return param_1;
}




// 函数: void FUN_18005b7c0(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005b7c0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0x60) != (code *)0x0) {
    (**(code **)(param_1 + 0x60))(param_1 + 0x50,0,0,param_4,0xfffffffffffffffe);
  }
  *(void* *)(param_1 + 0x28) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x30) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x30) = 0;
  *(uint32_t *)(param_1 + 0x40) = 0;
  *(void* *)(param_1 + 0x28) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 8) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 8) = &SystemMemoryAllocatorReference;
  return;
}



void* * FUN_18005b870(void* *param_1)

{
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &SystemGlobalDataReference;
  param_1[3] = 0;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 6) = 0;
  param_1[4] = &SystemGlobalDataReference;
  param_1[7] = 0;
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 6) = 0;
  param_1[8] = &SystemMemoryAllocatorReference;
  param_1[9] = 0;
  *(uint32_t *)(param_1 + 10) = 0;
  param_1[8] = &SystemGlobalDataReference;
  param_1[0xb] = 0;
  param_1[9] = 0;
  *(uint32_t *)(param_1 + 10) = 0;
  param_1[0xc] = &SystemMemoryAllocatorReference;
  param_1[0xd] = 0;
  *(uint32_t *)(param_1 + 0xe) = 0;
  param_1[0xc] = &SystemGlobalDataReference;
  param_1[0xf] = 0;
  param_1[0xd] = 0;
  *(uint32_t *)(param_1 + 0xe) = 0;
  param_1[0x10] = &SystemMemoryAllocatorReference;
  param_1[0x11] = 0;
  *(uint32_t *)(param_1 + 0x12) = 0;
  param_1[0x10] = &SystemGlobalDataReference;
  param_1[0x13] = 0;
  param_1[0x11] = 0;
  *(uint32_t *)(param_1 + 0x12) = 0;
  param_1[0x16] = 0;
  param_1[0x17] = _guard_check_icall;
  return param_1;
}




// 函数: void FUN_18005b960(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005b960(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  if ((code *)param_1[0x16] != (code *)0x0) {
    (*(code *)param_1[0x16])(param_1 + 0x14,0,0,param_4,0xfffffffffffffffe);
  }
  param_1[0x10] = &SystemGlobalDataReference;
  if (param_1[0x11] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x11] = 0;
  *(uint32_t *)(param_1 + 0x13) = 0;
  param_1[0x10] = &SystemMemoryAllocatorReference;
  param_1[0xc] = &SystemGlobalDataReference;
  if (param_1[0xd] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0xd] = 0;
  *(uint32_t *)(param_1 + 0xf) = 0;
  param_1[0xc] = &SystemMemoryAllocatorReference;
  param_1[8] = &SystemGlobalDataReference;
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[9] = 0;
  *(uint32_t *)(param_1 + 0xb) = 0;
  param_1[8] = &SystemMemoryAllocatorReference;
  param_1[4] = &SystemGlobalDataReference;
  if (param_1[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 7) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005ba80(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005ba80(void* param_1,void* param_2,void* param_3,void* param_4)

{
  uint32_t uVar1;
  void** systemDataTable;
  undefined *puStack_50;
  void* *puStack_48;
  uint32_t uStack_40;
  void* uStack_38;
  
  puStack_50 = &SystemGlobalDataReference;
  uStack_38 = 0;
  puStack_48 = (void* *)0x0;
  uStack_40 = 0;
  puVar2 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13,param_4,0xfffffffffffffffe);
  *(uint8_t *)puVar2 = 0;
  puStack_48 = puVar2;
  uVar1 = StartSystemThread(puVar2);
  uStack_38 = CONCAT44(uStack_38._4_4_,uVar1);
  *puVar2 = 0x6e6f632072657355;
  *(uint32_t *)(puVar2 + 1) = 0x676966;
  uStack_40 = 0xb;
  FUN_1800ae520(param_1,&puStack_50);
  puStack_50 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar2);
}



void* * FUN_18005c060(void* *param_1)

{
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 3) = 0x24;
  return param_1;
}



long long FUN_18005c090(long long param_1)

{
  long long lVar1;
  long long lVar2;
  
  FUN_1808fc838(param_1,0x20,0x400,FUN_18005c060,FUN_180046860);
  FUN_1808fc838(param_1 + 0x8000,0x20,0x400,FUN_18005c060,FUN_180046860);
  *(void* *)(param_1 + 0x10400) = 0;
  *(void* *)(param_1 + 0x10408) = 0;
  *(void* *)(param_1 + 0x10410) = 0;
  *(uint32_t *)(param_1 + 0x10418) = 0x24;
  lVar1 = param_1 + 0x10002;
  lVar2 = 8;
  do {
    *(void* *)(lVar1 + -2) = 0;
    *(void* *)(lVar1 + 6) = 0;
    *(void* *)(lVar1 + 0xe) = 0;
    *(void* *)(lVar1 + 0x16) = 0;
    *(void* *)(lVar1 + 0x1e) = 0;
    *(void* *)(lVar1 + 0x26) = 0;
    *(void* *)(lVar1 + 0x2e) = 0;
    *(void* *)(lVar1 + 0x36) = 0;
    *(void* *)(lVar1 + 0x3e) = 0;
    *(void* *)(lVar1 + 0x46) = 0;
    *(void* *)(lVar1 + 0x4e) = 0;
    *(void* *)(lVar1 + 0x56) = 0;
    *(void* *)(lVar1 + 0x5e) = 0;
    *(void* *)(lVar1 + 0x66) = 0;
    *(void* *)(lVar1 + 0x6e) = 0;
    *(void* *)(lVar1 + 0x76) = 0;
    lVar1 = lVar1 + 0x80;
    lVar2 = lVar2 + -1;
  } while (lVar2 != 0);
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void*
FUN_18005c1c0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_180627ae0(param_2,_DAT_180c86928 + 0xe0,param_3,param_4,0,0xfffffffffffffffe);
  return param_2;
}



void* * FUN_18005c210(void* *param_1,uint param_2,void* param_3,void* param_4)

{
  if ((code *)param_1[6] != (code *)0x0) {
    (*(code *)param_1[6])(param_1 + 4,0,0,param_4,0xfffffffffffffffe);
  }
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0x40);
  }
  return param_1;
}



void* *
FUN_18005c2a0(void* *param_1,void* *param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  code *pcVar2;
  
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_18098bdc8;
  LOCK();
  *(uint8_t *)(param_1 + 2) = 0;
  UNLOCK();
  param_1[3] = 0xffffffffffffffff;
  *param_1 = &UNK_1809fdea8;
  puVar1 = param_1 + 4;
  param_1[6] = 0;
  param_1[7] = _guard_check_icall;
  if (puVar1 != param_2) {
    if ((code *)param_1[6] != (code *)0x0) {
      (*(code *)param_1[6])(puVar1,0,0,param_4,0xfffffffffffffffe);
    }
    pcVar2 = (code *)param_2[2];
    if (pcVar2 != (code *)0x0) {
      (*pcVar2)(puVar1,param_2,1);
      pcVar2 = (code *)param_2[2];
    }
    param_1[6] = pcVar2;
    param_1[7] = param_2[3];
  }
  if ((code *)param_2[2] != (code *)0x0) {
    (*(code *)param_2[2])(param_2,0,0);
  }
  return param_1;
}




// 函数: void FUN_18005c380(long long param_1)
void FUN_18005c380(long long param_1)

{
  *(void* *)(param_1 + 0x18) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x20) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x20) = 0;
  *(uint32_t *)(param_1 + 0x30) = 0;
  *(void* *)(param_1 + 0x18) = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_18005c3d0(long long *param_1)
void FUN_18005c3d0(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  lVar2 = *param_1;
  if (lVar2 == lVar1) {
    param_1[1] = lVar2;
  }
  else {
    do {
      *(void* *)(lVar2 + 0x18) = &SystemGlobalDataReference;
      if (*(long long *)(lVar2 + 0x20) != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(lVar2 + 0x20) = 0;
      *(uint32_t *)(lVar2 + 0x30) = 0;
      *(void* *)(lVar2 + 0x18) = &SystemMemoryAllocatorReference;
      lVar2 = lVar2 + 0x50;
    } while (lVar2 != lVar1);
    param_1[1] = *param_1;
  }
  return;
}



long long FUN_18005c4f0(long long param_1,uint param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0xd0) != (code *)0x0) {
    (**(code **)(param_1 + 0xd0))(param_1 + 0xc0,0,0,param_4,0xfffffffffffffffe);
  }
  FUN_180049470(param_1);
  if ((param_2 & 1) != 0) {
    free(param_1,0xe8);
  }
  return param_1;
}




// 函数: void FUN_18005c560(long long param_1)
void FUN_18005c560(long long param_1)

{
  long long lVar1;
  int iVar2;
  
  (**(code **)(param_1 + 0xd8))(param_1 + 0xc0);
  lVar1 = *(long long *)(param_1 + 0xe0);
  iVar2 = _Mtx_lock(lVar1 + 0x48);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  *(uint8_t *)(lVar1 + 0x98) = 1;
  iVar2 = _Cnd_broadcast(lVar1);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  iVar2 = _Mtx_unlock(lVar1 + 0x48);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  return;
}



void* *
FUN_18005c590(void* *param_1,void* *param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  code *pcVar2;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  FUN_180049830();
  *param_1 = &UNK_1809fdf38;
  puVar1 = param_1 + 0x18;
  param_1[0x1a] = 0;
  param_1[0x1b] = _guard_check_icall;
  if (puVar1 != param_2) {
    if ((code *)param_1[0x1a] != (code *)0x0) {
      (*(code *)param_1[0x1a])(puVar1,0,0,param_4,uVar3);
    }
    pcVar2 = (code *)param_2[2];
    if (pcVar2 != (code *)0x0) {
      (*pcVar2)(puVar1,param_2,1);
      pcVar2 = (code *)param_2[2];
    }
    param_1[0x1a] = pcVar2;
    param_1[0x1b] = param_2[3];
  }
  param_1[0x1c] = param_3;
  if ((code *)param_2[2] != (code *)0x0) {
    (*(code *)param_2[2])(param_2,0,0);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005c650(long long *param_1)
void FUN_18005c650(long long *param_1)

{
  int iVar1;
  long long lVar2;
  int memoryCompareResult;
  void* uVar4;
  long long *plVar5;
  code *pcVar6;
  uint8_t auStack_128 [32];
  long long *plStack_108;
  long long **pplStack_100;
  long long alStack_f8 [2];
  code *pcStack_e8;
  code *pcStack_e0;
  void* uStack_d8;
  long long *plStack_d0;
  long long *plStack_c8;
  long long alStack_b8 [9];
  long long alStack_70 [10];
  uint8_t uStack_20;
  ulong long uStack_18;
  
  uStack_d8 = 0xfffffffffffffffe;
  uStack_18 = _DAT_180bf00a8 ^ (ulong long)auStack_128;
  iVar1 = *(int *)(*(long long *)(*(long long *)(_DAT_180c82868 + 8) + 8) + 0x48);
  plStack_d0 = param_1;
  iVar3 = _Thrd_id();
  if (iVar3 == iVar1) {
    (*(code *)param_1[3])(param_1);
  }
  else {
    plStack_108 = alStack_b8;
    _Cnd_init_in_situ(alStack_b8);
    plStack_108 = alStack_70;
    _Mtx_init_in_situ(alStack_70,2);
    uStack_20 = 0;
    uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0xe8,8,3);
    plStack_108 = alStack_f8;
    pcStack_e8 = (code *)0x0;
    pcStack_e0 = _guard_check_icall;
    if (alStack_f8 != param_1) {
      pcVar6 = (code *)param_1[2];
      if (pcVar6 != (code *)0x0) {
        (*pcVar6)(alStack_f8,param_1,1);
        pcVar6 = (code *)param_1[2];
      }
      pcStack_e0 = (code *)param_1[3];
      pcStack_e8 = pcVar6;
    }
    plVar5 = (long long *)FUN_18005c590(uVar4,alStack_f8,alStack_b8);
    plStack_c8 = plVar5;
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x28))(plVar5);
    }
    lVar2 = _DAT_180c82868;
    pplStack_100 = &plStack_108;
    plStack_108 = plVar5;
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x28))(plVar5);
    }
    FUN_18005e370(lVar2,&plStack_108);
    FUN_180046190(alStack_b8);
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x38))(plVar5);
    }
    pplStack_100 = (long long **)alStack_70;
    _Mtx_destroy_in_situ(alStack_70);
    pplStack_100 = (long long **)alStack_b8;
    _Cnd_destroy_in_situ(alStack_b8);
  }
  if ((code *)param_1[2] != (code *)0x0) {
    (*(code *)param_1[2])(param_1,0,0);
  }
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_18 ^ (ulong long)auStack_128);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005c830(uint *param_1)
void FUN_18005c830(uint *param_1)

{
  uint uVar1;
  char cVar2;
  
  if (*(undefined **)*_DAT_180c8ed08 == &UNK_18098bb88) {
    cVar2 = *(int *)(_DAT_180c8a9c8 + 0xe0) != 0;
  }
  else {
    cVar2 = (**(code **)(*(undefined **)*_DAT_180c8ed08 + 0x48))();
  }
  if (cVar2 != '\0') {
    *param_1 = 0x41c6fe0c;
    return;
  }
  uVar1 = timeGetTime();
  *param_1 = uVar1 ^ 0x41c64e6d;
  return;
}



void* FUN_18005c8a0(long long param_1,void* param_2)

{
  char systemNodeFlag;
  undefined *puVar2;
  
  if (*(long long *)(param_1 + 0xb0) != 0) {
    cVar1 = (**(code **)(param_1 + 0xb8))(param_2);
    if (cVar1 == '\0') {
      if (DAT_180c82860 == '\0') {
        puVar2 = &SystemStringTemplate;
        if (*(undefined **)(param_1 + 0x48) != (undefined *)0x0) {
          puVar2 = *(undefined **)(param_1 + 0x48);
        }
        FUN_180626f80(&UNK_18098bc00,puVar2);
      }
      FUN_180627be0(param_1,param_1 + 0x80);
      return 0;
    }
  }
  FUN_180627be0(param_1,param_2);
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005c930(void* *param_1,void* param_2,int *param_3)
void FUN_18005c930(void* *param_1,void* param_2,int *param_3)

{
  int iVar1;
  bool bVar2;
  void* *puVar3;
  long long lVar4;
  void* *puVar5;
  void* uVar6;
  
  lVar4 = CreateSystemThreadObject(_DAT_180c8ed18,0x28,*(uint8_t *)(param_1 + 5));
  iVar1 = *param_3;
  bVar2 = true;
  *(int *)(lVar4 + 0x20) = iVar1;
  puVar5 = (void* *)param_1[2];
  puVar3 = param_1;
  while (puVar5 != (void* *)0x0) {
    bVar2 = iVar1 < *(int *)(puVar5 + 4);
    puVar3 = puVar5;
    if (iVar1 < *(int *)(puVar5 + 4)) {
      puVar5 = (void* *)puVar5[1];
    }
    else {
      puVar5 = (void* *)*puVar5;
    }
  }
  puVar5 = puVar3;
  if (bVar2) {
    if (puVar3 == (void* *)param_1[1]) goto LAB_18005c9be;
    puVar5 = (void* *)func_0x00018066b9a0(puVar3);
  }
  if (*(int *)(lVar4 + 0x20) <= *(int *)(puVar5 + 4)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar4);
  }
LAB_18005c9be:
  if ((puVar3 == param_1) || (*(int *)(lVar4 + 0x20) < *(int *)(puVar3 + 4))) {
    uVar6 = 0;
  }
  else {
    uVar6 = 1;
  }
                    // WARNING: Subroutine does not return
  FUN_18066bdc0(lVar4,puVar3,param_1,uVar6);
}




// 函数: void FUN_18005ca20(long long param_1,uint32_t param_2)
void FUN_18005ca20(long long param_1,uint32_t param_2)

{
  char systemNodeFlag;
  undefined *puVar2;
  uint32_t auStackX_10 [6];
  
  if ((*(long long *)(param_1 + 0x1f00) != 0) &&
     (auStackX_10[0] = param_2, cVar1 = (**(code **)(param_1 + 0x1f08))(auStackX_10),
     param_2 = auStackX_10[0], cVar1 == '\0')) {
    if (DAT_180c82860 == '\0') {
      puVar2 = &SystemStringTemplate;
      if (*(undefined **)(param_1 + 0x1eb0) != (undefined *)0x0) {
        puVar2 = *(undefined **)(param_1 + 0x1eb0);
      }
      FUN_180626f80(&UNK_18098bc00,puVar2);
    }
    *(uint32_t *)(param_1 + 0x1ea0) = *(uint32_t *)(param_1 + 0x1ee8);
    return;
  }
  *(uint32_t *)(param_1 + 0x1ea0) = param_2;
  return;
}



void* * FUN_18005caa0(void* *param_1,long long param_2)

{
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &SystemGlobalDataReference;
  param_1[3] = 0;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint32_t *)(param_1 + 2) = *(uint32_t *)(param_2 + 0x10);
  param_1[1] = *(void* *)(param_2 + 8);
  *(uint32_t *)((long long)param_1 + 0x1c) = *(uint32_t *)(param_2 + 0x1c);
  *(uint32_t *)(param_1 + 3) = *(uint32_t *)(param_2 + 0x18);
  *(uint32_t *)(param_2 + 0x10) = 0;
  *(void* *)(param_2 + 8) = 0;
  *(void* *)(param_2 + 0x18) = 0;
  param_1[4] = &SystemMemoryAllocatorReference;
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 6) = 0;
  param_1[4] = &SystemGlobalDataReference;
  param_1[7] = 0;
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 6) = 0;
  *(uint32_t *)(param_1 + 6) = *(uint32_t *)(param_2 + 0x30);
  param_1[5] = *(void* *)(param_2 + 0x28);
  *(uint32_t *)((long long)param_1 + 0x3c) = *(uint32_t *)(param_2 + 0x3c);
  *(uint32_t *)(param_1 + 7) = *(uint32_t *)(param_2 + 0x38);
  *(uint32_t *)(param_2 + 0x30) = 0;
  *(void* *)(param_2 + 0x28) = 0;
  *(void* *)(param_2 + 0x38) = 0;
  return param_1;
}



long long FUN_18005cb60(long long param_1)

{
  *(void* *)(param_1 + 0x40) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x48) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x48) = 0;
  *(uint32_t *)(param_1 + 0x58) = 0;
  *(void* *)(param_1 + 0x40) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x28) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x28) = 0;
  *(uint32_t *)(param_1 + 0x38) = 0;
  *(void* *)(param_1 + 0x20) = &SystemMemoryAllocatorReference;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005cc00(undefined **param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005cc00(undefined **param_1,void* param_2,void* param_3,void* param_4)

{
  byte bVar1;
  uint uVar2;
  long long lVar3;
  undefined **ppuVar4;
  byte *pbVar5;
  undefined **ppuVar6;
  long long lVar7;
  void* uVar8;
  undefined **ppuStackX_8;
  char acStackX_20 [8];
  uint32_t uVar9;
  undefined *puStack_68;
  long long lStack_60;
  undefined *puStack_48;
  long long lStack_40;
  uint32_t uStack_30;
  
  lVar3 = _DAT_180c8a9a0;
  acStackX_20[0] = (char)param_4;
  uVar8 = 0;
  ppuVar6 = (undefined **)(_DAT_180c8a9a0 + 0x70);
  ppuStackX_8 = param_1;
  FUN_180058080(ppuVar6,&ppuStackX_8,param_2,param_4,0,0xfffffffffffffffe);
  if (ppuStackX_8 != ppuVar6) {
    FUN_180627be0(ppuStackX_8 + 8,param_3);
    return;
  }
  FUN_180627ae0(&puStack_68,param_2);
  FUN_180627ae0(&puStack_48,param_3);
  uVar9 = 1;
  lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,0x60,*(uint8_t *)(lVar3 + 0x98));
  FUN_18005caa0(lVar3 + 0x20,&puStack_68);
  ppuVar4 = (undefined **)FUN_1800590b0(ppuVar6,acStackX_20,lVar3 + 0x20);
  if (acStackX_20[0] == '\0') {
    FUN_18005cb60(lVar3);
    if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar3);
    }
    ppuStackX_8 = &puStack_48;
    puStack_48 = &SystemGlobalDataReference;
    if (lStack_40 == 0) {
      lStack_40 = 0;
      uStack_30 = 0;
      puStack_48 = &SystemMemoryAllocatorReference;
      ppuStackX_8 = &puStack_68;
      puStack_68 = &SystemGlobalDataReference;
      if (lStack_60 == 0) {
        return;
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (ppuVar4 == ppuVar6) goto LAB_18005ccff;
  if (*(int *)(ppuVar4 + 6) != 0) {
    if (*(int *)(lVar3 + 0x30) == 0) goto LAB_18005ccff;
    pbVar5 = ppuVar4[5];
    lVar7 = *(long long *)(lVar3 + 0x28) - (long long)pbVar5;
    do {
      bVar1 = *pbVar5;
      uVar2 = (uint)pbVar5[lVar7];
      if (bVar1 != uVar2) break;
      pbVar5 = pbVar5 + 1;
    } while (uVar2 != 0);
    if (0 < (int)(bVar1 - uVar2)) goto LAB_18005ccff;
  }
  uVar8 = 1;
LAB_18005ccff:
                    // WARNING: Subroutine does not return
  FUN_18066bdc0(lVar3,ppuVar4,ppuVar6,uVar8,uVar9);
}



void* *
FUN_18005cdb0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  param_1[4] = &SystemMemoryAllocatorReference;
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0x100,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}



void* * FUN_18005ce30(void* *param_1,void* *param_2)

{
  void* *puVar1;
  void* uVar2;
  
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_18098bdc8;
  LOCK();
  *(uint8_t *)(param_1 + 2) = 0;
  UNLOCK();
  param_1[3] = 0xffffffffffffffff;
  *param_1 = &UNK_1809fdfd0;
  puVar1 = param_1 + 4;
  *puVar1 = &SystemMemoryAllocatorReference;
  param_1[5] = 0;
  *(uint32_t *)(param_1 + 6) = 0;
  *puVar1 = &UNK_1809fcc28;
  param_1[5] = param_1 + 7;
  *(uint32_t *)(param_1 + 6) = 0;
  *(uint8_t *)(param_1 + 7) = 0;
  uVar2 = param_2[1];
  *puVar1 = *param_2;
  param_1[5] = uVar2;
  uVar2 = param_2[3];
  param_1[6] = param_2[2];
  param_1[7] = uVar2;
  uVar2 = param_2[5];
  param_1[8] = param_2[4];
  param_1[9] = uVar2;
  uVar2 = param_2[7];
  param_1[10] = param_2[6];
  param_1[0xb] = uVar2;
  uVar2 = param_2[9];
  param_1[0xc] = param_2[8];
  param_1[0xd] = uVar2;
  uVar2 = param_2[0xb];
  param_1[0xe] = param_2[10];
  param_1[0xf] = uVar2;
  uVar2 = param_2[0xd];
  param_1[0x10] = param_2[0xc];
  param_1[0x11] = uVar2;
  uVar2 = param_2[0xf];
  param_1[0x12] = param_2[0xe];
  param_1[0x13] = uVar2;
  uVar2 = param_2[0x11];
  param_1[0x14] = param_2[0x10];
  param_1[0x15] = uVar2;
  uVar2 = param_2[0x13];
  param_1[0x16] = param_2[0x12];
  param_1[0x17] = uVar2;
  uVar2 = param_2[0x15];
  param_1[0x18] = param_2[0x14];
  param_1[0x19] = uVar2;
  uVar2 = param_2[0x17];
  param_1[0x1a] = param_2[0x16];
  param_1[0x1b] = uVar2;
  uVar2 = param_2[0x19];
  param_1[0x1c] = param_2[0x18];
  param_1[0x1d] = uVar2;
  uVar2 = param_2[0x1b];
  param_1[0x1e] = param_2[0x1a];
  param_1[0x1f] = uVar2;
  *(uint32_t *)(param_1 + 0x17) = *(uint32_t *)(param_2 + 0x13);
  return param_1;
}



uint32_t FUN_18005cf50(long long param_1)

{
  int iVar1;
  uint32_t uVar2;
  
  iVar1 = _Mtx_lock(param_1 + 0x9f0);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  uVar2 = FUN_1800b2bd0();
  iVar1 = _Mtx_unlock(param_1 + 0x9f0);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_18005cfc0(void)

{
  long long lVar1;
  long long lVar2;
  int memoryCompareResult;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  lVar2 = _DAT_180c86930;
  lVar1 = _DAT_180c86930 + 0x770;
  iVar3 = _Mtx_lock(lVar1);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  iVar3 = FUN_1800b2bd0();
  iVar4 = _Mtx_unlock(lVar1);
  if (iVar4 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar4);
  }
  iVar4 = _Mtx_lock(lVar2 + 0x7c0);
  if (iVar4 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar4);
  }
  iVar4 = FUN_1800b2bd0();
  iVar5 = _Mtx_unlock(lVar2 + 0x7c0);
  if (iVar5 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar5);
  }
  iVar5 = FUN_18005cf50(lVar2);
  iVar6 = _Mtx_lock(lVar2 + 0x950);
  if (iVar6 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar6);
  }
  iVar6 = FUN_1800b2bd0();
  iVar7 = _Mtx_unlock(lVar2 + 0x950);
  if (iVar7 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar7);
  }
  return iVar6 + iVar4 + iVar3 + iVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005d0e0(ulong long param_1,long long param_2)
void FUN_18005d0e0(ulong long param_1,long long param_2)

{
  char systemNodeFlag;
  uint uVar2;
  ulong long uVar3;
  ulong long *puVar4;
  long long systemTimeValue;
  long long lVar6;
  int iVar7;
  int iVar8;
  float fVar9;
  float fVar10;
  double dStackX_18;
  ulong long uStackX_20;
  uint8_t auStack_478 [32];
  void* uStack_458;
  double *pdStack_450;
  char acStack_438 [1024];
  ulong long uStack_38;
  void* uStack_30;
  
  iVar7 = -1;
  iVar8 = -1;
  uVar2 = (uint)param_1;
  uVar3 = param_1 & 0xffffffff;
  while (uVar2 != 0) {
    iVar8 = iVar8 + 1;
    uVar2 = (uint)uVar3 >> 1;
    uVar3 = (ulong long)uVar2;
  }
  uVar2 = 0x400;
  do {
    iVar7 = iVar7 + 1;
    uVar2 = uVar2 >> 1;
  } while (uVar2 != 0);
  cVar1 = (&UNK_1809fe050)[iVar8 / iVar7];
  uStack_30 = 0x18005d147;
  fVar9 = (float)powf(0x44800000);
  fVar10 = (float)(long long)param_1;
  if ((long long)param_1 < 0) {
    fVar10 = fVar10 + 1.8446744e+19;
  }
  uStackX_20 = (ulong long)(uint)(int)cVar1;
  dStackX_18 = (double)(fVar9 * fVar10);
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_478;
  puVar4 = (ulong long *)func_0x00018004b9a0();
  lVar5 = 0;
  uStack_458 = 0;
  pdStack_450 = &dStackX_18;
  iVar8 = __stdio_common_vsprintf(*puVar4 | 1,0,0,&UNK_1809fe058);
  if (iVar8 < 0) {
    iVar8 = -1;
  }
  if (iVar8 < 0x400) {
    uStack_458 = 0;
    pdStack_450 = &dStackX_18;
    __stdio_common_vsprintf(*puVar4 | 1,acStack_438,0x400,&UNK_1809fe058);
    lVar5 = -1;
    do {
      lVar6 = lVar5;
      lVar5 = lVar6 + 1;
    } while (acStack_438[lVar6 + 1] != '\0');
    iVar8 = (int)(lVar6 + 1);
    if (0 < iVar8) {
      FUN_1806277c0(param_2,*(int *)(param_2 + 0x10) + iVar8);
                    // WARNING: Subroutine does not return
      memcpy((ulong long)*(uint *)(param_2 + 0x10) + *(long long *)(param_2 + 8),acStack_438,
             (long long)((int)lVar6 + 2));
    }
  }
  else {
    iVar8 = iVar8 + 1;
    if (iVar8 != 0) {
      lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar8,3);
    }
    FUN_18004b9b0(lVar5,(long long)iVar8,&UNK_1809fe058,&dStackX_18);
    FUN_1806281a0(param_2,lVar5);
    if (lVar5 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar5);
    }
  }
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_38 ^ (ulong long)auStack_478);
}



long long FUN_18005d190(long long param_1,long long param_2)

{
  if (*(long long *)(param_1 + 8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x18) = 0;
  *(void* *)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x10) = *(uint32_t *)(param_2 + 0x10);
  *(void* *)(param_1 + 8) = *(void* *)(param_2 + 8);
  *(uint32_t *)(param_1 + 0x1c) = *(uint32_t *)(param_2 + 0x1c);
  *(uint32_t *)(param_1 + 0x18) = *(uint32_t *)(param_2 + 0x18);
  *(uint32_t *)(param_2 + 0x10) = 0;
  *(void* *)(param_2 + 8) = 0;
  *(void* *)(param_2 + 0x18) = 0;
  return param_1;
}




// 函数: void FUN_18005d1f0(void* param_1,long long param_2)
void FUN_18005d1f0(void* param_1,long long param_2)

{
  *(void* *)(param_2 + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(param_2 + 0x28) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_2 + 0x28) = 0;
  *(uint32_t *)(param_2 + 0x38) = 0;
  *(void* *)(param_2 + 0x20) = &SystemMemoryAllocatorReference;
  if (param_2 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(param_2);
  }
  return;
}




// 函数: void FUN_18005d260(void* param_1,void* *param_2,void* param_3,void* param_4)
void FUN_18005d260(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  if (param_2 == (void* *)0x0) {
    return;
  }
  FUN_18005d260(param_1,*param_2,param_3,param_4,0xfffffffffffffffe);
  param_2[4] = &SystemGlobalDataReference;
  if (param_2[5] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_2[5] = 0;
  *(uint32_t *)(param_2 + 7) = 0;
  param_2[4] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(param_2);
}




// 函数: void FUN_18005d310(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d310(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_18005d260(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18005d330(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d330(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_18005d260(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18005d360(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d360(long long param_1,void* param_2,void* param_3,void* param_4)

{
  FUN_18005d260(param_1,*(void* *)(param_1 + 0x10),param_3,param_4,0xfffffffffffffffe);
  return;
}




// 函数: void FUN_18005d3a0(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d3a0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  void* uVar1;
  void** systemDataTable;
  void* uStackX_10;
  uint64_t systemInitializationFlag;
  void* uStackX_20;
  
  uStackX_10 = param_2;
  uStackX_18 = param_3;
  uStackX_20 = param_4;
  uVar1 = __acrt_iob_func(1);
  puVar2 = (void* *)func_0x00018004b9a0();
  __stdio_common_vfprintf(*puVar2,uVar1,param_1,0,&uStackX_10);
  return;
}



void* * FUN_18005d400(long long param_1,char *param_2)

{
  char *pcVar1;
  char cVar2;
  void* *puVar3;
  char *pcVar4;
  long long systemTimeValue;
  char *pcVar6;
  
  if (param_2 == (char *)0x0) {
    return *(void* **)(param_1 + 0x58);
  }
  cVar2 = *param_2;
  pcVar6 = param_2;
  while (cVar2 != '\0') {
    pcVar6 = pcVar6 + 1;
    cVar2 = *pcVar6;
  }
  puVar3 = *(void* **)(param_1 + 0x58);
  do {
    if (puVar3 == (void* *)0x0) {
      return (void* *)0x0;
    }
    pcVar4 = (char *)*puVar3;
    if (pcVar4 == (char *)0x0) {
      lVar5 = 0;
      pcVar4 = (char *)0x180d48d24;
    }
    else {
      lVar5 = puVar3[2];
    }
    if (lVar5 == (long long)pcVar6 - (long long)param_2) {
      pcVar1 = pcVar4 + lVar5;
      if (pcVar1 <= pcVar4) {
        return puVar3;
      }
      lVar5 = (long long)param_2 - (long long)pcVar4;
      while (*pcVar4 == pcVar4[lVar5]) {
        pcVar4 = pcVar4 + 1;
        if (pcVar1 <= pcVar4) {
          return puVar3;
        }
      }
    }
    puVar3 = (void* *)puVar3[0xb];
  } while( true );
}



void* * FUN_18005d430(void* param_1,void* *param_2)

{
  char *pcVar1;
  char *pcVar2;
  long long lVar3;
  long long in_R10;
  long long in_R11;
  
  if (param_2 != (void* *)0x0) {
    do {
      pcVar2 = (char *)*param_2;
      if (pcVar2 == (char *)0x0) {
        lVar3 = 0;
        pcVar2 = (char *)0x180d48d24;
      }
      else {
        lVar3 = param_2[2];
      }
      if (lVar3 == in_R10) {
        pcVar1 = pcVar2 + lVar3;
        if (pcVar1 <= pcVar2) {
          return param_2;
        }
        lVar3 = in_R11 - (long long)pcVar2;
        while (*pcVar2 == pcVar2[lVar3]) {
          pcVar2 = pcVar2 + 1;
          if (pcVar1 <= pcVar2) {
            return param_2;
          }
        }
      }
      param_2 = (void* *)param_2[0xb];
    } while (param_2 != (void* *)0x0);
  }
  return (void* *)0x0;
}



void* * FUN_18005d484(void* param_1,void* *param_2)

{
  char *pcVar1;
  char *pcVar2;
  char *unaff_RBX;
  long long lVar3;
  long long in_R10;
  long long in_R11;
  
  while( true ) {
    do {
      param_2 = (void* *)param_2[0xb];
      if (param_2 == (void* *)0x0) {
        return (void* *)0x0;
      }
      if ((char *)*param_2 == (char *)0x0) {
        lVar3 = 0;
        pcVar2 = unaff_RBX;
      }
      else {
        lVar3 = param_2[2];
        pcVar2 = (char *)*param_2;
      }
    } while (lVar3 != in_R10);
    pcVar1 = pcVar2 + lVar3;
    if (pcVar1 <= pcVar2) break;
    lVar3 = in_R11 - (long long)pcVar2;
    while (*pcVar2 == pcVar2[lVar3]) {
      pcVar2 = pcVar2 + 1;
      if (pcVar1 <= pcVar2) {
        return param_2;
      }
    }
  }
  return param_2;
}



void* FUN_18005d498(long long param_1)

{
  return *(void* *)(param_1 + 0x58);
}



void* * FUN_18005d4b0(long long param_1,char *param_2,long long param_3)

{
  char *pcVar1;
  char cVar2;
  void* *puVar3;
  char *pcVar4;
  long long systemTimeValue;
  
  if (param_2 == (char *)0x0) {
    return *(void* **)(param_1 + 0x30);
  }
  if (param_3 == 0) {
    cVar2 = *param_2;
    pcVar4 = param_2;
    while (cVar2 != '\0') {
      pcVar4 = pcVar4 + 1;
      cVar2 = *pcVar4;
    }
    param_3 = (long long)pcVar4 - (long long)param_2;
  }
  puVar3 = *(void* **)(param_1 + 0x30);
  do {
    if (puVar3 == (void* *)0x0) {
      return (void* *)0x0;
    }
    pcVar4 = (char *)*puVar3;
    if (pcVar4 == (char *)0x0) {
      lVar5 = 0;
      pcVar4 = (char *)0x180d48d24;
    }
    else {
      lVar5 = puVar3[2];
    }
    if (lVar5 == param_3) {
      pcVar1 = pcVar4 + lVar5;
      if (pcVar1 <= pcVar4) {
        return puVar3;
      }
      lVar5 = (long long)param_2 - (long long)pcVar4;
      while (*pcVar4 == pcVar4[lVar5]) {
        pcVar4 = pcVar4 + 1;
        if (pcVar1 <= pcVar4) {
          return puVar3;
        }
      }
    }
    puVar3 = (void* *)puVar3[0xb];
  } while( true );
}



void* * FUN_18005d4e0(void* param_1,void* *param_2,long long param_3)

{
  char *pcVar1;
  char *pcVar2;
  long long lVar3;
  long long in_R11;
  
  if (param_2 != (void* *)0x0) {
    do {
      pcVar2 = (char *)*param_2;
      if (pcVar2 == (char *)0x0) {
        lVar3 = 0;
        pcVar2 = (char *)0x180d48d24;
      }
      else {
        lVar3 = param_2[2];
      }
      if (lVar3 == param_3) {
        pcVar1 = pcVar2 + lVar3;
        if (pcVar1 <= pcVar2) {
          return param_2;
        }
        lVar3 = in_R11 - (long long)pcVar2;
        while (*pcVar2 == pcVar2[lVar3]) {
          pcVar2 = pcVar2 + 1;
          if (pcVar1 <= pcVar2) {
            return param_2;
          }
        }
      }
      param_2 = (void* *)param_2[0xb];
    } while (param_2 != (void* *)0x0);
  }
  return (void* *)0x0;
}



void* * FUN_18005d534(void* param_1,void* *param_2,long long param_3)

{
  char *pcVar1;
  char *pcVar2;
  char *unaff_RBX;
  long long lVar3;
  long long in_R11;
  
  while( true ) {
    do {
      param_2 = (void* *)param_2[0xb];
      if (param_2 == (void* *)0x0) {
        return (void* *)0x0;
      }
      if ((char *)*param_2 == (char *)0x0) {
        lVar3 = 0;
        pcVar2 = unaff_RBX;
      }
      else {
        lVar3 = param_2[2];
        pcVar2 = (char *)*param_2;
      }
    } while (lVar3 != param_3);
    pcVar1 = pcVar2 + lVar3;
    if (pcVar1 <= pcVar2) break;
    lVar3 = in_R11 - (long long)pcVar2;
    while (*pcVar2 == pcVar2[lVar3]) {
      pcVar2 = pcVar2 + 1;
      if (pcVar1 <= pcVar2) {
        return param_2;
      }
    }
  }
  return param_2;
}



void* FUN_18005d548(long long param_1)

{
  return *(void* *)(param_1 + 0x30);
}




// 函数: void FUN_18005d560(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d560(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 4) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18005d580(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d580(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 4) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



void* *
FUN_18005d600(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  *param_1 = &UNK_1809fe100;
  FUN_180049470();
  if ((param_2 & 1) != 0) {
    free(param_1,0xc0,param_3,param_4,uVar1);
  }
  return param_1;
}



uint8_t * FUN_18005d660(uint8_t *param_1)

{
  void* uVar1;
  
  *(void* *)(param_1 + 8) = 0;
  *(void* *)(param_1 + 0x10) = 0;
  *(void* *)(param_1 + 0x18) = 0;
  *(uint32_t *)(param_1 + 0x20) = 3;
  *(void* *)(param_1 + 0x28) = 0;
  *(void* *)(param_1 + 0x30) = 0;
  *(void* *)(param_1 + 0x38) = 0;
  *(uint32_t *)(param_1 + 0x40) = 3;
  *(void* *)(param_1 + 0x48) = 0;
  *(void* *)(param_1 + 0x50) = 0;
  *(void* *)(param_1 + 0x58) = 0;
  *(uint32_t *)(param_1 + 0x60) = 3;
  uVar1 = CreateSemaphoreW(0,0,0x7fffffff,0,0xfffffffffffffffe);
  *(void* *)(param_1 + 0x68) = uVar1;
  uVar1 = CreateSemaphoreW(0,0,0x7fffffff,0);
  *(void* *)(param_1 + 0x70) = uVar1;
  FUN_18005e950(param_1 + 0x78);
  FUN_18005e950(param_1 + 0x2e0);
  FUN_18005e950(param_1 + 0x548);
  *(uint32_t *)(param_1 + 0x7b0) = 0;
  *(uint32_t *)(param_1 + 0x7b4) = 0x1000;
  *param_1 = 0;
  return param_1;
}




// 函数: void FUN_18005d760(void* *param_1)
void FUN_18005d760(void* *param_1)

{
  CloseHandle(*param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005d790(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18005d790(long long param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  long long *plVar2;
  long long *plVar3;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  int iVar6;
  long long lVar7;
  
  lVar5 = _DAT_180c8ed18;
  if (*(code **)(_DAT_180c8ed18 + 0x20) != (code *)0x0) {
    (**(code **)(_DAT_180c8ed18 + 0x20))(_DAT_180c8ed18 + 0x10,0,0,param_4,0xfffffffffffffffe);
  }
  *(void* *)(lVar5 + 0x20) = 0;
  *(code **)(lVar5 + 0x28) = _guard_check_icall;
  iVar6 = 0;
  plVar1 = (long long *)(param_1 + 8);
  if (*(long long *)(param_1 + 0x10) - *plVar1 >> 3 != 0) {
    lVar5 = 0;
    do {
      FUN_18020e7b0(*(void* *)(*plVar1 + lVar5));
      iVar6 = iVar6 + 1;
      lVar5 = lVar5 + 8;
    } while ((ulong long)(long long)iVar6 < (ulong long)(*(long long *)(param_1 + 0x10) - *plVar1 >> 3))
    ;
  }
  iVar6 = 0;
  plVar2 = (long long *)(param_1 + 0x28);
  if (*(long long *)(param_1 + 0x30) - *plVar2 >> 3 != 0) {
    lVar5 = 0;
    do {
      FUN_18020e7b0(*(void* *)(*plVar2 + lVar5));
      iVar6 = iVar6 + 1;
      lVar5 = lVar5 + 8;
    } while ((ulong long)(long long)iVar6 < (ulong long)(*(long long *)(param_1 + 0x30) - *plVar2 >> 3))
    ;
  }
  iVar6 = 0;
  plVar3 = (long long *)(param_1 + 0x48);
  if (*(long long *)(param_1 + 0x50) - *plVar3 >> 3 != 0) {
    lVar5 = 0;
    do {
      FUN_18020e7b0(*(void* *)(*plVar3 + lVar5));
      iVar6 = iVar6 + 1;
      lVar5 = lVar5 + 8;
    } while ((ulong long)(long long)iVar6 < (ulong long)(*(long long *)(param_1 + 0x50) - *plVar3 >> 3))
    ;
  }
  iVar6 = 0;
  lVar5 = *plVar1;
  if (*(long long *)(param_1 + 0x10) - lVar5 >> 3 != 0) {
    lVar7 = 0;
    do {
      plVar4 = *(long long **)(lVar7 + lVar5);
      if (plVar4 != (long long *)0x0) {
        lVar5 = __RTCastToVoid(plVar4);
        (**(code **)(*plVar4 + 0x28))(plVar4,0);
        if (lVar5 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(lVar5);
        }
      }
      *(void* *)(lVar7 + *plVar1) = 0;
      iVar6 = iVar6 + 1;
      lVar7 = lVar7 + 8;
      lVar5 = *plVar1;
    } while ((ulong long)(long long)iVar6 < (ulong long)(*(long long *)(param_1 + 0x10) - lVar5 >> 3));
  }
  iVar6 = 0;
  lVar5 = *plVar2;
  if (*(long long *)(param_1 + 0x30) - lVar5 >> 3 != 0) {
    lVar7 = 0;
    do {
      plVar4 = *(long long **)(lVar5 + lVar7);
      if (plVar4 != (long long *)0x0) {
        lVar5 = __RTCastToVoid(plVar4);
        (**(code **)(*plVar4 + 0x28))(plVar4,0);
        if (lVar5 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(lVar5);
        }
      }
      *(void* *)(lVar7 + *plVar2) = 0;
      iVar6 = iVar6 + 1;
      lVar7 = lVar7 + 8;
      lVar5 = *plVar2;
    } while ((ulong long)(long long)iVar6 < (ulong long)(*(long long *)(param_1 + 0x30) - lVar5 >> 3));
  }
  iVar6 = 0;
  lVar5 = *plVar3;
  if (*(long long *)(param_1 + 0x50) - lVar5 >> 3 != 0) {
    lVar7 = 0;
    do {
      plVar4 = *(long long **)(lVar5 + lVar7);
      if (plVar4 != (long long *)0x0) {
        lVar5 = __RTCastToVoid(plVar4);
        (**(code **)(*plVar4 + 0x28))(plVar4,0);
        if (lVar5 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(lVar5);
        }
      }
      *(void* *)(lVar7 + *plVar3) = 0;
      iVar6 = iVar6 + 1;
      lVar7 = lVar7 + 8;
      lVar5 = *plVar3;
    } while ((ulong long)(long long)iVar6 < (ulong long)(*(long long *)(param_1 + 0x50) - lVar5 >> 3));
  }
  FUN_180059ee0(param_1 + 0x548);
  FUN_180059ee0(param_1 + 0x2e0);
  FUN_180059ee0(param_1 + 0x78);
  CloseHandle(*(void* *)(param_1 + 0x70));
  CloseHandle(*(void* *)(param_1 + 0x68));
  if (*plVar3 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (*plVar2 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}




// 函数: void FUN_18005dab0(long long param_1)
void FUN_18005dab0(long long param_1)

{
  long long lVar1;
  long long lVar2;
  int memoryCompareResult;
  long long lVar4;
  
  lVar2 = GetCurrentThread();
  iVar3 = (int)(*(long long *)(param_1 + 0x10) - *(long long *)(param_1 + 8) >> 3);
  if (0 < iVar3) {
    lVar4 = 0;
    do {
      lVar1 = *(long long *)(*(long long *)(*(long long *)(param_1 + 8) + lVar4 * 8) + 0x40);
      if ((lVar1 != 0) && (lVar1 != lVar2)) {
        SuspendThread();
      }
      lVar4 = lVar4 + 1;
    } while (lVar4 < iVar3);
  }
  return;
}




// 函数: void FUN_18005dade(void)
void FUN_18005dade(void)

{
  long long lVar1;
  long long lVar2;
  long long unaff_RBP;
  long long unaff_RSI;
  long long unaff_RDI;
  
  lVar2 = 0;
  do {
    lVar1 = *(long long *)(*(long long *)(*(long long *)(unaff_RSI + 8) + lVar2 * 8) + 0x40);
    if ((lVar1 != 0) && (lVar1 != unaff_RBP)) {
      SuspendThread();
    }
    lVar2 = lVar2 + 1;
  } while (lVar2 < unaff_RDI);
  return;
}




// 函数: void FUN_18005db19(void)
void FUN_18005db19(void)

{
  return;
}




// 函数: void FUN_18005db30(long long param_1)
void FUN_18005db30(long long param_1)

{
  long long lVar1;
  long long lVar2;
  int memoryCompareResult;
  long long lVar4;
  
  lVar2 = GetCurrentThread();
  iVar3 = (int)(*(long long *)(param_1 + 0x10) - *(long long *)(param_1 + 8) >> 3);
  if (0 < iVar3) {
    lVar4 = 0;
    do {
      lVar1 = *(long long *)(*(long long *)(*(long long *)(param_1 + 8) + lVar4 * 8) + 0x40);
      if ((lVar1 != 0) && (lVar1 != lVar2)) {
        ResumeThread();
      }
      lVar4 = lVar4 + 1;
    } while (lVar4 < iVar3);
  }
  return;
}




// 函数: void FUN_18005db5e(void)
void FUN_18005db5e(void)

{
  long long lVar1;
  long long lVar2;
  long long unaff_RBP;
  long long unaff_RSI;
  long long unaff_RDI;
  
  lVar2 = 0;
  do {
    lVar1 = *(long long *)(*(long long *)(*(long long *)(unaff_RSI + 8) + lVar2 * 8) + 0x40);
    if ((lVar1 != 0) && (lVar1 != unaff_RBP)) {
      ResumeThread();
    }
    lVar2 = lVar2 + 1;
  } while (lVar2 < unaff_RDI);
  return;
}




// 函数: void FUN_18005db99(void)
void FUN_18005db99(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005dbb0(void)
void FUN_18005dbb0(void)

{
  long long *plVar1;
  int iVar2;
  void* uVar3;
  void* *puVar4;
  long long systemTimeValue;
  long long lVar7;
  ulong long uVar8;
  ulong long uVar9;
  long long lVar10;
  long long lVar11;
  int iVar12;
  uint uVar13;
  ulong long uVar14;
  undefined **ppuVar15;
  uint8_t auStack_1b8 [32];
  long long lStack_198;
  long long lStack_190;
  long long lStack_188;
  long long lStack_178;
  undefined **ppuStack_170;
  void* uStack_168;
  undefined *puStack_160;
  uint8_t *puStack_158;
  uint uStack_150;
  uint8_t auStack_148 [16];
  undefined *puStack_138;
  uint8_t *puStack_130;
  uint32_t uStack_128;
  uint8_t auStack_120 [24];
  undefined *apuStack_108 [19];
  int iStack_70;
  void* uStack_58;
  char acStack_48 [16];
  ulong long uStack_38;
  long long lVar6;
  
  lVar10 = _DAT_180c82868;
  uStack_168 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_1b8;
  lStack_178 = _DAT_180c82868;
  FUN_180623de0(apuStack_108);
  iVar12 = iStack_70 + -1;
  if (*(int *)(lVar10 + 0x7b4) < iStack_70 + -1) {
    iVar12 = *(int *)(lVar10 + 0x7b4);
  }
  iVar2 = 3;
  if (3 < iVar12) {
    iVar2 = iVar12;
  }
  ppuVar15 = (undefined **)(lVar10 + 8);
  lVar11 = (long long)iVar2;
  ppuStack_170 = ppuVar15;
  FUN_180057340(ppuVar15,lVar11);
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
  uVar9 = 0;
  puStack_160 = &UNK_1809fdc18;
  puStack_158 = auStack_148;
  auStack_148[0] = 0;
  uStack_150 = 4;
  strcpy_s(auStack_148,0x10,&UNK_1809fe188);
  lStack_198 = lVar10 + 0x78;
  lStack_190 = lVar10 + 0x548;
  lStack_188 = lVar10 + 0x68;
  uVar3 = FUN_18020e410(uVar3,&puStack_160,0,0);
  *(void* *)*ppuVar15 = uVar3;
  puStack_160 = &SystemMemoryAllocatorReference;
  puVar4 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
  puStack_138 = &UNK_1809fdc18;
  puStack_130 = auStack_120;
  auStack_120[0] = 0;
  uStack_128 = 6;
  uStack_58 = puVar4;
  strcpy_s(auStack_120,0x10,&UNK_1809fe190);
  lStack_198 = lVar10 + 0x78;
  lStack_190 = lVar10 + 0x548;
  lStack_188 = lVar10 + 0x68;
  FUN_18020e410(puVar4,&puStack_138,1);
  *puVar4 = &UNK_1809fe290;
  *(void* **)((long long)*ppuVar15 + 8) = puVar4;
  puStack_138 = &SystemMemoryAllocatorReference;
  iVar12 = 2;
  *(uint32_t *)(lStack_178 + 0x7b0) = 2;
  if (2 < lVar11) {
    lVar10 = 2;
    do {
      puStack_160 = &UNK_1809fdc18;
      puStack_158 = auStack_148;
      auStack_148[0] = 0;
      uStack_150 = 7;
      strcpy_s(auStack_148,0x10,&UNK_1809fe198);
      FUN_180060680(&uStack_58,&UNK_1809fd0a0,iVar12 + -1);
      lVar6 = -1;
      do {
        lVar5 = lVar6 + 1;
        lVar7 = lVar6 + 1;
        lVar6 = lVar5;
      } while (*(char *)((long long)&uStack_58 + lVar7) != '\0');
      iVar2 = (int)lVar5;
      if ((0 < iVar2) && (uStack_150 + iVar2 < 0xf)) {
                    // WARNING: Subroutine does not return
        memcpy(puStack_158 + uStack_150,&uStack_58,(long long)(iVar2 + 1));
      }
      uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
      lStack_188 = lStack_178 + 0x68;
      lStack_190 = lStack_178 + 0x548;
      lStack_198 = lStack_178 + 0x78;
      uVar3 = FUN_18020e410(uVar3,&puStack_160,2,iVar12);
      *(void* *)((long long)*ppuVar15 + lVar10 * 8) = uVar3;
      puStack_160 = &SystemMemoryAllocatorReference;
      iVar12 = iVar12 + 1;
      lVar10 = lVar10 + 1;
    } while (lVar10 < lVar11);
  }
  lVar10 = lStack_178;
  iVar2 = (int)(iStack_70 + (iStack_70 >> 0x1f & 3U)) >> 2;
  iVar12 = 2;
  if ((1 < iVar2) && (iVar12 = iVar2, 4 < iVar2)) {
    iVar12 = 4;
  }
  plVar1 = (long long *)(lStack_178 + 0x28);
  lVar11 = (long long)iVar12;
  FUN_180057340(plVar1,lVar11);
  if (0 < lVar11) {
    uVar8 = uVar9;
    uVar14 = uVar9;
    do {
      puStack_160 = &UNK_1809fdc18;
      puStack_158 = auStack_148;
      auStack_148[0] = 0;
      uStack_150 = 10;
      strcpy_s(auStack_148,0x10,&UNK_1809fe1a0);
      FUN_180060680(acStack_48,&UNK_1809fd0a0,uVar8);
      lVar6 = -1;
      do {
        lVar7 = lVar6;
        lVar6 = lVar7 + 1;
      } while (acStack_48[lVar7 + 1] != '\0');
      iVar12 = (int)(lVar7 + 1);
      if ((0 < iVar12) && (uStack_150 + iVar12 < 0xf)) {
                    // WARNING: Subroutine does not return
        memcpy(puStack_158 + uStack_150,acStack_48,(long long)((int)lVar7 + 2));
      }
      puVar4 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
      lStack_198 = lVar10 + 0x70;
      uStack_58 = puVar4;
      FUN_18020e0e0(puVar4,&puStack_160,4,lStack_178 + 0x2e0);
      *puVar4 = &UNK_1809fe258;
      *(void* **)(*plVar1 + uVar14 * 8) = puVar4;
      puStack_160 = &SystemMemoryAllocatorReference;
      uVar8 = (ulong long)((int)uVar8 + 1);
      uVar14 = uVar14 + 1;
      ppuVar15 = ppuStack_170;
    } while ((long long)uVar14 < lVar11);
  }
  uVar8 = uVar9;
  uVar14 = uVar9;
  if (((long long *)ppuVar15)[1] - (long long)*ppuVar15 >> 3 != 0) {
    do {
      FUN_18020e840(*(void* *)((long long)*ppuVar15 + uVar8));
      uVar13 = (int)uVar14 + 1;
      uVar8 = uVar8 + 8;
      uVar14 = (ulong long)uVar13;
    } while ((ulong long)(long long)(int)uVar13 <
             (ulong long)(((long long *)ppuVar15)[1] - (long long)*ppuVar15 >> 3));
  }
  uVar8 = uVar9;
  if (*(long long *)(lVar10 + 0x30) - *plVar1 >> 3 != 0) {
    do {
      FUN_18020e840(*(void* *)(*plVar1 + uVar9));
      uVar13 = (int)uVar8 + 1;
      uVar9 = uVar9 + 8;
      uVar8 = (ulong long)uVar13;
    } while ((ulong long)(long long)(int)uVar13 <
             (ulong long)(*(long long *)(lVar10 + 0x30) - *plVar1 >> 3));
  }
  ppuStack_170 = apuStack_108;
  apuStack_108[0] = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_38 ^ (ulong long)auStack_1b8);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005e110(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_18005e110(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  uint uVar1;
  int iVar2;
  long long lVar3;
  long long lVar4;
  void* uVar5;
  
  uVar5 = 0xfffffffffffffffe;
  (**(code **)(*(long long *)*param_2 + 0x78))();
  uVar1 = *(uint *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8)
                   + 0xc);
  if (uVar1 == 0xffffffff) {
    lVar3 = FUN_18005eb80(param_1 + 0x78);
    if (lVar3 != 0) {
      FUN_18005f220(lVar3,param_2);
    }
  }
  else {
    lVar3 = *(long long *)(*(long long *)(*(long long *)(param_1 + 8) + (ulong long)uVar1 * 8) + 0x70);
    lVar4 = lVar3 + -8;
    if (lVar3 == 0) {
      lVar4 = 0;
    }
    FUN_18005f040(lVar4,param_2,(ulong long)__tls_index,param_4,uVar5);
  }
  do {
    iVar2 = ReleaseSemaphore(*(void* *)(param_1 + 0x68),1);
  } while (iVar2 == 0);
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}




// 函数: void FUN_18005e1d0(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_18005e1d0(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  int iVar1;
  long long lVar2;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  (**(code **)(*(long long *)*param_2 + 0x78))();
  lVar2 = FUN_18005eb80(param_1 + 0x548);
  if (lVar2 != 0) {
    FUN_18005f220(lVar2,param_2);
  }
  do {
    iVar1 = ReleaseSemaphore(*(void* *)(param_1 + 0x68),1,0,param_4,uVar3);
  } while (iVar1 == 0);
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005e250(long long param_1,void* param_2,int param_3)
void FUN_18005e250(long long param_1,void* param_2,int param_3)

{
  uint uVar1;
  int iVar2;
  long long lVar3;
  long long lVar4;
  
  uVar1 = *(uint *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8)
                   + 0xc);
  if (uVar1 == 0xffffffff) {
    lVar3 = FUN_18005eb80(param_1 + 0x78);
    if (lVar3 != 0) {
      FUN_18005fb30(lVar3,param_2,(long long)param_3);
    }
  }
  else {
    lVar3 = *(long long *)(*(long long *)(*(long long *)(param_1 + 8) + (ulong long)uVar1 * 8) + 0x70);
    lVar4 = lVar3 + -8;
    if (lVar3 == 0) {
      lVar4 = 0;
    }
    FUN_18005f570(lVar4,param_2,(long long)param_3);
  }
  do {
    iVar2 = ReleaseSemaphore(*(void* *)(param_1 + 0x68),param_3,0);
  } while (iVar2 == 0);
  return;
}




// 函数: void FUN_18005e300(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_18005e300(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  code *pcVar2;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)**(void* **)(param_1 + 8);
  pcVar2 = *(code **)*puVar1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)*param_2;
  plStackX_10 = param_2;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  (*pcVar2)(puVar1,&plStackX_8,param_3,param_4,uVar3);
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}




// 函数: void FUN_18005e370(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_18005e370(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  code *pcVar2;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = *(void* **)(*(long long *)(param_1 + 8) + 8);
  pcVar2 = *(code **)*puVar1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)*param_2;
  plStackX_10 = param_2;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  (*pcVar2)(puVar1,&plStackX_8,param_3,param_4,uVar3);
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}




// 函数: void FUN_18005e3e0(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_18005e3e0(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  code *pcVar2;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = *(void* **)(*(long long *)(param_1 + 8) + 0x10);
  pcVar2 = *(code **)*puVar1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)*param_2;
  plStackX_10 = param_2;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  (*pcVar2)(puVar1,&plStackX_8,param_3,param_4,uVar3);
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}




// 函数: void FUN_18005e450(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_18005e450(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  int iVar1;
  long long lVar2;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  (**(code **)(*(long long *)*param_2 + 0x78))();
  lVar2 = FUN_18005eb80(param_1 + 0x2e0);
  if (lVar2 != 0) {
    FUN_18005f220(lVar2,param_2);
  }
  do {
    iVar1 = ReleaseSemaphore(*(void* *)(param_1 + 0x70),1,0,param_4,uVar3);
  } while (iVar1 == 0);
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_18005e4d0(long long param_1,void* param_2)

{
  void* *puVar1;
  void* *puStackX_8;
  
  puVar1 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
  puStackX_8 = puVar1;
  FUN_18020e0e0(puVar1,param_2,3,param_1 + 0x2e0,param_1 + 0x70);
  *puVar1 = &UNK_1809fe220;
  puStackX_8 = puVar1;
  FUN_18020e840(puVar1);
  FUN_18005ea90(param_1 + 0x48,&puStackX_8);
  return puVar1;
}




// 函数: void FUN_18005e570(long long param_1,long long *param_2)
void FUN_18005e570(long long param_1,long long *param_2)

{
  long long *plVar1;
  ulong long uVar2;
  long long lVar3;
  long long* systemMemoryPointer;
  int iVar5;
  ulong long uVar6;
  
  iVar5 = 0;
  plVar1 = *(long long **)(param_1 + 0x48);
  uVar6 = *(long long *)(param_1 + 0x50) - (long long)plVar1 >> 3;
  plVar4 = plVar1;
  if (uVar6 != 0) {
    do {
      if ((long long *)*plVar4 == param_2) {
        FUN_18020e7b0(plVar1[iVar5]);
        uVar2 = *(ulong long *)(param_1 + 0x50);
        lVar3 = *(long long *)(param_1 + 0x48) + (long long)iVar5 * 8;
        uVar6 = lVar3 + 8;
        if (uVar6 < uVar2) {
                    // WARNING: Subroutine does not return
          memmove(lVar3,uVar6,uVar2 - uVar6);
        }
        *(ulong long *)(param_1 + 0x50) = uVar2 - 8;
        break;
      }
      iVar5 = iVar5 + 1;
      plVar4 = plVar4 + 1;
    } while ((ulong long)(long long)iVar5 < uVar6);
  }
  if (param_2 != (long long *)0x0) {
    lVar3 = __RTCastToVoid(param_2);
    (**(code **)(*param_2 + 0x28))(param_2,0);
    if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar3);
    }
  }
  return;
}




// 函数: void FUN_18005e57a(long long param_1,long long *param_2)
void FUN_18005e57a(long long param_1,long long *param_2)

{
  long long *plVar1;
  ulong long uVar2;
  long long lVar3;
  long long* systemMemoryPointer;
  int iVar5;
  ulong long uVar6;
  
  iVar5 = 0;
  plVar1 = *(long long **)(param_1 + 0x48);
  uVar6 = *(long long *)(param_1 + 0x50) - (long long)plVar1 >> 3;
  plVar4 = plVar1;
  if (uVar6 != 0) {
    do {
      if ((long long *)*plVar4 == param_2) {
        FUN_18020e7b0(plVar1[iVar5]);
        uVar2 = *(ulong long *)(param_1 + 0x50);
        lVar3 = *(long long *)(param_1 + 0x48) + (long long)iVar5 * 8;
        uVar6 = lVar3 + 8;
        if (uVar6 < uVar2) {
                    // WARNING: Subroutine does not return
          memmove(lVar3,uVar6,uVar2 - uVar6);
        }
        *(ulong long *)(param_1 + 0x50) = uVar2 - 8;
        break;
      }
      iVar5 = iVar5 + 1;
      plVar4 = plVar4 + 1;
    } while ((ulong long)(long long)iVar5 < uVar6);
  }
  if (param_2 != (long long *)0x0) {
    lVar3 = __RTCastToVoid(param_2);
    (**(code **)(*param_2 + 0x28))(param_2,0);
    if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(lVar3);
    }
  }
  return;
}




// 函数: void FUN_18005e5ff(void)
void FUN_18005e5ff(void)

{
  long long lVar1;
  long long *unaff_RDI;
  
  lVar1 = __RTCastToVoid();
  (**(code **)(*unaff_RDI + 0x28))();
  if (lVar1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005e630(long long param_1)
void FUN_18005e630(long long param_1)

{
  int iVar1;
  long long lVar2;
  
  FUN_18020f150(*(void* *)(*(long long *)(param_1 + 8) + 8));
  lVar2 = _DAT_180c86938 + 0x20;
  iVar1 = _Mtx_lock(lVar2);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  iVar1 = _Mtx_unlock(lVar2);
  if (iVar1 != 0) {
                    // WARNING: Could not recover jumptable at 0x00018005e68f. Too many branches
                    // WARNING: Treating indirect jump as call
    __Throw_C_error_std__YAXH_Z(iVar1);
    return;
  }
  return;
}




// 函数: void FUN_18005e6a0(void* param_1,long long *param_2,uint8_t param_3,void* param_4)
void FUN_18005e6a0(void* param_1,long long *param_2,uint8_t param_3,void* param_4)

{
  code *pcVar1;
  long long *plVar2;
  char cVar3;
  void* uVar4;
  
  uVar4 = 0xfffffffffffffffe;
  while( true ) {
    pcVar1 = *(code **)(*(long long *)*param_2 + 0x68);
    if (pcVar1 == (code *)&UNK_1800467f0) {
      cVar3 = (char)((long long *)*param_2)[2] != '\0';
    }
    else {
      cVar3 = (*pcVar1)();
    }
    if (cVar3 != '\0') break;
    plVar2 = (long long *)FUN_18005e890(param_1);
    cVar3 = (**(code **)(*plVar2 + 0x20))(plVar2,param_3,*(code **)(*plVar2 + 0x20),param_4,uVar4);
    if (cVar3 == '\0') {
      pcVar1 = *(code **)(*(long long *)*param_2 + 0x80);
      if (pcVar1 == (code *)&UNK_180049760) {
        FUN_1800496b0((long long *)*param_2 + 4);
      }
      else {
        (*pcVar1)();
      }
    }
  }
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}




// 函数: void FUN_18005e770(void* param_1,long long *param_2,char param_3)
void FUN_18005e770(void* param_1,long long *param_2,char param_3)

{
  code *pcVar1;
  bool bVar2;
  long long *plVar3;
  ulong long uVar4;
  long long systemTimeValue;
  long long lVar6;
  char cVar7;
  
  lVar6 = param_2[1];
  lVar5 = *param_2;
  do {
    bVar2 = false;
    uVar4 = 0;
    if (lVar6 - lVar5 >> 3 == 0) {
      return;
    }
    do {
      plVar3 = *(long long **)(uVar4 * 8 + lVar5);
      pcVar1 = *(code **)(*plVar3 + 0x68);
      if (pcVar1 == (code *)&UNK_1800467f0) {
        cVar7 = (char)plVar3[2] != '\0';
      }
      else {
        cVar7 = (*pcVar1)();
      }
      if (cVar7 == '\0') {
        bVar2 = true;
        plVar3 = (long long *)FUN_18005e890(param_1);
        if (param_3 == '\0') {
          cVar7 = (**(code **)(*plVar3 + 0x20))(plVar3,0);
        }
        else {
          cVar7 = FUN_18020ee40();
        }
        if (cVar7 == '\0') {
          plVar3 = *(long long **)(uVar4 * 8 + *param_2);
          pcVar1 = *(code **)(*plVar3 + 0x80);
          if (pcVar1 == (code *)&UNK_180049760) {
            FUN_1800496b0(plVar3 + 4);
          }
          else {
            (*pcVar1)();
          }
        }
      }
      lVar6 = param_2[1];
      uVar4 = (ulong long)((int)uVar4 + 1);
      lVar5 = *param_2;
    } while (uVar4 < (ulong long)(lVar6 - lVar5 >> 3));
  } while (bVar2);
  return;
}



long long FUN_18005e890(long long param_1)

{
  long long lVar1;
  int iVar2;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar4 = 0;
  uVar3 = uVar4;
  if (*(long long *)(param_1 + 0x10) - *(long long *)(param_1 + 8) >> 3 != 0) {
    do {
      iVar2 = _Thrd_id();
      lVar1 = *(long long *)(*(long long *)(param_1 + 8) + uVar3 * 8);
      if (*(int *)(lVar1 + 0x48) == iVar2) {
        return lVar1;
      }
      uVar3 = (ulong long)((int)uVar3 + 1);
    } while (uVar3 < (ulong long)(*(long long *)(param_1 + 0x10) - *(long long *)(param_1 + 8) >> 3));
  }
  if (*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x28) >> 3 != 0) {
    do {
      iVar2 = _Thrd_id();
      lVar1 = *(long long *)(*(long long *)(param_1 + 0x28) + uVar4 * 8);
      if (*(int *)(lVar1 + 0x48) == iVar2) {
        return lVar1;
      }
      uVar4 = (ulong long)((int)uVar4 + 1);
    } while (uVar4 < (ulong long)(*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x28) >> 3)
            );
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_18005e950(void* *param_1)

{
  void* uVar1;
  ulong long uVar2;
  void* *puVar3;
  ulong long uVar4;
  ulong long uVar5;
  void** systemRootNode;
  long long lVar7;
  long long lVar8;
  
  uVar5 = 0;
  puVar3 = param_1 + 0xb;
  *param_1 = 0;
  lVar8 = 0x20;
  *(uint32_t *)(param_1 + 1) = 0;
  param_1[2] = 0;
  param_1[5] = 0;
  lVar7 = 0x20;
  puVar6 = puVar3;
  do {
    func_0x000180059bb0(puVar6);
    puVar6 = puVar6 + 2;
    lVar7 = lVar7 + -1;
  } while (lVar7 != 0);
  *(void* *)((long long)param_1 + 0x25c) = 0;
  *(uint32_t *)(param_1 + 0x4b) = 0;
  param_1[7] = 0;
  param_1[8] = 0x20;
  param_1[9] = puVar3;
  do {
    *(uint32_t *)puVar3 = 0;
    uVar1 = _DAT_180c8ed18;
    puVar3 = puVar3 + 2;
    lVar8 = lVar8 + -1;
  } while (lVar8 != 0);
  lVar7 = 6;
  param_1[10] = 0;
  param_1[6] = param_1 + 8;
  param_1[4] = 6;
  uVar2 = CreateSystemThreadObject(uVar1,0x7b0,10);
  uVar4 = uVar5;
  if (uVar2 != 0) {
    puVar3 = (void* *)(uVar2 + 0x108);
    do {
      puVar3[-1] = 0;
      *puVar3 = 0;
      *(uint32_t *)(puVar3 + 5) = 0;
      puVar3[6] = 0;
      *(undefined2 *)(puVar3 + 7) = 0x100;
      puVar3 = puVar3 + 0x29;
      lVar7 = lVar7 + -1;
      uVar4 = uVar2;
    } while (lVar7 != 0);
  }
  param_1[3] = uVar4;
  if (uVar4 == 0) {
    param_1[4] = 0;
    uVar4 = uVar5;
  }
  else {
    uVar4 = param_1[4];
  }
  uVar2 = uVar5;
  if (uVar4 != 0) {
    do {
      uVar2 = uVar2 + 1;
      *(uint8_t *)(uVar5 + 0x141 + param_1[3]) = 0;
      uVar5 = uVar5 + 0x148;
    } while (uVar2 < (ulong long)param_1[4]);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18005ea90(ulong long *param_1,void* *param_2)
void FUN_18005ea90(ulong long *param_1,void* *param_2)

{
  long long lVar1;
  void** systemDataTable;
  void* *puVar3;
  void* *puVar4;
  
  puVar4 = (void* *)param_1[1];
  if (puVar4 < (void* *)param_1[2]) {
    param_1[1] = (ulong long)(puVar4 + 1);
    *puVar4 = *param_2;
    return;
  }
  puVar3 = (void* *)*param_1;
  lVar1 = (long long)puVar4 - (long long)puVar3 >> 3;
  if (lVar1 == 0) {
    lVar1 = 1;
  }
  else {
    lVar1 = lVar1 * 2;
    if (lVar1 == 0) {
      puVar2 = (void* *)0x0;
      goto LAB_18005eb20;
    }
  }
  puVar2 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,lVar1 * 8,(char)param_1[3]);
  puVar3 = (void* *)*param_1;
  puVar4 = (void* *)param_1[1];
LAB_18005eb20:
  if (puVar3 != puVar4) {
                    // WARNING: Subroutine does not return
    memmove(puVar2,puVar3,(long long)puVar4 - (long long)puVar3);
  }
  *puVar2 = *param_2;
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = (ulong long)puVar2;
  param_1[1] = (ulong long)(puVar2 + 1);
  param_1[2] = (ulong long)(puVar2 + lVar1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_18005eb80(long long param_1)

{
  long long *plVar1;
  uint *puVar2;
  ulong long *puVar3;
  ulong long uVar4;
  uint uVar5;
  ulong long uVar6;
  ulong long *systemPreviousNode;
  long long lVar8;
  ulong long uVar9;
  ulong long uVar10;
  uint uVar11;
  bool bVar12;
  char acStackX_8 [16];
  
  uVar5 = GetCurrentThreadId();
  uVar11 = (uVar5 >> 0x10 ^ uVar5) * -0x7a143595;
  uVar11 = (uVar11 >> 0xd ^ uVar11) * -0x3d4d51cb;
  uVar10 = (ulong long)(uVar11 >> 0x10 ^ uVar11);
  systemPreviousNode = *(ulong long **)(param_1 + 0x30);
  for (puVar3 = systemPreviousNode; uVar6 = uVar10, puVar3 != (ulong long *)0x0; puVar3 = (ulong long *)puVar3[2])
  {
    while( true ) {
      uVar6 = uVar6 & *puVar3 - 1;
      uVar11 = *(uint *)(uVar6 * 0x10 + puVar3[1]);
      if (uVar11 == uVar5) {
        lVar8 = *(long long *)(puVar3[1] + 8 + uVar6 * 0x10);
        if (puVar3 == systemPreviousNode) {
          return lVar8;
        }
        do {
          uVar10 = uVar10 & *systemPreviousNode - 1;
          if (*(int *)(systemPreviousNode[1] + uVar10 * 0x10) == 0) {
            puVar2 = (uint *)(systemPreviousNode[1] + uVar10 * 0x10);
            LOCK();
            bVar12 = *puVar2 == 0;
            if (bVar12) {
              *puVar2 = uVar5;
            }
            UNLOCK();
            if (bVar12) {
              *(long long *)(systemPreviousNode[1] + 8 + uVar10 * 0x10) = lVar8;
              return lVar8;
            }
          }
          uVar10 = uVar10 + 1;
        } while( true );
      }
      if (uVar11 == 0) break;
      uVar6 = uVar6 + 1;
    }
  }
  LOCK();
  plVar1 = (long long *)(param_1 + 0x38);
  lVar8 = *plVar1;
  *plVar1 = *plVar1 + 1;
  UNLOCK();
  uVar6 = lVar8 + 1;
  do {
    if (*systemPreviousNode >> 1 <= uVar6) {
      LOCK();
      puVar2 = (uint *)(param_1 + 600);
      uVar11 = *puVar2;
      *puVar2 = *puVar2 | 1;
      UNLOCK();
      if ((uVar11 & 1) == 0) {
        puVar3 = *(ulong long **)(param_1 + 0x30);
        systemPreviousNode = puVar3;
        uVar9 = *puVar3;
        if (*puVar3 >> 1 <= uVar6) {
          do {
            uVar4 = uVar9;
            uVar9 = uVar4 * 2;
          } while ((uVar4 & 0x7fffffffffffffff) <= uVar6);
          systemPreviousNode = (ulong long *)CreateSystemThreadObject(_DAT_180c8ed18,uVar4 * 0x20 + 0x1f,10);
          if (systemPreviousNode == (ulong long *)0x0) {
            LOCK();
            *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + -1;
            UNLOCK();
            *(uint32_t *)(param_1 + 600) = 0;
            return 0;
          }
          *systemPreviousNode = uVar9;
          systemPreviousNode[1] = (ulong long)(-(int)(systemPreviousNode + 3) & 7) + (long long)(systemPreviousNode + 3);
          lVar8 = 0;
          for (; uVar9 != 0; uVar9 = uVar9 - 1) {
            *(void* *)(lVar8 + 8 + systemPreviousNode[1]) = 0;
            *(uint32_t *)(lVar8 + systemPreviousNode[1]) = 0;
            lVar8 = lVar8 + 0x10;
          }
          systemPreviousNode[2] = (ulong long)puVar3;
          *(ulong long **)(param_1 + 0x30) = systemPreviousNode;
        }
        *(uint32_t *)(param_1 + 600) = 0;
      }
    }
    if (uVar6 < (*systemPreviousNode >> 2) + (*systemPreviousNode >> 1)) {
      lVar8 = FUN_18005ee30(param_1,0,acStackX_8);
      if (lVar8 == 0) {
        LOCK();
        *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + -1;
        UNLOCK();
        return 0;
      }
      if (acStackX_8[0] != '\0') {
        LOCK();
        *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + -1;
        UNLOCK();
      }
      do {
        uVar10 = uVar10 & *systemPreviousNode - 1;
        if (*(int *)(systemPreviousNode[1] + uVar10 * 0x10) == 0) {
          puVar2 = (uint *)(systemPreviousNode[1] + uVar10 * 0x10);
          LOCK();
          bVar12 = *puVar2 == 0;
          if (bVar12) {
            *puVar2 = uVar5;
          }
          UNLOCK();
          if (bVar12) {
            *(long long *)(systemPreviousNode[1] + 8 + uVar10 * 0x10) = lVar8;
            return lVar8;
          }
        }
        uVar10 = uVar10 + 1;
      } while( true );
    }
    systemPreviousNode = *(ulong long **)(param_1 + 0x30);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_18005ec11(void)

{
  long long *plVar1;
  uint *puVar2;
  int *piVar3;
  uint uVar4;
  ulong long *puVar5;
  ulong long uVar6;
  long long lVar7;
  ulong long uVar8;
  ulong long uVar9;
  ulong long unaff_RSI;
  ulong long *unaff_RDI;
  long long unaff_R14;
  int unaff_R15D;
  bool bVar10;
  char in_stack_00000050;
  
  LOCK();
  plVar1 = (long long *)(unaff_R14 + 0x38);
  lVar7 = *plVar1;
  *plVar1 = *plVar1 + 1;
  UNLOCK();
  uVar9 = lVar7 + 1;
  while( true ) {
    if (*unaff_RDI >> 1 <= uVar9) {
      LOCK();
      puVar2 = (uint *)(unaff_R14 + 600);
      uVar4 = *puVar2;
      *puVar2 = *puVar2 | 1;
      UNLOCK();
      if ((uVar4 & 1) == 0) {
        puVar5 = *(ulong long **)(unaff_R14 + 0x30);
        unaff_RDI = puVar5;
        uVar8 = *puVar5;
        if (*puVar5 >> 1 <= uVar9) {
          do {
            uVar6 = uVar8;
            uVar8 = uVar6 * 2;
          } while ((uVar6 & 0x7fffffffffffffff) <= uVar9);
          unaff_RDI = (ulong long *)CreateSystemThreadObject(_DAT_180c8ed18,uVar6 * 0x20 + 0x1f,10);
          if (unaff_RDI == (ulong long *)0x0) {
            LOCK();
            *(long long *)(unaff_R14 + 0x38) = *(long long *)(unaff_R14 + 0x38) + -1;
            UNLOCK();
            *(uint32_t *)(unaff_R14 + 600) = 0;
            return 0;
          }
          *unaff_RDI = uVar8;
          unaff_RDI[1] = (ulong long)(-(int)(unaff_RDI + 3) & 7) + (long long)(unaff_RDI + 3);
          lVar7 = 0;
          for (; uVar8 != 0; uVar8 = uVar8 - 1) {
            *(void* *)(lVar7 + 8 + unaff_RDI[1]) = 0;
            *(uint32_t *)(lVar7 + unaff_RDI[1]) = 0;
            lVar7 = lVar7 + 0x10;
          }
          unaff_RDI[2] = (ulong long)puVar5;
          *(ulong long **)(unaff_R14 + 0x30) = unaff_RDI;
        }
        *(uint32_t *)(unaff_R14 + 600) = 0;
      }
    }
    if (uVar9 < (*unaff_RDI >> 2) + (*unaff_RDI >> 1)) break;
    unaff_RDI = *(ulong long **)(unaff_R14 + 0x30);
  }
  lVar7 = FUN_18005ee30();
  if (lVar7 == 0) {
    LOCK();
    *(long long *)(unaff_R14 + 0x38) = *(long long *)(unaff_R14 + 0x38) + -1;
    UNLOCK();
    return 0;
  }
  if (in_stack_00000050 != '\0') {
    LOCK();
    *(long long *)(unaff_R14 + 0x38) = *(long long *)(unaff_R14 + 0x38) + -1;
    UNLOCK();
  }
  do {
    uVar9 = unaff_RSI & *unaff_RDI - 1;
    if (*(int *)(unaff_RDI[1] + uVar9 * 0x10) == 0) {
      piVar3 = (int *)(unaff_RDI[1] + uVar9 * 0x10);
      LOCK();
      bVar10 = *piVar3 == 0;
      if (bVar10) {
        *piVar3 = unaff_R15D;
      }
      UNLOCK();
      if (bVar10) {
        *(long long *)(unaff_RDI[1] + 8 + uVar9 * 0x10) = lVar7;
        return lVar7;
      }
    }
    unaff_RSI = uVar9 + 1;
  } while( true );
}



void* FUN_18005ecfc(void* param_1,void* param_2,long long *param_3)

{
  int *piVar1;
  void* uVar2;
  long long in_RAX;
  ulong long unaff_RSI;
  ulong long uVar3;
  long long *unaff_RDI;
  int unaff_R15D;
  bool bVar4;
  
  uVar2 = *(void* *)(param_3[1] + 8 + in_RAX * 0x10);
  if (param_3 == unaff_RDI) {
    return uVar2;
  }
  do {
    uVar3 = unaff_RSI & *unaff_RDI - 1U;
    if (*(int *)(unaff_RDI[1] + uVar3 * 0x10) == 0) {
      piVar1 = (int *)(unaff_RDI[1] + uVar3 * 0x10);
      LOCK();
      bVar4 = *piVar1 == 0;
      if (bVar4) {
        *piVar1 = unaff_R15D;
      }
      UNLOCK();
      if (bVar4) {
        *(void* *)(unaff_RDI[1] + 8 + uVar3 * 0x10) = uVar2;
        return uVar2;
      }
    }
    unaff_RSI = uVar3 + 1;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_18005ed54(void)

{
  uint *puVar1;
  int *piVar2;
  uint uVar3;
  ulong long *puVar4;
  ulong long uVar5;
  long long lVar6;
  ulong long uVar7;
  ulong long unaff_RBP;
  ulong long unaff_RSI;
  ulong long *unaff_RDI;
  uint32_t uVar8;
  long long unaff_R12;
  long long unaff_R14;
  int unaff_R15D;
  bool bVar9;
  char in_stack_00000050;
  
  while( true ) {
    do {
      uVar8 = (uint32_t)unaff_R12;
      *(uint32_t *)(unaff_R14 + 600) = uVar8;
      do {
        do {
          if (unaff_RBP < (*unaff_RDI >> 2) + (*unaff_RDI >> 1)) {
            lVar6 = FUN_18005ee30();
            if (lVar6 == 0) {
              LOCK();
              *(long long *)(unaff_R14 + 0x38) = *(long long *)(unaff_R14 + 0x38) + -1;
              UNLOCK();
              return 0;
            }
            if (in_stack_00000050 != (char)unaff_R12) {
              LOCK();
              *(long long *)(unaff_R14 + 0x38) = *(long long *)(unaff_R14 + 0x38) + -1;
              UNLOCK();
            }
            do {
              uVar7 = unaff_RSI & *unaff_RDI - 1;
              if (*(int *)(unaff_RDI[1] + uVar7 * 0x10) == 0) {
                piVar2 = (int *)(unaff_RDI[1] + uVar7 * 0x10);
                LOCK();
                bVar9 = *piVar2 == 0;
                if (bVar9) {
                  *piVar2 = unaff_R15D;
                }
                UNLOCK();
                if (bVar9) {
                  *(long long *)(unaff_RDI[1] + 8 + uVar7 * 0x10) = lVar6;
                  return lVar6;
                }
              }
              unaff_RSI = uVar7 + 1;
            } while( true );
          }
          unaff_RDI = *(ulong long **)(unaff_R14 + 0x30);
        } while (unaff_RBP < *unaff_RDI >> 1);
        LOCK();
        puVar1 = (uint *)(unaff_R14 + 600);
        uVar3 = *puVar1;
        *puVar1 = *puVar1 | 1;
        UNLOCK();
      } while ((uVar3 & 1) != 0);
      puVar4 = *(ulong long **)(unaff_R14 + 0x30);
      unaff_RDI = puVar4;
      uVar7 = *puVar4;
    } while (unaff_RBP < *puVar4 >> 1);
    do {
      uVar5 = uVar7;
      uVar7 = uVar5 * 2;
    } while ((uVar5 & 0x7fffffffffffffff) <= unaff_RBP);
    unaff_RDI = (ulong long *)CreateSystemThreadObject(_DAT_180c8ed18,uVar5 * 0x20 + 0x1f,10);
    if (unaff_RDI == (ulong long *)0x0) break;
    *unaff_RDI = uVar7;
    unaff_RDI[1] = (ulong long)(-(int)(unaff_RDI + 3) & 7) + (long long)(unaff_RDI + 3);
    lVar6 = unaff_R12;
    for (; uVar7 != 0; uVar7 = uVar7 - 1) {
      *(long long *)(lVar6 + 8 + unaff_RDI[1]) = unaff_R12;
      *(uint32_t *)(lVar6 + unaff_RDI[1]) = uVar8;
      lVar6 = lVar6 + 0x10;
    }
    unaff_RDI[2] = (ulong long)puVar4;
    *(ulong long **)(unaff_R14 + 0x30) = unaff_RDI;
  }
  LOCK();
  *(long long *)(unaff_R14 + 0x38) = *(long long *)(unaff_R14 + 0x38) + -1;
  UNLOCK();
  *(uint32_t *)(unaff_R14 + 600) = uVar8;
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_18005ee30(long long *param_1,char param_2,uint8_t *param_3)

{
  long long *plVar1;
  void** systemDataTable;
  long long lVar3;
  long long lVar4;
  void* *puVar5;
  void** systemRootNode;
  ulong long uVar7;
  ulong long uVar8;
  bool bVar9;
  
  puVar6 = (void* *)0x0;
  puVar2 = (void* *)*param_1;
  do {
    if (puVar2 == (void* *)0x0) {
      *param_3 = 0;
      if (param_2 == '\0') {
        puVar2 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x68,10,0,0xfffffffffffffffe);
        if (puVar2 == (void* *)0x0) {
          return (void* *)0x0;
        }
        puVar2[1] = 0;
        *(uint8_t *)(puVar2 + 2) = 0;
        puVar2[3] = 0;
        *puVar2 = &UNK_1809fe210;
        puVar2[4] = 0;
        puVar2[5] = 0;
        puVar2[6] = 0;
        puVar2[7] = 0;
        puVar2[8] = 0;
        *(uint8_t *)(puVar2 + 9) = 0;
        puVar2[10] = param_1;
        *puVar2 = &UNK_1809fe200;
        puVar2[0xb] = 0x20;
        puVar2[0xc] = 0;
        FUN_18005f430(puVar2);
      }
      else {
        puVar2 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x88,10,0,0xfffffffffffffffe);
        if (puVar2 == (void* *)0x0) {
          return (void* *)0x0;
        }
        puVar2[1] = 0;
        *(uint8_t *)(puVar2 + 2) = 0;
        puVar2[3] = 0;
        *puVar2 = &UNK_1809fe210;
        puVar2[4] = 0;
        puVar2[5] = 0;
        puVar2[6] = 0;
        puVar2[7] = 0;
        puVar2[8] = 0;
        *(uint8_t *)(puVar2 + 9) = 1;
        puVar2[10] = param_1;
        *puVar2 = &UNK_1809fe1f0;
        puVar2[0xb] = 0;
        puVar2[0xc] = 0;
        puVar2[0xd] = 0x10;
        puVar2[0xe] = 0;
        puVar2[0xf] = 0;
        puVar2[0x10] = 0;
        uVar7 = param_1[4] - 1U | param_1[4] - 1U >> 1;
        uVar7 = uVar7 | uVar7 >> 2;
        uVar7 = uVar7 | uVar7 >> 4;
        uVar8 = 1;
        do {
          uVar7 = uVar7 | uVar7 >> (((byte)uVar8 & 7) << 3);
          uVar8 = uVar8 * 2;
        } while (uVar8 < 8);
        uVar8 = uVar7 + 1 >> 1;
        if ((ulong long)puVar2[0xd] < uVar8) {
          puVar2[0xd] = uVar8;
        }
        FUN_18005f340(puVar2,0);
      }
      puVar5 = puVar6;
      if (puVar2 != (void* *)0x0) {
        LOCK();
        *(int *)(param_1 + 1) = (int)param_1[1] + 1;
        UNLOCK();
        lVar3 = *param_1;
        do {
          puVar5 = (void* *)(lVar3 + 8);
          if (lVar3 == 0) {
            puVar5 = puVar6;
          }
          puVar2[1] = puVar5;
          LOCK();
          lVar4 = *param_1;
          bVar9 = lVar3 == lVar4;
          if (bVar9) {
            *param_1 = (long long)puVar2;
            lVar4 = lVar3;
          }
          UNLOCK();
          lVar3 = lVar4;
          puVar5 = puVar2;
        } while (!bVar9);
      }
      return puVar5;
    }
    if ((*(char *)(puVar2 + 2) != '\0') && (*(char *)(puVar2 + 9) == param_2)) {
      LOCK();
      bVar9 = *(char *)(puVar2 + 2) == '\x01';
      if (bVar9) {
        *(char *)(puVar2 + 2) = '\0';
      }
      UNLOCK();
      if (bVar9) {
        *param_3 = 1;
        return puVar2;
      }
    }
    plVar1 = puVar2 + 1;
    puVar2 = (void* *)(*plVar1 + -8);
    if (*plVar1 == 0) {
      puVar2 = puVar6;
    }
  } while( true );
}



void* FUN_18005f040(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  ulong long uVar1;
  char cVar2;
  long long lVar3;
  ulong long uVar4;
  ulong long *puVar5;
  ulong long uVar6;
  ulong long uVar7;
  
  uVar1 = *(ulong long *)(param_1 + 0x20);
  uVar7 = (ulong long)((uint)uVar1 & 0x1f);
  if ((uVar1 & 0x1f) == 0) {
    uVar6 = 0;
    if (*(long long *)(param_1 + 0x40) == 0) {
LAB_18005f0e6:
      if ((((*(long long *)(param_1 + 0x28) - uVar1) - 0x20 < 0x8000000000000001) ||
          (((*(long long *)(param_1 + 0x80) == 0 ||
            (*(long long *)(param_1 + 0x60) == *(long long *)(param_1 + 0x68))) &&
           (cVar2 = FUN_18005f340(param_1,*(void* *)(param_1 + 0x60),uVar7,param_4,
                                  0xfffffffffffffffe), cVar2 == '\0')))) ||
         (lVar3 = FUN_18005ff50(*(void* *)(param_1 + 0x50)), lVar3 == 0)) {
        return 0;
      }
      do {
        *(uint8_t *)(lVar3 + 0x110 + uVar6) = 0;
        uVar6 = uVar6 + 1;
      } while (uVar6 != 0x20);
      if (*(long long *)(param_1 + 0x40) == 0) {
        *(long long *)(lVar3 + 0x100) = lVar3;
      }
      else {
        *(void* *)(lVar3 + 0x100) = *(void* *)(*(long long *)(param_1 + 0x40) + 0x100);
        *(long long *)(*(long long *)(param_1 + 0x40) + 0x100) = lVar3;
      }
      *(long long *)(param_1 + 0x40) = lVar3;
      *(long long *)(param_1 + 0x60) = *(long long *)(param_1 + 0x60) + 1;
    }
    else {
      uVar4 = uVar6;
      do {
        if (*(char *)(*(long long *)(*(long long *)(param_1 + 0x40) + 0x100) + 0x110 + uVar4) == '\0')
        goto LAB_18005f0e6;
        uVar4 = uVar4 + 1;
      } while (uVar4 < 0x20);
      lVar3 = *(long long *)(*(long long *)(param_1 + 0x40) + 0x100);
      *(long long *)(param_1 + 0x40) = lVar3;
      do {
        *(uint8_t *)(lVar3 + 0x110 + uVar6) = 0;
        uVar6 = uVar6 + 1;
      } while (uVar6 != 0x20);
    }
    param_2 = (long long *)*param_2;
    **(long long **)(param_1 + 0x40) = (long long)param_2;
    if (param_2 != (long long *)0x0) {
      (**(code **)(*param_2 + 0x28))();
    }
    puVar5 = (ulong long *)
             (*(long long *)(param_1 + 0x70) * 0x10 +
             *(long long *)(*(long long *)(param_1 + 0x58) + 0x10));
    *puVar5 = uVar1;
    puVar5[1] = *(ulong long *)(param_1 + 0x40);
    *(void* *)(*(long long *)(param_1 + 0x58) + 8) = *(void* *)(param_1 + 0x70);
    *(ulong long *)(param_1 + 0x70) =
         *(long long *)(param_1 + 0x68) - 1U & *(long long *)(param_1 + 0x70) + 1U;
  }
  else {
    param_2 = (long long *)*param_2;
    *(long long **)(*(long long *)(param_1 + 0x40) + uVar7 * 8) = param_2;
    if (param_2 != (long long *)0x0) {
      (**(code **)(*param_2 + 0x28))();
    }
  }
  *(ulong long *)(param_1 + 0x20) = uVar1 + 1;
  return 1;
}



void* FUN_18005f220(long long param_1,long long *param_2)

{
  ulong long uVar1;
  char cVar2;
  long long *plVar3;
  ulong long uVar4;
  ulong long uStackX_18;
  long long *plStackX_20;
  
  uVar1 = *(ulong long *)(param_1 + 0x20);
  uVar4 = (ulong long)((uint)uVar1 & 0x1f);
  if ((uVar1 & 0x1f) != 0) {
    param_2 = (long long *)*param_2;
    *(long long **)(*(long long *)(param_1 + 0x40) + uVar4 * 8) = param_2;
    if (param_2 != (long long *)0x0) {
      (**(code **)(*param_2 + 0x28))();
    }
LAB_18005f30a:
    *(ulong long *)(param_1 + 0x20) = uVar1 + 1;
    return 1;
  }
  if (0x8000000000000000 < (*(long long *)(param_1 + 0x28) - uVar1) - 0x20) {
    cVar2 = FUN_180060080(param_1,&uStackX_18,uVar1,uVar4,0xfffffffffffffffe);
    if (cVar2 != '\0') {
      plVar3 = (long long *)FUN_18005ff50(*(void* *)(param_1 + 0x50));
      if (plVar3 != (long long *)0x0) {
        plVar3[0x21] = 0;
        param_2 = (long long *)*param_2;
        *plVar3 = (long long)param_2;
        if (param_2 != (long long *)0x0) {
          plStackX_20 = plVar3;
          (**(code **)(*param_2 + 0x28))();
        }
        *(long long **)(uStackX_18 + 8) = plVar3;
        *(long long **)(param_1 + 0x40) = plVar3;
        goto LAB_18005f30a;
      }
      plVar3 = *(long long **)(param_1 + 0x60);
      plVar3[1] = *plVar3 - 1U & plVar3[1] - 1U;
      *(void* *)(uStackX_18 + 8) = 0;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_18005f340(long long param_1,long long param_2)

{
  void* *puVar1;
  long long lVar2;
  void* uVar3;
  void* *puVar4;
  ulong long uVar5;
  ulong long uVar6;
  void** systemCurrentNode;
  void** systemNextNode;
  long long lVar9;
  
  lVar2 = *(long long *)(param_1 + 0x68);
  *(long long *)(param_1 + 0x68) = lVar2 * 2;
  puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,lVar2 * 0x20 + 0x27,10);
  if (puVar4 == (void* *)0x0) {
    *(ulong long *)(param_1 + 0x68) = *(ulong long *)(param_1 + 0x68) >> 1;
    return 0;
  }
  lVar9 = 0;
  systemPreviousNode = (void* *)((ulong long)(-(int)(puVar4 + 4) & 7) + (long long)(puVar4 + 4));
  if (*(long long *)(param_1 + 0x60) != 0) {
    uVar5 = *(long long *)(param_1 + 0x70) - *(long long *)(param_1 + 0x60) & lVar2 - 1U;
    puVar8 = systemPreviousNode;
    do {
      lVar9 = lVar9 + 1;
      uVar6 = uVar5 + 1 & lVar2 - 1U;
      puVar1 = (void* *)(*(long long *)(param_1 + 0x78) + uVar5 * 0x10);
      uVar3 = puVar1[1];
      *puVar8 = *puVar1;
      puVar8[1] = uVar3;
      uVar5 = uVar6;
      puVar8 = puVar8 + 2;
    } while (uVar6 != *(ulong long *)(param_1 + 0x70));
  }
  *puVar4 = *(void* *)(param_1 + 0x68);
  puVar4[1] = param_2 + -1;
  puVar4[2] = systemPreviousNode;
  uVar3 = *(void* *)(param_1 + 0x80);
  puVar4[3] = uVar3;
  *(long long *)(param_1 + 0x70) = lVar9;
  *(void* **)(param_1 + 0x78) = systemPreviousNode;
  *(void* **)(param_1 + 0x80) = puVar4;
  *(void* **)(param_1 + 0x58) = puVar4;
  return CONCAT71((int7)((ulong long)uVar3 >> 8),1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_18005f430(long long param_1)

{
  long long *plVar1;
  ulong long uVar2;
  long long lVar3;
  void* *puVar4;
  void* *puVar5;
  void** systemRootNode;
  ulong long uVar7;
  long long lVar8;
  long long lVar9;
  void* *puVar10;
  void* *puVar11;
  
  plVar1 = *(long long **)(param_1 + 0x60);
  if (plVar1 == (long long *)0x0) {
    lVar3 = *(long long *)(param_1 + 0x58);
    lVar8 = lVar3;
    lVar9 = 0;
  }
  else {
    lVar8 = *plVar1;
    lVar3 = *(long long *)(param_1 + 0x58);
    lVar9 = lVar8;
  }
  puVar4 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,(lVar3 + lVar8 * 2) * 8 + 0x36,10);
  puVar10 = puVar4;
  if (puVar4 != (void* *)0x0) {
    puVar11 = (void* *)((ulong long)(-(int)(puVar4 + 5) & 7) + (long long)(puVar4 + 5));
    puVar10 = (void* *)
              ((ulong long)(-(int)(puVar11 + lVar8 * 2) & 7) + (long long)(puVar11 + lVar8 * 2));
    if (plVar1 != (long long *)0x0) {
      uVar2 = plVar1[1];
      uVar7 = uVar2;
      puVar6 = puVar10;
      do {
        uVar7 = *plVar1 - 1U & uVar7 + 1;
        *puVar6 = *(void* *)(plVar1[3] + uVar7 * 8);
        puVar6 = puVar6 + 1;
      } while (uVar7 != uVar2);
    }
    if (lVar8 != 0) {
      puVar6 = puVar10 + lVar9;
      puVar5 = puVar11;
      do {
        *puVar5 = 1;
        *puVar6 = puVar5;
        puVar6 = puVar6 + 1;
        puVar5 = puVar5 + 2;
        lVar8 = lVar8 + -1;
      } while (lVar8 != 0);
    }
    puVar4[4] = plVar1;
    puVar4[2] = puVar11;
    puVar4[3] = puVar10;
    *puVar4 = *(void* *)(param_1 + 0x58);
    puVar4[1] = *(long long *)(param_1 + 0x58) - 1U & lVar9 - 1U;
    puVar10 = (void* *)CONCAT71((int7)(lVar9 - 1U >> 8),1);
    *(void* **)(param_1 + 0x60) = puVar4;
    *(long long *)(param_1 + 0x58) = *(long long *)(param_1 + 0x58) << 1;
  }
  return puVar10;
}



void* FUN_18005f490(void)

{
  ulong long uVar1;
  long long in_RAX;
  void** systemDataTable;
  void* *puVar3;
  ulong long uVar4;
  long long unaff_RBX;
  long long unaff_RBP;
  long long unaff_RSI;
  long long *unaff_RDI;
  void* *in_R9;
  void* *puVar5;
  void** systemRootNode;
  
  puVar6 = (void* *)((ulong long)(-(int)in_RAX & 7) + in_RAX);
  puVar5 = (void* *)
           ((ulong long)(-(int)(puVar6 + unaff_RBX * 2) & 7) + (long long)(puVar6 + unaff_RBX * 2));
  if (unaff_RDI != (long long *)0x0) {
    uVar1 = unaff_RDI[1];
    uVar4 = uVar1;
    puVar3 = puVar5;
    do {
      uVar4 = *unaff_RDI - 1U & uVar4 + 1;
      *puVar3 = *(void* *)(unaff_RDI[3] + uVar4 * 8);
      puVar3 = puVar3 + 1;
    } while (uVar4 != uVar1);
  }
  if (unaff_RBX != 0) {
    puVar3 = puVar5 + unaff_RBP;
    puVar2 = puVar6;
    do {
      *puVar2 = 1;
      *puVar3 = puVar2;
      puVar3 = puVar3 + 1;
      puVar2 = puVar2 + 2;
      unaff_RBX = unaff_RBX + -1;
    } while (unaff_RBX != 0);
  }
  in_R9[4] = unaff_RDI;
  in_R9[2] = puVar6;
  in_R9[3] = puVar5;
  *in_R9 = *(void* *)(unaff_RSI + 0x58);
  in_R9[1] = *(long long *)(unaff_RSI + 0x58) - 1U & unaff_RBP - 1U;
  *(void* **)(unaff_RSI + 0x60) = in_R9;
  *(long long *)(unaff_RSI + 0x58) = *(long long *)(unaff_RSI + 0x58) << 1;
  return CONCAT71((int7)(unaff_RBP - 1U >> 8),1);
}




// 函数: void FUN_18005f54c(void)
void FUN_18005f54c(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18005f570(long long param_1,long long *param_2,long long param_3)

{
  uint *puVar1;
  uint32_t *puVar2;
  uint uVar3;
  uint uVar4;
  long long *plVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  long long *plVar9;
  ulong long uVar10;
  long long lVar11;
  ulong long uVar12;
  ulong long uVar13;
  ulong long uVar14;
  ulong long uVar15;
  ulong long uVar16;
  ulong long *puVar17;
  ulong long uVar18;
  ulong long uVar19;
  ulong long uVar20;
  uint32_t *puVar21;
  uint32_t *puVar22;
  long long lVar23;
  long long lVar24;
  ulong long uVar25;
  bool bVar26;
  ulong long uStack_78;
  ulong long uStack_68;
  
  uVar25 = *(ulong long *)(param_1 + 0x20);
  uVar13 = *(ulong long *)(param_1 + 0x40);
  uVar16 = *(ulong long *)(param_1 + 0x70);
  uVar12 = *(ulong long *)(param_1 + 0x60);
  uVar18 = 0;
  uVar19 = param_3 + uVar25;
  uStack_78 = uVar25 - 1 & 0xffffffffffffffe0;
  lVar24 = (uVar19 - 1 & 0xffffffffffffffe0) - uStack_78;
  uVar10 = uVar18;
  uVar20 = uVar18;
  uVar15 = uVar13;
  if (lVar24 != 0) {
    do {
      uStack_68 = uVar16;
      uVar20 = uVar10;
      if ((*(long long *)(param_1 + 0x40) == 0) ||
         (uVar15 = *(ulong long *)(*(long long *)(param_1 + 0x40) + 0x100), uVar14 = uVar18,
         uVar15 == uVar10)) goto joined_r0x00018005f6ef;
      do {
        if (*(char *)(uVar15 + 0x110 + uVar14) == '\0') goto joined_r0x00018005f6ef;
        uVar14 = uVar14 + 1;
      } while (uVar14 < 0x20);
      uStack_78 = uStack_78 + 0x20;
      uVar20 = *(ulong long *)(*(long long *)(param_1 + 0x40) + 0x100);
      *(ulong long *)(param_1 + 0x40) = uVar20;
      puVar17 = (ulong long *)
                (*(long long *)(*(long long *)(param_1 + 0x58) + 0x10) +
                *(long long *)(param_1 + 0x70) * 0x10);
      *puVar17 = uStack_78;
      puVar17[1] = *(ulong long *)(param_1 + 0x40);
      *(ulong long *)(param_1 + 0x70) =
           *(long long *)(param_1 + 0x68) - 1U & *(long long *)(param_1 + 0x70) + 1U;
      if (uVar10 != 0) {
        uVar20 = uVar10;
      }
      lVar24 = lVar24 + -0x20;
      uVar10 = uVar20;
    } while (lVar24 != 0);
LAB_18005f6a2:
    lVar24 = 0;
    uVar16 = uVar20;
    while( true ) {
      do {
        *(uint8_t *)(uVar16 + 0x110 + lVar24) = 0;
        lVar24 = lVar24 + 1;
      } while (lVar24 != 0x20);
      uVar15 = *(ulong long *)(param_1 + 0x40);
      if (uVar16 == uVar15) break;
      uVar16 = *(ulong long *)(uVar16 + 0x100);
      lVar24 = 0;
    }
  }
  *(ulong long *)(param_1 + 0x40) = uVar13;
  if ((uVar25 & 0x1f) == 0) {
    if (uVar20 != 0) {
      uVar13 = uVar20;
    }
    *(ulong long *)(param_1 + 0x40) = uVar13;
  }
  while( true ) {
    uVar16 = (uVar25 & 0xffffffffffffffe0) + 0x20;
    uVar13 = uVar19;
    if (uVar19 - uVar16 < 0x8000000000000001) {
      uVar13 = uVar16;
    }
    for (; uVar25 != uVar13; uVar25 = uVar25 + 1) {
      plVar5 = (long long *)*param_2;
      *(long long **)(*(long long *)(param_1 + 0x40) + (ulong long)((uint)uVar25 & 0x1f) * 8) = plVar5;
      if (plVar5 != (long long *)0x0) {
        (**(code **)(*plVar5 + 0x28))();
      }
      param_2 = param_2 + 1;
    }
    uVar13 = *(ulong long *)(param_1 + 0x40);
    if (uVar13 == uVar15) break;
    *(void* *)(param_1 + 0x40) = *(void* *)(uVar13 + 0x100);
  }
  if (uVar20 != 0) {
    uVar13 = *(long long *)(param_1 + 0x68) - 1;
    *(ulong long *)(*(long long *)(param_1 + 0x58) + 8) = *(long long *)(param_1 + 0x70) - 1U & uVar13;
  }
  *(ulong long *)(param_1 + 0x20) = uVar19;
  return CONCAT71((int7)(uVar13 >> 8),1);
joined_r0x00018005f6ef:
  if (lVar24 == 0) goto LAB_18005f6a2;
  lVar24 = lVar24 + -0x20;
  uStack_78 = uStack_78 + 0x20;
  uVar15 = (*(long long *)(param_1 + 0x28) - uStack_78) - 0x20;
  plVar5 = (long long *)(param_1 + 0x68);
  if ((*(long long *)(param_1 + 0x80) == 0) || (*(long long *)(param_1 + 0x60) == *plVar5)) {
    if (0x8000000000000000 < uVar15) {
      lVar11 = *plVar5;
      *plVar5 = lVar11 * 2;
      plVar9 = (long long *)CreateSystemThreadObject(_DAT_180c8ed18,lVar11 * 0x20 + 0x27,10);
      if (plVar9 != (long long *)0x0) {
        puVar22 = (uint32_t *)((ulong long)(-(int)(plVar9 + 4) & 7) + (long long)(plVar9 + 4));
        lVar23 = 0;
        if (*(long long *)(param_1 + 0x60) != 0) {
          uVar16 = *(long long *)(param_1 + 0x70) - *(long long *)(param_1 + 0x60) & lVar11 - 1U;
          puVar21 = puVar22;
          do {
            puVar2 = (uint32_t *)(*(long long *)(param_1 + 0x78) + uVar16 * 0x10);
            uVar6 = puVar2[1];
            uVar7 = puVar2[2];
            uVar8 = puVar2[3];
            *puVar21 = *puVar2;
            puVar21[1] = uVar6;
            puVar21[2] = uVar7;
            puVar21[3] = uVar8;
            lVar23 = lVar23 + 1;
            puVar21 = puVar21 + 4;
            uVar16 = uVar16 + 1 & lVar11 - 1U;
          } while (uVar16 != *(ulong long *)(param_1 + 0x70));
        }
        *plVar9 = *plVar5;
        plVar9[1] = uVar12 - 1;
        plVar9[2] = (long long)puVar22;
        plVar9[3] = *(long long *)(param_1 + 0x80);
        *(long long *)(param_1 + 0x70) = lVar23;
        *(uint32_t **)(param_1 + 0x78) = puVar22;
        *(long long **)(param_1 + 0x80) = plVar9;
        *(long long **)(param_1 + 0x58) = plVar9;
        uVar16 = uVar12;
        uStack_68 = uVar12;
        goto LAB_18005f818;
      }
      *(ulong long *)(param_1 + 0x68) = *(ulong long *)(param_1 + 0x68) >> 1;
      uVar16 = uStack_68;
    }
LAB_18005fa1c:
    *(ulong long *)(param_1 + 0x70) = uVar16;
    *(ulong long *)(param_1 + 0x60) = uVar12;
    if (uVar13 == 0) {
      uVar13 = uVar20;
    }
    *(ulong long *)(param_1 + 0x40) = uVar13;
LAB_18005fa01:
    return uVar12 & 0xffffffffffffff00;
  }
  if (uVar15 < 0x8000000000000001) goto LAB_18005fa1c;
LAB_18005f818:
  lVar11 = *(long long *)(param_1 + 0x50);
  if (*(ulong long *)(lVar11 + 0x20) <= *(ulong long *)(lVar11 + 0x10)) {
LAB_18005f848:
    uVar10 = *(ulong long *)(lVar11 + 0x28);
LAB_18005f84c:
    uVar15 = uVar10;
    if (uVar15 != 0) {
      puVar1 = (uint *)(uVar15 + 0x130);
      uVar4 = *puVar1;
      if ((uVar4 & 0x7fffffff) == 0) {
LAB_18005f8c7:
        uVar10 = *(ulong long *)(lVar11 + 0x28);
      }
      else {
        LOCK();
        uVar3 = *puVar1;
        if (uVar4 == uVar3) {
          *puVar1 = uVar4 + 1;
        }
        UNLOCK();
        if (uVar4 != uVar3) goto LAB_18005f8c7;
        LOCK();
        uVar10 = *(ulong long *)(lVar11 + 0x28);
        bVar26 = uVar15 == uVar10;
        if (bVar26) {
          *(ulong long *)(lVar11 + 0x28) = *(ulong long *)(uVar15 + 0x138);
          uVar10 = uVar15;
        }
        UNLOCK();
        if (bVar26) {
          LOCK();
          *puVar1 = *puVar1 - 2;
          UNLOCK();
          if (uVar15 != 0) goto LAB_18005f92b;
          goto LAB_18005f8e3;
        }
        LOCK();
        uVar4 = *puVar1;
        *puVar1 = *puVar1 - 1;
        UNLOCK();
        if (uVar4 == 0x80000001) {
          uVar18 = *(ulong long *)(lVar11 + 0x28);
          do {
            *(ulong long *)(uVar15 + 0x138) = uVar18;
            *puVar1 = 1;
            LOCK();
            uVar14 = *(ulong long *)(lVar11 + 0x28);
            bVar26 = uVar18 == uVar14;
            if (bVar26) {
              *(ulong long *)(lVar11 + 0x28) = uVar15;
              uVar14 = uVar18;
            }
            UNLOCK();
            if (bVar26) break;
            LOCK();
            uVar4 = *puVar1;
            *puVar1 = *puVar1 + 0x7fffffff;
            UNLOCK();
            uVar18 = uVar14;
          } while (uVar4 == 1);
        }
      }
      goto LAB_18005f84c;
    }
LAB_18005f8e3:
    uVar15 = CreateSystemThreadObject(_DAT_180c8ed18,0x148,CONCAT71((int7)(uVar15 >> 8),10));
    if (uVar15 != 0) {
      *(void* *)(uVar15 + 0x100) = 0;
      *(void* *)(uVar15 + 0x108) = 0;
      *(uint32_t *)(uVar15 + 0x130) = 0;
      *(void* *)(uVar15 + 0x138) = 0;
      *(undefined2 *)(uVar15 + 0x140) = 0x100;
      goto LAB_18005f92b;
    }
LAB_18005f9e1:
    *(ulong long *)(param_1 + 0x70) = uVar16;
    *(ulong long *)(param_1 + 0x60) = uVar12;
    uVar12 = uVar13;
    if (uVar13 == 0) {
      uVar12 = uVar20;
    }
    *(ulong long *)(param_1 + 0x40) = uVar12;
    goto LAB_18005fa01;
  }
  LOCK();
  puVar17 = (ulong long *)(lVar11 + 0x10);
  uVar15 = *puVar17;
  *puVar17 = *puVar17 + 1;
  UNLOCK();
  if ((*(ulong long *)(lVar11 + 0x20) <= uVar15) ||
     (uVar15 = uVar15 * 0x148 + *(long long *)(lVar11 + 0x18), uVar15 == 0)) goto LAB_18005f848;
LAB_18005f92b:
  lVar11 = 0;
  if (uVar15 == 0) goto LAB_18005f9e1;
  do {
    *(uint8_t *)(uVar15 + 0x110 + lVar11) = 1;
    lVar11 = lVar11 + 1;
  } while (lVar11 != 0x20);
  if (*(long long *)(param_1 + 0x40) == 0) {
    *(ulong long *)(uVar15 + 0x100) = uVar15;
  }
  else {
    *(void* *)(uVar15 + 0x100) = *(void* *)(*(long long *)(param_1 + 0x40) + 0x100);
    *(ulong long *)(*(long long *)(param_1 + 0x40) + 0x100) = uVar15;
  }
  *(ulong long *)(param_1 + 0x40) = uVar15;
  if (uVar20 != 0) {
    uVar15 = uVar20;
  }
  *(long long *)(param_1 + 0x60) = *(long long *)(param_1 + 0x60) + 1;
  puVar17 = (ulong long *)
            (*(long long *)(*(long long *)(param_1 + 0x58) + 0x10) +
            *(long long *)(param_1 + 0x70) * 0x10);
  *puVar17 = uStack_78;
  puVar17[1] = *(ulong long *)(param_1 + 0x40);
  *(ulong long *)(param_1 + 0x70) = *(long long *)(param_1 + 0x70) + 1U & *plVar5 - 1U;
  uVar20 = uVar15;
  goto joined_r0x00018005f6ef;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18005fb30(long long param_1,long long *param_2,long long param_3)

{
  ulong long *puVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  long long *plVar5;
  long long lVar6;
  ulong long uVar7;
  ulong long uVar8;
  char cVar9;
  ulong long uVar10;
  ulong long uVar11;
  ulong long uVar12;
  ulong long uVar13;
  ulong long uVar14;
  ulong long uVar15;
  ulong long uVar16;
  ulong long uVar17;
  ulong long uVar18;
  long long lVar19;
  ulong long *puVar20;
  bool bVar21;
  
  uVar16 = *(ulong long *)(param_1 + 0x20);
  uVar17 = *(ulong long *)(param_1 + 0x40);
  uVar13 = uVar16 + param_3;
  uVar18 = uVar16 - 1 & 0xffffffffffffffe0;
  lVar19 = (uVar13 - 1 & 0xffffffffffffffe0) - uVar18;
  uVar14 = uVar17;
  uVar10 = uVar18;
  uVar7 = 0;
  while( true ) {
    if (lVar19 == 0) {
      *(ulong long *)(param_1 + 0x40) = uVar17;
      if ((uVar16 & 0x1f) == 0) {
        if (uVar7 != 0) {
          uVar17 = uVar7;
        }
        *(ulong long *)(param_1 + 0x40) = uVar17;
      }
      while( true ) {
        uVar10 = (uVar16 & 0xffffffffffffffe0) + 0x20;
        uVar17 = uVar13;
        if (uVar13 - uVar10 < 0x8000000000000001) {
          uVar17 = uVar10;
        }
        for (; uVar16 != uVar17; uVar16 = uVar16 + 1) {
          plVar5 = (long long *)*param_2;
          *(long long **)(*(long long *)(param_1 + 0x40) + (ulong long)((uint)uVar16 & 0x1f) * 8) =
               plVar5;
          if (plVar5 != (long long *)0x0) {
            (**(code **)(*plVar5 + 0x28))();
          }
          param_2 = param_2 + 1;
        }
        uVar17 = *(ulong long *)(param_1 + 0x40);
        if (uVar17 == uVar14) break;
        *(void* *)(param_1 + 0x40) = *(void* *)(uVar17 + 0x100);
      }
      *(ulong long *)(param_1 + 0x20) = uVar13;
      return CONCAT71((int7)(uVar17 >> 8),1);
    }
    lVar19 = lVar19 + -0x20;
    uVar10 = uVar10 + 0x20;
    uVar8 = uVar7;
    if (((*(long long *)(param_1 + 0x28) - uVar10) - 0x20 < 0x8000000000000001) ||
       (plVar5 = *(long long **)(param_1 + 0x60), plVar5 == (long long *)0x0))
    goto joined_r0x00018005fdcd;
    uVar14 = *plVar5 - 1U & plVar5[1] + 1U;
    puVar20 = *(ulong long **)(plVar5[3] + uVar14 * 8);
    if ((*puVar20 == 1) || (puVar20[1] == 0)) {
      *puVar20 = uVar10;
      plVar5[1] = uVar14;
    }
    else {
      cVar9 = FUN_18005f430(param_1);
      if (cVar9 == '\0') goto joined_r0x00018005fdcd;
      plVar5 = *(long long **)(param_1 + 0x60);
      uVar14 = *plVar5 - 1U & plVar5[1] + 1U;
      puVar20 = *(ulong long **)(plVar5[3] + uVar14 * 8);
      *puVar20 = uVar10;
      plVar5[1] = uVar14;
    }
    lVar6 = *(long long *)(param_1 + 0x50);
    if (*(ulong long *)(lVar6 + 0x20) <= *(ulong long *)(lVar6 + 0x10)) break;
    LOCK();
    puVar1 = (ulong long *)(lVar6 + 0x10);
    uVar14 = *puVar1;
    *puVar1 = *puVar1 + 1;
    UNLOCK();
    if ((*(ulong long *)(lVar6 + 0x20) <= uVar14) ||
       (uVar14 = uVar14 * 0x148 + *(long long *)(lVar6 + 0x18), uVar14 == 0)) break;
LAB_18005fd51:
    if (uVar14 == 0) goto LAB_18005fda6;
LAB_18005fd56:
    *(void* *)(uVar14 + 0x108) = 0;
    *(void* *)(uVar14 + 0x100) = 0;
    puVar20[1] = uVar14;
    if (((uVar16 & 0x1f) != 0) || (uVar7 != 0)) {
      *(ulong long *)(*(long long *)(param_1 + 0x40) + 0x100) = uVar14;
    }
    *(ulong long *)(param_1 + 0x40) = uVar14;
    if (uVar7 == 0) {
      uVar7 = uVar14;
    }
  }
  uVar11 = *(ulong long *)(lVar6 + 0x28);
LAB_18005fc81:
  uVar14 = uVar11;
  if (uVar14 != 0) {
    puVar2 = (uint *)(uVar14 + 0x130);
    uVar4 = *puVar2;
    if ((uVar4 & 0x7fffffff) == 0) {
LAB_18005fcf9:
      uVar11 = *(ulong long *)(lVar6 + 0x28);
    }
    else {
      LOCK();
      uVar3 = *puVar2;
      if (uVar4 == uVar3) {
        *puVar2 = uVar4 + 1;
      }
      UNLOCK();
      if (uVar4 != uVar3) goto LAB_18005fcf9;
      LOCK();
      uVar11 = *(ulong long *)(lVar6 + 0x28);
      bVar21 = uVar14 == uVar11;
      if (bVar21) {
        *(ulong long *)(lVar6 + 0x28) = *(ulong long *)(uVar14 + 0x138);
        uVar11 = uVar14;
      }
      UNLOCK();
      if (bVar21) {
        LOCK();
        *puVar2 = *puVar2 - 2;
        UNLOCK();
        if (uVar14 != 0) goto LAB_18005fd56;
        goto LAB_18005fd0d;
      }
      LOCK();
      uVar4 = *puVar2;
      *puVar2 = *puVar2 - 1;
      UNLOCK();
      if (uVar4 == 0x80000001) {
        uVar15 = *(ulong long *)(lVar6 + 0x28);
        do {
          *(ulong long *)(uVar14 + 0x138) = uVar15;
          *puVar2 = 1;
          LOCK();
          uVar12 = *(ulong long *)(lVar6 + 0x28);
          bVar21 = uVar15 == uVar12;
          if (bVar21) {
            *(ulong long *)(lVar6 + 0x28) = uVar14;
            uVar12 = uVar15;
          }
          UNLOCK();
          if (bVar21) break;
          LOCK();
          uVar4 = *puVar2;
          *puVar2 = *puVar2 + 0x7fffffff;
          UNLOCK();
          uVar15 = uVar12;
        } while (uVar4 == 1);
      }
    }
    goto LAB_18005fc81;
  }
LAB_18005fd0d:
  uVar14 = CreateSystemThreadObject(_DAT_180c8ed18,0x148,CONCAT71((int7)((ulong long)lVar6 >> 8),10));
  if (uVar14 != 0) {
    *(void* *)(uVar14 + 0x100) = 0;
    *(void* *)(uVar14 + 0x108) = 0;
    *(uint32_t *)(uVar14 + 0x130) = 0;
    *(void* *)(uVar14 + 0x138) = 0;
    *(undefined2 *)(uVar14 + 0x140) = 0x100;
    goto LAB_18005fd51;
  }
LAB_18005fda6:
  plVar5 = *(long long **)(param_1 + 0x60);
  plVar5[1] = plVar5[1] - 1U & *plVar5 - 1U;
  puVar20[1] = 0;
joined_r0x00018005fdcd:
  for (; uVar8 != 0; uVar8 = *(ulong long *)(uVar8 + 0x100)) {
    uVar18 = uVar18 + 0x20;
    plVar5 = *(long long **)(param_1 + 0x60);
    *(void* *)
     (*(long long *)
       (plVar5[3] +
       ((uVar18 - **(long long **)(plVar5[3] + plVar5[1] * 8) >> 5) + plVar5[1] & *plVar5 - 1U) * 8)
     + 8) = 0;
    plVar5 = *(long long **)(param_1 + 0x60);
    plVar5[1] = plVar5[1] - 1U & *plVar5 - 1U;
  }
  uVar13 = func_0x000180060150(*(void* *)(param_1 + 0x50),uVar7);
  *(ulong long *)(param_1 + 0x40) = uVar17;
  return uVar13 & 0xffffffffffffff00;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_18005ff50(long long param_1)

{
  ulong long *puVar1;
  uint *puVar2;
  uint uVar3;
  ulong long uVar4;
  uint uVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  long long lVar9;
  bool bVar10;
  
  if (*(ulong long *)(param_1 + 0x10) < *(ulong long *)(param_1 + 0x20)) {
    LOCK();
    puVar1 = (ulong long *)(param_1 + 0x10);
    uVar4 = *puVar1;
    *puVar1 = *puVar1 + 1;
    UNLOCK();
    if ((uVar4 < *(ulong long *)(param_1 + 0x20)) &&
       (lVar6 = uVar4 * 0x148 + *(long long *)(param_1 + 0x18), lVar6 != 0)) {
      return lVar6;
    }
  }
  lVar6 = *(long long *)(param_1 + 0x28);
LAB_18005ff87:
  do {
    lVar9 = lVar6;
    if (lVar9 == 0) {
LAB_180060026:
      lVar6 = CreateSystemThreadObject(_DAT_180c8ed18,0x148,10);
      if (lVar6 == 0) {
        return 0;
      }
      *(void* *)(lVar6 + 0x100) = 0;
      *(void* *)(lVar6 + 0x108) = 0;
      *(uint32_t *)(lVar6 + 0x130) = 0;
      *(void* *)(lVar6 + 0x138) = 0;
      *(undefined2 *)(lVar6 + 0x140) = 0x100;
      return lVar6;
    }
    puVar2 = (uint *)(lVar9 + 0x130);
    uVar5 = *puVar2;
    if ((uVar5 & 0x7fffffff) == 0) {
LAB_180060007:
      lVar6 = *(long long *)(param_1 + 0x28);
      goto LAB_18005ff87;
    }
    LOCK();
    uVar3 = *puVar2;
    if (uVar5 == uVar3) {
      *puVar2 = uVar5 + 1;
    }
    UNLOCK();
    if (uVar5 != uVar3) goto LAB_180060007;
    LOCK();
    lVar6 = *(long long *)(param_1 + 0x28);
    bVar10 = lVar9 == lVar6;
    if (bVar10) {
      *(long long *)(param_1 + 0x28) = *(long long *)(lVar9 + 0x138);
      lVar6 = lVar9;
    }
    UNLOCK();
    if (bVar10) {
      LOCK();
      *puVar2 = *puVar2 - 2;
      UNLOCK();
      if (lVar9 != 0) {
        return lVar9;
      }
      goto LAB_180060026;
    }
    LOCK();
    uVar5 = *puVar2;
    *puVar2 = *puVar2 - 1;
    UNLOCK();
    if (uVar5 == 0x80000001) {
      lVar8 = *(long long *)(param_1 + 0x28);
      do {
        *(long long *)(lVar9 + 0x138) = lVar8;
        *puVar2 = 1;
        LOCK();
        lVar7 = *(long long *)(param_1 + 0x28);
        bVar10 = lVar8 == lVar7;
        if (bVar10) {
          *(long long *)(param_1 + 0x28) = lVar9;
          lVar7 = lVar8;
        }
        UNLOCK();
        if (bVar10) break;
        LOCK();
        uVar5 = *puVar2;
        *puVar2 = *puVar2 + 0x7fffffff;
        UNLOCK();
        lVar8 = lVar7;
      } while (uVar5 == 1);
    }
  } while( true );
}



ulong long FUN_180060080(long long param_1,long long *param_2,void* param_3)

{
  long long *plVar1;
  long long *plVar2;
  long long lVar3;
  void* *puVar4;
  ulong long in_RAX;
  ulong long uVar5;
  
  plVar1 = *(long long **)(param_1 + 0x60);
  if (plVar1 != (long long *)0x0) {
    uVar5 = *plVar1 - 1U & plVar1[1] + 1U;
    plVar2 = *(long long **)(plVar1[3] + uVar5 * 8);
    *param_2 = (long long)plVar2;
    if ((*plVar2 == 1) || (*(long long *)(*param_2 + 8) == 0)) {
      puVar4 = (void* *)*param_2;
      *puVar4 = param_3;
      plVar1[1] = uVar5;
      return CONCAT71((int7)((ulong long)puVar4 >> 8),1);
    }
    in_RAX = FUN_18005f430();
    if ((char)in_RAX != '\0') {
      plVar1 = *(long long **)(param_1 + 0x60);
      uVar5 = *plVar1 - 1U & plVar1[1] + 1U;
      lVar3 = plVar1[3];
      puVar4 = *(void* **)(lVar3 + uVar5 * 8);
      *param_2 = (long long)puVar4;
      *puVar4 = param_3;
      plVar1[1] = uVar5;
      return CONCAT71((int7)((ulong long)lVar3 >> 8),1);
    }
  }
  return in_RAX & 0xffffffffffffff00;
}



void* FUN_1800601c0(void* param_1,ulong long param_2)

{
  FUN_180060200();
  if ((param_2 & 1) != 0) {
    free(param_1,0x88);
  }
  return param_1;
}




// 函数: void FUN_180060200(void* *param_1)
void FUN_180060200(void* *param_1)

{
  long long *plVar1;
  int *piVar2;
  int memoryCompareResult;
  uint uVar4;
  ulong long uVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  long long lVar9;
  ulong long uVar10;
  long long lVar11;
  bool bVar12;
  
  *param_1 = &UNK_1809fe1f0;
  if (param_1[8] != 0) {
    lVar11 = 0;
    if ((param_1[5] & 0x1f) != 0) {
      uVar10 = param_1[0xe] - param_1[0xc];
      uVar5 = param_1[0xd] - 1;
      while( true ) {
        uVar10 = uVar10 & uVar5;
        if ((ulong long)((*(long long *)(param_1[0xf] + uVar10 * 0x10) + 0x20) - param_1[5]) <
            0x8000000000000001) break;
        uVar5 = uVar10 + 1;
        uVar10 = param_1[0xd] - 1;
      }
      lVar11 = *(long long *)(param_1[0xf] + 8 + uVar10 * 0x10);
    }
    lVar9 = param_1[8];
LAB_1800602a0:
    lVar9 = *(long long *)(lVar9 + 0x100);
    uVar5 = 0;
    do {
      if (*(char *)(lVar9 + 0x110 + uVar5) == '\0') {
        uVar5 = 0;
        if (lVar9 == lVar11) {
          uVar5 = (ulong long)((uint)param_1[5] & 0x1f);
        }
        if ((param_1[4] & 0x1f) == 0) {
          uVar10 = 0x20;
        }
        else {
          uVar10 = (ulong long)((uint)param_1[4] & 0x1f);
        }
        goto LAB_1800602f0;
      }
      uVar5 = uVar5 + 1;
    } while (uVar5 < 0x20);
    goto LAB_18006031a;
  }
LAB_18006039b:
  if (param_1[0x10] == 0) {
    *param_1 = &UNK_1809fe210;
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
  while( true ) {
    uVar4 = (uint)uVar5;
    uVar5 = uVar5 + 1;
    plVar1 = *(long long **)(lVar9 + (ulong long)(uVar4 & 0x1f) * 8);
    if (plVar1 != (long long *)0x0) {
      (**(code **)(*plVar1 + 0x38))();
    }
    if (uVar5 == 0x20) break;
LAB_1800602f0:
    if ((lVar9 == param_1[8]) && (uVar5 == uVar10)) break;
  }
LAB_18006031a:
  lVar7 = param_1[8];
  if (lVar9 == lVar7) goto code_r0x000180060327;
  goto LAB_1800602a0;
code_r0x000180060327:
  if (lVar7 != 0) {
    do {
      lVar11 = *(long long *)(lVar7 + 0x100);
      if (*(char *)(lVar7 + 0x141) != '\0') {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lVar9 = param_1[10];
      LOCK();
      piVar2 = (int *)(lVar7 + 0x130);
      iVar3 = *piVar2;
      *piVar2 = *piVar2 + -0x80000000;
      UNLOCK();
      if (iVar3 == 0) {
        lVar8 = *(long long *)(lVar9 + 0x28);
        do {
          *(long long *)(lVar7 + 0x138) = lVar8;
          *(uint32_t *)(lVar7 + 0x130) = 1;
          plVar1 = (long long *)(lVar9 + 0x28);
          LOCK();
          lVar6 = *plVar1;
          bVar12 = lVar8 == lVar6;
          if (bVar12) {
            *plVar1 = lVar7;
            lVar6 = lVar8;
          }
          UNLOCK();
          if (bVar12) break;
          LOCK();
          piVar2 = (int *)(lVar7 + 0x130);
          iVar3 = *piVar2;
          *piVar2 = *piVar2 + 0x7fffffff;
          UNLOCK();
          lVar8 = lVar6;
        } while (iVar3 == 1);
      }
      lVar7 = lVar11;
    } while (lVar11 != param_1[8]);
  }
  goto LAB_18006039b;
}



void* FUN_1800603e0(void* param_1,ulong long param_2)

{
  FUN_180060420();
  if ((param_2 & 1) != 0) {
    free(param_1,0x68);
  }
  return param_1;
}




// 函数: void FUN_180060420(void* *param_1)
void FUN_180060420(void* *param_1)

{
  int *piVar1;
  int iVar2;
  ulong long uVar3;
  ulong long uVar4;
  long long *plVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  long long lVar9;
  ulong long uVar10;
  bool bVar11;
  
  *param_1 = &UNK_1809fe200;
  uVar3 = param_1[4];
  lVar9 = 0;
  uVar4 = param_1[5];
  for (uVar10 = uVar4; uVar10 != uVar3; uVar10 = uVar10 + 1) {
    if ((uVar10 & 0x1f) == 0) {
      if (lVar9 != 0) {
        lVar6 = param_1[10];
        LOCK();
        piVar1 = (int *)(lVar9 + 0x130);
        iVar2 = *piVar1;
        *piVar1 = *piVar1 + -0x80000000;
        UNLOCK();
        if (iVar2 == 0) {
          lVar8 = *(long long *)(lVar6 + 0x28);
          do {
            *(long long *)(lVar9 + 0x138) = lVar8;
            *(uint32_t *)(lVar9 + 0x130) = 1;
            plVar5 = (long long *)(lVar6 + 0x28);
            LOCK();
            lVar7 = *plVar5;
            bVar11 = lVar8 == lVar7;
            if (bVar11) {
              *plVar5 = lVar9;
              lVar7 = lVar8;
            }
            UNLOCK();
            if (bVar11) break;
            LOCK();
            piVar1 = (int *)(lVar9 + 0x130);
            iVar2 = *piVar1;
            *piVar1 = *piVar1 + 0x7fffffff;
            UNLOCK();
            lVar8 = lVar7;
          } while (iVar2 == 1);
        }
      }
LAB_1800604d1:
      plVar5 = (long long *)param_1[0xc];
      lVar9 = *(long long *)
               (*(long long *)
                 (plVar5[3] +
                 (((uVar10 & 0xffffffffffffffe0) - **(long long **)(plVar5[3] + plVar5[1] * 8) >> 5)
                  + plVar5[1] & *plVar5 - 1U) * 8) + 8);
    }
    else if (lVar9 == 0) goto LAB_1800604d1;
    plVar5 = *(long long **)(lVar9 + (ulong long)((uint)uVar10 & 0x1f) * 8);
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x38))();
    }
  }
  lVar9 = param_1[8];
  if ((lVar9 != 0) && ((uVar4 != uVar3 || ((uVar3 & 0x1f) != 0)))) {
    lVar6 = param_1[10];
    LOCK();
    piVar1 = (int *)(lVar9 + 0x130);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -0x80000000;
    UNLOCK();
    if (iVar2 == 0) {
      lVar8 = *(long long *)(lVar6 + 0x28);
      do {
        *(long long *)(lVar9 + 0x138) = lVar8;
        *(uint32_t *)(lVar9 + 0x130) = 1;
        plVar5 = (long long *)(lVar6 + 0x28);
        LOCK();
        lVar7 = *plVar5;
        bVar11 = lVar8 == lVar7;
        if (bVar11) {
          *plVar5 = lVar9;
          lVar7 = lVar8;
        }
        UNLOCK();
        if (bVar11) break;
        LOCK();
        piVar1 = (int *)(lVar9 + 0x130);
        iVar2 = *piVar1;
        *piVar1 = *piVar1 + 0x7fffffff;
        UNLOCK();
        lVar8 = lVar7;
      } while (iVar2 == 1);
    }
  }
  if (param_1[0xc] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_1809fe210;
  return;
}



void* * FUN_1800605d0(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fe210;
  if ((param_2 & 1) != 0) {
    free(param_1,0x58);
  }
  return param_1;
}




// 函数: void FUN_180060610(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180060610(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  char systemNodeFlag;
  void* uVar2;
  
  uVar2 = 0xfffffffffffffffe;
  *param_1 = &UNK_180a10098;
  cVar1 = FUN_18020eba0(param_1,1,param_3,param_4,0xfffffffffffffffe);
  while (cVar1 != '\0') {
    cVar1 = FUN_18020eba0(param_1,1,param_3,param_4,uVar2);
  }
  if (param_1[1] == 0) {
    param_1[1] = 0;
    _Mtx_destroy_in_situ();
    _Cnd_destroy_in_situ(param_1 + 0x2a);
    _Mtx_destroy_in_situ();
    FUN_18020f530();
    if (param_1[0xe] != 0) {
      *(void* *)(param_1[0xe] + 0x10) = 0;
      *(uint8_t *)(param_1[0xe] + 8) = 1;
    }
    param_1[2] = &SystemMemoryAllocatorReference;
    return;
  }
  if (*(int *)(param_1[1] + 8) == 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
                    // WARNING: Subroutine does not return
  terminate();
}



void* FUN_180060630(void* param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  FUN_18020e6c0();
  if ((param_2 & 1) != 0) {
    free(param_1,0x208,param_3,param_4,uVar1);
  }
  return param_1;
}



int FUN_180060680(void* param_1,void* param_2,void* param_3,void* param_4)

{
  int iVar1;
  ulong long *puVar2;
  uint64_t systemInitializationFlag;
  void* uStackX_20;
  
  uStackX_18 = param_3;
  uStackX_20 = param_4;
  puVar2 = (ulong long *)func_0x00018004b9a0();
  iVar1 = __stdio_common_vsprintf(*puVar2 | 1,param_1,0xffffffffffffffff,param_2,0,&uStackX_18);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800606e0(long long *param_1)
void FUN_1800606e0(long long *param_1)

{
  long long *plVar1;
  char cVar2;
  int memoryCompareResult;
  void* uStackX_8;
  long long *plStack_20;
  char cStack_18;
  
  if ((char)param_1[0xb] != '\0') {
    plVar1 = (long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
    do {
      cVar2 = (**(code **)(*param_1 + 0x20))(param_1,1);
      if (cVar2 == '\0') {
        FUN_18064e0d0(*(void* *)(*plVar1 + 0x10),0);
        plStack_20 = param_1 + 0x33;
        cStack_18 = 0;
        iVar3 = _Mtx_lock();
        if (iVar3 != 0) {
          __Throw_C_error_std__YAXH_Z(iVar3);
        }
        cStack_18 = '\x01';
        if ((char)param_1[0x3d] == '\x01') {
          *(uint8_t *)(param_1 + 0x3d) = 0;
        }
        else {
          uStackX_8 = 0x32;
          FUN_1800495d0(param_1 + 0x2a,&plStack_20,&uStackX_8);
          *(uint8_t *)(param_1 + 0x3d) = 0;
          if (cStack_18 == '\0') goto LAB_1800607cc;
        }
        iVar3 = _Mtx_unlock(plStack_20);
        if (iVar3 != 0) {
          __Throw_C_error_std__YAXH_Z(iVar3);
        }
      }
LAB_1800607cc:
    } while ((char)param_1[0xb] != '\0');
  }
  return;
}



void* FUN_1800607f0(long long param_1,char param_2)

{
  long long lVar1;
  int iVar2;
  long long *plVar3;
  void* uVar4;
  long long *plStackX_18;
  
  plStackX_18 = (long long *)0x0;
  plVar3 = (long long *)0x0;
  if (param_2 != '\0') {
    if (*(int *)(param_1 + 0x140) < 1) {
      plVar3 = (long long *)0x0;
    }
    else {
      iVar2 = _Mtx_lock(param_1 + 0xf0);
      if (iVar2 != 0) {
        __Throw_C_error_std__YAXH_Z(iVar2);
      }
      if ((*(long long *)(param_1 + 200) - *(long long *)(param_1 + 0xd0) >> 3) +
          ((*(long long *)(param_1 + 0xe0) - *(long long *)(param_1 + 0xc0) >> 3) + -1) * 0x20 +
          (*(long long *)(param_1 + 0xb8) - (long long)*(long long **)(param_1 + 0xa8) >> 3) != 0) {
        plStackX_18 = (long long *)**(long long **)(param_1 + 0xa8);
        if (plStackX_18 != (long long *)0x0) {
          (**(code **)(*plStackX_18 + 0x28))(plStackX_18);
        }
        plVar3 = *(long long **)(param_1 + 0xa8);
        if (plVar3 + 1 == *(long long **)(param_1 + 0xb8)) {
          if ((long long *)*plVar3 != (long long *)0x0) {
            (**(code **)(*(long long *)*plVar3 + 0x38))();
          }
          if (*(long long *)(param_1 + 0xb0) != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          plVar3 = (long long *)(*(long long *)(param_1 + 0xc0) + 8);
          *(long long **)(param_1 + 0xc0) = plVar3;
          lVar1 = *plVar3;
          *(long long *)(param_1 + 0xb0) = lVar1;
          *(long long *)(param_1 + 0xb8) = lVar1 + 0x100;
          *(void* *)(param_1 + 0xa8) = *(void* *)(param_1 + 0xb0);
        }
        else {
          *(long long **)(param_1 + 0xa8) = plVar3 + 1;
          if ((long long *)*plVar3 != (long long *)0x0) {
            (**(code **)(*(long long *)*plVar3 + 0x38))();
          }
        }
      }
      iVar2 = _Mtx_unlock(param_1 + 0xf0);
      if (iVar2 != 0) {
        __Throw_C_error_std__YAXH_Z(iVar2);
      }
      plVar3 = plStackX_18;
      if (plStackX_18 != (long long *)0x0) {
        (**(code **)(*plStackX_18 + 0x60))(plStackX_18);
        (**(code **)(*plStackX_18 + 0x70))(plStackX_18);
        LOCK();
        *(int *)(param_1 + 0x140) = *(int *)(param_1 + 0x140) + -1;
        UNLOCK();
        uVar4 = 1;
        goto LAB_180060993;
      }
    }
  }
  plStackX_18 = plVar3;
  uVar4 = 0;
LAB_180060993:
  if (plStackX_18 != (long long *)0x0) {
    (**(code **)(*plStackX_18 + 0x38))(plStackX_18);
  }
  return uVar4;
}



bool FUN_1800609c0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  char cVar2;
  long long *plStackX_8;
  
  plStackX_8 = (long long *)0x0;
  WaitForSingleObject(**(void* **)(param_1 + 0x1f0),1,param_3,param_4,0xfffffffffffffffe);
  cVar2 = FUN_180060e40(*(void* *)(param_1 + 0x60),param_1 + 0x78,&plStackX_8);
  plVar1 = plStackX_8;
  if (cVar2 != '\0') {
    (**(code **)(*plStackX_8 + 0x60))(plStackX_8);
    (**(code **)(*plVar1 + 0x70))(plVar1);
  }
  if (plVar1 != (long long *)0x0) {
    (**(code **)(*plVar1 + 0x38))(plVar1);
  }
  return cVar2 != '\0';
}



ulong long FUN_180060a50(long long *param_1,uint *param_2)

{
  uint uVar1;
  uint uVar2;
  long long lVar3;
  ulong long in_RAX;
  ulong long *puVar4;
  ulong long *puVar5;
  ulong long *puVar6;
  ulong long uVar7;
  ulong long *puVar8;
  uint uVar9;
  ulong long uVar10;
  
  lVar3 = *param_1;
  if ((*(long long *)(param_2 + 6) == 0) && (lVar3 == 0)) {
    return in_RAX & 0xffffffffffffff00;
  }
  uVar1 = *(uint *)(param_1 + 1);
  uVar2 = *(uint *)(param_1 + 0x4c);
  puVar8 = (ulong long *)0x0;
  puVar4 = *(ulong long **)(param_2 + 6);
  if (*(ulong long **)(param_2 + 6) == (ulong long *)0x0) {
    puVar5 = (ulong long *)(lVar3 + 8);
    if (lVar3 == 0) {
      puVar5 = puVar8;
    }
    *(ulong long **)(param_2 + 6) = puVar5;
    uVar9 = (uVar1 - *param_2 % uVar1) - 1;
    uVar10 = (ulong long)uVar9;
    puVar4 = puVar5;
    if (uVar9 != 0) {
      do {
        if (puVar4 == (ulong long *)0x0) {
          puVar4 = (ulong long *)&DAT_00000008;
        }
        puVar6 = (ulong long *)(*puVar4 - 8);
        if (*puVar4 == 0) {
          systemCurrentNode = systemNextNode;
        }
        puVar4 = puVar6 + 1;
        if (puVar6 == (ulong long *)0x0) {
          puVar4 = puVar8;
        }
        *(ulong long **)(param_2 + 6) = puVar4;
        if (puVar4 == (ulong long *)0x0) {
          *(ulong long **)(param_2 + 6) = puVar5;
          puVar4 = puVar5;
        }
        uVar10 = uVar10 - 1;
      } while (uVar10 != 0);
    }
  }
  uVar9 = uVar2 - param_2[1];
  uVar10 = (ulong long)uVar9;
  if (uVar1 <= uVar9) {
    uVar10 = (ulong long)uVar9 % (ulong long)uVar1;
  }
  uVar7 = uVar10;
  if ((int)uVar10 != 0) {
    do {
      if (puVar4 == (ulong long *)0x0) {
        puVar4 = (ulong long *)&DAT_00000008;
      }
      uVar10 = *puVar4;
      puVar5 = (ulong long *)(uVar10 - 8);
      if (uVar10 == 0) {
        puVar5 = puVar8;
      }
      puVar4 = puVar8;
      if (puVar5 != (ulong long *)0x0) {
        puVar4 = puVar5 + 1;
      }
      *(ulong long **)(param_2 + 6) = puVar4;
      if (puVar4 == (ulong long *)0x0) {
        puVar4 = (ulong long *)(lVar3 + 8);
        if (lVar3 == 0) {
          puVar4 = puVar8;
        }
        *(ulong long **)(param_2 + 6) = puVar4;
      }
      uVar7 = uVar7 - 1;
    } while (uVar7 != 0);
  }
  param_2[1] = uVar2;
  param_2[2] = 0;
  *(ulong long **)(param_2 + 4) = puVar4;
  return CONCAT71((int7)(uVar10 >> 8),1);
}



long long * FUN_180060b80(long long *param_1,long long *param_2)

{
  long long lVar1;
  long long *plVar2;
  
  lVar1 = *param_2;
  *param_2 = 0;
  plVar2 = (long long *)*param_1;
  *param_1 = lVar1;
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))();
  }
  return param_1;
}



long long * FUN_180060bd0(long long *param_1)

{
  if ((long long *)*param_1 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_1 + 0x38))();
  }
  return param_1;
}



void* FUN_180060c60(long long param_1,void* param_2)

{
  long long *plVar1;
  ulong long *puVar2;
  long long lVar3;
  ulong long uVar4;
  long long systemTimeValue;
  long long lVar6;
  ulong long uVar7;
  
  if (*(char *)(param_1 + 0x48) == '\0') {
    if ((ulong long)
        ((*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x38)) -
        *(long long *)(param_1 + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    plVar1 = (long long *)(param_1 + 0x30);
    lVar3 = *plVar1;
    *plVar1 = *plVar1 + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((lVar3 - *(long long *)(param_1 + 0x20)) - *(long long *)(param_1 + 0x38))) {
      LOCK();
      puVar2 = (ulong long *)(param_1 + 0x28);
      uVar4 = *puVar2;
      *puVar2 = *puVar2 + 1;
      UNLOCK();
      plVar1 = *(long long **)(param_1 + 0x60);
      lVar3 = *(long long *)
               (plVar1[3] +
               (((uVar4 & 0xffffffffffffffe0) - **(long long **)(plVar1[3] + plVar1[1] * 8) >> 5) +
                plVar1[1] & *plVar1 - 1U) * 8);
      lVar6 = *(long long *)(lVar3 + 8);
      plVar1 = (long long *)(lVar6 + (ulong long)((uint)uVar4 & 0x1f) * 8);
      FUN_180060b80(param_2,plVar1);
      plVar1 = (long long *)*plVar1;
      if (plVar1 != (long long *)0x0) {
        (**(code **)(*plVar1 + 0x38))();
      }
      LOCK();
      plVar1 = (long long *)(lVar6 + 0x108);
      lVar5 = *plVar1;
      *plVar1 = *plVar1 + 1;
      UNLOCK();
      if (lVar5 == 0x1f) {
        *(void* *)(lVar3 + 8) = 0;
        func_0x000180060c10(*(void* *)(param_1 + 0x50),lVar6);
      }
      return 1;
    }
  }
  else {
    if ((ulong long)
        ((*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x38)) -
        *(long long *)(param_1 + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    plVar1 = (long long *)(param_1 + 0x30);
    lVar3 = *plVar1;
    *plVar1 = *plVar1 + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((lVar3 - *(long long *)(param_1 + 0x20)) - *(long long *)(param_1 + 0x38))) {
      LOCK();
      puVar2 = (ulong long *)(param_1 + 0x28);
      uVar4 = *puVar2;
      *puVar2 = *puVar2 + 1;
      UNLOCK();
      plVar1 = *(long long **)(param_1 + 0x58);
      uVar7 = (ulong long)((uint)uVar4 & 0x1f);
      lVar3 = *(long long *)
               (plVar1[2] + 8 +
               (((uVar4 & 0xffffffffffffffe0) - *(long long *)(plVar1[2] + plVar1[1] * 0x10) >> 5) +
                plVar1[1] & *plVar1 - 1U) * 0x10);
      plVar1 = (long long *)(lVar3 + uVar7 * 8);
      FUN_180060b80(param_2,plVar1);
      plVar1 = (long long *)*plVar1;
      if (plVar1 != (long long *)0x0) {
        (**(code **)(*plVar1 + 0x38))();
      }
      *(uint8_t *)((lVar3 - uVar7) + 0x12f) = 1;
      return 1;
    }
  }
  LOCK();
  *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + 1;
  UNLOCK();
  return 0;
}



void* FUN_180060d76(void)

{
  ulong long *puVar1;
  ulong long uVar2;
  long long lVar3;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  long long lVar6;
  ulong long unaff_RSI;
  long long unaff_RDI;
  
  LOCK();
  puVar1 = (ulong long *)(unaff_RDI + 0x28);
  uVar2 = *puVar1;
  *puVar1 = *puVar1 + (unaff_RSI & 0xffffffff);
  UNLOCK();
  plVar4 = *(long long **)(unaff_RDI + 0x60);
  lVar5 = *(long long *)
           (plVar4[3] +
           (((uVar2 & 0xffffffffffffffe0) - **(long long **)(plVar4[3] + plVar4[1] * 8) >> 5) +
            plVar4[1] & *plVar4 - 1U) * 8);
  lVar6 = *(long long *)(lVar5 + 8);
  FUN_180060b80();
  plVar4 = *(long long **)(lVar6 + (ulong long)((uint)uVar2 & 0x1f) * 8);
  if (plVar4 != (long long *)0x0) {
    (**(code **)(*plVar4 + 0x38))();
  }
  LOCK();
  plVar4 = (long long *)(lVar6 + 0x108);
  lVar3 = *plVar4;
  *plVar4 = *plVar4 + unaff_RSI;
  UNLOCK();
  if (lVar3 == 0x1f) {
    *(void* *)(lVar5 + 8) = 0;
    func_0x000180060c10(*(void* *)(unaff_RDI + 0x50),lVar6);
  }
  return 1;
}



uint8_t FUN_180060e22(void)

{
  long long unaff_RSI;
  long long unaff_RDI;
  
  LOCK();
  *(long long *)(unaff_RDI + 0x38) = *(long long *)(unaff_RDI + 0x38) + unaff_RSI;
  UNLOCK();
  return 0;
}



void* FUN_180060e40(void* *param_1,long long param_2,void* param_3)

{
  char systemNodeFlag;
  long long *plVar2;
  long long lVar3;
  long long* systemMemoryPointer;
  long long *plVar5;
  long long *plVar6;
  
  if (((*(long long *)(param_2 + 0x18) == 0) || (*(int *)(param_2 + 4) != *(int *)(param_1 + 0x4c)))
     && (cVar1 = FUN_180060a50(), cVar1 == '\0')) {
    return 0;
  }
  plVar6 = (long long *)0x0;
  plVar4 = (long long *)(*(long long *)(param_2 + 0x10) + -8);
  if (*(long long *)(param_2 + 0x10) == 0) {
    plVar4 = plVar6;
  }
  cVar1 = FUN_180060c60(plVar4,param_3);
  if (cVar1 == '\0') {
    plVar4 = (long long *)*param_1;
    plVar2 = *(long long **)(param_2 + 0x10);
    if (plVar2 == (long long *)0x0) {
      plVar2 = (long long *)&DAT_00000008;
    }
    lVar3 = *plVar2;
    while( true ) {
      plVar2 = (long long *)(lVar3 + -8);
      if (lVar3 == 0) {
        plVar2 = plVar6;
      }
      plVar5 = plVar4;
      if (plVar2 != (long long *)0x0) {
        plVar5 = plVar2;
      }
      plVar2 = (long long *)(*(long long *)(param_2 + 0x10) + -8);
      if (*(long long *)(param_2 + 0x10) == 0) {
        plVar2 = plVar6;
      }
      if (plVar5 == plVar2) {
        return 0;
      }
      cVar1 = FUN_180060c60(plVar5,param_3);
      if (cVar1 != '\0') break;
      lVar3 = plVar5[1];
    }
    *(uint32_t *)(param_2 + 8) = 1;
    plVar4 = plVar5 + 1;
    if (plVar5 == (long long *)0x0) {
      plVar4 = plVar6;
    }
    *(long long **)(param_2 + 0x10) = plVar4;
  }
  else {
    *(int *)(param_2 + 8) = *(int *)(param_2 + 8) + 1;
    if (*(int *)(param_2 + 8) == 0x100) {
      LOCK();
      *(int *)(param_1 + 0x4c) = *(int *)(param_1 + 0x4c) + 1;
      UNLOCK();
    }
  }
  return 1;
}



bool FUN_180060f50(long long param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  char cVar2;
  long long *plStackX_8;
  
  plStackX_8 = (long long *)0x0;
  cVar2 = FUN_180060e40(*(void* *)(param_1 + 0x60),param_1 + 0x78,&plStackX_8,param_4,
                        0xfffffffffffffffe);
  plVar1 = plStackX_8;
  if (cVar2 != '\0') {
    (**(code **)(*plStackX_8 + 0x60))(plStackX_8);
    (**(code **)(*plVar1 + 0x70))(plVar1);
  }
  if (plVar1 != (long long *)0x0) {
    (**(code **)(*plVar1 + 0x38))(plVar1);
  }
  return cVar2 != '\0';
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180060fc0(long long *param_1,long long *param_2)
void FUN_180060fc0(long long *param_1,long long *param_2)

{
  long long *plVar1;
  long long lVar2;
  long long *plVar3;
  long long lVar4;
  ulong long uVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  ulong long uVar9;
  void* uVar10;
  
  uVar10 = 0xfffffffffffffffe;
  plVar3 = (long long *)param_1[6];
  plVar1 = plVar3 + 1;
  if (plVar1 == (long long *)param_1[8]) {
    param_2 = (long long *)*param_2;
    if (param_2 != (long long *)0x0) {
      (**(code **)(*param_2 + 0x28))(param_2);
    }
    lVar7 = *param_1;
    lVar4 = param_1[1];
    if (lVar4 <= (param_1[9] - lVar7 >> 3) + 1) {
      lVar6 = param_1[5];
      uVar9 = lVar6 - lVar7 >> 3;
      lVar8 = param_1[9] - lVar6 >> 3;
      lVar2 = lVar8 * 8 + 8;
      if (uVar9 != 0) {
        uVar5 = uVar9 >> 1;
        if (uVar5 < 2) {
          uVar5 = 1;
        }
                    // WARNING: Subroutine does not return
        memmove(lVar7 + (uVar9 - uVar5) * 8,lVar6,lVar2);
      }
      lVar6 = lVar4;
      if (lVar4 == 0) {
        lVar6 = 1;
      }
      lVar6 = lVar4 + 2 + lVar6;
      lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,lVar6 * 8,(char)param_1[10],lVar7,uVar10);
      plVar1 = (long long *)(lVar7 + (param_1[5] - *param_1 >> 3) * 8);
      if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
        memcpy(plVar1,param_1[5],lVar2);
      }
      *param_1 = lVar7;
      param_1[1] = lVar6;
      param_1[5] = (long long)plVar1;
      lVar7 = *plVar1;
      param_1[3] = lVar7;
      param_1[4] = lVar7 + 0x100;
      param_1[9] = (long long)(plVar1 + lVar8);
      lVar7 = plVar1[lVar8];
      param_1[7] = lVar7;
      param_1[8] = lVar7 + 0x100;
    }
    uVar10 = CreateSystemThreadObject(_DAT_180c8ed18,0x100,(char)param_1[10]);
    *(void* *)(param_1[9] + 8) = uVar10;
    *(long long **)param_1[6] = param_2;
    lVar7 = param_1[9];
    param_1[9] = lVar7 + 8;
    lVar7 = *(long long *)(lVar7 + 8);
    param_1[7] = lVar7;
    param_1[8] = lVar7 + 0x100;
    param_1[6] = lVar7;
  }
  else {
    param_1[6] = (long long)plVar1;
    param_2 = (long long *)*param_2;
    *plVar3 = (long long)param_2;
    if (param_2 != (long long *)0x0) {
      (**(code **)(*param_2 + 0x28))();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800611a0(long long param_1,long long *param_2,void* param_3,void* param_4)
void FUN_1800611a0(long long param_1,long long *param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  long long lVar2;
  long long lVar3;
  int iVar4;
  long long systemTimeValue;
  void* uVar6;
  uint8_t uVar7;
  
  uVar6 = 0xfffffffffffffffe;
  lVar5 = param_1 + 0xf0;
  iVar4 = _Mtx_lock();
  if (iVar4 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar4);
  }
  uVar7 = 1;
  FUN_180060fc0(param_1 + 0x98,param_2);
  LOCK();
  *(int *)(param_1 + 0x140) = *(int *)(param_1 + 0x140) + 1;
  UNLOCK();
  puVar1 = *(void* **)(param_1 + 0x1f0);
  lVar2 = *(long long *)(_DAT_180c82868 + 0x10);
  lVar3 = *(long long *)(_DAT_180c82868 + 8);
  do {
    iVar4 = ReleaseSemaphore(*puVar1,lVar2 - lVar3 >> 3 & 0xffffffff,0,param_4,uVar6,lVar5,uVar7);
  } while (iVar4 == 0);
  SystemThreadSyncBroadcast(param_1 + 0x150);
  iVar4 = _Mtx_unlock(lVar5);
  if (iVar4 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar4);
  }
  if ((long long *)*param_2 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_2 + 0x38))();
  }
  return;
}




// 函数: void FUN_180061290(void* *param_1)
void FUN_180061290(void* *param_1)

{
  CloseHandle(*param_1);
  return;
}




// 函数: void FUN_1800612b0(void* *param_1)
void FUN_1800612b0(void* *param_1)

{
  *param_1 = &UNK_180a3cf50;
  if (*(char *)((long long)param_1 + 0xb1) != '\0') {
    FUN_180639250();
  }
  _Mtx_destroy_in_situ();
  *param_1 = &UNK_180a30778;
  param_1[7] = &SystemGlobalDataReference;
  if (param_1[8] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[8] = 0;
  *(uint32_t *)(param_1 + 10) = 0;
  param_1[7] = &SystemMemoryAllocatorReference;
  param_1[1] = &SystemGlobalDataReference;
  if (param_1[2] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[2] = 0;
  *(uint32_t *)(param_1 + 4) = 0;
  param_1[1] = &SystemMemoryAllocatorReference;
  return;
}



void* *
FUN_180061300(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  *param_1 = &UNK_180a3cf50;
  if (*(char *)((long long)param_1 + 0xb1) != '\0') {
    FUN_180639250();
  }
  _Mtx_destroy_in_situ();
  FUN_1805065c0(param_1);
  if ((param_2 & 1) != 0) {
    free(param_1,0xb8,param_3,param_4,uVar1);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180061380(void* param_1,long long param_2)
void FUN_180061380(void* param_1,long long param_2)

{
  long long lVar1;
  long long lVar2;
  void* *puVar3;
  uint8_t auStack_268 [32];
  long long lStack_248;
  void* *puStack_238;
  uint8_t auStack_230 [8];
  long long lStack_228;
  uint uStack_220;
  long long lStack_210;
  uint8_t auStack_208 [80];
  void* uStack_1b8;
  undefined *puStack_1a8;
  uint8_t *puStack_1a0;
  uint32_t uStack_198;
  uint8_t auStack_190 [88];
  uint8_t auStack_138 [256];
  ulong long uStack_38;
  
  lVar2 = _DAT_180c86928;
  lVar1 = _DAT_180c82868;
  uStack_1b8 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_268;
  lStack_210 = _DAT_180c86928;
  puStack_1a8 = &UNK_1809fdc18;
  puStack_1a0 = auStack_190;
  auStack_190[0] = 0;
  uStack_198 = 6;
  strcpy_s(auStack_190,0x10,&UNK_1809fe2c0);
  puVar3 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x208,8,3);
  lStack_248 = lVar1 + 0x70;
  puStack_238 = puVar3;
  FUN_18020e0e0(puVar3,&puStack_1a8,3,lVar1 + 0x2e0);
  *puVar3 = &UNK_1809fe220;
  puStack_238 = puVar3;
  FUN_18020e840(puVar3);
  FUN_18005ea90(lVar1 + 0x48,&puStack_238);
  *(void* **)(lVar2 + 400) = puVar3;
  puStack_1a8 = &SystemMemoryAllocatorReference;
  FUN_180627e10(_DAT_180c86870 + 0x170,auStack_230,&DAT_1809fc8c8);
  if (0 < *(int *)(param_2 + 0x10)) {
    FUN_1806277c0(auStack_230,uStack_220 + *(int *)(param_2 + 0x10));
                    // WARNING: Subroutine does not return
    memcpy((ulong long)uStack_220 + lStack_228,*(void* *)(param_2 + 8),
           (long long)(*(int *)(param_2 + 0x10) + 1));
  }
  FUN_18062c100(auStack_208,auStack_230);
  FUN_18062c1e0(auStack_208,1);
                    // WARNING: Subroutine does not return
  memset(auStack_138,0,0x100);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180061be0(long long *param_1)
void FUN_180061be0(long long *param_1)

{
  void* *puVar1;
  code *pcVar2;
  long long lVar3;
  void* uVar4;
  long long *plVar5;
  long long *plVar6;
  long long *plVar7;
  long long *plStackX_8;
  long long **pplStackX_10;
  long long *plStackX_18;
  long long *plStackX_20;
  
  lVar3 = _DAT_180c86928;
  plStackX_8 = param_1;
  uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3,0xfffffffffffffffe);
  plVar5 = (long long *)FUN_1800636f0(uVar4,0,lVar3);
  plStackX_18 = plVar5;
  if (plVar5 != (long long *)0x0) {
    (**(code **)(*plVar5 + 0x28))(plVar5);
  }
  puVar1 = *(void* **)(lVar3 + 400);
  pcVar2 = *(code **)*puVar1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plVar5;
  if (plVar5 != (long long *)0x0) {
    (**(code **)(*plVar5 + 0x28))(plVar5);
  }
  (*pcVar2)(puVar1,&plStackX_8);
  uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
  plVar6 = (long long *)FUN_1800636f0(uVar4,4,lVar3);
  plStackX_20 = plVar6;
  if (plVar6 != (long long *)0x0) {
    (**(code **)(*plVar6 + 0x28))(plVar6);
  }
  puVar1 = *(void* **)(lVar3 + 400);
  pcVar2 = *(code **)*puVar1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plVar6;
  if (plVar6 != (long long *)0x0) {
    (**(code **)(*plVar6 + 0x28))(plVar6);
  }
  (*pcVar2)(puVar1,&plStackX_8);
  uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
  plVar7 = (long long *)FUN_1800636f0(uVar4,0,lVar3);
  if (plVar7 != (long long *)0x0) {
    pplStackX_10 = (long long **)plVar7;
    (**(code **)(*plVar7 + 0x28))(plVar7);
  }
  plStackX_18 = plVar7;
  if (plVar5 != (long long *)0x0) {
    pplStackX_10 = (long long **)plVar5;
    (**(code **)(*plVar5 + 0x38))(plVar5);
  }
  puVar1 = *(void* **)(lVar3 + 400);
  pcVar2 = *(code **)*puVar1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plVar7;
  if (plVar7 != (long long *)0x0) {
    (**(code **)(*plVar7 + 0x28))(plVar7);
  }
  (*pcVar2)(puVar1,&plStackX_8);
  FUN_18020f150(*(void* *)(lVar3 + 400));
  if (plVar6 != (long long *)0x0) {
    (**(code **)(*plVar6 + 0x38))(plVar6);
  }
  if (plVar7 != (long long *)0x0) {
    (**(code **)(*plVar7 + 0x38))(plVar7);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180061db0(long long *param_1)
void FUN_180061db0(long long *param_1)

{
  void* *puVar1;
  code *pcVar2;
  long long lVar3;
  void* uVar4;
  long long *plVar5;
  long long *plVar6;
  long long *plVar7;
  long long *plStackX_8;
  long long **pplStackX_10;
  long long *plStackX_18;
  long long *plStackX_20;
  
  lVar3 = _DAT_180c86928;
  plStackX_8 = param_1;
  uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3,0xfffffffffffffffe);
  plVar5 = (long long *)FUN_1800636f0(uVar4,0,lVar3);
  plStackX_18 = plVar5;
  if (plVar5 != (long long *)0x0) {
    (**(code **)(*plVar5 + 0x28))(plVar5);
  }
  puVar1 = *(void* **)(lVar3 + 400);
  pcVar2 = *(code **)*puVar1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plVar5;
  if (plVar5 != (long long *)0x0) {
    (**(code **)(*plVar5 + 0x28))(plVar5);
  }
  (*pcVar2)(puVar1,&plStackX_8);
  uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
  plVar6 = (long long *)FUN_1800636f0(uVar4,3,lVar3);
  plStackX_20 = plVar6;
  if (plVar6 != (long long *)0x0) {
    (**(code **)(*plVar6 + 0x28))(plVar6);
  }
  puVar1 = *(void* **)(lVar3 + 400);
  pcVar2 = *(code **)*puVar1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plVar6;
  if (plVar6 != (long long *)0x0) {
    (**(code **)(*plVar6 + 0x28))(plVar6);
  }
  (*pcVar2)(puVar1,&plStackX_8);
  uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3);
  plVar7 = (long long *)FUN_1800636f0(uVar4,0,lVar3);
  if (plVar7 != (long long *)0x0) {
    pplStackX_10 = (long long **)plVar7;
    (**(code **)(*plVar7 + 0x28))(plVar7);
  }
  plStackX_18 = plVar7;
  if (plVar5 != (long long *)0x0) {
    pplStackX_10 = (long long **)plVar5;
    (**(code **)(*plVar5 + 0x38))(plVar5);
  }
  puVar1 = *(void* **)(lVar3 + 400);
  pcVar2 = *(code **)*puVar1;
  pplStackX_10 = &plStackX_8;
  plStackX_8 = plVar7;
  if (plVar7 != (long long *)0x0) {
    (**(code **)(*plVar7 + 0x28))(plVar7);
  }
  (*pcVar2)(puVar1,&plStackX_8);
  FUN_18020f150(*(void* *)(lVar3 + 400));
  if (plVar6 != (long long *)0x0) {
    (**(code **)(*plVar6 + 0x38))(plVar6);
  }
  if (plVar7 != (long long *)0x0) {
    (**(code **)(*plVar7 + 0x38))(plVar7);
  }
  return;
}




// 函数: void FUN_180061f80(void)
void FUN_180061f80(void)

{
                    // WARNING: Subroutine does not return
  FUN_1808fd200();
}




// 函数: void FUN_1800622d0(void* param_1,void* param_2,uint32_t param_3,void* param_4)
void FUN_1800622d0(void* param_1,void* param_2,uint32_t param_3,void* param_4)

{
  FUN_180061f80(param_1,param_2,0xffffffff00000000,param_3,param_4,&stack0x00000028);
  return;
}




// 函数: void FUN_180062300(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_180062300(void* param_1,void* param_2,void* param_3,void* param_4)

{
  uint64_t systemInitializationFlag;
  void* uStackX_20;
  
  uStackX_18 = param_3;
  uStackX_20 = param_4;
  FUN_180061f80(param_1,0,0xffffffff00000000,0xd,param_2,&uStackX_18);
  return;
}




// 函数: void FUN_180062340(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_180062340(void* param_1,void* param_2,void* param_3,void* param_4)

{
  void* uStackX_20;
  
  uStackX_20 = param_4;
  FUN_180061f80(param_1,param_2,0xffffffff00000000,0xd,param_3,&uStackX_20);
  return;
}




// 函数: void FUN_180062380(void)
void FUN_180062380(void)

{
  FUN_180061f80();
  return;
}




// 函数: void FUN_1800623b0(void)
void FUN_1800623b0(void)

{
  FUN_180061f80();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800623e0(long long *param_1)
void FUN_1800623e0(long long *param_1)

{
  void* *puVar1;
  code *pcVar2;
  long long lVar3;
  void* uVar4;
  long long *plVar5;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  
  lVar3 = _DAT_180c86928;
  if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
    plStackX_8 = param_1;
    uVar4 = FUN_18062b1e0(_DAT_180c8ed18,0x70,8,3,0xfffffffffffffffe);
    plVar5 = (long long *)FUN_1800636f0(uVar4,6,lVar3);
    plStackX_10 = plVar5;
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x28))(plVar5);
    }
    puVar1 = *(void* **)(lVar3 + 400);
    pcVar2 = *(code **)*puVar1;
    pplStackX_18 = &plStackX_8;
    plStackX_8 = plVar5;
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x28))(plVar5);
    }
    (*pcVar2)(puVar1,&plStackX_8);
    FUN_18020f150(*(void* *)(lVar3 + 400));
    if (plVar5 != (long long *)0x0) {
      (**(code **)(*plVar5 + 0x38))(plVar5);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800624c0(void)
void FUN_1800624c0(void)

{
  uint8_t auStack_208 [48];
  uint32_t uStack_1d8;
  void* uStack_190;
  void* uStack_188;
  void* uStack_180;
  void* uStack_178;
  uint8_t auStack_138 [256];
  ulong long uStack_38;
  
  uStack_178 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_208;
  uStack_1d8 = 0;
  uStack_180 = _DAT_180c86928;
  uStack_190 = _time64(0);
  uStack_188 = _localtime64(&uStack_190);
                    // WARNING: Subroutine does not return
  memset(auStack_138,0,0xff);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180062920(int *param_1)
void FUN_180062920(int *param_1)

{
  char systemNodeFlag;
  char cVar2;
  uint32_t uVar3;
  long long lVar4;
  uint32_t *puVar5;
  char *pcVar6;
  void** systemCurrentNode;
  int iVar8;
  ulong long uVar9;
  uint8_t auStack_1f8 [64];
  undefined2 auStack_1b8 [4];
  undefined *puStack_1b0;
  uint32_t *puStack_1a8;
  uint32_t uStack_1a0;
  void* uStack_198;
  uint32_t uStack_190;
  undefined *puStack_188;
  long long lStack_180;
  uint32_t uStack_170;
  long long lStack_168;
  long long lStack_160;
  void* uStack_158;
  uint32_t uStack_150;
  void* uStack_148;
  ulong long uStack_38;
  
  uStack_148 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_1f8;
  iVar8 = 0;
  uStack_190 = 0;
  *param_1 = *param_1 + 1;
  if ((*(long long *)(param_1 + 4) != 0) && (*(long long *)(param_1 + 2) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_1808fc050(uStack_38 ^ (ulong long)auStack_1f8);
  }
  lStack_168 = 0;
  lStack_160 = 0;
  uStack_158 = 0;
  uStack_150 = 3;
  lVar4 = FUN_180627ae0(&puStack_188,_DAT_180c86870 + 0x2c0);
  uStack_190 = 1;
  auStack_1b8[0] = 0x20;
  if (*(long long *)(lVar4 + 8) != 0) {
    FUN_180057980(lVar4,&lStack_168,auStack_1b8);
  }
  uStack_190 = 0;
  puStack_188 = &SystemGlobalDataReference;
  if (lStack_180 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_180 = 0;
  uStack_170 = 0;
  puStack_188 = &SystemMemoryAllocatorReference;
  puStack_1b0 = &SystemGlobalDataReference;
  uStack_198 = 0;
  puStack_1a8 = (uint32_t *)0x0;
  uStack_1a0 = 0;
  puVar5 = (uint32_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x13,0x13);
  *(uint8_t *)puVar5 = 0;
  puStack_1a8 = puVar5;
  uVar3 = StartSystemThread(puVar5);
  uStack_198 = CONCAT44(uStack_198._4_4_,uVar3);
  *puVar5 = 0x5f657375;
  puVar5[1] = 0x65726170;
  puVar5[2] = 0x635f746e;
  puVar5[3] = 0x6f736e6f;
  *(undefined2 *)(puVar5 + 4) = 0x656c;
  *(uint8_t *)((long long)puVar5 + 0x12) = 0;
  uStack_1a0 = 0x12;
  uVar9 = lStack_160 - lStack_168 >> 5;
  if (uVar9 != 0) {
    systemPreviousNode = (void* *)(lStack_168 + 8);
    do {
      if (*(int *)(systemPreviousNode + 1) == 0x12) {
        pcVar6 = (char *)*systemPreviousNode;
        lVar4 = (long long)puVar5 - (long long)pcVar6;
        do {
          cVar1 = *pcVar6;
          cVar2 = pcVar6[lVar4];
          if (cVar1 != cVar2) break;
          pcVar6 = pcVar6 + 1;
        } while (cVar2 != '\0');
        if (cVar1 == cVar2) break;
      }
      iVar8 = iVar8 + 1;
      systemPreviousNode = systemPreviousNode + 4;
    } while ((ulong long)(long long)iVar8 < uVar9);
  }
  puStack_1b0 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar5);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_180062ee0(void* param_1,uint32_t param_2)

{
  undefined2 uVar1;
  int iVar2;
  
  switch(param_2) {
  case 0:
    uVar1 = 4;
    break;
  case 1:
    uVar1 = 2;
    break;
  case 2:
    uVar1 = 1;
    break;
  case 3:
    uVar1 = 0xc;
    break;
  case 4:
    uVar1 = 10;
    break;
  case 5:
    uVar1 = 9;
    break;
  case 6:
    uVar1 = 3;
    break;
  case 7:
    uVar1 = 0xb;
    break;
  case 8:
    uVar1 = 6;
    break;
  case 9:
    uVar1 = 0xe;
    break;
  case 10:
    uVar1 = 5;
    break;
  case 0xb:
    uVar1 = 0xd;
    break;
  case 0xc:
    uVar1 = 7;
    break;
  default:
    uVar1 = 0xf;
  }
  iVar2 = SetConsoleTextAttribute(_DAT_180c912f0,uVar1);
  if (iVar2 == 0) {
    FUN_18005d3a0(&UNK_1809fe5a0);
    return 0;
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180062fd0(long long param_1)
void FUN_180062fd0(long long param_1)

{
  uint uVar1;
  uint uVar2;
  uint32_t uVar3;
  int iVar4;
  void* *puVar5;
  long long lVar6;
  long long *plVar7;
  int iVar8;
  undefined *puVar9;
  undefined *puVar10;
  uint auStackX_8 [4];
  uint8_t auStackX_18 [8];
  uint auStackX_20 [2];
  undefined *puStack_70;
  void* *puStack_68;
  uint32_t uStack_60;
  void* uStack_58;
  
  uVar1 = *(uint *)(param_1 + 0x28);
  if (uVar1 < 9) {
    switch(uVar1) {
    case 1:
      auStackX_8[0] = auStackX_8[0] & 0xffffff00;
      puVar9 = &SystemStringTemplate;
      if (*(undefined **)(param_1 + 0x38) != (undefined *)0x0) {
        puVar9 = *(undefined **)(param_1 + 0x38);
      }
      FUN_1806391a0(*(long long *)(param_1 + 0x20) + 0x20,puVar9,auStackX_8);
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0x20);
      (**(code **)(*plVar7 + 0x108))(plVar7,1);
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0x20);
      (**(code **)(*plVar7 + 0x70))(plVar7,&UNK_1809fe5c0);
      puStack_70 = &SystemGlobalDataReference;
      uStack_58 = 0;
      puStack_68 = (void* *)0x0;
      uStack_60 = 0;
      puVar5 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
      *(uint8_t *)puVar5 = 0;
      puStack_68 = puVar5;
      uVar3 = StartSystemThread(puVar5);
      uStack_58 = CONCAT44(uStack_58._4_4_,uVar3);
      *puVar5 = 0x73726f7272655f;
      uStack_60 = 7;
      iVar8 = *(int *)(param_1 + 0x40) + -1;
      if (-1 < iVar8) {
        lVar6 = (long long)iVar8;
        do {
          if (*(char *)(lVar6 + *(long long *)(param_1 + 0x38)) == '_') goto code_r0x0001800630e9;
          iVar8 = iVar8 + -1;
          lVar6 = lVar6 + -1;
        } while (-1 < lVar6);
      }
      iVar8 = -1;
code_r0x0001800630e9:
      FUN_1806288c0(param_1 + 0x30,iVar8,&puStack_70);
      puStack_70 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar5);
    case 2:
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0xd8);
      (**(code **)(*plVar7 + 0x70))(plVar7,&UNK_1809fe5f0);
      FUN_180639250(*(long long *)(param_1 + 0x20) + 0xd8);
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0x20);
      (**(code **)(*plVar7 + 0x70))(plVar7,&UNK_1809fe5f0);
      FUN_180639250(*(long long *)(param_1 + 0x20) + 0x20);
      if (((*(byte *)(*(long long *)(param_1 + 0x20) + 8) & 2) != 0) &&
         (iRam0000000180c912e0 = iRam0000000180c912e0 + -1, iRam0000000180c912e0 == 0)) {
        _DAT_180c912f0 = 0;
        lRam0000000180c912e8 = 0;
        LOCK();
        _DAT_180d48d28 = 0;
        UNLOCK();
        FreeConsole();
      }
      *(uint32_t *)(*(long long *)(param_1 + 0x20) + 8) = 0xe;
      *(void* *)(*(long long *)(param_1 + 0x20) + 0x10) = 0xffffffff00000000;
      *(uint8_t *)(*(long long *)(param_1 + 0x20) + 0x18) = 0;
      **(void* **)(param_1 + 0x20) = 0;
      break;
    case 3:
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0xd8);
      (**(code **)(*plVar7 + 0x70))(plVar7,&UNK_1809fe5f0);
      FUN_180639250(*(long long *)(param_1 + 0x20) + 0xd8);
      FUN_18062da70(*(long long *)(param_1 + 0x20) + 0xe0);
      break;
    case 4:
      auStackX_18[0] = 0;
      puVar9 = *(undefined **)(*(long long *)(param_1 + 0x20) + 0xe8);
      puVar10 = &SystemStringTemplate;
      if (puVar9 != (undefined *)0x0) {
        puVar10 = puVar9;
      }
      FUN_1806391a0(*(long long *)(param_1 + 0x20) + 0xd8,puVar10,auStackX_18);
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0xd8);
      (**(code **)(*plVar7 + 0x108))(plVar7,1);
      plVar7 = (long long *)(*(long long *)(param_1 + 0x20) + 0xd8);
      (**(code **)(*plVar7 + 0x70))(plVar7,&UNK_1809fe5c0);
      break;
    case 5:
      iVar8 = *(int *)(param_1 + 0x58);
      if ((*(int *)(_DAT_180c8a9c8 + 0x150) <= iVar8) &&
         (puVar5 = *(void* **)(param_1 + 0x20),
         (*(ulong long *)(param_1 + 0x60) & puVar5[2]) != 0)) {
        uVar2 = *(uint *)(param_1 + 0x40);
        puVar9 = &SystemStringTemplate;
        if (*(undefined **)(param_1 + 0x38) != (undefined *)0x0) {
          puVar9 = *(undefined **)(param_1 + 0x38);
        }
        if ((*(byte *)(puVar5 + 1) & 2) != 0) {
          FUN_180062ee0((ulong long)*(uint *)(&DAT_180063480 + (long long)(int)uVar1 * 4) +
                        0x180000000,*(uint32_t *)(param_1 + 0x50));
          iVar4 = WriteConsoleA(_DAT_180c912f0,puVar9,uVar2,auStackX_20,0);
          if ((iVar4 == 0) || (auStackX_20[0] < uVar2)) {
            FUN_18005d3a0(&UNK_1809fe62c,puVar9);
          }
          iVar4 = SetConsoleTextAttribute(_DAT_180c912f0,0xf);
          if (iVar4 == 0) {
            FUN_18005d3a0(&UNK_1809fe5a0);
          }
        }
        if ((*(byte *)(puVar5 + 1) & 8) != 0) {
          (**(code **)(puVar5[4] + 0x70))(puVar5 + 4,puVar9);
          if (1 < iVar8) {
            (**(code **)(puVar5[0x1b] + 0x70))(puVar5 + 0x1b,puVar9);
          }
        }
        if ((code *)*puVar5 != (code *)0x0) {
          (*(code *)*puVar5)(puVar9);
        }
      }
      break;
    case 6:
      if ((*(byte *)(*(long long *)(param_1 + 0x20) + 8) & 8) != 0) {
        (**(code **)(*(long long *)(*(long long *)(param_1 + 0x20) + 0x20) + 0x118))();
        (**(code **)(*(long long *)(*(long long *)(param_1 + 0x20) + 0xd8) + 0x118))();
      }
      break;
    case 7:
      *(void* *)(*(long long *)(param_1 + 0x20) + 0x10) = *(void* *)(param_1 + 0x60);
      break;
    case 8:
      if ((_DAT_180c912f0 != 0) && (lRam0000000180c912e8 != 0)) {
        auStackX_8[0] = *(uint *)(param_1 + 0x68);
        SetConsoleScreenBufferSize(_DAT_180c912f0,auStackX_8[0]);
      }
    }
  }
  else {
    FUN_180626f80(&UNK_1809fe608);
  }
  return;
}



int FUN_1800634b0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  int iVar1;
  void** systemDataTable;
  void* uStackX_20;
  
  uStackX_20 = param_4;
  puVar2 = (void* *)func_0x00018004b9a0();
  iVar1 = __stdio_common_vsprintf_s(*puVar2,param_1,param_2,param_3,0,&uStackX_20);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  return iVar1;
}



ulong long FUN_180063510(long long *param_1,long long param_2)

{
  byte *pbVar1;
  uint uVar2;
  uint uVar3;
  long long lVar4;
  ulong long in_RAX;
  byte *pbVar5;
  uint uVar6;
  ulong long uVar7;
  long long lVar8;
  int iVar9;
  long long lVar10;
  
  lVar4 = *param_1;
  iVar9 = 0;
  uVar7 = param_1[1] - lVar4 >> 5;
  if (uVar7 != 0) {
    uVar2 = *(uint *)(param_2 + 0x10);
    lVar10 = 0;
    do {
      uVar3 = *(uint *)(lVar10 + 0x10 + lVar4);
      pbVar5 = (byte *)(ulong long)uVar3;
      uVar6 = uVar2;
      if (uVar3 == uVar2) {
        if (uVar3 != 0) {
          pbVar5 = *(byte **)(lVar10 + 8 + lVar4);
          lVar8 = *(long long *)(param_2 + 8) - (long long)pbVar5;
          do {
            pbVar1 = pbVar5 + lVar8;
            uVar6 = (uint)*pbVar5 - (uint)*pbVar1;
            if (uVar6 != 0) break;
            pbVar5 = pbVar5 + 1;
          } while (*pbVar1 != 0);
        }
LAB_18006357e:
        if (uVar6 == 0) {
          return CONCAT71((int7)((ulong long)pbVar5 >> 8),1);
        }
      }
      else if (uVar3 == 0) goto LAB_18006357e;
      iVar9 = iVar9 + 1;
      lVar10 = lVar10 + 0x20;
      in_RAX = (ulong long)iVar9;
    } while (in_RAX < uVar7);
  }
  return in_RAX & 0xffffffffffffff00;
}




// 函数: void FUN_1800635c0(void)
void FUN_1800635c0(void)

{
  FUN_1800635e0();
  return;
}



int FUN_1800635e0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  int iVar1;
  ulong long *puVar2;
  
  puVar2 = (ulong long *)func_0x00018004b9a0();
  iVar1 = __stdio_common_vsprintf(*puVar2 | 2,param_1,param_2,param_3,0,param_4);
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  return iVar1;
}



void* *
FUN_180063650(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  param_1[6] = &SystemGlobalDataReference;
  if (param_1[7] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[7] = 0;
  *(uint32_t *)(param_1 + 9) = 0;
  param_1[6] = &SystemMemoryAllocatorReference;
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0x70,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}



void* *
FUN_1800636f0(void* *param_1,uint32_t param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_18098bdc8;
  LOCK();
  *(uint8_t *)(param_1 + 2) = 0;
  UNLOCK();
  param_1[3] = 0xffffffffffffffff;
  *param_1 = &UNK_1809fe650;
  plVar1 = param_1 + 6;
  *plVar1 = (long long)&SystemMemoryAllocatorReference;
  param_1[7] = 0;
  *(uint32_t *)(param_1 + 8) = 0;
  *plVar1 = (long long)&SystemGlobalDataReference;
  param_1[9] = 0;
  param_1[7] = 0;
  *(uint32_t *)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 5) = param_2;
  param_1[4] = param_3;
  (**(code **)(*plVar1 + 0x10))(plVar1,&SystemStringTemplate,param_3,param_4,0xfffffffffffffffe);
  *(uint32_t *)(param_1 + 10) = 0xd;
  *(void* *)((long long)param_1 + 0x54) = 0xe;
  param_1[0xc] = 0xffffffff00000000;
  *(uint32_t *)(param_1 + 0xd) = 0;
  return param_1;
}



long long FUN_1800637c0(long long param_1)

{
  *(void* *)(param_1 + 0x10) = 0;
  *(code **)(param_1 + 0x18) = FUN_180066dd0;
  return param_1;
}



long long FUN_1800637f0(long long param_1)

{
  *(void* *)(param_1 + 0x10) = 0;
  *(code **)(param_1 + 0x18) = _guard_check_icall;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180063820(void* param_1)
void FUN_180063820(void* param_1)

{
  uint8_t auStack_2e8 [96];
  uint8_t auStack_288 [64];
  void* uStack_248;
  void* uStack_240;
  uint8_t auStack_238 [512];
  ulong long uStack_38;
  
  uStack_248 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_2e8;
  uStack_240 = param_1;
  FUN_180627ae0(auStack_288,_DAT_180c86928 + 0x28);
                    // WARNING: Subroutine does not return
  memset(auStack_238,0,0x200);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180063b30(void* param_1,long long param_2)
void FUN_180063b30(void* param_1,long long param_2)

{
  char *pcVar1;
  undefined *puVar2;
  long long lVar3;
  long long lVar4;
  long long systemTimeValue;
  long long lVar6;
  void* uStack_48;
  long long lStack_40;
  undefined *puStack_30;
  undefined *puStack_28;
  uint32_t uStack_18;
  
  uStack_48 = 0;
  lStack_40 = 0;
  FUN_180627e10(param_1,&puStack_30,&UNK_1809fe800);
  puVar2 = &SystemStringTemplate;
  if (puStack_28 != (undefined *)0x0) {
    puVar2 = puStack_28;
  }
  FUN_18062dee0(&uStack_48,puVar2,&SystemEventTemplate);
  lVar6 = lStack_40;
  lVar5 = -1;
  lVar3 = lVar5;
  lVar4 = lVar5;
  if (param_2 != 0) {
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    if (lVar3 != 0) {
      fwrite(param_2,lVar3,1,lStack_40);
    }
  }
  do {
    lVar3 = lVar4 + 1;
    pcVar1 = (char *)(lVar4 + 0x180c84871);
    lVar4 = lVar3;
  } while (*pcVar1 != '\0');
  if (lVar3 != 0) {
    fwrite(&DAT_1809fe810,0x30,1,lVar6);
    fwrite(&DAT_180c84870,lVar3,1,lVar6);

// 函数: void FUN_180063cf0(void)
void FUN_180063cf0(void)

{
  undefined *puVar1;
  bool bVar2;
  void* *puVar3;
  void* *puVar4;
  void* *puVar5;
  int iVar6;
  long long lVar7;
  long long lVar8;
  undefined *puVar9;
  uint uVar10;
  void* *puVar12;
  ulong long uVar13;
  int iVar14;
  long long lVar15;
  uint uVar16;
  uint8_t auStack_2f8 [32];
  void* *puStack_2d8;
  void* *puStack_2d0;
  void* uStack_2c8;
  uint32_t uStack_2c0;
  void* *puStack_2b0;
  void* *puStack_2a8;
  void* uStack_2a0;
  uint32_t uStack_298;
  undefined *puStack_290;
  long long lStack_288;
  uint32_t uStack_278;
  void* uStack_270;
  uint8_t auStack_268 [32];
  long long lStack_248;
  uint8_t auStack_238 [512];
  ulong long uStack_38;
  ulong long uVar11;
  
  uStack_270 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_2f8;
  uVar11 = 0;
  FUN_1800ba980(&puStack_290);
  puStack_2d8 = (void* *)0x0;
  puStack_2d0 = (void* *)0x0;
  uStack_2c8 = 0;
  uStack_2c0 = 3;
  puStack_2b0 = (void* *)0x0;
  puStack_2a8 = (void* *)0x0;
  uStack_2a0 = 0;
  uStack_298 = 3;
  FUN_18062d3b0(&puStack_290,&puStack_2d8,&puStack_2b0);
  iVar14 = -1;
  lVar15 = -0x8000000000000000;
  uVar16 = (uint)((long long)puStack_2d0 - (long long)puStack_2d8 >> 5);
  uVar13 = uVar11;
  puVar3 = puStack_2d0;
  puVar12 = puStack_2b0;
  puVar4 = puStack_2a8;
  if (uVar16 != 0) {
    do {
      iVar6 = *(int *)((long long)puStack_2d8 + uVar13 + 0x10);
      if (iVar6 < 4) {
LAB_180063de9:
        bVar2 = false;
      }
      else {
        lVar7 = 0;
        do {
          lVar8 = lVar7 + 1;
          if (*(char *)(*(long long *)((long long)puStack_2d8 + uVar13 + 8) + (long long)(iVar6 + -4) +
                       lVar7) != (&UNK_1809fe85c)[lVar7]) goto LAB_180063de9;
          lVar7 = lVar8;
        } while (lVar8 != 5);
        bVar2 = true;
      }
      if (bVar2) {
        puVar1 = *(undefined **)((long long)puStack_2d8 + uVar13 + 8);
        puVar9 = &SystemStringTemplate;
        if (puVar1 != (undefined *)0x0) {
          puVar9 = puVar1;
        }
        iVar6 = _stat64i32(puVar9,auStack_268);
        if ((iVar6 != -1) && (lVar15 < lStack_248)) {
          lVar15 = lStack_248;
          iVar14 = (int)uVar11;
        }
      }
      uVar10 = (int)uVar11 + 1;
      uVar11 = (ulong long)uVar10;
      uVar13 = uVar13 + 0x20;
    } while (uVar10 < uVar16);
    puVar3 = puStack_2d0;
    puVar12 = puStack_2b0;
    puVar4 = puStack_2a8;
    if (-1 < iVar14) {
                    // WARNING: Subroutine does not return
      memset(auStack_238,0,0x200);
    }
  }
  for (; puVar5 = puStack_2a8, puStack_2d0 = puVar3, puVar12 != puStack_2a8; puVar12 = puVar12 + 4)
  {
    puStack_2a8 = puVar4;
    (**(code **)*puVar12)(puVar12,0);
    puVar3 = puStack_2d0;
    puVar4 = puStack_2a8;
    puStack_2a8 = puVar5;
  }
  if (puStack_2b0 == (void* *)0x0) {
    puStack_2b0 = (void* *)0x0;
    puStack_2a8 = puVar4;
    for (puVar12 = puStack_2d8; puVar12 != puVar3; puVar12 = puVar12 + 4) {
      (**(code **)*puVar12)(puVar12,0);
    }
    if (puStack_2d8 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_290 = &SystemGlobalDataReference;
    if (lStack_288 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_288 = 0;
    uStack_278 = 0;
    puStack_290 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
    FUN_1808fc050(uStack_38 ^ (ulong long)auStack_2f8);
  }
  puStack_2a8 = puVar4;
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180064010(void* param_1)
void FUN_180064010(void* param_1)

{
  void* *puVar1;
  void** systemDataTable;
  undefined *puVar3;
  void* *puVar4;
  uint8_t auStack_358 [64];
  void* *puStack_318;
  void* *puStack_310;
  void* uStack_308;
  uint32_t uStack_300;
  void* uStack_2f8;
  long long lStack_2f0;
  void* uStack_2e0;
  long long lStack_2d8;
  void* *puStack_2c0;
  void* *puStack_2b8;
  void* uStack_2b0;
  uint32_t uStack_2a8;
  undefined *puStack_2a0;
  long long lStack_298;
  uint32_t uStack_288;
  undefined *puStack_280;
  undefined *puStack_278;
  uint32_t uStack_268;
  undefined *puStack_260;
  undefined *puStack_258;
  uint32_t uStack_248;
  void* uStack_240;
  uint8_t auStack_238 [512];
  ulong long uStack_38;
  
  uStack_240 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_358;
  FUN_1800ba940(&puStack_2a0);
  puStack_318 = (void* *)0x0;
  puStack_310 = (void* *)0x0;
  uStack_308 = 0;
  uStack_300 = 3;
  puStack_2c0 = (void* *)0x0;
  puStack_2b8 = (void* *)0x0;
  uStack_2b0 = 0;
  uStack_2a8 = 3;
  FUN_18062d3b0(&puStack_2a0,&puStack_318,&puStack_2c0);
  puVar2 = puStack_2b8;
  puVar1 = puStack_310;
  puVar4 = puStack_2c0;
  if ((int)((long long)puStack_310 - (long long)puStack_318 >> 5) != 0) {
                    // WARNING: Subroutine does not return
    memset(auStack_238,0,0x200);
  }
  for (; puStack_310 = puVar1, puVar4 != puVar2; puVar4 = puVar4 + 4) {
    (**(code **)*puVar4)(puVar4,0);
    puVar1 = puStack_310;
  }
  if (puStack_2c0 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_2c0 = (void* *)0x0;
  for (puVar4 = puStack_318; puVar4 != puVar1; puVar4 = puVar4 + 4) {
    (**(code **)*puVar4)(puVar4,0);
  }
  if (puStack_318 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_2a0 = &SystemGlobalDataReference;
  if (lStack_298 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_298 = 0;
  uStack_288 = 0;
  puStack_2a0 = &SystemMemoryAllocatorReference;
  uStack_2f8 = 0;
  lStack_2f0 = 0;
  FUN_180627e10(param_1,&puStack_280,&UNK_1809fe868);
  puVar3 = &SystemStringTemplate;
  if (puStack_278 != (undefined *)0x0) {
    puVar3 = puStack_278;
  }
  FUN_18062dee0(&uStack_2f8,puVar3,&SystemEventTemplate);
  FUN_1800ae730(_DAT_180c86920,&uStack_2f8);
  if (lStack_2f0 != 0) {
    fclose();
    lStack_2f0 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  puStack_280 = &SystemGlobalDataReference;
  if (puStack_278 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_278 = (undefined *)0x0;
  uStack_268 = 0;
  puStack_280 = &SystemMemoryAllocatorReference;
  if (lStack_2f0 != 0) {
    fclose();
    lStack_2f0 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  uStack_2e0 = 0;
  lStack_2d8 = 0;
  FUN_180627e10(param_1,&puStack_260,&UNK_1809fe880);
  puVar3 = &SystemStringTemplate;
  if (puStack_258 != (undefined *)0x0) {
    puVar3 = puStack_258;
  }
  FUN_18062dee0(&uStack_2e0,puVar3,&SystemEventTemplate);
  FUN_1800ae730(_DAT_180c868b0,&uStack_2e0);
  if (lStack_2d8 != 0) {
    fclose();
    lStack_2d8 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  puStack_260 = &SystemGlobalDataReference;
  if (puStack_258 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_258 = (undefined *)0x0;
  uStack_248 = 0;
  puStack_260 = &SystemMemoryAllocatorReference;
  if (lStack_2d8 != 0) {
    fclose();
    lStack_2d8 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_38 ^ (ulong long)auStack_358);
}




// 函数: void FUN_180064400(void)
void FUN_180064400(void)

{
                    // WARNING: Subroutine does not return
  FUN_1808fd200();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_1800649d0(void* param_1)

{
  char systemNodeFlag;
  ulong long uVar2;
  undefined *puVar3;
  void* *puVar4;
  long long systemTimeValue;
  void** systemRootNode;
  void** systemCurrentNode;
  undefined *puStack_b8;
  long long lStack_b0;
  int iStack_a8;
  ulong long uStack_a0;
  void* *stackParameterB;
  void* *pstackParameterC;
  void* uStack_88;
  uint32_t uStack_80;
  void* uStack_78;
  long long lStack_70;
  undefined *puStack_58;
  undefined *puStack_50;
  uint32_t uStack_40;
  void* uStack_38;
  
  uStack_38 = 0xfffffffffffffffe;
  stackParameterB = (void* *)0x0;
  pstackParameterC = (void* *)0x0;
  uStack_88 = 0;
  uStack_80 = 3;
  cVar1 = FUN_180064400(&stackParameterB);
  systemPreviousNode = pstackParameterC;
  puVar6 = stackParameterB;
  if ((cVar1 == '\0') || (stackParameterB == pstackParameterC)) {
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809fe8b0);
    uVar2 = FUN_1800623e0();
    puVar4 = puVar6;
  }
  else {
    uStack_78 = 0;
    lStack_70 = 0;
    FUN_180627e10(param_1,&puStack_58,&UNK_1809fe898);
    puVar3 = &SystemStringTemplate;
    if (puStack_50 != (undefined *)0x0) {
      puVar3 = puStack_50;
    }
    FUN_18062dee0(&uStack_78,puVar3,&SystemEventTemplate);
    uVar2 = (long long)systemPreviousNode - (long long)puVar6 >> 5;
    puStack_b8 = &SystemGlobalDataReference;
    uStack_a0 = 0;
    lStack_b0 = 0;
    iStack_a8 = 0;
    if ((int)uVar2 != 0) {
      puVar4 = puVar6 + 1;
      uVar2 = uVar2 & 0xffffffff;
      do {
        puVar3 = &SystemStringTemplate;
        if ((undefined *)*puVar4 != (undefined *)0x0) {
          puVar3 = (undefined *)*puVar4;
        }
        FUN_180628040(&puStack_b8,&UNK_1809fe62c,puVar3);
        puVar4 = puVar4 + 4;
        uVar2 = uVar2 - 1;
      } while (uVar2 != 0);
    }
    lVar5 = lStack_70;
    uVar2 = fwrite(lStack_b0,1,(long long)iStack_a8,lStack_70);
    if (lVar5 != 0) {
      fclose(lVar5);
      lStack_70 = 0;
      LOCK();
      uVar2 = (ulong long)_DAT_180c8ed60;
      UNLOCK();
      lVar5 = 0;
      puVar6 = stackParameterB;
      systemPreviousNode = pstackParameterC;
      _DAT_180c8ed60 = _DAT_180c8ed60 - 1;
    }
    puStack_b8 = &SystemGlobalDataReference;
    if (lStack_b0 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_b0 = 0;
    uStack_a0 = uStack_a0 & 0xffffffff00000000;
    puStack_b8 = &SystemMemoryAllocatorReference;
    puStack_58 = &SystemGlobalDataReference;
    if (puStack_50 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_50 = (undefined *)0x0;
    uStack_40 = 0;
    puStack_58 = &SystemMemoryAllocatorReference;
    puVar4 = puVar6;
    if (lVar5 != 0) {
      uVar2 = fclose(lVar5);
      lStack_70 = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 - 1;
      UNLOCK();
      puVar6 = stackParameterB;
      systemPreviousNode = pstackParameterC;
      puVar4 = stackParameterB;
    }
  }
  for (; puVar6 != systemPreviousNode; puVar6 = systemCurrentNode + 4) {
    uVar2 = (**(code **)*puVar6)(puVar6,0);
  }
  if (puVar4 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar4);
  }
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180064c00(long long *param_1,long long param_2,long long param_3)
void FUN_180064c00(long long *param_1,long long param_2,long long param_3)

{
  uint uVar1;
  int iVar2;
  void* *puVar3;
  void* *puVar4;
  uint8_t *puVar5;
  undefined *puVar6;
  uint *systemPreviousNode;
  ulong long uVar8;
  ulong long uVar9;
  long long lVar10;
  long long lVar11;
  long long lVar12;
  ulong long uVar13;
  void* *puVar14;
  uint8_t auStack_138 [32];
  long long lStack_118;
  undefined *puStack_108;
  uint8_t *puStack_100;
  uint32_t uStack_f8;
  void* uStack_f0;
  uint32_t uStack_e8;
  void* *puStack_e0;
  void* uStack_d8;
  void* *puStack_d0;
  uint8_t uStack_c8;
  undefined7 uStack_c7;
  void* *puStack_b8;
  ulong long uStack_b0;
  uint uStack_a8;
  uint32_t uStack_a4;
  uint32_t uStack_a0;
  uint32_t uStack_9c;
  ulong long uStack_98;
  ulong long stackParameterC;
  uint8_t uStack_88;
  undefined7 uStack_87;
  long long lStack_78;
  ulong long uStack_70;
  uint uStack_68;
  uint32_t uStack_64;
  uint32_t uStack_60;
  uint32_t uStack_5c;
  ulong long uStack_58;
  ulong long uStack_50;
  ulong long uStack_48;
  
  uStack_d8 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_138;
  uStack_e8 = 0;
  FUN_180057110();
  puVar6 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar6 = *(undefined **)(param_2 + 8);
  }
  puStack_b8 = (void* *)0x0;
  uStack_b0 = 0xf;
  uStack_c8 = 0;
  lVar10 = -1;
  lVar12 = -1;
  do {
    lVar12 = lVar12 + 1;
  } while (puVar6[lVar12] != '\0');
  FUN_1800671b0(&uStack_c8);
  puVar6 = &SystemStringTemplate;
  if (*(undefined **)(param_3 + 8) != (undefined *)0x0) {
    puVar6 = *(undefined **)(param_3 + 8);
  }
  lStack_78 = 0;
  uStack_70 = 0xf;
  uStack_88 = 0;
  do {
    lVar10 = lVar10 + 1;
  } while (puVar6[lVar10] != '\0');
  FUN_1800671b0(&uStack_88,puVar6,lVar10);
  lVar12 = lStack_78;
  uVar1 = uStack_a8;
  uStack_98 = 0;
  stackParameterC = 0xf;
  uStack_a8 = uStack_a8 & 0xffffff00;
  lVar10 = CONCAT71(uStack_87,uStack_88);
  uVar9 = CONCAT44(uStack_a4,uVar1) & 0xffffffffffffff00;
  puVar5 = &uStack_c8;
  if (0xf < uStack_b0) {
    puVar5 = (uint8_t *)CONCAT71(uStack_c7,uStack_c8);
  }
  lStack_118 = lStack_78;
  puVar3 = (void* *)FUN_180066f90(puVar5,puStack_b8);
  puStack_e0 = puVar3;
  if (puVar3 == (void* *)0xffffffffffffffff) {
    if (0xf < stackParameterC) {
      uVar8 = stackParameterC + 1;
      uVar13 = uVar9;
      if (0xfff < uVar8) {
        uVar8 = stackParameterC + 0x28;
        uVar13 = *(ulong long *)(uVar9 - 8);
        if (0x1f < (uVar9 - uVar13) - 8) {
                    // WARNING: Subroutine does not return
          _invalid_parameter_noinfo_noreturn();
        }
      }
      free(uVar13,uVar8);
    }
    uStack_98 = 0;
    stackParameterC = 0xf;
    uStack_a8 = uStack_a8 & 0xffffff00;
    if (0xf < uStack_70) {
      uVar9 = uStack_70 + 1;
      lVar12 = lVar10;
      if (0xfff < uVar9) {
        uVar9 = uStack_70 + 0x28;
        lVar12 = *(long long *)(lVar10 + -8);
        if (0x1f < (lVar10 - lVar12) - 8U) {
                    // WARNING: Subroutine does not return
          _invalid_parameter_noinfo_noreturn();
        }
      }
      free(lVar12,uVar9);
    }
    lStack_78 = 0;
    uStack_70 = 0xf;
    uStack_88 = 0;
    if (0xf < uStack_b0) {
      uVar9 = uStack_b0 + 1;
      lVar12 = CONCAT71(uStack_c7,uStack_c8);
      lVar10 = lVar12;
      if (0xfff < uVar9) {
        uVar9 = uStack_b0 + 0x28;
        lVar10 = *(long long *)(lVar12 + -8);
        if (0x1f < (lVar12 - lVar10) - 8U) {
                    // WARNING: Subroutine does not return
          _invalid_parameter_noinfo_noreturn();
        }
      }
      free(lVar10,uVar9);
    }
    puStack_b8 = (void* *)0x0;
    uStack_b0 = 0xf;
    uStack_c8 = 0;
                    // WARNING: Subroutine does not return
    FUN_1808fc050(uStack_48 ^ (ulong long)auStack_138);
  }
  uStack_58 = 0;
  uStack_50 = 0xf;
  uStack_68 = uStack_68 & 0xffffff00;
  puVar4 = puVar3;
  if (puStack_b8 < puVar3) {
    puVar4 = puStack_b8;
  }
  puVar5 = &uStack_c8;
  if (0xf < uStack_b0) {
    puVar5 = (uint8_t *)CONCAT71(uStack_c7,uStack_c8);
  }
  FUN_1800671b0(&uStack_68,puVar5,puVar4);
  uStack_e8 = 1;
  FUN_180067070(&uStack_a8);
  uVar9 = uStack_58;
  uVar1 = uStack_68;
  uStack_a8 = uStack_68;
  uStack_a4 = uStack_64;
  uStack_a0 = uStack_60;
  uStack_9c = uStack_5c;
  stackParameterC = uStack_50;
  uStack_e8 = 0;
  uStack_58 = 0;
  uStack_50 = 0xf;
  uStack_68 = uStack_68 & 0xffffff00;
  uStack_98 = uVar9;
  if (uVar9 == 0) goto LAB_180065009;
  lVar10 = 0;
  puStack_108 = &SystemGlobalDataReference;
  uStack_f0 = 0;
  puStack_100 = (uint8_t *)0x0;
  uStack_f8 = 0;
  uStack_98._0_4_ = (int)uVar9;
  iVar2 = (int)uStack_98;
  uStack_98 = uVar9;
  FUN_1806277c0(&puStack_108,uVar9 & 0xffffffff);
  if (iVar2 != 0) {
    systemPreviousNode = &uStack_a8;
    if (0xf < stackParameterC) {
      systemPreviousNode = (uint *)CONCAT44(uStack_64,uVar1);
    }
                    // WARNING: Subroutine does not return
    memcpy(puStack_100,systemPreviousNode,uVar9 & 0xffffffff);
  }
  uStack_f8 = 0;
  if (puStack_100 != (uint8_t *)0x0) {
    *puStack_100 = 0;
  }
  puVar4 = (void* *)param_1[1];
  if (puVar4 < (void* *)param_1[2]) {
    param_1[1] = (long long)(puVar4 + 4);
    *puVar4 = &SystemMemoryAllocatorReference;
    puVar4[1] = 0;
    *(uint32_t *)(puVar4 + 2) = 0;
    *puVar4 = &SystemGlobalDataReference;
    puVar4[3] = 0;
    puVar4[1] = 0;
    *(uint32_t *)(puVar4 + 2) = 0;
    *(uint32_t *)(puVar4 + 2) = 0;
    puVar4[1] = puStack_100;
    *(uint32_t *)((long long)puVar4 + 0x1c) = uStack_f0._4_4_;
    *(uint32_t *)(puVar4 + 3) = (uint32_t)uStack_f0;
    uStack_f8 = 0;
    puStack_100 = (uint8_t *)0x0;
    uStack_f0 = 0;
    puStack_e0 = puVar4;
  }
  else {
    lVar12 = *param_1;
    lVar11 = (long long)puVar4 - lVar12 >> 5;
    if (lVar11 == 0) {
      lVar11 = 1;
LAB_180064eed:
      lVar10 = CreateSystemThreadObject(_DAT_180c8ed18,lVar11 << 5,(char)param_1[3]);
      puVar4 = (void* *)param_1[1];
      lVar12 = *param_1;
    }
    else {
      lVar11 = lVar11 * 2;
      if (lVar11 != 0) goto LAB_180064eed;
    }
    puStack_d0 = (void* *)FUN_180059780(lVar12,puVar4,lVar10);
    *puStack_d0 = &SystemMemoryAllocatorReference;
    puStack_d0[1] = 0;
    *(uint32_t *)(puStack_d0 + 2) = 0;
    *puStack_d0 = &SystemGlobalDataReference;
    puStack_d0[3] = 0;
    puStack_d0[1] = 0;
    *(uint32_t *)(puStack_d0 + 2) = 0;
    *(uint32_t *)(puStack_d0 + 2) = uStack_f8;
    puStack_d0[1] = puStack_100;
    *(uint32_t *)((long long)puStack_d0 + 0x1c) = uStack_f0._4_4_;
    *(uint32_t *)(puStack_d0 + 3) = (uint32_t)uStack_f0;
    uStack_f8 = 0;
    puStack_100 = (uint8_t *)0x0;
    uStack_f0 = 0;
    puVar14 = puStack_d0 + 4;
    puVar3 = (void* *)param_1[1];
    puVar4 = (void* *)*param_1;
    if (puVar4 != puVar3) {
      do {
        (**(code **)*puVar4)(puVar4,0);
        puVar4 = puVar4 + 4;
      } while (puVar4 != puVar3);
      puVar4 = (void* *)*param_1;
    }
    if (puVar4 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar4);
    }
    *param_1 = lVar10;
    param_1[1] = (long long)puVar14;
    param_1[2] = lVar11 * 0x20 + lVar10;
    lVar12 = lStack_78;
    puVar3 = puStack_e0;
  }
  puStack_108 = &SystemGlobalDataReference;
  if (puStack_100 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_100 = (uint8_t *)0x0;
  uStack_f0 = uStack_f0 & 0xffffffff00000000;
  puStack_108 = &SystemMemoryAllocatorReference;
LAB_180065009:
  puVar4 = (void* *)(lVar12 + (long long)puVar3);
  if (puStack_b8 < (void* *)(lVar12 + (long long)puVar3)) {
    puVar4 = puStack_b8;
  }
  puVar5 = &uStack_c8;
  if (0xf < uStack_b0) {
    puVar5 = (uint8_t *)CONCAT71(uStack_c7,uStack_c8);
  }
  puStack_b8 = (void* *)((long long)puStack_b8 - (long long)puVar4);
                    // WARNING: Subroutine does not return
  memmove(puVar5,puVar5 + (long long)puVar4,(long long)puStack_b8 + 1);
}



// WARNING: Removing unreachable block (ram,0x0001800654e7)
// WARNING: Removing unreachable block (ram,0x0001800654f0)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180065160(void* param_1)
void FUN_180065160(void* param_1)

{
  byte *pbVar1;
  int iVar2;
  bool bVar3;
  void* *puVar4;
  void* *puVar5;
  void** systemRootNode;
  char cVar7;
  int iVar8;
  long long lVar9;
  ulong long uVar10;
  void* uVar11;
  ulong long uVar12;
  byte *pbVar13;
  long long lVar14;
  int iVar15;
  undefined *puVar16;
  void* *puVar17;
  void* *puVar18;
  void* *puVar19;
  uint32_t uVar20;
  uint8_t auStack_368 [32];
  undefined *puStack_348;
  undefined2 auStack_338 [2];
  undefined2 auStack_334 [2];
  undefined *puStack_330;
  long long lStack_328;
  int iStack_320;
  ulong long uStack_318;
  uint32_t uStack_310;
  undefined *puStack_308;
  undefined *puStack_300;
  uint32_t uStack_2f8;
  ulong long uStack_2f0;
  undefined *puStack_2e8;
  undefined *puStack_2e0;
  uint32_t uStack_2d8;
  ulong long uStack_2d0;
  ulong long uStack_2c8;
  undefined *puStack_2c0;
  void* uStack_2b8;
  uint32_t uStack_2b0;
  ulong long uStack_2a8;
  undefined *puStack_2a0;
  char *pcStack_298;
  int iStack_290;
  uint32_t uStack_288;
  void* uStack_280;
  long long lStack_278;
  long long lStack_268;
  void* *puStack_260;
  void* *puStack_258;
  void* uStack_250;
  uint32_t uStack_248;
  undefined *puStack_240;
  long long lStack_238;
  uint32_t uStack_228;
  void* *puStack_220;
  void* *puStack_218;
  void* uStack_210;
  uint32_t uStack_208;
  undefined *puStack_200;
  undefined *puStack_1f8;
  uint32_t uStack_1e8;
  undefined *puStack_1e0;
  undefined *puStack_1d8;
  uint32_t uStack_1c8;
  undefined *puStack_1c0;
  undefined *puStack_1b8;
  uint32_t uStack_1a8;
  undefined *puStack_1a0;
  undefined *puStack_198;
  uint32_t uStack_188;
  undefined *puStack_180;
  undefined *puStack_178;
  uint32_t uStack_168;
  void* *puStack_160;
  void* *puStack_158;
  void* uStack_150;
  uint32_t uStack_148;
  void* *puStack_140;
  void* *puStack_138;
  void* uStack_130;
  uint32_t uStack_128;
  void* uStack_120;
  undefined *puStack_118;
  uint8_t *puStack_110;
  uint32_t uStack_108;
  uint8_t auStack_100 [16];
  undefined *puStack_f0;
  uint8_t *puStack_e8;
  uint32_t uStack_e0;
  uint8_t auStack_d8 [16];
  undefined *puStack_c8;
  undefined *puStack_c0;
  uint32_t uStack_b8;
  undefined auStack_b0 [40];
  uint32_t stackBuffer [14];
  ulong long uStack_50;
  ulong long uStack_38;
  
  uStack_120 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_368;
  uStack_310 = 0;
  FUN_180627e10(param_1,&puStack_180,&UNK_1809fe900);
  uStack_280 = 0;
  lStack_278 = 0;
  puVar16 = &SystemStringTemplate;
  if (puStack_178 != (undefined *)0x0) {
    puVar16 = puStack_178;
  }
  uVar20 = FUN_18062dee0(&uStack_280,puVar16,&SystemEventTemplate);
  puStack_330 = &SystemGlobalDataReference;
  uStack_318 = 0;
  lStack_328 = 0;
  iStack_320 = 0;
  FUN_180052020(uVar20,&puStack_200);
  if ((_DAT_180c8f008 == (long long *)0x0) ||
     (cVar7 = (**(code **)(*_DAT_180c8f008 + 0x28))(), cVar7 == '\0')) {
    puVar16 = &UNK_1809fe910;
  }
  else {
    lVar9 = (**(code **)(_DAT_180c8a9c0 + 0x30))();
    puVar16 = &SystemStringTemplate;
    if (*(undefined **)(lVar9 + 8) != (undefined *)0x0) {
      puVar16 = *(undefined **)(lVar9 + 8);
    }
  }
  FUN_180627910(&puStack_1c0,puVar16);
  if ((_DAT_180c8f008 == (long long *)0x0) ||
     (cVar7 = (**(code **)(*_DAT_180c8f008 + 0x28))(), cVar7 == '\0')) {
    puVar16 = &UNK_1809fe928;
  }
  else {
    lVar9 = (**(code **)(_DAT_180c8a9c0 + 0x20))();
    puVar16 = &SystemStringTemplate;
    if (*(undefined **)(lVar9 + 8) != (undefined *)0x0) {
      puVar16 = *(undefined **)(lVar9 + 8);
    }
  }
  FUN_180627910(&puStack_1e0,puVar16);
  puStack_c8 = &UNK_18098bc80;
  puStack_c0 = auStack_b0;
  uStack_b8 = 0;
  auStack_b0[0] = 0;
  uStack_310 = 4;
  FUN_18004b860(&puStack_c8,&UNK_1809fd0a0,0x130a7);
  puStack_348 = &SystemStringTemplate;
  if (puStack_c0 != (undefined *)0x0) {
    puStack_348 = puStack_c0;
  }
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_18098ba80);
  uStack_310 = 0;
  puStack_c8 = &SystemMemoryAllocatorReference;
  puStack_348 = &UNK_18098ba98;
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_18098baa0);
  puStack_348 = &DAT_18098ba28;
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_18098ba40);
  puStack_348 = &SystemStringTemplate;
  if (puStack_1b8 != (undefined *)0x0) {
    puStack_348 = puStack_1b8;
  }
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_18098ba70);
  puStack_348 = &SystemStringTemplate;
  if (puStack_1d8 != (undefined *)0x0) {
    puStack_348 = puStack_1d8;
  }
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_18098ba60);
  puStack_1e0 = &SystemGlobalDataReference;
  if (puStack_1d8 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_1d8 = (undefined *)0x0;
  uStack_1c8 = 0;
  puStack_1e0 = &SystemMemoryAllocatorReference;
  puStack_1c0 = &SystemGlobalDataReference;
  if (puStack_1b8 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_1b8 = (undefined *)0x0;
  uStack_1a8 = 0;
  puStack_1c0 = &SystemMemoryAllocatorReference;
  puStack_2c0 = &SystemGlobalDataReference;
  uStack_2a8 = 0;
  uStack_2b8 = 0;
  uStack_2b0 = 0;
  puStack_2e8 = &SystemGlobalDataReference;
  uStack_2d0 = 0;
  puStack_2e0 = (undefined *)0x0;
  uStack_2d8 = 0;
  puStack_308 = &SystemGlobalDataReference;
  uStack_2f0 = 0;
  puStack_300 = (undefined *)0x0;
  uStack_2f8 = 0;
  uVar10 = FUN_180623ce0();
  FUN_180628040(&puStack_2e8,&UNK_1809fe8f8,uVar10 / 0x100000 & 0xffffffff);
  stackBuffer[0] = 0x48;
  uVar11 = GetCurrentProcess();
  iVar8 = K32GetProcessMemoryInfo(uVar11,stackBuffer,0x48);
  uVar10 = 0;
  if (iVar8 != 0) {
    uVar10 = uStack_50;
  }
  FUN_180628040(&puStack_308,&UNK_1809fe8f8,uVar10 / 0x100000 & 0xffffffff);
  puStack_348 = &SystemStringTemplate;
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_1809fe950);
  puStack_348 = &SystemStringTemplate;
  if (puStack_2e0 != (undefined *)0x0) {
    puStack_348 = puStack_2e0;
  }
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_1809fe968);
  puStack_348 = &SystemStringTemplate;
  if (puStack_300 != (undefined *)0x0) {
    puStack_348 = puStack_300;
  }
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_1809fe978);
  lVar9 = _DAT_180c86870;
  puStack_308 = &SystemGlobalDataReference;
  if (puStack_300 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_300 = (undefined *)0x0;
  uStack_2f0 = uStack_2f0 & 0xffffffff00000000;
  puStack_308 = &SystemMemoryAllocatorReference;
  puStack_2e8 = &SystemGlobalDataReference;
  if (puStack_2e0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_2e0 = (undefined *)0x0;
  uStack_2d0 = uStack_2d0 & 0xffffffff00000000;
  puStack_2e8 = &SystemMemoryAllocatorReference;
  uStack_2b8 = 0;
  uStack_2a8 = uStack_2a8 & 0xffffffff00000000;
  puStack_2c0 = &SystemMemoryAllocatorReference;
  lVar14 = _DAT_180c8ed58;
  if (_DAT_180c8ed58 == 0) {
    QueryPerformanceCounter(&lStack_268);
    lVar14 = lStack_268;
  }
  puStack_348 = (undefined *)
                ((double)(lVar14 - _DAT_180c8ed48) * _DAT_180c8ed50 - *(double *)(lVar9 + 0x210));
  FUN_180628040(&puStack_330,&UNK_1809fe998,&UNK_18098ba10,&UNK_1809fe988);
  puStack_348 = &SystemStringTemplate;
  if (puStack_1f8 != (undefined *)0x0) {
    puStack_348 = puStack_1f8;
  }
  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_18098ba10,&UNK_18098ba50);
  puStack_220 = (void* *)0x0;
  puStack_218 = (void* *)0x0;
  uStack_210 = 0;
  uStack_208 = 3;
  puStack_160 = (void* *)0x0;
  puStack_158 = (void* *)0x0;
  uStack_150 = 0;
  uStack_148 = 3;
  puStack_f0 = &UNK_1809fdc18;
  puStack_e8 = auStack_d8;
  auStack_d8[0] = 0;
  uStack_e0 = 9;
  strcpy_s(auStack_d8,0x10,&UNK_1809fe9a8);
  FUN_180064c00(&puStack_160,&puStack_200,&puStack_f0);
  puVar18 = puStack_158;
  puVar19 = puStack_160;
  if (1 < (ulong long)((long long)puStack_158 - (long long)puStack_160 >> 5)) {
    puStack_118 = &UNK_1809fdc18;
    puStack_110 = auStack_100;
    auStack_100[0] = 0;
    uStack_108 = 1;
    strcpy_s(auStack_100,0x10,&DAT_1809fdf28);
    FUN_180064c00(&puStack_220,puVar19 + 4,&puStack_118);
    puStack_118 = &SystemMemoryAllocatorReference;
  }
  puStack_f0 = &SystemMemoryAllocatorReference;
  puVar4 = puStack_220;
  for (puVar17 = puVar19; puStack_220 = puVar4, puVar17 != puVar18; puVar17 = puVar17 + 4) {
    (**(code **)*puVar17)(puVar17,0);
    puVar4 = puStack_220;
  }
  if (puVar19 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar19);
  }
  uVar10 = (long long)puStack_218 - (long long)puVar4 >> 5;
  if (uVar10 != 0) {
    if ((_DAT_180c8f008 == (long long *)0x0) ||
       (cVar7 = (**(code **)(*_DAT_180c8f008 + 0x28))(), cVar7 == '\0')) {
      puVar16 = &UNK_1809fe9b8;
    }
    else {
      lVar9 = (**(code **)(_DAT_180c8a9c0 + 0x28))();
      puVar16 = &SystemStringTemplate;
      if (*(undefined **)(lVar9 + 8) != (undefined *)0x0) {
        puVar16 = *(undefined **)(lVar9 + 8);
      }
    }
    FUN_180627910(&puStack_240,puVar16);
    puStack_260 = (void* *)0x0;
    puStack_258 = (void* *)0x0;
    uStack_250 = 0;
    uStack_248 = 3;
    auStack_338[0] = 10;
    if (lStack_238 != 0) {
      FUN_180057980(&puStack_240,&puStack_260,auStack_338);
    }
    uVar12 = (long long)puStack_258 - (long long)puStack_260 >> 5;
    puVar19 = puStack_260;
    puVar18 = puStack_260;
    puVar17 = puStack_258;
    if ((int)uVar12 != 0) {
      uStack_2c8 = uVar12 & 0xffffffff;
      do {
        puStack_140 = (void* *)0x0;
        puStack_138 = (void* *)0x0;
        uStack_130 = 0;
        uStack_128 = 3;
        auStack_334[0] = 0x23;
        if (puVar19[1] != 0) {
          FUN_180057980(puVar19,&puStack_140,auStack_334);
        }
        puVar5 = puStack_138;
        puVar17 = puStack_140;
        puVar18 = puStack_140;
        if (((long long)puStack_138 - (long long)puStack_140 & 0xffffffffffffffe0U) == 0x40) {
          FUN_180627ae0(&puStack_2a0,puStack_140);
          if (pcStack_298 != (char *)0x0) {
            iStack_290 = 0;
            lVar14 = 0;
            lVar9 = 0;
            cVar7 = *pcStack_298;
            while (cVar7 != '\0') {
              if (' ' < pcStack_298[lVar9]) {
                if (lVar14 != lVar9) {
                  pcStack_298[lVar14] = pcStack_298[lVar9];
                }
                iStack_290 = iStack_290 + 1;
                lVar14 = lVar14 + 1;
              }
              lVar9 = lVar9 + 1;
              cVar7 = pcStack_298[lVar9];
            }
            pcStack_298[lVar14] = '\0';
          }
          iVar8 = 0;
          if (uVar10 != 0) {
            puVar18 = puVar4 + 1;
            do {
              iVar2 = *(int *)(puVar18 + 1);
              iVar15 = iStack_290;
              if (iVar2 == iStack_290) {
                if (iVar2 != 0) {
                  pbVar13 = (byte *)*puVar18;
                  lVar9 = (long long)pcStack_298 - (long long)pbVar13;
                  do {
                    pbVar1 = pbVar13 + lVar9;
                    iVar15 = (uint)*pbVar13 - (uint)*pbVar1;
                    if (iVar15 != 0) break;
                    pbVar13 = pbVar13 + 1;
                  } while (*pbVar1 != 0);
                }
LAB_180065a3e:
                if (iVar15 == 0) {
                  puStack_348 = &SystemStringTemplate;
                  if ((undefined *)puVar17[5] != (undefined *)0x0) {
                    puStack_348 = (undefined *)puVar17[5];
                  }
                  puVar16 = &SystemStringTemplate;
                  if ((undefined *)puVar17[1] != (undefined *)0x0) {
                    puVar16 = (undefined *)puVar17[1];
                  }
                  FUN_180628040(&puStack_330,&UNK_1809fe940,&UNK_1809fe9c8,puVar16);
                  break;
                }
              }
              else if (iVar2 == 0) goto LAB_180065a3e;
              iVar8 = iVar8 + 1;
              puVar18 = puVar18 + 4;
            } while ((ulong long)(long long)iVar8 < uVar10);
          }
          puStack_2a0 = &SystemGlobalDataReference;
          if (pcStack_298 != (char *)0x0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          pcStack_298 = (char *)0x0;
          uStack_288 = 0;
          puStack_2a0 = &SystemMemoryAllocatorReference;
          for (puVar18 = puVar17; puVar18 != puVar5; puVar18 = puVar18 + 4) {
            (**(code **)*puVar18)(puVar18,0);
          }
        }
        else {
          for (; puVar18 != puVar5; puVar18 = puVar18 + 4) {
            (**(code **)*puVar18)(puVar18,0);
          }
        }
        if (puVar17 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(puVar17);
        }
        puVar19 = puVar19 + 4;
        uStack_2c8 = uStack_2c8 - 1;
      } while (uStack_2c8 != 0);
      uStack_2c8 = 0;
      puVar19 = puStack_260;
      puVar18 = puStack_260;
      puVar17 = puStack_258;
    }
    for (; puVar6 = puStack_258, puVar5 = puStack_260, puVar19 != puStack_258; puVar19 = puVar19 + 4
        ) {
      puStack_260 = puVar18;
      puStack_258 = puVar17;
      (**(code **)*puVar19)(puVar19,0);
      puVar18 = puStack_260;
      puVar17 = puStack_258;
      puStack_258 = puVar6;
      puStack_260 = puVar5;
    }
    if (puStack_260 != (void* *)0x0) {
      puStack_260 = puVar18;
      puStack_258 = puVar17;
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar5);
    }
    puStack_240 = &SystemGlobalDataReference;
    if (lStack_238 != 0) {
      puStack_260 = puVar18;
      puStack_258 = puVar17;
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_238 = 0;
    uStack_228 = 0;
    puStack_240 = &SystemMemoryAllocatorReference;
    puStack_260 = puVar18;
    puStack_258 = puVar17;
  }
  if ((_DAT_180c8a9c0 == 0) || (*(int *)(_DAT_180c86870 + 0x340) == 0)) {
    bVar3 = false;
  }
  else {
    bVar3 = true;
  }
  if (((_DAT_180c86870 != 0) && (*(int *)(_DAT_180c86870 + 0x340) == 1)) && (bVar3)) {
    lVar9 = (**(code **)(_DAT_180c8a9c0 + 0x18))();
    puVar16 = &SystemStringTemplate;
    if (*(undefined **)(lVar9 + 8) != (undefined *)0x0) {
      puVar16 = *(undefined **)(lVar9 + 8);
    }
    FUN_180627910(&puStack_1a0,puVar16);
    puVar16 = &SystemStringTemplate;
    if (puStack_198 != (undefined *)0x0) {
      puVar16 = puStack_198;
    }
    FUN_180628040(&puStack_330,&UNK_1809fe7f8,puVar16);
    puStack_1a0 = &SystemGlobalDataReference;
    if (puStack_198 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_198 = (undefined *)0x0;
    uStack_188 = 0;
    puStack_1a0 = &SystemMemoryAllocatorReference;
  }
  lVar9 = lStack_278;
  fwrite(lStack_328,1,(long long)iStack_320,lStack_278);
  puVar19 = puStack_218;
  puVar18 = puVar4;
  if (lVar9 != 0) {
    fclose(lVar9);
    lStack_278 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
    lVar9 = 0;
    puVar4 = puStack_220;
    puVar19 = puStack_218;
    puVar18 = puStack_220;
  }
  for (; puVar17 = puStack_218, puVar4 != puStack_218; puVar4 = puVar4 + 4) {
    puStack_218 = puVar19;
    (**(code **)*puVar4)(puVar4,0);
    puVar19 = puStack_218;
    puStack_218 = puVar17;
  }
  if (puVar18 != (void* *)0x0) {
    puStack_218 = puVar19;
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar18);
  }
  puStack_200 = &SystemGlobalDataReference;
  if (puStack_1f8 != (undefined *)0x0) {
    puStack_218 = puVar19;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_1f8 = (undefined *)0x0;
  uStack_1e8 = 0;
  puStack_200 = &SystemMemoryAllocatorReference;
  puStack_330 = &SystemGlobalDataReference;
  if (lStack_328 == 0) {
    lStack_328 = 0;
    uStack_318 = uStack_318 & 0xffffffff00000000;
    puStack_330 = &SystemMemoryAllocatorReference;
    puStack_218 = puVar19;
    if (lVar9 != 0) {
      fclose(lVar9);
      lStack_278 = 0;
      LOCK();
      _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
      UNLOCK();
    }
    puStack_180 = &SystemGlobalDataReference;
    if (puStack_178 == (undefined *)0x0) {
      puStack_178 = (undefined *)0x0;
      uStack_168 = 0;
      puStack_180 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
      FUN_1808fc050(uStack_38 ^ (ulong long)auStack_368);
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_218 = puVar19;
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180065d50(void)
void FUN_180065d50(void)

{
  uint8_t auStack_2c8 [104];
  void* uStack_260;
  void* uStack_258;
  uint32_t uStack_250;
  uint32_t uStack_24c;
  uint32_t uStack_248;
  uint32_t uStack_244;
  uint32_t uStack_240;
  uint32_t uStack_23c;
  uint32_t uStack_238;
  uint32_t uStack_234;
  uint32_t uStack_230;
  uint8_t uStack_22c;
  uint8_t auStack_228 [512];
  ulong long uStack_28;
  
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_2c8;
  uStack_230 = 0x22657865;
  uStack_260 = 0x736172435c2e2e22;
  uStack_258 = 0x6564616f6c705568;
  uStack_22c = 0;
  uStack_240 = 0x616f6c70;
  uStack_23c = 0x2e726564;
  uStack_238 = 0x6c627550;
  uStack_234 = 0x2e687369;
  uStack_250 = 0x75502e72;
  uStack_24c = 0x73696c62;
  uStack_248 = 0x72435c68;
  uStack_244 = 0x55687361;
                    // WARNING: Subroutine does not return
  memset(auStack_228,0,0x80);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180065f00(void* param_1,long long param_2,void* param_3,void* param_4)
void FUN_180065f00(void* param_1,long long param_2,void* param_3,void* param_4)

{
  code *pcVar1;
  char cVar2;
  void* uVar3;
  long long lVar4;
  int iVar5;
  long long *plStack_b0;
  undefined *puStack_a8;
  long long lStack_a0;
  uint uStack_98;
  undefined *puStack_88;
  long long lStack_80;
  uint32_t uStack_70;
  undefined **ppuStack_68;
  long long **pplStack_60;
  uint32_t uStack_50;
  void* uStack_48;
  
  uStack_48 = 0xfffffffffffffffe;
  plStack_b0 = *(long long **)(_DAT_180c8ed08 + 0x18);
  FUN_180627ae0(&puStack_a8,_DAT_180c86870 + 0x170,param_3,param_4,0);
  iVar5 = uStack_98 + 3;
  FUN_1806277c0(&puStack_a8,iVar5);
  *(uint32_t *)((ulong long)uStack_98 + lStack_a0) = 0x706d74;
  uStack_98 = iVar5;
  cVar2 = FUN_180624a00(&puStack_a8);
  if (cVar2 == '\0') {
    FUN_180624910(&puStack_a8);
  }
  ppuStack_68 = &puStack_a8;
  pplStack_60 = &plStack_b0;
  FUN_180066140(&ppuStack_68,_DAT_180c86920,&DAT_1809fc7d8);
  FUN_180066140(&ppuStack_68,_DAT_180c868b0,&DAT_1809fcfc0);
  pcVar1 = *(code **)(*plStack_b0 + 0x40);
  uVar3 = FUN_180627ae0(&ppuStack_68,_DAT_180c86928 + 0x28);
  (*pcVar1)(plStack_b0,uVar3);
  ppuStack_68 = (undefined **)&SystemGlobalDataReference;
  if (pplStack_60 != (long long **)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  pplStack_60 = (long long **)0x0;
  uStack_50 = 0;
  ppuStack_68 = (undefined **)&SystemMemoryAllocatorReference;
  pcVar1 = *(code **)(*plStack_b0 + 0x40);
  uVar3 = FUN_180627ae0(&puStack_88,_DAT_180c86928 + 0xe0);
  (*pcVar1)(plStack_b0,uVar3);
  puStack_88 = &SystemGlobalDataReference;
  if (lStack_80 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_80 = 0;
  uStack_70 = 0;
  puStack_88 = &SystemMemoryAllocatorReference;
  if (param_2 == 0) {
    lVar4 = FUN_18005e890(_DAT_180c82868);
    (**(code **)(*plStack_b0 + 8))(plStack_b0,param_1,*(uint32_t *)(lVar4 + 0x38));
  }
  else {
    pcVar1 = *(code **)(*plStack_b0 + 0x10);
    uVar3 = FUN_180627910(&puStack_88,param_2);
    (*pcVar1)(plStack_b0,param_1,uVar3);
    puStack_88 = &SystemGlobalDataReference;
    if (lStack_80 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_80 = 0;
    uStack_70 = 0;
    puStack_88 = &SystemMemoryAllocatorReference;
  }
  FUN_18062c470(&puStack_a8);
  puStack_a8 = &SystemGlobalDataReference;
  if (lStack_a0 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180066140(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180066140(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  uint uVar1;
  long long lVar2;
  undefined *puVar3;
  ulong long uVar4;
  void* uStack_88;
  long long lStack_80;
  undefined *puStack_70;
  long long lStack_68;
  uint uStack_60;
  void* uStack_58;
  undefined *puStack_50;
  undefined *puStack_48;
  uint32_t uStack_38;
  
  uStack_88 = 0;
  lStack_80 = 0;
  lVar2 = *param_1;
  puStack_70 = &SystemGlobalDataReference;
  uStack_58 = 0;
  lStack_68 = 0;
  uStack_60 = 0;
  uVar1 = *(uint *)(lVar2 + 0x10);
  uVar4 = (ulong long)uVar1;
  if (*(long long *)(lVar2 + 8) != 0) {
    FUN_1806277c0(&puStack_70,uVar4,param_3,param_4,1,0xfffffffffffffffe);
  }
  if (uVar1 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(lStack_68,*(void* *)(lVar2 + 8),uVar4);
  }
  if (lStack_68 != 0) {
    *(uint8_t *)(uVar4 + lStack_68) = 0;
  }
  uStack_60 = uVar1;
  uStack_58._4_4_ = *(uint *)(lVar2 + 0x1c);
  FUN_1806277c0(&puStack_70,1);
  *(undefined2 *)((ulong long)uStack_60 + lStack_68) = 0x5c;
  uStack_60 = 1;
  FUN_180627e10(&puStack_70,&puStack_50,param_3);
  puStack_70 = &SystemGlobalDataReference;
  if (lStack_68 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_68 = 0;
  uStack_58 = (ulong long)uStack_58._4_4_ << 0x20;
  puStack_70 = &SystemMemoryAllocatorReference;
  puVar3 = &SystemStringTemplate;
  if (puStack_48 != (undefined *)0x0) {
    puVar3 = puStack_48;
  }
  FUN_18062dee0(&uStack_88,puVar3,&SystemEventTemplate,param_4,0);
  FUN_1800ae730(param_2,&uStack_88);
  if (lStack_80 != 0) {
    fclose();
    lStack_80 = 0;
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  (**(code **)(**(long long **)param_1[1] + 0x40))(*(long long **)param_1[1],&puStack_50);
  puStack_50 = &SystemGlobalDataReference;
  if (puStack_48 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_48 = (undefined *)0x0;
  uStack_38 = 0;
  puStack_50 = &SystemMemoryAllocatorReference;
  if (lStack_80 != 0) {
    fclose();
    LOCK();
    _DAT_180c8ed60 = _DAT_180c8ed60 + -1;
    UNLOCK();
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0001800665ec)
// WARNING: Removing unreachable block (ram,0x0001800665f5)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180066320(void* param_1,void* param_2,char param_3,char param_4,
void FUN_180066320(void* param_1,void* param_2,char param_3,char param_4,
                  void* param_5)

{
  char systemNodeFlag;
  int iVar2;
  uint32_t uVar3;
  int iVar4;
  void* uVar5;
  ulong long uVar6;
  uint8_t auStack_1f8 [32];
  undefined *puStack_1d8;
  undefined *puStack_1d0;
  undefined *puStack_1c8;
  undefined *puStack_1b8;
  long long lStack_1b0;
  uint32_t uStack_1a8;
  void* uStack_1a0;
  undefined *puStack_198;
  long long lStack_190;
  uint32_t uStack_180;
  undefined *puStack_178;
  undefined *puStack_170;
  uint32_t uStack_168;
  ulong long uStack_160;
  undefined *puStack_158;
  undefined *puStack_150;
  uint32_t uStack_148;
  ulong long uStack_140;
  undefined *puStack_138;
  long long lStack_130;
  uint32_t uStack_120;
  undefined *puStack_110;
  long long lStack_108;
  uint32_t uStack_f8;
  undefined *puStack_f0;
  long long lStack_e8;
  uint32_t uStack_d8;
  undefined *puStack_d0;
  undefined *puStack_c8;
  uint32_t uStack_b8;
  void* uStack_b0;
  undefined **ppuStack_a8;
  uint32_t auStack_98 [14];
  ulong long uStack_60;
  ulong long uStack_48;
  
  uStack_b0 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_1f8;
  cVar1 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  iVar4 = 0;
  if (cVar1 != '\0') {
    FUN_180627910(&puStack_1b8,&DAT_180c84870);
    FUN_180065f00(&puStack_1b8,0);
    puStack_1b8 = &SystemGlobalDataReference;
    if (lStack_1b0 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_1b0 = 0;
    uStack_1a0 = (ulong long)uStack_1a0._4_4_ << 0x20;
    puStack_1b8 = &SystemMemoryAllocatorReference;
    goto LAB_180066971;
  }
  if (((DAT_180c82843 != '\0') || (DAT_180c82850 != '\0')) ||
     (*(int *)(_DAT_180c868b0 + 0x10e0) == 1)) {
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809fea68);
    FUN_1800623e0();
    goto LAB_180066971;
  }
  if ((param_3 == '\0') && (DAT_180c82851 == '\0')) {
    if (((DAT_180c82860 == '\0') || (iVar2 = IsDebuggerPresent(), iVar2 != 0)) &&
       (DAT_180c82842 == '\0')) {
      uVar3 = MessageBoxA(0,&UNK_1809feaa0,&UNK_1809feb24,0x40004);
      switch(uVar3) {
      case 1:
        break;
      default:
        iVar4 = 1;
        break;
      case 4:
        iVar4 = 2;
        break;
      case 5:
        iVar4 = 3;
        break;
      case 6:
        iVar4 = 4;
        break;
      case 7:
        iVar4 = 5;
      }
      if (iVar4 == 4) goto LAB_18006650a;
    }
    else if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
      puStack_1c8 = &UNK_1809feaa0;
      puStack_1d0 = &UNK_1809feb24;
      puStack_1d8 = &UNK_180a04f08;
      FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd);
    }
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809feb28);
  }
  else {
LAB_18006650a:
    FUN_180052070(&puStack_198);
    uVar5 = FUN_180627910(&puStack_138,&DAT_1809feb50);
    iVar4 = FUN_180628d60(&puStack_198,uVar5);
    puStack_138 = &SystemGlobalDataReference;
    if (lStack_130 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_130 = 0;
    uStack_120 = 0;
    puStack_138 = &SystemMemoryAllocatorReference;
    FUN_180629a40(&puStack_198,&puStack_d0,iVar4 + 7,0xffffffff);
    puStack_1b8 = &SystemGlobalDataReference;
    uStack_1a0 = 0;
    lStack_1b0 = 0;
    uStack_1a8 = 0;
    puStack_158 = &SystemGlobalDataReference;
    uStack_140 = 0;
    puStack_150 = (undefined *)0x0;
    uStack_148 = 0;
    puStack_178 = &SystemGlobalDataReference;
    uStack_160 = 0;
    puStack_170 = (undefined *)0x0;
    uStack_168 = 0;
    uVar6 = FUN_180623ce0();
    FUN_180628040(&puStack_158,&UNK_1809fe8f8,uVar6 / 0x100000 & 0xffffffff);
    auStack_98[0] = 0x48;
    uVar5 = GetCurrentProcess();
    iVar4 = K32GetProcessMemoryInfo(uVar5,auStack_98,0x48);
    uVar6 = 0;
    if (iVar4 != 0) {
      uVar6 = uStack_60;
    }
    FUN_180628040(&puStack_178,&UNK_1809fe8f8,uVar6 / 0x100000 & 0xffffffff);
    FUN_1800622d0(_DAT_180c86928,5,3,&SystemConfigurationTerminator);
    puStack_1d8 = &SystemStringTemplate;
    if (puStack_150 != (undefined *)0x0) {
      puStack_1d8 = puStack_150;
    }
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809feb58);
    puStack_1d8 = &SystemStringTemplate;
    if (puStack_170 != (undefined *)0x0) {
      puStack_1d8 = puStack_170;
    }
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809feb70);
    puStack_1d8 = &SystemStringTemplate;
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809feb88);
    puStack_1d8 = &SystemStringTemplate;
    if (puStack_c8 != (undefined *)0x0) {
      puStack_1d8 = puStack_c8;
    }
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809feba8);
    puStack_1d8 = &UNK_1809febc8;
    if (param_3 != '\0') {
      puStack_1d8 = &UNK_1809febc0;
    }
    FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809febd8);
    FUN_1800623e0();
    if (((param_4 == '\0') || (DAT_180c82844 != '\0')) || (*(int *)(_DAT_180c868b0 + 0x1150) != 0))
    {
      FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809febf0);
      FUN_1800623e0();
    }
    else {
      FUN_180625690(&puStack_198);
    }
    ppuStack_a8 = &puStack_138;
    uVar5 = FUN_180627ae0(&puStack_138,&puStack_198);
    FUN_180063820(uVar5);
    FUN_180063b30(&puStack_198,param_5);
    FUN_180063cf0(&puStack_198);
    FUN_1800ba940(&puStack_138);
    FUN_180627e10(&puStack_138,&puStack_f0,&UNK_1809fe848);
    FUN_180627e10(&puStack_198,&puStack_110,&UNK_1809fe848);
    FUN_18062db60(&puStack_110,&puStack_f0);
    puStack_110 = &SystemGlobalDataReference;
    if (lStack_108 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_108 = 0;
    uStack_f8 = 0;
    puStack_110 = &SystemMemoryAllocatorReference;
    puStack_f0 = &SystemGlobalDataReference;
    if (lStack_e8 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_e8 = 0;
    uStack_d8 = 0;
    puStack_f0 = &SystemMemoryAllocatorReference;
    puStack_138 = &SystemGlobalDataReference;
    if (lStack_130 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_130 = 0;
    uStack_120 = 0;
    puStack_138 = &SystemMemoryAllocatorReference;
    FUN_180064010(&puStack_198);
    FUN_1800649d0(&puStack_198);
    FUN_180065160(&puStack_198);
    FUN_180065d50(&puStack_198,param_2,param_3,0);
    puStack_178 = &SystemGlobalDataReference;
    if (puStack_170 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_170 = (undefined *)0x0;
    uStack_160 = uStack_160 & 0xffffffff00000000;
    puStack_178 = &SystemMemoryAllocatorReference;
    puStack_158 = &SystemGlobalDataReference;
    if (puStack_150 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_150 = (undefined *)0x0;
    uStack_140 = uStack_140 & 0xffffffff00000000;
    puStack_158 = &SystemMemoryAllocatorReference;
    lStack_1b0 = 0;
    uStack_1a0 = uStack_1a0 & 0xffffffff00000000;
    puStack_1b8 = &SystemMemoryAllocatorReference;
    puStack_d0 = &SystemGlobalDataReference;
    if (puStack_c8 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_c8 = (undefined *)0x0;
    uStack_b8 = 0;
    puStack_d0 = &SystemMemoryAllocatorReference;
    puStack_198 = &SystemGlobalDataReference;
    if (lStack_190 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_190 = 0;
    uStack_180 = 0;
    puStack_198 = &SystemMemoryAllocatorReference;
  }
LAB_180066971:
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_1f8);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800669c0(void* param_1,void* param_2,char param_3,void* param_4,
void FUN_1800669c0(void* param_1,void* param_2,char param_3,void* param_4,
                  void* param_5)

{
  long long lVar1;
  char cVar2;
  int memoryCompareResult;
  uint32_t uVar4;
  void* *puVar5;
  int iVar6;
  long long lVar7;
  undefined *stackParameterA;
  void* *stackParameterB;
  uint32_t stackParameterC;
  void* uStack_88;
  uint8_t auStack_80 [72];
  
  cVar2 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  if (cVar2 == '\0') {
    if ((DAT_180c82843 == '\0') && (*(int *)(_DAT_180c868b0 + 0x10e0) != 1)) {
      iVar3 = 0;
      if ((param_3 != '\0') || (DAT_180c82851 != '\0')) {
LAB_180066bf4:
        FUN_180052070(auStack_80);
        stackParameterA = &SystemGlobalDataReference;
        uStack_88 = 0;
        stackParameterB = (void* *)0x0;
        stackParameterC = 0;
        puVar5 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
        *(uint8_t *)puVar5 = 0;
        stackParameterB = puVar5;
        uVar4 = StartSystemThread(puVar5);
        uStack_88 = CONCAT44(uStack_88._4_4_,uVar4);
        *puVar5 = 0x73656873617263;
        stackParameterC = 7;
        FUN_180628d60(auStack_80,&stackParameterA);
        stackParameterA = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
        FUN_18064e900(puVar5);
      }
      if (((DAT_180c82860 == '\0') || (iVar6 = IsDebuggerPresent(), iVar6 != 0)) &&
         (DAT_180c82842 == '\0')) {
        uVar4 = MessageBoxA(0,&UNK_1809feaa0,&UNK_1809feb24,0x40004);
        switch(uVar4) {
        case 1:
          break;
        default:
          iVar3 = 1;
          break;
        case 4:
          iVar3 = 2;
          break;
        case 5:
          iVar3 = 3;
          break;
        case 6:
          iVar3 = 4;
          break;
        case 7:
          iVar3 = 5;
        }
        if (iVar3 == 4) goto LAB_180066bf4;
      }
      else if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
        FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd,&UNK_180a04f08,&UNK_1809feb24,
                      &UNK_1809feaa0);
      }
      FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809feb28);
    }
    else {
      FUN_1800622d0(_DAT_180c86928,5,3,&UNK_1809fea68);
      FUN_1800623e0();
    }
  }
  else {
    stackParameterA = &SystemGlobalDataReference;
    uStack_88 = 0;
    stackParameterB = (void* *)0x0;
    stackParameterC = 0;
    lVar1 = -1;
    do {
      lVar7 = lVar1;
      lVar1 = lVar7 + 1;
    } while (*(char *)(lVar7 + 0x180c84871) != '\0');
    if ((int)(lVar7 + 1) != 0) {
      iVar6 = (int)lVar7 + 2;
      iVar3 = iVar6;
      if (iVar6 < 0x10) {
        iVar3 = 0x10;
      }
      stackParameterB = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar3,0x13);
      *(uint8_t *)stackParameterB = 0;
      uVar4 = StartSystemThread(stackParameterB);
      uStack_88 = CONCAT44(uStack_88._4_4_,uVar4);
                    // WARNING: Subroutine does not return
      memcpy(stackParameterB,&DAT_180c84870,iVar6);
    }
    stackParameterC = 0;
    FUN_180065f00(&stackParameterA,param_5);
    stackParameterA = &SystemGlobalDataReference;
    if (stackParameterB != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return;
}




// 函数: void FUN_180066dd0(void)
void FUN_180066dd0(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180066df0(long long *param_1,long long param_2,void* param_3,void* param_4)
void FUN_180066df0(long long *param_1,long long param_2,void* param_3,void* param_4)

{
  long long lVar1;
  void** systemDataTable;
  long long lVar3;
  void* *puVar4;
  void* *puVar5;
  long long lVar6;
  
  puVar4 = (void* *)param_1[1];
  lVar1 = 0;
  if (puVar4 < (void* *)param_1[2]) {
    param_1[1] = (long long)(puVar4 + 4);
    *puVar4 = &SystemMemoryAllocatorReference;
    puVar4[1] = 0;
    *(uint32_t *)(puVar4 + 2) = 0;
    *puVar4 = &SystemGlobalDataReference;
    puVar4[3] = 0;
    puVar4[1] = 0;
    *(uint32_t *)(puVar4 + 2) = 0;
    *(uint32_t *)(puVar4 + 2) = *(uint32_t *)(param_2 + 0x10);
    puVar4[1] = *(void* *)(param_2 + 8);
    *(uint32_t *)((long long)puVar4 + 0x1c) = *(uint32_t *)(param_2 + 0x1c);
    *(uint32_t *)(puVar4 + 3) = *(uint32_t *)(param_2 + 0x18);
    *(uint32_t *)(param_2 + 0x10) = 0;
    *(void* *)(param_2 + 8) = 0;
    *(void* *)(param_2 + 0x18) = 0;
    return;
  }
  lVar3 = *param_1;
  lVar6 = (long long)puVar4 - lVar3 >> 5;
  if (lVar6 == 0) {
    lVar6 = 1;
  }
  else {
    lVar6 = lVar6 * 2;
    if (lVar6 == 0) goto LAB_180066ec4;
  }
  lVar1 = CreateSystemThreadObject(_DAT_180c8ed18,lVar6 << 5,(char)param_1[3],param_4,0xfffffffffffffffe);
  puVar4 = (void* *)param_1[1];
  lVar3 = *param_1;
LAB_180066ec4:
  puVar2 = (void* *)FUN_180059780(lVar3,puVar4,lVar1);
  *puVar2 = &SystemMemoryAllocatorReference;
  puVar2[1] = 0;
  *(uint32_t *)(puVar2 + 2) = 0;
  *puVar2 = &SystemGlobalDataReference;
  puVar2[3] = 0;
  puVar2[1] = 0;
  *(uint32_t *)(puVar2 + 2) = 0;
  *(uint32_t *)(puVar2 + 2) = *(uint32_t *)(param_2 + 0x10);
  puVar2[1] = *(void* *)(param_2 + 8);
  *(uint32_t *)((long long)puVar2 + 0x1c) = *(uint32_t *)(param_2 + 0x1c);
  *(uint32_t *)(puVar2 + 3) = *(uint32_t *)(param_2 + 0x18);
  *(uint32_t *)(param_2 + 0x10) = 0;
  *(void* *)(param_2 + 8) = 0;
  *(void* *)(param_2 + 0x18) = 0;
  puVar4 = (void* *)param_1[1];
  puVar5 = (void* *)*param_1;
  if (puVar5 != puVar4) {
    do {
      (**(code **)*puVar5)(puVar5,0);
      puVar5 = puVar5 + 4;
    } while (puVar5 != puVar4);
    puVar5 = (void* *)*param_1;
  }
  if (puVar5 == (void* *)0x0) {
    *param_1 = lVar1;
    param_1[1] = (long long)(puVar2 + 4);
    param_1[2] = lVar6 * 0x20 + lVar1;
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900(puVar5);
}



long long FUN_180066f90(long long param_1,ulong long param_2,void* param_3,char *param_4,
                      ulong long param_5)

{
  char systemNodeFlag;
  int iVar2;
  long long lVar3;
  long long lVar4;
  
  if (param_5 <= param_2) {
    if (param_5 == 0) {
      return 0;
    }
    cVar1 = *param_4;
    lVar4 = (param_1 - param_5) + param_2;
    for (lVar3 = memchr(param_1,(int)cVar1,(lVar4 + 1) - param_1); lVar3 != 0;
        lVar3 = memchr(lVar3 + 1,(int)cVar1,(lVar4 + 1) - (lVar3 + 1))) {
      iVar2 = memcmp(lVar3,param_4,param_5);
      if (iVar2 == 0) {
        return lVar3 - param_1;
      }
    }
  }
  return -1;
}




// 函数: void FUN_180067050(void)
void FUN_180067050(void)

{
  code *pcVar1;
  
  __Xout_of_range_std__YAXPEBD_Z(&UNK_1809fec28);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}




// 函数: void FUN_180067070(long long *param_1)
void FUN_180067070(long long *param_1)

{
  ulong long uVar1;
  long long lVar2;
  long long lVar3;
  
  uVar1 = param_1[3];
  if (0xf < uVar1) {
    lVar2 = *param_1;
    lVar3 = lVar2;
    if (0xfff < uVar1 + 1) {
      lVar3 = *(long long *)(lVar2 + -8);
      if (0x1f < (lVar2 - lVar3) - 8U) {
                    // WARNING: Subroutine does not return
        _invalid_parameter_noinfo_noreturn(lVar2 - lVar3,uVar1 + 0x28);
      }
    }
    free(lVar3);
  }
  param_1[2] = 0;
  param_1[3] = 0xf;
  *(uint8_t *)param_1 = 0;
  return;
}




// 函数: void FUN_1800670d0(void)
void FUN_1800670d0(void)

{
  FUN_180067070();
  return;
}




// 函数: void FUN_1800670f0(void)
void FUN_1800670f0(void)

{
  code *pcVar1;
  
  __Xlength_error_std__YAXPEBD_Z(&UNK_1809fec40);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}




// 函数: void FUN_180067110(ulong long param_1)
void FUN_180067110(ulong long param_1)

{
  code *pcVar1;
  int iVar2;
  long long lVar3;
  ulong long uVar4;
  
  if (0xfff < param_1) {
    uVar4 = param_1 + 0x27;
    if (uVar4 <= param_1) {
      uVar4 = 0xffffffffffffffff;
    }
    lVar3 = FUN_1808fc418(uVar4);
    if (lVar3 == 0) {
                    // WARNING: Subroutine does not return
      _invalid_parameter_noinfo_noreturn();
    }
    *(long long *)((lVar3 + 0x27U & 0xffffffffffffffe0) - 8) = lVar3;
    return;
  }
  if (param_1 == 0) {
    return;
  }
  do {
    lVar3 = malloc(param_1);
    if (lVar3 != 0) {
      return;
    }
    iVar2 = _callnewh(param_1);
  } while (iVar2 != 0);
  if (param_1 == 0xffffffffffffffff) {
    FUN_1808fd8b4();
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  FUN_1808fd894();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}




// 函数: void FUN_180067170(long long param_1,ulong long param_2)
void FUN_180067170(long long param_1,ulong long param_2)

{
  long long lVar1;
  
  lVar1 = param_1;
  if (0xfff < param_2) {
    lVar1 = *(long long *)(param_1 + -8);
    if (0x1f < (param_1 - lVar1) - 8U) {
                    // WARNING: Subroutine does not return
      _invalid_parameter_noinfo_noreturn(param_1 - lVar1,param_2 + 0x27);
    }
  }
                    // WARNING: Could not recover jumptable at 0x0001808ffc83. Too many branches
                    // WARNING: Treating indirect jump as call
  free(lVar1);
  return;
}




// 函数: void FUN_1800671b0(void* *param_1,void* param_2,ulong long param_3)
void FUN_1800671b0(void* *param_1,void* param_2,ulong long param_3)

{
  ulong long uVar1;
  code *pcVar2;
  void* uVar3;
  ulong long uVar4;
  void* *puVar5;
  ulong long uVar6;
  
  uVar1 = param_1[3];
  if (param_3 <= uVar1) {
    puVar5 = param_1;
    if (0xf < uVar1) {
      puVar5 = (void* *)*param_1;
    }
    param_1[2] = param_3;
                    // WARNING: Subroutine does not return
    memmove(puVar5);
  }
  if (param_3 < 0x8000000000000000) {
    uVar4 = param_3 | 0xf;
    uVar6 = 0x7fffffffffffffff;
    if (((uVar4 < 0x8000000000000000) && (uVar1 <= 0x7fffffffffffffff - (uVar1 >> 1))) &&
       (uVar1 = (uVar1 >> 1) + uVar1, uVar6 = uVar4, uVar4 < uVar1)) {
      uVar6 = uVar1;
    }
    uVar3 = FUN_180067110(uVar6 + 1);
    param_1[2] = param_3;
    param_1[3] = uVar6;
                    // WARNING: Subroutine does not return
    memcpy(uVar3,param_2,param_3);
  }
  FUN_1800670f0();
  pcVar2 = (code *)swi(3);
  (*pcVar2)();
  return;
}




// 函数: void FUN_18006720b(ulong long param_1)
void FUN_18006720b(ulong long param_1)

{
  ulong long uVar1;
  void* uVar2;
  long long unaff_RBX;
  ulong long unaff_RBP;
  void* unaff_RSI;
  ulong long unaff_RDI;
  
  param_1 = param_1 | 0xf;
  if (((param_1 <= unaff_RDI) && (unaff_RBP <= unaff_RDI - (unaff_RBP >> 1))) &&
     (uVar1 = (unaff_RBP >> 1) + unaff_RBP, unaff_RDI = param_1, param_1 < uVar1)) {
    unaff_RDI = uVar1;
  }
  uVar2 = FUN_180067110(unaff_RDI + 1);
  *(void* *)(unaff_RBX + 0x10) = unaff_RSI;
  *(ulong long *)(unaff_RBX + 0x18) = unaff_RDI;
                    // WARNING: Subroutine does not return
  memcpy(uVar2);
}




// 函数: void FUN_18006729a(void)
void FUN_18006729a(void)

{
  return;
}




// 函数: void FUN_1800672b0(void)
void FUN_1800672b0(void)

{
                    // WARNING: Subroutine does not return
  _invalid_parameter_noinfo_noreturn();
}




// 函数: void FUN_1800672b7(void)
void FUN_1800672b7(void)

{
  code *pcVar1;
  
  FUN_1800670f0();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800672c0(long long param_1)
void FUN_1800672c0(long long param_1)

{
  long long lVar1;
  long long lVar2;
  int memoryCompareResult;
  void* uVar4;
  void* uVar5;
  long long *plVar6;
  uint auStackX_8 [2];
  long long lStackX_10;
  long long lStackX_18;
  long long *plStackX_20;
  uint32_t uStack_70;
  uint32_t uStack_6c;
  uint32_t uStack_68;
  uint32_t uStack_64;
  uint32_t uStack_60;
  uint32_t uStack_5c;
  uint32_t uStack_58;
  uint32_t uStack_54;
  undefined *puStack_50;
  undefined *puStack_48;
  
  uVar4 = GetCurrentThread();
  SetThreadPriority(uVar4,0);
  auStackX_8[0] = 0;
  lStackX_18 = 0;
  lStackX_10 = 0;
  while( true ) {
    while( true ) {
      iVar3 = GetQueuedCompletionStatus
                        (*(void* *)(param_1 + 0x28),auStackX_8,&lStackX_18,&lStackX_10,
                         0xffffffff);
      lVar2 = lStackX_10;
      if (iVar3 == 0) break;
      if (lStackX_18 == -1) {
        return;
      }
      *(long long *)(lStackX_10 + 0x1c8) =
           *(long long *)(lStackX_10 + 0x1c8) - (ulong long)auStackX_8[0];
      uVar4 = _DAT_180c86940;
      if (*(long long *)(lStackX_10 + 0x1c8) < 1) {
        lVar1 = *(long long *)(param_1 + 0x20);
        uVar5 = FUN_18062b1e0(_DAT_180c8ed18,0x40,8,10);
        plStackX_20 = (long long *)&uStack_60;
        puStack_50 = &UNK_180068e70;
        puStack_48 = &UNK_180068e60;
        uStack_70 = (uint32_t)uVar4;
        uStack_6c = (uint32_t)((ulong long)uVar4 >> 0x20);
        uStack_68 = (uint32_t)lVar2;
        uStack_64 = (uint32_t)((ulong long)lVar2 >> 0x20);
        uStack_60 = uStack_70;
        uStack_5c = uStack_6c;
        uStack_58 = uStack_68;
        uStack_54 = uStack_64;
        plVar6 = (long long *)FUN_180069e10(uVar5,&uStack_60);
        if (plVar6 != (long long *)0x0) {
          (**(code **)(*plVar6 + 0x28))(plVar6);
        }
        uVar4 = _DAT_180c82868;
        plStackX_20 = plVar6;
        if (*(char *)(lVar1 + 0x368) == '\0') {
          plVar6[3] = -4;
          (**(code **)(*plVar6 + 0x28))(plVar6);
          FUN_18005e110(uVar4,&plStackX_20);
        }
        else {
          if (plVar6 != (long long *)0x0) {
            (**(code **)(*plVar6 + 0x28))(plVar6);
          }
          FUN_18005e450(uVar4,&plStackX_20);
        }
        if (plVar6 != (long long *)0x0) {
          (**(code **)(*plVar6 + 0x38))(plVar6);
        }
      }
    }
    iVar3 = GetLastError();
    if (iVar3 == 0x2df) {
      return;
    }
    if (lStackX_10 == 0) break;
    FUN_180067480(*(void* *)(param_1 + 0x20));
  }
                    // WARNING: Subroutine does not return
  FUN_180062300(_DAT_180c86928,&UNK_1809fec50,iVar3);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180067480(void* param_1,long long param_2)
void FUN_180067480(void* param_1,long long param_2)

{
  undefined *puVar1;
  undefined *puVar2;
  
  puVar1 = *(undefined **)(*(long long *)(param_2 + 0x1f8) + 0x10);
  puVar2 = &SystemStringTemplate;
  if (puVar1 != (undefined *)0x0) {
    puVar2 = puVar1;
  }
                    // WARNING: Subroutine does not return
  FUN_180062300(_DAT_180c86928,&UNK_1809fec70,puVar2);
}




// 函数: void FUN_180067810(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_180067810(long long param_1,void* param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0x10) != (code *)0x0) {
    (**(code **)(param_1 + 0x10))(param_1,0,0,param_4,0xfffffffffffffffe);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180067840(long long *param_1)
void FUN_180067840(long long *param_1)

{
  int *piVar1;
  long long *plVar2;
  long long lVar3;
  long long lVar4;
  void* uVar5;
  void* uVar6;
  void** systemCurrentNode;
  long long *plVar8;
  int iVar9;
  long long lStackX_8;
  void** systemPreviousNode;
  long long lStack_c8;
  long long lStack_c0;
  void* uStack_b8;
  undefined2 uStack_b0;
  uint8_t uStack_ae;
  uint8_t stackBuffer [64];
  void* uStack_48;
  void* uStack_40;
  
  uStack_48 = 0xfffffffffffffffe;
  lVar3 = param_1[1];
  iVar9 = *(int *)(lVar3 + 0x138) - *(int *)(lVar3 + 0x1d8);
  lVar4 = *(long long *)(lVar3 + 0x150);
  plVar8 = (long long *)0x0;
  if (lVar4 != 0) {
    uVar5 = *(void* *)(lVar3 + 0x158);
    uVar6 = *(void* *)(lVar3 + 0x1e0);
    lStackX_8 = *(long long *)(lVar3 + 0x140);
    lVar3 = *(long long *)(lVar3 + 0x1f0);
    if (lVar4 - 2U < 2) {
      plVar8 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x10,8,3);
      *plVar8 = (long long)&UNK_1809ff4e0;
      *(bool *)(plVar8 + 1) = lVar4 == 3;
    }
    (**(code **)(*plVar8 + 0x18))(plVar8,stackBuffer,iVar9 + lVar3,lStackX_8,uVar6,uVar5);
                    // WARNING: Subroutine does not return
    FUN_18064e900(plVar8);
  }
  uStack_ae = 3;
  lVar3 = param_1[1];
  uStack_b8 = *(void* *)(lVar3 + 0x140);
  lStack_c8 = (long long)iVar9 + *(long long *)(lVar3 + 0x1f0);
  uStack_b0 = 1;
  lStack_c0 = lStack_c8;
  (**(code **)(lVar3 + 0x180))(&lStack_c8,*(long long *)(lVar3 + 0x1f8) + 8);
  if (((char)uStack_b0 == '\0') && (lStack_c8 != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  LOCK();
  piVar1 = (int *)(*(long long *)(param_1[1] + 0x1f8) + 0x120);
  *piVar1 = *piVar1 + -1;
  UNLOCK();
  lStackX_8 = *(long long *)(param_1[1] + 0x1a8);
  lVar3 = *param_1;
  FUN_180069cc0(lVar3 + 0x10,&lStackX_8);
  iVar9 = _Cnd_signal(lVar3 + 0x278);
  if (iVar9 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar9);
  }
  puStackX_10 = *(void* **)(param_1[1] + 0x1b0);
  lVar3 = *param_1;
  FUN_180069cc0(lVar3 + 0x10,&puStackX_10);
  iVar9 = _Cnd_signal(lVar3 + 0x278);
  if (iVar9 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar9);
  }
  lVar3 = *(long long *)(param_1[1] + 0x1c0);
  if (*(long long *)(param_1[1] + 0x1b8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar3);
  }
  lVar3 = param_1[1];
  if (*(long long *)(lVar3 + 0x150) == 0) {
    if (*(long long *)(lVar3 + 0x148) == 0) {
      plVar8 = *(long long **)(lVar3 + 0x140);
    }
  }
  else {
    plVar8 = *(long long **)(lVar3 + 0x140);
    if (*(long long *)(lVar3 + 0x148) == 0) {
      plVar8 = (long long *)((long long)plVar8 + *(long long *)(lVar3 + 0x158));
    }
  }
  LOCK();
  plVar2 = (long long *)(*(long long *)(*param_1 + 8) + 0x3f0);
  *plVar2 = *plVar2 - (long long)plVar8;
  UNLOCK();
  LOCK();
  piVar1 = (int *)(*(long long *)(*param_1 + 8) + 0x3f8);
  *piVar1 = *piVar1 + -1;
  UNLOCK();
  lVar4 = *param_1;
  systemPreviousNode = (void* *)param_1[1];
  lVar3 = lVar4 + 0x200380;
  uStack_40 = 0x180068808;
  lStackX_8 = lVar3;
  puStackX_10 = systemPreviousNode;
  iVar9 = _Mtx_lock(lVar3);
  if (iVar9 != 0) {
    uStack_40 = 0x180068815;
    __Throw_C_error_std__YAXH_Z(iVar9);
  }
  uStack_40 = 0x18006881f;
  FUN_180069530(systemPreviousNode + 4);
  *systemPreviousNode = *(void* *)(lVar4 + 0x200378);
  *(void* **)(lVar4 + 0x200378) = systemPreviousNode;
  uStack_40 = 0x18006883a;
  iVar9 = _Mtx_unlock(lVar3);
  if (iVar9 != 0) {
    uStack_40 = 0x180068847;
    __Throw_C_error_std__YAXH_Z(iVar9);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180067bc0(void* *param_1)
void FUN_180067bc0(void* *param_1)

{
  uint8_t auStack_b8 [48];
  void* *puStack_88;
  void* uStack_70;
  void* *puStack_68;
  ulong long uStack_30;
  
  uStack_70 = 0xfffffffffffffffe;
  uStack_30 = _DAT_180bf00a8 ^ (ulong long)auStack_b8;
  puStack_68 = param_1;
  FUN_18006b940();
  *param_1 = &UNK_1809fee70;
  puStack_88 = param_1 + 0x6e;
                    // WARNING: Subroutine does not return
  memset(puStack_88,0,0x200000);
}




// 函数: void FUN_180067f00(void)
void FUN_180067f00(void)

{
  _Mtx_destroy_in_situ();
  return;
}




// 函数: void FUN_180067f30(void)
void FUN_180067f30(void)

{
  _Mtx_destroy_in_situ();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180067f60(long long param_1,long long param_2)
void FUN_180067f60(long long param_1,long long param_2)

{
  int iVar1;
  long long lVar2;
  long long lVar3;
  undefined *puVar4;
  void* *puVar5;
  ulong long uVar6;
  uint uVar7;
  uint8_t auStack_2e8 [32];
  ulong long uStack_2c8;
  uint32_t uStack_2c0;
  void* uStack_2b8;
  long long lStack_2a8;
  void* uStack_2a0;
  long long alStack_288 [4];
  undefined *puStack_268;
  undefined *puStack_260;
  ulong long uStack_48;
  ulong long uVar8;
  
  uStack_2a0 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_2e8;
  FUN_180624440(&puStack_268);
  puVar4 = &SystemStringTemplate;
  if (puStack_260 != (undefined *)0x0) {
    puVar4 = puStack_260;
  }
  uVar6 = 0;
  uStack_2b8 = 0;
  uStack_2c0 = 0x60000001;
  uStack_2c8 = CONCAT44(uStack_2c8._4_4_,3);
  lVar2 = CreateFileA(puVar4,0x80000000,1,0);
  if (lVar2 == -1) {
    puVar4 = &SystemStringTemplate;
    if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
      puVar4 = *(undefined **)(param_2 + 8);
    }
                    // WARNING: Subroutine does not return
    FUN_180062300(_DAT_180c86928,&UNK_1809fecd8,puVar4);
  }
  lVar3 = CreateIoCompletionPort(lVar2,*(void* *)(param_1 + 0x213430),0,0);
  if (lVar3 != *(long long *)(param_1 + 0x213430)) {
    puVar4 = &SystemStringTemplate;
    if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
      puVar4 = *(undefined **)(param_2 + 8);
    }
                    // WARNING: Subroutine does not return
    FUN_180062300(_DAT_180c86928,&UNK_1809fed10,puVar4);
  }
  lVar3 = param_1 + 0x2133e0;
  lStack_2a8 = lVar3;
  iVar1 = _Mtx_lock(lVar3);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  puVar5 = *(void* **)(param_1 + 0x2133d8);
  if (puVar5 == (void* *)0x0) {
    uVar8 = *(ulong long *)(param_1 + 0x2133d0);
    if (0xff < uVar8) {
      iVar1 = _Mtx_unlock(lVar3);
      if (iVar1 != 0) {
        __Throw_C_error_std__YAXH_Z(iVar1);
      }
      _DAT_00000018 = *(uint32_t *)(param_2 + 0x10);
      puVar4 = &SystemStringTemplate;
      if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
        puVar4 = *(undefined **)(param_2 + 8);
      }
      strcpy_s(_DAT_00000010,0x100,puVar4);
      uVar8 = uVar6;
      if (0 < *(int *)(param_2 + 0x10)) {
        do {
          uVar6 = uVar6 * 0x1f + (long long)*(char *)(uVar8 + *(long long *)(param_2 + 8));
          uVar7 = (int)uVar8 + 1;
          uVar8 = (ulong long)uVar7;
        } while ((int)uVar7 < *(int *)(param_2 + 0x10));
      }
      lRam0000000000000128 = lVar2;
      uStack_2c8 = uVar6;
      FUN_180068860(param_1 + 0x330,alStack_288,uVar8,param_2);
      *(void* *)(alStack_288[0] + 0x118) = 0;
      puStack_268 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
      FUN_1808fc050(uStack_48 ^ (ulong long)auStack_2e8);
    }
    puVar5 = (void* *)(uVar8 * 0x130 + param_1 + 0x2003d0);
    *(ulong long *)(param_1 + 0x2133d0) = uVar8 + 1;
  }
  else {
    *(void* *)(param_1 + 0x2133d8) = *puVar5;
  }
                    // WARNING: Subroutine does not return
  memset(puVar5 + 1,0,0x128);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_180068250(long long param_1,long long param_2,long long param_3)

{
  ulong long uVar1;
  char cVar2;
  int memoryCompareResult;
  void* uVar4;
  ulong long uVar5;
  void** systemRootNode;
  ulong long uVar7;
  ulong long uVar8;
  
  uVar8 = *(ulong long *)(param_3 + 0x118) & 0xfffffffffffff000;
  uVar5 = (*(long long *)(param_3 + 0x120) - uVar8) + *(ulong long *)(param_3 + 0x118);
  uVar7 = (ulong long)(-(uint)((uVar5 & 0xfff) != 0) & 0x1000) + (uVar5 & 0xfffffffffffff000);
  iVar3 = _Mtx_lock(param_1 + 0x200380);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  puVar6 = *(void* **)(param_1 + 0x200378);
  if (puVar6 == (void* *)0x0) {
    uVar1 = *(ulong long *)(param_1 + 0x200370);
    if (0xfff < uVar1) {
      iVar3 = _Mtx_unlock(param_1 + 0x200380);
      if (iVar3 != 0) {
        __Throw_C_error_std__YAXH_Z(iVar3);
      }
      FUN_180068490(0x20,param_3);
      uRam00000000000001f0 = 0;
      uRam00000000000001e8 = 0;
      uRam00000000000001e0 = 0;
      cVar2 = FUN_18006bda0(param_1,0x20,0x1e0,0x1e8,0x1f0);
      if (cVar2 == '\0') {
        FUN_1800687d0(param_1 + 0x370,0);
        uVar4 = 0;
      }
      else {
        _DAT_00000000 = 0;
        _DAT_00000008 = 0;
        _DAT_00000018 = 0;
        LOCK();
        _DAT_00000010 = uVar8;
        uRam00000000000001c8 = uVar5;
        uRam00000000000001d0 = uVar7;
        uRam00000000000001d8 = uVar8;
        lRam00000000000001f8 = param_2;
        *(int *)(param_2 + 0x120) = *(int *)(param_2 + 0x120) + 1;
        UNLOCK();
        iVar3 = ReadFile(*(void* *)(param_2 + 0x128),uRam00000000000001f0,uVar7 & 0xffffffff,0,
                         0);
        if (iVar3 != 0) {
                    // WARNING: Subroutine does not return
          FUN_180062300(_DAT_180c86928,&UNK_1809fed78);
        }
        iVar3 = GetLastError();
        if (iVar3 != 0x3e5) {
                    // WARNING: Subroutine does not return
          FUN_180062300(_DAT_180c86928,&UNK_1809fed40,iVar3);
        }
        uVar4 = 1;
      }
      return uVar4;
    }
    puVar6 = (void* *)(uVar1 * 0x200 + param_1 + 0x370);
    *(ulong long *)(param_1 + 0x200370) = uVar1 + 1;
  }
  else {
    *(void* *)(param_1 + 0x200378) = *puVar6;
    *puVar6 = 0;
  }
                    // WARNING: Subroutine does not return
  memset(puVar6,0,0x200);
}



long long FUN_180068490(long long param_1,long long param_2)

{
  long long lVar1;
  code *pcVar2;
  undefined *puVar3;
  
  *(uint32_t *)(param_1 + 0x10) = *(uint32_t *)(param_2 + 0x10);
  puVar3 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar3 = *(undefined **)(param_2 + 8);
  }
  strcpy_s(*(void* *)(param_1 + 8),0x100,puVar3);
  *(void* *)(param_1 + 0x118) = *(void* *)(param_2 + 0x118);
  lVar1 = param_1 + 0x148;
  *(void* *)(param_1 + 0x120) = *(void* *)(param_2 + 0x120);
  *(void* *)(param_1 + 0x128) = *(void* *)(param_2 + 0x128);
  *(void* *)(param_1 + 0x130) = *(void* *)(param_2 + 0x130);
  *(void* *)(param_1 + 0x138) = *(void* *)(param_2 + 0x138);
  *(uint8_t *)(param_1 + 0x140) = *(uint8_t *)(param_2 + 0x140);
  if (lVar1 != param_2 + 0x148) {
    if (*(code **)(param_1 + 0x158) != (code *)0x0) {
      (**(code **)(param_1 + 0x158))(lVar1,0,0);
    }
    pcVar2 = *(code **)(param_2 + 0x158);
    if (pcVar2 != (code *)0x0) {
      (*pcVar2)(lVar1,param_2 + 0x148,1);
      pcVar2 = *(code **)(param_2 + 0x158);
    }
    *(code **)(param_1 + 0x158) = pcVar2;
    *(void* *)(param_1 + 0x160) = *(void* *)(param_2 + 0x160);
  }
  lVar1 = param_1 + 0x168;
  if (lVar1 != param_2 + 0x168) {
    if (*(code **)(param_1 + 0x178) != (code *)0x0) {
      (**(code **)(param_1 + 0x178))(lVar1,0,0);
    }
    pcVar2 = *(code **)(param_2 + 0x178);
    if (pcVar2 != (code *)0x0) {
      (*pcVar2)(lVar1,param_2 + 0x168,1);
      pcVar2 = *(code **)(param_2 + 0x178);
    }
    *(code **)(param_1 + 0x178) = pcVar2;
    *(void* *)(param_1 + 0x180) = *(void* *)(param_2 + 0x180);
  }
  *(void* *)(param_1 + 0x188) = *(void* *)(param_2 + 0x188);
  *(void* *)(param_1 + 400) = *(void* *)(param_2 + 400);
  *(void* *)(param_1 + 0x198) = *(void* *)(param_2 + 0x198);
  *(void* *)(param_1 + 0x1a0) = *(void* *)(param_2 + 0x1a0);
  return param_1;
}




// 函数: void FUN_180068620(long long param_1,void* *param_2,void* param_3,void* param_4)
void FUN_180068620(long long param_1,void* *param_2,void* param_3,void* param_4)

{
  int iVar1;
  void* uVar2;
  
  uVar2 = 0xfffffffffffffffe;
  CloseHandle(param_2[0x25]);
  iVar1 = _Mtx_lock(param_1 + 0x2133e0);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  (**(code **)*param_2)(param_2,0,param_3,param_4,uVar2);
  *param_2 = *(void* *)(param_1 + 0x2133d8);
  *(void* **)(param_1 + 0x2133d8) = param_2;
  iVar1 = _Mtx_unlock(param_1 + 0x2133e0);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}




// 函数: void FUN_1800686b0(long long param_1)
void FUN_1800686b0(long long param_1)

{
  long long *plVar1;
  long long *plVar2;
  long long lVar3;
  char cVar4;
  long long *plVar5;
  long long *plVar6;
  long long *plVar7;
  long long *plStackX_8;
  
  cVar4 = FUN_180068a90(param_1 + 0x10,&plStackX_8);
  do {
    if (cVar4 == '\0') {
      return;
    }
    plVar2 = *(long long **)(param_1 + 0x318);
    if (plStackX_8 != (long long *)0x0) {
      *(uint8_t *)(plStackX_8 + 4) = 0;
      *plVar2 = *plVar2 - plStackX_8[1];
      plVar2[2] = plVar2[2] + plStackX_8[1];
      plVar7 = (long long *)plStackX_8[3];
      plVar6 = (long long *)plVar2[3];
      plVar5 = plStackX_8;
      if (plVar7 != plVar6) {
        do {
          if ((plVar7 == (long long *)0x0) || ((char)plVar7[4] != '\0')) break;
          lVar3 = plVar5[2];
          plVar7[2] = lVar3;
          if (lVar3 != 0) {
            *(long long **)(lVar3 + 0x18) = plVar7;
          }
          plVar7[1] = plVar7[1] + plVar5[1];
          *plVar5 = plVar2[0x28005];
          plVar2[0x28005] = (long long)plVar5;
          plVar6 = (long long *)plVar2[3];
          plVar1 = plVar7 + 3;
          plVar5 = plVar7;
          plVar7 = (long long *)*plVar1;
        } while ((long long *)*plVar1 != plVar6);
      }
      plVar7 = (long long *)plVar5[2];
      while (((plVar5 != plVar6 && (plVar7 != (long long *)0x0)) && ((char)plVar7[4] == '\0'))) {
        lVar3 = plVar7[2];
        plVar5[2] = lVar3;
        if (lVar3 != 0) {
          *(long long **)(lVar3 + 0x18) = plVar5;
        }
        plVar5[1] = plVar5[1] + plVar7[1];
        *plVar7 = plVar2[0x28005];
        plVar2[0x28005] = (long long)plVar7;
        plVar6 = (long long *)plVar2[3];
        plVar7 = (long long *)plVar5[2];
      }
    }
    cVar4 = FUN_180068a90(param_1 + 0x10,&plStackX_8);
  } while( true );
}




// 函数: void FUN_1800687d0(long long param_1,void* *param_2)
void FUN_1800687d0(long long param_1,void* *param_2)

{
  int iVar1;
  
  iVar1 = _Mtx_lock(param_1 + 0x200010);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  FUN_180069530(param_2 + 4);
  *param_2 = *(void* *)(param_1 + 0x200008);
  *(void* **)(param_1 + 0x200008) = param_2;
  iVar1 = _Mtx_unlock(param_1 + 0x200010);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long *
FUN_180068860(long long param_1,long long *param_2,void* param_3,void* param_4,
             ulong long param_5)

{
  long long lVar1;
  ulong long uVar2;
  long long lVar3;
  void* uVar4;
  
  uVar2 = param_5 % (ulong long)*(uint *)(param_1 + 0x10);
  lVar3 = func_0x0001800694c0(param_1,*(void* *)(*(long long *)(param_1 + 8) + uVar2 * 8),
                              param_4);
  if (lVar3 == 0) {
    FUN_18066c220(param_1 + 0x20,&param_5,*(uint32_t *)(param_1 + 0x10),
                  *(uint32_t *)(param_1 + 0x18),1);
    lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,0x128,*(uint8_t *)(param_1 + 0x2c));
    FUN_180068ff0(lVar3,param_4);
    *(void* *)(lVar3 + 0x118) = 0;
    *(void* *)(lVar3 + 0x120) = 0;
    if ((char)param_5 != '\0') {
      uVar4 = FUN_18062b1e0(_DAT_180c8ed18,(ulong long)param_5._4_4_ * 8 + 8,8,
                            *(uint8_t *)(param_1 + 0x2c));
                    // WARNING: Subroutine does not return
      memset(uVar4,0,(ulong long)param_5._4_4_ * 8);
    }
    *(void* *)(lVar3 + 0x120) = *(void* *)(*(long long *)(param_1 + 8) + uVar2 * 8);
    *(long long *)(*(long long *)(param_1 + 8) + uVar2 * 8) = lVar3;
    *(long long *)(param_1 + 0x18) = *(long long *)(param_1 + 0x18) + 1;
    lVar1 = *(long long *)(param_1 + 8);
    *param_2 = lVar3;
    param_2[1] = lVar1 + uVar2 * 8;
    *(uint8_t *)(param_2 + 2) = 1;
  }
  else {
    lVar1 = *(long long *)(param_1 + 8);
    *param_2 = lVar3;
    param_2[1] = lVar1 + uVar2 * 8;
    *(uint8_t *)(param_2 + 2) = 0;
  }
  return param_2;
}



void* FUN_180068a90(ulong long *param_1,void* *param_2)

{
  long long *plVar1;
  ulong long *puVar2;
  long long lVar3;
  long long lVar4;
  char cVar5;
  bool bVar6;
  ulong long uVar7;
  ulong long uVar8;
  ulong long uVar9;
  ulong long uVar10;
  ulong long uVar11;
  ulong long uVar12;
  ulong long uVar13;
  ulong long uVar14;
  
  uVar11 = *param_1;
  uVar10 = 0;
  uVar8 = uVar10;
  uVar12 = uVar10;
  uVar14 = uVar10;
  do {
    uVar9 = uVar8;
    if (uVar11 == 0) break;
    uVar7 = *(long long *)(uVar11 + 0x20) - *(long long *)(uVar11 + 0x28);
    if ((ulong long)(*(long long *)(uVar11 + 0x28) - *(long long *)(uVar11 + 0x20)) <
        0x8000000000000001) {
      uVar7 = uVar10;
    }
    uVar13 = uVar12;
    if ((uVar7 != 0) && (uVar14 = uVar14 + 1, uVar9 = uVar11, uVar13 = uVar7, uVar7 <= uVar12)) {
      uVar9 = uVar8;
      uVar13 = uVar12;
    }
    plVar1 = (long long *)(uVar11 + 8);
    uVar11 = *plVar1 - 8;
    if (*plVar1 == 0) {
      uVar11 = uVar10;
    }
    uVar8 = uVar9;
    uVar12 = uVar13;
  } while (uVar14 < 3);
  if (uVar14 != 0) {
    cVar5 = FUN_180068ce0(uVar9,param_2);
    if (cVar5 != '\0') {
      return 1;
    }
    uVar11 = *param_1;
    while (uVar11 != 0) {
      if (uVar11 != uVar9) {
        lVar4 = *(long long *)(uVar11 + 0x38);
        if (*(char *)(uVar11 + 0x48) == '\0') {
          if ((ulong long)((*(long long *)(uVar11 + 0x30) - lVar4) - *(long long *)(uVar11 + 0x20)) <
              0x8000000000000001) goto LAB_180068c92;
          LOCK();
          plVar1 = (long long *)(uVar11 + 0x30);
          lVar3 = *plVar1;
          *plVar1 = *plVar1 + 1;
          UNLOCK();
          if ((ulong long)((lVar3 - *(long long *)(uVar11 + 0x20)) - lVar4) < 0x8000000000000001)
          goto LAB_180068c87;
          LOCK();
          puVar2 = (ulong long *)(uVar11 + 0x28);
          uVar8 = *puVar2;
          *puVar2 = *puVar2 + 1;
          UNLOCK();
          plVar1 = *(long long **)(uVar11 + 0x60);
          lVar3 = *(long long *)
                   (plVar1[3] +
                   (((uVar8 & 0xffffffffffffffe0) - **(long long **)(plVar1[3] + plVar1[1] * 8) >> 5)
                    + plVar1[1] & *plVar1 - 1U) * 8);
          lVar4 = *(long long *)(lVar3 + 8);
          *param_2 = *(void* *)(lVar4 + (ulong long)((uint)uVar8 & 0x1f) * 8);
          LOCK();
          plVar1 = (long long *)(lVar4 + 0x108);
          lVar4 = *plVar1;
          *plVar1 = *plVar1 + 1;
          UNLOCK();
          if (lVar4 == 0x1f) {
            *(void* *)(lVar3 + 8) = 0;
            func_0x000180060c10(*(void* *)(uVar11 + 0x50));
          }
          bVar6 = true;
        }
        else {
          if (0x8000000000000000 <
              (ulong long)((*(long long *)(uVar11 + 0x30) - lVar4) - *(long long *)(uVar11 + 0x20))) {
            LOCK();
            plVar1 = (long long *)(uVar11 + 0x30);
            lVar3 = *plVar1;
            *plVar1 = *plVar1 + 1;
            UNLOCK();
            if (0x8000000000000000 < (ulong long)((lVar3 - *(long long *)(uVar11 + 0x20)) - lVar4)) {
              LOCK();
              puVar2 = (ulong long *)(uVar11 + 0x28);
              uVar8 = *puVar2;
              *puVar2 = *puVar2 + 1;
              UNLOCK();
              plVar1 = *(long long **)(uVar11 + 0x58);
              uVar12 = (ulong long)((uint)uVar8 & 0x1f);
              lVar4 = *(long long *)
                       (plVar1[2] + 8 +
                       (((uVar8 & 0xffffffffffffffe0) - *(long long *)(plVar1[2] + plVar1[1] * 0x10)
                        >> 5) + plVar1[1] & *plVar1 - 1U) * 0x10);
              *param_2 = *(void* *)(lVar4 + uVar12 * 8);
              *(uint8_t *)((lVar4 - uVar12) + 0x12f) = 1;
              bVar6 = true;
              goto LAB_180068c94;
            }
LAB_180068c87:
            LOCK();
            *(long long *)(uVar11 + 0x38) = *(long long *)(uVar11 + 0x38) + 1;
            UNLOCK();
          }
LAB_180068c92:
          bVar6 = false;
        }
LAB_180068c94:
        if (bVar6) {
          return 1;
        }
      }
      plVar1 = (long long *)(uVar11 + 8);
      uVar11 = *plVar1 - 8;
      if (*plVar1 == 0) {
        uVar11 = uVar10;
      }
    }
  }
  return 0;
}



void* FUN_180068ce0(long long param_1,void* *param_2)

{
  long long *plVar1;
  ulong long *puVar2;
  long long lVar3;
  ulong long uVar4;
  long long systemTimeValue;
  ulong long uVar6;
  
  if (*(char *)(param_1 + 0x48) == '\0') {
    if ((ulong long)
        ((*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x38)) -
        *(long long *)(param_1 + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    plVar1 = (long long *)(param_1 + 0x30);
    lVar3 = *plVar1;
    *plVar1 = *plVar1 + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((lVar3 - *(long long *)(param_1 + 0x20)) - *(long long *)(param_1 + 0x38))) {
      LOCK();
      puVar2 = (ulong long *)(param_1 + 0x28);
      uVar4 = *puVar2;
      *puVar2 = *puVar2 + 1;
      UNLOCK();
      plVar1 = *(long long **)(param_1 + 0x60);
      lVar5 = *(long long *)
               (plVar1[3] +
               (((uVar4 & 0xffffffffffffffe0) - **(long long **)(plVar1[3] + plVar1[1] * 8) >> 5) +
                plVar1[1] & *plVar1 - 1U) * 8);
      lVar3 = *(long long *)(lVar5 + 8);
      *param_2 = *(void* *)(lVar3 + (ulong long)((uint)uVar4 & 0x1f) * 8);
      LOCK();
      plVar1 = (long long *)(lVar3 + 0x108);
      lVar3 = *plVar1;
      *plVar1 = *plVar1 + 1;
      UNLOCK();
      if (lVar3 == 0x1f) {
        *(void* *)(lVar5 + 8) = 0;
        func_0x000180060c10(*(void* *)(param_1 + 0x50));
      }
      return 1;
    }
  }
  else {
    if ((ulong long)
        ((*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x38)) -
        *(long long *)(param_1 + 0x20)) < 0x8000000000000001) {
      return 0;
    }
    LOCK();
    plVar1 = (long long *)(param_1 + 0x30);
    lVar3 = *plVar1;
    *plVar1 = *plVar1 + 1;
    UNLOCK();
    if (0x8000000000000000 <
        (ulong long)((lVar3 - *(long long *)(param_1 + 0x20)) - *(long long *)(param_1 + 0x38))) {
      LOCK();
      puVar2 = (ulong long *)(param_1 + 0x28);
      uVar4 = *puVar2;
      *puVar2 = *puVar2 + 1;
      UNLOCK();
      plVar1 = *(long long **)(param_1 + 0x58);
      uVar6 = (ulong long)((uint)uVar4 & 0x1f);
      lVar3 = *(long long *)
               (plVar1[2] + 8 +
               (((uVar4 & 0xffffffffffffffe0) - *(long long *)(plVar1[2] + plVar1[1] * 0x10) >> 5) +
                plVar1[1] & *plVar1 - 1U) * 0x10);
      *param_2 = *(void* *)(lVar3 + uVar6 * 8);
      *(uint8_t *)((lVar3 - uVar6) + 0x12f) = 1;
      return 1;
    }
  }
  LOCK();
  *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + 1;
  UNLOCK();
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_180068ec0(long long *param_1,long long *param_2,int param_3,void* param_4)

{
  long long lVar1;
  long long lVar2;
  code *pcVar3;
  
  if (param_3 == 3) {
    lVar2 = 0x180bfd400;
  }
  else if (param_3 == 4) {
    lVar2 = *param_1;
  }
  else {
    if (param_3 == 0) {
      lVar2 = *param_1;
      if (lVar2 != 0) {
        if (*(code **)(lVar2 + 0x10) != (code *)0x0) {
          (**(code **)(lVar2 + 0x10))(lVar2,0,0,param_4,0xfffffffffffffffe);
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900(lVar2);
      }
    }
    else {
      if (param_3 == 1) {
        lVar1 = FUN_18062b1e0(_DAT_180c8ed18,0x20,8,DAT_180bf65bc);
        lVar2 = *param_2;
        *(void* *)(lVar1 + 0x10) = 0;
        *(code **)(lVar1 + 0x18) = _guard_check_icall;
        if (lVar1 != lVar2) {
          pcVar3 = *(code **)(lVar2 + 0x10);
          if (pcVar3 != (code *)0x0) {
            (*pcVar3)(lVar1,lVar2,1);
            pcVar3 = *(code **)(lVar2 + 0x10);
          }
          *(code **)(lVar1 + 0x10) = pcVar3;
          *(void* *)(lVar1 + 0x18) = *(void* *)(lVar2 + 0x18);
        }
        *param_1 = lVar1;
        return 0;
      }
      if (param_3 == 2) {
        *param_1 = *param_2;
        *param_2 = 0;
        return 0;
      }
    }
    lVar2 = 0;
  }
  return lVar2;
}



void* *
FUN_180068ff0(void* *param_1,long long param_2,void* param_3,void* param_4)

{
  undefined *puVar1;
  
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809feda8;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  *(uint32_t *)(param_1 + 2) = *(uint32_t *)(param_2 + 0x10);
  puVar1 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar1 = *(undefined **)(param_2 + 8);
  }
  strcpy_s(param_1[1],0x100,puVar1,param_4,0xfffffffffffffffe);
  return param_1;
}



void* * FUN_180069070(void* *param_1)

{
  *param_1 = &SystemMemoryAllocatorReference;
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 2) = 0;
  *param_1 = &UNK_1809feda8;
  param_1[1] = param_1 + 3;
  *(uint32_t *)(param_1 + 2) = 0;
  *(uint8_t *)(param_1 + 3) = 0;
  param_1[0x2b] = 0;
  param_1[0x2c] = _guard_check_icall;
  param_1[0x2f] = 0;
  param_1[0x30] = _guard_check_icall;
  param_1[0x27] = 0xffffffffffffffff;
  param_1[0x24] = 0xffffffffffffffff;
  param_1[0x23] = 0xffffffffffffffff;
  param_1[0x25] = 0;
  param_1[0x26] = 0;
  *(uint8_t *)(param_1 + 0x28) = 0;
  return param_1;
}




// 函数: void FUN_180069130(long long param_1,long long param_2)
void FUN_180069130(long long param_1,long long param_2)

{
  code *pcVar1;
  
  pcVar1 = *(code **)(param_2 + 0x10);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(param_1,param_2,2);
    pcVar1 = *(code **)(param_2 + 0x10);
  }
  *(code **)(param_1 + 0x10) = pcVar1;
  *(void* *)(param_1 + 0x18) = *(void* *)(param_2 + 0x18);
  *(code **)(param_2 + 0x18) = _guard_check_icall;
  *(void* *)(param_2 + 0x10) = 0;
  return;
}



long long FUN_180069190(long long param_1,ulong long param_2,void* param_3,void* param_4)

{
  *(undefined **)(param_1 + 8) = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x128,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}



void* *
FUN_1800691e0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x118,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180069220(long long param_1,void* param_2,int param_3)
void FUN_180069220(long long param_1,void* param_2,int param_3)

{
  if (param_3 + 1 < 0x100) {
                    // WARNING: Subroutine does not return
    memcpy(*(uint8_t **)(param_1 + 8),param_2,(long long)param_3);
  }
  **(uint8_t **)(param_1 + 8) = 0;
  *(uint32_t *)(param_1 + 0x10) = 0;
  return;
}




// 函数: void FUN_180069241(void)
void FUN_180069241(void)

{
                    // WARNING: Subroutine does not return
  memcpy();
}




// 函数: void FUN_180069266(uint8_t *param_1)
void FUN_180069266(uint8_t *param_1)

{
  long long unaff_RDI;
  
  *param_1 = 0;
  *(uint32_t *)(unaff_RDI + 0x10) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180069280(long long param_1,long long param_2,long long param_3)
void FUN_180069280(long long param_1,long long param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  long long lVar3;
  uint8_t auStack_198 [32];
  void* uStack_178;
  undefined *puStack_168;
  uint8_t *puStack_160;
  uint32_t uStack_158;
  uint8_t auStack_150 [264];
  ulong long uStack_48;
  
  uStack_178 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_198;
  puStack_168 = &UNK_1809feda8;
  puStack_160 = auStack_150;
  uStack_158 = 0;
  auStack_150[0] = 0;
  lVar1 = strstr(*(void* *)(param_1 + 8));
  if (lVar1 != 0) {
    lVar2 = -1;
    lVar3 = -1;
    do {
      lVar3 = lVar3 + 1;
    } while (*(char *)(param_2 + lVar3) != '\0');
    do {
      lVar2 = lVar2 + 1;
    } while (*(char *)(lVar2 + param_3) != '\0');
                    // WARNING: Subroutine does not return
    memcpy(puStack_160,*(long long *)(param_1 + 8),lVar1 - *(long long *)(param_1 + 8));
  }
  puStack_168 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_48 ^ (ulong long)auStack_198);
}




// 函数: void FUN_1800693f0(long long param_1,long long param_2)
void FUN_1800693f0(long long param_1,long long param_2)

{
  long long lVar1;
  
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x10) = 0;
    **(uint8_t **)(param_1 + 8) = 0;
    return;
  }
  lVar1 = -1;
  do {
    lVar1 = lVar1 + 1;
  } while (*(char *)(param_2 + lVar1) != '\0');
  if ((int)lVar1 < 0x100) {
    *(int *)(param_1 + 0x10) = (int)lVar1;
                    // WARNING: Could not recover jumptable at 0x000180069429. Too many branches
                    // WARNING: Treating indirect jump as call
    strcpy_s(*(void* *)(param_1 + 8),0x100);
    return;
  }
  FUN_180626f80(&UNK_18098bc48,0x100,param_2);
  *(uint32_t *)(param_1 + 0x10) = 0;
  **(uint8_t **)(param_1 + 8) = 0;
  return;
}



long long FUN_180069470(long long param_1,ulong long param_2,void* param_3,void* param_4)

{
  *(undefined **)(param_1 + 8) = &SystemMemoryAllocatorReference;
  if ((param_2 & 1) != 0) {
    free(param_1,0x130,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}




// 函数: void FUN_180069530(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180069530(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  if ((code *)param_1[0x2f] != (code *)0x0) {
    (*(code *)param_1[0x2f])(param_1 + 0x2d,0,0,param_4,0xfffffffffffffffe);
  }
  if ((code *)param_1[0x2b] != (code *)0x0) {
    (*(code *)param_1[0x2b])(param_1 + 0x29,0,0);
  }
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_1800695a0(long long param_1)
void FUN_1800695a0(long long param_1)

{
  *(undefined **)(param_1 + 8) = &SystemMemoryAllocatorReference;
  return;
}



void* *
FUN_1800696d0(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_18098bdc8;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0x30,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}



void* * FUN_180069720(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809feeb8;
  if ((param_2 & 1) != 0) {
    free(param_1,0x58);
  }
  return param_1;
}



void* FUN_180069760(void* param_1,ulong long param_2)

{
  FUN_1800697a0();
  if ((param_2 & 1) != 0) {
    free(param_1,0x68);
  }
  return param_1;
}




// 函数: void FUN_1800697a0(void* *param_1)
void FUN_1800697a0(void* *param_1)

{
  int *piVar1;
  int iVar2;
  ulong long uVar3;
  ulong long uVar4;
  long long *plVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  long long lVar9;
  ulong long uVar10;
  bool bVar11;
  
  *param_1 = &UNK_1809feec8;
  uVar3 = param_1[4];
  lVar9 = 0;
  uVar4 = param_1[5];
  for (uVar10 = uVar4; uVar10 != uVar3; uVar10 = uVar10 + 1) {
    if ((uVar10 & 0x1f) == 0) {
      if (lVar9 != 0) {
        lVar6 = param_1[10];
        LOCK();
        piVar1 = (int *)(lVar9 + 0x130);
        iVar2 = *piVar1;
        *piVar1 = *piVar1 + -0x80000000;
        UNLOCK();
        if (iVar2 == 0) {
          lVar8 = *(long long *)(lVar6 + 0x28);
          do {
            *(long long *)(lVar9 + 0x138) = lVar8;
            *(uint32_t *)(lVar9 + 0x130) = 1;
            plVar5 = (long long *)(lVar6 + 0x28);
            LOCK();
            lVar7 = *plVar5;
            bVar11 = lVar8 == lVar7;
            if (bVar11) {
              *plVar5 = lVar9;
              lVar7 = lVar8;
            }
            UNLOCK();
            if (bVar11) break;
            LOCK();
            piVar1 = (int *)(lVar9 + 0x130);
            iVar2 = *piVar1;
            *piVar1 = *piVar1 + 0x7fffffff;
            UNLOCK();
            lVar8 = lVar7;
          } while (iVar2 == 1);
        }
      }
LAB_180069842:
      plVar5 = (long long *)param_1[0xc];
      lVar9 = *(long long *)
               (*(long long *)
                 (plVar5[3] +
                 (plVar5[1] +
                  ((uVar10 & 0xffffffffffffffe0) - **(long long **)(plVar5[3] + plVar5[1] * 8) >> 5)
                 & *plVar5 - 1U) * 8) + 8);
    }
    else if (lVar9 == 0) goto LAB_180069842;
  }
  lVar9 = param_1[8];
  if ((lVar9 != 0) && ((uVar4 != uVar3 || ((uVar3 & 0x1f) != 0)))) {
    lVar6 = param_1[10];
    LOCK();
    piVar1 = (int *)(lVar9 + 0x130);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -0x80000000;
    UNLOCK();
    if (iVar2 == 0) {
      lVar8 = *(long long *)(lVar6 + 0x28);
      do {
        *(long long *)(lVar9 + 0x138) = lVar8;
        *(uint32_t *)(lVar9 + 0x130) = 1;
        plVar5 = (long long *)(lVar6 + 0x28);
        LOCK();
        lVar7 = *plVar5;
        bVar11 = lVar8 == lVar7;
        if (bVar11) {
          *plVar5 = lVar9;
          lVar7 = lVar8;
        }
        UNLOCK();
        if (bVar11) break;
        LOCK();
        piVar1 = (int *)(lVar9 + 0x130);
        iVar2 = *piVar1;
        *piVar1 = *piVar1 + 0x7fffffff;
        UNLOCK();
        lVar8 = lVar7;
      } while (iVar2 == 1);
    }
  }
  if (param_1[0xc] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_1809feeb8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_180069920(long long *param_1)

{
  long long *plVar1;
  uint *puVar2;
  ulong long *puVar3;
  ulong long uVar4;
  uint uVar5;
  ulong long uVar6;
  ulong long *systemPreviousNode;
  void** systemNextNode;
  long long lVar9;
  long long lVar10;
  void* *puVar11;
  ulong long uVar12;
  ulong long uVar13;
  uint uVar14;
  void* *puVar15;
  bool bVar16;
  bool bVar17;
  
  uVar5 = GetCurrentThreadId();
  uVar14 = (uVar5 >> 0x10 ^ uVar5) * -0x7a143595;
  uVar14 = (uVar14 >> 0xd ^ uVar14) * -0x3d4d51cb;
  uVar13 = (ulong long)(uVar14 >> 0x10 ^ uVar14);
  systemPreviousNode = (ulong long *)param_1[6];
  for (puVar3 = systemPreviousNode; uVar6 = uVar13, puVar3 != (ulong long *)0x0; puVar3 = (ulong long *)puVar3[2])
  {
    while( true ) {
      uVar6 = uVar6 & *puVar3 - 1;
      uVar14 = *(uint *)(uVar6 * 0x10 + puVar3[1]);
      if (uVar14 == uVar5) {
        puVar15 = *(void* **)(puVar3[1] + 8 + uVar6 * 0x10);
        if (puVar3 == systemPreviousNode) {
          return puVar15;
        }
        do {
          uVar13 = uVar13 & *systemPreviousNode - 1;
          if (*(int *)(systemPreviousNode[1] + uVar13 * 0x10) == 0) {
            puVar2 = (uint *)(systemPreviousNode[1] + uVar13 * 0x10);
            LOCK();
            bVar17 = *puVar2 == 0;
            if (bVar17) {
              *puVar2 = uVar5;
            }
            UNLOCK();
            if (bVar17) {
              *(void* **)(systemPreviousNode[1] + 8 + uVar13 * 0x10) = puVar15;
              return puVar15;
            }
          }
          uVar13 = uVar13 + 1;
        } while( true );
      }
      if (uVar14 == 0) break;
      uVar6 = uVar6 + 1;
    }
  }
  LOCK();
  plVar1 = param_1 + 7;
  lVar9 = *plVar1;
  *plVar1 = *plVar1 + 1;
  UNLOCK();
  uVar6 = lVar9 + 1;
  puVar15 = (void* *)0x0;
  while( true ) {
    if (*systemPreviousNode >> 1 <= uVar6) {
      LOCK();
      puVar2 = (uint *)(param_1 + 0x4b);
      uVar14 = *puVar2;
      *puVar2 = *puVar2 | 1;
      UNLOCK();
      if ((uVar14 & 1) == 0) {
        puVar3 = (ulong long *)param_1[6];
        systemPreviousNode = puVar3;
        uVar12 = *puVar3;
        if (*puVar3 >> 1 <= uVar6) {
          do {
            uVar4 = uVar12;
            uVar12 = uVar4 * 2;
          } while ((uVar4 & 0x7fffffffffffffff) <= uVar6);
          systemPreviousNode = (ulong long *)CreateSystemThreadObject(_DAT_180c8ed18,uVar4 * 0x20 + 0x1f,10);
          if (systemPreviousNode == (ulong long *)0x0) {
            LOCK();
            param_1[7] = param_1[7] + -1;
            UNLOCK();
            *(uint32_t *)(param_1 + 0x4b) = 0;
            return (void* *)0x0;
          }
          *systemPreviousNode = uVar12;
          systemPreviousNode[1] = (ulong long)(-(int)(systemPreviousNode + 3) & 7) + (long long)(systemPreviousNode + 3);
          puVar11 = puVar15;
          for (; uVar12 != 0; uVar12 = uVar12 - 1) {
            *(void* *)((long long)puVar11 + systemPreviousNode[1] + 8) = 0;
            *(uint32_t *)((long long)puVar11 + systemPreviousNode[1]) = 0;
            puVar11 = puVar11 + 2;
          }
          systemPreviousNode[2] = (ulong long)puVar3;
          param_1[6] = (long long)systemPreviousNode;
        }
        *(uint32_t *)(param_1 + 0x4b) = 0;
      }
    }
    if (uVar6 < (*systemPreviousNode >> 2) + (*systemPreviousNode >> 1)) break;
    systemPreviousNode = (ulong long *)param_1[6];
  }
  puVar11 = (void* *)*param_1;
  while (puVar11 != (void* *)0x0) {
    if ((*(char *)(puVar11 + 2) != '\0') && (*(char *)(puVar11 + 9) == '\0')) {
      bVar17 = true;
      LOCK();
      bVar16 = *(char *)(puVar11 + 2) == '\x01';
      if (bVar16) {
        *(char *)(puVar11 + 2) = '\0';
      }
      UNLOCK();
      if (bVar16) goto LAB_180069c2b;
    }
    plVar1 = puVar11 + 1;
    puVar11 = (void* *)(*plVar1 + -8);
    if (*plVar1 == 0) {
      puVar11 = puVar15;
    }
  }
  bVar17 = false;
  puVar8 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x68,10);
  puVar11 = puVar15;
  if (puVar8 != (void* *)0x0) {
    puVar8[1] = 0;
    *(uint8_t *)(puVar8 + 2) = 0;
    puVar8[3] = 0;
    *puVar8 = &UNK_1809feeb8;
    puVar8[4] = 0;
    puVar8[5] = 0;
    puVar8[6] = 0;
    puVar8[7] = 0;
    puVar8[8] = 0;
    *(uint8_t *)(puVar8 + 9) = 0;
    puVar8[10] = param_1;
    *puVar8 = &UNK_1809feec8;
    puVar8[0xb] = 0x20;
    puVar8[0xc] = 0;
    FUN_18005f430(puVar8);
    LOCK();
    *(int *)(param_1 + 1) = (int)param_1[1] + 1;
    UNLOCK();
    lVar9 = *param_1;
    do {
      puVar11 = (void* *)(lVar9 + 8);
      if (lVar9 == 0) {
        puVar11 = puVar15;
      }
      puVar8[1] = puVar11;
      LOCK();
      lVar10 = *param_1;
      bVar16 = lVar9 == lVar10;
      if (bVar16) {
        *param_1 = (long long)puVar8;
        lVar10 = lVar9;
      }
      UNLOCK();
      lVar9 = lVar10;
      puVar11 = puVar8;
    } while (!bVar16);
  }
LAB_180069c2b:
  if (puVar11 == (void* *)0x0) {
    LOCK();
    param_1[7] = param_1[7] + -1;
    UNLOCK();
    return (void* *)0x0;
  }
  if (bVar17) {
    LOCK();
    param_1[7] = param_1[7] + -1;
    UNLOCK();
  }
  do {
    uVar13 = uVar13 & *systemPreviousNode - 1;
    if (*(int *)(systemPreviousNode[1] + uVar13 * 0x10) == 0) {
      puVar2 = (uint *)(systemPreviousNode[1] + uVar13 * 0x10);
      LOCK();
      bVar17 = *puVar2 == 0;
      if (bVar17) {
        *puVar2 = uVar5;
      }
      UNLOCK();
      if (bVar17) {
        *(void* **)(systemPreviousNode[1] + 8 + uVar13 * 0x10) = puVar11;
        return puVar11;
      }
    }
    uVar13 = uVar13 + 1;
  } while( true );
}



ulong long FUN_180069cc0(void* param_1,void* *param_2)

{
  ulong long uVar1;
  long long *plVar2;
  void* uVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long *puVar6;
  
  lVar4 = FUN_180069920();
  if (lVar4 == 0) {
    return 0;
  }
  uVar1 = *(ulong long *)(lVar4 + 0x20);
  if ((uVar1 & 0x1f) == 0) {
    uVar5 = (*(long long *)(lVar4 + 0x28) - uVar1) - 0x20;
    if ((0x8000000000000000 < uVar5) &&
       (plVar2 = *(long long **)(lVar4 + 0x60), plVar2 != (long long *)0x0)) {
      uVar5 = *plVar2 - 1U & plVar2[1] + 1U;
      puVar6 = *(ulong long **)(plVar2[3] + uVar5 * 8);
      if ((*puVar6 == 1) || (puVar6[1] == 0)) {
        *puVar6 = uVar1;
        plVar2[1] = uVar5;
      }
      else {
        uVar5 = FUN_18005f430(lVar4);
        if ((char)uVar5 == '\0') goto LAB_180069dc3;
        plVar2 = *(long long **)(lVar4 + 0x60);
        uVar5 = *plVar2 - 1U & plVar2[1] + 1U;
        puVar6 = *(ulong long **)(plVar2[3] + uVar5 * 8);
        *puVar6 = uVar1;
        plVar2[1] = uVar5;
      }
      uVar5 = FUN_18005ff50(*(void* *)(lVar4 + 0x50));
      if (uVar5 != 0) {
        *(void* *)(uVar5 + 0x108) = 0;
        puVar6[1] = uVar5;
        *(ulong long *)(lVar4 + 0x40) = uVar5;
        goto LAB_180069dda;
      }
      plVar2 = *(long long **)(lVar4 + 0x60);
      uVar5 = plVar2[1] - 1;
      plVar2[1] = *plVar2 - 1U & uVar5;
      puVar6[1] = 0;
    }
LAB_180069dc3:
    uVar5 = uVar5 & 0xffffffffffffff00;
  }
  else {
LAB_180069dda:
    uVar3 = *param_2;
    *(void* *)(*(long long *)(lVar4 + 0x40) + (ulong long)((uint)uVar1 & 0x1f) * 8) = uVar3;
    *(ulong long *)(lVar4 + 0x20) = uVar1 + 1;
    uVar5 = CONCAT71((int7)((ulong long)uVar3 >> 8),1);
  }
  return uVar5;
}



void* *
FUN_180069e10(void* *param_1,void* *param_2,void* param_3,void* param_4)

{
  code *pcVar1;
  
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_18098bdc8;
  LOCK();
  *(uint8_t *)(param_1 + 2) = 0;
  UNLOCK();
  param_1[3] = 0xffffffffffffffff;
  *param_1 = &UNK_1809feed8;
  param_1[6] = 0;
  param_1[7] = _guard_check_icall;
  if (param_1 + 4 != param_2) {
    pcVar1 = (code *)param_2[2];
    if (pcVar1 != (code *)0x0) {
      (*pcVar1)(param_1 + 4,param_2,1,param_4,0xfffffffffffffffe);
      pcVar1 = (code *)param_2[2];
    }
    param_1[6] = pcVar1;
    param_1[7] = param_2[3];
  }
  if ((code *)param_2[2] != (code *)0x0) {
    (*(code *)param_2[2])(param_2,0,0);
  }
  return param_1;
}



void*
FUN_180069f00(void* param_1,void* param_2,void* param_3,void* param_4)

{
  void* uVar1;
  uint32_t uVar2;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  uVar2 = 0;
  uVar1 = FUN_180628ca0();
  FUN_180627ae0(param_2,uVar1,param_3,param_4,uVar2,uVar3);
  return param_2;
}



void* * FUN_180069f60(void* param_1,void* *param_2)

{
  *param_2 = 0;
  param_2[1] = 0;
  param_2[2] = 0;
  *(uint32_t *)(param_2 + 3) = 3;
  return param_2;
}



void* * FUN_180069fb0(void* param_1,void* *param_2)

{
  *param_2 = 0;
  return param_2;
}



void* FUN_180069fe0(void* param_1,ulong long param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  FUN_1801570c0();
  if ((param_2 & 1) != 0) {
    free(param_1,0x260,param_3,param_4,uVar1);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_18006a050(int param_1)

{
  if ((param_1 != -0x3fffff03) && (param_1 != -0x3ffffffb)) {
    return 0;
  }
  (**(code **)(*(long long *)*_DAT_180c8ed08 + 0x68))();
  return 1;
}



void* * FUN_18006a090(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809ff040;
  param_1[0x18] = &SystemGlobalDataReference;
  if (param_1[0x19] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x19] = 0;
  *(uint32_t *)(param_1 + 0x1b) = 0;
  param_1[0x18] = &SystemMemoryAllocatorReference;
  FUN_180049470(param_1);
  if ((param_2 & 1) != 0) {
    free(param_1,0xe8);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006a130(long long param_1)
void FUN_18006a130(long long param_1)

{
  long long *plVar1;
  char cVar2;
  void* uVar3;
  void* *puVar4;
  undefined *puVar5;
  uint8_t auStack_278 [40];
  long long *plStack_250;
  int iStack_248;
  char cStack_1fc;
  void* uStack_98;
  
  uStack_98 = 0xfffffffffffffffe;
  SetErrorMode(1);
  cVar2 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  if (cVar2 == '\0') {
    SetUnhandledExceptionFilter(&UNK_18006a030);
  }
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,0x170,8,3);
  _DAT_180c86948 = FUN_18006e870(uVar3);
  FUN_18004c330(auStack_278);
  uVar3 = FUN_18062b1e0(_DAT_180c8ed18,1000,8,3);
  _DAT_180c86870 = FUN_18004c480(uVar3);
  FUN_180055050();
  FUN_18004d020();
  if ((*(char *)(_DAT_180c8a9a0 + 0x20) == '\0') && (*(char *)(_DAT_180c8a9a0 + 0x21) == '\0')) {
    uVar3 = FUN_1808fc418(0x428);
    plStack_250 = (long long *)FUN_18049d530(uVar3);
  }
  else {
    plStack_250 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x28,8,3);
    *plStack_250 = (long long)&UNK_180a0e170;
    *plStack_250 = (long long)&UNK_180a0e368;
    plStack_250[4] = 0;
    *(uint8_t *)(plStack_250 + 1) = 0;
    plStack_250[2] = 0;
    *(uint8_t *)(plStack_250 + 3) = 0;
    plVar1 = (long long *)plStack_250[4];
    plStack_250[4] = 0;
    if (plVar1 != (long long *)0x0) {
      (**(code **)(*plVar1 + 0x38))();
    }
  }
  puVar5 = &SystemStringTemplate;
  if (*(undefined **)(param_1 + 200) != (undefined *)0x0) {
    puVar5 = *(undefined **)(param_1 + 200);
  }
  (**(code **)(*plStack_250 + 0x50))(plStack_250,puVar5);
  (**(code **)(*plStack_250 + 0x60))(plStack_250,auStack_278);
  if (cStack_1fc == '\0') {
    iStack_248 = 0;
  }
  else if (DAT_180c82841 == '\0') {
    iStack_248 = (DAT_180c82840 != '\0') + 2;
  }
  else {
    iStack_248 = 1;
  }
  _DAT_180c868f8 = FUN_18062b1e0(_DAT_180c8ed18,0x28,8,3);
  *(void* *)(_DAT_180c868f8 + 8) = 0;
  *(void* *)(_DAT_180c868f8 + 0x10) = 0;
  *(void* *)(_DAT_180c868f8 + 0x18) = 0;
  *(uint32_t *)(_DAT_180c868f8 + 0x20) = 3;
  FUN_180162600();
  puVar4 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x478,8,3);
  *puVar4 = 0;
  puVar4[1] = 0;
  puVar4[2] = 0;
  *(uint32_t *)(puVar4 + 3) = 3;
  puVar4[4] = 0;
  puVar4[5] = 0;
  puVar4[6] = 0;
  *(uint32_t *)(puVar4 + 7) = 3;
  puVar4[8] = 0;
  puVar4[9] = 0;
  puVar4[10] = 0;
  *(uint32_t *)(puVar4 + 0xb) = 3;
  *(uint8_t *)(puVar4 + 0xc) = 0;
  *(void* *)((long long)puVar4 + 100) = 0xffffffffffffffff;
  *(uint32_t *)((long long)puVar4 + 0x6c) = 0;
  *(undefined2 *)(puVar4 + 0xe) = 0;
  *(uint8_t *)((long long)puVar4 + 0x72) = 0;
                    // WARNING: Subroutine does not return
  memset((long long)puVar4 + 0x74,0,0x400);
}




// 函数: void FUN_18006b220(long long param_1)
void FUN_18006b220(long long param_1)

{
  *(void* *)(param_1 + 0xa0) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0xa8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0xa8) = 0;
  *(uint32_t *)(param_1 + 0xb8) = 0;
  *(void* *)(param_1 + 0xa0) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x80) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x88) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x88) = 0;
  *(uint32_t *)(param_1 + 0x98) = 0;
  *(void* *)(param_1 + 0x80) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x58) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x60) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x60) = 0;
  *(uint32_t *)(param_1 + 0x70) = 0;
  *(void* *)(param_1 + 0x58) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 0x38) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x40) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x40) = 0;
  *(uint32_t *)(param_1 + 0x50) = 0;
  *(void* *)(param_1 + 0x38) = &SystemMemoryAllocatorReference;
  *(void* *)(param_1 + 8) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x10) = 0;
  *(uint32_t *)(param_1 + 0x20) = 0;
  *(void* *)(param_1 + 8) = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_18006b350(long long *param_1,long long *param_2,int param_3)

{
  void* *puVar1;
  void** systemDataTable;
  
  if (param_3 == 3) {
    return 0x180bfd730;
  }
  if (param_3 == 4) {
    return *param_1;
  }
  if (param_3 == 0) {
    if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  else {
    if (param_3 == 1) {
      puVar2 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x20,8,DAT_180bf65bc,0xfffffffffffffffe);
      puVar1 = (void* *)*param_2;
      *puVar2 = *puVar1;
      *(uint32_t *)(puVar2 + 1) = *(uint32_t *)(puVar1 + 1);
      puVar2[2] = puVar1[2];
      puVar2[3] = puVar1[3];
      *param_1 = (long long)puVar2;
      return 0;
    }
    if (param_3 == 2) {
      *param_1 = *param_2;
      *param_2 = 0;
      return 0;
    }
  }
  return 0;
}




// 函数: void FUN_18006b440(long long param_1,uint32_t param_2)
void FUN_18006b440(long long param_1,uint32_t param_2)

{
  char systemNodeFlag;
  undefined *puVar2;
  uint32_t auStackX_10 [6];
  
  if ((*(long long *)(param_1 + 0x1e20) != 0) &&
     (auStackX_10[0] = param_2, cVar1 = (**(code **)(param_1 + 0x1e28))(auStackX_10),
     param_2 = auStackX_10[0], cVar1 == '\0')) {
    if (DAT_180c82860 == '\0') {
      puVar2 = &SystemStringTemplate;
      if (*(undefined **)(param_1 + 0x1dd0) != (undefined *)0x0) {
        puVar2 = *(undefined **)(param_1 + 0x1dd0);
      }
      FUN_180626f80(&UNK_18098bc00,puVar2);
    }
    *(uint32_t *)(param_1 + 0x1dc0) = *(uint32_t *)(param_1 + 0x1e08);
    return;
  }
  *(uint32_t *)(param_1 + 0x1dc0) = param_2;
  return;
}




// 函数: void FUN_18006b4c0(long long param_1,uint32_t param_2)
void FUN_18006b4c0(long long param_1,uint32_t param_2)

{
  char systemNodeFlag;
  undefined *puVar2;
  uint32_t auStackX_10 [6];
  
  if ((*(long long *)(param_1 + 0x1db0) != 0) &&
     (auStackX_10[0] = param_2, cVar1 = (**(code **)(param_1 + 0x1db8))(auStackX_10),
     param_2 = auStackX_10[0], cVar1 == '\0')) {
    if (DAT_180c82860 == '\0') {
      puVar2 = &SystemStringTemplate;
      if (*(undefined **)(param_1 + 0x1d60) != (undefined *)0x0) {
        puVar2 = *(undefined **)(param_1 + 0x1d60);
      }
      FUN_180626f80(&UNK_18098bc00,puVar2);
    }
    *(uint32_t *)(param_1 + 0x1d50) = *(uint32_t *)(param_1 + 0x1d98);
    return;
  }
  *(uint32_t *)(param_1 + 0x1d50) = param_2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006b540(void* param_1,uint32_t param_2)
void FUN_18006b540(void* param_1,uint32_t param_2)

{
  long long lVar1;
  char cVar2;
  undefined *puVar3;
  uint32_t auStackX_10 [6];
  
  lVar1 = _DAT_180c86920;
  if ((*(long long *)(_DAT_180c86920 + 0x1870) != 0) &&
     (auStackX_10[0] = param_2, cVar2 = (**(code **)(_DAT_180c86920 + 0x1878))(auStackX_10),
     param_2 = auStackX_10[0], cVar2 == '\0')) {
    if (DAT_180c82860 == '\0') {
      puVar3 = &SystemStringTemplate;
      if (*(undefined **)(lVar1 + 0x1820) != (undefined *)0x0) {
        puVar3 = *(undefined **)(lVar1 + 0x1820);
      }
      FUN_180626f80(&UNK_18098bc00,puVar3);
    }
    *(uint32_t *)(lVar1 + 0x1810) = *(uint32_t *)(lVar1 + 0x1858);
    return;
  }
  *(uint32_t *)(lVar1 + 0x1810) = param_2;
  return;
}



long long FUN_18006b5c0(long long param_1,uint param_2,void* param_3,void* param_4)

{
  if (*(code **)(param_1 + 0xd0) != (code *)0x0) {
    (**(code **)(param_1 + 0xd0))(param_1 + 0xc0,0,0,param_4,0xfffffffffffffffe);
  }
  FUN_180049470(param_1);
  if ((param_2 & 1) != 0) {
    free(param_1,0xe0);
  }
  return param_1;
}



void* *
FUN_18006b640(void* *param_1,void* *param_2,void* param_3,void* param_4)

{
  code *pcVar1;
  void* uVar2;
  
  uVar2 = 0xfffffffffffffffe;
  FUN_180049830();
  *param_1 = &UNK_1809fefb0;
  param_1[0x1a] = 0;
  param_1[0x1b] = _guard_check_icall;
  if (param_1 + 0x18 != param_2) {
    pcVar1 = (code *)param_2[2];
    if (pcVar1 != (code *)0x0) {
      (*pcVar1)(param_1 + 0x18,param_2,1,param_4,uVar2);
      pcVar1 = (code *)param_2[2];
    }
    param_1[0x1a] = pcVar1;
    param_1[0x1b] = param_2[3];
  }
  if ((code *)param_2[2] != (code *)0x0) {
    (*(code *)param_2[2])(param_2,0,0);
  }
  return param_1;
}




// 函数: void FUN_18006b6f0(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18006b6f0(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 0x13) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18006b760(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18006b760(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  void* *puVar1;
  void** systemDataTable;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 0x13) {
    (**(code **)*puVar2)(puVar2,0,param_3,param_4,uVar3);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006b780(void)
void FUN_18006b780(void)

{
  long long *plVar1;
  long long lVar2;
  char cVar3;
  
  if (_DAT_180c8f008 != 0) {
    (**(code **)(_DAT_180c8f008 + 0x88))(1);
  }

// 函数: void FUN_18006b8f0(long long param_1)
void FUN_18006b8f0(long long param_1)

{
  *(void* *)(param_1 + 0x20) = &SystemGlobalDataReference;
  if (*(long long *)(param_1 + 0x28) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(param_1 + 0x28) = 0;
  *(uint32_t *)(param_1 + 0x38) = 0;
  *(void* *)(param_1 + 0x20) = &SystemMemoryAllocatorReference;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006b940(void* *param_1)
void FUN_18006b940(void* *param_1)

{
  ulong long uVar1;
  ulong long uVar2;
  ulong long uVar3;
  void* *puVar4;
  void* *puVar5;
  long long lVar6;
  long long lVar7;
  uint8_t auStack_b8 [48];
  void* *puStack_88;
  void* *puStack_80;
  void* uStack_68;
  void* *puStack_60;
  ulong long uStack_30;
  
  uStack_68 = 0xfffffffffffffffe;
  uStack_30 = _DAT_180bf00a8 ^ (ulong long)auStack_b8;
  *param_1 = &UNK_1809ff498;
  uVar2 = 0;
  param_1[1] = 0;
  puStack_80 = param_1 + 2;
  *puStack_80 = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  param_1[4] = 0;
  param_1[7] = 0;
  puVar5 = param_1 + 0xd;
  lVar7 = 0x20;
  lVar6 = 0x20;
  puVar4 = puVar5;
  puStack_60 = param_1;
  do {
    func_0x000180059bb0(puVar4);
    puVar4 = puVar4 + 2;
    lVar6 = lVar6 + -1;
  } while (lVar6 != 0);
  *(void* *)((long long)param_1 + 0x26c) = 0;
  *(uint32_t *)(param_1 + 0x4d) = 0;
  param_1[9] = 0;
  param_1[10] = 0x20;
  param_1[0xb] = puVar5;
  do {
    *(uint32_t *)puVar5 = 0;
    puVar5 = puVar5 + 2;
    lVar7 = lVar7 + -1;
  } while (lVar7 != 0);
  param_1[0xc] = 0;
  param_1[8] = param_1 + 10;
  param_1[6] = 0x15;
  lVar6 = FUN_180059bc0();
  param_1[5] = lVar6;
  if (lVar6 == 0) {
    param_1[6] = 0;
    uVar1 = uVar2;
  }
  else {
    uVar1 = param_1[6];
  }
  uVar3 = uVar2;
  if (uVar1 != 0) {
    do {
      *(uint8_t *)(uVar2 + 0x141 + param_1[5]) = 0;
      uVar3 = uVar3 + 1;
      uVar2 = uVar2 + 0x148;
    } while (uVar3 < (ulong long)param_1[6]);
  }
  puStack_88 = param_1 + 0x4f;
  _Cnd_init_in_situ();
  puStack_88 = param_1 + 0x58;
  _Mtx_init_in_situ(puStack_88,2);
  *(uint32_t *)(param_1 + 0x65) = 0;
  *(uint32_t *)((long long)param_1 + 0x32c) = 0x80;
  puStack_80 = param_1 + 0x66;
  *(uint32_t *)(param_1 + 0x6a) = 0x3f800000;
  *(void* *)((long long)param_1 + 0x354) = 0x40000000;
  *(uint32_t *)((long long)param_1 + 0x35c) = 3;
  param_1[0x68] = 1;
  param_1[0x67] = &DAT_180be0000;
  param_1[0x69] = 0;
  *(uint32_t *)(param_1 + 0x6b) = 0;
  *(uint8_t *)(param_1 + 0x6d) = 1;
  lVar6 = FUN_18062b1e0(_DAT_180c8ed18,0x140038,8,3);
                    // WARNING: Subroutine does not return
  memset(lVar6 + 0x20,0,0x140000);
}



void* FUN_18006bd20(void* param_1,ulong long param_2)

{
  FUN_18006bfe0();
  if ((param_2 & 1) != 0) {
    free(param_1,0x370);
  }
  return param_1;
}




// 函数: void FUN_18006bd60(long long param_1)
void FUN_18006bd60(long long param_1)

{
  long long lVar1;
  void** systemDataTable;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar3 = *(ulong long *)(param_1 + 0x10);
  lVar1 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar3 != 0) {
    do {
      puVar2 = *(void* **)(lVar1 + uVar4 * 8);
      if (puVar2 != (void* *)0x0) {
        *puVar2 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(lVar1 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar3);
    uVar3 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar3) && (*(long long *)(param_1 + 8) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}




// 函数: void FUN_18006bd80(long long param_1)
void FUN_18006bd80(long long param_1)

{
  long long lVar1;
  void** systemDataTable;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar3 = *(ulong long *)(param_1 + 0x10);
  lVar1 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar3 != 0) {
    do {
      puVar2 = *(void* **)(lVar1 + uVar4 * 8);
      if (puVar2 != (void* *)0x0) {
        *puVar2 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(lVar1 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar3);
    uVar3 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar3) && (*(long long *)(param_1 + 8) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void*
FUN_18006bda0(long long param_1,long long param_2,long long *param_3,long long *param_4,
             long long *param_5)

{
  long long lVar1;
  long long *plVar2;
  long long lVar3;
  ulong long uVar4;
  ulong long uVar5;
  ulong long uVar6;
  undefined7 uVar7;
  
  lVar3 = *(long long *)(param_2 + 0x128);
  if (lVar3 != 0) {
    *param_3 = lVar3;
    lVar3 = *(long long *)(param_2 + 0x128);
  }
  lVar1 = *(long long *)(param_2 + 0x130);
  uVar4 = 0;
  if (lVar1 == 0) {
    if (lVar3 == 0) {
      uVar4 = *(ulong long *)(param_2 + 0x120);
    }
  }
  else {
    uVar4 = *(ulong long *)(param_2 + 0x120);
    if (lVar3 == 0) {
      uVar4 = uVar4 + *(long long *)(param_2 + 0x138);
    }
  }
  *(void* *)(param_2 + 0x1a0) = 0;
  *(void* *)(param_2 + 0x198) = 0;
  *(void* *)(param_2 + 400) = 0;
  *(void* *)(param_2 + 0x188) = 0;
  uVar5 = (*(long long *)(param_2 + 0x120) - (*(ulong long *)(param_2 + 0x118) & 0xfffffffffffff000))
          + *(ulong long *)(param_2 + 0x118);
  uVar6 = uVar5 & 0xfffffffffffff000;
  lVar3 = (-(uint)((uVar5 & 0xfff) != 0) & 0x1000) + uVar6;
  if (*(ulong long *)(param_1 + 0x360) < uVar4) {
    uVar7 = (undefined7)(uVar6 >> 8);
    if (lVar1 == 0) {
      if (*param_3 == 0) {
        lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,lVar3,CONCAT71(uVar7,3));
        *param_3 = lVar3;
        *(long long *)(param_2 + 0x198) = lVar3;
        *param_5 = *param_3;
      }
    }
    else {
      lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,lVar3,CONCAT71(uVar7,3));
      *param_4 = lVar3;
      *(long long *)(param_2 + 0x198) = lVar3;
      *param_5 = *param_4;
      if (*param_3 == 0) {
        lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,*(void* *)(param_2 + 0x138),3);
        *param_3 = lVar3;
        *(long long *)(param_2 + 0x1a0) = lVar3;
      }
    }
  }
  else if (lVar1 == 0) {
    if (*param_3 == 0) {
      plVar2 = (long long *)FUN_18006e000(param_1,lVar3);
      *(long long **)(param_2 + 400) = plVar2;
      if (plVar2 == (long long *)0x0) goto LAB_18006bf7f;
      lVar3 = *(long long *)(param_1 + 800) + *plVar2;
      *param_3 = lVar3;
      *param_5 = lVar3;
    }
  }
  else {
    plVar2 = (long long *)FUN_18006e000(param_1,lVar3);
    *(long long **)(param_2 + 0x188) = plVar2;
    if (plVar2 == (long long *)0x0) {
LAB_18006bf7f:
      func_0x0001800695d0(param_1,*(void* *)(param_2 + 0x188));
      func_0x0001800695d0(param_1,*(void* *)(param_2 + 400));
      return 0;
    }
    lVar3 = *plVar2 + *(long long *)(param_1 + 800);
    *param_4 = lVar3;
    *param_5 = lVar3;
    if (*param_3 == 0) {
      plVar2 = (long long *)FUN_18006e000(param_1,*(void* *)(param_2 + 0x138));
      *(long long **)(param_2 + 400) = plVar2;
      if (plVar2 == (long long *)0x0) goto LAB_18006bf7f;
      *param_3 = *plVar2 + *(long long *)(param_1 + 800);
    }
  }
  return 1;
}




// 函数: void FUN_18006bfe0(void* *param_1)
void FUN_18006bfe0(void* *param_1)

{
  *param_1 = &UNK_1809ff498;
  FUN_18006cb90();
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  FUN_180059ee0(param_1 + 2);
  if ((long long *)param_1[1] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[1] + 0x38))();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006c070(long long param_1)
void FUN_18006c070(long long param_1)

{
  long long *plVar1;
  int *piVar2;
  byte *pbVar3;
  void* uVar4;
  void* *puVar5;
  void** systemRootNode;
  bool bVar7;
  long long lVar8;
  char cVar9;
  long long lVar10;
  long long *plVar11;
  byte *pbVar12;
  long long lVar13;
  long long lVar14;
  long long *plVar15;
  uint uVar16;
  int iVar17;
  long long *plVar18;
  void* *puVar20;
  long long lVar21;
  code *pcVar22;
  long long *plVar23;
  undefined *puVar24;
  ulong long uVar25;
  uint8_t auStack_278 [32];
  ulong long uStack_258;
  undefined **ppuStack_248;
  long long *plStack_240;
  long long lStack_238;
  long long lStack_230;
  uint8_t uStack_228;
  void* uStack_218;
  int iStack_210;
  uint32_t uStack_20c;
  void* uStack_208;
  undefined *puStack_1f8;
  byte *pbStack_1f0;
  int iStack_1e8;
  byte abStack_1e0 [256];
  void* uStack_e0;
  ulong long uStack_d8;
  long long lStack_d0;
  long long lStack_c8;
  long long lStack_c0;
  uint8_t uStack_b8;
  uint8_t auStack_b0 [16];
  code *pcStack_a0;
  code *pcStack_98;
  uint8_t astackParameterC [16];
  code *pcStack_80;
  code *pcStack_78;
  void* uStack_70;
  void* uStack_68;
  void* uStack_60;
  void* uStack_58;
  int iStack_48;
  uint32_t uStack_44;
  int iStack_40;
  uint32_t uStack_3c;
  ulong long uStack_38;
  ulong long uVar19;
  
  uStack_208 = 0xfffffffffffffffe;
  uStack_38 = _DAT_180bf00a8 ^ (ulong long)auStack_278;
  cVar9 = *(char *)(*(long long *)(param_1 + 1000) + 0x58);
  do {
    if ((cVar9 == '\0') || (uVar19 = 0, *(char *)(param_1 + 0x400) != '\0')) {
                    // WARNING: Subroutine does not return
      FUN_1808fc050(uStack_38 ^ (ulong long)auStack_278);
    }
    puStack_1f8 = &UNK_1809feda8;
    pbStack_1f0 = abStack_1e0;
    iStack_1e8 = 0;
    abStack_1e0[0] = 0;
    pcStack_a0 = (code *)0x0;
    pcStack_98 = _guard_check_icall;
    ppuStack_248 = (undefined **)astackParameterC;
    pcStack_80 = (code *)0x0;
    pcStack_78 = _guard_check_icall;
    lStack_c0 = -1;
    uStack_d8 = 0xffffffffffffffff;
    uStack_e0 = 0xffffffffffffffff;
    lStack_d0 = 0;
    lStack_c8 = 0;
    uStack_b8 = 0;
    lVar13 = *(long long *)(param_1 + 0x3c8);
    lVar14 = *(long long *)(param_1 + 0x3d0) - lVar13;
    lVar10 = lVar14 >> 0x3f;
    if (lVar14 / 0x1a8 + lVar10 == lVar10) {
      cVar9 = FUN_18006d4e0(param_1 + 200,&puStack_1f8);
      if (cVar9 == '\0') {
        lVar13 = param_1 + 0x378;
        uStack_228 = 0;
        lStack_230 = lVar13;
        iVar17 = _Mtx_lock(lVar13);
        if (iVar17 != 0) {
          __Throw_C_error_std__YAXH_Z(iVar17);
        }
        uStack_228 = 1;
        lVar10 = _Xtime_get_ticks();
        lVar14 = (lVar10 + 50000) * 100;
        lVar10 = lVar14 / 1000000000;
        iStack_48 = (int)lVar10;
        iStack_210 = (int)lVar14 + iStack_48 * -1000000000;
        uStack_218._4_4_ = (uint32_t)((ulong long)lVar10 >> 0x20);
        uStack_44 = uStack_218._4_4_;
        uStack_3c = uStack_20c;
        uStack_218 = lVar10;
        iStack_40 = iStack_210;
        iVar17 = _Mtx_current_owns(lVar13);
        if (iVar17 == 0) {
          __Throw_Cpp_error_std__YAXH_Z(4);
        }
        uVar16 = _Cnd_timedwait(param_1 + 0x330,lVar13,&iStack_48);
        if ((uVar16 & 0xfffffffd) != 0) {
          __Throw_C_error_std__YAXH_Z(uVar16);
        }
        cVar9 = FUN_18006d4e0(param_1 + 200,&puStack_1f8);
        if (cVar9 == '\0') {
          iVar17 = _Mtx_unlock(lVar13);
          if (iVar17 != 0) {
            __Throw_C_error_std__YAXH_Z(iVar17);
          }
          bVar7 = false;
        }
        else {
          iVar17 = _Mtx_unlock();
          if (iVar17 != 0) {
            __Throw_C_error_std__YAXH_Z(iVar17);
          }
          bVar7 = true;
        }
      }
      else {
        bVar7 = true;
      }
    }
    else {
      iStack_1e8 = *(int *)(lVar13 + 0x10);
      puVar24 = &SystemStringTemplate;
      if (*(undefined **)(lVar13 + 8) != (undefined *)0x0) {
        puVar24 = *(undefined **)(lVar13 + 8);
      }
      strcpy_s(pbStack_1f0,0x100,puVar24);
      uStack_e0 = *(void* *)(lVar13 + 0x118);
      uStack_d8 = *(ulong long *)(lVar13 + 0x120);
      lStack_d0 = *(long long *)(lVar13 + 0x128);
      lStack_c8 = *(long long *)(lVar13 + 0x130);
      lStack_c0 = *(long long *)(lVar13 + 0x138);
      uStack_b8 = *(uint8_t *)(lVar13 + 0x140);
      if (auStack_b0 != (uint8_t *)(lVar13 + 0x148)) {
        if (pcStack_a0 != (code *)0x0) {
          (*pcStack_a0)(auStack_b0,0,0);
        }
        pcVar22 = *(code **)(lVar13 + 0x158);
        if (pcVar22 != (code *)0x0) {
          (*pcVar22)(auStack_b0,(uint8_t *)(lVar13 + 0x148),1);
          pcVar22 = *(code **)(lVar13 + 0x158);
        }
        pcStack_98 = *(code **)(lVar13 + 0x160);
        pcStack_a0 = pcVar22;
      }
      if (astackParameterC != (uint8_t *)(lVar13 + 0x168)) {
        if (pcStack_80 != (code *)0x0) {
          (*pcStack_80)(astackParameterC,0,0);
        }
        pcVar22 = *(code **)(lVar13 + 0x178);
        if (pcVar22 != (code *)0x0) {
          (*pcVar22)(astackParameterC,(uint8_t *)(lVar13 + 0x168),1);
          pcVar22 = *(code **)(lVar13 + 0x178);
        }
        pcStack_78 = *(code **)(lVar13 + 0x180);
        pcStack_80 = pcVar22;
      }
      uStack_70 = *(void* *)(lVar13 + 0x188);
      uStack_68 = *(void* *)(lVar13 + 400);
      uStack_60 = *(void* *)(lVar13 + 0x198);
      uStack_58 = *(void* *)(lVar13 + 0x1a0);
      *(long long *)(param_1 + 0x3d0) = *(long long *)(param_1 + 0x3d0) + -0x1a8;
      FUN_180069530();
      bVar7 = true;
    }
    puVar20 = *(void* **)(param_1 + 0xc0);
    if ((undefined *)*puVar20 == &UNK_1809fee70) {
      cVar9 = FUN_180068a90(puVar20 + 2,&plStack_240);
      while (cVar9 != '\0') {
        plVar23 = (long long *)puVar20[99];
        if (plStack_240 != (long long *)0x0) {
          *(uint8_t *)(plStack_240 + 4) = 0;
          *plVar23 = *plVar23 - plStack_240[1];
          plVar23[2] = plVar23[2] + plStack_240[1];
          plVar18 = (long long *)plStack_240[3];
          plVar15 = (long long *)plVar23[3];
          plVar11 = plStack_240;
          if (plVar18 != plVar15) {
            do {
              if ((plVar18 == (long long *)0x0) || ((char)plVar18[4] != '\0')) break;
              lVar13 = plVar11[2];
              plVar18[2] = lVar13;
              if (lVar13 != 0) {
                *(long long **)(lVar13 + 0x18) = plVar18;
              }
              plVar18[1] = plVar18[1] + plVar11[1];
              *plVar11 = plVar23[0x28005];
              plVar23[0x28005] = (long long)plVar11;
              plVar1 = plVar18 + 3;
              plVar15 = (long long *)plVar23[3];
              plVar11 = plVar18;
              plVar18 = (long long *)*plVar1;
            } while ((long long *)*plVar1 != plVar15);
          }
          plVar18 = (long long *)plVar11[2];
          while (((plVar11 != plVar15 && (plVar18 != (long long *)0x0)) && ((char)plVar18[4] == '\0')
                 )) {
            lVar13 = plVar18[2];
            plVar11[2] = lVar13;
            if (lVar13 != 0) {
              *(long long **)(lVar13 + 0x18) = plVar11;
            }
            plVar11[1] = plVar11[1] + plVar18[1];
            *plVar18 = plVar23[0x28005];
            plVar23[0x28005] = (long long)plVar18;
            plVar15 = (long long *)plVar23[3];
            plVar18 = (long long *)plVar11[2];
          }
        }
        cVar9 = FUN_180068a90(puVar20 + 2,&plStack_240);
      }
    }
    else {
      (**(code **)((undefined *)*puVar20 + 0x18))(puVar20);
    }
    if (bVar7) {
      plVar23 = *(long long **)(param_1 + 0xc0);
      uVar25 = uVar19;
      if (0 < iStack_1e8) {
        do {
          uVar25 = uVar25 * 0x1f + (long long)(char)pbStack_1f0[uVar19];
          uVar16 = (int)uVar19 + 1;
          uVar19 = (ulong long)uVar16;
        } while ((int)uVar16 < iStack_1e8);
      }
      plVar18 = (long long *)plVar23[0x67];
      for (lVar13 = plVar18[uVar25 % (ulong long)*(uint *)(plVar23 + 0x68)]; lVar13 != 0;
          lVar13 = *(long long *)(lVar13 + 0x120)) {
        iVar17 = *(int *)(lVar13 + 0x10);
        if (iStack_1e8 == iVar17) {
          if (iStack_1e8 != 0) {
            pbVar12 = pbStack_1f0;
            do {
              pbVar3 = pbVar12 + (*(long long *)(lVar13 + 8) - (long long)pbStack_1f0);
              iVar17 = (uint)*pbVar12 - (uint)*pbVar3;
              if (iVar17 != 0) break;
              pbVar12 = pbVar12 + 1;
            } while (*pbVar3 != 0);
          }
LAB_18006c61e:
          if (iVar17 == 0) {
            if (lVar13 != 0) {
              lVar10 = plVar23[0x68];
              goto LAB_18006c642;
            }
            break;
          }
        }
        else if (iStack_1e8 == 0) goto LAB_18006c61e;
      }
      lVar10 = plVar23[0x68];
      lVar13 = plVar18[lVar10];
LAB_18006c642:
      if ((lVar13 != plVar18[lVar10]) && (lVar13 = *(long long *)(lVar13 + 0x118), lVar13 != 0)) {
LAB_18006c852:
        if (lStack_c8 == 0) {
          uVar19 = 0;
          if (lStack_d0 == 0) {
            uVar19 = uStack_d8;
          }
        }
        else {
          uVar19 = uStack_d8;
          if (lStack_d0 == 0) {
            uVar19 = uStack_d8 + lStack_c0;
          }
        }
        LOCK();
        plVar23 = (long long *)(param_1 + 0x3f0);
        lVar10 = *plVar23;
        *plVar23 = *plVar23 + uVar19;
        UNLOCK();
        LOCK();
        piVar2 = (int *)(param_1 + 0x3f8);
        iVar17 = *piVar2;
        *piVar2 = *piVar2 + 1;
        UNLOCK();
        puVar20 = *(void* **)(param_1 + 0xc0);
        uStack_258 = puVar20[0x6c];
        if (uStack_258 < uVar19) {
          pbVar12 = &SystemStringTemplate;
          if (pbStack_1f0 != (byte *)0x0) {
            pbVar12 = pbStack_1f0;
          }
                    // WARNING: Subroutine does not return
          FUN_180062300(_DAT_180c86928,&UNK_1809ff390,uVar19,pbVar12);
        }
        if (((uStack_258 < lVar10 + uVar19) ||
            ((ulong long)(long long)*(int *)(param_1 + 0x3fc) < (long long)iVar17 + 1U)) ||
           (cVar9 = (**(code **)*puVar20)(puVar20,lVar13,&puStack_1f8), cVar9 == '\0')) {
          LOCK();
          *(long long *)(param_1 + 0x3f0) = *(long long *)(param_1 + 0x3f0) - uVar19;
          UNLOCK();
          LOCK();
          *(int *)(param_1 + 0x3f8) = *(int *)(param_1 + 0x3f8) + -1;
          UNLOCK();
          FUN_18006cc50(param_1 + 0x3c8,&puStack_1f8);
LAB_18006ca44:
          pcVar22 = *(code **)(**(long long **)(param_1 + 0xc0) + 0x28);
          if (pcVar22 != _guard_check_icall) {
            (*pcVar22)();
          }
          Sleep(1);
        }
        pcVar22 = *(code **)(**(long long **)(param_1 + 0xc0) + 0x20);
        if (pcVar22 != _guard_check_icall) {
          (*pcVar22)();
        }
        goto LAB_18006ca95;
      }
      if (*(int *)((long long)plVar23 + 0x32c) < (int)plVar23[0x65]) {
        puVar20 = (void* *)*plVar18;
        plVar15 = plVar18;
        if (puVar20 == (void* *)0x0) {
          plVar15 = plVar18 + 1;
          puVar20 = (void* *)*plVar15;
          if (puVar20 == (void* *)0x0) {
            do {
              plVar15 = plVar15 + 1;
              puVar20 = (void* *)*plVar15;
            } while (puVar20 == (void* *)0x0);
            lVar10 = plVar23[0x68];
          }
        }
        if (puVar20 != (void* *)plVar18[lVar10]) {
          do {
            if (*(int *)(puVar20[0x23] + 0x120) == 0) {
              uVar4 = puVar20[0x23];
              *(int *)(plVar23 + 0x65) = (int)plVar23[0x65] + -1;
              (**(code **)(*plVar23 + 0x10))(plVar23,uVar4);
              lVar13 = puVar20[0x24];
              plVar23 = plVar15;
              while (lVar13 == 0) {
                plVar23 = plVar23 + 1;
                lVar13 = *plVar23;
              }
              puVar5 = (void* *)*plVar15;
              puVar6 = (void* *)puVar5[0x24];
              if (puVar5 == puVar20) {
                *plVar15 = (long long)puVar6;
              }
              else {
                for (; puVar6 != puVar20; puVar6 = (void* *)puVar6[0x24]) {
                  puVar5 = puVar6;
                }
                puVar5[0x24] = puVar6[0x24];
              }
              *puVar20 = &SystemMemoryAllocatorReference;
              ppuStack_248 = (undefined **)puVar20;
                    // WARNING: Subroutine does not return
              FUN_18064e900(puVar20);
            }
            puVar20 = (void* *)puVar20[0x24];
            while (puVar20 == (void* *)0x0) {
              plVar15 = plVar15 + 1;
              puVar20 = (void* *)*plVar15;
            }
          } while (puVar20 != *(void* **)(plVar23[0x67] + plVar23[0x68] * 8));
        }
      }
      plVar18 = (long long *)(param_1 + 0x3c8);
      lVar13 = 0;
      plVar23 = *(long long **)(param_1 + 0xc0);
      if (*(int *)((long long)plVar23 + 0x32c) < (int)plVar23[0x65]) {
        uVar19 = *(ulong long *)(param_1 + 0x3d0);
        if (uVar19 < *(ulong long *)(param_1 + 0x3d8)) {
          *(ulong long *)(param_1 + 0x3d0) = uVar19 + 0x1a8;
          FUN_18006cd80(uVar19,&puStack_1f8);
          goto LAB_18006ca44;
        }
        lVar10 = *plVar18;
        lVar14 = (long long)(uVar19 - lVar10) / 0x1a8;
        if (lVar14 == 0) {
          lVar14 = 1;
LAB_18006c9ac:
          lVar13 = CreateSystemThreadObject(_DAT_180c8ed18,lVar14 * 0x1a8,*(uint8_t *)(param_1 + 0x3e0));
          uVar19 = *(ulong long *)(param_1 + 0x3d0);
          lVar10 = *plVar18;
        }
        else {
          lVar14 = lVar14 * 2;
          if (lVar14 != 0) goto LAB_18006c9ac;
        }
        FUN_18006de00(&lStack_238,lVar10,uVar19,lVar13);
        lVar8 = lStack_238;
        FUN_18006cd80(lStack_238,&puStack_1f8);
        lVar10 = *(long long *)(param_1 + 0x3d0);
        lVar21 = *plVar18;
        if (lVar21 != lVar10) {
          do {
            FUN_180069530(lVar21);
            lVar21 = lVar21 + 0x1a8;
          } while (lVar21 != lVar10);
          lVar21 = *plVar18;
        }
        if (lVar21 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(lVar21);
        }
        *plVar18 = lVar13;
        *(long long *)(param_1 + 0x3d0) = lVar8 + 0x1a8;
        *(long long *)(param_1 + 0x3d8) = lVar14 * 0x1a8 + lVar13;
        goto LAB_18006ca44;
      }
      *(int *)(plVar23 + 0x65) = (int)plVar23[0x65] + 1;
      lVar13 = (**(code **)(*plVar23 + 8))(plVar23,&puStack_1f8);
      if (lVar13 != 0) goto LAB_18006c852;
      (*pcStack_78)(astackParameterC);
      ppuStack_248 = (undefined **)astackParameterC;
      if (pcStack_80 != (code *)0x0) {
        (*pcStack_80)(astackParameterC,0,0);
      }
      ppuStack_248 = (undefined **)auStack_b0;
      if (pcStack_a0 != (code *)0x0) {
        (*pcStack_a0)(auStack_b0,0,0);
      }
    }
    else {
      pcVar22 = *(code **)(**(long long **)(param_1 + 0xc0) + 0x28);
      if (pcVar22 != _guard_check_icall) {
        (*pcVar22)();
      }
LAB_18006ca95:
      ppuStack_248 = (undefined **)astackParameterC;
      if (pcStack_80 != (code *)0x0) {
        (*pcStack_80)(astackParameterC,0,0);
      }
      ppuStack_248 = (undefined **)auStack_b0;
      if (pcStack_a0 != (code *)0x0) {
        (*pcStack_a0)(auStack_b0,0,0);
      }
    }
    ppuStack_248 = &puStack_1f8;
    puStack_1f8 = &SystemMemoryAllocatorReference;
    cVar9 = *(char *)(*(long long *)(param_1 + 1000) + 0x58);
  } while( true );
}




// 函数: void FUN_18006cb90(long long param_1)
void FUN_18006cb90(long long param_1)

{
  long long lVar1;
  void** systemDataTable;
  ulong long uVar3;
  ulong long uVar4;
  
  uVar3 = *(ulong long *)(param_1 + 0x10);
  lVar1 = *(long long *)(param_1 + 8);
  uVar4 = 0;
  if (uVar3 != 0) {
    do {
      puVar2 = *(void* **)(lVar1 + uVar4 * 8);
      if (puVar2 != (void* *)0x0) {
        *puVar2 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(void* *)(lVar1 + uVar4 * 8) = 0;
      uVar4 = uVar4 + 1;
    } while (uVar4 < uVar3);
    uVar3 = *(ulong long *)(param_1 + 0x10);
  }
  *(void* *)(param_1 + 0x18) = 0;
  if ((1 < uVar3) && (*(long long *)(param_1 + 8) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18006cc50(long long *param_1,long long param_2)

{
  long long lVar1;
  ulong long uVar2;
  long long lVar3;
  long long lVar4;
  code *pcVar5;
  long long lVar6;
  ulong long uStackX_8;
  
  uVar2 = param_1[1];
  if (uVar2 < (ulong long)param_1[2]) {
    param_1[1] = uVar2 + 0x1a8;
    uStackX_8 = uVar2;
    FUN_180068ff0();
    *(void* *)(uVar2 + 0x118) = *(void* *)(param_2 + 0x118);
    *(void* *)(uVar2 + 0x120) = *(void* *)(param_2 + 0x120);
    *(void* *)(uVar2 + 0x128) = *(void* *)(param_2 + 0x128);
    *(void* *)(uVar2 + 0x130) = *(void* *)(param_2 + 0x130);
    *(void* *)(uVar2 + 0x138) = *(void* *)(param_2 + 0x138);
    *(uint8_t *)(uVar2 + 0x140) = *(uint8_t *)(param_2 + 0x140);
    *(void* *)(uVar2 + 0x158) = 0;
    *(code **)(uVar2 + 0x160) = _guard_check_icall;
    if (uVar2 + 0x148 != param_2 + 0x148) {
      pcVar5 = *(code **)(param_2 + 0x158);
      if (pcVar5 != (code *)0x0) {
        (*pcVar5)(uVar2 + 0x148,param_2 + 0x148,1);
        pcVar5 = *(code **)(param_2 + 0x158);
      }
      *(code **)(uVar2 + 0x158) = pcVar5;
      *(void* *)(uVar2 + 0x160) = *(void* *)(param_2 + 0x160);
    }
    *(void* *)(uVar2 + 0x178) = 0;
    *(code **)(uVar2 + 0x180) = _guard_check_icall;
    if (uVar2 + 0x168 != param_2 + 0x168) {
      pcVar5 = *(code **)(param_2 + 0x178);
      if (pcVar5 != (code *)0x0) {
        (*pcVar5)(uVar2 + 0x168,param_2 + 0x168,1);
        pcVar5 = *(code **)(param_2 + 0x178);
      }
      *(code **)(uVar2 + 0x178) = pcVar5;
      *(void* *)(uVar2 + 0x180) = *(void* *)(param_2 + 0x180);
    }
    *(void* *)(uVar2 + 0x188) = *(void* *)(param_2 + 0x188);
    *(void* *)(uVar2 + 400) = *(void* *)(param_2 + 400);
    *(void* *)(uVar2 + 0x198) = *(void* *)(param_2 + 0x198);
    *(void* *)(uVar2 + 0x1a0) = *(void* *)(param_2 + 0x1a0);
    return uVar2;
  }
  lVar6 = *param_1;
  lVar4 = (long long)(uVar2 - lVar6) / 0x1a8;
  if (lVar4 == 0) {
    lVar4 = 1;
  }
  else {
    lVar4 = lVar4 * 2;
    if (lVar4 == 0) {
      lVar1 = 0;
      goto LAB_18006ccef;
    }
  }
  lVar1 = CreateSystemThreadObject(_DAT_180c8ed18,lVar4 * 0x1a8,(char)param_1[3]);
  uVar2 = param_1[1];
  lVar6 = *param_1;
LAB_18006ccef:
  FUN_18006de00(&uStackX_8,lVar6,uVar2,lVar1);
  FUN_18006cd80(uStackX_8,param_2);
  lVar6 = param_1[1];
  lVar3 = *param_1;
  if (lVar3 != lVar6) {
    do {
      FUN_180069530(lVar3);
      lVar3 = lVar3 + 0x1a8;
    } while (lVar3 != lVar6);
    lVar3 = *param_1;
  }
  if (lVar3 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar3);
  }
  uVar2 = lVar4 * 0x1a8 + lVar1;
  *param_1 = lVar1;
  param_1[1] = uStackX_8 + 0x1a8;
  param_1[2] = uVar2;
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006cc8d(void* param_1,void* param_2,long long param_3)
void FUN_18006cc8d(void* param_1,void* param_2,long long param_3)

{
  long long lVar1;
  long long lVar2;
  long long in_RAX;
  long long lVar3;
  long long lVar4;
  long long systemTimeValue;
  long long *unaff_RDI;
  long long in_R10;
  long long in_stack_00000050;
  
  lVar4 = SUB168(SEXT816(in_RAX) * SEXT816(param_3 - in_R10),8);
  lVar4 = (lVar4 >> 7) - (lVar4 >> 0x3f);
  if (lVar4 == 0) {
    lVar4 = 1;
  }
  else {
    lVar4 = lVar4 * 2;
    if (lVar4 == 0) {
      lVar3 = 0;
      goto LAB_18006ccef;
    }
  }
  lVar3 = CreateSystemThreadObject(_DAT_180c8ed18,lVar4 * 0x1a8,(char)unaff_RDI[3]);
  param_3 = unaff_RDI[1];
  in_R10 = *unaff_RDI;
LAB_18006ccef:
  FUN_18006de00(&stack0x00000050,in_R10,param_3,lVar3);
  lVar2 = in_stack_00000050;
  FUN_18006cd80(in_stack_00000050);
  lVar1 = unaff_RDI[1];
  lVar5 = *unaff_RDI;
  if (lVar5 != lVar1) {
    do {
      FUN_180069530(lVar5);
      lVar5 = lVar5 + 0x1a8;
    } while (lVar5 != lVar1);
    lVar5 = *unaff_RDI;
  }
  if (lVar5 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar5);
  }
  *unaff_RDI = lVar3;
  unaff_RDI[1] = lVar2 + 0x1a8;
  unaff_RDI[2] = lVar4 * 0x1a8 + lVar3;
  return;
}




// 函数: void FUN_18006cd43(void)
void FUN_18006cd43(void)

{
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



long long FUN_18006cd80(long long param_1,long long param_2,void* param_3,void* param_4)

{
  code *pcVar1;
  void* uVar2;
  
  uVar2 = 0xfffffffffffffffe;
  FUN_180068ff0();
  *(void* *)(param_1 + 0x118) = *(void* *)(param_2 + 0x118);
  *(void* *)(param_1 + 0x120) = *(void* *)(param_2 + 0x120);
  *(void* *)(param_1 + 0x128) = *(void* *)(param_2 + 0x128);
  *(void* *)(param_1 + 0x130) = *(void* *)(param_2 + 0x130);
  *(void* *)(param_1 + 0x138) = *(void* *)(param_2 + 0x138);
  *(uint8_t *)(param_1 + 0x140) = *(uint8_t *)(param_2 + 0x140);
  *(void* *)(param_1 + 0x158) = 0;
  *(code **)(param_1 + 0x160) = _guard_check_icall;
  if (param_1 + 0x148 != param_2 + 0x148) {
    pcVar1 = *(code **)(param_2 + 0x158);
    if (pcVar1 != (code *)0x0) {
      (*pcVar1)(param_1 + 0x148,param_2 + 0x148,1,param_4,uVar2);
      pcVar1 = *(code **)(param_2 + 0x158);
    }
    *(code **)(param_1 + 0x158) = pcVar1;
    *(void* *)(param_1 + 0x160) = *(void* *)(param_2 + 0x160);
  }
  *(void* *)(param_1 + 0x178) = 0;
  *(code **)(param_1 + 0x180) = _guard_check_icall;
  if (param_1 + 0x168 != param_2 + 0x168) {
    pcVar1 = *(code **)(param_2 + 0x178);
    if (pcVar1 != (code *)0x0) {
      (*pcVar1)(param_1 + 0x168,param_2 + 0x168,1);
      pcVar1 = *(code **)(param_2 + 0x178);
    }
    *(code **)(param_1 + 0x178) = pcVar1;
    *(void* *)(param_1 + 0x180) = *(void* *)(param_2 + 0x180);
  }
  *(void* *)(param_1 + 0x188) = *(void* *)(param_2 + 0x188);
  *(void* *)(param_1 + 400) = *(void* *)(param_2 + 400);
  *(void* *)(param_1 + 0x198) = *(void* *)(param_2 + 0x198);
  *(void* *)(param_1 + 0x1a0) = *(void* *)(param_2 + 0x1a0);
  return param_1;
}




// 函数: void FUN_18006cf00(void* *param_1)
void FUN_18006cf00(void* *param_1)

{
  int *piVar1;
  int iVar2;
  ulong long uVar3;
  ulong long uVar4;
  long long *plVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  long long lVar9;
  ulong long uVar10;
  bool bVar11;
  
  *param_1 = &UNK_1809ff3e8;
  uVar3 = param_1[4];
  lVar9 = 0;
  uVar4 = param_1[5];
  for (uVar10 = uVar4; uVar10 != uVar3; uVar10 = uVar10 + 1) {
    if ((uVar10 & 0x1f) == 0) {
      if (lVar9 != 0) {
        lVar6 = param_1[10];
        LOCK();
        piVar1 = (int *)(lVar9 + 0x3530);
        iVar2 = *piVar1;
        *piVar1 = *piVar1 + -0x80000000;
        UNLOCK();
        if (iVar2 == 0) {
          lVar8 = *(long long *)(lVar6 + 0x28);
          do {
            *(long long *)(lVar9 + 0x3538) = lVar8;
            *(uint32_t *)(lVar9 + 0x3530) = 1;
            plVar5 = (long long *)(lVar6 + 0x28);
            LOCK();
            lVar7 = *plVar5;
            bVar11 = lVar8 == lVar7;
            if (bVar11) {
              *plVar5 = lVar9;
              lVar7 = lVar8;
            }
            UNLOCK();
            if (bVar11) break;
            LOCK();
            piVar1 = (int *)(lVar9 + 0x3530);
            iVar2 = *piVar1;
            *piVar1 = *piVar1 + 0x7fffffff;
            UNLOCK();
            lVar8 = lVar7;
          } while (iVar2 == 1);
        }
      }
LAB_18006cfb1:
      plVar5 = (long long *)param_1[0xc];
      lVar9 = *(long long *)
               (*(long long *)
                 (plVar5[3] +
                 (((uVar10 & 0xffffffffffffffe0) - **(long long **)(plVar5[3] + plVar5[1] * 8) >> 5)
                  + plVar5[1] & *plVar5 - 1U) * 8) + 8);
    }
    else if (lVar9 == 0) goto LAB_18006cfb1;
    FUN_180069530((ulong long)((uint)uVar10 & 0x1f) * 0x1a8 + lVar9);
  }
  lVar9 = param_1[8];
  if ((lVar9 != 0) && ((uVar4 != uVar3 || ((uVar3 & 0x1f) != 0)))) {
    lVar6 = param_1[10];
    LOCK();
    piVar1 = (int *)(lVar9 + 0x3530);
    iVar2 = *piVar1;
    *piVar1 = *piVar1 + -0x80000000;
    UNLOCK();
    if (iVar2 == 0) {
      lVar8 = *(long long *)(lVar6 + 0x28);
      do {
        *(long long *)(lVar9 + 0x3538) = lVar8;
        *(uint32_t *)(lVar9 + 0x3530) = 1;
        plVar5 = (long long *)(lVar6 + 0x28);
        LOCK();
        lVar7 = *plVar5;
        bVar11 = lVar8 == lVar7;
        if (bVar11) {
          *plVar5 = lVar9;
          lVar7 = lVar8;
        }
        UNLOCK();
        if (bVar11) break;
        LOCK();
        piVar1 = (int *)(lVar9 + 0x3530);
        iVar2 = *piVar1;
        *piVar1 = *piVar1 + 0x7fffffff;
        UNLOCK();
        lVar8 = lVar7;
      } while (iVar2 == 1);
    }
  }
  if (param_1[0xc] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_1809ff488;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_18006d0b0(long long *param_1)

{
  long long *plVar1;
  uint *puVar2;
  ulong long *puVar3;
  ulong long uVar4;
  uint uVar5;
  ulong long uVar6;
  ulong long *systemPreviousNode;
  void** systemNextNode;
  long long lVar9;
  long long lVar10;
  void* *puVar11;
  ulong long uVar12;
  ulong long uVar13;
  uint uVar14;
  void* *puVar15;
  bool bVar16;
  bool bVar17;
  
  uVar5 = GetCurrentThreadId();
  uVar14 = (uVar5 >> 0x10 ^ uVar5) * -0x7a143595;
  uVar14 = (uVar14 >> 0xd ^ uVar14) * -0x3d4d51cb;
  uVar13 = (ulong long)(uVar14 >> 0x10 ^ uVar14);
  systemPreviousNode = (ulong long *)param_1[6];
  for (puVar3 = systemPreviousNode; uVar6 = uVar13, puVar3 != (ulong long *)0x0; puVar3 = (ulong long *)puVar3[2])
  {
    while( true ) {
      uVar6 = uVar6 & *puVar3 - 1;
      uVar14 = *(uint *)(uVar6 * 0x10 + puVar3[1]);
      if (uVar14 == uVar5) {
        puVar15 = *(void* **)(puVar3[1] + 8 + uVar6 * 0x10);
        if (puVar3 == systemPreviousNode) {
          return puVar15;
        }
        do {
          uVar13 = uVar13 & *systemPreviousNode - 1;
          if (*(int *)(systemPreviousNode[1] + uVar13 * 0x10) == 0) {
            puVar2 = (uint *)(systemPreviousNode[1] + uVar13 * 0x10);
            LOCK();
            bVar17 = *puVar2 == 0;
            if (bVar17) {
              *puVar2 = uVar5;
            }
            UNLOCK();
            if (bVar17) {
              *(void* **)(systemPreviousNode[1] + 8 + uVar13 * 0x10) = puVar15;
              return puVar15;
            }
          }
          uVar13 = uVar13 + 1;
        } while( true );
      }
      if (uVar14 == 0) break;
      uVar6 = uVar6 + 1;
    }
  }
  LOCK();
  plVar1 = param_1 + 7;
  lVar9 = *plVar1;
  *plVar1 = *plVar1 + 1;
  UNLOCK();
  uVar6 = lVar9 + 1;
  puVar15 = (void* *)0x0;
  while( true ) {
    if (*systemPreviousNode >> 1 <= uVar6) {
      LOCK();
      puVar2 = (uint *)(param_1 + 0x4b);
      uVar14 = *puVar2;
      *puVar2 = *puVar2 | 1;
      UNLOCK();
      if ((uVar14 & 1) == 0) {
        puVar3 = (ulong long *)param_1[6];
        systemPreviousNode = puVar3;
        uVar12 = *puVar3;
        if (*puVar3 >> 1 <= uVar6) {
          do {
            uVar4 = uVar12;
            uVar12 = uVar4 * 2;
          } while ((uVar4 & 0x7fffffffffffffff) <= uVar6);
          systemPreviousNode = (ulong long *)CreateSystemThreadObject(_DAT_180c8ed18,uVar4 * 0x20 + 0x1f,10);
          if (systemPreviousNode == (ulong long *)0x0) {
            LOCK();
            param_1[7] = param_1[7] + -1;
            UNLOCK();
            *(uint32_t *)(param_1 + 0x4b) = 0;
            return (void* *)0x0;
          }
          *systemPreviousNode = uVar12;
          systemPreviousNode[1] = (ulong long)(-(int)(systemPreviousNode + 3) & 7) + (long long)(systemPreviousNode + 3);
          puVar11 = puVar15;
          for (; uVar12 != 0; uVar12 = uVar12 - 1) {
            *(void* *)((long long)puVar11 + systemPreviousNode[1] + 8) = 0;
            *(uint32_t *)((long long)puVar11 + systemPreviousNode[1]) = 0;
            puVar11 = puVar11 + 2;
          }
          systemPreviousNode[2] = (ulong long)puVar3;
          param_1[6] = (long long)systemPreviousNode;
        }
        *(uint32_t *)(param_1 + 0x4b) = 0;
      }
    }
    if (uVar6 < (*systemPreviousNode >> 2) + (*systemPreviousNode >> 1)) break;
    systemPreviousNode = (ulong long *)param_1[6];
  }
  puVar11 = (void* *)*param_1;
  while (puVar11 != (void* *)0x0) {
    if ((*(char *)(puVar11 + 2) != '\0') && (*(char *)(puVar11 + 9) == '\0')) {
      bVar17 = true;
      LOCK();
      bVar16 = *(char *)(puVar11 + 2) == '\x01';
      if (bVar16) {
        *(char *)(puVar11 + 2) = '\0';
      }
      UNLOCK();
      if (bVar16) goto LAB_18006d3bb;
    }
    plVar1 = puVar11 + 1;
    puVar11 = (void* *)(*plVar1 + -8);
    if (*plVar1 == 0) {
      puVar11 = puVar15;
    }
  }
  bVar17 = false;
  puVar8 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x68,10);
  puVar11 = puVar15;
  if (puVar8 != (void* *)0x0) {
    puVar8[1] = 0;
    *(uint8_t *)(puVar8 + 2) = 0;
    puVar8[3] = 0;
    *puVar8 = &UNK_1809ff488;
    puVar8[4] = 0;
    puVar8[5] = 0;
    puVar8[6] = 0;
    puVar8[7] = 0;
    puVar8[8] = 0;
    *(uint8_t *)(puVar8 + 9) = 0;
    puVar8[10] = param_1;
    *puVar8 = &UNK_1809ff3e8;
    puVar8[0xb] = 0x20;
    puVar8[0xc] = 0;
    FUN_18005f430(puVar8);
    LOCK();
    *(int *)(param_1 + 1) = (int)param_1[1] + 1;
    UNLOCK();
    lVar9 = *param_1;
    do {
      puVar11 = (void* *)(lVar9 + 8);
      if (lVar9 == 0) {
        puVar11 = puVar15;
      }
      puVar8[1] = puVar11;
      LOCK();
      lVar10 = *param_1;
      bVar16 = lVar9 == lVar10;
      if (bVar16) {
        *param_1 = (long long)puVar8;
        lVar10 = lVar9;
      }
      UNLOCK();
      lVar9 = lVar10;
      puVar11 = puVar8;
    } while (!bVar16);
  }
LAB_18006d3bb:
  if (puVar11 == (void* *)0x0) {
    LOCK();
    param_1[7] = param_1[7] + -1;
    UNLOCK();
    return (void* *)0x0;
  }
  if (bVar17) {
    LOCK();
    param_1[7] = param_1[7] + -1;
    UNLOCK();
  }
  do {
    uVar13 = uVar13 & *systemPreviousNode - 1;
    if (*(int *)(systemPreviousNode[1] + uVar13 * 0x10) == 0) {
      puVar2 = (uint *)(systemPreviousNode[1] + uVar13 * 0x10);
      LOCK();
      bVar17 = *puVar2 == 0;
      if (bVar17) {
        *puVar2 = uVar5;
      }
      UNLOCK();
      if (bVar17) {
        *(void* **)(systemPreviousNode[1] + 8 + uVar13 * 0x10) = puVar11;
        return puVar11;
      }
    }
    uVar13 = uVar13 + 1;
  } while( true );
}



void* FUN_18006d450(void* param_1,ulong long param_2)

{
  FUN_18006cf00();
  if ((param_2 & 1) != 0) {
    free(param_1,0x68);
  }
  return param_1;
}



void* FUN_18006d4e0(ulong long *param_1,void* param_2)

{
  long long *plVar1;
  ulong long *puVar2;
  long long lVar3;
  long long lVar4;
  char cVar5;
  ulong long uVar6;
  ulong long uVar7;
  ulong long uVar8;
  ulong long uVar9;
  ulong long uVar10;
  ulong long uVar11;
  ulong long uVar12;
  ulong long uVar13;
  
  uVar13 = 0;
  uVar7 = *param_1;
  uVar8 = uVar13;
  uVar10 = uVar13;
  uVar12 = uVar13;
  do {
    uVar9 = uVar8;
    uVar11 = uVar10;
    if (uVar7 == 0) break;
    uVar6 = *(long long *)(uVar7 + 0x20) - *(long long *)(uVar7 + 0x28);
    if ((ulong long)(*(long long *)(uVar7 + 0x28) - *(long long *)(uVar7 + 0x20)) < 0x8000000000000001)
    {
      uVar6 = uVar13;
    }
    if ((uVar6 != 0) && (uVar12 = uVar12 + 1, uVar9 = uVar7, uVar11 = uVar6, uVar6 <= uVar10)) {
      uVar9 = uVar8;
      uVar11 = uVar10;
    }
    plVar1 = (long long *)(uVar7 + 8);
    uVar7 = *plVar1 - 8;
    if (*plVar1 == 0) {
      uVar7 = uVar13;
    }
    uVar8 = uVar9;
    uVar10 = uVar11;
  } while (uVar12 < 3);
  if (uVar12 != 0) {
    cVar5 = FUN_18006d810(uVar9,param_2,uVar7,uVar11,0xfffffffffffffffe);
    if (cVar5 != '\0') {
      return 1;
    }
    uVar7 = *param_1;
    while (uVar7 != 0) {
      if (uVar7 != uVar9) {
        if (*(char *)(uVar7 + 0x48) == '\0') {
          cVar5 = FUN_18006da90(uVar7,param_2);
        }
        else {
          if (0x8000000000000000 <
              (ulong long)
              ((*(long long *)(uVar7 + 0x30) - *(long long *)(uVar7 + 0x38)) -
              *(long long *)(uVar7 + 0x20))) {
            LOCK();
            plVar1 = (long long *)(uVar7 + 0x30);
            lVar3 = *plVar1;
            *plVar1 = *plVar1 + 1;
            UNLOCK();
            if (0x8000000000000000 <
                (ulong long)((lVar3 - *(long long *)(uVar7 + 0x20)) - *(long long *)(uVar7 + 0x38))) {
              LOCK();
              puVar2 = (ulong long *)(uVar7 + 0x28);
              uVar8 = *puVar2;
              *puVar2 = *puVar2 + 1;
              UNLOCK();
              plVar1 = *(long long **)(uVar7 + 0x58);
              lVar4 = *(long long *)
                       (plVar1[2] + 8 +
                       (((uVar8 & 0xffffffffffffffe0) - *(long long *)(plVar1[2] + plVar1[1] * 0x10)
                        >> 5) + plVar1[1] & *plVar1 - 1U) * 0x10);
              uVar8 = (ulong long)((uint)uVar8 & 0x1f);
              lVar3 = uVar8 * 0x1a8 + lVar4;
              FUN_18006dcb0(param_2,lVar3);
              FUN_180069530(lVar3);
              *(uint8_t *)((lVar4 - uVar8) + 0x352f) = 1;
              cVar5 = '\x01';
              goto LAB_18006d67d;
            }
            LOCK();
            *(long long *)(uVar7 + 0x38) = *(long long *)(uVar7 + 0x38) + 1;
            UNLOCK();
          }
          cVar5 = '\0';
        }
LAB_18006d67d:
        if (cVar5 != '\0') {
          return 1;
        }
      }
      plVar1 = (long long *)(uVar7 + 8);
      uVar7 = *plVar1 - 8;
      if (*plVar1 == 0) {
        uVar7 = uVar13;
      }
    }
  }
  return 0;
}



void* FUN_18006d6c0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  ulong long uVar1;
  long long *plVar2;
  char cVar3;
  ulong long uVar4;
  ulong long *puVar5;
  void* uVar6;
  
  uVar6 = 0xfffffffffffffffe;
  uVar1 = *(ulong long *)(param_1 + 0x20);
  if ((uVar1 & 0x1f) != 0) {
    FUN_18006cd80((ulong long)((uint)uVar1 & 0x1f) * 0x1a8 + *(long long *)(param_1 + 0x40));
LAB_18006d7fb:
    *(ulong long *)(param_1 + 0x20) = uVar1 + 1;
    return 1;
  }
  if ((0x8000000000000000 < (*(long long *)(param_1 + 0x28) - uVar1) - 0x20) &&
     (plVar2 = *(long long **)(param_1 + 0x60), plVar2 != (long long *)0x0)) {
    uVar4 = *plVar2 - 1U & plVar2[1] + 1U;
    puVar5 = *(ulong long **)(plVar2[3] + uVar4 * 8);
    if ((*puVar5 == 1) || (puVar5[1] == 0)) {
      *puVar5 = uVar1;
      plVar2[1] = uVar4;
    }
    else {
      cVar3 = FUN_18005f430(param_1);
      if (cVar3 == '\0') {
        return 0;
      }
      plVar2 = *(long long **)(param_1 + 0x60);
      uVar4 = *plVar2 - 1U & plVar2[1] + 1U;
      puVar5 = *(ulong long **)(plVar2[3] + uVar4 * 8);
      *puVar5 = uVar1;
      plVar2[1] = uVar4;
    }
    uVar4 = FUN_18006d920(*(void* *)(param_1 + 0x50));
    if (uVar4 != 0) {
      *(void* *)(uVar4 + 0x3508) = 0;
      FUN_18006cd80(uVar4,param_2,param_3,param_4,uVar6);
      puVar5[1] = uVar4;
      *(ulong long *)(param_1 + 0x40) = uVar4;
      goto LAB_18006d7fb;
    }
    plVar2 = *(long long **)(param_1 + 0x60);
    plVar2[1] = *plVar2 - 1U & plVar2[1] - 1U;
    puVar5[1] = 0;
  }
  return 0;
}



void* FUN_18006d810(long long param_1,void* param_2)

{
  long long *plVar1;
  ulong long *puVar2;
  long long lVar3;
  ulong long uVar4;
  long long systemTimeValue;
  long long lVar6;
  void* uVar7;
  ulong long uVar8;
  
  if (*(char *)(param_1 + 0x48) == '\0') {
    uVar7 = FUN_18006da90();
  }
  else {
    if (0x8000000000000000 <
        (ulong long)
        ((*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x38)) -
        *(long long *)(param_1 + 0x20))) {
      LOCK();
      plVar1 = (long long *)(param_1 + 0x30);
      lVar3 = *plVar1;
      *plVar1 = *plVar1 + 1;
      UNLOCK();
      if (0x8000000000000000 <
          (ulong long)((lVar3 - *(long long *)(param_1 + 0x20)) - *(long long *)(param_1 + 0x38))) {
        LOCK();
        puVar2 = (ulong long *)(param_1 + 0x28);
        uVar4 = *puVar2;
        *puVar2 = *puVar2 + 1;
        UNLOCK();
        plVar1 = *(long long **)(param_1 + 0x58);
        lVar5 = plVar1[2];
        lVar6 = *(long long *)
                 (lVar5 + 8 +
                 (((uVar4 & 0xffffffffffffffe0) - *(long long *)(lVar5 + plVar1[1] * 0x10) >> 5) +
                  plVar1[1] & *plVar1 - 1U) * 0x10);
        uVar8 = (ulong long)((uint)uVar4 & 0x1f);
        lVar3 = uVar8 * 0x1a8 + lVar6;
        FUN_18006dcb0(param_2,lVar3,plVar1,lVar5,0xfffffffffffffffe,lVar6,uVar4);
        FUN_180069530(lVar3);
        *(uint8_t *)((lVar6 - uVar8) + 0x352f) = 1;
        return 1;
      }
      LOCK();
      *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + 1;
      UNLOCK();
    }
    uVar7 = 0;
  }
  return uVar7;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long FUN_18006d920(long long param_1)

{
  ulong long *puVar1;
  uint *puVar2;
  uint uVar3;
  ulong long uVar4;
  uint uVar5;
  long long lVar6;
  long long lVar7;
  long long lVar8;
  long long lVar9;
  bool bVar10;
  
  if (*(ulong long *)(param_1 + 0x10) < *(ulong long *)(param_1 + 0x20)) {
    LOCK();
    puVar1 = (ulong long *)(param_1 + 0x10);
    uVar4 = *puVar1;
    *puVar1 = *puVar1 + 1;
    UNLOCK();
    if ((uVar4 < *(ulong long *)(param_1 + 0x20)) &&
       (lVar6 = uVar4 * 0x3548 + *(long long *)(param_1 + 0x18), lVar6 != 0)) {
      return lVar6;
    }
  }
  lVar6 = *(long long *)(param_1 + 0x28);
LAB_18006d957:
  do {
    lVar9 = lVar6;
    if (lVar9 == 0) {
LAB_18006d9f6:
      lVar6 = CreateSystemThreadObject(_DAT_180c8ed18,0x3548,10);
      if (lVar6 == 0) {
        return 0;
      }
      *(void* *)(lVar6 + 0x3500) = 0;
      *(void* *)(lVar6 + 0x3508) = 0;
      *(uint32_t *)(lVar6 + 0x3530) = 0;
      *(void* *)(lVar6 + 0x3538) = 0;
      *(undefined2 *)(lVar6 + 0x3540) = 0x100;
      return lVar6;
    }
    puVar2 = (uint *)(lVar9 + 0x3530);
    uVar5 = *puVar2;
    if ((uVar5 & 0x7fffffff) == 0) {
LAB_18006d9d7:
      lVar6 = *(long long *)(param_1 + 0x28);
      goto LAB_18006d957;
    }
    LOCK();
    uVar3 = *puVar2;
    if (uVar5 == uVar3) {
      *puVar2 = uVar5 + 1;
    }
    UNLOCK();
    if (uVar5 != uVar3) goto LAB_18006d9d7;
    LOCK();
    lVar6 = *(long long *)(param_1 + 0x28);
    bVar10 = lVar9 == lVar6;
    if (bVar10) {
      *(long long *)(param_1 + 0x28) = *(long long *)(lVar9 + 0x3538);
      lVar6 = lVar9;
    }
    UNLOCK();
    if (bVar10) {
      LOCK();
      *puVar2 = *puVar2 - 2;
      UNLOCK();
      if (lVar9 != 0) {
        return lVar9;
      }
      goto LAB_18006d9f6;
    }
    LOCK();
    uVar5 = *puVar2;
    *puVar2 = *puVar2 - 1;
    UNLOCK();
    if (uVar5 == 0x80000001) {
      lVar8 = *(long long *)(param_1 + 0x28);
      do {
        *(long long *)(lVar9 + 0x3538) = lVar8;
        *puVar2 = 1;
        LOCK();
        lVar7 = *(long long *)(param_1 + 0x28);
        bVar10 = lVar8 == lVar7;
        if (bVar10) {
          *(long long *)(param_1 + 0x28) = lVar9;
          lVar7 = lVar8;
        }
        UNLOCK();
        if (bVar10) break;
        LOCK();
        uVar5 = *puVar2;
        *puVar2 = *puVar2 + 0x7fffffff;
        UNLOCK();
        lVar8 = lVar7;
      } while (uVar5 == 1);
    }
  } while( true );
}




// 函数: void FUN_18006da50(long long *param_1)
void FUN_18006da50(long long *param_1)

{
  FUN_180069530((ulong long)(*(uint *)(param_1 + 1) & 0x1f) * 0x1a8 + *param_1);
  *(uint8_t *)((*param_1 - (ulong long)(*(uint *)(param_1 + 1) & 0x1f)) + 0x352f) = 1;
  return;
}



ulong long FUN_18006da90(long long param_1,void* param_2)

{
  long long *plVar1;
  ulong long *puVar2;
  uint *puVar3;
  uint uVar4;
  long long systemTimeValue;
  ulong long uVar6;
  long long lVar7;
  ulong long uVar8;
  ulong long uVar9;
  long long lVar10;
  ulong long uVar11;
  bool bVar12;
  
  uVar8 = (*(long long *)(param_1 + 0x30) - *(long long *)(param_1 + 0x38)) -
          *(long long *)(param_1 + 0x20);
  if (0x8000000000000000 < uVar8) {
    LOCK();
    plVar1 = (long long *)(param_1 + 0x30);
    lVar5 = *plVar1;
    *plVar1 = *plVar1 + 1;
    UNLOCK();
    uVar8 = *(ulong long *)(param_1 + 0x20);
    if (0x8000000000000000 < (lVar5 - uVar8) - *(long long *)(param_1 + 0x38)) {
      LOCK();
      puVar2 = (ulong long *)(param_1 + 0x28);
      uVar8 = *puVar2;
      *puVar2 = *puVar2 + 1;
      UNLOCK();
      plVar1 = *(long long **)(param_1 + 0x60);
      uVar11 = (uVar8 & 0xffffffffffffffe0) - **(long long **)(plVar1[3] + plVar1[1] * 8) >> 5;
      lVar5 = *(long long *)(plVar1[3] + (plVar1[1] + uVar11 & *plVar1 - 1U) * 8);
      uVar6 = *(ulong long *)(lVar5 + 8);
      lVar10 = (ulong long)((uint)uVar8 & 0x1f) * 0x1a8 + uVar6;
      lVar7 = *(long long *)(param_1 + 0x50);
      FUN_18006dcb0(param_2,lVar10,uVar11,plVar1,0xfffffffffffffffe,uVar6,uVar8,lVar5);
      FUN_180069530(lVar10);
      LOCK();
      puVar2 = (ulong long *)(uVar6 + 0x3508);
      uVar8 = *puVar2;
      *puVar2 = *puVar2 + 1;
      UNLOCK();
      if (uVar8 == 0x1f) {
        *(void* *)(lVar5 + 8) = 0;
        LOCK();
        puVar3 = (uint *)(uVar6 + 0x3530);
        uVar4 = *puVar3;
        *puVar3 = *puVar3 + 0x80000000;
        UNLOCK();
        uVar8 = (ulong long)uVar4;
        if (uVar4 == 0) {
          uVar11 = *(ulong long *)(lVar7 + 0x28);
          do {
            *(ulong long *)(uVar6 + 0x3538) = uVar11;
            *(uint32_t *)(uVar6 + 0x3530) = 1;
            puVar2 = (ulong long *)(lVar7 + 0x28);
            LOCK();
            uVar9 = *puVar2;
            bVar12 = uVar11 == uVar9;
            if (bVar12) {
              *puVar2 = uVar6;
              uVar9 = uVar11;
            }
            UNLOCK();
            uVar8 = uVar9;
            if (bVar12) break;
            LOCK();
            puVar3 = (uint *)(uVar6 + 0x3530);
            uVar4 = *puVar3;
            uVar8 = (ulong long)uVar4;
            *puVar3 = *puVar3 + 0x7fffffff;
            UNLOCK();
            uVar11 = uVar9;
          } while (uVar4 == 1);
        }
      }
      return CONCAT71((int7)(uVar8 >> 8),1);
    }
    LOCK();
    *(long long *)(param_1 + 0x38) = *(long long *)(param_1 + 0x38) + 1;
    UNLOCK();
  }
  return uVar8 & 0xffffffffffffff00;
}




// 函数: void FUN_18006dc10(long long *param_1)
void FUN_18006dc10(long long *param_1)

{
  long long *plVar1;
  int *piVar2;
  int memoryCompareResult;
  long long lVar4;
  long long systemTimeValue;
  long long lVar6;
  long long lVar7;
  bool bVar8;
  
  FUN_180069530((ulong long)(*(uint *)(param_1 + 1) & 0x1f) * 0x1a8 + *param_1);
  LOCK();
  plVar1 = (long long *)(*param_1 + 0x3508);
  lVar4 = *plVar1;
  *plVar1 = *plVar1 + 1;
  UNLOCK();
  if (lVar4 == 0x1f) {
    *(void* *)(param_1[2] + 8) = 0;
    lVar4 = *param_1;
    lVar5 = param_1[3];
    LOCK();
    piVar2 = (int *)(lVar4 + 0x3530);
    iVar3 = *piVar2;
    *piVar2 = *piVar2 + -0x80000000;
    UNLOCK();
    if (iVar3 == 0) {
      lVar7 = *(long long *)(lVar5 + 0x28);
      do {
        *(long long *)(lVar4 + 0x3538) = lVar7;
        *(uint32_t *)(lVar4 + 0x3530) = 1;
        plVar1 = (long long *)(lVar5 + 0x28);
        LOCK();
        lVar6 = *plVar1;
        bVar8 = lVar7 == lVar6;
        if (bVar8) {
          *plVar1 = lVar4;
          lVar6 = lVar7;
        }
        UNLOCK();
        if (bVar8) {
          return;
        }
        LOCK();
        piVar2 = (int *)(lVar4 + 0x3530);
        iVar3 = *piVar2;
        *piVar2 = *piVar2 + 0x7fffffff;
        UNLOCK();
        lVar7 = lVar6;
      } while (iVar3 == 1);
    }
  }
  return;
}



long long FUN_18006dcb0(long long param_1,long long param_2)

{
  long long lVar1;
  undefined *puVar2;
  
  *(uint32_t *)(param_1 + 0x10) = *(uint32_t *)(param_2 + 0x10);
  puVar2 = &SystemStringTemplate;
  if (*(undefined **)(param_2 + 8) != (undefined *)0x0) {
    puVar2 = *(undefined **)(param_2 + 8);
  }
  strcpy_s(*(void* *)(param_1 + 8),0x100,puVar2);
  *(void* *)(param_1 + 0x118) = *(void* *)(param_2 + 0x118);
  lVar1 = param_1 + 0x148;
  *(void* *)(param_1 + 0x120) = *(void* *)(param_2 + 0x120);
  *(void* *)(param_1 + 0x128) = *(void* *)(param_2 + 0x128);
  *(void* *)(param_1 + 0x130) = *(void* *)(param_2 + 0x130);
  *(void* *)(param_1 + 0x138) = *(void* *)(param_2 + 0x138);
  *(uint8_t *)(param_1 + 0x140) = *(uint8_t *)(param_2 + 0x140);
  if (lVar1 != param_2 + 0x148) {
    if (*(code **)(param_1 + 0x158) != (code *)0x0) {
      (**(code **)(param_1 + 0x158))(lVar1,0,0);
    }
    FUN_180069130(lVar1,param_2 + 0x148);
  }
  lVar1 = param_1 + 0x168;
  if (lVar1 != param_2 + 0x168) {
    if (*(code **)(param_1 + 0x178) != (code *)0x0) {
      (**(code **)(param_1 + 0x178))(lVar1,0,0);
    }
    FUN_180069130(lVar1,param_2 + 0x168);
  }
  *(void* *)(param_1 + 0x188) = *(void* *)(param_2 + 0x188);
  *(void* *)(param_1 + 400) = *(void* *)(param_2 + 400);
  *(void* *)(param_1 + 0x198) = *(void* *)(param_2 + 0x198);
  *(void* *)(param_1 + 0x1a0) = *(void* *)(param_2 + 0x1a0);
  return param_1;
}



long long *
FUN_18006de00(long long *param_1,void* *param_2,void* *param_3,void* *param_4)

{
  void* *puVar1;
  code *pcVar2;
  void* *puVar3;
  undefined *puVar4;
  
  *param_1 = (long long)param_4;
  if (param_2 != param_3) {
    puVar3 = param_2 + 0x2b;
    do {
      *param_4 = &SystemMemoryAllocatorReference;
      param_4[1] = 0;
      *(uint32_t *)(param_4 + 2) = 0;
      *param_4 = &UNK_1809feda8;
      param_4[1] = param_4 + 3;
      *(uint32_t *)(param_4 + 2) = 0;
      *(uint8_t *)(param_4 + 3) = 0;
      *(uint32_t *)(param_4 + 2) = *(uint32_t *)(puVar3 + -0x29);
      puVar4 = &SystemStringTemplate;
      if ((undefined *)puVar3[-0x2a] != (undefined *)0x0) {
        puVar4 = (undefined *)puVar3[-0x2a];
      }
      strcpy_s(param_4[1],0x100,puVar4);
      param_4[0x23] = puVar3[-8];
      param_4[0x24] = puVar3[-7];
      param_4[0x25] = puVar3[-6];
      param_4[0x26] = puVar3[-5];
      param_4[0x27] = puVar3[-4];
      *(uint8_t *)(param_4 + 0x28) = *(uint8_t *)(puVar3 + -3);
      param_4[0x2b] = 0;
      param_4[0x2c] = _guard_check_icall;
      if (param_4 + 0x29 != puVar3 + -2) {
        pcVar2 = (code *)*puVar3;
        if (pcVar2 != (code *)0x0) {
          (*pcVar2)(param_4 + 0x29,puVar3 + -2,2);
          pcVar2 = (code *)*puVar3;
        }
        param_4[0x2b] = pcVar2;
        param_4[0x2c] = puVar3[1];
        *puVar3 = 0;
        puVar3[1] = _guard_check_icall;
      }
      param_4[0x2f] = 0;
      param_4[0x30] = _guard_check_icall;
      if (param_4 + 0x2d != puVar3 + 2) {
        pcVar2 = (code *)puVar3[4];
        if (pcVar2 != (code *)0x0) {
          (*pcVar2)(param_4 + 0x2d,puVar3 + 2,2);
          pcVar2 = (code *)puVar3[4];
        }
        param_4[0x2f] = pcVar2;
        param_4[0x30] = puVar3[5];
        puVar3[4] = 0;
        puVar3[5] = _guard_check_icall;
      }
      param_4[0x31] = puVar3[6];
      param_4[0x32] = puVar3[7];
      param_4[0x33] = puVar3[8];
      param_4[0x34] = puVar3[9];
      *param_1 = *param_1 + 0x1a8;
      param_4 = (void* *)*param_1;
      puVar1 = puVar3 + 10;
      puVar3 = puVar3 + 0x35;
    } while (puVar1 != param_3);
  }
  return param_1;
}



long long * FUN_18006e000(long long param_1,long long param_2)

{
  long long lVar1;
  long long *plVar2;
  long long *plVar3;
  ulong long uVar4;
  long long *plVar5;
  
  plVar5 = *(long long **)(param_1 + 0x318);
  uVar4 = param_2 + 0xfU & 0xfffffffffffffff0;
  plVar3 = (long long *)0x0;
  plVar2 = (long long *)plVar5[3];
  if (plVar2 != (long long *)0x0) {
    do {
      if ((((char)plVar2[4] == '\0') && (uVar4 <= (ulong long)plVar2[1])) &&
         ((plVar3 == (long long *)0x0 || ((ulong long)plVar2[1] < (ulong long)plVar3[1])))) {
        plVar3 = plVar2;
      }
      plVar2 = (long long *)plVar2[2];
    } while (plVar2 != (long long *)0x0);
    if (plVar3 != (long long *)0x0) {
      if (uVar4 < (ulong long)plVar3[1]) {
        plVar2 = (long long *)func_0x00018006e810(plVar5 + 4);
        *(uint8_t *)(plVar2 + 4) = 0;
        *plVar2 = *plVar3 + uVar4;
        plVar2[1] = plVar3[1] - uVar4;
        lVar1 = plVar3[2];
        plVar2[2] = lVar1;
        if (lVar1 != 0) {
          *(long long **)(lVar1 + 0x18) = plVar2;
        }
        plVar3[2] = (long long)plVar2;
        plVar2[3] = (long long)plVar3;
        plVar3[1] = uVar4;
      }
      *(uint8_t *)(plVar3 + 4) = 1;
      *plVar5 = *plVar5 + uVar4;
      plVar5[2] = plVar5[2] - uVar4;
      return plVar3;
    }
  }
  return (long long *)0x0;
}



long long FUN_18006e0b0(long long param_1,ulong long param_2)

{
  FUN_18006e5d0();
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  FUN_18006e4a0(param_1 + 200);
  FUN_180049470(param_1);
  if ((param_2 & 1) != 0) {
    free(param_1,0x408);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006e140(void)
void FUN_18006e140(void)

{
  long long lVar1;
  
  lVar1 = CreateSystemThreadObject(_DAT_180c8ed18,0x45ee8,10);
  if (lVar1 == 0) {
    return;
  }
  *(void* *)(lVar1 + 0x3500) = 0;
  *(void* *)(lVar1 + 0x3508) = 0;
  *(uint32_t *)(lVar1 + 0x3530) = 0;
  *(void* *)(lVar1 + 0x3538) = 0;
  *(undefined2 *)(lVar1 + 0x3540) = 0x100;
  *(void* *)(lVar1 + 0x6a48) = 0;
  *(void* *)(lVar1 + 0x6a50) = 0;
  *(uint32_t *)(lVar1 + 0x6a78) = 0;
  *(void* *)(lVar1 + 0x6a80) = 0;
  *(undefined2 *)(lVar1 + 0x6a88) = 0x100;
  *(void* *)(lVar1 + 0x9f90) = 0;
  *(void* *)(lVar1 + 0x9f98) = 0;
  *(uint32_t *)(lVar1 + 0x9fc0) = 0;
  *(void* *)(lVar1 + 0x9fc8) = 0;
  *(undefined2 *)(lVar1 + 0x9fd0) = 0x100;
  *(void* *)(lVar1 + 0xd4d8) = 0;
  *(void* *)(lVar1 + 0xd4e0) = 0;
  *(uint32_t *)(lVar1 + 0xd508) = 0;
  *(void* *)(lVar1 + 0xd510) = 0;
  *(undefined2 *)(lVar1 + 0xd518) = 0x100;
  *(void* *)(lVar1 + 0x10a20) = 0;
  *(void* *)(lVar1 + 0x10a28) = 0;
  *(uint32_t *)(lVar1 + 0x10a50) = 0;
  *(void* *)(lVar1 + 0x10a58) = 0;
  *(undefined2 *)(lVar1 + 0x10a60) = 0x100;
  *(void* *)(lVar1 + 0x13f68) = 0;
  *(void* *)(lVar1 + 0x13f70) = 0;
  *(uint32_t *)(lVar1 + 0x13f98) = 0;
  *(void* *)(lVar1 + 0x13fa0) = 0;
  *(undefined2 *)(lVar1 + 0x13fa8) = 0x100;
  *(void* *)(lVar1 + 0x174b0) = 0;
  *(void* *)(lVar1 + 0x174b8) = 0;
  *(uint32_t *)(lVar1 + 0x174e0) = 0;
  *(void* *)(lVar1 + 0x174e8) = 0;
  *(undefined2 *)(lVar1 + 0x174f0) = 0x100;
  *(void* *)(lVar1 + 0x1a9f8) = 0;
  *(void* *)(lVar1 + 0x1aa00) = 0;
  *(uint32_t *)(lVar1 + 0x1aa28) = 0;
  *(void* *)(lVar1 + 0x1aa30) = 0;
  *(undefined2 *)(lVar1 + 0x1aa38) = 0x100;
  *(void* *)(lVar1 + 0x1df40) = 0;
  *(void* *)(lVar1 + 0x1df48) = 0;
  *(uint32_t *)(lVar1 + 0x1df70) = 0;
  *(void* *)(lVar1 + 0x1df78) = 0;
  *(undefined2 *)(lVar1 + 0x1df80) = 0x100;
  *(void* *)(lVar1 + 0x21488) = 0;
  *(void* *)(lVar1 + 0x21490) = 0;
  *(uint32_t *)(lVar1 + 0x214b8) = 0;
  *(void* *)(lVar1 + 0x214c0) = 0;
  *(undefined2 *)(lVar1 + 0x214c8) = 0x100;
  *(void* *)(lVar1 + 0x249d0) = 0;
  *(void* *)(lVar1 + 0x249d8) = 0;
  *(uint32_t *)(lVar1 + 0x24a00) = 0;
  *(void* *)(lVar1 + 0x24a08) = 0;
  *(undefined2 *)(lVar1 + 0x24a10) = 0x100;
  *(void* *)(lVar1 + 0x27f18) = 0;
  *(void* *)(lVar1 + 0x27f20) = 0;
  *(uint32_t *)(lVar1 + 0x27f48) = 0;
  *(void* *)(lVar1 + 0x27f50) = 0;
  *(undefined2 *)(lVar1 + 0x27f58) = 0x100;
  *(void* *)(lVar1 + 0x2b460) = 0;
  *(void* *)(lVar1 + 0x2b468) = 0;
  *(uint32_t *)(lVar1 + 0x2b490) = 0;
  *(void* *)(lVar1 + 0x2b498) = 0;
  *(undefined2 *)(lVar1 + 0x2b4a0) = 0x100;
  *(void* *)(lVar1 + 0x2e9a8) = 0;
  *(void* *)(lVar1 + 0x2e9b0) = 0;
  *(uint32_t *)(lVar1 + 0x2e9d8) = 0;
  *(void* *)(lVar1 + 0x2e9e0) = 0;
  *(undefined2 *)(lVar1 + 0x2e9e8) = 0x100;
  *(void* *)(lVar1 + 0x31ef0) = 0;
  *(void* *)(lVar1 + 0x31ef8) = 0;
  *(uint32_t *)(lVar1 + 0x31f20) = 0;
  *(void* *)(lVar1 + 0x31f28) = 0;
  *(undefined2 *)(lVar1 + 0x31f30) = 0x100;
  *(void* *)(lVar1 + 0x35438) = 0;
  *(void* *)(lVar1 + 0x35440) = 0;
  *(uint32_t *)(lVar1 + 0x35468) = 0;
  *(void* *)(lVar1 + 0x35470) = 0;
  *(undefined2 *)(lVar1 + 0x35478) = 0x100;
  *(void* *)(lVar1 + 0x38980) = 0;
  *(void* *)(lVar1 + 0x38988) = 0;
  *(uint32_t *)(lVar1 + 0x389b0) = 0;
  *(void* *)(lVar1 + 0x389b8) = 0;
  *(undefined2 *)(lVar1 + 0x389c0) = 0x100;
  *(void* *)(lVar1 + 0x3bec8) = 0;
  *(void* *)(lVar1 + 0x3bed0) = 0;
  *(uint32_t *)(lVar1 + 0x3bef8) = 0;
  *(void* *)(lVar1 + 0x3bf00) = 0;
  *(undefined2 *)(lVar1 + 0x3bf08) = 0x100;
  *(void* *)(lVar1 + 0x3f410) = 0;
  *(void* *)(lVar1 + 0x3f418) = 0;
  *(uint32_t *)(lVar1 + 0x3f440) = 0;
  *(void* *)(lVar1 + 0x3f448) = 0;
  *(undefined2 *)(lVar1 + 0x3f450) = 0x100;
  *(void* *)(lVar1 + 0x42958) = 0;
  *(void* *)(lVar1 + 0x42960) = 0;
  *(uint32_t *)(lVar1 + 0x42988) = 0;
  *(void* *)(lVar1 + 0x42990) = 0;
  *(undefined2 *)(lVar1 + 0x42998) = 0x100;
  *(void* *)(lVar1 + 0x45ea0) = 0;
  *(void* *)(lVar1 + 0x45ea8) = 0;
  *(uint32_t *)(lVar1 + 0x45ed0) = 0;
  *(void* *)(lVar1 + 0x45ed8) = 0;
  *(undefined2 *)(lVar1 + 0x45ee0) = 0x100;
  return;
}



void* * FUN_18006e460(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809ff488;
  if ((param_2 & 1) != 0) {
    free(param_1,0x58);
  }
  return param_1;
}




// 函数: void FUN_18006e4a0(long long *param_1)
void FUN_18006e4a0(long long *param_1)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  
  puVar3 = (void* *)*param_1;
  if (puVar3 != (void* *)0x0) {
    if ((void* *)puVar3[3] != (void* *)0x0) {
      *(void* *)puVar3[3] = 0;
    }
    (**(code **)*puVar3)(puVar3,0);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  if ((param_1[6] != 0) && (*(long long *)(param_1[6] + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = param_1[5];
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x3541);
    lVar4 = *(long long *)(lVar4 + 0x3538);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = (void* *)param_1[3];
  if (puVar3 == (void* *)0x0) {
    return;
  }
  uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
  if (uVar5 != 0) {
    lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
    lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
    if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
      *puVar3 = *(void* *)(lVar4 + 0x20);
      *(void* **)(lVar4 + 0x20) = puVar3;
      piVar1 = (int *)(lVar4 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                          puVar3,uVar5,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18006e4a4(long long *param_1)
void FUN_18006e4a4(long long *param_1)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  
  puVar3 = (void* *)*param_1;
  if (puVar3 != (void* *)0x0) {
    if ((void* *)puVar3[3] != (void* *)0x0) {
      *(void* *)puVar3[3] = 0;
    }
    (**(code **)*puVar3)(puVar3,0);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  if ((param_1[6] != 0) && (*(long long *)(param_1[6] + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = param_1[5];
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x3541);
    lVar4 = *(long long *)(lVar4 + 0x3538);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = (void* *)param_1[3];
  if (puVar3 == (void* *)0x0) {
    return;
  }
  uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
  if (uVar5 != 0) {
    lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
    lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
    if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
      *puVar3 = *(void* *)(lVar4 + 0x20);
      *(void* **)(lVar4 + 0x20) = puVar3;
      piVar1 = (int *)(lVar4 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                          puVar3,uVar5,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18006e4b9(void)
void FUN_18006e4b9(void)

{
  void* *unaff_RBX;
  
  if ((void* *)unaff_RBX[3] != (void* *)0x0) {
    *(void* *)unaff_RBX[3] = 0;
  }
  (**(code **)*unaff_RBX)();
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18006e50f(void)
void FUN_18006e50f(void)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  long long unaff_RSI;
  ulong long uVar5;
  
  if ((*(long long *)(unaff_RSI + 0x30) != 0) &&
     (*(long long *)(*(long long *)(unaff_RSI + 0x30) + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = *(long long *)(unaff_RSI + 0x28);
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x3541);
    lVar4 = *(long long *)(lVar4 + 0x3538);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = *(void* **)(unaff_RSI + 0x18);
  if (puVar3 != (void* *)0x0) {
    uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
    if (uVar5 != 0) {
      lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
      lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
      if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
        *puVar3 = *(void* *)(lVar4 + 0x20);
        *(void* **)(lVar4 + 0x20) = puVar3;
        piVar1 = (int *)(lVar4 + 0x18);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
          FUN_18064d630();
          return;
        }
      }
      else {
        func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                            puVar3,uVar5,0xfffffffffffffffe);
      }
    }
    return;
  }
  return;
}




// 函数: void FUN_18006e570(void* *param_1)
void FUN_18006e570(void* *param_1)

{
  int *piVar1;
  long long lVar2;
  ulong long uVar3;
  
  uVar3 = (ulong long)param_1 & 0xffffffffffc00000;
  if (uVar3 != 0) {
    lVar2 = uVar3 + 0x80 + ((long long)param_1 - uVar3 >> 0x10) * 0x50;
    lVar2 = lVar2 - (ulong long)*(uint *)(lVar2 + 4);
    if ((*(void ***)(uVar3 + 0x70) == &ExceptionList) && (*(char *)(lVar2 + 0xe) == '\0')) {
      *param_1 = *(void* *)(lVar2 + 0x20);
      *(void* **)(lVar2 + 0x20) = param_1;
      piVar1 = (int *)(lVar2 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar3,CONCAT71(0xff000000,*(void ***)(uVar3 + 0x70) == &ExceptionList),
                          param_1,uVar3,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18006e580(long long *param_1)
void FUN_18006e580(long long *param_1)

{
  int *piVar1;
  char *pcVar2;
  void* *puVar3;
  long long lVar4;
  ulong long uVar5;
  
  _Mtx_destroy_in_situ();
  _Cnd_destroy_in_situ();
  puVar3 = (void* *)*param_1;
  if (puVar3 != (void* *)0x0) {
    if ((void* *)puVar3[3] != (void* *)0x0) {
      *(void* *)puVar3[3] = 0;
    }
    (**(code **)*puVar3)(puVar3,0);
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar3);
  }
  if ((param_1[6] != 0) && (*(long long *)(param_1[6] + 0x10) != 0)) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lVar4 = param_1[5];
  while (lVar4 != 0) {
    pcVar2 = (char *)(lVar4 + 0x3541);
    lVar4 = *(long long *)(lVar4 + 0x3538);
    if (*pcVar2 != '\0') {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  puVar3 = (void* *)param_1[3];
  if (puVar3 == (void* *)0x0) {
    return;
  }
  uVar5 = (ulong long)puVar3 & 0xffffffffffc00000;
  if (uVar5 != 0) {
    lVar4 = uVar5 + 0x80 + ((long long)puVar3 - uVar5 >> 0x10) * 0x50;
    lVar4 = lVar4 - (ulong long)*(uint *)(lVar4 + 4);
    if ((*(void ***)(uVar5 + 0x70) == &ExceptionList) && (*(char *)(lVar4 + 0xe) == '\0')) {
      *puVar3 = *(void* *)(lVar4 + 0x20);
      *(void* **)(lVar4 + 0x20) = puVar3;
      piVar1 = (int *)(lVar4 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar5,CONCAT71(0xff000000,*(void ***)(uVar5 + 0x70) == &ExceptionList),
                          puVar3,uVar5,0xfffffffffffffffe);
    }
  }
  return;
}




// 函数: void FUN_18006e5d0(long long *param_1)
void FUN_18006e5d0(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x1a8) {
    FUN_180069530(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18006e640(long long *param_1)
void FUN_18006e640(long long *param_1)

{
  long long lVar1;
  long long lVar2;
  
  lVar1 = param_1[1];
  for (lVar2 = *param_1; lVar2 != lVar1; lVar2 = lVar2 + 0x1a8) {
    FUN_180069530(lVar2);
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



void* * FUN_18006e660(void* *param_1,void* param_2,void* param_3)

{
  ulong long uVar1;
  ulong long uVar2;
  ulong long uVar3;
  long long lVar4;
  void* *puVar5;
  void** systemRootNode;
  long long lVar7;
  
  FUN_180049830();
  *param_1 = &UNK_1809ff3f8;
  param_1[0x19] = 0;
  *(uint32_t *)(param_1 + 0x1a) = 0;
  param_1[0x1b] = 0;
  param_1[0x1e] = 0;
  puVar6 = param_1 + 0x24;
  lVar7 = 0x20;
  lVar4 = 0x20;
  puVar5 = puVar6;
  do {
    func_0x000180059bb0(puVar5);
    puVar5 = puVar5 + 2;
    lVar4 = lVar4 + -1;
  } while (lVar4 != 0);
  uVar2 = 0;
  *(void* *)((long long)param_1 + 0x324) = 0;
  *(uint32_t *)(param_1 + 100) = 0;
  param_1[0x20] = 0;
  param_1[0x21] = 0x20;
  param_1[0x22] = puVar6;
  do {
    *(uint32_t *)puVar6 = 0;
    puVar6 = puVar6 + 2;
    lVar7 = lVar7 + -1;
  } while (lVar7 != 0);
  param_1[0x23] = 0;
  param_1[0x1f] = param_1 + 0x21;
  param_1[0x1d] = 0x15;
  lVar4 = FUN_18006e140();
  param_1[0x1c] = lVar4;
  if (lVar4 == 0) {
    param_1[0x1d] = 0;
    uVar1 = uVar2;
  }
  else {
    uVar1 = param_1[0x1d];
  }
  uVar3 = uVar2;
  if (uVar1 != 0) {
    do {
      *(uint8_t *)(uVar2 + 0x3541 + param_1[0x1c]) = 0;
      uVar3 = uVar3 + 1;
      uVar2 = uVar2 + 0x3548;
    } while (uVar3 < (ulong long)param_1[0x1d]);
  }
  _Cnd_init_in_situ();
  _Mtx_init_in_situ(param_1 + 0x6f,2);
  param_1[0x79] = 0;
  param_1[0x7a] = 0;
  param_1[0x7b] = 0;
  *(uint32_t *)(param_1 + 0x7c) = 3;
  param_1[0x7e] = 0;
  *(uint32_t *)(param_1 + 0x7f) = 0;
  *(uint32_t *)((long long)param_1 + 0x3fc) = 4000;
  param_1[0x18] = param_2;
  param_1[0x7d] = param_3;
  *(uint8_t *)(param_1 + 0x80) = 0;
  return param_1;
}



uint32_t *
FUN_18006e870(uint32_t *param_1,void* param_2,void* param_3,void* param_4)

{
  uint32_t *puVar1;
  
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 3;
  *(void* *)(param_1 + 6) = 0;
  *(uint32_t **)param_1 = param_1;
  *(uint32_t **)(param_1 + 2) = param_1;
  _Mtx_init_in_situ(param_1 + 8,0x102,param_3,param_4,0xfffffffffffffffe);
  *(void* *)(param_1 + 0x1c) = 1;
  puVar1 = param_1 + 0x1e;
  *puVar1 = 0;
  param_1[0x1f] = 0;
  param_1[0x20] = 0;
  param_1[0x21] = 0;
  param_1[0x22] = 3;
  *(void* *)(param_1 + 0x24) = 0;
  *(uint32_t **)puVar1 = puVar1;
  *(uint32_t **)(param_1 + 0x20) = puVar1;
  _Mtx_init_in_situ(param_1 + 0x26,0x102);
  *(void* *)(param_1 + 0x3a) = 1;
  puVar1 = param_1 + 0x3c;
  *puVar1 = 0;
  param_1[0x3d] = 0;
  param_1[0x3e] = 0;
  param_1[0x3f] = 0;
  param_1[0x40] = 3;
  *(void* *)(param_1 + 0x42) = 0;
  *(uint32_t **)puVar1 = puVar1;
  *(uint32_t **)(param_1 + 0x3e) = puVar1;
  _Mtx_init_in_situ(param_1 + 0x44,0x102);
  *(void* *)(param_1 + 0x58) = 1;
  param_1[0x5a] = 0;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006e990(void)
void FUN_18006e990(void)

{
  long long lVar1;
  char cVar2;
  int memoryCompareResult;
  long long* systemMemoryPointer;
  
  lVar1 = _DAT_180c86948;
  FUN_18006f160(_DAT_180c86948);
  *(int *)(lVar1 + 0xec) = *(int *)(lVar1 + 0xec) + 1;
  iVar3 = _Mtx_lock(lVar1 + 0x98);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  plVar4 = *(long long **)(lVar1 + 0x78);
  if ((plVar4 != (long long *)(lVar1 + 0x78)) && (*(uint *)(plVar4 + 2) < *(uint *)(lVar1 + 0xec))) {
    plVar4 = *(long long **)(*plVar4 + 8);
    *(long long *)(*plVar4 + 8) = plVar4[1];
    *(long long *)plVar4[1] = *plVar4;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  iVar3 = _Mtx_unlock(lVar1 + 0x98);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  *(int *)(lVar1 + 0x164) = *(int *)(lVar1 + 0x164) + 1;
  iVar3 = _Mtx_lock(lVar1 + 0x110);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  plVar4 = *(long long **)(lVar1 + 0xf0);
  do {
    if (plVar4 == (long long *)(lVar1 + 0xf0)) {
LAB_18006f48d:
      iVar3 = _Mtx_unlock(lVar1 + 0x110);
      if (iVar3 != 0) {
        __Throw_C_error_std__YAXH_Z(iVar3);
      }
      return;
    }
    cVar2 = (**(code **)(*(long long *)plVar4[3] + 0x40))();
    if (cVar2 != '\0') {
      if (*(uint *)(plVar4 + 2) < *(uint *)(lVar1 + 0x164)) {
        plVar4 = *(long long **)(*plVar4 + 8);
        *(long long *)(*plVar4 + 8) = plVar4[1];
        *(long long *)plVar4[1] = *plVar4;
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      goto LAB_18006f48d;
    }
    plVar4 = (long long *)*plVar4;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006eb30(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18006eb30(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  long long lVar2;
  int memoryCompareResult;
  
  lVar2 = _DAT_180c86948;
  FUN_18005e630(_DAT_180c82868,param_2,param_3,param_4,0xfffffffffffffffe);
  FUN_18006efc0(lVar2);
  iVar3 = _Mtx_lock(lVar2 + 0x98);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  if (*(long long *)(lVar2 + 0x90) != 0) {
    plVar1 = *(long long **)(**(long long **)(lVar2 + 0x78) + 8);
    *(long long *)(*plVar1 + 8) = plVar1[1];
    *(long long *)plVar1[1] = *plVar1;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  iVar3 = _Mtx_unlock(lVar2 + 0x98);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  iVar3 = _Mtx_lock(lVar2 + 0x110);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  if (*(long long *)(lVar2 + 0x108) != 0) {
    plVar1 = *(long long **)(**(long long **)(lVar2 + 0xf0) + 8);
    *(long long *)(*plVar1 + 8) = plVar1[1];
    *(long long *)plVar1[1] = *plVar1;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  iVar3 = _Mtx_unlock(lVar2 + 0x110);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18006edf0(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_18006edf0(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long lVar1;
  int iVar2;
  long long lVar3;
  int iVar4;
  long long *plVar5;
  long long lVar6;
  void* uVar7;
  uint32_t uStack_1c;
  uint32_t uStack_18;
  uint32_t uStack_14;
  uint7 uStack_f;
  
  lVar3 = _DAT_180c86948;
  uVar7 = 0xfffffffffffffffe;
  if (_DAT_180c86948 != 0) {
    lVar6 = _DAT_180c86948 + 0xf0;
    lVar1 = _DAT_180c86948 + 0x110;
    iVar4 = _Mtx_lock(lVar1);
    if (iVar4 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar4);
    }
    iVar4 = *(int *)(lVar3 + 0x164);
    iVar2 = *(int *)(lVar3 + 0x160);
    plVar5 = (long long *)
             CreateSystemThreadObject(_DAT_180c8ed18,0x28,*(uint8_t *)(lVar3 + 0x100),param_4,uVar7);
    uStack_18 = (uint32_t)param_1;
    uStack_14 = (uint32_t)((ulong long)param_1 >> 0x20);
    *(int *)(plVar5 + 2) = iVar4 + iVar2;
    *(uint32_t *)((long long)plVar5 + 0x14) = uStack_1c;
    *(uint32_t *)(plVar5 + 3) = uStack_18;
    *(uint32_t *)((long long)plVar5 + 0x1c) = uStack_14;
    plVar5[4] = (ulong long)uStack_f << 8;
    *plVar5 = lVar6;
    plVar5[1] = *(long long *)(lVar3 + 0xf8);
    **(long long **)(lVar3 + 0xf8) = (long long)plVar5;
    *(long long **)(lVar3 + 0xf8) = plVar5;
    *(long long *)(lVar3 + 0x108) = *(long long *)(lVar3 + 0x108) + 1;
    iVar4 = _Mtx_unlock(lVar1);
    if (iVar4 != 0) {
      __Throw_C_error_std__YAXH_Z(iVar4);
    }
  }
  return;
}



void* FUN_18006eec0(long long param_1)

{
  void* uVar1;
  int iVar2;
  
  iVar2 = _Mtx_lock(param_1 + 0x20);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  uVar1 = *(void* *)(param_1 + 0x18);
  iVar2 = _Mtx_unlock(param_1 + 0x20);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  return uVar1;
}




// 函数: void FUN_18006ef20(long long *param_1)
void FUN_18006ef20(long long *param_1)

{
  _Mtx_destroy_in_situ();
  if ((long long *)*param_1 != param_1) {
                    // WARNING: Subroutine does not return
    FUN_18064e900((long long *)*param_1);
  }
  return;
}




// 函数: void FUN_18006ef80(long long *param_1)
void FUN_18006ef80(long long *param_1)

{
  if ((long long *)*param_1 != param_1) {
                    // WARNING: Subroutine does not return
    FUN_18064e900((long long *)*param_1);
  }
  return;
}




// 函数: void FUN_18006efc0(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18006efc0(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  int iVar2;
  
  iVar2 = _Mtx_lock(param_1 + 4,param_2,param_3,param_4,0xfffffffffffffffe);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  if (param_1[3] != 0) {
    plVar1 = *(long long **)(*(long long *)*param_1 + 8);
    *(long long *)(*plVar1 + 8) = plVar1[1];
    *(long long *)plVar1[1] = *plVar1;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  iVar2 = _Mtx_unlock(param_1 + 4);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  return;
}




// 函数: void FUN_18006f160(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18006f160(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  int iVar2;
  
  *(int *)((long long)param_1 + 0x74) = *(int *)((long long)param_1 + 0x74) + 1;
  iVar2 = _Mtx_lock(param_1 + 4,param_2,param_3,param_4,0xfffffffffffffffe);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  plVar1 = (long long *)*param_1;
  if ((plVar1 != param_1) && (*(uint *)(plVar1 + 2) < *(uint *)((long long)param_1 + 0x74))) {
    plVar1 = *(long long **)(*plVar1 + 8);
    *(long long *)(*plVar1 + 8) = plVar1[1];
    *(long long *)plVar1[1] = *plVar1;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  iVar2 = _Mtx_unlock(param_1 + 4);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  return;
}




// 函数: void FUN_18006f310(long long *param_1)
void FUN_18006f310(long long *param_1)

{
  if ((long long *)*param_1 != param_1) {
                    // WARNING: Subroutine does not return
    FUN_18064e900((long long *)*param_1);
  }
  return;
}




// 函数: void FUN_18006f340(long long *param_1)
void FUN_18006f340(long long *param_1)

{
  char systemNodeFlag;
  int iVar2;
  long long *plVar3;
  
  *(int *)((long long)param_1 + 0x74) = *(int *)((long long)param_1 + 0x74) + 1;
  iVar2 = _Mtx_lock(param_1 + 4);
  if (iVar2 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar2);
  }
  plVar3 = (long long *)*param_1;
  do {
    if (plVar3 == param_1) {
LAB_18006f48d:
      iVar2 = _Mtx_unlock(param_1 + 4);
      if (iVar2 != 0) {
        __Throw_C_error_std__YAXH_Z(iVar2);
      }
      return;
    }
    cVar1 = (**(code **)(*(long long *)plVar3[3] + 0x40))();
    if (cVar1 != '\0') {
      if (*(uint *)(plVar3 + 2) < *(uint *)((long long)param_1 + 0x74)) {
        plVar3 = *(long long **)(*plVar3 + 8);
        *(long long *)(*plVar3 + 8) = plVar3[1];
        *(long long *)plVar3[1] = *plVar3;
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      goto LAB_18006f48d;
    }
    plVar3 = (long long *)*plVar3;
  } while( true );
}




// 函数: void ExecuteSystemEntryPoint(void* *entryPointPtr)
/**
 * @brief 执行系统入口点
 * 
 * 该函数负责执行系统的入口点函数。它会检查入口点指针是否有效，
 * 如果有效则调用相应的函数指针，并处理运行时类型转换。
 * 
 * @param entryPointPtr 入口点指针，指向要执行的函数
 */
void ExecuteSystemEntryPoint(void* *entryPointPtr)

{
  long long runtimeCastResult;
  
  if (entryPointPtr != (void* *)0x0) {
    runtimeCastResult = __RTCastToVoid();
    (**(code **)*entryPointPtr)(entryPointPtr,0);
    if (runtimeCastResult != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(runtimeCastResult);
    }
  }
  return;
}




// 函数: void FUN_18006f4cd(void)
void FUN_18006f4cd(void)

{
  long long lVar1;
  void* *unaff_RBX;
  
  lVar1 = __RTCastToVoid();
  (**(code **)*unaff_RBX)();
  if (lVar1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar1);
  }
  return;
}




// 函数: void FUN_18006f4fc(void)
void FUN_18006f4fc(void)

{
  return;
}




// 函数: void FUN_18006f500(long long param_1)
void FUN_18006f500(long long param_1)

{
  if (*(long long **)(param_1 + 0x70) != (long long *)0x0) {
    (**(code **)(**(long long **)(param_1 + 0x70) + 0x38))();
  }
  return;
}




// 函数: void FUN_18006f530(long long param_1)
void FUN_18006f530(long long param_1)

{
  if (*(long long *)(param_1 + 0x1d8) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (*(long long **)(param_1 + 0x1b8) != (long long *)0x0) {
    (**(code **)(**(long long **)(param_1 + 0x1b8) + 0x38))();
  }
  return;
}



void* *
FUN_18006f590(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  if (DAT_180c8aa69 == '\0') {
    *param_1 = &SystemMemoryAllocatorReference;
    param_1[1] = 0;
    *(uint32_t *)(param_1 + 2) = 0;
    *param_1 = &SystemGlobalDataReference;
    param_1[3] = 0;
    param_1[1] = 0;
    *(uint32_t *)(param_1 + 2) = 0;
    FUN_1806277c0(param_1,0,param_3,param_4,0,0xfffffffffffffffe);
    *(uint32_t *)(param_1 + 2) = 0;
    if ((uint8_t *)param_1[1] != (uint8_t *)0x0) {
      *(uint8_t *)param_1[1] = 0;
    }
  }
  else {
    FUN_1802265d0(param_1,param_1);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18006f620(void* param_1,void* param_2)

{
  code *pcVar1;
  bool bVar2;
  long long lVar3;
  char cVar4;
  int iVar5;
  int iVar6;
  ulong long uVar7;
  undefined *puVar8;
  bool bVar9;
  undefined *puStack_50;
  undefined *puStack_48;
  uint32_t uStack_40;
  void* uStack_38;
  uint8_t auStack_30 [8];
  undefined *puStack_28;
  
  lVar3 = _DAT_180c82868;
  uVar7 = FUN_1800f9600(param_2);
  if (((char)uVar7 != '\0') || (uVar7 = WaitForSingleObject(SystemSemaphoreHandle,0), (int)uVar7 != 0)) {
    return uVar7 & 0xffffffffffffff00;
  }
  if (lVar3 != 0) {
    FUN_18005dab0(lVar3);
  }
  bVar9 = true;
  cVar4 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  if ((cVar4 == '\0') && (iVar5 = IsDebuggerPresent(), iVar5 != 0)) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  if (lVar3 != 0) {
    iVar5 = *(int *)(**(long long **)(lVar3 + 8) + 0x48);
    iVar6 = _Thrd_id();
    bVar9 = iVar6 == iVar5;
  }
  FUN_1800f9ce0(auStack_30,0);
  puStack_50 = &SystemGlobalDataReference;
  uStack_38 = 0;
  puStack_48 = (undefined *)0x0;
  uStack_40 = 0;
  FUN_180628040(&puStack_50,&UNK_1809ff538,param_2);
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff550);
  puVar8 = &SystemStringTemplate;
  if (puStack_48 != (undefined *)0x0) {
    puVar8 = puStack_48;
  }
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff5b0,puVar8);
  puVar8 = &SystemStringTemplate;
  if (puStack_28 != (undefined *)0x0) {
    puVar8 = puStack_28;
  }
  FUN_1800623b0(_DAT_180c86928,5,0xffffffff00000000,3,puVar8);
  FUN_1800623e0();
  puVar8 = &SystemStringTemplate;
  if (puStack_48 != (undefined *)0x0) {
    puVar8 = puStack_48;
  }
  OutputDebugStringA(puVar8);
  FUN_18004c2b0(param_2);
  lVar3 = _DAT_180c86950;
  if (((bVar9) && (_DAT_180c86950 != 0)) && (*(char *)(_DAT_180c86950 + 0x1609) != '\x01')) {
    FUN_1801723a0(*(void* *)(_DAT_180c86870 + 8),*(char *)(_DAT_180c868d0 + 0x2028) != '\0',
                  *(uint32_t *)(_DAT_180c86950 + 0x160c));
    *(uint8_t *)(lVar3 + 0x1609) = 1;
  }
  if (DAT_180c82842 == '\0') {
    if ((DAT_180c82860 == '\0') ||
       ((iVar5 = IsDebuggerPresent(), iVar5 != 0 && (DAT_180c82842 == '\0')))) {
      MessageBoxA(0,param_2,&UNK_1809ff5b8,0x41010);
    }
    else if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
      FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd,&UNK_180a04f08,&UNK_1809ff5b8,param_2);
    }
  }
  else if (DAT_180c82860 == '\0') {
    puVar8 = &SystemStringTemplate;
    if (puStack_48 != (undefined *)0x0) {
      puVar8 = puStack_48;
    }
    FUN_1806272a0(puVar8);
  }
  iVar5 = FUN_1800f98e0(param_2);
  if ((!bVar2) && (iVar5 == 0)) {
    FUN_180066320();
  }
  FUN_1800f96b0(param_2,0);
  if (_DAT_180c86870 == 0) {
    _Exit(5);
    pcVar1 = (code *)swi(3);
    uVar7 = (*pcVar1)();
    return uVar7;
  }
  FUN_180055f70();
  pcVar1 = (code *)swi(3);
  uVar7 = (*pcVar1)();
  return uVar7;
}



// WARNING: Removing unreachable block (ram,0x00018006fc4b)
// WARNING: Removing unreachable block (ram,0x00018006fc66)
// WARNING: Removing unreachable block (ram,0x00018006fc6b)
// WARNING: Removing unreachable block (ram,0x00018006fe26)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18006f940(void* param_1,void* param_2,char param_3)

{
  uint8_t uVar1;
  code *pcVar2;
  bool bVar3;
  long long lVar4;
  undefined *puVar5;
  char cVar6;
  int iVar7;
  int iVar8;
  uint32_t uVar9;
  ulong long in_RAX;
  long long lVar10;
  undefined *puVar11;
  ulong long uVar12;
  void* uVar13;
  void* *puVar14;
  bool bVar15;
  byte bStackX_20;
  undefined *puStack_e0;
  void* *puStack_d8;
  uint32_t uStack_d0;
  ulong long uStack_c8;
  undefined *puStack_c0;
  undefined *puStack_b8;
  uint32_t uStack_b0;
  void* uStack_a8;
  undefined *stackParameterA;
  undefined *stackParameterB;
  uint32_t stackParameterC;
  ulong long uStack_88;
  undefined *puStack_80;
  long long lStack_78;
  uint32_t uStack_68;
  void* uStack_40;
  
  lVar4 = _DAT_180c82868;
  uStack_40 = 0xfffffffffffffffe;
  bStackX_20 = 0;
  if (((DAT_180c82860 == '\0') || (in_RAX = FUN_1800f9600(param_2), (char)in_RAX != '\0')) ||
     (in_RAX = WaitForSingleObject(SystemSemaphoreHandle,0), (int)in_RAX != 0)) {
    uVar12 = in_RAX & 0xffffffffffffff00;
  }
  else {
    if (lVar4 != 0) {
      FUN_18005dab0(lVar4);
    }
    bVar15 = true;
    cVar6 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
    if ((cVar6 == '\0') && (iVar7 = IsDebuggerPresent(), iVar7 != 0)) {
      bVar3 = true;
    }
    else {
      bVar3 = false;
    }
    if (lVar4 != 0) {
      iVar7 = *(int *)(**(long long **)(lVar4 + 8) + 0x48);
      iVar8 = _Thrd_id();
      bVar15 = iVar8 == iVar7;
    }
    puStack_c0 = &SystemGlobalDataReference;
    uStack_a8 = 0;
    puStack_b8 = (undefined *)0x0;
    uStack_b0 = 0;
    if (!bVar3) {
      lVar10 = FUN_1800f9ce0(&puStack_e0,0);
      uStack_b0 = *(uint32_t *)(lVar10 + 0x10);
      puStack_b8 = *(undefined **)(lVar10 + 8);
      uStack_a8 = *(void* *)(lVar10 + 0x18);
      *(uint32_t *)(lVar10 + 0x10) = 0;
      *(void* *)(lVar10 + 8) = 0;
      *(void* *)(lVar10 + 0x18) = 0;
      puStack_e0 = &SystemGlobalDataReference;
      if (puStack_d8 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      puStack_d8 = (void* *)0x0;
      uStack_c8 = uStack_c8 & 0xffffffff00000000;
      puStack_e0 = &SystemMemoryAllocatorReference;
    }
    puVar5 = puStack_b8;
    stackParameterA = &SystemGlobalDataReference;
    uStack_88 = 0;
    stackParameterB = (undefined *)0x0;
    stackParameterC = 0;
    FUN_180628040(&stackParameterA,&UNK_1809ff5c0,param_2);
    FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff550);
    puVar11 = &SystemStringTemplate;
    if (stackParameterB != (undefined *)0x0) {
      puVar11 = stackParameterB;
    }
    FUN_180062380(_DAT_180c86928,2,0xffffffff00000000,&UNK_1809ff5b0,puVar11);
    puVar11 = &SystemStringTemplate;
    if (puVar5 != (undefined *)0x0) {
      puVar11 = puVar5;
    }
    FUN_1800623b0(_DAT_180c86928,2,0xffffffff00000000,3,puVar11);
    FUN_1800623e0();
    puVar11 = &SystemStringTemplate;
    if (stackParameterB != (undefined *)0x0) {
      puVar11 = stackParameterB;
    }
    OutputDebugStringA(puVar11);
    FUN_18004c2b0(param_2);
    if (((DAT_180c82860 != '\0') && (bVar3)) &&
       ((*(char *)(_DAT_180c86870 + 0x25) != '\0' ||
        ((param_3 == '\0' || (*(int *)(_DAT_180c86870 + 0x340) == 2)))))) {
      if (DAT_180c82851 == '\0') {
        pcVar2 = (code *)swi(3);
        uVar12 = (*pcVar2)();
        return uVar12;
      }
      bStackX_20 = 1;
    }
    if (DAT_180c82842 == '\0') {
      if (bVar15) {
        if (*(long long *)(_DAT_180c86870 + 8) != 0) {
          FUN_1801719d0(*(long long *)(_DAT_180c86870 + 8));
        }
        lVar4 = _DAT_180c86950;
        if ((_DAT_180c86950 != 0) && (*(char *)(_DAT_180c86950 + 0x1609) != '\x01')) {
          FUN_1801723a0(*(void* *)(_DAT_180c86870 + 8),
                        *(char *)(_DAT_180c868d0 + 0x2028) != '\0',
                        *(uint32_t *)(_DAT_180c86950 + 0x160c));
          *(uint8_t *)(lVar4 + 0x1609) = 1;
        }
      }
      puStack_e0 = &SystemGlobalDataReference;
      uStack_c8 = 0;
      puStack_d8 = (void* *)0x0;
      uStack_d0 = 0;
      puVar14 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
      *(uint8_t *)puVar14 = 0;
      puStack_d8 = puVar14;
      uVar9 = StartSystemThread(puVar14);
      uStack_c8 = CONCAT44(uStack_c8._4_4_,uVar9);
      *puVar14 = 0x4e524157204c4752;
      *(uint32_t *)(puVar14 + 1) = 0x474e49;
      uStack_d0 = 0xb;
      if (((DAT_180c82860 == '\0') || (iVar7 = IsDebuggerPresent(), iVar7 != 0)) &&
         (DAT_180c82842 == '\0')) {
        MessageBoxA(0,param_2,puVar14,0x41030);
      }
      else if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
        FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd,&UNK_180a04f08,puVar14,param_2);
      }
      puStack_e0 = &SystemGlobalDataReference;
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar14);
    }
    if (DAT_180c82860 == '\0') {
      FUN_1806272a0(&UNK_1809ff5d0,param_2);
    }
    iVar7 = FUN_1800f98e0(param_2);
    if (((!bVar3) && (iVar7 == 0)) && (*(char *)(_DAT_180c86870 + 0x2a) != '\0')) {
      uVar1 = *(uint8_t *)(_DAT_180c86870 + 0x141);
      uVar13 = FUN_180627ae0(&puStack_80,_DAT_180c86870 + 0x148);
      uVar13 = FUN_180627ae0(&puStack_e0,uVar13);
      puStack_80 = &SystemGlobalDataReference;
      if (lStack_78 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lStack_78 = 0;
      uStack_68 = 0;
      puStack_80 = &SystemMemoryAllocatorReference;
      puVar11 = &SystemStringTemplate;
      if (puVar5 != (undefined *)0x0) {
        puVar11 = puVar5;
      }
      FUN_180066320(uVar13,&puStack_e0,uVar1,0,puVar11);
      puStack_e0 = &SystemGlobalDataReference;
      if (puStack_d8 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      puStack_d8 = (void* *)0x0;
      uStack_c8 = uStack_c8 & 0xffffffff00000000;
      puStack_e0 = &SystemMemoryAllocatorReference;
    }
    FUN_1800f96b0(param_2,0);
    if (_DAT_180c86870 == 0) {
      cVar6 = '\x01';
    }
    else {
      cVar6 = *(char *)(_DAT_180c86870 + 0x29);
    }
    if (*(char *)(_DAT_180c86870 + 0x25) != '\0') {
      FUN_180055f70(_DAT_180c86870,5);
      pcVar2 = (code *)swi(3);
      uVar12 = (*pcVar2)();
      return uVar12;
    }
    if (cVar6 != '\0') {
      _DAT_180c82854 = 5;
    }
    if ((DAT_180c82842 == '\0') && (bVar15)) {
      if (*(long long *)(_DAT_180c86870 + 8) != 0) {
        FUN_1801718f0();
      }
      if (_DAT_180c86950 != 0) {
        FUN_180092940(_DAT_180c86950,*(uint8_t *)(_DAT_180c86950 + 0x160a));
      }
    }
    if (lVar4 != 0) {
      FUN_18005db30(lVar4);
    }
    do {
      iVar7 = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (iVar7 == 0);
    stackParameterA = &SystemGlobalDataReference;
    if (stackParameterB != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    stackParameterB = (undefined *)0x0;
    uStack_88 = uStack_88 & 0xffffffff00000000;
    stackParameterA = &SystemMemoryAllocatorReference;
    puStack_c0 = &SystemGlobalDataReference;
    if (puVar5 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar5);
    }
    uVar12 = (ulong long)bStackX_20;
  }
  return uVar12;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18006ff80(void* param_1,void* param_2,char param_3)

{
  code *pcVar1;
  long long lVar2;
  char cVar3;
  int iVar4;
  int iVar5;
  uint8_t *puVar6;
  long long lVar7;
  undefined **ppuVar8;
  void* *puVar9;
  undefined *puVar10;
  ulong long uVar11;
  undefined *puVar12;
  uint8_t uVar13;
  bool bVar14;
  bool bVar15;
  uint32_t uVar16;
  byte bStack_d8;
  undefined *puStack_b0;
  undefined *puStack_a8;
  uint32_t uStack_a0;
  ulong long uStack_98;
  undefined *pstackParameterC;
  void* *puStack_88;
  uint32_t uStack_80;
  ulong long uStack_78;
  undefined *puStack_70;
  long long lStack_68;
  uint32_t uStack_58;
  undefined *puStack_50;
  long long lStack_48;
  uint32_t uStack_38;
  void* uStack_30;
  
  lVar2 = _DAT_180c82868;
  uStack_30 = 0xfffffffffffffffe;
  bStack_d8 = 0;
  puVar6 = (uint8_t *)register0x00000020;
  if (((DAT_180c82860 == '\0') ||
      (puVar6 = (uint8_t *)FUN_1800f9600(param_2), (char)puVar6 != '\0')) ||
     (puVar6 = (uint8_t *)WaitForSingleObject(SystemSemaphoreHandle,0), (int)puVar6 != 0)) {
    return (ulong long)puVar6 & 0xffffffffffffff00;
  }
  if (lVar2 != 0) {
    FUN_18005dab0(lVar2);
  }
  bVar14 = true;
  cVar3 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  if ((cVar3 == '\0') && (iVar4 = IsDebuggerPresent(), iVar4 != 0)) {
    bVar15 = true;
  }
  else {
    bVar15 = false;
  }
  if (lVar2 != 0) {
    iVar4 = *(int *)(**(long long **)(lVar2 + 8) + 0x48);
    iVar5 = _Thrd_id();
    bVar14 = iVar5 == iVar4;
  }
  puVar12 = (undefined *)0x0;
  if (!bVar15) {
    lVar7 = FUN_1800f9ce0(&puStack_70,0);
    puVar12 = *(undefined **)(lVar7 + 8);
    *(uint32_t *)(lVar7 + 0x10) = 0;
    *(void* *)(lVar7 + 8) = 0;
    *(void* *)(lVar7 + 0x18) = 0;
    puStack_70 = &SystemGlobalDataReference;
    if (lStack_68 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_68 = 0;
    uStack_58 = 0;
    puStack_70 = &SystemMemoryAllocatorReference;
  }
  puStack_b0 = &SystemGlobalDataReference;
  uStack_98 = 0;
  puStack_a8 = (undefined *)0x0;
  uStack_a0 = 0;
  FUN_180628040(&puStack_b0,&UNK_1809ff5f8,param_2);
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff550);
  puVar10 = &SystemStringTemplate;
  if (puStack_a8 != (undefined *)0x0) {
    puVar10 = puStack_a8;
  }
  FUN_180062380(_DAT_180c86928,2,0xffffffff00000000,&UNK_1809ff5b0,puVar10);
  if (DAT_180bf0100 != '\0') {
    puVar10 = &SystemStringTemplate;
    if (puVar12 != (undefined *)0x0) {
      puVar10 = puVar12;
    }
    FUN_1800623b0(_DAT_180c86928,2,0xffffffff00000000,3,puVar10);
  }
  FUN_1800623e0();
  puVar10 = &SystemStringTemplate;
  if (puStack_a8 != (undefined *)0x0) {
    puVar10 = puStack_a8;
  }
  OutputDebugStringA(puVar10);
  FUN_18004c2b0(param_2);
  if ((DAT_180c82860 != '\0') && (bVar15)) {
    if ((*(char *)(_DAT_180c86870 + 0x25) == '\0') &&
       ((param_3 != '\0' && (*(int *)(_DAT_180c86870 + 0x340) != 2)))) {
      uVar11 = 1;
      bStack_d8 = 1;
      goto LAB_180070230;
    }
    if (DAT_180c82851 == '\0') {
      pcVar1 = (code *)swi(3);
      uVar11 = (*pcVar1)();
      return uVar11;
    }
  }
  uVar11 = 0;
LAB_180070230:
  if (*(int *)(_DAT_180c86908 + 0x460) == 0) {
    if (DAT_180c82842 == '\0') {
      if (bVar14) {
        if (*(long long *)(_DAT_180c86870 + 8) != 0) {
          FUN_1801719d0(*(long long *)(_DAT_180c86870 + 8));
        }
        lVar7 = _DAT_180c86950;
        if ((_DAT_180c86950 != 0) && (*(char *)(_DAT_180c86950 + 0x1609) != '\x01')) {
          FUN_1801723a0(*(void* *)(_DAT_180c86870 + 8),
                        *(char *)(_DAT_180c868d0 + 0x2028) != '\0',
                        *(uint32_t *)(_DAT_180c86950 + 0x160c));
          *(uint8_t *)(lVar7 + 0x1609) = 1;
        }
      }
      if (((DAT_180c82860 == '\0') || (iVar4 = IsDebuggerPresent(), iVar4 != 0)) &&
         (DAT_180c82842 == '\0')) {
        MessageBoxA(0,param_2,&UNK_1809ff630,0x41030);
      }
      else if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
        FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd,&UNK_180a04f08,&UNK_1809ff630,param_2)
        ;
      }
    }
    else if (DAT_180c82860 == '\0') {
      FUN_1806272a0(&UNK_1809ff610,param_2);
    }
    iVar4 = FUN_1800f98e0(param_2);
    if ((!bVar15) && (iVar4 == 0)) {
      bVar15 = _DAT_180c86870 == 0;
      if (bVar15) {
        uVar13 = 0;
        pstackParameterC = &SystemGlobalDataReference;
        uStack_78 = 0;
        puStack_88 = (void* *)0x0;
        uStack_80 = 0;
        puVar9 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x34,0x13);
        *(uint8_t *)puVar9 = 0;
        puStack_88 = puVar9;
        uVar16 = StartSystemThread(puVar9);
        uStack_78 = CONCAT44(uStack_78._4_4_,uVar16);
        *puVar9 = 0x7270706d75645c5c;
        puVar9[1] = 0x2e726f737365636f;
        puVar9[2] = 0x6c726f77656c6174;
        puVar9[3] = 0x445c6d6f632e7364;
        *(uint32_t *)(puVar9 + 4) = 0x50706d75;
        *(uint32_t *)((long long)puVar9 + 0x24) = 0x65636f72;
        *(uint32_t *)(puVar9 + 5) = 0x6e697373;
        *(uint32_t *)((long long)puVar9 + 0x2c) = 0x6c6f4667;
        *(uint32_t *)(puVar9 + 6) = 0x726564;
        uStack_80 = 0x33;
        ppuVar8 = &pstackParameterC;
      }
      else {
        uVar13 = *(uint8_t *)(_DAT_180c86870 + 0x141);
        ppuVar8 = (undefined **)FUN_180627ae0(&puStack_50,_DAT_180c86870 + 0x148);
        puVar9 = puStack_88;
      }
      uVar16 = FUN_180627ae0(&puStack_70,ppuVar8);
      if (bVar15) {
        pstackParameterC = &SystemGlobalDataReference;
        if (puVar9 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(puVar9);
        }
        puStack_88 = (void* *)0x0;
        uStack_78 = uStack_78 & 0xffffffff00000000;
        pstackParameterC = &SystemMemoryAllocatorReference;
      }
      if (!bVar15) {
        puStack_50 = &SystemGlobalDataReference;
        if (lStack_48 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        lStack_48 = 0;
        uStack_38 = 0;
        puStack_50 = &SystemMemoryAllocatorReference;
      }
      puVar10 = &SystemStringTemplate;
      if (puVar12 != (undefined *)0x0) {
        puVar10 = puVar12;
      }
      FUN_180066320(uVar16,&puStack_70,uVar13,0,puVar10);
      puStack_70 = &SystemGlobalDataReference;
      if (lStack_68 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lStack_68 = 0;
      uStack_58 = 0;
      puStack_70 = &SystemMemoryAllocatorReference;
    }
    FUN_1800f96b0(param_2,0);
    if (_DAT_180c86870 == 0) {
      cVar3 = '\x01';
    }
    else {
      cVar3 = *(char *)(_DAT_180c86870 + 0x29);
    }
    if (*(char *)(_DAT_180c86870 + 0x25) != '\0') {
      FUN_180055f70(_DAT_180c86870,5);
      pcVar1 = (code *)swi(3);
      uVar11 = (*pcVar1)();
      return uVar11;
    }
    if (cVar3 != '\0') {
      _DAT_180c82854 = 5;
    }
    if ((DAT_180c82842 == '\0') && (bVar14)) {
      if (*(long long *)(_DAT_180c86870 + 8) != 0) {
        FUN_1801718f0();
      }
      if (_DAT_180c86950 != 0) {
        FUN_180092940(_DAT_180c86950,*(uint8_t *)(_DAT_180c86950 + 0x160a));
      }
    }
    if (lVar2 != 0) {
      FUN_18005db30(lVar2);
    }
    do {
      iVar4 = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (iVar4 == 0);
    puStack_b0 = &SystemGlobalDataReference;
    if (puStack_a8 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_a8 = (undefined *)0x0;
    uStack_98 = uStack_98 & 0xffffffff00000000;
    puStack_b0 = &SystemMemoryAllocatorReference;
    if (puVar12 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar12);
    }
    uVar11 = (ulong long)bStack_d8;
  }
  else {
    if (*(int *)(_DAT_180c86908 + 0x460) == 1) {
      FUN_1806272a0(&UNK_1809ff610,param_2);
    }
    puStack_b0 = &SystemGlobalDataReference;
    if (puStack_a8 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_a8 = (undefined *)0x0;
    uStack_98 = uStack_98 & 0xffffffff00000000;
    puStack_b0 = &SystemMemoryAllocatorReference;
    if (puVar12 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar12);
    }
  }
  return uVar11;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180070680(void* param_1,void* param_2)
void FUN_180070680(void* param_1,void* param_2)

{
  bool bVar1;
  char cVar2;
  int memoryCompareResult;
  int iVar4;
  long long systemTimeValue;
  undefined *puVar6;
  void* uVar7;
  undefined *puVar8;
  bool bVar9;
  undefined *puStack_70;
  undefined *puStack_68;
  uint32_t uStack_60;
  void* uStack_58;
  undefined *puStack_50;
  long long lStack_48;
  uint32_t uStack_38;
  
  iVar3 = WaitForSingleObject(SystemSemaphoreHandle,0);
  if (iVar3 != 0) {
    return;
  }
  bVar9 = true;
  cVar2 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  if ((cVar2 == '\0') && (iVar3 = IsDebuggerPresent(), iVar3 != 0)) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  if (_DAT_180c82868 != 0) {
    iVar3 = *(int *)(**(long long **)(_DAT_180c82868 + 8) + 0x48);
    iVar4 = _Thrd_id();
    bVar9 = iVar4 == iVar3;
  }
  puVar8 = (undefined *)0x0;
  if (!bVar1) {
    lVar5 = FUN_1800f9ce0(&puStack_50,0);
    puVar8 = *(undefined **)(lVar5 + 8);
    *(uint32_t *)(lVar5 + 0x10) = 0;
    *(void* *)(lVar5 + 8) = 0;
    *(void* *)(lVar5 + 0x18) = 0;
    puStack_50 = &SystemGlobalDataReference;
    if (lStack_48 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_48 = 0;
    uStack_38 = 0;
    puStack_50 = &SystemMemoryAllocatorReference;
  }
  puStack_70 = &SystemGlobalDataReference;
  uStack_58 = 0;
  puStack_68 = (undefined *)0x0;
  uStack_60 = 0;
  FUN_180628040(&puStack_70,&UNK_1809ff538,param_2);
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff550);
  puVar6 = &SystemStringTemplate;
  if (puStack_68 != (undefined *)0x0) {
    puVar6 = puStack_68;
  }
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff5b0,puVar6);
  puVar6 = &SystemStringTemplate;
  if (puVar8 != (undefined *)0x0) {
    systemCurrentNode = systemNextNode;
  }
  FUN_1800623b0(_DAT_180c86928,5,0xffffffff00000000,3,puVar6);
  FUN_1800623e0();
  puVar8 = &SystemStringTemplate;
  if (puStack_68 != (undefined *)0x0) {
    puVar8 = puStack_68;
  }
  OutputDebugStringA(puVar8);
  lVar5 = _DAT_180c86950;
  if (((bVar9) && (_DAT_180c86950 != 0)) && (*(char *)(_DAT_180c86950 + 0x1609) != '\x01')) {
    FUN_1801723a0(*(void* *)(_DAT_180c86870 + 8),*(char *)(_DAT_180c868d0 + 0x2028) != '\0',
                  *(uint32_t *)(_DAT_180c86950 + 0x160c));
    *(uint8_t *)(lVar5 + 0x1609) = 1;
  }
  if (DAT_180c82842 == '\0') {
    FUN_1800f93e0();
  }
  else {
    uVar7 = func_0x0001800464d0(&puStack_70);
    FUN_1806272a0(uVar7);
  }
  FUN_180046130(&DAT_180c91900,1);
  _Exit(5);
  return;
}



// WARNING: Removing unreachable block (ram,0x000180070cdc)
// WARNING: Removing unreachable block (ram,0x000180070ce2)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180070930(void* param_1,long long param_2,uint32_t param_3,long long param_4,
void FUN_180070930(void* param_1,long long param_2,uint32_t param_3,long long param_4,
                  char param_5,char param_6)

{
  code *pcVar1;
  bool bVar2;
  char cVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  int iVar8;
  long long lVar9;
  uint8_t *puVar10;
  void* *puVar11;
  uint8_t *puVar12;
  byte bVar13;
  uint uVar14;
  long long lVar15;
  long long lVar16;
  undefined *puVar18;
  ulong long uVar19;
  uint8_t auStack_188 [32];
  uint8_t *puStack_168;
  undefined *puStack_160;
  uint8_t *puStack_158;
  uint8_t uStack_148;
  char cStack_147;
  undefined *puStack_140;
  uint8_t *puStack_138;
  uint uStack_130;
  ulong long uStack_128;
  char cStack_120;
  char cStack_11f;
  uint32_t uStack_11c;
  undefined *puStack_118;
  uint8_t *puStack_110;
  uint uStack_108;
  void* uStack_100;
  undefined *puStack_f8;
  undefined *puStack_f0;
  uint32_t uStack_e0;
  undefined *puStack_d8;
  long long lStack_d0;
  uint32_t uStack_c0;
  uint32_t uStack_98;
  uint32_t uStack_94;
  long long lStack_90;
  long long lStack_88;
  void* uStack_60;
  void* uStack_58;
  void* uStack_50;
  ulong long uStack_48;
  long long lVar17;
  
  uStack_60 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_188;
  cStack_120 = param_5;
  puVar10 = (uint8_t *)0x0;
  uVar14 = 0;
  uStack_11c = 0;
  uStack_148 = 0;
  uStack_58 = 0;
  uStack_50 = 0;
  uStack_98 = param_3;
  lStack_88 = param_4;
  FUN_1800634b0(&uStack_58,0x10,&UNK_1809fd0a0,param_3);
  lVar9 = FUN_180627910(&puStack_d8,param_4);
  puStack_118 = &SystemGlobalDataReference;
  uStack_100 = 0;
  puStack_110 = (uint8_t *)0x0;
  uStack_108 = 0;
  uStack_11c = 4;
  uVar6 = *(uint *)(lVar9 + 0x10);
  uVar19 = (ulong long)uVar6;
  uVar5 = 0;
  if (*(long long *)(lVar9 + 8) == 0) {
LAB_180070a3f:
    uVar14 = uVar5;
    if (uVar6 != 0) {
                    // WARNING: Subroutine does not return
      memcpy(puVar10,*(void* *)(lVar9 + 8),uVar19);
    }
  }
  else if (uVar6 != 0) {
    iVar4 = uVar6 + 1;
    if (iVar4 < 0x10) {
      iVar4 = 0x10;
    }
    puVar10 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar4,0x13);
    *puVar10 = 0;
    puStack_110 = puVar10;
    uVar5 = StartSystemThread(puVar10);
    uStack_100 = CONCAT44(uStack_100._4_4_,uVar5);
    goto LAB_180070a3f;
  }
  if (puVar10 != (uint8_t *)0x0) {
    puVar10[uVar19] = 0;
  }
  uVar5 = *(uint *)(lVar9 + 0x1c);
  uStack_108 = uVar6;
  uStack_100._4_4_ = uVar5;
  if (param_2 != 0) {
    lVar9 = -1;
    do {
      lVar15 = lVar9;
      lVar9 = lVar15 + 1;
    } while (*(char *)(param_2 + lVar9) != '\0');
    if (0 < (int)lVar9) {
      iVar4 = uVar6 + (int)lVar9;
      if (iVar4 != 0) {
        uVar6 = iVar4 + 1;
        if (puVar10 == (uint8_t *)0x0) {
          if ((int)uVar6 < 0x10) {
            uVar6 = 0x10;
          }
          puVar10 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar6,0x13);
          *puVar10 = 0;
        }
        else {
          if (uVar6 <= uVar14) goto LAB_180070b00;
          puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
          puVar10 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puVar10,uVar6,0x10);
        }
        puStack_110 = puVar10;
        uStack_100._0_4_ = StartSystemThread(puVar10);
      }
LAB_180070b00:
                    // WARNING: Subroutine does not return
      memcpy(puVar10 + uVar19,param_2,(long long)((int)lVar15 + 2));
    }
  }
  FUN_180627e10(&puStack_118,&puStack_f8,&uStack_58);
  uStack_94 = 0;
  uStack_11c = 0;
  puStack_118 = &SystemGlobalDataReference;
  if (puVar10 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar10);
  }
  puStack_110 = (uint8_t *)0x0;
  uStack_100 = (ulong long)uStack_100._4_4_ << 0x20;
  puStack_118 = &SystemMemoryAllocatorReference;
  puStack_d8 = &SystemGlobalDataReference;
  if (lStack_d0 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_d0 = 0;
  uStack_c0 = 0;
  puStack_d8 = &SystemMemoryAllocatorReference;
  puVar18 = &SystemStringTemplate;
  if (puStack_f0 != (undefined *)0x0) {
    puVar18 = puStack_f0;
  }
  cVar3 = FUN_1800f9600(puVar18);
  if (cVar3 != '\0') {
    puStack_f8 = &SystemGlobalDataReference;
    if (puStack_f0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    goto LAB_1800718e9;
  }
  iVar4 = WaitForSingleObject(SystemSemaphoreHandle,1);
  lVar9 = _DAT_180c82868;
  if (iVar4 != 0) {
    puStack_f8 = &SystemGlobalDataReference;
    if (puStack_f0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    goto LAB_1800718e9;
  }
  lStack_90 = _DAT_180c82868;
  puStack_140 = &SystemGlobalDataReference;
  uStack_128 = 0;
  puStack_138 = (uint8_t *)0x0;
  uStack_130 = 0;
  puVar18 = &DAT_1809ff660;
  if (cStack_120 != '\0') {
    puVar18 = &UNK_1809ff648;
  }
  lVar15 = -1;
  do {
    lVar16 = lVar15;
    lVar15 = lVar16 + 1;
  } while (puVar18[lVar15] != '\0');
  iVar4 = (int)lVar15;
  if (0 < iVar4) {
    if (iVar4 != 0) {
      iVar4 = iVar4 + 1;
      if (iVar4 < 0x10) {
        iVar4 = 0x10;
      }
      puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar4,0x13);
      *puStack_138 = 0;
      uVar7 = StartSystemThread(puStack_138);
      uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
    }
                    // WARNING: Subroutine does not return
    memcpy(puStack_138 + uStack_130,puVar18,(long long)((int)lVar16 + 2));
  }
  puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
  *puStack_138 = 0;
  uVar5 = StartSystemThread(puStack_138);
  uStack_128 = CONCAT44(uStack_128._4_4_,uVar5);
  *(undefined2 *)(puStack_138 + uStack_130) = 10;
  uStack_130 = 1;
  uVar6 = 2;
  if (puStack_138 == (uint8_t *)0x0) {
    uStack_130 = 1;
    puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
    *puStack_138 = 0;
LAB_180070db8:
    uVar7 = StartSystemThread(puStack_138);
    uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
  }
  else if (uVar5 < 3) {
    puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
    uStack_130 = 1;
    puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,3,0x10);
    goto LAB_180070db8;
  }
  *(undefined2 *)(puStack_138 + uStack_130) = 10;
  uStack_130 = 2;
  if (param_2 != 0) {
    lVar15 = -1;
    do {
      lVar16 = lVar15;
      lVar15 = lVar16 + 1;
    } while (*(char *)(param_2 + lVar15) != '\0');
    iVar4 = (int)lVar15;
    if (0 < iVar4) {
      uVar5 = uVar6;
      if (iVar4 != -2) {
        uVar14 = iVar4 + 3;
        if (puStack_138 == (uint8_t *)0x0) {
          if ((int)uVar14 < 0x10) {
            uVar14 = 0x10;
          }
          uStack_130 = uVar6;
          puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar14,0x13);
          *puStack_138 = 0;
        }
        else {
          uVar5 = uStack_130;
          if (uVar14 <= (uint)uStack_128) goto LAB_180070e64;
          puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
          uStack_130 = uVar6;
          puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,uVar14,0x10);
        }
        uVar7 = StartSystemThread(puStack_138);
        uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
        uVar5 = uStack_130;
      }
LAB_180070e64:
      uStack_130 = uVar5;
                    // WARNING: Subroutine does not return
      memcpy(puStack_138 + uStack_130,param_2,(long long)((int)lVar16 + 2));
    }
  }
  if (puStack_138 == (uint8_t *)0x0) {
    uStack_130 = uVar6;
    puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
    *puStack_138 = 0;
LAB_180070ee8:
    uVar7 = StartSystemThread(puStack_138);
    uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
  }
  else if ((uint)uStack_128 < 4) {
    puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
    uStack_130 = uVar6;
    puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,4,0x10);
    goto LAB_180070ee8;
  }
  *(undefined2 *)(puStack_138 + uStack_130) = 0x3a;
  uStack_130 = 3;
  FUN_180628380(&puStack_140,uStack_98);
  uVar6 = uStack_130;
  uVar5 = uStack_130 + 1;
  if (uVar5 != 0) {
    uVar14 = uStack_130 + 2;
    if (puStack_138 == (uint8_t *)0x0) {
      if ((int)uVar14 < 0x10) {
        uVar14 = 0x10;
      }
      puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar14,0x13);
      *puStack_138 = 0;
    }
    else {
      if (uVar14 <= (uint)uStack_128) goto LAB_180070f81;
      puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
      puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,uVar14,0x10);
    }
    uVar7 = StartSystemThread(puStack_138);
    uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
  }
LAB_180070f81:
  *(undefined2 *)(puStack_138 + uStack_130) = 10;
  uVar14 = uVar6 + 0xd;
  uStack_130 = uVar5;
  if (uVar14 != 0) {
    uVar5 = uVar6 + 0xe;
    if (puStack_138 == (uint8_t *)0x0) {
      if ((int)uVar5 < 0x10) {
        uVar5 = 0x10;
      }
      puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar5,0x13);
      *puStack_138 = 0;
    }
    else {
      if (uVar5 <= (uint)uStack_128) goto LAB_180071000;
      puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
      puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,uVar5,0x10);
    }
    uVar7 = StartSystemThread(puStack_138);
    uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
  }
LAB_180071000:
  lVar15 = lStack_88;
  puVar11 = (void* *)(puStack_138 + uStack_130);
  *puVar11 = 0x6973736572707845;
  *(uint32_t *)(puVar11 + 1) = 0x203a6e6f;
  *(uint8_t *)((long long)puVar11 + 0xc) = 0;
  lVar16 = -1;
  uStack_130 = uVar14;
  if (lStack_88 != 0) {
    do {
      lVar17 = lVar16;
      lVar16 = lVar17 + 1;
    } while (*(char *)(lStack_88 + lVar16) != '\0');
    if (0 < (int)lVar16) {
      iVar4 = uVar14 + (int)lVar16;
      if (iVar4 != 0) {
        uVar6 = iVar4 + 1;
        if (puStack_138 == (uint8_t *)0x0) {
          if ((int)uVar6 < 0x10) {
            uVar6 = 0x10;
          }
          puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar6,0x13);
          *puStack_138 = 0;
        }
        else {
          if (uVar6 <= (uint)uStack_128) goto LAB_1800710b8;
          puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
          puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,uVar6,0x10);
        }
        uVar7 = StartSystemThread(puStack_138);
        uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
      }
LAB_1800710b8:
                    // WARNING: Subroutine does not return
      memcpy(puStack_138 + uStack_130,lVar15,(long long)((int)lVar17 + 2));
    }
  }
  iVar4 = uVar6 + 0xe;
  if (iVar4 != 0) {
    uVar6 = uVar6 + 0xf;
    if (puStack_138 == (uint8_t *)0x0) {
      if ((int)uVar6 < 0x10) {
        uVar6 = 0x10;
      }
      puStack_138 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar6,0x13);
      *puStack_138 = 0;
    }
    else {
      if (uVar6 <= (uint)uStack_128) goto LAB_18007113f;
      puStack_168 = (uint8_t *)CONCAT71(puStack_168._1_7_,0x13);
      puStack_138 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_138,uVar6,0x10);
    }
    uVar7 = StartSystemThread(puStack_138);
    uStack_128 = CONCAT44(uStack_128._4_4_,uVar7);
  }
LAB_18007113f:
  *(undefined2 *)(puStack_138 + uStack_130) = 10;
  uStack_130 = iVar4;
  if (lVar9 != 0) {
    FUN_18005dab0(lVar9);
  }
  bVar13 = 1;
  cStack_11f = '\x01';
  cVar3 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
  if ((cVar3 != '\0') || (iVar4 = IsDebuggerPresent(), iVar4 == 0)) {
    bVar13 = 0;
  }
  if (_DAT_180c86870 == 0) {
    cStack_147 = '\0';
  }
  else {
    cStack_147 = *(char *)(_DAT_180c86870 + 0x24);
  }
  bVar2 = true;
  if (lVar9 != 0) {
    iVar4 = *(int *)(**(long long **)(lVar9 + 8) + 0x48);
    iVar8 = _Thrd_id();
    cStack_11f = iVar8 == iVar4;
    bVar2 = (bool)cStack_11f;
  }
  lVar9 = _DAT_180c86950;
  if ((DAT_180c82842 == '\0') && (bVar2)) {
    if ((_DAT_180c86950 != 0) && (*(char *)(_DAT_180c86950 + 0x1609) != '\x01')) {
      FUN_1801723a0(*(void* *)(_DAT_180c86870 + 8),*(char *)(_DAT_180c868d0 + 0x2028) != '\0',
                    *(uint32_t *)(_DAT_180c86950 + 0x160c));
      *(uint8_t *)(lVar9 + 0x1609) = 1;
    }
    if (*(long long *)(_DAT_180c86870 + 8) != 0) {
      FUN_1801719d0();
    }
  }
  puStack_118 = &SystemGlobalDataReference;
  uStack_100 = 0;
  puStack_110 = (uint8_t *)0x0;
  uStack_108 = 0;
  if (bVar13 == 0) {
    lVar9 = FUN_1800f9ce0(&puStack_d8,0);
    uStack_108 = *(uint *)(lVar9 + 0x10);
    puStack_110 = *(uint8_t **)(lVar9 + 8);
    uStack_100 = *(ulong long *)(lVar9 + 0x18);
    *(uint32_t *)(lVar9 + 0x10) = 0;
    *(void* *)(lVar9 + 8) = 0;
    *(void* *)(lVar9 + 0x18) = 0;
    puStack_d8 = &SystemGlobalDataReference;
    if (lStack_d0 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_d0 = 0;
    uStack_c0 = 0;
    puStack_d8 = &SystemMemoryAllocatorReference;
  }
  puVar10 = puStack_110;
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff550);
  puStack_168 = &SystemStringTemplate;
  if (puStack_138 != (uint8_t *)0x0) {
    puStack_168 = puStack_138;
  }
  FUN_180062380(_DAT_180c86928,4,0xffffffff00000000,&UNK_1809ff5b0);
  puStack_168 = &SystemStringTemplate;
  if (puVar10 != (uint8_t *)0x0) {
    puStack_168 = puVar10;
  }
  FUN_1800623b0(_DAT_180c86928,4,0xffffffff00000000,3);
  FUN_1800623e0();
  puVar12 = &SystemStringTemplate;
  if (puStack_138 != (uint8_t *)0x0) {
    puVar12 = puStack_138;
  }
  OutputDebugStringA(puVar12);
  FUN_18004c2b0(lVar15);
  if (DAT_180c82860 != '\0') {
    if (bVar13 != 0) {
      if (((cStack_147 == '\0') && (param_6 != '\0')) && (*(int *)(_DAT_180c86870 + 0x340) != 2)) {
        uStack_148 = 1;
      }
      else if (DAT_180c82851 == '\0') {
        pcVar1 = (code *)swi(3);
        (*pcVar1)();
        return;
      }
    }
    if ((_DAT_180c86948 == 0) || (*(int *)(_DAT_180c86948 + 0x168) == 2)) {
      FUN_180062380(_DAT_180c86928,4,0xffffffff00000000,&UNK_1809ff688);
      FUN_1800623e0();
      iVar4 = IsDebuggerPresent();
      if ((iVar4 != 0) && (DAT_180c82851 == '\0')) {
        pcVar1 = (code *)swi(3);
        (*pcVar1)();
        return;
      }
    }
  }
  if (DAT_180c82842 == '\0') {
    puVar18 = &UNK_1809ff6bc;
    if (cStack_120 != '\0') {
      puVar18 = &UNK_1809ff6b0;
    }
    do {
      while( true ) {
        puVar12 = &SystemStringTemplate;
        if (puStack_138 != (uint8_t *)0x0) {
          puVar12 = puStack_138;
        }
        if (((DAT_180c82860 == '\0') || (iVar4 = IsDebuggerPresent(), iVar4 != 0)) &&
           (DAT_180c82842 == '\0')) break;
        if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
          puStack_168 = &UNK_180a04f08;
          puStack_160 = puVar18;
          puStack_158 = puVar12;
          FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd);
        }
      }
      uVar7 = MessageBoxA(0,puVar12,puVar18,0x52012);
      switch(uVar7) {
      case 1:
        iVar4 = 0;
        break;
      default:
        iVar4 = 1;
        break;
      case 4:
        iVar4 = 2;
        break;
      case 5:
        iVar4 = 3;
        break;
      case 6:
        iVar4 = 4;
        break;
      case 7:
        iVar4 = 5;
      }
    } while (iVar4 == 1);
    if (iVar4 == 2) {
      if (bVar13 == 0) {
        puVar12 = &SystemStringTemplate;
        if (puVar10 != (uint8_t *)0x0) {
          puVar12 = puVar10;
        }
        if (((DAT_180c82860 == '\0') || (iVar4 = IsDebuggerPresent(), iVar4 != 0)) &&
           (DAT_180c82842 == '\0')) {
          MessageBoxA(0,puVar12,&UNK_1809ff6c8,0x41010);
        }
        else if (*(char *)(_DAT_180c86928 + 0x18) != '\0') {
          puStack_160 = &UNK_1809ff6c8;
          puStack_168 = &UNK_180a04f08;
          puStack_158 = puVar12;
          FUN_1800623b0(_DAT_180c86928,3,0xffffffff00000000,0xd);
        }
      }
      else if (((param_6 == '\0') || (*(int *)(_DAT_180c86870 + 0x340) == 2)) &&
              (DAT_180c82851 == '\0')) {
        pcVar1 = (code *)swi(3);
        (*pcVar1)();
        return;
      }
    }
    else if (iVar4 == 3) goto LAB_1800715eb;
    if (_DAT_180c86870 == 0) {
      cVar3 = '\x01';
    }
    else {
      cVar3 = *(char *)(_DAT_180c86870 + 0x29);
    }
    if (cStack_147 != '\0') {
      FUN_180055f70(cVar3,5);
      pcVar1 = (code *)swi(3);
      (*pcVar1)();
      return;
    }
    if (cVar3 != '\0') {
      _DAT_180c82854 = 5;
    }
    if ((DAT_180c82842 == '\0') && (cStack_11f != '\0')) {
      if (*(long long *)(_DAT_180c86870 + 8) != 0) {
        FUN_1801718f0();
      }
      if (_DAT_180c86950 != 0) {
        FUN_180092940(_DAT_180c86950,*(uint8_t *)(_DAT_180c86950 + 0x160a));
      }
    }
    if (lStack_90 != 0) {
      FUN_18005db30();
    }
    do {
      iVar4 = ReleaseSemaphore(SystemSemaphoreHandle,1);
    } while (iVar4 == 0);
    puStack_118 = &SystemGlobalDataReference;
    if (puVar10 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar10);
    }
    puStack_110 = (uint8_t *)0x0;
    uStack_100 = uStack_100 & 0xffffffff00000000;
    puStack_118 = &SystemMemoryAllocatorReference;
    puStack_140 = &SystemGlobalDataReference;
    if (puStack_138 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_138 = (uint8_t *)0x0;
    uStack_128 = uStack_128 & 0xffffffff00000000;
    puStack_140 = &SystemMemoryAllocatorReference;
    puStack_f8 = &SystemGlobalDataReference;
    if (puStack_f0 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
LAB_1800718e9:
    uStack_e0 = 0;
    puStack_f0 = (undefined *)0x0;
    puStack_f8 = &SystemMemoryAllocatorReference;
                    // WARNING: Subroutine does not return
    FUN_1808fc050(uStack_48 ^ (ulong long)auStack_188);
  }
LAB_1800715eb:
  puVar18 = &SystemStringTemplate;
  if (puStack_f0 != (undefined *)0x0) {
    puVar18 = puStack_f0;
  }
  uVar7 = FUN_1800f98e0(puVar18);
                    // WARNING: Subroutine does not return
  FUN_180062300(_DAT_180c86928,&UNK_1809ff6e0,bVar13 ^ 1,uVar7);
}



// WARNING: Removing unreachable block (ram,0x000180071b49)
// WARNING: Removing unreachable block (ram,0x000180071ad3)
// WARNING: Removing unreachable block (ram,0x000180071a52)
// WARNING: Removing unreachable block (ram,0x000180071c73)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180071940(void* param_1,long long param_2,uint32_t param_3,long long param_4)
void FUN_180071940(void* param_1,long long param_2,uint32_t param_3,long long param_4)

{
  int iVar1;
  uint uVar2;
  uint32_t uVar3;
  long long lVar4;
  undefined *puVar5;
  uint32_t *puVar6;
  void** systemCurrentNode;
  uint8_t *puVar8;
  undefined *puVar9;
  long long lVar10;
  uint uVar11;
  uint uVar12;
  undefined *pstackParameterC;
  uint8_t *puStack_88;
  uint uStack_80;
  ulong long uStack_78;
  undefined *puStack_70;
  undefined *puStack_68;
  uint32_t uStack_60;
  void* uStack_58;
  undefined *puStack_50;
  long long lStack_48;
  uint32_t uStack_38;
  
  iVar1 = WaitForSingleObject(SystemSemaphoreHandle,0);
  if (iVar1 != 0) {
    return;
  }
  puVar9 = (undefined *)0x0;
  puStack_70 = &SystemGlobalDataReference;
  uStack_58 = 0;
  puStack_68 = (undefined *)0x0;
  uStack_60 = 0;
  iVar1 = IsDebuggerPresent();
  if (iVar1 == 0) {
    lVar4 = FUN_1800f9ce0(&puStack_50,0);
    uStack_60 = *(uint32_t *)(lVar4 + 0x10);
    puVar9 = *(undefined **)(lVar4 + 8);
    uStack_58 = *(void* *)(lVar4 + 0x18);
    *(uint32_t *)(lVar4 + 0x10) = 0;
    *(void* *)(lVar4 + 8) = 0;
    *(void* *)(lVar4 + 0x18) = 0;
    puStack_50 = &SystemGlobalDataReference;
    puStack_68 = puVar9;
    if (lStack_48 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lStack_48 = 0;
    uStack_38 = 0;
    puStack_50 = &SystemMemoryAllocatorReference;
  }
  pstackParameterC = &SystemGlobalDataReference;
  uStack_78 = 0;
  puStack_88 = (uint8_t *)0x0;
  uStack_80 = 0;
  puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x12,0x13);
  *puStack_88 = 0;
  uVar2 = StartSystemThread(puStack_88);
  uStack_78 = CONCAT44(uStack_78._4_4_,uVar2);
  puVar6 = (uint32_t *)(puStack_88 + uStack_80);
  *puVar6 = 0x65737341;
  puVar6[1] = 0x6f697472;
  puVar6[2] = 0x6146206e;
  puVar6[3] = 0x64656c69;
  *(undefined2 *)(systemCurrentNode + 4) = 0x21;
  uStack_80 = 0x11;
  if (puStack_88 == (uint8_t *)0x0) {
    uStack_80 = 0x11;
    puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x13,0x13);
    *puStack_88 = 0;
LAB_180071af3:
    uVar3 = StartSystemThread(puStack_88);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
  }
  else if (uVar2 < 0x13) {
    uStack_80 = 0x11;
    puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,0x13,0x10,0x13);
    goto LAB_180071af3;
  }
  *(undefined2 *)(puStack_88 + uStack_80) = 10;
  uStack_80 = 0x12;
  uVar2 = 0x13;
  if (puStack_88 == (uint8_t *)0x0) {
    uStack_80 = 0x12;
    puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x14,0x13);
    *puStack_88 = 0;
LAB_180071b69:
    uVar3 = StartSystemThread(puStack_88);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
  }
  else if ((uint)uStack_78 < 0x14) {
    uStack_80 = 0x12;
    puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,0x14,0x10,0x13);
    goto LAB_180071b69;
  }
  *(undefined2 *)(puStack_88 + uStack_80) = 10;
  uStack_80 = 0x13;
  if (param_2 != 0) {
    lVar4 = -1;
    do {
      lVar10 = lVar4;
      lVar4 = lVar10 + 1;
    } while (*(char *)(param_2 + lVar4) != '\0');
    iVar1 = (int)lVar4;
    if (0 < iVar1) {
      uVar11 = uVar2;
      if (iVar1 != -0x13) {
        uVar12 = iVar1 + 0x14;
        if (puStack_88 == (uint8_t *)0x0) {
          if ((int)uVar12 < 0x10) {
            uVar12 = 0x10;
          }
          uStack_80 = uVar2;
          puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar12,0x13);
          *puStack_88 = 0;
        }
        else {
          uVar11 = uStack_80;
          if (uVar12 <= (uint)uStack_78) goto LAB_180071c1a;
          uStack_80 = uVar2;
          puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,uVar12,0x10,0x13);
        }
        uVar3 = StartSystemThread(puStack_88);
        uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
        uVar11 = uStack_80;
      }
LAB_180071c1a:
      uStack_80 = uVar11;
                    // WARNING: Subroutine does not return
      memcpy(puStack_88 + uStack_80,param_2,(long long)((int)lVar10 + 2));
    }
  }
  if (puStack_88 == (uint8_t *)0x0) {
    uStack_80 = uVar2;
    puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x15,0x13);
    *puStack_88 = 0;
LAB_180071c93:
    uVar3 = StartSystemThread(puStack_88);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
  }
  else if ((uint)uStack_78 < 0x15) {
    uStack_80 = uVar2;
    puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,0x15,0x10,0x13);
    goto LAB_180071c93;
  }
  *(undefined2 *)(puStack_88 + uStack_80) = 0x3a;
  uStack_80 = 0x14;
  FUN_180628380(&pstackParameterC,param_3);
  uVar2 = uStack_80;
  uVar11 = uStack_80 + 1;
  if (uVar11 != 0) {
    uVar12 = uStack_80 + 2;
    if (puStack_88 == (uint8_t *)0x0) {
      if ((int)uVar12 < 0x10) {
        uVar12 = 0x10;
      }
      puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar12,0x13);
      *puStack_88 = 0;
    }
    else {
      if (uVar12 <= (uint)uStack_78) goto LAB_180071d1f;
      puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,uVar12,0x10,0x13);
    }
    uVar3 = StartSystemThread(puStack_88);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
  }
LAB_180071d1f:
  *(undefined2 *)(puStack_88 + uStack_80) = 10;
  uVar12 = uVar2 + 0xd;
  uStack_80 = uVar11;
  if (uVar12 != 0) {
    uVar11 = uVar2 + 0xe;
    if (puStack_88 == (uint8_t *)0x0) {
      if ((int)uVar11 < 0x10) {
        uVar11 = 0x10;
      }
      puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar11,0x13);
      *puStack_88 = 0;
    }
    else {
      if (uVar11 <= (uint)uStack_78) goto LAB_180071d94;
      puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,uVar11,0x10,0x13);
    }
    uVar3 = StartSystemThread(puStack_88);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
  }
LAB_180071d94:
  systemPreviousNode = (void* *)(puStack_88 + uStack_80);
  *systemPreviousNode = 0x6973736572707845;
  *(uint32_t *)(systemPreviousNode + 1) = 0x203a6e6f;
  *(uint8_t *)((long long)systemPreviousNode + 0xc) = 0;
  lVar4 = -1;
  uStack_80 = uVar12;
  if (param_4 != 0) {
    do {
      lVar10 = lVar4;
      lVar4 = lVar10 + 1;
    } while (*(char *)(param_4 + lVar4) != '\0');
    if (0 < (int)lVar4) {
      iVar1 = uVar12 + (int)lVar4;
      if (iVar1 != 0) {
        uVar2 = iVar1 + 1;
        if (puStack_88 == (uint8_t *)0x0) {
          if ((int)uVar2 < 0x10) {
            uVar2 = 0x10;
          }
          puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar2,0x13);
          *puStack_88 = 0;
        }
        else {
          if (uVar2 <= (uint)uStack_78) goto LAB_180071e34;
          puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,uVar2,0x10,0x13);
        }
        uVar3 = StartSystemThread(puStack_88);
        uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
      }
LAB_180071e34:
                    // WARNING: Subroutine does not return
      memcpy(puStack_88 + uStack_80,param_4,(long long)((int)lVar10 + 2));
    }
  }
  if (uVar2 + 0xe != 0) {
    uVar11 = uVar2 + 0xf;
    if (puStack_88 == (uint8_t *)0x0) {
      if ((int)uVar11 < 0x10) {
        uVar11 = 0x10;
      }
      puStack_88 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar11,0x13);
      *puStack_88 = 0;
    }
    else {
      if (uVar11 <= (uint)uStack_78) goto LAB_180071eb0;
      puStack_88 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_88,uVar11,0x10,0x13);
    }
    uVar3 = StartSystemThread(puStack_88);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar3);
  }
LAB_180071eb0:
  *(undefined2 *)(puStack_88 + uStack_80) = 10;
  uStack_80 = uVar2 + 0xe;
  FUN_180062380(_DAT_180c86928,5,0xffffffff00000000,&UNK_1809ff550);
  puVar8 = &SystemStringTemplate;
  if (puStack_88 != (uint8_t *)0x0) {
    puVar8 = puStack_88;
  }
  FUN_180062380(_DAT_180c86928,4,0xffffffff00000000,&UNK_1809ff5b0,puVar8);
  puVar5 = &SystemStringTemplate;
  if (puVar9 != (undefined *)0x0) {
    puVar5 = puVar9;
  }
  FUN_1800623b0(_DAT_180c86928,4,0xffffffff00000000,3,puVar5);
  FUN_1800623e0();
  puVar8 = &SystemStringTemplate;
  if (puStack_88 != (uint8_t *)0x0) {
    puVar8 = puStack_88;
  }
  OutputDebugStringA(puVar8);
  do {
    iVar1 = ReleaseSemaphore(SystemSemaphoreHandle,1);
  } while (iVar1 == 0);
  pstackParameterC = &SystemGlobalDataReference;
  if (puStack_88 == (uint8_t *)0x0) {
    puStack_88 = (uint8_t *)0x0;
    uStack_78 = uStack_78 & 0xffffffff00000000;
    pstackParameterC = &SystemMemoryAllocatorReference;
    puStack_70 = &SystemGlobalDataReference;
    if (puVar9 == (undefined *)0x0) {
      return;
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar9);
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Removing unreachable block (ram,0x00018007258a)
// WARNING: Removing unreachable block (ram,0x0001800724fe)
// WARNING: Removing unreachable block (ram,0x00018007246a)
// WARNING: Removing unreachable block (ram,0x0001800726c4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180072000(void* param_1,long long param_2,uint32_t param_3,long long param_4,
void FUN_180072000(void* param_1,long long param_2,uint32_t param_3,long long param_4,
                  uint8_t param_5,char param_6)

{
  code *pcVar1;
  char cVar2;
  int memoryCompareResult;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  long long lVar9;
  uint8_t *puVar10;
  undefined **ppuVar11;
  uint32_t *puVar12;
  void* *puVar13;
  uint8_t *puVar14;
  undefined *puVar15;
  uint uVar16;
  long long lVar17;
  uint8_t uVar18;
  ulong long uVar19;
  uint8_t auStack_168 [32];
  uint8_t *puStack_148;
  undefined *puStack_138;
  uint8_t *puStack_130;
  uint uStack_128;
  ulong long uStack_120;
  char cStack_118;
  char cStack_117;
  uint8_t uStack_116;
  uint uStack_114;
  undefined *puStack_110;
  uint8_t *puStack_108;
  uint uStack_100;
  void* uStack_f8;
  undefined *puStack_f0;
  long long lStack_e8;
  uint32_t uStack_d8;
  undefined *puStack_d0;
  void* *puStack_c8;
  uint32_t uStack_c0;
  ulong long uStack_b8;
  uint32_t uStack_b0;
  undefined *puStack_a8;
  undefined *stackParameterA;
  uint32_t stackParameterC;
  long long lStack_88;
  undefined *puStack_80;
  long long lStack_78;
  uint32_t uStack_68;
  void* uStack_60;
  void* uStack_58;
  void* uStack_50;
  ulong long uStack_48;
  
  uStack_60 = 0xfffffffffffffffe;
  uStack_48 = _DAT_180bf00a8 ^ (ulong long)auStack_168;
  puVar10 = (uint8_t *)0x0;
  uStack_114 = 0;
  uStack_116 = 0;
  uStack_b0 = param_3;
  lStack_88 = param_4;
  if ((DAT_180c82860 != '\0') || (DAT_180c82850 != '\0')) goto LAB_180072d7b;
  uStack_58 = 0;
  uStack_50 = 0;
  FUN_1800634b0(&uStack_58,0x10,&UNK_1809fd0a0,param_3);
  lVar9 = FUN_180627910(&puStack_f0,param_4);
  puStack_110 = &SystemGlobalDataReference;
  uVar16 = 0;
  uStack_f8 = 0;
  puStack_108 = (uint8_t *)0x0;
  uStack_100 = 0;
  uStack_114 = 4;
  uVar6 = *(uint *)(lVar9 + 0x10);
  uVar19 = (ulong long)uVar6;
  uVar4 = 0;
  if (*(long long *)(lVar9 + 8) == 0) {
LAB_180072120:
    uVar16 = uVar4;
    if (uVar6 != 0) {
                    // WARNING: Subroutine does not return
      memcpy(puVar10,*(void* *)(lVar9 + 8),uVar19);
    }
  }
  else if (uVar6 != 0) {
    iVar3 = uVar6 + 1;
    if (memoryCompareResult < 0x10) {
      iVar3 = 0x10;
    }
    puVar10 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar3,0x13);
    *puVar10 = 0;
    puStack_108 = puVar10;
    uVar4 = StartSystemThread(puVar10);
    uStack_f8 = CONCAT44(uStack_f8._4_4_,uVar4);
    goto LAB_180072120;
  }
  if (puVar10 != (uint8_t *)0x0) {
    puVar10[uVar19] = 0;
  }
  uVar4 = *(uint *)(lVar9 + 0x1c);
  uStack_100 = uVar6;
  uStack_f8._4_4_ = uVar4;
  if (param_2 != 0) {
    lVar9 = -1;
    do {
      lVar17 = lVar9;
      lVar9 = lVar17 + 1;
    } while (*(char *)(param_2 + lVar9) != '\0');
    if (0 < (int)lVar9) {
      iVar3 = uVar6 + (int)lVar9;
      if (iVar3 != 0) {
        uVar6 = iVar3 + 1;
        if (puVar10 == (uint8_t *)0x0) {
          if ((int)uVar6 < 0x10) {
            uVar6 = 0x10;
          }
          puVar10 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar6,0x13);
          *puVar10 = 0;
        }
        else {
          if (uVar6 <= uVar16) goto LAB_1800721e1;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puVar10 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puVar10,uVar6,0x10);
        }
        puStack_108 = puVar10;
        uStack_f8._0_4_ = StartSystemThread(puVar10);
      }
LAB_1800721e1:
                    // WARNING: Subroutine does not return
      memcpy(puVar10 + uVar19,param_2,(long long)((int)lVar17 + 2));
    }
  }
  FUN_180627e10(&puStack_110,&puStack_a8,&uStack_58);
  uStack_114 = 0;
  puStack_110 = &SystemGlobalDataReference;
  if (puVar10 != (uint8_t *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(puVar10);
  }
  puStack_108 = (uint8_t *)0x0;
  uStack_f8 = (ulong long)uStack_f8._4_4_ << 0x20;
  puStack_110 = &SystemMemoryAllocatorReference;
  puStack_f0 = &SystemGlobalDataReference;
  if (lStack_e8 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  lStack_e8 = 0;
  uStack_d8 = 0;
  puStack_f0 = &SystemMemoryAllocatorReference;
  puVar15 = &SystemStringTemplate;
  if (stackParameterA != (undefined *)0x0) {
    puVar15 = stackParameterA;
  }
  cVar2 = FUN_1800f9600(puVar15);
  if (cVar2 == '\0') {
    iVar3 = WaitForSingleObject(SystemSemaphoreHandle,0);
    if (iVar3 == 0) {
      cStack_117 = '\x01';
      cVar2 = (**(code **)**(void* **)(_DAT_180c8ed08 + 0x18))();
      if ((cVar2 == '\0') && (iVar3 = IsDebuggerPresent(), iVar3 != 0)) {
        cVar2 = '\x01';
      }
      else {
        cVar2 = '\0';
      }
      cStack_118 = cVar2;
      if (_DAT_180c82868 == 0) {
LAB_1800722f5:
        lVar9 = _DAT_180c86950;
        if ((_DAT_180c86950 != 0) && (*(char *)(_DAT_180c86950 + 0x1609) != '\x01')) {
          FUN_1801723a0(*(void* *)(_DAT_180c86870 + 8),
                        *(char *)(_DAT_180c868d0 + 0x2028) != '\0',
                        *(uint32_t *)(_DAT_180c86950 + 0x160c));
          *(uint8_t *)(lVar9 + 0x1609) = 1;
        }
        if (*(long long *)(_DAT_180c86870 + 8) != 0) {
          FUN_1801719d0();
        }
      }
      else {
        iVar3 = *(int *)(**(long long **)(_DAT_180c82868 + 8) + 0x48);
        iVar5 = _Thrd_id();
        cStack_117 = iVar5 == iVar3;
        if ((bool)cStack_117) goto LAB_1800722f5;
      }
      if (cVar2 != '\0') {
        if ((param_6 == '\0') || (*(int *)(_DAT_180c86870 + 0x340) == 2)) {
          pcVar1 = (code *)swi(3);
          (*pcVar1)();
          return;
        }
        uStack_116 = 1;
      }
      puStack_110 = &SystemGlobalDataReference;
      uStack_f8 = 0;
      puStack_108 = (undefined *)0x0;
      uStack_100 = 0;
      if (cVar2 == '\0') {
        lVar9 = FUN_1800f9ce0(&puStack_f0,0);
        uStack_100 = *(uint *)(lVar9 + 0x10);
        puStack_108 = *(uint8_t **)(lVar9 + 8);
        uStack_f8 = *(ulong long *)(lVar9 + 0x18);
        *(uint32_t *)(lVar9 + 0x10) = 0;
        *(void* *)(lVar9 + 8) = 0;
        *(void* *)(lVar9 + 0x18) = 0;
        puStack_f0 = &SystemGlobalDataReference;
        if (lStack_e8 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        lStack_e8 = 0;
        uStack_d8 = 0;
        puStack_f0 = &SystemMemoryAllocatorReference;
      }
      puVar10 = puStack_108;
      puStack_138 = &SystemGlobalDataReference;
      uStack_120 = 0;
      puStack_130 = (uint8_t *)0x0;
      uStack_128 = 0;
      puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x15,0x13);
      *puStack_130 = 0;
      uVar6 = StartSystemThread(puStack_130);
      uStack_120 = CONCAT44(uStack_120._4_4_,uVar6);
      puVar12 = (uint32_t *)(puStack_130 + uStack_128);
      *puVar12 = 0x69746f4e;
      puVar12[1] = 0x61636966;
      puVar12[2] = 0x6e6f6974;
      puVar12[3] = 0x73734120;
      puVar12[4] = 0x21747265;
      *(uint8_t *)(puVar12 + 5) = 0;
      uStack_128 = 0x14;
      if (puStack_130 == (uint8_t *)0x0) {
        uStack_128 = 0x14;
        puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x16,0x13);
        *puStack_130 = 0;
LAB_180072521:
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
      else if (uVar6 < 0x16) {
        puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
        uStack_128 = 0x14;
        puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,0x16,0x10);
        goto LAB_180072521;
      }
      *(undefined2 *)(puStack_130 + uStack_128) = 10;
      uStack_128 = 0x15;
      uVar6 = 0x16;
      if (puStack_130 == (uint8_t *)0x0) {
        uStack_128 = 0x15;
        puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x17,0x13);
        *puStack_130 = 0;
LAB_1800725ac:
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
      else if ((uint)uStack_120 < 0x17) {
        puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
        uStack_128 = 0x15;
        puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,0x17,0x10);
        goto LAB_1800725ac;
      }
      *(undefined2 *)(puStack_130 + uStack_128) = 10;
      uStack_128 = 0x16;
      if (param_2 != 0) {
        lVar9 = -1;
        do {
          lVar17 = lVar9;
          lVar9 = lVar17 + 1;
        } while (*(char *)(param_2 + lVar9) != '\0');
        iVar3 = (int)lVar9;
        if (0 < iVar3) {
          uVar4 = uVar6;
          if (iVar3 != -0x16) {
            uVar16 = iVar3 + 0x17;
            if (puStack_130 == (uint8_t *)0x0) {
              if ((int)uVar16 < 0x10) {
                uVar16 = 0x10;
              }
              uStack_128 = uVar6;
              puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar16,0x13);
              *puStack_130 = 0;
            }
            else {
              uVar4 = uStack_128;
              if (uVar16 <= (uint)uStack_120) goto LAB_180072662;
              puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
              uStack_128 = uVar6;
              puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,uVar16,0x10);
            }
            uVar7 = StartSystemThread(puStack_130);
            uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
            uVar4 = uStack_128;
          }
LAB_180072662:
          uStack_128 = uVar4;
                    // WARNING: Subroutine does not return
          memcpy(puStack_130 + uStack_128,param_2,(long long)((int)lVar17 + 2));
        }
      }
      if (puStack_130 == (uint8_t *)0x0) {
        uStack_128 = uVar6;
        puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,0x18,0x13);
        *puStack_130 = 0;
LAB_1800726e7:
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
      else if ((uint)uStack_120 < 0x18) {
        puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
        uStack_128 = uVar6;
        puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,0x18,0x10);
        goto LAB_1800726e7;
      }
      *(undefined2 *)(puStack_130 + uStack_128) = 0x3a;
      uStack_128 = 0x17;
      FUN_180628380(&puStack_138,uStack_b0);
      uVar6 = uStack_128;
      uVar4 = uStack_128 + 1;
      if (uVar4 != 0) {
        uVar16 = uStack_128 + 2;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)uVar16 < 0x10) {
            uVar16 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar16,0x13);
          *puStack_130 = 0;
        }
        else {
          if (uVar16 <= (uint)uStack_120) goto LAB_180072780;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,uVar16,0x10);
        }
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
LAB_180072780:
      *(undefined2 *)(puStack_130 + uStack_128) = 10;
      uVar16 = uVar6 + 0xd;
      uStack_128 = uVar4;
      if (uVar16 != 0) {
        uVar4 = uVar6 + 0xe;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)uVar4 < 0x10) {
            uVar4 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar4,0x13);
          *puStack_130 = 0;
        }
        else {
          if (uVar4 <= (uint)uStack_120) goto LAB_1800727ff;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,uVar4,0x10);
        }
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
LAB_1800727ff:
      puVar13 = (void* *)(puStack_130 + uStack_128);
      *puVar13 = 0x6973736572707845;
      *(uint32_t *)(puVar13 + 1) = 0x203a6e6f;
      *(uint8_t *)((long long)puVar13 + 0xc) = 0;
      lVar9 = -1;
      uStack_128 = uVar16;
      if (param_4 != 0) {
        do {
          lVar17 = lVar9;
          lVar9 = lVar17 + 1;
        } while (*(char *)(lVar9 + param_4) != '\0');
        if (0 < (int)lVar9) {
          iVar3 = uVar16 + (int)lVar9;
          if (iVar3 != 0) {
            uVar6 = iVar3 + 1;
            if (puStack_130 == (uint8_t *)0x0) {
              if ((int)uVar6 < 0x10) {
                uVar6 = 0x10;
              }
              puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar6,0x13);
              *puStack_130 = 0;
            }
            else {
              if (uVar6 <= (uint)uStack_120) goto LAB_1800728ad;
              puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
              puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,uVar6,0x10);
            }
            uVar7 = StartSystemThread(puStack_130);
            uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
          }
LAB_1800728ad:
                    // WARNING: Subroutine does not return
          memcpy(puStack_130 + uStack_128,param_4,(long long)((int)lVar17 + 2));
        }
      }
      uVar4 = uVar6 + 0xf;
      if (uVar4 != 0) {
        uVar8 = uVar6 + 0x10;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)uVar8 < 0x10) {
            uVar8 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar8,0x13);
          *puStack_130 = 0;
        }
        else {
          if (uVar8 <= (uint)uStack_120) goto LAB_180072934;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,uVar8,0x10);
        }
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
LAB_180072934:
      *(undefined2 *)(puStack_130 + uStack_128) = 0xa0a;
      *(uint8_t *)((long long)(puStack_130 + uStack_128) + 2) = 0;
      uStack_128 = uVar4;
      if (uVar6 + 0x6d != 0) {
        uVar4 = uVar6 + 0x6e;
        if (puStack_130 == (uint8_t *)0x0) {
          if ((int)uVar4 < 0x10) {
            uVar4 = 0x10;
          }
          puStack_130 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)(int)uVar4,0x13);
          *puStack_130 = 0;
        }
        else {
          if (uVar4 <= (uint)uStack_120) goto LAB_1800729bd;
          puStack_148 = (uint8_t *)CONCAT71(puStack_148._1_7_,0x13);
          puStack_130 = (uint8_t *)FUN_18062b8b0(_DAT_180c8ed18,puStack_130,uVar4,0x10);
        }
        uVar7 = StartSystemThread(puStack_130);
        uStack_120 = CONCAT44(uStack_120._4_4_,uVar7);
      }
LAB_1800729bd:
      puVar13 = (void* *)(puStack_130 + uStack_128);
      *puVar13 = 0x232323232323233c;
      puVar13[1] = 0x2323232323232323;
      puVar13[2] = 0x2323232323232323;
      puVar13[3] = 0x2323232323232323;
      puVar13[4] = 0x2323232323232323;
      puVar13[5] = 0x2323232323232323;
      puVar13[6] = 0x2323232323232323;
      puVar13[7] = 0x2323232323232323;
      *(uint32_t *)(puVar13 + 8) = 0x23232323;
      *(uint32_t *)((long long)puVar13 + 0x44) = 0x23232323;
      *(uint32_t *)(puVar13 + 9) = 0x23232323;
      *(uint32_t *)((long long)puVar13 + 0x4c) = 0x23232323;
      puVar13[10] = 0x2323232323232323;
      *(uint32_t *)(puVar13 + 0xb) = 0x3e232323;
      *(undefined2 *)((long long)puVar13 + 0x5c) = 0xa0a;
      *(uint8_t *)((long long)puVar13 + 0x5e) = 0;
      puStack_148 = &SystemStringTemplate;
      if (puStack_130 != (uint8_t *)0x0) {
        puStack_148 = puStack_130;
      }
      uStack_128 = uVar6 + 0x6d;
      FUN_180062380(_DAT_180c86928,4,0xffffffff00000000,&UNK_1809ff5b0);
      puStack_148 = &SystemStringTemplate;
      if (puVar10 != (undefined *)0x0) {
        puStack_148 = puVar10;
      }
      FUN_1800623b0(_DAT_180c86928,4,0xffffffff00000000,3);
      FUN_1800623e0();
      puVar14 = &SystemStringTemplate;
      if (puStack_130 != (uint8_t *)0x0) {
        puVar14 = puStack_130;
      }
      OutputDebugStringA(puVar14);
      FUN_18004c2b0(param_4);
      puVar15 = &SystemStringTemplate;
      if (stackParameterA != (undefined *)0x0) {
        puVar15 = stackParameterA;
      }
      iVar3 = FUN_1800f98e0(puVar15);
      if ((cStack_118 == '\0') && (iVar3 == 0)) {
        if ((_DAT_180c86870 == 0) || (*(char *)(_DAT_180c86870 + 0x141) == '\0')) {
          uVar18 = 0;
        }
        else {
          uVar18 = 1;
        }
        if (_DAT_180c86870 == 0) {
          puStack_d0 = &SystemGlobalDataReference;
          uStack_b8 = 0;
          puStack_c8 = (void* *)0x0;
          uStack_c0 = 0;
          puVar13 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x34,0x13);
          *(uint8_t *)puVar13 = 0;
          puStack_c8 = puVar13;
          uVar7 = StartSystemThread(puVar13);
          uStack_b8 = CONCAT44(uStack_b8._4_4_,uVar7);
          *puVar13 = 0x7270706d75645c5c;
          puVar13[1] = 0x2e726f737365636f;
          puVar13[2] = 0x6c726f77656c6174;
          puVar13[3] = 0x445c6d6f632e7364;
          *(uint32_t *)(puVar13 + 4) = 0x50706d75;
          *(uint32_t *)((long long)puVar13 + 0x24) = 0x65636f72;
          *(uint32_t *)(puVar13 + 5) = 0x6e697373;
          *(uint32_t *)((long long)puVar13 + 0x2c) = 0x6c6f4667;
          *(uint32_t *)(puVar13 + 6) = 0x726564;
          uStack_c0 = 0x33;
          ppuVar11 = &puStack_d0;
          uVar6 = 2;
          uStack_114 = 2;
        }
        else {
          ppuVar11 = (undefined **)FUN_180627ae0(&puStack_80,_DAT_180c86870 + 0x148);
          uVar6 = 1;
          uStack_114 = 1;
          puVar13 = puStack_c8;
        }
        uVar7 = FUN_180627ae0(&puStack_f0,ppuVar11);
        if ((uVar6 & 2) != 0) {
          uVar6 = uVar6 & 0xfffffffd;
          puStack_d0 = &SystemGlobalDataReference;
          uStack_114 = uVar6;
          if (puVar13 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900(puVar13);
          }
          puStack_c8 = (void* *)0x0;
          uStack_b8 = uStack_b8 & 0xffffffff00000000;
          puStack_d0 = &SystemMemoryAllocatorReference;
        }
        if ((uVar6 & 1) != 0) {
          uStack_114 = uVar6 & 0xfffffffe;
          puStack_80 = &SystemGlobalDataReference;
          if (lStack_78 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          lStack_78 = 0;
          uStack_68 = 0;
          puStack_80 = &SystemMemoryAllocatorReference;
        }
        puStack_148 = &SystemStringTemplate;
        if (puVar10 != (undefined *)0x0) {
          puStack_148 = puVar10;
        }
        FUN_1800669c0(uVar7,&puStack_f0,uVar18,param_5);
        puStack_f0 = &SystemGlobalDataReference;
        if (lStack_e8 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        lStack_e8 = 0;
        uStack_d8 = 0;
        puStack_f0 = &SystemMemoryAllocatorReference;
      }
      puVar15 = &SystemStringTemplate;
      if (stackParameterA != (undefined *)0x0) {
        puVar15 = stackParameterA;
      }
      FUN_1800f96b0(puVar15,1);
      if (cStack_117 != '\0') {
        if (*(long long *)(_DAT_180c86870 + 8) != 0) {
          FUN_1801718f0();
        }
        if (_DAT_180c86950 != 0) {
          FUN_180092940(_DAT_180c86950,*(uint8_t *)(_DAT_180c86950 + 0x160a));
        }
      }

// 函数: void FUN_180072e80(void* param_1,void* param_2,void* param_3,void* param_4)
void FUN_180072e80(void* param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  void* uVar2;
  undefined *puStack_30;
  long long lStack_28;
  
  plVar1 = *(long long **)(_DAT_180c86870 + 0x2b0);
  if (plVar1 != (long long *)0x0) {
    uVar2 = (**(code **)(*plVar1 + 0x110))(plVar1,&puStack_30,param_3,param_4,0xfffffffffffffffe);
    FUN_18005d190(param_2,uVar2);
    puStack_30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_180072f00(void* param_1,void* *param_2)

{
  uint32_t uVar1;
  int iVar2;
  int memoryCompareResult;
  long long lVar4;
  void* *puVar5;
  void** systemRootNode;
  void* **psystemPreviousNode;
  uint8_t *puVar8;
  void* uVar9;
  undefined2 *puVar10;
  uint uVar11;
  void* *puVar12;
  undefined *puVar13;
  undefined *puVar14;
  char cStackX_10;
  uint uVar15;
  undefined *puStack_110;
  void* *puStack_108;
  int iStack_100;
  void* uStack_f8;
  undefined *puStack_f0;
  undefined2 *puStack_e8;
  uint32_t uStack_e0;
  void* uStack_d8;
  undefined *puStack_d0;
  undefined *puStack_c8;
  uint32_t uStack_c0;
  ulong long uStack_b8;
  undefined *puStack_b0;
  void* *puStack_a8;
  uint32_t uStack_a0;
  ulong long uStack_98;
  undefined *pstackParameterC;
  uint8_t *puStack_88;
  uint32_t uStack_80;
  ulong long uStack_78;
  undefined *puStack_70;
  void* *puStack_68;
  void* *puStack_60;
  long long lStack_48;
  void* uStack_40;
  
  uStack_40 = 0xfffffffffffffffe;
  puVar5 = (void* *)0x0;
  iVar3 = 0;
  WaitForSingleObject(SystemSemaphoreHandle,300000);
  lStack_48 = _DAT_180c82868;
  if (_DAT_180c82868 != 0) {
    FUN_18005dab0(_DAT_180c82868);
  }
  puStack_f0 = &SystemGlobalDataReference;
  uStack_d8 = 0;
  puStack_e8 = (undefined2 *)0x0;
  uStack_e0 = 0;
  puStack_e8 = (undefined2 *)CreateSystemThreadObject(_DAT_180c8ed18,0x10,0x13);
  *(uint8_t *)puStack_e8 = 0;
  uVar1 = StartSystemThread(puStack_e8);
  uStack_d8 = CONCAT44(uStack_d8._4_4_,uVar1);
  *puStack_e8 = 0xa0a;
  *(uint8_t *)(puStack_e8 + 1) = 0;
  uStack_e0 = 2;
  puStack_d0 = &SystemGlobalDataReference;
  uStack_b8 = 0;
  puStack_c8 = (undefined *)0x0;
  uStack_c0 = 0;
  FUN_1800a32b0(_DAT_180c86938,&puStack_68);
  if (puStack_68 != puStack_60) {
    FUN_180628040(&puStack_f0,&UNK_1809fe62c,&UNK_1809ff7c0);
    puVar6 = puVar5;
    puVar12 = puVar5;
    if ((long long)puStack_60 - (long long)puStack_68 >> 5 != 0) {
      do {
        puVar13 = &SystemStringTemplate;
        if (*(undefined **)((long long)(puVar6 + 1) + (long long)puStack_68) != (undefined *)0x0) {
          puVar13 = *(undefined **)((long long)(puVar6 + 1) + (long long)puStack_68);
        }
        FUN_180628040(&puStack_f0,&UNK_1809fe62c,puVar13);
        uVar11 = (int)puVar12 + 1;
        puVar6 = systemCurrentNode + 4;
        puVar12 = (void* *)(ulong long)uVar11;
      } while ((ulong long)(long long)(int)uVar11 <
               (ulong long)((long long)puStack_60 - (long long)puStack_68 >> 5));
    }
    FUN_180628040(&puStack_f0,&UNK_1809ff840,&UNK_1809ff800);
    FUN_18006f590(&puStack_110);
    if (iStack_100 != 0) {
      FUN_180628040(&puStack_f0,&UNK_1809fe62c,&UNK_1809ff848);
      puVar6 = (void* *)&SystemStringTemplate;
      if (puStack_108 != (void* *)0x0) {
        puVar6 = puStack_108;
      }
      FUN_180628040(&puStack_f0,&UNK_1809ff888,puVar6);
      FUN_180628040(&puStack_f0,&UNK_1809ff840,&UNK_1809ff800);
    }
    puStack_110 = &SystemGlobalDataReference;
    if (puStack_108 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_108 = (void* *)0x0;
    uStack_f8 = (ulong long)uStack_f8._4_4_ << 0x20;
    puStack_110 = &SystemMemoryAllocatorReference;
  }
  lVar4 = FUN_1800f9ce0(&puStack_110,param_2[1]);
  uStack_c0 = *(uint32_t *)(lVar4 + 0x10);
  puVar13 = *(undefined **)(lVar4 + 8);
  uStack_b8 = *(ulong long *)(lVar4 + 0x18);
  *(uint32_t *)(lVar4 + 0x10) = 0;
  *(void* *)(lVar4 + 8) = 0;
  *(void* *)(lVar4 + 0x18) = 0;
  puStack_110 = &SystemGlobalDataReference;
  puStack_c8 = puVar13;
  puStack_70 = puVar13;
  if (puStack_108 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puStack_108 = (void* *)0x0;
  uStack_f8 = uStack_f8 & 0xffffffff00000000;
  puStack_110 = &SystemMemoryAllocatorReference;
  FUN_180628040(&puStack_f0,&UNK_1809ff8a8,*(uint32_t *)*param_2,
                *(void* *)((uint32_t *)*param_2 + 4));
  FUN_180628040(&puStack_f0,&UNK_1809fe62c,&UNK_1809ff8d8);
  puVar14 = &SystemStringTemplate;
  if (puVar13 != (undefined *)0x0) {
    puVar14 = puVar13;
  }
  FUN_180628040(&puStack_f0,&UNK_1809fe62c,puVar14);
  puVar10 = (undefined2 *)&SystemStringTemplate;
  if (puStack_e8 != (undefined2 *)0x0) {
    puVar10 = puStack_e8;
  }
  FUN_1800623b0(_DAT_180c86928,5,0xffffffff00000000,3,&UNK_1809fe62c,puVar10);
  FUN_1800623e0();
  lVar4 = _DAT_180c86870;
  if (_DAT_180c86870 == 0) {
    cStackX_10 = '\0';
    puStack_110 = &SystemGlobalDataReference;
    uStack_f8 = 0;
    puStack_108 = (void* *)0x0;
    iStack_100 = 0;
    puVar6 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,0x34,0x13);
    *(uint8_t *)puVar6 = 0;
    puStack_108 = puVar6;
    uVar1 = StartSystemThread(puVar6);
    uStack_f8 = CONCAT44(uStack_f8._4_4_,uVar1);
    *puVar6 = 0x7270706d75645c5c;
    puVar6[1] = 0x2e726f737365636f;
    puVar6[2] = 0x6c726f77656c6174;
    puVar6[3] = 0x445c6d6f632e7364;
    *(uint32_t *)(systemCurrentNode + 4) = 0x50706d75;
    *(uint32_t *)((long long)puVar6 + 0x24) = 0x65636f72;
    *(uint32_t *)(puVar6 + 5) = 0x6e697373;
    *(uint32_t *)((long long)puVar6 + 0x2c) = 0x6c6f4667;
    *(uint32_t *)(puVar6 + 6) = 0x726564;
    iVar3 = 0x33;
    iStack_100 = 0x33;
    uVar11 = 2;
    uVar15 = 2;
    psystemPreviousNode = &puStack_108;
    puVar5 = puStack_a8;
  }
  else {
    cStackX_10 = *(char *)(_DAT_180c86870 + 0x141);
    puStack_b0 = &SystemGlobalDataReference;
    uStack_98 = 0;
    puStack_a8 = (void* *)0x0;
    uStack_a0 = 0;
    if (*(int *)(_DAT_180c86870 + 0x158) != 0) {
      iVar2 = *(int *)(_DAT_180c86870 + 0x158) + 1;
      if (iVar2 < 0x10) {
        iVar2 = 0x10;
      }
      puVar5 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)iVar2,0x13);
      *(uint8_t *)puVar5 = 0;
      puStack_a8 = puVar5;
      uVar1 = StartSystemThread(puVar5);
      uStack_98 = CONCAT44(uStack_98._4_4_,uVar1);
      if (*(int *)(lVar4 + 0x158) != 0) {
                    // WARNING: Subroutine does not return
        memcpy(puVar5,*(void* *)(lVar4 + 0x150),*(int *)(lVar4 + 0x158) + 1);
      }
    }
    if (*(long long *)(lVar4 + 0x150) != 0) {
      uStack_a0 = 0;
      if (puVar5 != (void* *)0x0) {
        *(uint8_t *)puVar5 = 0;
      }
      uStack_98 = uStack_98 & 0xffffffff;
    }
    uVar11 = 1;
    uVar15 = 1;
    psystemPreviousNode = &puStack_a8;
    puVar6 = puStack_108;
  }
  pstackParameterC = &SystemGlobalDataReference;
  uStack_78 = 0;
  puStack_88 = (uint8_t *)0x0;
  uStack_80 = 0;
  if (iVar3 != 0) {
    uVar15 = iVar3 + 1;
    uVar11 = uVar15;
    if (uVar15 < 0x10) {
      uVar11 = 0x10;
    }
    puVar8 = (uint8_t *)CreateSystemThreadObject(_DAT_180c8ed18,uVar11,0x13);
    *puVar8 = 0;
    puStack_88 = puVar8;
    uVar1 = StartSystemThread(puVar8);
    uStack_78 = CONCAT44(uStack_78._4_4_,uVar1);
                    // WARNING: Subroutine does not return
    memcpy(puVar8,*psystemPreviousNode,uVar15);
  }
  uStack_78 = 0;
  uStack_80 = 0;
  if ((uVar11 & 2) != 0) {
    uVar15 = uVar11 & 0xfffffffd;
    puStack_110 = &SystemGlobalDataReference;
    if (puVar6 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar6);
    }
    puStack_108 = (void* *)0x0;
    uStack_f8 = uStack_f8 & 0xffffffff00000000;
    puStack_110 = &SystemMemoryAllocatorReference;
    uVar11 = uVar15;
  }
  if ((uVar11 & 1) != 0) {
    uVar15 = uVar11 & 0xfffffffe;
    puStack_b0 = &SystemGlobalDataReference;
    if (puVar5 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(puVar5);
    }
    puStack_a8 = (void* *)0x0;
    uStack_98 = uStack_98 & 0xffffffff00000000;
    puStack_b0 = &SystemMemoryAllocatorReference;
  }
  puVar14 = &SystemStringTemplate;
  if (puVar13 != (undefined *)0x0) {
    puVar14 = puVar13;
  }
  FUN_180066320(0,&pstackParameterC,cStackX_10,1,puVar14,puVar10,uVar15);
  if (lStack_48 != 0) {
    FUN_18005db30();
  }
  do {
    iVar3 = ReleaseSemaphore(SystemSemaphoreHandle,1);
  } while (iVar3 == 0);
  uVar9 = __acrt_iob_func(1);
  fflush(uVar9);
  uVar9 = __acrt_iob_func(2);
  fflush(uVar9);
  pstackParameterC = &SystemGlobalDataReference;
  if (puStack_88 == (uint8_t *)0x0) {
    puStack_88 = (uint8_t *)0x0;
    uStack_78 = uStack_78 & 0xffffffff00000000;
    pstackParameterC = &SystemMemoryAllocatorReference;
    for (puVar5 = puStack_68; puVar5 != puStack_60; puVar5 = puVar5 + 4) {
      (**(code **)*puVar5)(puVar5,0);
    }
    if (puStack_68 != (void* *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_d0 = &SystemGlobalDataReference;
    if (puStack_70 != (undefined *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puStack_c8 = (undefined *)0x0;
    uStack_b8 = uStack_b8 & 0xffffffff00000000;
    puStack_d0 = &SystemMemoryAllocatorReference;
    puStack_f0 = &SystemGlobalDataReference;
    if (puStack_e8 == (undefined2 *)0x0) {
      return cStackX_10 != '\0';
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180073630(void* param_1,void* param_2)
void FUN_180073630(void* param_1,void* param_2)

{
  undefined *puVar1;
  char cVar2;
  uint32_t auStackX_18 [4];
  undefined *puStack_30;
  long long lStack_28;
  
  FUN_1800623b0(_DAT_180c86928,0,0x100000000,0,&UNK_1809ff918,param_2,0xfffffffffffffffe);
  if (DAT_180c82860 == '\0') {
    auStackX_18[0] = 0xffff0000;
    FUN_180627910(&puStack_30,param_2);
    puVar1 = *(undefined **)*_DAT_180c8ed08;
    if (puVar1 == &UNK_18098bb88) {
      cVar2 = *(int *)(_DAT_180c8a9c8 + 0xc40) != 0;
    }
    else {
      cVar2 = (**(code **)(puVar1 + 0x50))((void* *)*_DAT_180c8ed08);
    }
    if (cVar2 == '\0') {
      (**(code **)(*(long long *)_DAT_180c8ed08[1] + 0x18))
                ((long long *)_DAT_180c8ed08[1],&puStack_30,auStackX_18);
    }
    puStack_30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180073730(void* param_1,void* param_2)
void FUN_180073730(void* param_1,void* param_2)

{
  undefined *puVar1;
  char cVar2;
  uint32_t auStackX_18 [4];
  undefined *puStack_30;
  long long lStack_28;
  
  FUN_1800623b0(_DAT_180c86928,0,0x100000000,1,&UNK_1809ff938,param_2,0xfffffffffffffffe);
  if (DAT_180c82860 == '\0') {
    auStackX_18[0] = 0xff00ff00;
    FUN_180627910(&puStack_30,param_2);
    puVar1 = *(undefined **)*_DAT_180c8ed08;
    if (puVar1 == &UNK_18098bb88) {
      cVar2 = *(int *)(_DAT_180c8a9c8 + 0xc40) != 0;
    }
    else {
      cVar2 = (**(code **)(puVar1 + 0x50))((void* *)*_DAT_180c8ed08);
    }
    if (cVar2 == '\0') {
      (**(code **)(*(long long *)_DAT_180c8ed08[1] + 0x18))
                ((long long *)_DAT_180c8ed08[1],&puStack_30,auStackX_18);
    }
    puStack_30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180073830(void* param_1,uint32_t param_2,void* param_3)
void FUN_180073830(void* param_1,uint32_t param_2,void* param_3)

{
  undefined *puVar1;
  char cVar2;
  uint32_t auStackX_20 [2];
  undefined *puStack_30;
  long long lStack_28;
  
  FUN_1800623b0(_DAT_180c86928,0,0x100000000,0xc,&UNK_1809ff958,param_3,0xfffffffffffffffe);
  if (DAT_180c82860 == '\0') {
    auStackX_20[0] = param_2;
    FUN_180627910(&puStack_30,param_3);
    puVar1 = *(undefined **)*_DAT_180c8ed08;
    if (puVar1 == &UNK_18098bb88) {
      cVar2 = *(int *)(_DAT_180c8a9c8 + 0xc40) != 0;
    }
    else {
      cVar2 = (**(code **)(puVar1 + 0x50))((void* *)*_DAT_180c8ed08);
    }
    if (cVar2 == '\0') {
      (**(code **)(*(long long *)_DAT_180c8ed08[1] + 0x18))
                ((long long *)_DAT_180c8ed08[1],&puStack_30,auStackX_20);
    }
    puStack_30 = &SystemGlobalDataReference;
    if (lStack_28 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return;
}




// 函数: void FUN_180073930(void* param_1,void* param_2,void* param_3,void* param_4)
/**
 * @brief 系统回调函数管理器
 * 
 * 该函数负责管理系统回调函数的初始化和设置，处理系统全局数据引用。
 * 它会调用其他相关函数来完成回调函数的配置和清理工作。
 * 
 * @param param_1 回调函数参数1
 * @param param_2 回调函数参数2  
 * @param param_3 回调函数参数3
 * @param param_4 回调函数参数4
 */
void SystemCallbackManager(void* param_1,void* param_2,void* param_3,void* param_4)

{
  undefined *puStack_88;
  void* uStack_80;
  uint32_t uStack_78;
  void* uStack_70;
  void* uStack_68;
  void* uStack_60;
  void* uStack_58;
  uint32_t uStack_50;
  void* uStack_48;
  void* uStack_40;
  undefined2 uStack_38;
  void* uStack_36;
  void* uStack_2e;
  undefined2 uStack_26;
  void* uStack_18;
  
  uStack_18 = 0xfffffffffffffffe;
  puStack_88 = &SystemGlobalDataReference;
  uStack_70 = 0;
  uStack_80 = 0;
  uStack_78 = 0;
  uStack_68 = 0;
  uStack_60 = 0;
  uStack_58 = 0;
  uStack_50 = 3;
  uStack_38 = 0;
  uStack_48 = 0;
  uStack_40 = 0;
  uStack_26 = 0;
  uStack_36 = 0;
  uStack_2e = 0;
  FUN_180074090(&puStack_88,param_1,param_3,param_4,&uStack_68);
  FUN_180073ad0(&puStack_88,param_3);
  FUN_1800739f0(&puStack_88);
  return;
}




// 函数: void FUN_1800739f0(void* *param_1)
void FUN_1800739f0(void* *param_1)

{
  if (*(long long *)((long long)param_1 + 0x52) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)((long long)param_1 + 0x52) = 0;
  if (*(long long *)((long long)param_1 + 0x5a) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)((long long)param_1 + 0x5a) = 0;
  if (param_1[8] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[8] = 0;
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[9] = 0;
  FUN_180074a80();
  *param_1 = &SystemGlobalDataReference;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  *(uint32_t *)(param_1 + 3) = 0;
  *param_1 = &SystemMemoryAllocatorReference;
  return;
}




// 函数: void FUN_180073ab0(long long *param_1)
void FUN_180073ab0(long long *param_1)

{
  long long *plVar1;
  long long *plVar2;
  
  plVar1 = (long long *)param_1[1];
  plVar2 = (long long *)*param_1;
  while( true ) {
    if (plVar2 == plVar1) {
      if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      return;
    }
    if (*(long long *)((long long)plVar2 + 0x12) != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *(void* *)((long long)plVar2 + 0x12) = 0;
    if (*(long long *)((long long)plVar2 + 0x1a) != 0) break;
    *(void* *)((long long)plVar2 + 0x1a) = 0;
    if (*plVar2 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *plVar2 = 0;
    if (plVar2[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    plVar2[1] = 0;
    plVar2 = (long long *)((long long)plVar2 + 0x24);
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180073ad0(long long param_1,long long *param_2)
void FUN_180073ad0(long long param_1,long long *param_2)

{
  ushort uVar1;
  void* uVar2;
  int *piVar3;
  uint32_t *puVar4;
  uint *puVar5;
  long long lVar6;
  long long lVar7;
  int iVar8;
  ulong long uVar9;
  long long lVar10;
  
  FUN_180639ec0(param_2,param_1);
  lVar6 = *(long long *)(param_1 + 0x28) - *(long long *)(param_1 + 0x20);
  piVar3 = (int *)param_2[1];
  lVar6 = lVar6 / 0x12 + (lVar6 >> 0x3f);
  iVar8 = (int)(lVar6 >> 1) - (int)(lVar6 >> 0x3f);
  if ((ulong long)((*param_2 - (long long)piVar3) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)piVar3 + (4 - *param_2));
    piVar3 = (int *)param_2[1];
  }
  *piVar3 = iVar8;
  puVar4 = (uint32_t *)(param_2[1] + 4);
  param_2[1] = (long long)puVar4;
  lVar6 = (long long)iVar8;
  if (0 < iVar8) {
    lVar10 = 0;
    do {
      lVar7 = *(long long *)(param_1 + 0x20) + lVar10;
      if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
        FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
        puVar4 = (uint32_t *)param_2[1];
      }
      *puVar4 = 0;
      param_2[1] = param_2[1] + 4;
      puVar4 = (uint32_t *)param_2[1];
      if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
        FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
        puVar4 = (uint32_t *)param_2[1];
      }
      *puVar4 = 0x10;
      param_2[1] = param_2[1] + 4;
      puVar5 = (uint *)param_2[1];
      uVar1 = *(ushort *)(lVar7 + 0x10);
      if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
        FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
        puVar5 = (uint *)param_2[1];
      }
      *puVar5 = (uint)uVar1;
      puVar4 = (uint32_t *)(param_2[1] + 4);
      param_2[1] = (long long)puVar4;
      if (*(ushort *)(lVar7 + 0x10) != 0) {
        uVar2 = *(void* *)(lVar7 + 8);
        uVar9 = (ulong long)*(ushort *)(lVar7 + 0x10) * 4;
        if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) <= uVar9) {
          FUN_180639bf0(param_2,(long long)puVar4 + (uVar9 - *param_2));
          puVar4 = (uint32_t *)param_2[1];
        }
                    // WARNING: Subroutine does not return
        memcpy(puVar4,uVar2,uVar9);
      }
      lVar7 = *(long long *)(param_1 + 0x20) + lVar10;
      if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
        FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
        puVar4 = (uint32_t *)param_2[1];
      }
      *puVar4 = 0;
      param_2[1] = param_2[1] + 4;
      puVar4 = (uint32_t *)param_2[1];
      if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
        FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
        puVar4 = (uint32_t *)param_2[1];
      }
      *puVar4 = 0x10;
      param_2[1] = param_2[1] + 4;
      puVar5 = (uint *)param_2[1];
      uVar1 = *(ushort *)(lVar7 + 0x22);
      if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
        FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
        puVar5 = (uint *)param_2[1];
      }
      *puVar5 = (uint)uVar1;
      puVar4 = (uint32_t *)(param_2[1] + 4);
      param_2[1] = (long long)puVar4;
      if (*(ushort *)(lVar7 + 0x22) != 0) {
        uVar2 = *(void* *)(lVar7 + 0x1a);
        uVar9 = (ulong long)*(ushort *)(lVar7 + 0x22) * 4;
        if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) <= uVar9) {
          FUN_180639bf0(param_2,(long long)puVar4 + (uVar9 - *param_2));
          puVar4 = (uint32_t *)param_2[1];
        }
                    // WARNING: Subroutine does not return
        memcpy(puVar4,uVar2,uVar9);
      }
      lVar10 = lVar10 + 0x24;
      lVar6 = lVar6 + -1;
    } while (lVar6 != 0);
  }
  if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
    puVar4 = (uint32_t *)param_2[1];
  }
  *puVar4 = 0;
  param_2[1] = param_2[1] + 4;
  puVar4 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
    puVar4 = (uint32_t *)param_2[1];
  }
  *puVar4 = 0x10;
  param_2[1] = param_2[1] + 4;
  puVar5 = (uint *)param_2[1];
  uVar1 = *(ushort *)(param_1 + 0x50);
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
    puVar5 = (uint *)param_2[1];
  }
  *puVar5 = (uint)uVar1;
  puVar4 = (uint32_t *)(param_2[1] + 4);
  param_2[1] = (long long)puVar4;
  if (*(ushort *)(param_1 + 0x50) != 0) {
    uVar2 = *(void* *)(param_1 + 0x48);
    uVar9 = (ulong long)*(ushort *)(param_1 + 0x50) * 4;
    if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) <= uVar9) {
      FUN_180639bf0(param_2,(long long)puVar4 + (uVar9 - *param_2));
      puVar4 = (uint32_t *)param_2[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(puVar4,uVar2,uVar9);
  }
  if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
    puVar4 = (uint32_t *)param_2[1];
  }
  *puVar4 = 0;
  param_2[1] = param_2[1] + 4;
  puVar4 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar4) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar4 + (4 - *param_2));
    puVar4 = (uint32_t *)param_2[1];
  }
  *puVar4 = 0x10;
  param_2[1] = param_2[1] + 4;
  puVar5 = (uint *)param_2[1];
  uVar1 = *(ushort *)(param_1 + 0x62);
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
    puVar5 = (uint *)param_2[1];
  }
  *puVar5 = (uint)uVar1;
  lVar6 = param_2[1] + 4;
  param_2[1] = lVar6;
  if (*(ushort *)(param_1 + 0x62) == 0) {
    return;
  }
  uVar2 = *(void* *)(param_1 + 0x5a);
  uVar9 = (ulong long)*(ushort *)(param_1 + 0x62) * 4;
  if ((ulong long)((*param_2 - lVar6) + param_2[2]) <= uVar9) {
    FUN_180639bf0(param_2,uVar9 + (lVar6 - *param_2));
    lVar6 = param_2[1];
  }
                    // WARNING: Subroutine does not return
  memcpy(lVar6,uVar2,uVar9);
}




// 函数: void FUN_180073adc(long long param_1)
void FUN_180073adc(long long param_1)

{
  ushort uVar1;
  void* uVar2;
  int *piVar3;
  uint32_t *puVar4;
  uint *puVar5;
  long long lVar6;
  long long *unaff_RBX;
  long long lVar7;
  int iVar8;
  ulong long uVar9;
  long long lVar10;
  
  FUN_180639ec0();
  lVar6 = *(long long *)(param_1 + 0x28) - *(long long *)(param_1 + 0x20);
  piVar3 = (int *)unaff_RBX[1];
  lVar6 = lVar6 / 0x12 + (lVar6 >> 0x3f);
  iVar8 = (int)(lVar6 >> 1) - (int)(lVar6 >> 0x3f);
  if ((ulong long)((*unaff_RBX - (long long)piVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    piVar3 = (int *)unaff_RBX[1];
  }
  *piVar3 = iVar8;
  puVar4 = (uint32_t *)(unaff_RBX[1] + 4);
  unaff_RBX[1] = (long long)puVar4;
  lVar6 = (long long)iVar8;
  if (0 < iVar8) {
    lVar10 = 0;
    do {
      lVar7 = *(long long *)(param_1 + 0x20) + lVar10;
      if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
        FUN_180639bf0();
        puVar4 = (uint32_t *)unaff_RBX[1];
      }
      *puVar4 = 0;
      unaff_RBX[1] = unaff_RBX[1] + 4;
      puVar4 = (uint32_t *)unaff_RBX[1];
      if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
        FUN_180639bf0();
        puVar4 = (uint32_t *)unaff_RBX[1];
      }
      *puVar4 = 0x10;
      unaff_RBX[1] = unaff_RBX[1] + 4;
      puVar5 = (uint *)unaff_RBX[1];
      uVar1 = *(ushort *)(lVar7 + 0x10);
      if ((ulong long)((*unaff_RBX - (long long)puVar5) + unaff_RBX[2]) < 5) {
        FUN_180639bf0();
        puVar5 = (uint *)unaff_RBX[1];
      }
      *puVar5 = (uint)uVar1;
      puVar4 = (uint32_t *)(unaff_RBX[1] + 4);
      unaff_RBX[1] = (long long)puVar4;
      if (*(ushort *)(lVar7 + 0x10) != 0) {
        uVar2 = *(void* *)(lVar7 + 8);
        uVar9 = (ulong long)*(ushort *)(lVar7 + 0x10) * 4;
        if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) <= uVar9) {
          FUN_180639bf0();
          puVar4 = (uint32_t *)unaff_RBX[1];
        }
                    // WARNING: Subroutine does not return
        memcpy(puVar4,uVar2,uVar9);
      }
      lVar7 = *(long long *)(param_1 + 0x20) + lVar10;
      if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
        FUN_180639bf0();
        puVar4 = (uint32_t *)unaff_RBX[1];
      }
      *puVar4 = 0;
      unaff_RBX[1] = unaff_RBX[1] + 4;
      puVar4 = (uint32_t *)unaff_RBX[1];
      if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
        FUN_180639bf0();
        puVar4 = (uint32_t *)unaff_RBX[1];
      }
      *puVar4 = 0x10;
      unaff_RBX[1] = unaff_RBX[1] + 4;
      puVar5 = (uint *)unaff_RBX[1];
      uVar1 = *(ushort *)(lVar7 + 0x22);
      if ((ulong long)((*unaff_RBX - (long long)puVar5) + unaff_RBX[2]) < 5) {
        FUN_180639bf0();
        puVar5 = (uint *)unaff_RBX[1];
      }
      *puVar5 = (uint)uVar1;
      puVar4 = (uint32_t *)(unaff_RBX[1] + 4);
      unaff_RBX[1] = (long long)puVar4;
      if (*(ushort *)(lVar7 + 0x22) != 0) {
        uVar2 = *(void* *)(lVar7 + 0x1a);
        uVar9 = (ulong long)*(ushort *)(lVar7 + 0x22) * 4;
        if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) <= uVar9) {
          FUN_180639bf0();
          puVar4 = (uint32_t *)unaff_RBX[1];
        }
                    // WARNING: Subroutine does not return
        memcpy(puVar4,uVar2,uVar9);
      }
      lVar10 = lVar10 + 0x24;
      lVar6 = lVar6 + -1;
    } while (lVar6 != 0);
  }
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint32_t *)unaff_RBX[1];
  }
  *puVar4 = 0;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint32_t *)unaff_RBX[1];
  }
  *puVar4 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar5 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(param_1 + 0x50);
  if ((ulong long)((*unaff_RBX - (long long)puVar5) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar5 = (uint *)unaff_RBX[1];
  }
  *puVar5 = (uint)uVar1;
  puVar4 = (uint32_t *)(unaff_RBX[1] + 4);
  unaff_RBX[1] = (long long)puVar4;
  if (*(ushort *)(param_1 + 0x50) != 0) {
    uVar2 = *(void* *)(param_1 + 0x48);
    uVar9 = (ulong long)*(ushort *)(param_1 + 0x50) * 4;
    if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) <= uVar9) {
      FUN_180639bf0();
      puVar4 = (uint32_t *)unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(puVar4,uVar2,uVar9);
  }
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint32_t *)unaff_RBX[1];
  }
  *puVar4 = 0;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint32_t *)unaff_RBX[1];
  }
  *puVar4 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar5 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(param_1 + 0x62);
  if ((ulong long)((*unaff_RBX - (long long)puVar5) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar5 = (uint *)unaff_RBX[1];
  }
  *puVar5 = (uint)uVar1;
  lVar6 = unaff_RBX[1] + 4;
  unaff_RBX[1] = lVar6;
  if (*(ushort *)(param_1 + 0x62) == 0) {
    return;
  }
  uVar2 = *(void* *)(param_1 + 0x5a);
  uVar9 = (ulong long)*(ushort *)(param_1 + 0x62) * 4;
  if ((ulong long)((*unaff_RBX - lVar6) + unaff_RBX[2]) <= uVar9) {
    FUN_180639bf0();
    lVar6 = unaff_RBX[1];
  }
                    // WARNING: Subroutine does not return
  memcpy(lVar6,uVar2,uVar9);
}




// 函数: void FUN_180073b64(uint *param_1)
void FUN_180073b64(uint *param_1)

{
  ushort uVar1;
  void* uVar2;
  uint32_t *puVar3;
  uint *puVar4;
  long long *unaff_RBX;
  long long systemTimeValue;
  ulong long uVar6;
  long long unaff_R12;
  uint unaff_R13D;
  long long unaff_R15;
  
  uVar6 = (ulong long)unaff_R13D;
  do {
    lVar5 = *(long long *)(unaff_R15 + 0x20) + uVar6;
    if ((ulong long)((*unaff_RBX - (long long)param_1) + unaff_RBX[2]) < 5) {
      FUN_180639bf0();
      param_1 = (uint *)unaff_RBX[1];
    }
    *param_1 = unaff_R13D;
    unaff_RBX[1] = unaff_RBX[1] + 4;
    puVar3 = (uint32_t *)unaff_RBX[1];
    if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
      FUN_180639bf0();
      puVar3 = (uint32_t *)unaff_RBX[1];
    }
    *puVar3 = 0x10;
    unaff_RBX[1] = unaff_RBX[1] + 4;
    puVar4 = (uint *)unaff_RBX[1];
    uVar1 = *(ushort *)(lVar5 + 0x10);
    if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
      FUN_180639bf0();
      puVar4 = (uint *)unaff_RBX[1];
    }
    *puVar4 = (uint)uVar1;
    puVar4 = (uint *)(unaff_RBX[1] + 4);
    unaff_RBX[1] = (long long)puVar4;
    if (*(ushort *)(lVar5 + 0x10) != 0) {
      uVar2 = *(void* *)(lVar5 + 8);
      uVar6 = (ulong long)*(ushort *)(lVar5 + 0x10) * 4;
      if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) <= uVar6) {
        FUN_180639bf0();
        puVar4 = (uint *)unaff_RBX[1];
      }
                    // WARNING: Subroutine does not return
      memcpy(puVar4,uVar2,uVar6);
    }
    lVar5 = *(long long *)(unaff_R15 + 0x20) + uVar6;
    if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
      FUN_180639bf0();
      puVar4 = (uint *)unaff_RBX[1];
    }
    *puVar4 = unaff_R13D;
    unaff_RBX[1] = unaff_RBX[1] + 4;
    puVar3 = (uint32_t *)unaff_RBX[1];
    if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
      FUN_180639bf0();
      puVar3 = (uint32_t *)unaff_RBX[1];
    }
    *puVar3 = 0x10;
    unaff_RBX[1] = unaff_RBX[1] + 4;
    puVar4 = (uint *)unaff_RBX[1];
    uVar1 = *(ushort *)(lVar5 + 0x22);
    if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
      FUN_180639bf0();
      puVar4 = (uint *)unaff_RBX[1];
    }
    *puVar4 = (uint)uVar1;
    param_1 = (uint *)(unaff_RBX[1] + 4);
    unaff_RBX[1] = (long long)param_1;
    if (*(ushort *)(lVar5 + 0x22) != 0) {
      uVar2 = *(void* *)(lVar5 + 0x1a);
      uVar6 = (ulong long)*(ushort *)(lVar5 + 0x22) * 4;
      if ((ulong long)((*unaff_RBX - (long long)param_1) + unaff_RBX[2]) <= uVar6) {
        FUN_180639bf0();
        param_1 = (uint *)unaff_RBX[1];
      }
                    // WARNING: Subroutine does not return
      memcpy(param_1,uVar2,uVar6);
    }
    uVar6 = uVar6 + 0x24;
    unaff_R12 = unaff_R12 + -1;
  } while (unaff_R12 != 0);
  if ((ulong long)((*unaff_RBX - (long long)param_1) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    param_1 = (uint *)unaff_RBX[1];
  }
  *param_1 = unaff_R13D;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x50);
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = (uint)uVar1;
  puVar4 = (uint *)(unaff_RBX[1] + 4);
  unaff_RBX[1] = (long long)puVar4;
  if (*(ushort *)(unaff_R15 + 0x50) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x48);
    uVar6 = (ulong long)*(ushort *)(unaff_R15 + 0x50) * 4;
    if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) <= uVar6) {
      FUN_180639bf0();
      puVar4 = (uint *)unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(puVar4,uVar2,uVar6);
  }
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = unaff_R13D;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x62);
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = (uint)uVar1;
  lVar5 = unaff_RBX[1] + 4;
  unaff_RBX[1] = lVar5;
  if (*(ushort *)(unaff_R15 + 0x62) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x5a);
    uVar6 = (ulong long)*(ushort *)(unaff_R15 + 0x62) * 4;
    if ((ulong long)((*unaff_RBX - lVar5) + unaff_RBX[2]) <= uVar6) {
      FUN_180639bf0();
      lVar5 = unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(lVar5,uVar2,uVar6);
  }
  return;
}




// 函数: void FUN_180073e0b(uint32_t *param_1)
void FUN_180073e0b(uint32_t *param_1)

{
  ushort uVar1;
  void* uVar2;
  uint32_t *puVar3;
  uint *puVar4;
  long long systemTimeValue;
  long long *unaff_RBX;
  ulong long uVar6;
  uint32_t unaff_R13D;
  long long unaff_R15;
  
  if ((ulong long)((*unaff_RBX - (long long)param_1) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    param_1 = (uint32_t *)unaff_RBX[1];
  }
  *param_1 = unaff_R13D;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x50);
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = (uint)uVar1;
  puVar3 = (uint32_t *)(unaff_RBX[1] + 4);
  unaff_RBX[1] = (long long)puVar3;
  if (*(ushort *)(unaff_R15 + 0x50) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x48);
    uVar6 = (ulong long)*(ushort *)(unaff_R15 + 0x50) * 4;
    if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) <= uVar6) {
      FUN_180639bf0();
      puVar3 = (uint32_t *)unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(puVar3,uVar2,uVar6);
  }
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = unaff_R13D;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x62);
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = (uint)uVar1;
  lVar5 = unaff_RBX[1] + 4;
  unaff_RBX[1] = lVar5;
  if (*(ushort *)(unaff_R15 + 0x62) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x5a);
    uVar6 = (ulong long)*(ushort *)(unaff_R15 + 0x62) * 4;
    if ((ulong long)((*unaff_RBX - lVar5) + unaff_RBX[2]) <= uVar6) {
      FUN_180639bf0();
      lVar5 = unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(lVar5,uVar2,uVar6);
  }
  return;
}




// 函数: void FUN_180073e23(void)
void FUN_180073e23(void)

{
  ushort uVar1;
  void* uVar2;
  uint32_t *puVar3;
  uint *puVar4;
  long long systemTimeValue;
  long long *unaff_RBX;
  ulong long uVar6;
  uint32_t unaff_R13D;
  long long unaff_R15;
  
  FUN_180639bf0();
  *(uint32_t *)unaff_RBX[1] = unaff_R13D;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x50);
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = (uint)uVar1;
  puVar3 = (uint32_t *)(unaff_RBX[1] + 4);
  unaff_RBX[1] = (long long)puVar3;
  if (*(ushort *)(unaff_R15 + 0x50) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x48);
    uVar6 = (ulong long)*(ushort *)(unaff_R15 + 0x50) * 4;
    if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) <= uVar6) {
      FUN_180639bf0();
      puVar3 = (uint32_t *)unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(puVar3,uVar2,uVar6);
  }
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = unaff_R13D;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint32_t *)unaff_RBX[1];
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint32_t *)unaff_RBX[1];
  }
  *puVar3 = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar4 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x62);
  if ((ulong long)((*unaff_RBX - (long long)puVar4) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar4 = (uint *)unaff_RBX[1];
  }
  *puVar4 = (uint)uVar1;
  lVar5 = unaff_RBX[1] + 4;
  unaff_RBX[1] = lVar5;
  if (*(ushort *)(unaff_R15 + 0x62) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x5a);
    uVar6 = (ulong long)*(ushort *)(unaff_R15 + 0x62) * 4;
    if ((ulong long)((*unaff_RBX - lVar5) + unaff_RBX[2]) <= uVar6) {
      FUN_180639bf0();
      lVar5 = unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(lVar5,uVar2,uVar6);
  }
  return;
}




// 函数: void FUN_180073f90(void)
void FUN_180073f90(void)

{
  ushort uVar1;
  void* uVar2;
  uint *puVar3;
  long long lVar4;
  long long *unaff_RBX;
  ulong long uVar5;
  long long unaff_R15;
  
  FUN_180639bf0();
  *(uint32_t *)unaff_RBX[1] = 0x10;
  unaff_RBX[1] = unaff_RBX[1] + 4;
  puVar3 = (uint *)unaff_RBX[1];
  uVar1 = *(ushort *)(unaff_R15 + 0x62);
  if ((ulong long)((*unaff_RBX - (long long)puVar3) + unaff_RBX[2]) < 5) {
    FUN_180639bf0();
    puVar3 = (uint *)unaff_RBX[1];
  }
  *puVar3 = (uint)uVar1;
  lVar4 = unaff_RBX[1] + 4;
  unaff_RBX[1] = lVar4;
  if (*(ushort *)(unaff_R15 + 0x62) != 0) {
    uVar2 = *(void* *)(unaff_R15 + 0x5a);
    uVar5 = (ulong long)*(ushort *)(unaff_R15 + 0x62) * 4;
    if ((ulong long)((*unaff_RBX - lVar4) + unaff_RBX[2]) <= uVar5) {
      FUN_180639bf0();
      lVar4 = unaff_RBX[1];
    }
                    // WARNING: Subroutine does not return
    memcpy(lVar4,uVar2,uVar5);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180074090(long long *param_1,long long param_2)
void FUN_180074090(long long *param_1,long long param_2)

{
  long long *plVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  long long systemTimeValue;
  ulong long uVar6;
  long long lVar7;
  long long lVar8;
  uint *puVar9;
  long long lVar10;
  long long lVar11;
  long long *plVar12;
  
  uVar3 = **(uint **)(param_2 + 8);
  puVar9 = *(uint **)(param_2 + 8) + 1;
  *(uint **)(param_2 + 8) = puVar9;
  if (uVar3 != 0) {
    (**(code **)(*param_1 + 0x18))(param_1,puVar9,uVar3);
    *(long long *)(param_2 + 8) = *(long long *)(param_2 + 8) + (ulong long)uVar3;
    puVar9 = *(uint **)(param_2 + 8);
  }
  lVar8 = (long long)(int)*puVar9;
  *(uint **)(param_2 + 8) = puVar9 + 1;
  plVar1 = param_1 + 4;
  FUN_180074b30(plVar1,lVar8);
  lVar5 = *(long long *)(param_2 + 8);
  lVar7 = 0;
  lVar11 = lVar7;
  if (0 < lVar8) {
    do {
      lVar10 = *plVar1;
      *(int **)(param_2 + 8) = (int *)(lVar5 + 8);
      iVar4 = *(int *)(lVar5 + 8);
      plVar12 = (long long *)(lVar10 + lVar11);
      *(long long *)(param_2 + 8) = lVar5 + 0xc;
      if (0 < iVar4) {
        *(short *)(plVar12 + 2) = (short)iVar4;
        if (plVar12[1] != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        plVar12[1] = 0;
        if (*plVar12 == 0) {
          *plVar12 = 0;
          if ((ulong long)*(ushort *)(plVar12 + 2) == 0) {
            uVar6 = 0;
            lVar5 = lVar7;
          }
          else {
            lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(plVar12 + 2) * 4,4);
            uVar6 = (ulong long)*(ushort *)(plVar12 + 2);
          }
          plVar12[1] = lVar5;
          if (uVar6 != 0) {
            lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
          }
          *plVar12 = lVar7;
                    // WARNING: Subroutine does not return
          memcpy(plVar12[1],*(void* *)(param_2 + 8),(long long)(iVar4 * 4));
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lVar10 = *plVar1;
      piVar2 = (int *)(lVar5 + 0x14);
      *(int **)(param_2 + 8) = piVar2;
      lVar5 = lVar5 + 0x18;
      iVar4 = *piVar2;
      lVar10 = lVar10 + lVar11;
      *(long long *)(param_2 + 8) = lVar5;
      if (0 < iVar4) {
        *(short *)(lVar10 + 0x22) = (short)iVar4;
        if (*(long long *)(lVar10 + 0x1a) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)(lVar10 + 0x1a) = 0;
        if (*(long long *)(lVar10 + 0x12) == 0) {
          *(void* *)(lVar10 + 0x12) = 0;
          if ((ulong long)*(ushort *)(lVar10 + 0x22) == 0) {
            uVar6 = 0;
            lVar5 = lVar7;
          }
          else {
            lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(lVar10 + 0x22) * 4,4);
            uVar6 = (ulong long)*(ushort *)(lVar10 + 0x22);
          }
          *(long long *)(lVar10 + 0x1a) = lVar5;
          if (uVar6 != 0) {
            lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
          }
          *(long long *)(lVar10 + 0x12) = lVar7;
                    // WARNING: Subroutine does not return
          memcpy(*(void* *)(lVar10 + 0x1a),*(void* *)(param_2 + 8),(long long)(iVar4 * 4));
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lVar8 = lVar8 + -1;
      lVar11 = lVar11 + 0x24;
    } while (lVar8 != 0);
  }
  *(int **)(param_2 + 8) = (int *)(lVar5 + 8);
  iVar4 = *(int *)(lVar5 + 8);
  *(long long *)(param_2 + 8) = lVar5 + 0xc;
  if (iVar4 < 1) {
    *(int **)(param_2 + 8) = (int *)(lVar5 + 0x14);
    iVar4 = *(int *)(lVar5 + 0x14);
    *(long long *)(param_2 + 8) = lVar5 + 0x18;
    if (iVar4 < 1) {
      return;
    }
    *(short *)((long long)param_1 + 0x62) = (short)iVar4;
    if (*(long long *)((long long)param_1 + 0x5a) == 0) {
      *(void* *)((long long)param_1 + 0x5a) = 0;
      if (*(long long *)((long long)param_1 + 0x52) == 0) {
        *(void* *)((long long)param_1 + 0x52) = 0;
        if ((ulong long)*(ushort *)((long long)param_1 + 0x62) == 0) {
          uVar6 = 0;
          lVar5 = lVar7;
        }
        else {
          lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)((long long)param_1 + 0x62) * 4,
                                4);
          uVar6 = (ulong long)*(ushort *)((long long)param_1 + 0x62);
        }
        *(long long *)((long long)param_1 + 0x5a) = lVar5;
        if (uVar6 != 0) {
          lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
        }
        *(long long *)((long long)param_1 + 0x52) = lVar7;
                    // WARNING: Subroutine does not return
        memcpy(*(void* *)((long long)param_1 + 0x5a),*(void* *)(param_2 + 8),
               (long long)(iVar4 * 4));
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(short *)(param_1 + 10) = (short)iVar4;
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[9] = 0;
  if (param_1[8] == 0) {
    param_1[8] = 0;
    if ((ulong long)*(ushort *)(param_1 + 10) == 0) {
      uVar6 = 0;
      lVar5 = lVar7;
    }
    else {
      lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(param_1 + 10) * 4,4);
      uVar6 = (ulong long)*(ushort *)(param_1 + 10);
    }
    param_1[9] = lVar5;
    if (uVar6 != 0) {
      lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
    }
    param_1[8] = lVar7;
                    // WARNING: Subroutine does not return
    memcpy(param_1[9],*(void* *)(param_2 + 8),(long long)(iVar4 * 4));
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800740a2(long long *param_1)
void FUN_1800740a2(long long *param_1)

{
  long long *plVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  uint *in_RAX;
  long long systemTimeValue;
  ulong long uVar6;
  long long lVar7;
  long long lVar8;
  uint *puVar9;
  long long lVar10;
  long long unaff_RDI;
  long long lVar11;
  long long *plVar12;
  
  uVar3 = *in_RAX;
  puVar9 = in_RAX + 1;
  *(uint **)(unaff_RDI + 8) = puVar9;
  if (uVar3 != 0) {
    (**(code **)(*param_1 + 0x18))(param_1,puVar9,uVar3);
    *(long long *)(unaff_RDI + 8) = *(long long *)(unaff_RDI + 8) + (ulong long)uVar3;
    puVar9 = *(uint **)(unaff_RDI + 8);
  }
  lVar8 = (long long)(int)*puVar9;
  *(uint **)(unaff_RDI + 8) = puVar9 + 1;
  plVar1 = param_1 + 4;
  FUN_180074b30(plVar1,lVar8);
  lVar5 = *(long long *)(unaff_RDI + 8);
  lVar7 = 0;
  lVar11 = lVar7;
  if (0 < lVar8) {
    do {
      lVar10 = *plVar1;
      *(int **)(unaff_RDI + 8) = (int *)(lVar5 + 8);
      iVar4 = *(int *)(lVar5 + 8);
      plVar12 = (long long *)(lVar10 + lVar11);
      *(long long *)(unaff_RDI + 8) = lVar5 + 0xc;
      if (0 < iVar4) {
        *(short *)(plVar12 + 2) = (short)iVar4;
        if (plVar12[1] != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        plVar12[1] = 0;
        if (*plVar12 == 0) {
          *plVar12 = 0;
          if ((ulong long)*(ushort *)(plVar12 + 2) == 0) {
            uVar6 = 0;
            lVar5 = lVar7;
          }
          else {
            lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(plVar12 + 2) * 4,4);
            uVar6 = (ulong long)*(ushort *)(plVar12 + 2);
          }
          plVar12[1] = lVar5;
          if (uVar6 != 0) {
            lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
          }
          *plVar12 = lVar7;
                    // WARNING: Subroutine does not return
          memcpy(plVar12[1],*(void* *)(unaff_RDI + 8),(long long)(iVar4 * 4));
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lVar10 = *plVar1;
      piVar2 = (int *)(lVar5 + 0x14);
      *(int **)(unaff_RDI + 8) = piVar2;
      lVar5 = lVar5 + 0x18;
      iVar4 = *piVar2;
      lVar10 = lVar10 + lVar11;
      *(long long *)(unaff_RDI + 8) = lVar5;
      if (0 < iVar4) {
        *(short *)(lVar10 + 0x22) = (short)iVar4;
        if (*(long long *)(lVar10 + 0x1a) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)(lVar10 + 0x1a) = 0;
        if (*(long long *)(lVar10 + 0x12) == 0) {
          *(void* *)(lVar10 + 0x12) = 0;
          if ((ulong long)*(ushort *)(lVar10 + 0x22) == 0) {
            uVar6 = 0;
            lVar5 = lVar7;
          }
          else {
            lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(lVar10 + 0x22) * 4,4);
            uVar6 = (ulong long)*(ushort *)(lVar10 + 0x22);
          }
          *(long long *)(lVar10 + 0x1a) = lVar5;
          if (uVar6 != 0) {
            lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
          }
          *(long long *)(lVar10 + 0x12) = lVar7;
                    // WARNING: Subroutine does not return
          memcpy(*(void* *)(lVar10 + 0x1a),*(void* *)(unaff_RDI + 8),(long long)(iVar4 * 4)
                );
        }
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      lVar8 = lVar8 + -1;
      lVar11 = lVar11 + 0x24;
    } while (lVar8 != 0);
  }
  *(int **)(unaff_RDI + 8) = (int *)(lVar5 + 8);
  iVar4 = *(int *)(lVar5 + 8);
  *(long long *)(unaff_RDI + 8) = lVar5 + 0xc;
  if (iVar4 < 1) {
    *(int **)(unaff_RDI + 8) = (int *)(lVar5 + 0x14);
    iVar4 = *(int *)(lVar5 + 0x14);
    *(long long *)(unaff_RDI + 8) = lVar5 + 0x18;
    if (iVar4 < 1) {
      return;
    }
    *(short *)((long long)param_1 + 0x62) = (short)iVar4;
    if (*(long long *)((long long)param_1 + 0x5a) == 0) {
      *(void* *)((long long)param_1 + 0x5a) = 0;
      if (*(long long *)((long long)param_1 + 0x52) == 0) {
        *(void* *)((long long)param_1 + 0x52) = 0;
        if ((ulong long)*(ushort *)((long long)param_1 + 0x62) == 0) {
          uVar6 = 0;
          lVar5 = lVar7;
        }
        else {
          lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)((long long)param_1 + 0x62) * 4,
                                4);
          uVar6 = (ulong long)*(ushort *)((long long)param_1 + 0x62);
        }
        *(long long *)((long long)param_1 + 0x5a) = lVar5;
        if (uVar6 != 0) {
          lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
        }
        *(long long *)((long long)param_1 + 0x52) = lVar7;
                    // WARNING: Subroutine does not return
        memcpy(*(void* *)((long long)param_1 + 0x5a),*(void* *)(unaff_RDI + 8),
               (long long)(iVar4 * 4));
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(short *)(param_1 + 10) = (short)iVar4;
  if (param_1[9] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[9] = 0;
  if (param_1[8] == 0) {
    param_1[8] = 0;
    if ((ulong long)*(ushort *)(param_1 + 10) == 0) {
      uVar6 = 0;
      lVar5 = lVar7;
    }
    else {
      lVar5 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(param_1 + 10) * 4,4);
      uVar6 = (ulong long)*(ushort *)(param_1 + 10);
    }
    param_1[9] = lVar5;
    if (uVar6 != 0) {
      lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,uVar6 << 4,4);
    }
    param_1[8] = lVar7;
                    // WARNING: Subroutine does not return
    memcpy(param_1[9],*(void* *)(unaff_RDI + 8),(long long)(iVar4 * 4));
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800740f5(long long param_1)
void FUN_1800740f5(long long param_1)

{
  int iVar1;
  ulong long uVar2;
  long long lVar3;
  long long *unaff_RBX;
  long long lVar4;
  ulong long unaff_RSI;
  long long unaff_RDI;
  ulong long uVar5;
  long long unaff_R13;
  ulong long *puVar6;
  long long unaff_R15;
  
  uVar5 = unaff_RSI & 0xffffffff;
  do {
    lVar3 = param_1;
    lVar4 = *unaff_RBX;
    *(int **)(unaff_RDI + 8) = (int *)(lVar3 + 8);
    iVar1 = *(int *)(lVar3 + 8);
    puVar6 = (ulong long *)(lVar4 + uVar5);
    *(long long *)(unaff_RDI + 8) = lVar3 + 0xc;
    if (0 < iVar1) {
      *(short *)(puVar6 + 2) = (short)iVar1;
      if (puVar6[1] != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      puVar6[1] = unaff_RSI;
      if (*puVar6 == 0) {
        *puVar6 = unaff_RSI;
        if ((ulong long)(ushort)puVar6[2] == 0) {
          uVar5 = 0;
          uVar2 = unaff_RSI;
        }
        else {
          uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)(ushort)puVar6[2] * 4,4);
          uVar5 = (ulong long)(ushort)puVar6[2];
        }
        puVar6[1] = uVar2;
        if (uVar5 != 0) {
          unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar5 << 4,4);
        }
        *puVar6 = unaff_RSI;
                    // WARNING: Subroutine does not return
        memcpy(puVar6[1],*(void* *)(unaff_RDI + 8),(long long)(iVar1 * 4));
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    lVar4 = *unaff_RBX;
    *(int **)(unaff_RDI + 8) = (int *)(lVar3 + 0x14);
    iVar1 = *(int *)(lVar3 + 0x14);
    lVar4 = lVar4 + uVar5;
    *(long long *)(unaff_RDI + 8) = lVar3 + 0x18;
    if (0 < iVar1) {
      *(short *)(lVar4 + 0x22) = (short)iVar1;
      if (*(long long *)(lVar4 + 0x1a) != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *(ulong long *)(lVar4 + 0x1a) = unaff_RSI;
      if (*(long long *)(lVar4 + 0x12) == 0) {
        *(ulong long *)(lVar4 + 0x12) = unaff_RSI;
        if ((ulong long)*(ushort *)(lVar4 + 0x22) == 0) {
          uVar5 = 0;
          uVar2 = unaff_RSI;
        }
        else {
          uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(lVar4 + 0x22) * 4,4);
          uVar5 = (ulong long)*(ushort *)(lVar4 + 0x22);
        }
        *(ulong long *)(lVar4 + 0x1a) = uVar2;
        if (uVar5 != 0) {
          unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar5 << 4,4);
        }
        *(ulong long *)(lVar4 + 0x12) = unaff_RSI;
                    // WARNING: Subroutine does not return
        memcpy(*(void* *)(lVar4 + 0x1a),*(void* *)(unaff_RDI + 8),(long long)(iVar1 * 4));
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    uVar5 = uVar5 + 0x24;
    unaff_R13 = unaff_R13 + -1;
    param_1 = lVar3 + 0x18;
  } while (unaff_R13 != 0);
  *(int **)(unaff_RDI + 8) = (int *)(lVar3 + 0x20);
  iVar1 = *(int *)(lVar3 + 0x20);
  *(long long *)(unaff_RDI + 8) = lVar3 + 0x24;
  if (iVar1 < 1) {
    *(int **)(unaff_RDI + 8) = (int *)(lVar3 + 0x2c);
    iVar1 = *(int *)(lVar3 + 0x2c);
    *(long long *)(unaff_RDI + 8) = lVar3 + 0x30;
    if (iVar1 < 1) {
      return;
    }
    *(short *)(unaff_R15 + 0x62) = (short)iVar1;
    if (*(long long *)(unaff_R15 + 0x5a) == 0) {
      *(ulong long *)(unaff_R15 + 0x5a) = unaff_RSI;
      if (*(long long *)(unaff_R15 + 0x52) == 0) {
        *(ulong long *)(unaff_R15 + 0x52) = unaff_RSI;
        if ((ulong long)*(ushort *)(unaff_R15 + 0x62) == 0) {
          uVar5 = 0;
          uVar2 = unaff_RSI;
        }
        else {
          uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(unaff_R15 + 0x62) * 4,4);
          uVar5 = (ulong long)*(ushort *)(unaff_R15 + 0x62);
        }
        *(ulong long *)(unaff_R15 + 0x5a) = uVar2;
        if (uVar5 != 0) {
          unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar5 << 4,4);
        }
        *(ulong long *)(unaff_R15 + 0x52) = unaff_RSI;
                    // WARNING: Subroutine does not return
        memcpy(*(void* *)(unaff_R15 + 0x5a),*(void* *)(unaff_RDI + 8),
               (long long)(iVar1 * 4));
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(short *)(unaff_R15 + 0x50) = (short)iVar1;
  if (*(long long *)(unaff_R15 + 0x48) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(ulong long *)(unaff_R15 + 0x48) = unaff_RSI;
  if (*(long long *)(unaff_R15 + 0x40) == 0) {
    *(ulong long *)(unaff_R15 + 0x40) = unaff_RSI;
    if ((ulong long)*(ushort *)(unaff_R15 + 0x50) == 0) {
      uVar5 = 0;
      uVar2 = unaff_RSI;
    }
    else {
      uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(unaff_R15 + 0x50) * 4,4);
      uVar5 = (ulong long)*(ushort *)(unaff_R15 + 0x50);
    }
    *(ulong long *)(unaff_R15 + 0x48) = uVar2;
    if (uVar5 != 0) {
      unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar5 << 4,4);
    }
    *(ulong long *)(unaff_R15 + 0x40) = unaff_RSI;
                    // WARNING: Subroutine does not return
    memcpy(*(void* *)(unaff_R15 + 0x48),*(void* *)(unaff_RDI + 8),(long long)(iVar1 * 4));
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800742ea(long long param_1)
void FUN_1800742ea(long long param_1)

{
  int iVar1;
  void* uVar2;
  ulong long uVar3;
  void* unaff_RSI;
  long long unaff_RDI;
  long long unaff_R15;
  
  *(int **)(unaff_RDI + 8) = (int *)(param_1 + 8);
  iVar1 = *(int *)(param_1 + 8);
  *(long long *)(unaff_RDI + 8) = param_1 + 0xc;
  if (iVar1 < 1) {
    *(int **)(unaff_RDI + 8) = (int *)(param_1 + 0x14);
    iVar1 = *(int *)(param_1 + 0x14);
    *(long long *)(unaff_RDI + 8) = param_1 + 0x18;
    if (iVar1 < 1) {
      return;
    }
    *(short *)(unaff_R15 + 0x62) = (short)iVar1;
    if (*(long long *)(unaff_R15 + 0x5a) == 0) {
      *(void* *)(unaff_R15 + 0x5a) = unaff_RSI;
      if (*(long long *)(unaff_R15 + 0x52) == 0) {
        *(void* *)(unaff_R15 + 0x52) = unaff_RSI;
        if ((ulong long)*(ushort *)(unaff_R15 + 0x62) == 0) {
          uVar3 = 0;
          uVar2 = unaff_RSI;
        }
        else {
          uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(unaff_R15 + 0x62) * 4,4);
          uVar3 = (ulong long)*(ushort *)(unaff_R15 + 0x62);
        }
        *(void* *)(unaff_R15 + 0x5a) = uVar2;
        if (uVar3 != 0) {
          unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar3 << 4,4);
        }
        *(void* *)(unaff_R15 + 0x52) = unaff_RSI;
                    // WARNING: Subroutine does not return
        memcpy(*(void* *)(unaff_R15 + 0x5a),*(void* *)(unaff_RDI + 8),
               (long long)(iVar1 * 4));
      }
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(short *)(unaff_R15 + 0x50) = (short)iVar1;
  if (*(long long *)(unaff_R15 + 0x48) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(unaff_R15 + 0x48) = unaff_RSI;
  if (*(long long *)(unaff_R15 + 0x40) == 0) {
    *(void* *)(unaff_R15 + 0x40) = unaff_RSI;
    if ((ulong long)*(ushort *)(unaff_R15 + 0x50) == 0) {
      uVar3 = 0;
      uVar2 = unaff_RSI;
    }
    else {
      uVar2 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(unaff_R15 + 0x50) * 4,4);
      uVar3 = (ulong long)*(ushort *)(unaff_R15 + 0x50);
    }
    *(void* *)(unaff_R15 + 0x48) = uVar2;
    if (uVar3 != 0) {
      unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar3 << 4,4);
    }
    *(void* *)(unaff_R15 + 0x40) = unaff_RSI;
                    // WARNING: Subroutine does not return
    memcpy(*(void* *)(unaff_R15 + 0x48),*(void* *)(unaff_RDI + 8),(long long)(iVar1 * 4));
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180074309(void)
void FUN_180074309(void)

{
  void* uVar1;
  ulong long uVar2;
  undefined2 unaff_BP;
  undefined6 unaff_0000002a;
  void* unaff_RSI;
  long long unaff_RDI;
  long long unaff_R15;
  
  *(undefined2 *)(unaff_R15 + 0x50) = unaff_BP;
  if (*(long long *)(unaff_R15 + 0x48) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *(void* *)(unaff_R15 + 0x48) = unaff_RSI;
  if (*(long long *)(unaff_R15 + 0x40) == 0) {
    *(void* *)(unaff_R15 + 0x40) = unaff_RSI;
    if ((ulong long)*(ushort *)(unaff_R15 + 0x50) == 0) {
      uVar2 = 0;
      uVar1 = unaff_RSI;
    }
    else {
      uVar1 = CreateSystemThreadObject(_DAT_180c8ed18,(ulong long)*(ushort *)(unaff_R15 + 0x50) * 4,4);
      uVar2 = (ulong long)*(ushort *)(unaff_R15 + 0x50);
    }
    *(void* *)(unaff_R15 + 0x48) = uVar1;
    if (uVar2 != 0) {
      unaff_RSI = CreateSystemThreadObject(_DAT_180c8ed18,uVar2 << 4,4);
    }
    *(void* *)(unaff_R15 + 0x40) = unaff_RSI;
                    // WARNING: Subroutine does not return
    memcpy(*(void* *)(unaff_R15 + 0x48),*(void* *)(unaff_RDI + 8),
           (long long)((int)CONCAT62(unaff_0000002a,unaff_BP) * 4));
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800744b0(long long param_1,long long param_2)
void FUN_1800744b0(long long param_1,long long param_2)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  long long systemTimeValue;
  int iVar6;
  int iVar7;
  int iVar8;
  uint32_t uVar9;
  uint32_t uVar10;
  uint32_t uVar11;
  uint8_t *puVar12;
  uint32_t *puVar13;
  uint8_t auStack_f8 [32];
  void* uStack_d8;
  undefined *puStack_c8;
  uint8_t *puStack_c0;
  uint32_t uStack_b8;
  uint8_t auStack_b0 [136];
  ulong long uStack_28;
  
  uStack_d8 = 0xfffffffffffffffe;
  uStack_28 = _DAT_180bf00a8 ^ (ulong long)auStack_f8;
  piVar4 = *(int **)(param_2 + 8);
  iVar2 = *piVar4;
  *(int **)(param_2 + 8) = piVar4 + 1;
  iVar6 = piVar4[2];
  iVar7 = piVar4[3];
  iVar8 = piVar4[4];
  *(int *)(param_1 + 0x18) = piVar4[1];
  *(int *)(param_1 + 0x1c) = iVar6;
  *(int *)(param_1 + 0x20) = iVar7;
  *(int *)(param_1 + 0x24) = iVar8;
  puVar12 = (uint8_t *)(*(long long *)(param_2 + 8) + 0x10);
  *(uint8_t **)(param_2 + 8) = puVar12;
  *(uint8_t *)(param_1 + 0x28) = *puVar12;
  lVar5 = *(long long *)(param_2 + 8);
  *(uint32_t **)(param_2 + 8) = (uint32_t *)(lVar5 + 1);
  if (iVar2 == 0) {
    puStack_c8 = &UNK_1809fcc28;
    puStack_c0 = auStack_b0;
    uStack_b8 = 0;
    auStack_b0[0] = 0;
    uVar3 = **(uint **)(param_2 + 8);
    puVar1 = *(uint **)(param_2 + 8) + 1;
    *(uint **)(param_2 + 8) = puVar1;
    if (uVar3 != 0) {
      FUN_180049910(&puStack_c8,puVar1,uVar3);
      *(long long *)(param_2 + 8) = *(long long *)(param_2 + 8) + (ulong long)uVar3;
    }
    puStack_c8 = &SystemMemoryAllocatorReference;
    puVar13 = *(uint32_t **)(param_2 + 8);
  }
  else {
    uVar9 = *(uint32_t *)(lVar5 + 5);
    uVar10 = *(uint32_t *)(lVar5 + 9);
    uVar11 = *(uint32_t *)(lVar5 + 0xd);
    *(uint32_t *)(param_1 + 8) = *(uint32_t *)(lVar5 + 1);
    *(uint32_t *)(param_1 + 0xc) = uVar9;
    *(uint32_t *)(param_1 + 0x10) = uVar10;
    *(uint32_t *)(param_1 + 0x14) = uVar11;
    *(long long *)(param_2 + 8) = *(long long *)(param_2 + 8) + 0x10;
    puVar13 = *(uint32_t **)(param_2 + 8);
  }
  *(uint32_t *)(param_1 + 0x2c) = *puVar13;
  puVar13 = (uint32_t *)(*(long long *)(param_2 + 8) + 4);
  *(uint32_t **)(param_2 + 8) = puVar13;
  *(uint32_t *)(param_1 + 0x30) = *puVar13;
  puVar13 = (uint32_t *)(*(long long *)(param_2 + 8) + 4);
  *(uint32_t **)(param_2 + 8) = puVar13;
  *(uint32_t *)(param_1 + 0x34) = *puVar13;
  *(long long *)(param_2 + 8) = *(long long *)(param_2 + 8) + 4;
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_28 ^ (ulong long)auStack_f8);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_1800745f0(void* param_1,long long param_2)

{
  void* uVar1;
  void** systemDataTable;
  
  puVar2 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x38,8,3,0xfffffffffffffffe);
  *puVar2 = &UNK_1809ffa18;
  *puVar2 = &UNK_1809ff9a8;
  *(void* *)((long long)puVar2 + 0x2c) = 0;
  *(uint32_t *)((long long)puVar2 + 0x34) = 0;
  *(uint8_t *)(puVar2 + 5) = 0;
  puVar2[3] = 0;
  puVar2[4] = 0;
  puVar2[1] = 0;
  puVar2[2] = 0;
  if (param_2 != 0) {
    uVar1 = *(void* *)(param_2 + 0x10);
    puVar2[1] = *(void* *)(param_2 + 8);
    puVar2[2] = uVar1;
    uVar1 = *(void* *)(param_2 + 0x20);
    puVar2[3] = *(void* *)(param_2 + 0x18);
    puVar2[4] = uVar1;
    *(uint8_t *)(puVar2 + 5) = *(uint8_t *)(param_2 + 0x28);
    *(uint32_t *)((long long)puVar2 + 0x2c) = *(uint32_t *)(param_2 + 0x2c);
    *(uint32_t *)(puVar2 + 6) = *(uint32_t *)(param_2 + 0x30);
    *(uint32_t *)((long long)puVar2 + 0x34) = *(uint32_t *)(param_2 + 0x34);
  }
  return puVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800746c0(long long param_1)
void FUN_1800746c0(long long param_1)

{
  long long lVar1;
  int iVar2;
  long long *plVar3;
  long long* systemMemoryPointer;
  undefined *puVar5;
  
  if (*(char *)(*(long long *)(param_1 + 0x20) + 0x28) == '\0') {
    plVar3 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0xc0,0x10,4,0xfffffffffffffffe);
    *plVar3 = (long long)&UNK_180a21690;
    *plVar3 = (long long)&UNK_180a21720;
    *(uint32_t *)(plVar3 + 1) = 0;
    *plVar3 = (long long)&UNK_180a02e68;
    plVar3[2] = (long long)&SystemMemoryAllocatorReference;
    plVar3[3] = 0;
    *(uint32_t *)(plVar3 + 4) = 0;
    plVar3[2] = (long long)&UNK_1809fcc28;
    plVar3[3] = (long long)(plVar3 + 5);
    *(uint32_t *)(plVar3 + 4) = 0;
    *(uint8_t *)(plVar3 + 5) = 0;
    *(uint8_t *)((long long)plVar3 + 0xb2) = 0;
    *(uint32_t *)(plVar3 + 1) = 0;
    *(undefined2 *)(plVar3 + 0x16) = 0;
    plVar3[0x15] = 0;
    *plVar3 = (long long)&UNK_180a13a28;
    plVar3[0x15] = 0;
    *(uint8_t *)(plVar3 + 0x17) = 0;
    (**(code **)(*plVar3 + 0x28))(plVar3);
    plVar4 = *(long long **)(param_1 + 0xb0);
    *(long long **)(param_1 + 0xb0) = plVar3;
    if (plVar4 != (long long *)0x0) {
      (**(code **)(*plVar4 + 0x38))();
    }
    *(long long *)(*(long long *)(param_1 + 0xb0) + 0xa8) = param_1;
    plVar4 = (long long *)(*(long long *)(param_1 + 0xb0) + 0x10);
    puVar5 = &SystemStringTemplate;
    if (*(undefined **)(param_1 + 0x70) != (undefined *)0x0) {
      puVar5 = *(undefined **)(param_1 + 0x70);
    }
    (**(code **)(*plVar4 + 0x10))(plVar4,puVar5);
    *(uint8_t *)(*(long long *)(param_1 + 0xb0) + 0xb1) = 1;
    lVar1 = _DAT_180c86930;
    plVar4 = *(long long **)(param_1 + 0xb0);
    iVar2 = (**(code **)(*plVar4 + 0x60))(plVar4);
    *(uint8_t *)((long long)plVar4 + 0xb2) = 1;
    FUN_1802abe00((long long)iVar2 * 0x98 + lVar1 + 8,plVar4);
  }
  return;
}




// 函数: void FUN_180074840(long long param_1)
void FUN_180074840(long long param_1)

{
  long long *plStackX_8;
  long long **pplStackX_10;
  
  if (*(long long *)(param_1 + 0xb0) != 0) {
    *(void* *)(*(long long *)(param_1 + 0xb0) + 0xa8) = 0;
    pplStackX_10 = &plStackX_8;
    plStackX_8 = *(long long **)(param_1 + 0xb0);
    if (plStackX_8 != (long long *)0x0) {
      (**(code **)(*plStackX_8 + 0x28))();
    }
    FUN_1800b55b0();
    pplStackX_10 = *(long long ***)(param_1 + 0xb0);
    *(void* *)(param_1 + 0xb0) = 0;
    if (pplStackX_10 != (long long **)0x0) {
                    // WARNING: Could not recover jumptable at 0x0001800748c2. Too many branches
                    // WARNING: Treating indirect jump as call
      (**(code **)((long long)*pplStackX_10 + 0x38))();
      return;
    }
  }
  return;
}




// 函数: void FUN_1800748d0(long long param_1,long long *param_2)
void FUN_1800748d0(long long param_1,long long *param_2)

{
  uint8_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t *puVar5;
  uint8_t *puVar6;
  
  puVar5 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
    puVar5 = (uint32_t *)param_2[1];
  }
  *puVar5 = 1;
  puVar5 = (uint32_t *)(param_2[1] + 4);
  param_2[1] = (long long)puVar5;
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 0x11) {
    FUN_180639bf0(param_2,(long long)puVar5 + (0x10 - *param_2));
    puVar5 = (uint32_t *)param_2[1];
  }
  uVar2 = *(uint32_t *)(param_1 + 0x1c);
  uVar3 = *(uint32_t *)(param_1 + 0x20);
  uVar4 = *(uint32_t *)(param_1 + 0x24);
  *puVar5 = *(uint32_t *)(param_1 + 0x18);
  puVar5[1] = uVar2;
  puVar5[2] = uVar3;
  puVar5[3] = uVar4;
  puVar6 = (uint8_t *)(param_2[1] + 0x10);
  param_2[1] = (long long)puVar6;
  uVar1 = *(uint8_t *)(param_1 + 0x28);
  if ((ulong long)((*param_2 - (long long)puVar6) + param_2[2]) < 2) {
    FUN_180639bf0(param_2,puVar6 + (1 - *param_2));
    puVar6 = (uint8_t *)param_2[1];
  }
  *puVar6 = uVar1;
  puVar5 = (uint32_t *)(param_2[1] + 1);
  param_2[1] = (long long)puVar5;
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 0x11) {
    FUN_180639bf0(param_2,(long long)puVar5 + (0x10 - *param_2));
    puVar5 = (uint32_t *)param_2[1];
  }
  uVar2 = *(uint32_t *)(param_1 + 0xc);
  uVar3 = *(uint32_t *)(param_1 + 0x10);
  uVar4 = *(uint32_t *)(param_1 + 0x14);
  *puVar5 = *(uint32_t *)(param_1 + 8);
  puVar5[1] = uVar2;
  puVar5[2] = uVar3;
  puVar5[3] = uVar4;
  puVar5 = (uint32_t *)(param_2[1] + 0x10);
  param_2[1] = (long long)puVar5;
  uVar2 = *(uint32_t *)(param_1 + 0x2c);
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
    puVar5 = (uint32_t *)param_2[1];
  }
  *puVar5 = uVar2;
  puVar5 = (uint32_t *)(param_2[1] + 4);
  param_2[1] = (long long)puVar5;
  uVar2 = *(uint32_t *)(param_1 + 0x30);
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
    puVar5 = (uint32_t *)param_2[1];
  }
  *puVar5 = uVar2;
  puVar5 = (uint32_t *)(param_2[1] + 4);
  param_2[1] = (long long)puVar5;
  uVar2 = *(uint32_t *)(param_1 + 0x34);
  if ((ulong long)((*param_2 - (long long)puVar5) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar5 + (4 - *param_2));
    *(uint32_t *)param_2[1] = uVar2;
  }
  else {
    *puVar5 = uVar2;
  }
  param_2[1] = param_2[1] + 4;
  return;
}




// 函数: void FUN_180074a80(long long *param_1)
void FUN_180074a80(long long *param_1)

{
  long long *plVar1;
  long long *plVar2;
  
  plVar1 = (long long *)param_1[1];
  plVar2 = (long long *)*param_1;
  while( true ) {
    if (plVar2 == plVar1) {
      if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      return;
    }
    if (*(long long *)((long long)plVar2 + 0x12) != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *(void* *)((long long)plVar2 + 0x12) = 0;
    if (*(long long *)((long long)plVar2 + 0x1a) != 0) break;
    *(void* *)((long long)plVar2 + 0x1a) = 0;
    if (*plVar2 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *plVar2 = 0;
    if (plVar2[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    plVar2[1] = 0;
    plVar2 = (long long *)((long long)plVar2 + 0x24);
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_180074b30(long long *param_1,ulong long param_2)
void FUN_180074b30(long long *param_1,ulong long param_2)

{
  long long *plVar1;
  ulong long uVar2;
  long long *plVar3;
  long long lVar4;
  long long systemTimeValue;
  
  plVar1 = (long long *)param_1[1];
  lVar5 = *param_1;
  uVar2 = ((long long)plVar1 - lVar5) / 0x24;
  if (uVar2 < param_2) {
    lVar4 = param_2 - uVar2;
    FUN_180074c20(param_1,lVar4,(long long)plVar1 - lVar5,lVar4,0xfffffffffffffffe);
  }
  else {
    plVar3 = (long long *)(param_2 * 0x24 + lVar5);
    if (plVar3 != plVar1) {
      do {
        if (*(long long *)((long long)plVar3 + 0x12) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)((long long)plVar3 + 0x12) = 0;
        if (*(long long *)((long long)plVar3 + 0x1a) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)((long long)plVar3 + 0x1a) = 0;
        if (*plVar3 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *plVar3 = 0;
        if (plVar3[1] != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        plVar3[1] = 0;
        plVar3 = (long long *)((long long)plVar3 + 0x24);
      } while (plVar3 != plVar1);
      lVar5 = *param_1;
    }
    param_1[1] = param_2 * 0x24 + lVar5;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180074c20(void* *param_1,ulong long param_2)
void FUN_180074c20(void* *param_1,ulong long param_2)

{
  long long *plVar1;
  long long *plVar2;
  void* *puVar3;
  long long* systemMemoryPointer;
  long long *plVar5;
  ulong long uVar6;
  void** systemCurrentNode;
  long long lVar8;
  ulong long uVar9;
  
  systemPreviousNode = (void* *)param_1[1];
  if ((ulong long)((param_1[2] - (long long)systemPreviousNode) / 0x24) < param_2) {
    puVar3 = (void* *)*param_1;
    lVar8 = ((long long)systemPreviousNode - (long long)puVar3) / 0x24;
    uVar9 = lVar8 * 2;
    if (lVar8 == 0) {
      uVar9 = 1;
    }
    if (uVar9 < lVar8 + param_2) {
      uVar9 = lVar8 + param_2;
    }
    plVar1 = (long long *)0x0;
    if (uVar9 != 0) {
      plVar1 = (long long *)
               CreateSystemThreadObject(_DAT_180c8ed18,uVar9 * 0x24,*(uint8_t *)(param_1 + 3),systemPreviousNode,
                             0xfffffffffffffffe);
      systemPreviousNode = (void* *)param_1[1];
      puVar3 = (void* *)*param_1;
    }
    plVar2 = plVar1;
    if (puVar3 != systemPreviousNode) {
      lVar8 = (long long)plVar1 - (long long)puVar3;
      plVar4 = (long long *)((long long)puVar3 + 0x1a);
      do {
        *(undefined2 *)(lVar8 + -10 + (long long)plVar4) = *(undefined2 *)((long long)plVar4 + -10);
        if (*(long long *)((long long)plVar4 + -0x12) == 0) {
          *(void* *)(lVar8 + -0x12 + (long long)plVar4) = 0;
        }
        else {
          *(long long *)(lVar8 + -0x12 + (long long)plVar4) = *(long long *)((long long)plVar4 + -0x12);
          *(void* *)((long long)plVar4 + -0x12) = 0;
        }
        if (*(long long *)((long long)plVar4 + -0x1a) == 0) {
          *plVar2 = 0;
        }
        else {
          *plVar2 = *(long long *)((long long)plVar4 + -0x1a);
          *(void* *)((long long)plVar4 + -0x1a) = 0;
        }
        *(undefined2 *)((long long)plVar4 + -10) = 0;
        *(short *)(lVar8 + 8 + (long long)plVar4) = (short)plVar4[1];
        if (*plVar4 == 0) {
          *(void* *)((long long)plVar4 + lVar8) = 0;
        }
        else {
          *(long long *)((long long)plVar4 + lVar8) = *plVar4;
          *plVar4 = 0;
        }
        if (plVar4[-1] == 0) {
          *(void* *)(lVar8 + -8 + (long long)plVar4) = 0;
        }
        else {
          *(long long *)(lVar8 + -8 + (long long)plVar4) = plVar4[-1];
          plVar4[-1] = 0;
        }
        *(undefined2 *)(plVar4 + 1) = 0;
        plVar2 = (long long *)((long long)plVar2 + 0x24);
        puVar3 = (void* *)((long long)plVar4 + 10);
        plVar4 = (long long *)((long long)plVar4 + 0x24);
      } while (puVar3 != systemPreviousNode);
    }
    if (param_2 != 0) {
      systemPreviousNode = (void* *)((long long)plVar2 + 0x1a);
      uVar6 = param_2;
      do {
        systemPreviousNode[-1] = 0;
        *systemPreviousNode = 0;
        *(undefined2 *)(systemPreviousNode + 1) = 0;
        *(undefined2 *)((long long)systemPreviousNode + -10) = 0;
        *(void* *)((long long)systemPreviousNode + -0x1a) = 0;
        *(void* *)((long long)systemPreviousNode + -0x12) = 0;
        *(undefined2 *)(systemPreviousNode + 1) = 0;
        systemPreviousNode[-1] = 0;
        *systemPreviousNode = 0;
        systemPreviousNode = (void* *)((long long)systemPreviousNode + 0x24);
        uVar6 = uVar6 - 1;
      } while (uVar6 != 0);
    }
    plVar4 = (long long *)param_1[1];
    plVar5 = (long long *)*param_1;
    if (plVar5 != plVar4) {
      do {
        if (*(long long *)((long long)plVar5 + 0x12) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)((long long)plVar5 + 0x12) = 0;
        if (*(long long *)((long long)plVar5 + 0x1a) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(void* *)((long long)plVar5 + 0x1a) = 0;
        if (*plVar5 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *plVar5 = 0;
        if (plVar5[1] != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        plVar5[1] = 0;
        plVar5 = (long long *)((long long)plVar5 + 0x24);
      } while (plVar5 != plVar4);
      plVar5 = (long long *)*param_1;
    }
    if (plVar5 != (long long *)0x0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900(plVar5);
    }
    *param_1 = plVar1;
    param_1[1] = (long long)plVar2 + param_2 * 0x24;
    param_1[2] = (long long)plVar1 + uVar9 * 0x24;
  }
  else {
    if (param_2 != 0) {
      puVar3 = (void* *)((long long)systemPreviousNode + 0x1a);
      uVar9 = param_2;
      do {
        systemPreviousNode[1] = 0;
        systemPreviousNode[2] = 0;
        systemPreviousNode[3] = 0;
        *(uint32_t *)(systemPreviousNode + 4) = 0;
        *(undefined2 *)((long long)puVar3 + -10) = 0;
        *systemPreviousNode = 0;
        *(void* *)((long long)puVar3 + -0x12) = 0;
        *(undefined2 *)(puVar3 + 1) = 0;
        puVar3[-1] = 0;
        *puVar3 = 0;
        systemPreviousNode = (void* *)((long long)systemPreviousNode + 0x24);
        puVar3 = (void* *)((long long)puVar3 + 0x24);
        uVar9 = uVar9 - 1;
      } while (uVar9 != 0);
      systemPreviousNode = (void* *)param_1[1];
    }
    param_1[1] = (long long)systemPreviousNode + param_2 * 0x24;
  }
  return;
}




// 函数: void FUN_180074ed0(long long *param_1)
void FUN_180074ed0(long long *param_1)

{
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = 0;
  if (param_1[1] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[1] = 0;
  return;
}



void* *
FUN_180074f20(void* *param_1,ulong long param_2,void* param_3,void* param_4)

{
  *param_1 = &UNK_1809ffa18;
  if ((param_2 & 1) != 0) {
    free(param_1,0x38,param_3,param_4,0xfffffffffffffffe);
  }
  return param_1;
}



void* * FUN_180074f70(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809ffa18;
  if ((param_2 & 1) != 0) {
    free(param_1,8);
  }
  return param_1;
}



void* *
FUN_180074fb0(void* param_1,void* *param_2,void* param_3,void* param_4)

{
  *param_2 = &SystemMemoryAllocatorReference;
  param_2[1] = 0;
  *(uint32_t *)(param_2 + 2) = 0;
  *param_2 = &UNK_1809fcc28;
  param_2[1] = param_2 + 3;
  *(uint8_t *)(param_2 + 3) = 0;
  *(uint32_t *)(param_2 + 2) = 7;
  strcpy_s(param_2[1],0x80,&UNK_1809ffa30,param_4,0,0xfffffffffffffffe);
  return param_2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* * FUN_180075030(void* *param_1,char param_2,char param_3)

{
  long long *plVar1;
  byte bVar2;
  long long *plVar3;
  long long* systemMemoryPointer;
  
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_180a02e68;
  param_1[2] = &SystemMemoryAllocatorReference;
  param_1[3] = 0;
  *(uint32_t *)(param_1 + 4) = 0;
  param_1[2] = &UNK_1809fcc28;
  param_1[3] = param_1 + 5;
  *(uint32_t *)(param_1 + 4) = 0;
  *(uint8_t *)(param_1 + 5) = 0;
  *(uint8_t *)((long long)param_1 + 0xb2) = 0;
  *(uint32_t *)(param_1 + 1) = 0;
  *(undefined2 *)(param_1 + 0x16) = 0;
  param_1[0x15] = 0;
  *param_1 = &UNK_180a00270;
  func_0x000180086550(param_1 + 0x19);
  *(uint32_t *)(param_1 + 0x1e) = 0;
  LOCK();
  *(uint32_t *)(param_1 + 0x1d) = 0;
  UNLOCK();
  LOCK();
  *(uint8_t *)((long long)param_1 + 0xec) = 0;
  UNLOCK();
  *(uint32_t *)(param_1 + 0x1e) = 0;
  param_1[0x23] = 0;
  param_1[0x36] = 0;
  param_1[0x37] = 0;
  param_1[0x38] = 0;
  param_1[0x3e] = param_1;
  param_1[0x3d] = 0;
  param_1[0x42] = 0;
  param_1[0x43] = 0;
  param_1[0x44] = 0;
  param_1[0x45] = 0;
  *(uint32_t *)(param_1 + 0x46) = 3;
  param_1[0x4d] = 0;
  *(uint32_t *)((long long)param_1 + 0x2a4) = 0;
  *(void* *)((long long)param_1 + 0x274) = 0;
  *(void* *)((long long)param_1 + 0x27c) = 0;
  *(void* *)((long long)param_1 + 0x284) = 0;
  *(void* *)((long long)param_1 + 0x28c) = 0;
  *(void* *)((long long)param_1 + 0x294) = 0;
  *(void* *)((long long)param_1 + 0x29c) = 0;
  *(undefined2 *)(param_1 + 0x5d) = 0;
  param_1[0x5c] = 0;
  *(uint32_t *)((long long)param_1 + 0x2ec) = 0xffffffff;
  *(undefined2 *)(param_1 + 0x5f) = 0;
  param_1[0x5e] = 0;
  *(uint32_t *)((long long)param_1 + 0x2fc) = 0xffffffff;
  *(byte *)((long long)param_1 + 0xfd) = *(byte *)((long long)param_1 + 0xfd) & 0xfb;
  *(byte *)((long long)param_1 + 0xfd) = *(byte *)((long long)param_1 + 0xfd) | param_2 << 2;
  param_1[0x15] = 0;
  *(uint32_t *)(param_1 + 0x17) = 0;
  *(uint32_t *)((long long)param_1 + 0xbc) = 0;
  *(uint32_t *)(param_1 + 0x18) = 0;
  *(uint32_t *)((long long)param_1 + 0xc4) = 0;
  *(byte *)((long long)param_1 + 0xfe) = *(byte *)((long long)param_1 + 0xfe) & 0xfe;
  *(uint8_t *)((long long)param_1 + 0xfc) = 0;
  plVar4 = (long long *)param_1[0x36];
  param_1[0x36] = 0;
  if (plVar4 != (long long *)0x0) {
    (**(code **)(*plVar4 + 0x38))();
  }
  param_1[0x39] = 0;
  param_1[0x3c] = 0;
  if (param_3 == '\0') {
    *(byte *)((long long)param_1 + 0xfd) = *(byte *)((long long)param_1 + 0xfd) & 0xdf;
  }
  else {
    *(byte *)((long long)param_1 + 0xfd) = *(byte *)((long long)param_1 + 0xfd) | 0x20;
  }
  *(byte *)((long long)param_1 + 0xfd) = *(byte *)((long long)param_1 + 0xfd) & 0xbf;
  *(uint8_t *)((long long)param_1 + 0xff) = 1;
  plVar4 = (long long *)param_1[0x37];
  param_1[0x37] = 0;
  if (plVar4 != (long long *)0x0) {
    (**(code **)(*plVar4 + 0x38))();
  }
  *(uint8_t *)((long long)param_1 + 0xf4) = 0;
  *(uint32_t *)(param_1 + 0x20) = 0;
  *(uint8_t *)((long long)param_1 + 0xf7) = 0;
  *(byte *)((long long)param_1 + 0xfd) = *(byte *)((long long)param_1 + 0xfd) & 0x6d;
  plVar3 = (long long *)param_1[0x38];
  param_1[0x38] = 0;
  if (plVar3 != (long long *)0x0) {
    (**(code **)(*plVar3 + 0x38))();
  }
  bVar2 = *(byte *)((long long)param_1 + 0xfd) & 0xf7;
  *(byte *)((long long)param_1 + 0xfd) = bVar2;
  param_1[0x47] = 0x3f8000003f800000;
  param_1[0x48] = 0x3f8000003f800000;
  param_1[0x49] = 0x3f8000003f800000;
  param_1[0x4a] = 0x3f8000003f800000;
  *(uint32_t *)(param_1 + 0x4c) = 0x3f800000;
  param_1[0x24] = 0x3f800000;
  param_1[0x25] = 0;
  param_1[0x26] = 0x3f80000000000000;
  param_1[0x27] = 0;
  param_1[0x28] = 0;
  param_1[0x29] = 0x3f800000;
  param_1[0x2a] = 0;
  param_1[0x2b] = 0x3f80000000000000;
  param_1[0x2c] = 0x3f800000;
  param_1[0x2d] = 0;
  param_1[0x2e] = 0x3f80000000000000;
  param_1[0x2f] = 0;
  param_1[0x30] = 0;
  param_1[0x31] = 0x3f800000;
  param_1[0x32] = 0;
  param_1[0x33] = 0x3f80000000000000;
  *(byte *)((long long)param_1 + 0xfd) = bVar2 | 1;
  *(byte *)((long long)param_1 + 0xfe) = *(byte *)((long long)param_1 + 0xfe) | 2;
  *(uint32_t *)(param_1 + 0x4e) = 0x21;
  *(uint32_t *)((long long)param_1 + 0x104) = 0x80;
  *(uint8_t *)((long long)param_1 + 0xf6) = 0;
  *(undefined2 *)((long long)param_1 + 0xfa) = 0;
  *(void* *)((long long)param_1 + 0x204) = 0;
  param_1[0x3f] = 0;
  *(uint32_t *)(param_1 + 0x40) = 0;
  *(uint32_t *)(param_1 + 0x5b) = 0xbf800000;
  *(uint32_t *)((long long)param_1 + 0x2dc) = 0xbf800000;
  param_1[0x55] = 0;
  param_1[0x56] = 0;
  param_1[0x57] = 0;
  param_1[0x58] = 0;
  *(uint32_t *)(param_1 + 0x19) = 0;
  *(uint32_t *)((long long)param_1 + 0xcc) = 0;
  *(uint32_t *)(param_1 + 0x1a) = 0;
  *(uint32_t *)((long long)param_1 + 0xd4) = 0x7f7fffff;
  *(uint32_t *)(param_1 + 0x1b) = 0;
  *(uint32_t *)((long long)param_1 + 0xdc) = 0;
  *(uint32_t *)(param_1 + 0x1c) = 0;
  *(uint32_t *)((long long)param_1 + 0xe4) = 0x7f7fffff;
  *(uint32_t *)(param_1 + 0x21) = 0xffffffff;
  param_1[0x5a] = 0;
  if (param_2 == '\0') {
    plVar1 = (long long *)param_1[0x42];
    param_1[0x42] = 0;
    if (plVar1 != (long long *)0x0) {
      (**(code **)(*plVar1 + 0x38))(plVar1,0);
    }
  }
  *(uint8_t *)(param_1 + 0x1f) = 0;
  *(uint32_t *)(param_1 + 0x34) = 0x3f800000;
  *(uint32_t *)((long long)param_1 + 0x1a4) = 0x3f800000;
  *(uint32_t *)(param_1 + 0x35) = 0x3f800000;
  *(uint32_t *)((long long)param_1 + 0x1ac) = 0x7f7fffff;
  *(uint32_t *)(param_1 + 0x3a) = 0xffffffff;
  plVar3 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x70,8,9,plVar4,plVar3);
  *plVar3 = (long long)&UNK_180a21690;
  *plVar3 = (long long)&UNK_180a21720;
  *(uint32_t *)(plVar3 + 1) = 0;
  *plVar3 = (long long)&UNK_180a00208;
  plVar3[4] = (long long)&SystemMemoryAllocatorReference;
  plVar3[5] = 0;
  *(uint32_t *)(plVar3 + 6) = 0;
  plVar3[4] = (long long)&SystemGlobalDataReference;
  plVar3[7] = 0;
  plVar3[5] = 0;
  *(uint32_t *)(plVar3 + 6) = 0;
  *(uint32_t *)(plVar3 + 8) = 0xffffffff;
  *(uint32_t *)((long long)plVar3 + 0x44) = 0x3f000000;
  *(uint32_t *)(plVar3 + 9) = 0x3f000000;
  *(uint32_t *)((long long)plVar3 + 0x4c) = 0x3f4ccccd;
  *(uint32_t *)(plVar3 + 10) = 0x3f000000;
  *(uint32_t *)((long long)plVar3 + 0x54) = 0x3e99999a;
  *(uint32_t *)(plVar3 + 0xb) = 0x411cf5c3;
  *(uint32_t *)((long long)plVar3 + 0x5c) = 0x3f800000;
  *(uint32_t *)(plVar3 + 0xc) = 0xbf800000;
  *(uint32_t *)((long long)plVar3 + 100) = 0x3f800000;
  *(uint32_t *)(plVar3 + 0xd) = 0x3f000000;
  *(uint32_t *)((long long)plVar3 + 0x6c) = 0x3f800000;
  *(uint32_t *)(plVar3 + 2) = 0x3f800000;
  *(uint32_t *)((long long)plVar3 + 0x14) = 0x78;
  *(undefined2 *)(plVar3 + 3) = 0;
  *(uint8_t *)((long long)plVar3 + 0x1a) = 0;
  (**(code **)(*plVar3 + 0x28))(plVar3);
  plVar4 = (long long *)param_1[0x4d];
  param_1[0x4d] = plVar3;
  if (plVar4 != (long long *)0x0) {
    (**(code **)(*plVar4 + 0x38))();
  }
  *(byte *)((long long)param_1 + 0xfe) = *(byte *)((long long)param_1 + 0xfe) & 0xf3;
  param_1[0x3b] = 0;
  LOCK();
  *(uint8_t *)((long long)param_1 + 0xf9) = 0;
  UNLOCK();
  param_1[0x59] = 0;
  *(uint8_t *)((long long)param_1 + 0xf5) = 0;
  param_1[0x4b] = 0;
  return param_1;
}



void* FUN_180075580(void* param_1,ulong long param_2)

{
  FUN_1800756e0();
  if ((param_2 & 1) != 0) {
    free(param_1,0x300);
  }
  return param_1;
}



uint8_t FUN_1800755c0(long long param_1,void* param_2,void* param_3,void* param_4)

{
  uint8_t uVar1;
  void* uVar2;
  undefined *puStack_30;
  long long lStack_28;
  
  uVar2 = 0xfffffffffffffffe;
  FUN_1806279c0(&puStack_30);
  uVar1 = FUN_180063510(param_1 + 0x218,&puStack_30,param_3,param_4,uVar2);
  puStack_30 = &SystemGlobalDataReference;
  if (lStack_28 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return uVar1;
}



// WARNING: Removing unreachable block (ram,0x000180276fbd)


// 函数: void FUN_180075630(long long param_1,void* *param_2)
void FUN_180075630(long long param_1,void* *param_2)

{
  void* *puVar1;
  long long *plVar2;
  long long lVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  void* uVar7;
  char cVar8;
  long long lVar9;
  long long *plVar10;
  uint uVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  uint8_t auStack_e8 [184];
  void* uStack_30;
  
  uVar11 = *(uint *)(param_1 + 0x100) & 0xfbffffff;
  *(uint *)(param_1 + 0x100) = uVar11;
  uStack_30 = 0x180075655;
  cVar8 = FUN_1800861a0(param_2);
  if (cVar8 == '\0') {
    *(uint *)(param_1 + 0x100) = uVar11 | 0x4000000;
  }
  uVar7 = param_2[1];
  plVar2 = *(long long **)(param_1 + 0x1c8);
  *(void* *)(param_1 + 0x120) = *param_2;
  *(void* *)(param_1 + 0x128) = uVar7;
  uVar7 = param_2[3];
  *(void* *)(param_1 + 0x130) = param_2[2];
  *(void* *)(param_1 + 0x138) = uVar7;
  uVar4 = *(uint32_t *)((long long)param_2 + 0x24);
  uVar5 = *(uint32_t *)(param_2 + 5);
  uVar6 = *(uint32_t *)((long long)param_2 + 0x2c);
  *(uint32_t *)(param_1 + 0x140) = *(uint32_t *)(param_2 + 4);
  *(uint32_t *)(param_1 + 0x144) = uVar4;
  *(uint32_t *)(param_1 + 0x148) = uVar5;
  *(uint32_t *)(param_1 + 0x14c) = uVar6;
  uVar4 = *(uint32_t *)((long long)param_2 + 0x34);
  uVar5 = *(uint32_t *)(param_2 + 7);
  uVar6 = *(uint32_t *)((long long)param_2 + 0x3c);
  *(uint32_t *)(param_1 + 0x150) = *(uint32_t *)(param_2 + 6);
  *(uint32_t *)(param_1 + 0x154) = uVar4;
  *(uint32_t *)(param_1 + 0x158) = uVar5;
  *(uint32_t *)(param_1 + 0x15c) = uVar6;
  if (plVar2 != (long long *)0x0) {
    if (*(code **)(*plVar2 + 0x160) == (code *)&UNK_180277350) {
      puVar1 = (void* *)((long long)plVar2 + 0x214);
      *(uint32_t *)((long long)plVar2 + 0x244) = 0;
      if (plVar2[8] - plVar2[7] >> 4 == 0) {
        *puVar1 = 0;
        *(void* *)((long long)plVar2 + 0x21c) = 0;
        *(void* *)((long long)plVar2 + 0x224) = 0;
        *(void* *)((long long)plVar2 + 0x22c) = 0;
        *(void* *)((long long)plVar2 + 0x234) = 0;
        *(void* *)((long long)plVar2 + 0x23c) = 0;
      }
      else {
        *puVar1 = 0x4cbebc204cbebc20;
        *(void* *)((long long)plVar2 + 0x21c) = 0x7f7fffff4cbebc20;
        *(uint32_t *)((long long)plVar2 + 0x234) = 0;
        *(uint32_t *)(plVar2 + 0x47) = 0;
        *(uint32_t *)((long long)plVar2 + 0x23c) = 0;
        *(uint32_t *)(plVar2 + 0x48) = 0x7f7fffff;
        *(void* *)((long long)plVar2 + 0x224) = 0xccbebc20ccbebc20;
        *(void* *)((long long)plVar2 + 0x22c) = 0x7f7fffffccbebc20;
        plVar10 = (long long *)plVar2[7];
        if (plVar10 < (long long *)plVar2[8]) {
          do {
            lVar3 = *plVar10;
            if (((*(byte *)(lVar3 + 0x100) & 0x20) == 0) || (plVar2[5] == 0)) {
              lVar9 = lVar3 + 0x120;
            }
            else {
              lVar9 = FUN_180194940(lVar3 + 0x120,auStack_e8,plVar2[5] + 0x70);
            }
            FUN_18063a240(puVar1,lVar3 + 0x274,lVar9);
            plVar10 = plVar10 + 2;
          } while (plVar10 < (long long *)plVar2[8]);
        }
        if (((plVar2[8] - plVar2[7] & 0xfffffffffffffff0U) == 0x10) &&
           (lVar3 = *(long long *)plVar2[7], (*(uint *)(lVar3 + 0x100) & 0x4000000) == 0)) {
          uVar7 = *(void* *)(lVar3 + 0x29c);
          *(void* *)((long long)plVar2 + 0x234) = *(void* *)(lVar3 + 0x294);
          *(void* *)((long long)plVar2 + 0x23c) = uVar7;
          *(uint32_t *)((long long)plVar2 + 0x244) =
               *(uint32_t *)(*(long long *)plVar2[7] + 0x2a4);
        }
        else {
          FUN_1800b9f60(puVar1);
          plVar10 = (long long *)plVar2[7];
          fVar14 = 0.0;
          if (plVar10 < (long long *)plVar2[8]) {
            do {
              lVar3 = *plVar10;
              if ((*(uint *)(lVar3 + 0x100) & 0x4000000) == 0) {
                fVar15 = *(float *)(lVar3 + 0x294);
                fVar16 = *(float *)(lVar3 + 0x298);
                fVar17 = *(float *)(lVar3 + 0x29c);
                fVar12 = *(float *)(lVar3 + 0x2a4);
              }
              else {
                fVar12 = *(float *)(lVar3 + 0x298);
                fVar17 = *(float *)(lVar3 + 0x294);
                fVar13 = *(float *)(lVar3 + 0x29c);
                fVar15 = *(float *)(lVar3 + 0x130) * fVar12 + *(float *)(lVar3 + 0x120) * fVar17 +
                         *(float *)(lVar3 + 0x140) * fVar13 + *(float *)(lVar3 + 0x150);
                fVar16 = *(float *)(lVar3 + 0x134) * fVar12 + *(float *)(lVar3 + 0x124) * fVar17 +
                         *(float *)(lVar3 + 0x144) * fVar13 + *(float *)(lVar3 + 0x154);
                fVar17 = *(float *)(lVar3 + 0x138) * fVar12 + *(float *)(lVar3 + 0x128) * fVar17 +
                         *(float *)(lVar3 + 0x148) * fVar13 + *(float *)(lVar3 + 0x158);
                fVar12 = *(float *)(lVar3 + 0x140) * *(float *)(lVar3 + 0x140) +
                         *(float *)(lVar3 + 0x144) * *(float *)(lVar3 + 0x144) +
                         *(float *)(lVar3 + 0x148) * *(float *)(lVar3 + 0x148);
                fVar13 = *(float *)(lVar3 + 0x130) * *(float *)(lVar3 + 0x130) +
                         *(float *)(lVar3 + 0x134) * *(float *)(lVar3 + 0x134) +
                         *(float *)(lVar3 + 0x138) * *(float *)(lVar3 + 0x138);
                fVar18 = *(float *)(lVar3 + 0x120) * *(float *)(lVar3 + 0x120) +
                         *(float *)(lVar3 + 0x124) * *(float *)(lVar3 + 0x124) +
                         *(float *)(lVar3 + 0x128) * *(float *)(lVar3 + 0x128);
                if (fVar18 <= fVar13) {
                  if (fVar12 <= fVar13) {
                    fVar12 = fVar13;
                  }
                }
                else if (fVar12 <= fVar18) {
                  fVar12 = fVar18;
                }
                if ((fVar12 - 1.0 <= -1e-06) || (1e-06 <= fVar12 - 1.0)) {
                  fVar12 = SQRT(fVar12) * *(float *)(lVar3 + 0x2a4);
                }
                else {
                  fVar12 = *(float *)(lVar3 + 0x2a4) * 1.0;
                }
              }
              fVar17 = *(float *)((long long)plVar2 + 0x23c) - fVar17;
              fVar15 = *(float *)((long long)plVar2 + 0x234) - fVar15;
              fVar16 = (*(float *)(plVar2 + 0x47) - fVar16) * (*(float *)(plVar2 + 0x47) - fVar16) +
                       fVar15 * fVar15 + fVar17 * fVar17;
              fVar15 = fVar14 - fVar12;
              if (fVar15 <= 0.0) {
                fVar15 = 0.0;
              }
              if (fVar15 * fVar15 < fVar16) {
                fVar14 = SQRT(fVar16) + fVar12;
              }
              plVar10 = plVar10 + 2;
            } while (plVar10 < (long long *)plVar2[8]);
            if ((0.0 < fVar14) &&
               (fVar14 < *(float *)((long long)plVar2 + 0x244) ||
                fVar14 == *(float *)((long long)plVar2 + 0x244))) {
              *(float *)((long long)plVar2 + 0x244) = fVar14;
            }
          }
        }
      }
      return;
    }
    uStack_30 = 0x1800756d4;
    (**(code **)(*plVar2 + 0x160))();
  }
  return;
}




// 函数: void FUN_1800756e0(void* *param_1)
void FUN_1800756e0(void* *param_1)

{
  byte *pbVar1;
  long long *plVar2;
  long long lVar3;
  void* uVar4;
  
  uVar4 = 0xfffffffffffffffe;
  *param_1 = &UNK_180a00270;
  param_1[0x39] = 0;
  if (param_1[0x59] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x59] = 0;
  plVar2 = (long long *)param_1[0x37];
  param_1[0x37] = 0;
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))();
  }
  plVar2 = (long long *)param_1[0x38];
  param_1[0x38] = 0;
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))();
  }
  if (param_1[0x5a] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x5a] = 0;
  plVar2 = (long long *)param_1[0x4b];
  if (plVar2 != (long long *)0x0) {
    if (*plVar2 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *plVar2 = 0;
    if (plVar2[2] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    plVar2[2] = 0;
    if (plVar2[7] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    plVar2[2] = 0;
    plVar2[7] = 0;
                    // WARNING: Subroutine does not return
    FUN_18064e900(plVar2);
  }
  param_1[0x4b] = 0;
  if (*(char *)((long long)param_1 + 0xf9) != '\0') {
    if (param_1[0x3b] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    param_1[0x3b] = 0;
    LOCK();
    *(uint8_t *)((long long)param_1 + 0xf9) = 0;
    UNLOCK();
  }
  if (param_1[0x3d] != 0) {
    FUN_180080060();
    param_1[0x3d] = 0;
    if (param_1[0x3e] != 0) {
      pbVar1 = (byte *)(param_1[0x3e] + 0xfe);
      *pbVar1 = *pbVar1 & 0xfb;
    }
  }
  plVar2 = (long long *)param_1[0x42];
  param_1[0x42] = 0;
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))();
  }
  lVar3 = param_1[0x3c];
  if (lVar3 != 0) {
    FUN_1808fc8a8(lVar3,0x18,0x10,FUN_18007bb70,uVar4,lVar3);
                    // WARNING: Subroutine does not return
    FUN_18064e900(lVar3);
  }
  param_1[0x3c] = 0;
  FUN_180080870(param_1 + 0x5e);
  FUN_1800809a0(param_1 + 0x5c);
  if ((long long *)param_1[0x4d] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x4d] + 0x38))();
  }
  FUN_18005d580();
  if ((long long *)param_1[0x42] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x42] + 0x38))();
  }
  if (param_1[0x3d] != 0) {
    FUN_180080060();
  }
  if ((long long *)param_1[0x38] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x38] + 0x38))();
  }
  if ((long long *)param_1[0x37] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x37] + 0x38))();
  }
  if ((long long *)param_1[0x36] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x36] + 0x38))();
  }
  if ((long long *)param_1[0x23] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[0x23] + 0x38))();
  }
  *param_1 = &UNK_180a02e68;
  param_1[2] = &SystemMemoryAllocatorReference;
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  return;
}




// 函数: void FUN_180075990(long long param_1,long long *param_2)
void FUN_180075990(long long param_1,long long *param_2)

{
  long long *plVar1;
  void* uStack_40;
  uint32_t uStack_38;
  long long lStack_30;
  uint8_t auStack_28 [8];
  long long lStack_20;
  uint32_t uStack_18;
  long long *plStack_10;
  
  if (*(long long *)(param_1 + 0x1b0) != *param_2) {
    if (*param_2 == 0) {
      plStack_10 = (long long *)0x0;
      auStack_28[0] = 0;
      uStack_18 = 0;
      lStack_20 = param_1;
      FUN_18007f4c0(auStack_28);
      if ((*(int *)(param_1 + 0x208) != 0) || (*(int *)(param_1 + 0x204) != 0)) {
        uStack_40 = *(void* *)(param_1 + 0x1b0);
        uStack_38 = 0;
        FUN_18007f770(&uStack_40);
        plVar1 = plStack_10;
        FUN_1800860f0(plStack_10 + 2,lStack_30 + 0x10);
        FUN_1800860f0(plVar1 + 7,lStack_30 + 0x38);
        FUN_180086090(plVar1 + 0xc,lStack_30 + 0x60);
        FUN_180085fb0(plVar1 + 0x11,lStack_30 + 0x88);
        FUN_180085ec0(plVar1 + 0x19,lStack_30 + 200);
        FUN_18007f840(&uStack_40);
      }
      FUN_18007f6a0(auStack_28);
      if (plStack_10 != (long long *)0x0) {
        (**(code **)(*plStack_10 + 0x38))();
      }
    }
    param_2 = (long long *)*param_2;
    if (param_2 != (long long *)0x0) {
      (**(code **)(*param_2 + 0x28))(param_2);
    }
    plVar1 = *(long long **)(param_1 + 0x1b0);
    *(long long **)(param_1 + 0x1b0) = param_2;
    if (plVar1 != (long long *)0x0) {
      (**(code **)(*plVar1 + 0x38))();
    }
  }
  return;
}



long long FUN_180075af0(long long param_1)

{
  long long lVar1;
  long long lVar2;
  byte bVar3;
  
  bVar3 = *(byte *)(param_1 + 0xfd) & 0x20;
  lVar1 = param_1;
  if (bVar3 == 0) {
    lVar1 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  lVar2 = 2;
  if (0xffff < *(int *)(lVar1 + 0x200)) {
    lVar2 = 4;
  }
  if (bVar3 == 0) {
    param_1 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  return (*(int *)(param_1 + 0x1fc) * 3) * lVar2;
}



float * FUN_180075b70(float *param_1)

{
  float *pfVar1;
  byte bVar2;
  long long *plVar3;
  float *pfVar4;
  char cVar5;
  float *pfVar6;
  uint uVar7;
  ulong long uVar8;
  bool bVar9;
  float fVar10;
  float fVar11;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  uint32_t uStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  uint32_t uStack_9c;
  float *pfStack_98;
  uint32_t stackParameterC;
  long long lStack_88;
  void* uStack_78;
  void* uStack_70;
  void* uStack_68;
  void* uStack_60;
  float fStack_58;
  float fStack_54;
  float fStack_50;
  float fStack_4c;
  void* uStack_48;
  void* uStack_40;
  void* uStack_38;
  
  uStack_38 = 0xfffffffffffffffe;
  pfVar6 = param_1;
  if ((*(byte *)((long long)param_1 + 0xfd) & 0x20) == 0) {
    pfVar6 = (float *)func_0x000180085de0(*(void* *)(param_1 + 0x6c));
  }
  if ((*(long long *)(pfVar6 + 0x84) != 0) && (((uint)param_1[0x40] & 0x80) == 0)) {
    pfVar1 = param_1 + 0x9d;
    pfVar1[0] = 1e+08;
    pfVar1[1] = 1e+08;
    param_1[0x9f] = 1e+08;
    param_1[0xa0] = 3.4028235e+38;
    param_1[0xa1] = -1e+08;
    param_1[0xa2] = -1e+08;
    param_1[0xa3] = -1e+08;
    param_1[0xa4] = 3.4028235e+38;
    uVar7 = 0;
    param_1[0xa9] = 0.0;
    param_1[0xa5] = 0.0;
    param_1[0xa6] = 0.0;
    param_1[0xa7] = 0.0;
    param_1[0xa8] = 3.4028235e+38;
    stackParameterC = 0;
    pfStack_98 = pfVar6;
    FUN_18007f770(&pfStack_98);
    if (*(int *)(lStack_88 + 0x10) != 0) {
      do {
        pfVar6 = (float *)((long long)(int)uVar7 * 0x10 + *(long long *)(lStack_88 + 0x18));
        fStack_a8 = *pfVar6;
        if (*pfVar1 < fStack_a8) {
          fStack_a8 = *pfVar1;
        }
        fStack_a4 = pfVar6[1];
        if (param_1[0x9e] < fStack_a4) {
          fStack_a4 = param_1[0x9e];
        }
        fStack_a0 = pfVar6[2];
        if (param_1[0x9f] < fStack_a0) {
          fStack_a0 = param_1[0x9f];
        }
        *(ulong long *)pfVar1 = CONCAT44(fStack_a4,fStack_a8);
        *(ulong long *)(param_1 + 0x9f) = CONCAT44(uStack_9c,fStack_a0);
        fStack_b8 = *pfVar6;
        if (fStack_b8 < param_1[0xa1]) {
          fStack_b8 = param_1[0xa1];
        }
        fStack_b4 = pfVar6[1];
        if (fStack_b4 < param_1[0xa2]) {
          fStack_b4 = param_1[0xa2];
        }
        fStack_b0 = pfVar6[2];
        if (fStack_b0 < param_1[0xa3]) {
          fStack_b0 = param_1[0xa3];
        }
        *(ulong long *)(param_1 + 0xa1) = CONCAT44(fStack_b4,fStack_b8);
        *(ulong long *)(param_1 + 0xa3) = CONCAT44(uStack_ac,fStack_b0);
        uVar7 = uVar7 + 1;
      } while (uVar7 < *(uint *)(lStack_88 + 0x10));
    }
    pfVar6 = *(float **)(param_1 + 0x6e);
    if ((pfVar6 != (float *)0x0) && (((uint)pfVar6[0x4e] & 0x3000) != 0)) {
      uStack_78 = *(void* *)(param_1 + 0x48);
      uStack_70 = *(void* *)(param_1 + 0x4a);
      uStack_68 = *(void* *)(param_1 + 0x4c);
      uStack_60 = *(void* *)(param_1 + 0x4e);
      fStack_58 = param_1[0x50];
      fStack_54 = param_1[0x51];
      fStack_50 = param_1[0x52];
      fStack_4c = param_1[0x53];
      uStack_48 = *(void* *)(param_1 + 0x54);
      uStack_40 = *(void* *)(param_1 + 0x56);
      FUN_180085c10(&uStack_78);
      FUN_18063a240(pfVar1,pfVar1,&uStack_78);
      pfVar6 = *(float **)(param_1 + 0x6e);
      if (((uint)pfVar6[0x4e] & 0x3000) == 0x2000) {
        uStack_78 = *(void* *)(param_1 + 0x48);
        uStack_70 = *(void* *)(param_1 + 0x4a);
        uStack_68 = *(void* *)(param_1 + 0x4c);
        uStack_60 = *(void* *)(param_1 + 0x4e);
        fStack_58 = param_1[0x50];
        fStack_54 = param_1[0x51];
        fStack_50 = param_1[0x52];
        fStack_4c = param_1[0x53];
        uStack_48 = *(void* *)(param_1 + 0x54);
        uStack_40 = *(void* *)(param_1 + 0x56);
        FUN_180085ac0(&uStack_78,0x3fc90fdb);
        FUN_18063a240(pfVar1,pfVar1,&uStack_78);
        uStack_78 = *(void* *)(param_1 + 0x48);
        uStack_70 = *(void* *)(param_1 + 0x4a);
        uStack_68 = *(void* *)(param_1 + 0x4c);
        uStack_60 = *(void* *)(param_1 + 0x4e);
        fStack_58 = param_1[0x50];
        fStack_54 = param_1[0x51];
        fStack_50 = param_1[0x52];
        fStack_4c = param_1[0x53];
        uStack_48 = *(void* *)(param_1 + 0x54);
        uStack_40 = *(void* *)(param_1 + 0x56);
        FUN_180085970(&uStack_78);
        pfVar6 = (float *)FUN_18063a240(pfVar1,pfVar1,&uStack_78);
      }
    }
    pfVar4 = pfStack_98;
    if (param_1[0xa1] < *pfVar1) {
      param_1[0xa9] = 0.0;
      pfVar1[0] = 0.0;
      pfVar1[1] = 0.0;
      param_1[0x9f] = 0.0;
      param_1[0xa0] = 0.0;
      param_1[0xa1] = 0.0;
      param_1[0xa2] = 0.0;
      param_1[0xa3] = 0.0;
      param_1[0xa4] = 0.0;
      param_1[0xa5] = 0.0;
      param_1[0xa6] = 0.0;
      param_1[0xa7] = 0.0;
      param_1[0xa8] = 0.0;
    }
    else {
      param_1[0xa5] = (param_1[0xa1] + *pfVar1) * 0.5;
      param_1[0xa6] = (param_1[0xa2] + param_1[0x9e]) * 0.5;
      param_1[0xa7] = (param_1[0xa3] + param_1[0x9f]) * 0.5;
      param_1[0xa8] = 3.4028235e+38;
      fVar10 = 0.0;
      uVar8 = (ulong long)*(uint *)(lStack_88 + 0x10);
      if (0 < (int)*(uint *)(lStack_88 + 0x10)) {
        pfVar6 = *(float **)(lStack_88 + 0x18);
        fVar11 = fVar10;
        do {
          fVar10 = (*pfVar6 - param_1[0xa5]) * (*pfVar6 - param_1[0xa5]) +
                   (pfVar6[1] - param_1[0xa6]) * (pfVar6[1] - param_1[0xa6]) +
                   (pfVar6[2] - param_1[0xa7]) * (pfVar6[2] - param_1[0xa7]);
          if (fVar10 <= fVar11) {
            fVar10 = fVar11;
          }
          pfVar6 = pfVar6 + 4;
          uVar8 = uVar8 - 1;
          fVar11 = fVar10;
        } while (uVar8 != 0);
      }
      param_1[0xa9] = SQRT(fVar10);
    }
    if (pfStack_98 != (float *)0x0) {
      while( true ) {
        LOCK();
        cVar5 = *(char *)(pfVar4 + 0x3b);
        bVar9 = cVar5 == '\0';
        if (bVar9) {
          *(char *)(pfVar4 + 0x3b) = '\x01';
          cVar5 = '\0';
        }
        UNLOCK();
        if (bVar9) break;
        fVar10 = (float)_Thrd_id();
        if ((pfVar4[0x3c] == fVar10) || (pfVar4[0x3c] != 0.0)) goto LAB_180075f4f;
        Sleep();
      }
      cVar5 = '\0';
LAB_180075f4f:
      LOCK();
      pfVar1 = pfVar4 + 0x3a;
      fVar10 = *pfVar1;
      pfVar6 = (float *)(ulong long)(uint)fVar10;
      *pfVar1 = (float)((int)*pfVar1 + -1);
      UNLOCK();
      if (cVar5 == '\0') {
        if ((((fVar10 == 1.4013e-45) && (*(long long *)(pfStack_98 + 0x84) != 0)) &&
            (pfVar6 = pfStack_98, FUN_1800791a0(pfStack_98), *(char *)(pfVar6 + 0x3f) == '\0')) &&
           ((*(char *)(pfVar6 + 0x3d) == '\0' &&
            (((*(byte *)((long long)pfVar6 + 0xfd) & 0x20) == 0 ||
             ((*(byte *)((long long)pfVar6 + 0xfe) & 1) == 0)))))) {
          plVar3 = *(long long **)(pfVar6 + 0x84);
          pfVar6[0x84] = 0.0;
          pfVar6[0x85] = 0.0;
          if (plVar3 != (long long *)0x0) {
            (**(code **)(*plVar3 + 0x38))();
          }
        }
        LOCK();
        bVar2 = *(byte *)(pfVar4 + 0x3b);
        *(byte *)(pfVar4 + 0x3b) = 0;
        pfVar6 = (float *)(ulong long)bVar2;
        UNLOCK();
      }
    }
  }
  return pfVar6;
}




// 函数: void FUN_180075ff0(long long *param_1)
void FUN_180075ff0(long long *param_1)

{
  ushort uVar1;
  long long *plVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  long long lVar7;
  float fVar8;
  float fVar9;
  uint8_t auStack_138 [8];
  long long *plStack_130;
  uint32_t uStack_128;
  long long *plStack_120;
  long long *plStack_118;
  uint32_t uStack_110;
  long long lStack_108;
  void* uStack_100;
  void* uStack_f8;
  uint8_t uStack_f0;
  void* uStack_e8;
  void* uStack_d8;
  void* uStack_c8;
  void* uStack_c0;
  uint8_t uStack_b8;
  void* uStack_b0;
  void* uStack_a0;
  void* stackParameterC;
  
  stackParameterC = 0xfffffffffffffffe;
  while( true ) {
    if (((int)param_1[0x41] != 0) &&
       ((fVar8 = *(float *)(param_1 + 0x5b) - *(float *)((long long)param_1 + 0x2dc), fVar8 <= -0.01
        || (0.01 <= fVar8)))) {
      plVar2 = param_1;
      if ((((*(byte *)((long long)param_1 + 0xfd) & 0x40) == 0) || (param_1[0x42] == 0)) &&
         (param_1[0x36] != 0)) {
        plVar2 = (long long *)FUN_180085900();
      }
      iVar6 = 0;
      if (plVar2 == param_1) {
        plStack_120 = (long long *)0x0;
        auStack_138[0] = 0;
        uStack_128 = 0;
        plStack_130 = plVar2;
        FUN_18007f4c0(auStack_138);
        plVar2 = plStack_120 + 0x16;
        uVar1 = *(ushort *)(plStack_120 + 0x18);
        fVar8 = *(float *)(plStack_120[0x17] + -4 + (ulong long)uVar1 * 4);
        fVar9 = *(float *)((long long)param_1 + 0x2dc);
        if (fVar8 < *(float *)((long long)param_1 + 0x2dc)) {
          *(float *)((long long)param_1 + 0x2dc) = fVar8;
          uVar1 = *(ushort *)(plStack_120 + 0x18);
          fVar9 = fVar8;
        }
        uVar3 = (uint)uVar1;
        if (uVar1 < 2) {
          iVar6 = uVar3 - 1;
          fVar8 = 0.0;
          iVar5 = iVar6;
        }
        else {
          iVar5 = uVar3 - 1;
          if (0 < (int)(uVar3 - 2)) {
            do {
              iVar4 = iVar5 + iVar6 >> 1;
              if (*(float *)(plStack_120[0x17] + (long long)iVar4 * 4) <= fVar9) {
                iVar6 = iVar4;
                iVar4 = iVar5;
              }
              iVar5 = iVar4;
            } while (iVar6 < iVar5 + -1);
          }
          fVar8 = *(float *)(plStack_120[0x17] + (long long)iVar6 * 4);
          fVar8 = (fVar9 - fVar8) / (*(float *)(plStack_120[0x17] + (long long)iVar5 * 4) - fVar8);
          if (0.0 <= fVar8) {
            if (1.0 <= fVar8) {
              fVar8 = 1.0;
            }
          }
          else {
            fVar8 = 0.0;
          }
        }
        if (-1 < iVar6) {
          (**(code **)(*param_1 + 0x28))(param_1);
          uStack_100 = 0;
          uStack_f8 = 0;
          uStack_d8 = 0;
          uStack_e8 = 0;
          uStack_f0 = 0;
          FUN_18022f2e0(&uStack_100,param_1,0);
          (**(code **)(*param_1 + 0x38))(param_1);
          FUN_18022f9b0(&uStack_100,plVar2,iVar5,iVar6,fVar8);
          FUN_18022f410(&uStack_100);
        }
        FUN_18007f6a0(auStack_138);
        if (plStack_120 != (long long *)0x0) {
          (**(code **)(*plStack_120 + 0x38))();
        }
      }
      else {
        uStack_110 = 0;
        plStack_118 = plVar2;
        FUN_18007f770(&plStack_118);
        lVar7 = lStack_108 + 0xb0;
        uVar1 = *(ushort *)(lStack_108 + 0xc0);
        fVar8 = *(float *)(*(long long *)(lStack_108 + 0xb8) + -4 + (ulong long)uVar1 * 4);
        fVar9 = *(float *)((long long)param_1 + 0x2dc);
        if (fVar8 < *(float *)((long long)param_1 + 0x2dc)) {
          *(float *)((long long)param_1 + 0x2dc) = fVar8;
          uVar1 = *(ushort *)(lStack_108 + 0xc0);
          fVar9 = fVar8;
        }
        uVar3 = (uint)uVar1;
        if (uVar1 < 2) {
          iVar6 = uVar3 - 1;
          fVar8 = 0.0;
          iVar5 = iVar6;
        }
        else {
          iVar5 = uVar3 - 1;
          if (0 < (int)(uVar3 - 2)) {
            do {
              iVar4 = iVar5 + iVar6 >> 1;
              if (*(float *)(*(long long *)(lStack_108 + 0xb8) + (long long)iVar4 * 4) <= fVar9) {
                iVar6 = iVar4;
                iVar4 = iVar5;
              }
              iVar5 = iVar4;
            } while (iVar6 < iVar5 + -1);
          }
          fVar8 = *(float *)(*(long long *)(lStack_108 + 0xb8) + (long long)iVar6 * 4);
          fVar8 = (fVar9 - fVar8) /
                  (*(float *)(*(long long *)(lStack_108 + 0xb8) + (long long)iVar5 * 4) - fVar8);
          if (0.0 <= fVar8) {
            if (1.0 <= fVar8) {
              fVar8 = 1.0;
            }
          }
          else {
            fVar8 = 0.0;
          }
        }
        if (-1 < iVar6) {
          (**(code **)(*param_1 + 0x28))(param_1);
          uStack_c8 = 0;
          uStack_c0 = 0;
          uStack_a0 = 0;
          uStack_b0 = 0;
          uStack_b8 = 0;
          FUN_18022f2e0(&uStack_c8,param_1,0);
          (**(code **)(*param_1 + 0x38))(param_1);
          FUN_18022f9b0(&uStack_c8,lVar7,iVar5,iVar6,fVar8);
          FUN_18022f410(&uStack_c8);
        }
        FUN_18007f840(&plStack_118);
      }
      *(uint32_t *)(param_1 + 0x5b) = *(uint32_t *)((long long)param_1 + 0x2dc);
    }
    if ((*(byte *)((long long)param_1 + 0xfd) & 0x20) != 0) break;
    param_1 = (long long *)param_1[0x36];
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

long long * FUN_1800763c0(long long *param_1,long long *param_2)

{
  byte *pbVar1;
  uint32_t uVar2;
  long long lVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  void* uVar7;
  void* uVar8;
  void* uVar9;
  void* uVar10;
  long long lVar11;
  long long lVar12;
  long long lVar13;
  long long lVar14;
  long long lVar15;
  long long lVar16;
  long long lVar17;
  void* uVar18;
  long long *plVar19;
  undefined *puVar20;
  long long *plStackX_8;
  long long *plStackX_10;
  uint32_t uVar21;
  
  plStackX_10 = param_2;
  uVar18 = FUN_18062b1e0(_DAT_180c8ed18,0x300,0x10,9,0,0xfffffffffffffffe);
  plVar19 = (long long *)FUN_180075030(uVar18,0,0);
  *param_2 = (long long)plVar19;
  if (plVar19 != (long long *)0x0) {
    (**(code **)(*plVar19 + 0x28))(plVar19);
  }
  uVar21 = 1;
  *(byte *)(*param_2 + 0xfd) = *(byte *)(*param_2 + 0xfd) & 0xdf;
  lVar11 = param_1[0x18];
  lVar3 = *param_2;
  *(long long *)(lVar3 + 0xb8) = param_1[0x17];
  *(long long *)(lVar3 + 0xc0) = lVar11;
  *(byte *)(*param_2 + 0xfd) = *(byte *)(*param_2 + 0xfd) & 0xbf;
  uVar2 = *(uint32_t *)((long long)param_1 + 0xcc);
  lVar11 = param_1[0x1a];
  uVar4 = *(uint32_t *)((long long)param_1 + 0xd4);
  lVar12 = param_1[0x1b];
  uVar5 = *(uint32_t *)((long long)param_1 + 0xdc);
  lVar13 = param_1[0x1c];
  uVar6 = *(uint32_t *)((long long)param_1 + 0xe4);
  lVar3 = *param_2;
  *(int *)(lVar3 + 200) = (int)param_1[0x19];
  *(uint32_t *)(lVar3 + 0xcc) = uVar2;
  *(int *)(lVar3 + 0xd0) = (int)lVar11;
  *(uint32_t *)(lVar3 + 0xd4) = uVar4;
  *(int *)(lVar3 + 0xd8) = (int)lVar12;
  *(uint32_t *)(lVar3 + 0xdc) = uVar5;
  *(int *)(lVar3 + 0xe0) = (int)lVar13;
  *(uint32_t *)(lVar3 + 0xe4) = uVar6;
  if ((*(byte *)((long long)param_1 + 0xfd) & 0x20) == 0) {
    FUN_180075990(*param_2,param_1 + 0x36);
  }
  else {
    lVar3 = *param_2;
    plStackX_8 = param_1;
    (**(code **)(*param_1 + 0x28))(param_1);
    FUN_180075990(lVar3,&plStackX_8);
    (**(code **)(*param_1 + 0x38))(param_1);
  }
  *(long long *)(*param_2 + 0xa8) = param_1[0x15];
  pbVar1 = (byte *)(*param_2 + 0xfd);
  *pbVar1 = *pbVar1 ^ (*(byte *)(*param_2 + 0xfd) ^ *(byte *)((long long)param_1 + 0xfd)) & 2;
  *(int *)(*param_2 + 0x100) = (int)param_1[0x20];
  lVar11 = param_1[0x48];
  lVar3 = *param_2;
  *(long long *)(lVar3 + 0x238) = param_1[0x47];
  *(long long *)(lVar3 + 0x240) = lVar11;
  lVar11 = param_1[0x4a];
  lVar3 = *param_2;
  *(long long *)(lVar3 + 0x248) = param_1[0x49];
  *(long long *)(lVar3 + 0x250) = lVar11;
  uVar2 = *(uint32_t *)((long long)param_1 + 0x2ac);
  lVar11 = param_1[0x56];
  uVar4 = *(uint32_t *)((long long)param_1 + 0x2b4);
  lVar3 = *param_2;
  *(int *)(lVar3 + 0x2a8) = (int)param_1[0x55];
  *(uint32_t *)(lVar3 + 0x2ac) = uVar2;
  *(int *)(lVar3 + 0x2b0) = (int)lVar11;
  *(uint32_t *)(lVar3 + 0x2b4) = uVar4;
  uVar2 = *(uint32_t *)((long long)param_1 + 700);
  lVar11 = param_1[0x58];
  uVar4 = *(uint32_t *)((long long)param_1 + 0x2c4);
  lVar3 = *param_2;
  *(int *)(lVar3 + 0x2b8) = (int)param_1[0x57];
  *(uint32_t *)(lVar3 + 700) = uVar2;
  *(int *)(lVar3 + 0x2c0) = (int)lVar11;
  *(uint32_t *)(lVar3 + 0x2c4) = uVar4;
  *(int *)(*param_2 + 0x108) = (int)param_1[0x21];
  if ((long long *)(*param_2 + 0x218) != param_1 + 0x43) {
    FUN_1800588c0((long long *)(*param_2 + 0x218),param_1[0x43],param_1[0x44]);
  }
  puVar20 = &SystemStringTemplate;
  if ((undefined *)param_1[3] != (undefined *)0x0) {
    puVar20 = (undefined *)param_1[3];
  }
  (**(code **)(*(long long *)(*param_2 + 0x10) + 0x10))((long long *)(*param_2 + 0x10),puVar20);
  *(uint8_t *)(*param_2 + 0xf6) = *(uint8_t *)((long long)param_1 + 0xf6);
  uVar18 = *(void* *)((long long)param_1 + 0x27c);
  uVar7 = *(void* *)((long long)param_1 + 0x284);
  uVar8 = *(void* *)((long long)param_1 + 0x28c);
  uVar9 = *(void* *)((long long)param_1 + 0x294);
  uVar10 = *(void* *)((long long)param_1 + 0x29c);
  uVar2 = *(uint32_t *)((long long)param_1 + 0x2a4);
  lVar3 = *param_2;
  *(void* *)(lVar3 + 0x274) = *(void* *)((long long)param_1 + 0x274);
  *(void* *)(lVar3 + 0x27c) = uVar18;
  *(void* *)(lVar3 + 0x284) = uVar7;
  *(void* *)(lVar3 + 0x28c) = uVar8;
  *(void* *)(lVar3 + 0x294) = uVar9;
  *(void* *)(lVar3 + 0x29c) = uVar10;
  *(uint32_t *)(lVar3 + 0x2a4) = uVar2;
  *(uint8_t *)(*param_2 + 0xff) = *(uint8_t *)((long long)param_1 + 0xff);
  *(int *)(*param_2 + 0x270) = (int)param_1[0x4e];
  lVar11 = param_1[0x25];
  lVar12 = param_1[0x26];
  lVar13 = param_1[0x27];
  lVar14 = param_1[0x28];
  lVar15 = param_1[0x29];
  lVar16 = param_1[0x2a];
  lVar17 = param_1[0x2b];
  lVar3 = *param_2;
  *(long long *)(lVar3 + 0x120) = param_1[0x24];
  *(long long *)(lVar3 + 0x128) = lVar11;
  *(long long *)(lVar3 + 0x130) = lVar12;
  *(long long *)(lVar3 + 0x138) = lVar13;
  *(long long *)(lVar3 + 0x140) = lVar14;
  *(long long *)(lVar3 + 0x148) = lVar15;
  *(long long *)(lVar3 + 0x150) = lVar16;
  *(long long *)(lVar3 + 0x158) = lVar17;
  lVar11 = param_1[0x2d];
  lVar12 = param_1[0x2e];
  lVar13 = param_1[0x2f];
  lVar14 = param_1[0x30];
  uVar2 = *(uint32_t *)((long long)param_1 + 0x184);
  lVar15 = param_1[0x31];
  uVar4 = *(uint32_t *)((long long)param_1 + 0x18c);
  lVar16 = param_1[0x32];
  uVar5 = *(uint32_t *)((long long)param_1 + 0x194);
  lVar17 = param_1[0x33];
  uVar6 = *(uint32_t *)((long long)param_1 + 0x19c);
  lVar3 = *param_2;
  *(long long *)(lVar3 + 0x160) = param_1[0x2c];
  *(long long *)(lVar3 + 0x168) = lVar11;
  *(long long *)(lVar3 + 0x170) = lVar12;
  *(long long *)(lVar3 + 0x178) = lVar13;
  *(int *)(lVar3 + 0x180) = (int)lVar14;
  *(uint32_t *)(lVar3 + 0x184) = uVar2;
  *(int *)(lVar3 + 0x188) = (int)lVar15;
  *(uint32_t *)(lVar3 + 0x18c) = uVar4;
  *(int *)(lVar3 + 400) = (int)lVar16;
  *(uint32_t *)(lVar3 + 0x194) = uVar5;
  *(int *)(lVar3 + 0x198) = (int)lVar17;
  *(uint32_t *)(lVar3 + 0x19c) = uVar6;
  pbVar1 = (byte *)(*param_2 + 0xfd);
  *pbVar1 = *pbVar1 ^ (*(byte *)(*param_2 + 0xfd) ^ *(byte *)((long long)param_1 + 0xfd)) & 1;
  *(uint8_t *)(*param_2 + 0xf7) = *(uint8_t *)((long long)param_1 + 0xf7);
  *(int *)(*param_2 + 0x208) = (int)param_1[0x41];
  *(int *)(*param_2 + 0x1f8) = (int)param_1[0x3f];
  *(uint32_t *)(*param_2 + 0x1fc) = *(uint32_t *)((long long)param_1 + 0x1fc);
  *(int *)(*param_2 + 0x200) = (int)param_1[0x40];
  *(uint32_t *)(*param_2 + 0x204) = *(uint32_t *)((long long)param_1 + 0x204);
  *(int *)(*param_2 + 0x2d8) = (int)param_1[0x5b];
  uVar2 = *(uint32_t *)((long long)param_1 + 0x2dc);
  *(uint32_t *)(*param_2 + 0x2dc) = uVar2;
  lVar3 = *param_2;
  plVar19 = (long long *)param_1[0x4d];
  if (plVar19 != (long long *)0x0) {
    plStackX_8 = plVar19;
    (**(code **)(*plVar19 + 0x28))(plVar19,uVar2,(int)lVar14,(int)lVar16,uVar21);
  }
  plStackX_8 = *(long long **)(lVar3 + 0x268);
  *(long long **)(lVar3 + 0x268) = plVar19;
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x38))();
  }
  FUN_180076910(*param_2,param_1 + 0x37);
  return param_2;
}




// 函数: void FUN_180076760(long long *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180076760(long long *param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  void* uVar2;
  long long *plStack_40;
  long long *plStack_38;
  uint8_t auStack_30 [8];
  void* uStack_28;
  long long *plStack_18;
  undefined2 uStack_10;
  char cStack_e;
  
  uVar2 = 0xfffffffffffffffe;
  if (param_1[0x42] == 0) {
    param_1[0x3f] = 0;
    param_1[0x40] = 0;
    *(uint32_t *)(param_1 + 0x41) = 0;
    FUN_180079520();
  }
  else {
    (**(code **)(*param_1 + 0x28))();
    plStack_40 = (long long *)0x0;
    plStack_38 = (long long *)0x0;
    plStack_18 = (long long *)0x0;
    uStack_28 = 0;
    auStack_30[0] = 0;
    FUN_18022f2e0(&plStack_40,param_1,0,param_4,uVar2);
    (**(code **)(*param_1 + 0x38))(param_1);
    plVar1 = plStack_38;
    *(uint32_t *)(plStack_38 + 2) = 0;
    *(uint32_t *)(plStack_38 + 7) = 0;
    *(uint32_t *)(plStack_38 + 0x11) = 0;
    *(uint32_t *)(plStack_38 + 0xc) = 0;
    *(undefined2 *)(plStack_38 + 0x18) = 0;
    if (plStack_38[0x17] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    plStack_38[0x17] = 0;
    FUN_180085530(plStack_38[0x16]);
    plVar1[0x16] = 0;
    *(uint32_t *)(plVar1 + 0x19) = 0;
    uStack_10 = 0x101;
    if ((plStack_40 != (long long *)0x0) && (plStack_38 != (long long *)0x0)) {
      if (cStack_e != '\0') {
        FUN_180075b70();
      }
      FUN_18007f6a0(auStack_30);
      if ((char)uStack_10 != '\0') {
        FUN_180079520(plStack_40);
      }
      if (uStack_10._1_1_ != '\0') {
        FUN_180079520(plStack_40);
      }
      plVar1 = plStack_38;
      plStack_38 = (long long *)0x0;
      if (plVar1 != (long long *)0x0) {
        (**(code **)(*plVar1 + 0x38))();
      }
    }
    FUN_18007f6a0(auStack_30);
    if (plStack_18 != (long long *)0x0) {
      (**(code **)(*plStack_18 + 0x38))();
    }
    if (plStack_38 != (long long *)0x0) {
      (**(code **)(*plStack_38 + 0x38))();
    }
    if (plStack_40 != (long long *)0x0) {
      (**(code **)(*plStack_40 + 0x38))();
      return;
    }
  }
  return;
}




// 函数: void FUN_180076910(long long param_1,long long *param_2)
void FUN_180076910(long long param_1,long long *param_2)

{
  byte bVar1;
  long long lVar2;
  uint8_t uVar3;
  byte bVar4;
  uint uVar5;
  long long lVar6;
  long long *plVar7;
  
  if (*param_2 != *(long long *)(param_1 + 0x1b8)) {
    if (*(char *)(param_1 + 0xb1) != '\0') {
                    // WARNING: Subroutine does not return
      FUN_1808fd200();
    }
    FUN_180080810(param_1 + 0x1b8);
    lVar2 = *(long long *)(param_1 + 0x1b8);
    if (lVar2 != 0) {
      lVar6 = 0;
      bVar1 = *(byte *)(param_1 + 0xfd);
      bVar4 = (byte)((uint)*(uint32_t *)(*(long long *)(lVar2 + 0x1e0) + 0x1588) >> 0x1b) << 7;
      *(byte *)(param_1 + 0xfd) = bVar4 | bVar1 & 0x7f;
      uVar5 = *(uint *)(lVar2 + 0x138) & 0x3000;
      if (uVar5 == 0x1000) {
        *(uint8_t *)(param_1 + 0xf7) = 1;
      }
      else {
        uVar3 = 0;
        if (uVar5 == 0x2000) {
          uVar3 = 2;
        }
        *(uint8_t *)(param_1 + 0xf7) = uVar3;
      }
      bVar4 = bVar4 | bVar1 & 0x77;
      *(byte *)(param_1 + 0xfd) = bVar4;
      plVar7 = (long long *)(lVar2 + 0xb8);
      do {
        if (0xf < lVar6) break;
        if ((*plVar7 != 0) && (*(int *)(*plVar7 + 0x36c) != 0)) {
          bVar4 = bVar4 | 8;
          *(byte *)(param_1 + 0xfd) = bVar4;
        }
        lVar6 = lVar6 + 1;
        plVar7 = plVar7 + 1;
      } while ((bVar4 & 8) == 0);
      FUN_1800781e0(param_1);
    }
  }
  return;
}




// 函数: void FUN_180076a20(long long param_1)
void FUN_180076a20(long long param_1)

{
  int iVar1;
  
  iVar1 = _Mtx_lock(0x180c91910);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  *(char *)(param_1 + 0xfc) = *(char *)(param_1 + 0xfc) + '\x01';
  iVar1 = _Mtx_unlock(0x180c91910);
  if (iVar1 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar1);
  }
  return;
}




// 函数: void FUN_180076a80(long long param_1)
void FUN_180076a80(long long param_1)

{
  char *pcVar1;
  long long *plVar2;
  int memoryCompareResult;
  bool bVar4;
  
  iVar3 = _Mtx_lock(0x180c91910);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  pcVar1 = (char *)(param_1 + 0xfc);
  *pcVar1 = *pcVar1 + -1;
  if (*pcVar1 == '\0') {
    while( true ) {
      LOCK();
      bVar4 = *(char *)(param_1 + 0xec) == '\0';
      if (bVar4) {
        *(char *)(param_1 + 0xec) = '\x01';
      }
      UNLOCK();
      if (bVar4) break;
      Sleep();
    }
    while (*(int *)(param_1 + 0xe8) != 0) {
      Sleep(0);
    }
    if ((((*(long long *)(param_1 + 0x210) != 0) &&
         (FUN_1800791a0(param_1), *(char *)(param_1 + 0xfc) == '\0')) &&
        (*(char *)(param_1 + 0xf4) == '\0')) &&
       (((*(byte *)(param_1 + 0xfd) & 0x20) == 0 || ((*(byte *)(param_1 + 0xfe) & 1) == 0)))) {
      plVar2 = *(long long **)(param_1 + 0x210);
      *(void* *)(param_1 + 0x210) = 0;
      if (plVar2 != (long long *)0x0) {
        (**(code **)(*plVar2 + 0x38))();
      }
    }
    LOCK();
    if (*(char *)(param_1 + 0xec) == '\x01') {
      *(char *)(param_1 + 0xec) = '\0';
    }
    UNLOCK();
  }
  iVar3 = _Mtx_unlock(0x180c91910);
  if (iVar3 != 0) {
    __Throw_C_error_std__YAXH_Z(iVar3);
  }
  return;
}



void* FUN_180076b90(long long param_1)

{
  byte bVar1;
  long long lVar2;
  byte bVar3;
  
  bVar3 = *(byte *)(param_1 + 0xfd);
  lVar2 = param_1;
  if ((bVar3 & 0x20) == 0) {
    lVar2 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  if (0 < *(int *)(lVar2 + 0x200)) {
    lVar2 = *(long long *)(param_1 + 0x1b8);
    bVar1 = *(byte *)(lVar2 + 0x38c);
    if (bVar1 == 9) {
      bVar1 = func_0x00018022d300();
      *(byte *)(lVar2 + 0x38c) = bVar1;
      bVar3 = *(byte *)(param_1 + 0xfd);
    }
    if ((bVar3 & 0x20) == 0) {
      param_1 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
    }
    if ((*(long long *)(param_1 + 0x1e0) == 0) ||
       (*(byte *)(*(long long *)(param_1 + 0x1e0) + 0x15 + (ulong long)bVar1 * 0x18) < 2)) {
      return 0;
    }
  }
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int FUN_180076c50(long long param_1,long long *param_2)

{
  long long *plVar1;
  long long *plVar2;
  ulong long *puVar3;
  char cVar4;
  int iVar5;
  uint uVar6;
  long long lVar7;
  char *pcVar8;
  long long lVar9;
  ulong long uVar10;
  ulong long uVar11;
  ulong long *puVar12;
  uint uVar13;
  ulong long uVar14;
  uint32_t extraout_XMM0_Da;
  uint32_t uVar15;
  void* uStackX_8;
  void** systemPreviousNode;
  void* *systemStackPointer;
  uint in_stack_ffffffffffffff38;
  void* uVar16;
  ulong long *puStack_80;
  long long *plStack_78;
  code *pcStack_70;
  code *pcStack_68;
  void* uStack_60;
  void* uStack_58;
  void* uStack_50;
  uint32_t uStack_48;
  
  uVar16 = 0xfffffffffffffffe;
  iVar5 = 0;
  if (((*(long long *)(param_1 + 0x1b8) != 0) && (iVar5 = 0, (*(byte *)(param_2 + 1) & 4) == 0)) &&
     (*(char *)((long long)param_2 + 0x12) == '\0')) {
    iVar5 = FUN_18022d470();
  }
  if ((*(byte *)(param_2 + 1) & 0x20) == 0) {
    cVar4 = FUN_180076b90(param_1);
    if (cVar4 == '\0') {
      if ((char)param_2[2] != '\0') {
        puStack_80 = (ulong long *)0x0;
        plStack_78 = (long long *)0x0;
        pcStack_70 = (code *)0x0;
        pcStack_68 = _guard_check_icall;
        FUN_1800b6f90(extraout_XMM0_Da,param_1,&puStack_80);
        if (pcStack_70 != (code *)0x0) {
          (*pcStack_70)(&puStack_80,0,0);
        }
      }
      cVar4 = FUN_180076b90(param_1);
      if (cVar4 == '\0') {
        iVar5 = iVar5 + 1;
        if (*param_2 != 0) {
          uStackX_8 = param_1;
          FUN_18005ea90(*param_2,&uStackX_8);
        }
      }
    }
    else if ((char)param_2[2] != '\0') {
      FUN_18007b1e0(param_1,0);
    }
  }
  if ((*(byte *)(param_2 + 1) & 0x10) == 0) {
    return iVar5;
  }
  uStack_60 = 0;
  uStack_58 = 0;
  uStack_50 = 0;
  uStack_48 = 3;
  puStackX_10 = *(void* **)(param_1 + 0x1b8);
  uVar13 = *(uint *)(param_1 + 0x100) >> 0x16;
  pcVar8 = "";
  if ((char *)puStackX_10[3] != (char *)0x0) {
    pcVar8 = (char *)puStackX_10[3];
  }
  uVar6 = 0x1505;
  cVar4 = *pcVar8;
  while (cVar4 != '\0') {
    pcVar8 = pcVar8 + 1;
    uVar6 = uVar6 * 0x21 + (int)cVar4;
    cVar4 = *pcVar8;
  }
  uVar11 = (ulong long)uVar6;
  if ((uVar13 & 1) != 0) {
    uVar11 = (ulong long)uVar6 | 0x400000000;
  }
  lVar9 = param_2[9];
  if (lVar9 != 0) {
    plVar1 = (long long *)(*(long long *)(lVar9 + 8) + *(ulong long *)(lVar9 + 0x10) * 8);
    puVar12 = (ulong long *)*plVar1;
    plVar2 = (long long *)
             (*(long long *)(lVar9 + 8) + (uVar11 % (*(ulong long *)(lVar9 + 0x10) & 0xffffffff)) * 8)
    ;
    for (puVar3 = (ulong long *)*plVar2;
        (puStack_80 = puVar12, plStack_78 = plVar1, puVar3 != (ulong long *)0x0 &&
        (puStack_80 = puVar3, plStack_78 = plVar2, uVar11 != *puVar3));
        puVar3 = (ulong long *)puVar3[1]) {
    }
    if (puStack_80 != puVar12) goto LAB_180076feb;
  }
  plVar1 = param_2 + 5;
  lVar9 = param_2[7] - *plVar1;
  if ((ulong long)(lVar9 / 0x18) < 0x100) {
    lVar7 = CreateSystemThreadObject(_DAT_180c8ed18,0x1800,(char)param_2[8]);
    lVar9 = *plVar1;
    if (lVar9 != param_2[6]) {
                    // WARNING: Subroutine does not return
      memmove(lVar7,lVar9,param_2[6] - lVar9);
    }
    if (lVar9 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *plVar1 = lVar7;
    param_2[6] = lVar7;
    param_2[7] = lVar7 + 0x1800;
    lVar9 = 0;
  }
  systemStackPointer = &uStackX_8;
  uStackX_8 = 0;
  uVar15 = FUN_1801cdb50(lVar9,puStackX_10,&uStack_60,0,in_stack_ffffffffffffff38 & 0xffffff00,0,
                         (byte)uVar13 & 1,plVar1,1,0,0,&uStackX_8,uVar16);
  puStackX_10 = &uStackX_8;
  uStackX_8 = 0;
  cVar4 = FUN_1801de280(uVar15,plVar1,&uStackX_8);
  if (cVar4 == '\0') {
    iVar5 = iVar5 + 1;
  }
  param_2[6] = *plVar1;
  lVar9 = param_2[9];
  uVar14 = uVar11 % (ulong long)*(uint *)(lVar9 + 0x10);
  for (puVar12 = *(ulong long **)(*(long long *)(lVar9 + 8) + uVar14 * 8); puVar12 != (ulong long *)0x0
      ; puVar12 = (ulong long *)puVar12[1]) {
    if (uVar11 == *puVar12) goto LAB_180076feb;
  }
  plVar1 = *(long long **)(lVar9 + 0x30);
  uVar10 = (long long)(int)plVar1[2] + 0xfU & 0xfffffffffffffff0;
  *(int *)(plVar1 + 2) = (int)uVar10 + 0x10;
  puVar12 = (ulong long *)(*plVar1 + uVar10);
  *puVar12 = uVar11;
  puVar12[1] = 0;
  FUN_18066c220(lVar9 + 0x20,&uStackX_8,*(uint32_t *)(lVar9 + 0x10),*(uint32_t *)(lVar9 + 0x18),
                1);
  if ((char)uStackX_8 != '\0') {
    uVar14 = uVar11 % (ulong long)uStackX_8._4_4_;
    FUN_180083b20(lVar9,uStackX_8._4_4_);
  }
  puVar12[1] = *(ulong long *)(*(long long *)(lVar9 + 8) + uVar14 * 8);
  *(ulong long **)(*(long long *)(lVar9 + 8) + uVar14 * 8) = puVar12;
  *(long long *)(lVar9 + 0x18) = *(long long *)(lVar9 + 0x18) + 1;
LAB_180076feb:
  FUN_180080df0(&uStack_60);
  return iVar5;
}




// 函数: void FUN_180077020(long long *param_1)
void FUN_180077020(long long *param_1)

{
  void* *puVar1;
  void** systemDataTable;
  
  puVar1 = (void* *)param_1[1];
  for (puVar2 = (void* *)*param_1; puVar2 != puVar1; puVar2 = puVar2 + 6) {
    *puVar2 = &SystemGlobalDataReference;
    if (puVar2[1] != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    puVar2[1] = 0;
    *(uint32_t *)(puVar2 + 3) = 0;
    *puVar2 = &SystemMemoryAllocatorReference;
  }
  if (*param_1 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_180077040(long long param_1)

{
  int *piVar1;
  byte bVar2;
  long long lVar3;
  ulong long uVar4;
  long long systemTimeValue;
  long long lVar6;
  
  if (*(long long *)(param_1 + 0x1b8) != 0) {
    lVar6 = 0xb8;
    lVar5 = _DAT_180c86870;
    do {
      lVar3 = *(long long *)(lVar6 + *(long long *)(param_1 + 0x1b8));
      if ((((lVar3 != 0) && (*(long long *)(*(long long *)(param_1 + 0x1b8) + 0x328 + lVar6) == 0)) &&
          ((*(uint *)(lVar3 + 0x328) & 0x20000000) == 0)) && (*(long long *)(lVar3 + 0x370) == 0)) {
        if (*(long long *)(lVar3 + 0x1d8) == 0) {
          FUN_18023b050(lVar3,0);
          lVar5 = _DAT_180c86870;
          piVar1 = (int *)(*(long long *)(lVar6 + *(long long *)(param_1 + 0x1b8)) + 0x3a8);
          *piVar1 = *piVar1 + 1;
        }
        else if (lVar5 != 0) {
          *(long long *)(lVar3 + 0x340) = (long long)*(int *)(lVar5 + 0x224);
        }
      }
      lVar6 = lVar6 + 8;
    } while (lVar6 < 0x138);
  }
  bVar2 = *(byte *)(param_1 + 0xf9);
  if (bVar2 != 0) {
    if (*(long long *)(param_1 + 0x1d8) != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *(void* *)(param_1 + 0x1d8) = 0;
    LOCK();
    bVar2 = *(byte *)(param_1 + 0xf9);
    *(byte *)(param_1 + 0xf9) = 0;
    UNLOCK();
  }
  uVar4 = (ulong long)bVar2;
  if (*(long long *)(param_1 + 0x1e8) != 0) {
    FUN_180080060();
    uVar4 = *(ulong long *)(param_1 + 0x1f0);
    *(void* *)(param_1 + 0x1e8) = 0;
    if (uVar4 != 0) {
      *(byte *)(uVar4 + 0xfe) = *(byte *)(uVar4 + 0xfe) & 0xfb;
    }
  }
  return uVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180077150(long long *param_1)
void FUN_180077150(long long *param_1)

{
  void* uVar1;
  ulong long *puVar2;
  ulong long uVar3;
  long long* systemMemoryPointer;
  long long systemTimeValue;
  byte bVar6;
  uint8_t stackBuffer [32];
  ulong long *puStack_68;
  void* uStack_60;
  undefined *puStack_58;
  ulong long *puStack_50;
  ulong long uStack_48;
  ulong long auStack_40 [2];
  void* uStack_30;
  char cStack_28;
  char cStack_27;
  char cStack_26;
  ulong long uStack_20;
  
  uStack_60 = 0xfffffffffffffffe;
  uStack_20 = _DAT_180bf00a8 ^ (ulong long)stackBuffer;
  uVar1 = *(void* *)(param_1[0x37] + 0x1e0);
  puStack_58 = &UNK_18098bc80;
  puStack_50 = auStack_40;
  auStack_40[0] = auStack_40[0] & 0xffffffffffffff00;
  uStack_48._0_4_ = 0x12;
  strcpy_s(auStack_40,0x20,&UNK_1809ffa98);
  uVar3 = FUN_180240430(uVar1,&puStack_58,0);
  puStack_58 = &SystemMemoryAllocatorReference;
  if (uVar3 != 0) {
    lVar5 = param_1[0x37];
    if ((*(ulong long *)(lVar5 + 0x140) & uVar3) != 0) {
      bVar6 = *(byte *)((long long)param_1 + 0xfd) & 0x20;
      plVar4 = param_1;
      if (bVar6 == 0) {
        plVar4 = (long long *)func_0x000180085de0(param_1[0x36]);
      }
      if (((*(uint *)(plVar4 + 0x20) & 0x8000000) == 0) && (bVar6 != 0)) {
        puStack_68 = (ulong long *)param_1;
        (**(code **)(*param_1 + 0x28))(param_1);
        puStack_58 = (undefined *)0x0;
        puStack_50 = (ulong long *)0x0;
        puStack_68 = &uStack_48;
        uStack_30 = 0;
        auStack_40[0] = 0;
        uStack_48._0_4_ = (uint)uStack_48 & 0xffffff00;
        FUN_18022f2e0(&puStack_58,param_1,0);
        (**(code **)(*param_1 + 0x38))(param_1);
        FUN_180237d00(&puStack_58);
        FUN_18022f390(&puStack_58);
        FUN_18022f410(&puStack_58);
        lVar5 = param_1[0x37];
      }
      if ((*(ulong long *)(lVar5 + 0x140) & uVar3) != 0) goto LAB_18007738d;
    }
    plVar4 = param_1;
    if ((*(byte *)((long long)param_1 + 0xfd) & 0x20) == 0) {
      plVar4 = (long long *)func_0x000180085de0(param_1[0x36]);
    }
    if ((*(uint *)(plVar4 + 0x20) & 0x8000000) != 0) {
      puStack_68 = (ulong long *)param_1;
      (**(code **)(*param_1 + 0x28))(param_1);
      puStack_58 = (undefined *)0x0;
      puStack_50 = (ulong long *)0x0;
      puStack_68 = &uStack_48;
      uStack_30 = 0;
      auStack_40[0] = 0;
      uStack_48._0_4_ = (uint)uStack_48 & 0xffffff00;
      FUN_18022f2e0(&puStack_58,param_1,0);
      (**(code **)(*param_1 + 0x38))(param_1);
      FUN_180238950(&puStack_58);
      if (puStack_50 != (ulong long *)0x0) {
        if (cStack_26 != '\0') {
          FUN_180075b70(puStack_58);
        }
        FUN_18007f6a0(&uStack_48);
        if (cStack_28 != '\0') {
          FUN_180079520(puStack_58);
        }
        if (cStack_27 != '\0') {
          FUN_180079520(puStack_58);
        }
        puVar2 = puStack_50;
        puStack_68 = puStack_50;
        puStack_50 = (ulong long *)0x0;
        if (puVar2 != (ulong long *)0x0) {
          (**(code **)(*puVar2 + 0x38))();
        }
      }
      FUN_18022f410(&puStack_58);
    }
  }
LAB_18007738d:
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_20 ^ (ulong long)stackBuffer);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void* FUN_180077420(long long param_1,long long param_2)

{
  uint *puVar1;
  long long *plVar2;
  uint uVar3;
  code *pcVar4;
  bool bVar5;
  byte bVar6;
  char cVar7;
  int iVar8;
  uint uVar9;
  long long lVar10;
  long long lVar11;
  long long lVar12;
  long long lVar13;
  ulong long uVar14;
  code *pcVar15;
  bool bVar16;
  void* uStack_78;
  uint32_t uStack_70;
  uint32_t uStack_6c;
  undefined2 uStack_68;
  uint8_t uStack_66;
  uint32_t uStack_64;
  uint8_t uStack_60;
  void* uStack_58;
  long long lStack_50;
  void* uStack_48;
  void* uStack_40;
  uint32_t uStack_38;
  void* uStack_30;
  
  lVar13 = param_1;
  if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
    lVar13 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  lVar12 = *(long long *)(param_1 + 0x1b8);
  bVar6 = *(byte *)(lVar12 + 0x38c);
  if (bVar6 == 9) {
    bVar6 = func_0x00018022d300();
    *(byte *)(lVar12 + 0x38c) = bVar6;
  }
  if ((*(long long *)(lVar13 + 0x1e0) == 0) ||
     (((lVar12 = (ulong long)bVar6 * 0x18,
       *(char *)(*(long long *)(lVar13 + 0x1e0) + 0x15 + lVar12) != '\x03' &&
       (*(char *)(*(long long *)(lVar13 + 0x1e0) + 0x15 + lVar12) != '\x04')) &&
      (*(char *)(*(long long *)(lVar13 + 0x1e0) + lVar12 + 0x15) != '\x02')))) {
    *(int *)(param_2 + 0x124e8) = *(int *)(param_2 + 0x124e8) + 1;
  }
  else if (*(char *)(*(long long *)(lVar13 + 0x1e0) + lVar12 + 0x15) != '\x04') {
    uStack_78 = 0;
    uStack_70 = 0;
    uStack_6c = 0xffffffff;
    uStack_68 = 1;
    uStack_66 = 0;
    uStack_64 = 0xffffffff;
    uStack_60 = 1;
    uStack_58 = 0;
    lStack_50 = 0;
    uStack_48 = 0;
    uStack_40 = 0;
    uStack_38 = 3;
    uStack_30 = 0;
    iVar8 = FUN_18022d470(*(void* *)(param_1 + 0x1b8),&uStack_78);
    if (iVar8 < 1) {
      if (lStack_50 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      bVar5 = false;
      if ((*(byte *)(param_1 + 0xfd) & 8) != 0) {
        lVar13 = 0xb8;
        pcVar15 = (code *)&UNK_1802426a0;
        do {
          lVar12 = *(long long *)(lVar13 + *(long long *)(param_1 + 0x1b8));
          if (((lVar12 != 0) && (lVar11 = *(long long *)(lVar12 + 0x370), lVar11 != 0)) &&
             ((cVar7 = func_0x0001802434e0(), cVar7 != '\0' &&
              ((*(char *)(lVar11 + 0xde) != '\0' &&
               (bVar5 = true, (*(byte *)(param_2 + 0x1bd8) & 0x20) != 0)))))) {
            pcVar4 = *(code **)(**(long long **)(param_2 + 0x3580) + 0xb8);
            if (pcVar4 == pcVar15) {
              lVar11 = (*(long long **)(param_2 + 0x3580))[0xda];
            }
            else {
              lVar11 = (*pcVar4)();
            }
            puVar1 = (uint *)(lVar11 + 0x3f68);
            LOCK();
            uVar3 = *puVar1;
            *puVar1 = *puVar1 + 1;
            UNLOCK();
            uVar9 = uVar3 >> 10;
            uVar14 = (ulong long)uVar9;
            if (*(long long *)(lVar11 + 0x3f70 + (ulong long)uVar9 * 8) == 0) {
              lVar10 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
              plVar2 = (long long *)(lVar11 + 0x3f70 + uVar14 * 8);
              LOCK();
              bVar16 = *plVar2 == 0;
              if (bVar16) {
                *plVar2 = lVar10;
              }
              UNLOCK();
              if (bVar16) {
                LOCK();
                *(uint8_t *)(uVar14 + 0x48 + (long long)puVar1) = 0;
                UNLOCK();
              }
              else {
                if (lVar10 != 0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900();
                }
                do {
                } while (*(char *)(uVar14 + 0x48 + (long long)puVar1) != '\0');
              }
            }
            else {
              do {
              } while (*(char *)(uVar14 + 0x48 + (long long)puVar1) != '\0');
            }
            *(long long *)
             (*(long long *)(lVar11 + 0x3f70 + uVar14 * 8) + (ulong long)(uVar3 + uVar9 * -0x400) * 8)
                 = lVar12;
            pcVar15 = (code *)&UNK_1802426a0;
          }
          lVar13 = lVar13 + 8;
        } while (lVar13 < 0x138);
        if (bVar5) {
          return 0;
        }
      }
      *(byte *)(param_1 + 0xfe) = *(byte *)(param_1 + 0xfe) | 4;
      return 1;
    }
    if (lStack_50 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  return 0;
}




// 函数: void FUN_180077710(long long param_1)
void FUN_180077710(long long param_1)

{
  int *piVar1;
  void** systemDataTable;
  long long lVar3;
  ulong long uVar4;
  
  puVar2 = *(void* **)(param_1 + 0x28);
  if (puVar2 == (void* *)0x0) {
    return;
  }
  uVar4 = (ulong long)puVar2 & 0xffffffffffc00000;
  if (uVar4 != 0) {
    lVar3 = uVar4 + 0x80 + ((long long)puVar2 - uVar4 >> 0x10) * 0x50;
    lVar3 = lVar3 - (ulong long)*(uint *)(lVar3 + 4);
    if ((*(void ***)(uVar4 + 0x70) == &ExceptionList) && (*(char *)(lVar3 + 0xe) == '\0')) {
      *puVar2 = *(void* *)(lVar3 + 0x20);
      *(void* **)(lVar3 + 0x20) = puVar2;
      piVar1 = (int *)(lVar3 + 0x18);
      *piVar1 = *piVar1 + -1;
      if (*piVar1 == 0) {
        FUN_18064d630();
        return;
      }
    }
    else {
      func_0x00018064e870(uVar4,CONCAT71(0xff000000,*(void ***)(uVar4 + 0x70) == &ExceptionList),
                          puVar2,uVar4,0xfffffffffffffffe);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_180077750(long long param_1,uint *param_2,float *param_3,long long param_4,
                       long long param_5)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  uint uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  char cVar21;
  byte bVar22;
  uint32_t uVar23;
  void* uVar24;
  ulong long uVar25;
  void* *puVar26;
  long long lVar27;
  long long lVar28;
  uint32_t *puVar29;
  uint *puVar30;
  byte bVar31;
  char *pcVar32;
  int iVar33;
  ulong long uVar34;
  uint *puVar35;
  bool bVar36;
  uint32_t auStackX_8 [2];
  uint *puStackX_10;
  float *pfStackX_18;
  long long lStackX_20;
  uint32_t auStack_138 [2];
  ulong long uStack_130;
  void* *apuStack_128 [2];
  long long lStack_118;
  void* uStack_108;
  void* uStack_100;
  void* uStack_f8;
  void* uStack_f0;
  void* uStack_e8;
  void* uStack_e0;
  void* uStack_d8;
  void* uStack_d0;
  float fStack_c8;
  float fStack_c4;
  float fStack_c0;
  float fStack_bc;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  float fStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  float fStack_9c;
  float fStack_98;
  float fStack_94;
  float fStack_90;
  float fStack_8c;
  
  puStackX_10 = param_2;
  pfStackX_18 = param_3;
  lStackX_20 = param_4;
  if (*(char *)(param_1 + 0xf9) == '\0') {
    uVar24 = FUN_18062b1e0(_DAT_180c8ed18,0xc0,8,9);
    uVar24 = FUN_180084ea0(uVar24);
    *(void* *)(param_1 + 0x1d8) = uVar24;
    LOCK();
    *(uint8_t *)(param_1 + 0xf9) = 1;
    UNLOCK();
  }
  if ((char)*(byte *)(param_1 + 0xfd) < '\0') {
    lVar27 = *(long long *)(param_1 + 0x1b8);
    uVar24 = *(void* *)(lVar27 + 0x290);
    *(void* *)(param_1 + 0x2a8) = *(void* *)(lVar27 + 0x288);
    *(void* *)(param_1 + 0x2b0) = uVar24;
    uVar23 = *(uint32_t *)(lVar27 + 0x29c);
    uVar7 = *(uint32_t *)(lVar27 + 0x2a0);
    uVar8 = *(uint32_t *)(lVar27 + 0x2a4);
    *(uint32_t *)(param_1 + 0x2b8) = *(uint32_t *)(lVar27 + 0x298);
    *(uint32_t *)(param_1 + 700) = uVar23;
    *(uint32_t *)(param_1 + 0x2c0) = uVar7;
    *(uint32_t *)(param_1 + 0x2c4) = uVar8;
  }
  uVar25 = (ulong long)*(uint *)(param_1 + 0x270);
  if ((*param_2 & *(uint *)(param_1 + 0x270)) == 0) goto FUN_180077ef9;
  bVar31 = *(byte *)(param_1 + 0xfd) & 0x20;
  lVar27 = param_1;
  if (bVar31 == 0) {
    lVar27 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  if (*(int *)(lVar27 + 0x200) == 0) {
LAB_180077847:
    if ((*(byte *)(param_1 + 0x100) & 4) != 0) goto LAB_180077879;
    lVar27 = *(long long *)(param_1 + 0x1b8);
    uVar25 = 0;
    if (*(char *)(lVar27 + 0x38c) == '\t') {
      uVar25 = func_0x00018022d300();
      *(char *)(lVar27 + 0x38c) = (char)uVar25;
      if ((char)uVar25 == '\t') goto LAB_180077879;
    }
FUN_180077ef9:
    uVar25 = uVar25 & 0xffffffffffffff00;
  }
  else {
    lVar27 = param_1;
    if (bVar31 == 0) {
      lVar27 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
    }
    if (*(int *)(lVar27 + 0x1fc) * 3 == 0) goto LAB_180077847;
LAB_180077879:
    cVar21 = func_0x0001800854e0(param_1);
    if ((cVar21 == '\0') || (param_4 == 0)) {
      FUN_18007b1e0(param_1,0);
      if ((*(byte *)(param_1 + 0xfe) & 4) == 0) {
        uVar24 = FUN_180077420(param_1,param_2);
        bVar31 = (char)uVar24 << 2;
        bVar22 = bVar31 | *(byte *)(param_1 + 0xfe) & 0xfb;
        uVar25 = CONCAT71((int7)((ulong long)uVar24 >> 8),bVar22);
        *(byte *)(param_1 + 0xfe) = bVar22;
        if ((bVar31 & 4) == 0) goto FUN_180077ef9;
      }
      uVar6 = *(uint *)(*(long long *)(param_1 + 0x1b8) + 0x388);
      if (((uVar6 >> 0x19 & 1) != 0) ||
         ((*(long long *)(param_1 + 600) != 0 && (0 < *(int *)(*(long long *)(param_1 + 600) + 0x1c)))
         )) {
        iVar33 = *(int *)(_DAT_180c86870 + 0x224);
        puVar26 = *(void* **)(param_1 + 600);
        if (puVar26 == (void* *)0x0) {
          puVar26 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,3);
          *(void* *)((long long)puVar26 + 0x2c) = 0xffffffffffffffff;
          *(uint32_t *)(puVar26 + 9) = 0xffffffff;
          *puVar26 = 0;
          puVar26[2] = 0;
          puVar26[7] = 0;
          *(uint32_t *)(puVar26 + 5) = 0xffffffff;
          *(uint32_t *)(puVar26 + 4) = 0xffffffff;
          puVar26[3] = 0;
          *(uint32_t *)(puVar26 + 8) = 0;
          *(uint32_t *)(puVar26 + 1) = 0;
          *(uint8_t *)((long long)puVar26 + 0x44) = 0;
          *(uint8_t *)((long long)puVar26 + 0x24) = 0;
          *(void* **)(param_1 + 600) = puVar26;
        }
        param_3 = pfStackX_18;
        if (*(int *)(puVar26 + 4) != iVar33) {
          *(int *)(puVar26 + 4) = iVar33;
          FUN_180079270(param_1,param_5);
          param_3 = pfStackX_18;
          if (((byte)(uVar6 >> 0x19) & 1) != 0) {
            if ((*(uint *)(param_1 + 0x100) & 0x800) != 0) {
              FUN_18007ee70(param_1);
            }
            lStack_118 = _DAT_180c86890 + 0x5868;
            puVar30 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0x6a78) * 0x908 + lStack_118);
            LOCK();
            uVar6 = *puVar30;
            *puVar30 = *puVar30 + 1;
            UNLOCK();
            uVar25 = (ulong long)(uVar6 >> 9);
            uVar34 = (ulong long)(uVar6 >> 9);
            pcVar32 = (char *)((long long)puVar30 + uVar34 + 0x808);
            puVar35 = puVar30 + (uVar25 + 1) * 2;
            uStack_130 = uVar25;
            do {
              iVar33 = (int)uVar34;
              if (*(long long *)puVar35 == 0) {
                lVar27 = CreateSystemThreadObject(_DAT_180c8ed18,0xc000,0x25);
                LOCK();
                bVar36 = *(long long *)(puVar30 + (long long)iVar33 * 2 + 2) == 0;
                if (bVar36) {
                  *(long long *)(puVar30 + (long long)iVar33 * 2 + 2) = lVar27;
                }
                UNLOCK();
                if (bVar36) {
                  FUN_1800e94a0(puVar30,iVar33 << 9);
                  LOCK();
                  *(uint8_t *)((long long)puVar30 + (long long)iVar33 + 0x808) = 0;
                  UNLOCK();
                  uVar25 = uStack_130;
                }
                else {
                  if (lVar27 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                    uVar25 = uStack_130;
                  } while (*pcVar32 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar32 != '\0');
              }
              pcVar32 = pcVar32 + 1;
              uVar34 = (ulong long)(iVar33 + 1);
              puVar35 = puVar35 + 2;
            } while ((long long)(pcVar32 + (-0x808 - (long long)puVar30)) <= (long long)uVar25);
            puVar26 = (void* *)
                      (*(long long *)
                        ((long long)*(int *)(lStack_118 + 0x1210) * 0x908 + lStack_118 + 8 +
                        uVar25 * 8) + (ulong long)(uVar6 - (uVar6 & 0xfffffe00)) * 0x60);
            lVar27 = param_1;
            apuStack_128[0] = puVar26;
            if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
              lVar27 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
            }
            lVar28 = *(long long *)(param_1 + 0x1b8);
            bVar31 = *(byte *)(lVar28 + 0x38c);
            if (bVar31 == 9) {
              bVar31 = func_0x00018022d300();
              *(byte *)(lVar28 + 0x38c) = bVar31;
            }
            param_2 = puStackX_10;
            lVar27 = *(long long *)(lVar27 + 0x1e0);
            *puVar26 = *(void* *)(lVar27 + (ulong long)bVar31 * 0x18);
            puVar26[1] = *(void* *)(lVar27 + 8 + (ulong long)bVar31 * 0x18);
            *(uint32_t *)(apuStack_128[0] + 2) =
                 *(uint32_t *)(*(long long *)(param_1 + 600) + 0x2c);
            *(uint32_t *)((long long)apuStack_128[0] + 0x14) =
                 *(uint32_t *)(*(long long *)(param_1 + 600) + 0x4c);
            *(int *)(apuStack_128[0] + 9) = (int)*(char *)(*(long long *)(param_1 + 600) + 0x44);
            if ((*(long long *)(param_1 + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(param_1 + 0x2d0) + 0x14) == 0)) {
              uVar23 = 0xffffffff;
            }
            else {
              uVar23 = *(uint32_t *)(param_1 + 0x108);
            }
            *(uint32_t *)(apuStack_128[0] + 3) = uVar23;
            if ((*(long long *)(param_1 + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(param_1 + 0x2d0) + 0x14) == 0)) {
              uVar23 = 0xffffffff;
            }
            else {
              uVar23 = *(uint32_t *)(param_1 + 0x10c);
            }
            *(uint32_t *)((long long)apuStack_128[0] + 0x1c) = uVar23;
            if ((*(long long *)(param_1 + 0x2d0) == 0) ||
               (*(int *)(*(long long *)(param_1 + 0x2d0) + 0x14) == 0)) {
              uVar23 = 0xffffffff;
            }
            else {
              uVar23 = *(uint32_t *)(param_1 + 0x110);
            }
            *(uint32_t *)(apuStack_128[0] + 4) = uVar23;
            *(byte *)((long long)apuStack_128[0] + 0x4e) = *(byte *)(param_1 + 0xfe) >> 3 & 1;
            if (*(int *)(param_1 + 0x108) != -1) {
              puVar29 = *(uint32_t **)(param_1 + 0x2d0);
              uVar23 = puVar29[1];
              uVar7 = puVar29[2];
              uVar8 = puVar29[3];
              *(uint32_t *)(apuStack_128[0] + 5) = *puVar29;
              *(uint32_t *)((long long)apuStack_128[0] + 0x2c) = uVar23;
              *(uint32_t *)(apuStack_128[0] + 6) = uVar7;
              *(uint32_t *)((long long)apuStack_128[0] + 0x34) = uVar8;
              uVar24 = *(void* *)(puVar29 + 6);
              apuStack_128[0][7] = *(void* *)(puVar29 + 4);
              apuStack_128[0][8] = uVar24;
            }
            *(uint8_t *)((long long)apuStack_128[0] + 0x4f) =
                 *(uint8_t *)(*(long long *)(param_1 + 600) + 0x24);
            lVar27 = *(long long *)(param_1 + 600);
            if (*(char *)(lVar27 + 0x24) != '\0') {
              uVar23 = *(uint32_t *)(param_1 + 0x2ac);
              uVar7 = *(uint32_t *)(param_1 + 0x2b0);
              uVar8 = *(uint32_t *)(param_1 + 0x2b4);
              *(uint32_t *)(apuStack_128[0] + 10) = *(uint32_t *)(param_1 + 0x2a8);
              *(uint32_t *)((long long)apuStack_128[0] + 0x54) = uVar23;
              *(uint32_t *)(apuStack_128[0] + 0xb) = uVar7;
              *(uint32_t *)((long long)apuStack_128[0] + 0x5c) = uVar8;
              lVar27 = *(long long *)(param_1 + 600);
            }
            *(bool *)((long long)apuStack_128[0] + 0x4c) = *(long long *)(lVar27 + 0x10) != 0;
            *(uint8_t *)((long long)apuStack_128[0] + 0x4d) = 1;
            if ((*(char *)(param_5 + 0xc) != '\0') ||
               (0 < *(int *)(*(long long *)(param_1 + 600) + 0x1c))) {
              *(uint8_t *)((long long)apuStack_128[0] + 0x4d) = 0;
            }
            if (*(uint **)(puStackX_10 + 10) == (uint *)0x0) {
              auStack_138[0] = 0xffffffff;
              puVar29 = auStack_138;
              puVar35 = puStackX_10;
            }
            else {
              auStackX_8[0] = 0xffffffff;
              puVar29 = auStackX_8;
              puVar35 = *(uint **)(puStackX_10 + 10);
            }
            FUN_180080e90(puVar35 + 0xce2,puVar29,apuStack_128);
            param_3 = pfStackX_18;
            param_4 = lStackX_20;
          }
        }
      }
    }
    if ((*(uint *)(param_1 + 0x100) & 0x4000000) != 0) {
      fVar9 = *param_3;
      fVar10 = param_3[1];
      fVar11 = param_3[2];
      fVar12 = param_3[3];
      fVar13 = param_3[4];
      fVar14 = param_3[5];
      fVar15 = param_3[6];
      fVar16 = param_3[7];
      fVar17 = param_3[8];
      fVar18 = param_3[9];
      fVar19 = param_3[10];
      fVar20 = param_3[0xb];
      fVar1 = *(float *)(param_1 + 0x124);
      fVar2 = *(float *)(param_1 + 0x120);
      fVar3 = *(float *)(param_1 + 0x128);
      fVar4 = *(float *)(param_1 + 0x134);
      fVar5 = *(float *)(param_1 + 0x130);
      fStack_c8 = fVar1 * fVar13 + fVar2 * fVar9 + fVar3 * fVar17;
      fStack_c4 = fVar1 * fVar14 + fVar2 * fVar10 + fVar3 * fVar18;
      fStack_c0 = fVar1 * fVar15 + fVar2 * fVar11 + fVar3 * fVar19;
      fStack_bc = fVar1 * fVar16 + fVar2 * fVar12 + fVar3 * fVar20;
      fVar1 = *(float *)(param_1 + 0x138);
      fVar2 = *(float *)(param_1 + 0x140);
      fVar3 = *(float *)(param_1 + 0x144);
      fStack_b8 = fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17;
      fStack_b4 = fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18;
      fStack_b0 = fVar4 * fVar15 + fVar5 * fVar11 + fVar1 * fVar19;
      fStack_ac = fVar4 * fVar16 + fVar5 * fVar12 + fVar1 * fVar20;
      fVar1 = *(float *)(param_1 + 0x148);
      fVar4 = *(float *)(param_1 + 0x154);
      fVar5 = *(float *)(param_1 + 0x150);
      fStack_a8 = fVar3 * fVar13 + fVar2 * fVar9 + fVar1 * fVar17;
      fStack_a4 = fVar3 * fVar14 + fVar2 * fVar10 + fVar1 * fVar18;
      fStack_a0 = fVar3 * fVar15 + fVar2 * fVar11 + fVar1 * fVar19;
      fStack_9c = fVar3 * fVar16 + fVar2 * fVar12 + fVar1 * fVar20;
      fVar1 = *(float *)(param_1 + 0x158);
      fStack_98 = fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17 + param_3[0xc];
      fStack_94 = fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18 + param_3[0xd];
      fStack_90 = fVar4 * fVar15 + fVar5 * fVar11 + fVar1 * fVar19 + param_3[0xe];
      fStack_8c = fVar4 * fVar16 + fVar5 * fVar12 + fVar1 * fVar20 + param_3[0xf];
      param_3 = &fStack_c8;
    }
    FUN_180085190(&uStack_108,param_2 + 0xc,*(uint8_t *)(param_1 + 0xf7),param_3);
    uVar6 = param_2[0x6f6];
    iVar33 = *(int *)(_DAT_180c86870 + 0x224);
    if (((*(byte *)(param_1 + 0xfd) & 1) == 0) &&
       ((*(int *)(param_1 + 0x1d0) == iVar33 || (*(int *)(param_1 + 0x1d0) == iVar33 + -1)))) {
      bVar31 = 0;
    }
    else {
      bVar31 = 1;
    }
    *(byte *)(param_1 + 0xfd) = *(byte *)(param_1 + 0xfd) & 0xfe | bVar31;
    bVar22 = (byte)uVar6 & 0x20;
    if ((bVar22 != 0) && (bVar31 != 0)) {
      *(void* *)(param_1 + 0x160) = uStack_108;
      *(void* *)(param_1 + 0x168) = uStack_100;
      *(void* *)(param_1 + 0x170) = uStack_f8;
      *(void* *)(param_1 + 0x178) = uStack_f0;
      *(void* *)(param_1 + 0x180) = uStack_e8;
      *(void* *)(param_1 + 0x188) = uStack_e0;
      *(void* *)(param_1 + 400) = uStack_d8;
      *(void* *)(param_1 + 0x198) = uStack_d0;
    }
    uVar25 = FUN_18024a290(param_2,param_1,&uStack_108,param_4,param_5);
    *(byte *)(param_1 + 0xfd) = *(byte *)(param_1 + 0xfd) & 0xfe;
    *(int *)(param_1 + 0x1d0) = iVar33;
    if (bVar22 != 0) {
      *(void* *)(param_1 + 0x160) = uStack_108;
      *(void* *)(param_1 + 0x168) = uStack_100;
      *(void* *)(param_1 + 0x170) = uStack_f8;
      *(void* *)(param_1 + 0x178) = uStack_f0;
      *(void* *)(param_1 + 0x180) = uStack_e8;
      *(void* *)(param_1 + 0x188) = uStack_e0;
      *(void* *)(param_1 + 400) = uStack_d8;
      *(void* *)(param_1 + 0x198) = uStack_d0;
    }
  }
  return uVar25;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007799c(void)
void FUN_18007799c(void)

{
  uint uVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  void* uVar21;
  void* uVar22;
  void* uVar23;
  void* uVar24;
  void* uVar25;
  void* uVar26;
  void* uVar27;
  void* uVar28;
  byte bVar29;
  byte bVar30;
  uint32_t uVar31;
  ulong long uVar32;
  long long lVar33;
  long long lVar34;
  uint32_t *puVar35;
  long long unaff_RBX;
  uint *puVar36;
  char *pcVar37;
  void* *puVar38;
  float *pfVar39;
  int unaff_R12D;
  int iVar40;
  ulong long uVar41;
  uint *puVar42;
  bool in_ZF;
  bool bVar43;
  uint32_t in_stack_00000030;
  ulong long in_stack_00000038;
  void* *in_stack_00000040;
  long long in_stack_00000050;
  void* in_stack_00000060;
  void* in_stack_00000068;
  void* in_stack_00000070;
  void* in_stack_00000078;
  void* in_stack_00000080;
  void* in_stack_00000088;
  void* in_stack_00000090;
  void* in_stack_00000098;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  uint32_t in_stack_000000f0;
  uint32_t in_stack_000000f8;
  uint32_t in_stack_00000100;
  uint32_t in_stack_00000108;
  uint32_t in_stack_00000110;
  uint32_t in_stack_00000118;
  uint32_t in_stack_00000170;
  long long in_stack_00000178;
  float *in_stack_00000180;
  void* in_stack_00000188;
  long long in_stack_00000190;
  
  if (!in_ZF) {
    FUN_18007ee70();
  }
  in_stack_00000050 = _DAT_180c86890 + 0x5868;
  puVar36 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0x6a78) * 0x908 + in_stack_00000050);
  LOCK();
  uVar1 = *puVar36;
  *puVar36 = *puVar36 + unaff_R12D;
  UNLOCK();
  uVar32 = (ulong long)(uVar1 >> 9);
  uVar41 = (ulong long)(uVar1 >> 9);
  pcVar37 = (char *)((long long)puVar36 + uVar41 + 0x808);
  puVar42 = puVar36 + (uVar32 + 1) * 2;
  in_stack_00000038 = uVar32;
  do {
    iVar40 = (int)uVar41;
    if (*(long long *)puVar42 == 0) {
      lVar33 = CreateSystemThreadObject(_DAT_180c8ed18,0xc000,0x25);
      LOCK();
      bVar43 = *(long long *)(puVar36 + (long long)iVar40 * 2 + 2) == 0;
      if (bVar43) {
        *(long long *)(puVar36 + (long long)iVar40 * 2 + 2) = lVar33;
      }
      UNLOCK();
      if (bVar43) {
        FUN_1800e94a0(puVar36,iVar40 << 9);
        LOCK();
        *(uint8_t *)((long long)puVar36 + (long long)iVar40 + 0x808) = 0;
        UNLOCK();
        uVar32 = in_stack_00000038;
      }
      else {
        if (lVar33 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        do {
          uVar32 = in_stack_00000038;
        } while (*pcVar37 != '\0');
      }
    }
    else {
      do {
      } while (*pcVar37 != '\0');
    }
    pcVar37 = pcVar37 + 1;
    uVar41 = (ulong long)(iVar40 + 1);
    puVar42 = puVar42 + 2;
  } while ((long long)(pcVar37 + (-0x808 - (long long)puVar36)) <= (long long)uVar32);
  puVar38 = (void* *)
            (*(long long *)
              ((long long)*(int *)(in_stack_00000050 + 0x1210) * 0x908 + in_stack_00000050 + 8 +
              uVar32 * 8) + (ulong long)(uVar1 - (uVar1 & 0xfffffe00)) * 0x60);
  lVar33 = unaff_RBX;
  in_stack_00000040 = puVar38;
  if ((*(byte *)(unaff_RBX + 0xfd) & 0x20) == 0) {
    lVar33 = func_0x000180085de0(*(void* *)(unaff_RBX + 0x1b0));
  }
  lVar34 = *(long long *)(unaff_RBX + 0x1b8);
  bVar29 = *(byte *)(lVar34 + 0x38c);
  if (bVar29 == 9) {
    bVar29 = func_0x00018022d300();
    *(byte *)(lVar34 + 0x38c) = bVar29;
  }
  lVar34 = in_stack_00000178;
  lVar33 = *(long long *)(lVar33 + 0x1e0);
  *puVar38 = *(void* *)(lVar33 + (ulong long)bVar29 * 0x18);
  puVar38[1] = *(void* *)(lVar33 + 8 + (ulong long)bVar29 * 0x18);
  *(uint32_t *)(in_stack_00000040 + 2) = *(uint32_t *)(*(long long *)(unaff_RBX + 600) + 0x2c);
  *(uint32_t *)((long long)in_stack_00000040 + 0x14) =
       *(uint32_t *)(*(long long *)(unaff_RBX + 600) + 0x4c);
  *(int *)(in_stack_00000040 + 9) = (int)*(char *)(*(long long *)(unaff_RBX + 600) + 0x44);
  if ((*(long long *)(unaff_RBX + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) == 0)) {
    uVar31 = 0xffffffff;
  }
  else {
    uVar31 = *(uint32_t *)(unaff_RBX + 0x108);
  }
  *(uint32_t *)(in_stack_00000040 + 3) = uVar31;
  if ((*(long long *)(unaff_RBX + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) == 0)) {
    uVar31 = 0xffffffff;
  }
  else {
    uVar31 = *(uint32_t *)(unaff_RBX + 0x10c);
  }
  *(uint32_t *)((long long)in_stack_00000040 + 0x1c) = uVar31;
  if ((*(long long *)(unaff_RBX + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) == 0)) {
    uVar31 = 0xffffffff;
  }
  else {
    uVar31 = *(uint32_t *)(unaff_RBX + 0x110);
  }
  *(uint32_t *)(in_stack_00000040 + 4) = uVar31;
  *(byte *)((long long)in_stack_00000040 + 0x4e) = *(byte *)(unaff_RBX + 0xfe) >> 3 & 1;
  if (*(int *)(unaff_RBX + 0x108) != -1) {
    puVar35 = *(uint32_t **)(unaff_RBX + 0x2d0);
    uVar31 = puVar35[1];
    uVar7 = puVar35[2];
    uVar8 = puVar35[3];
    *(uint32_t *)(in_stack_00000040 + 5) = *puVar35;
    *(uint32_t *)((long long)in_stack_00000040 + 0x2c) = uVar31;
    *(uint32_t *)(in_stack_00000040 + 6) = uVar7;
    *(uint32_t *)((long long)in_stack_00000040 + 0x34) = uVar8;
    uVar21 = *(void* *)(puVar35 + 6);
    in_stack_00000040[7] = *(void* *)(puVar35 + 4);
    in_stack_00000040[8] = uVar21;
  }
  *(uint8_t *)((long long)in_stack_00000040 + 0x4f) =
       *(uint8_t *)(*(long long *)(unaff_RBX + 600) + 0x24);
  lVar33 = *(long long *)(unaff_RBX + 600);
  if (*(char *)(lVar33 + 0x24) != '\0') {
    uVar31 = *(uint32_t *)(unaff_RBX + 0x2ac);
    uVar7 = *(uint32_t *)(unaff_RBX + 0x2b0);
    uVar8 = *(uint32_t *)(unaff_RBX + 0x2b4);
    *(uint32_t *)(in_stack_00000040 + 10) = *(uint32_t *)(unaff_RBX + 0x2a8);
    *(uint32_t *)((long long)in_stack_00000040 + 0x54) = uVar31;
    *(uint32_t *)(in_stack_00000040 + 0xb) = uVar7;
    *(uint32_t *)((long long)in_stack_00000040 + 0x5c) = uVar8;
    lVar33 = *(long long *)(unaff_RBX + 600);
  }
  *(bool *)((long long)in_stack_00000040 + 0x4c) = *(long long *)(lVar33 + 0x10) != 0;
  *(uint8_t *)((long long)in_stack_00000040 + 0x4d) = 1;
  if ((*(char *)(in_stack_00000190 + 0xc) != '\0') ||
     (0 < *(int *)(*(long long *)(unaff_RBX + 600) + 0x1c))) {
    *(uint8_t *)((long long)in_stack_00000040 + 0x4d) = 0;
  }
  if (*(long long *)(in_stack_00000178 + 0x28) == 0) {
    in_stack_00000030 = 0xffffffff;
    puVar35 = &stack0x00000030;
    lVar33 = in_stack_00000178;
  }
  else {
    in_stack_00000170 = 0xffffffff;
    puVar35 = &stack0x00000170;
    lVar33 = *(long long *)(in_stack_00000178 + 0x28);
  }
  FUN_180080e90(lVar33 + 0x3388,puVar35,&stack0x00000040);
  pfVar39 = in_stack_00000180;
  if ((*(uint *)(unaff_RBX + 0x100) & 0x4000000) != 0) {
    fVar9 = *in_stack_00000180;
    fVar10 = in_stack_00000180[1];
    fVar11 = in_stack_00000180[2];
    fVar12 = in_stack_00000180[3];
    fVar13 = in_stack_00000180[4];
    fVar14 = in_stack_00000180[5];
    fVar15 = in_stack_00000180[6];
    fVar16 = in_stack_00000180[7];
    fVar17 = in_stack_00000180[8];
    fVar18 = in_stack_00000180[9];
    fVar19 = in_stack_00000180[10];
    fVar20 = in_stack_00000180[0xb];
    fVar2 = *(float *)(unaff_RBX + 0x124);
    fVar3 = *(float *)(unaff_RBX + 0x120);
    fVar4 = *(float *)(unaff_RBX + 0x128);
    fVar5 = *(float *)(unaff_RBX + 0x134);
    fVar6 = *(float *)(unaff_RBX + 0x130);
    fStack00000000000000a0 = fVar2 * fVar13 + fVar3 * fVar9 + fVar4 * fVar17;
    fStack00000000000000a4 = fVar2 * fVar14 + fVar3 * fVar10 + fVar4 * fVar18;
    fStack00000000000000a8 = fVar2 * fVar15 + fVar3 * fVar11 + fVar4 * fVar19;
    fStack00000000000000ac = fVar2 * fVar16 + fVar3 * fVar12 + fVar4 * fVar20;
    fVar2 = *(float *)(unaff_RBX + 0x138);
    fVar3 = *(float *)(unaff_RBX + 0x140);
    fVar4 = *(float *)(unaff_RBX + 0x144);
    fStack00000000000000b0 = fVar5 * fVar13 + fVar6 * fVar9 + fVar2 * fVar17;
    fStack00000000000000b4 = fVar5 * fVar14 + fVar6 * fVar10 + fVar2 * fVar18;
    fStack00000000000000b8 = fVar5 * fVar15 + fVar6 * fVar11 + fVar2 * fVar19;
    fStack00000000000000bc = fVar5 * fVar16 + fVar6 * fVar12 + fVar2 * fVar20;
    fVar2 = *(float *)(unaff_RBX + 0x148);
    fVar5 = *(float *)(unaff_RBX + 0x154);
    fVar6 = *(float *)(unaff_RBX + 0x150);
    fStack00000000000000c0 = fVar4 * fVar13 + fVar3 * fVar9 + fVar2 * fVar17;
    fStack00000000000000c4 = fVar4 * fVar14 + fVar3 * fVar10 + fVar2 * fVar18;
    fStack00000000000000c8 = fVar4 * fVar15 + fVar3 * fVar11 + fVar2 * fVar19;
    fStack00000000000000cc = fVar4 * fVar16 + fVar3 * fVar12 + fVar2 * fVar20;
    fVar2 = *(float *)(unaff_RBX + 0x158);
    fStack00000000000000d0 =
         fVar5 * fVar13 + fVar6 * fVar9 + fVar2 * fVar17 + in_stack_00000180[0xc];
    fStack00000000000000d4 =
         fVar5 * fVar14 + fVar6 * fVar10 + fVar2 * fVar18 + in_stack_00000180[0xd];
    fStack00000000000000d8 =
         fVar5 * fVar15 + fVar6 * fVar11 + fVar2 * fVar19 + in_stack_00000180[0xe];
    fStack00000000000000dc =
         fVar5 * fVar16 + fVar6 * fVar12 + fVar2 * fVar20 + in_stack_00000180[0xf];
    pfVar39 = &stack0x000000a0;
  }
  FUN_180085190(&stack0x00000060,lVar34 + 0x30,*(uint8_t *)(unaff_RBX + 0xf7),pfVar39);
  uVar28 = in_stack_00000098;
  uVar27 = in_stack_00000090;
  uVar26 = in_stack_00000088;
  uVar25 = in_stack_00000080;
  uVar24 = in_stack_00000078;
  uVar23 = in_stack_00000070;
  uVar22 = in_stack_00000068;
  uVar21 = in_stack_00000060;
  bVar29 = *(byte *)(lVar34 + 0x1bd8);
  iVar40 = *(int *)(_DAT_180c86870 + 0x224);
  if (((*(byte *)(unaff_RBX + 0xfd) & 1) == 0) &&
     ((*(int *)(unaff_RBX + 0x1d0) == iVar40 || (*(int *)(unaff_RBX + 0x1d0) == iVar40 + -1)))) {
    bVar30 = 0;
  }
  else {
    bVar30 = 1;
  }
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe | bVar30;
  bVar29 = bVar29 & 0x20;
  if ((bVar29 != 0) && (bVar30 != 0)) {
    *(void* *)(unaff_RBX + 0x160) = in_stack_00000060;
    *(void* *)(unaff_RBX + 0x168) = in_stack_00000068;
    *(void* *)(unaff_RBX + 0x170) = in_stack_00000070;
    *(void* *)(unaff_RBX + 0x178) = in_stack_00000078;
    *(void* *)(unaff_RBX + 0x180) = in_stack_00000080;
    *(void* *)(unaff_RBX + 0x188) = in_stack_00000088;
    *(void* *)(unaff_RBX + 400) = in_stack_00000090;
    *(void* *)(unaff_RBX + 0x198) = in_stack_00000098;
  }
  FUN_18024a290(lVar34);
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe;
  *(int *)(unaff_RBX + 0x1d0) = iVar40;
  if (bVar29 != 0) {
    *(void* *)(unaff_RBX + 0x160) = uVar21;
    *(void* *)(unaff_RBX + 0x168) = uVar22;
    *(void* *)(unaff_RBX + 0x170) = uVar23;
    *(void* *)(unaff_RBX + 0x178) = uVar24;
    *(void* *)(unaff_RBX + 0x180) = uVar25;
    *(void* *)(unaff_RBX + 0x188) = uVar26;
    *(void* *)(unaff_RBX + 400) = uVar27;
    *(void* *)(unaff_RBX + 0x198) = uVar28;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180077ad8(void)
void FUN_180077ad8(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  int iVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  void* uVar21;
  void* uVar22;
  void* uVar23;
  void* uVar24;
  void* uVar25;
  void* uVar26;
  void* uVar27;
  void* uVar28;
  long long lVar29;
  byte bVar30;
  byte bVar31;
  uint32_t uVar32;
  long long lVar33;
  uint32_t *puVar34;
  long long unaff_RBX;
  void* *unaff_RDI;
  long long lVar35;
  float *pfVar36;
  uint32_t in_stack_00000030;
  long long in_stack_00000040;
  void* in_stack_00000060;
  void* in_stack_00000068;
  void* in_stack_00000070;
  void* in_stack_00000078;
  void* in_stack_00000080;
  void* in_stack_00000088;
  void* in_stack_00000090;
  void* in_stack_00000098;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  uint32_t in_stack_000000f0;
  uint32_t in_stack_000000f8;
  uint32_t in_stack_00000100;
  uint32_t in_stack_00000108;
  uint32_t in_stack_00000110;
  uint32_t in_stack_00000118;
  uint32_t in_stack_00000170;
  long long in_stack_00000178;
  float *in_stack_00000180;
  void* in_stack_00000188;
  long long in_stack_00000190;
  
  lVar33 = *(long long *)(unaff_RBX + 0x1b8);
  bVar30 = *(byte *)(lVar33 + 0x38c);
  lVar35 = unaff_RBX;
  if (bVar30 == 9) {
    bVar30 = func_0x00018022d300();
    *(byte *)(lVar33 + 0x38c) = bVar30;
  }
  lVar29 = in_stack_00000178;
  lVar33 = *(long long *)(lVar35 + 0x1e0);
  *unaff_RDI = *(void* *)(lVar33 + (ulong long)bVar30 * 0x18);
  unaff_RDI[1] = *(void* *)(lVar33 + 8 + (ulong long)bVar30 * 0x18);
  *(uint32_t *)(in_stack_00000040 + 0x10) = *(uint32_t *)(*(long long *)(unaff_RBX + 600) + 0x2c)
  ;
  *(uint32_t *)(in_stack_00000040 + 0x14) = *(uint32_t *)(*(long long *)(unaff_RBX + 600) + 0x4c)
  ;
  *(int *)(in_stack_00000040 + 0x48) = (int)*(char *)(*(long long *)(unaff_RBX + 600) + 0x44);
  if ((*(long long *)(unaff_RBX + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) == 0)) {
    uVar32 = 0xffffffff;
  }
  else {
    uVar32 = *(uint32_t *)(unaff_RBX + 0x108);
  }
  *(uint32_t *)(in_stack_00000040 + 0x18) = uVar32;
  if ((*(long long *)(unaff_RBX + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) == 0)) {
    uVar32 = 0xffffffff;
  }
  else {
    uVar32 = *(uint32_t *)(unaff_RBX + 0x10c);
  }
  *(uint32_t *)(in_stack_00000040 + 0x1c) = uVar32;
  if ((*(long long *)(unaff_RBX + 0x2d0) == 0) ||
     (*(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) == 0)) {
    uVar32 = 0xffffffff;
  }
  else {
    uVar32 = *(uint32_t *)(unaff_RBX + 0x110);
  }
  *(uint32_t *)(in_stack_00000040 + 0x20) = uVar32;
  *(byte *)(in_stack_00000040 + 0x4e) = *(byte *)(unaff_RBX + 0xfe) >> 3 & 1;
  if (*(int *)(unaff_RBX + 0x108) != -1) {
    puVar34 = *(uint32_t **)(unaff_RBX + 0x2d0);
    uVar32 = puVar34[1];
    uVar7 = puVar34[2];
    uVar8 = puVar34[3];
    *(uint32_t *)(in_stack_00000040 + 0x28) = *puVar34;
    *(uint32_t *)(in_stack_00000040 + 0x2c) = uVar32;
    *(uint32_t *)(in_stack_00000040 + 0x30) = uVar7;
    *(uint32_t *)(in_stack_00000040 + 0x34) = uVar8;
    uVar21 = *(void* *)(puVar34 + 6);
    *(void* *)(in_stack_00000040 + 0x38) = *(void* *)(puVar34 + 4);
    *(void* *)(in_stack_00000040 + 0x40) = uVar21;
  }
  *(uint8_t *)(in_stack_00000040 + 0x4f) = *(uint8_t *)(*(long long *)(unaff_RBX + 600) + 0x24)
  ;
  lVar33 = *(long long *)(unaff_RBX + 600);
  if (*(char *)(lVar33 + 0x24) != '\0') {
    uVar32 = *(uint32_t *)(unaff_RBX + 0x2ac);
    uVar7 = *(uint32_t *)(unaff_RBX + 0x2b0);
    uVar8 = *(uint32_t *)(unaff_RBX + 0x2b4);
    *(uint32_t *)(in_stack_00000040 + 0x50) = *(uint32_t *)(unaff_RBX + 0x2a8);
    *(uint32_t *)(in_stack_00000040 + 0x54) = uVar32;
    *(uint32_t *)(in_stack_00000040 + 0x58) = uVar7;
    *(uint32_t *)(in_stack_00000040 + 0x5c) = uVar8;
    lVar33 = *(long long *)(unaff_RBX + 600);
  }
  *(bool *)(in_stack_00000040 + 0x4c) = *(long long *)(lVar33 + 0x10) != 0;
  *(uint8_t *)(in_stack_00000040 + 0x4d) = 1;
  if ((*(char *)(in_stack_00000190 + 0xc) != '\0') ||
     (0 < *(int *)(*(long long *)(unaff_RBX + 600) + 0x1c))) {
    *(uint8_t *)(in_stack_00000040 + 0x4d) = 0;
  }
  if (*(long long *)(in_stack_00000178 + 0x28) == 0) {
    in_stack_00000030 = 0xffffffff;
    puVar34 = &stack0x00000030;
    lVar33 = in_stack_00000178;
  }
  else {
    in_stack_00000170 = 0xffffffff;
    puVar34 = &stack0x00000170;
    lVar33 = *(long long *)(in_stack_00000178 + 0x28);
  }
  FUN_180080e90(lVar33 + 0x3388,puVar34,&stack0x00000040);
  pfVar36 = in_stack_00000180;
  if ((*(uint *)(unaff_RBX + 0x100) & 0x4000000) != 0) {
    fVar9 = *in_stack_00000180;
    fVar10 = in_stack_00000180[1];
    fVar11 = in_stack_00000180[2];
    fVar12 = in_stack_00000180[3];
    fVar13 = in_stack_00000180[4];
    fVar14 = in_stack_00000180[5];
    fVar15 = in_stack_00000180[6];
    fVar16 = in_stack_00000180[7];
    fVar17 = in_stack_00000180[8];
    fVar18 = in_stack_00000180[9];
    fVar19 = in_stack_00000180[10];
    fVar20 = in_stack_00000180[0xb];
    fVar1 = *(float *)(unaff_RBX + 0x124);
    fVar2 = *(float *)(unaff_RBX + 0x120);
    fVar3 = *(float *)(unaff_RBX + 0x128);
    fVar4 = *(float *)(unaff_RBX + 0x134);
    fVar5 = *(float *)(unaff_RBX + 0x130);
    fStack00000000000000a0 = fVar1 * fVar13 + fVar2 * fVar9 + fVar3 * fVar17;
    fStack00000000000000a4 = fVar1 * fVar14 + fVar2 * fVar10 + fVar3 * fVar18;
    fStack00000000000000a8 = fVar1 * fVar15 + fVar2 * fVar11 + fVar3 * fVar19;
    fStack00000000000000ac = fVar1 * fVar16 + fVar2 * fVar12 + fVar3 * fVar20;
    fVar1 = *(float *)(unaff_RBX + 0x138);
    fVar2 = *(float *)(unaff_RBX + 0x140);
    fVar3 = *(float *)(unaff_RBX + 0x144);
    fStack00000000000000b0 = fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17;
    fStack00000000000000b4 = fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18;
    fStack00000000000000b8 = fVar4 * fVar15 + fVar5 * fVar11 + fVar1 * fVar19;
    fStack00000000000000bc = fVar4 * fVar16 + fVar5 * fVar12 + fVar1 * fVar20;
    fVar1 = *(float *)(unaff_RBX + 0x148);
    fVar4 = *(float *)(unaff_RBX + 0x154);
    fVar5 = *(float *)(unaff_RBX + 0x150);
    fStack00000000000000c0 = fVar3 * fVar13 + fVar2 * fVar9 + fVar1 * fVar17;
    fStack00000000000000c4 = fVar3 * fVar14 + fVar2 * fVar10 + fVar1 * fVar18;
    fStack00000000000000c8 = fVar3 * fVar15 + fVar2 * fVar11 + fVar1 * fVar19;
    fStack00000000000000cc = fVar3 * fVar16 + fVar2 * fVar12 + fVar1 * fVar20;
    fVar1 = *(float *)(unaff_RBX + 0x158);
    fStack00000000000000d0 =
         fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17 + in_stack_00000180[0xc];
    fStack00000000000000d4 =
         fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18 + in_stack_00000180[0xd];
    fStack00000000000000d8 =
         fVar4 * fVar15 + fVar5 * fVar11 + fVar1 * fVar19 + in_stack_00000180[0xe];
    fStack00000000000000dc =
         fVar4 * fVar16 + fVar5 * fVar12 + fVar1 * fVar20 + in_stack_00000180[0xf];
    pfVar36 = &stack0x000000a0;
  }
  FUN_180085190(&stack0x00000060,lVar29 + 0x30,*(uint8_t *)(unaff_RBX + 0xf7),pfVar36);
  uVar28 = in_stack_00000098;
  uVar27 = in_stack_00000090;
  uVar26 = in_stack_00000088;
  uVar25 = in_stack_00000080;
  uVar24 = in_stack_00000078;
  uVar23 = in_stack_00000070;
  uVar22 = in_stack_00000068;
  uVar21 = in_stack_00000060;
  bVar30 = *(byte *)(lVar29 + 0x1bd8);
  iVar6 = *(int *)(_DAT_180c86870 + 0x224);
  if (((*(byte *)(unaff_RBX + 0xfd) & 1) == 0) &&
     ((*(int *)(unaff_RBX + 0x1d0) == iVar6 || (*(int *)(unaff_RBX + 0x1d0) == iVar6 + -1)))) {
    bVar31 = 0;
  }
  else {
    bVar31 = 1;
  }
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe | bVar31;
  bVar30 = bVar30 & 0x20;
  if ((bVar30 != 0) && (bVar31 != 0)) {
    *(void* *)(unaff_RBX + 0x160) = in_stack_00000060;
    *(void* *)(unaff_RBX + 0x168) = in_stack_00000068;
    *(void* *)(unaff_RBX + 0x170) = in_stack_00000070;
    *(void* *)(unaff_RBX + 0x178) = in_stack_00000078;
    *(void* *)(unaff_RBX + 0x180) = in_stack_00000080;
    *(void* *)(unaff_RBX + 0x188) = in_stack_00000088;
    *(void* *)(unaff_RBX + 400) = in_stack_00000090;
    *(void* *)(unaff_RBX + 0x198) = in_stack_00000098;
  }
  FUN_18024a290(lVar29);
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe;
  *(int *)(unaff_RBX + 0x1d0) = iVar6;
  if (bVar30 != 0) {
    *(void* *)(unaff_RBX + 0x160) = uVar21;
    *(void* *)(unaff_RBX + 0x168) = uVar22;
    *(void* *)(unaff_RBX + 0x170) = uVar23;
    *(void* *)(unaff_RBX + 0x178) = uVar24;
    *(void* *)(unaff_RBX + 0x180) = uVar25;
    *(void* *)(unaff_RBX + 0x188) = uVar26;
    *(void* *)(unaff_RBX + 400) = uVar27;
    *(void* *)(unaff_RBX + 0x198) = uVar28;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180077c96(void)
void FUN_180077c96(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  int iVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  void* uVar19;
  void* uVar20;
  void* uVar21;
  void* uVar22;
  void* uVar23;
  void* uVar24;
  void* uVar25;
  void* uVar26;
  byte bVar27;
  long long unaff_RBX;
  byte bVar28;
  float *unaff_RSI;
  long long unaff_R13;
  bool in_ZF;
  void* in_stack_00000060;
  void* in_stack_00000068;
  void* in_stack_00000070;
  void* in_stack_00000078;
  void* in_stack_00000080;
  void* in_stack_00000088;
  void* in_stack_00000090;
  void* in_stack_00000098;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  
  if (!in_ZF) {
    fVar7 = *unaff_RSI;
    fVar8 = unaff_RSI[1];
    fVar9 = unaff_RSI[2];
    fVar10 = unaff_RSI[3];
    fVar11 = unaff_RSI[4];
    fVar12 = unaff_RSI[5];
    fVar13 = unaff_RSI[6];
    fVar14 = unaff_RSI[7];
    fVar15 = unaff_RSI[8];
    fVar16 = unaff_RSI[9];
    fVar17 = unaff_RSI[10];
    fVar18 = unaff_RSI[0xb];
    fVar1 = *(float *)(unaff_RBX + 0x124);
    fVar2 = *(float *)(unaff_RBX + 0x120);
    fVar3 = *(float *)(unaff_RBX + 0x128);
    fVar4 = *(float *)(unaff_RBX + 0x134);
    fVar5 = *(float *)(unaff_RBX + 0x130);
    fStack00000000000000a0 = fVar1 * fVar11 + fVar2 * fVar7 + fVar3 * fVar15;
    fStack00000000000000a4 = fVar1 * fVar12 + fVar2 * fVar8 + fVar3 * fVar16;
    fStack00000000000000a8 = fVar1 * fVar13 + fVar2 * fVar9 + fVar3 * fVar17;
    fStack00000000000000ac = fVar1 * fVar14 + fVar2 * fVar10 + fVar3 * fVar18;
    fVar1 = *(float *)(unaff_RBX + 0x138);
    fVar2 = *(float *)(unaff_RBX + 0x140);
    fVar3 = *(float *)(unaff_RBX + 0x144);
    fStack00000000000000b0 = fVar4 * fVar11 + fVar5 * fVar7 + fVar1 * fVar15;
    fStack00000000000000b4 = fVar4 * fVar12 + fVar5 * fVar8 + fVar1 * fVar16;
    fStack00000000000000b8 = fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17;
    fStack00000000000000bc = fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18;
    fVar1 = *(float *)(unaff_RBX + 0x148);
    fVar4 = *(float *)(unaff_RBX + 0x154);
    fVar5 = *(float *)(unaff_RBX + 0x150);
    fStack00000000000000c0 = fVar3 * fVar11 + fVar2 * fVar7 + fVar1 * fVar15;
    fStack00000000000000c4 = fVar3 * fVar12 + fVar2 * fVar8 + fVar1 * fVar16;
    fStack00000000000000c8 = fVar3 * fVar13 + fVar2 * fVar9 + fVar1 * fVar17;
    fStack00000000000000cc = fVar3 * fVar14 + fVar2 * fVar10 + fVar1 * fVar18;
    fVar1 = *(float *)(unaff_RBX + 0x158);
    fStack00000000000000d0 = fVar4 * fVar11 + fVar5 * fVar7 + fVar1 * fVar15 + unaff_RSI[0xc];
    fStack00000000000000d4 = fVar4 * fVar12 + fVar5 * fVar8 + fVar1 * fVar16 + unaff_RSI[0xd];
    fStack00000000000000d8 = fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17 + unaff_RSI[0xe];
    fStack00000000000000dc = fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18 + unaff_RSI[0xf];
  }
  FUN_180085190(&stack0x00000060,unaff_R13 + 0x30,*(uint8_t *)(unaff_RBX + 0xf7));
  uVar26 = in_stack_00000098;
  uVar25 = in_stack_00000090;
  uVar24 = in_stack_00000088;
  uVar23 = in_stack_00000080;
  uVar22 = in_stack_00000078;
  uVar21 = in_stack_00000070;
  uVar20 = in_stack_00000068;
  uVar19 = in_stack_00000060;
  bVar28 = *(byte *)(unaff_R13 + 0x1bd8);
  iVar6 = *(int *)(_DAT_180c86870 + 0x224);
  if (((*(byte *)(unaff_RBX + 0xfd) & 1) == 0) &&
     ((*(int *)(unaff_RBX + 0x1d0) == iVar6 || (*(int *)(unaff_RBX + 0x1d0) == iVar6 + -1)))) {
    bVar27 = 0;
  }
  else {
    bVar27 = 1;
  }
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe | bVar27;
  bVar28 = bVar28 & 0x20;
  if ((bVar28 != 0) && (bVar27 != 0)) {
    *(void* *)(unaff_RBX + 0x160) = in_stack_00000060;
    *(void* *)(unaff_RBX + 0x168) = in_stack_00000068;
    *(void* *)(unaff_RBX + 0x170) = in_stack_00000070;
    *(void* *)(unaff_RBX + 0x178) = in_stack_00000078;
    *(void* *)(unaff_RBX + 0x180) = in_stack_00000080;
    *(void* *)(unaff_RBX + 0x188) = in_stack_00000088;
    *(void* *)(unaff_RBX + 400) = in_stack_00000090;
    *(void* *)(unaff_RBX + 0x198) = in_stack_00000098;
  }
  FUN_18024a290();
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe;
  *(int *)(unaff_RBX + 0x1d0) = iVar6;
  if (bVar28 != 0) {
    *(void* *)(unaff_RBX + 0x160) = uVar19;
    *(void* *)(unaff_RBX + 0x168) = uVar20;
    *(void* *)(unaff_RBX + 0x170) = uVar21;
    *(void* *)(unaff_RBX + 0x178) = uVar22;
    *(void* *)(unaff_RBX + 0x180) = uVar23;
    *(void* *)(unaff_RBX + 0x188) = uVar24;
    *(void* *)(unaff_RBX + 400) = uVar25;
    *(void* *)(unaff_RBX + 0x198) = uVar26;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180077dc6(void)
void FUN_180077dc6(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  int iVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  void* uVar19;
  void* uVar20;
  void* uVar21;
  void* uVar22;
  void* uVar23;
  void* uVar24;
  void* uVar25;
  void* uVar26;
  byte bVar27;
  long long unaff_RBX;
  byte bVar28;
  float *pfVar29;
  long long unaff_R13;
  uint32_t uStack0000000000000030;
  void* in_stack_00000060;
  void* in_stack_00000068;
  void* in_stack_00000070;
  void* in_stack_00000078;
  void* in_stack_00000080;
  void* in_stack_00000088;
  void* in_stack_00000090;
  void* in_stack_00000098;
  float fStack00000000000000a0;
  float fStack00000000000000a4;
  float fStack00000000000000a8;
  float fStack00000000000000ac;
  float fStack00000000000000b0;
  float fStack00000000000000b4;
  float fStack00000000000000b8;
  float fStack00000000000000bc;
  float fStack00000000000000c0;
  float fStack00000000000000c4;
  float fStack00000000000000c8;
  float fStack00000000000000cc;
  float fStack00000000000000d0;
  float fStack00000000000000d4;
  float fStack00000000000000d8;
  float fStack00000000000000dc;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  uint32_t in_stack_000000f0;
  uint32_t in_stack_000000f8;
  uint32_t in_stack_00000100;
  uint32_t in_stack_00000108;
  uint32_t in_stack_00000110;
  uint32_t in_stack_00000118;
  float *in_stack_00000180;
  void* in_stack_00000188;
  
  uStack0000000000000030 = 0xffffffff;
  FUN_180080e90(unaff_R13 + 0x3388,&stack0x00000030);
  pfVar29 = in_stack_00000180;
  if ((*(uint *)(unaff_RBX + 0x100) & 0x4000000) != 0) {
    fVar7 = *in_stack_00000180;
    fVar8 = in_stack_00000180[1];
    fVar9 = in_stack_00000180[2];
    fVar10 = in_stack_00000180[3];
    fVar11 = in_stack_00000180[4];
    fVar12 = in_stack_00000180[5];
    fVar13 = in_stack_00000180[6];
    fVar14 = in_stack_00000180[7];
    fVar15 = in_stack_00000180[8];
    fVar16 = in_stack_00000180[9];
    fVar17 = in_stack_00000180[10];
    fVar18 = in_stack_00000180[0xb];
    fVar1 = *(float *)(unaff_RBX + 0x124);
    fVar2 = *(float *)(unaff_RBX + 0x120);
    fVar3 = *(float *)(unaff_RBX + 0x128);
    fVar4 = *(float *)(unaff_RBX + 0x134);
    fVar5 = *(float *)(unaff_RBX + 0x130);
    fStack00000000000000a0 = fVar1 * fVar11 + fVar2 * fVar7 + fVar3 * fVar15;
    fStack00000000000000a4 = fVar1 * fVar12 + fVar2 * fVar8 + fVar3 * fVar16;
    fStack00000000000000a8 = fVar1 * fVar13 + fVar2 * fVar9 + fVar3 * fVar17;
    fStack00000000000000ac = fVar1 * fVar14 + fVar2 * fVar10 + fVar3 * fVar18;
    fVar1 = *(float *)(unaff_RBX + 0x138);
    fVar2 = *(float *)(unaff_RBX + 0x140);
    fVar3 = *(float *)(unaff_RBX + 0x144);
    fStack00000000000000b0 = fVar4 * fVar11 + fVar5 * fVar7 + fVar1 * fVar15;
    fStack00000000000000b4 = fVar4 * fVar12 + fVar5 * fVar8 + fVar1 * fVar16;
    fStack00000000000000b8 = fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17;
    fStack00000000000000bc = fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18;
    fVar1 = *(float *)(unaff_RBX + 0x148);
    fVar4 = *(float *)(unaff_RBX + 0x154);
    fVar5 = *(float *)(unaff_RBX + 0x150);
    fStack00000000000000c0 = fVar3 * fVar11 + fVar2 * fVar7 + fVar1 * fVar15;
    fStack00000000000000c4 = fVar3 * fVar12 + fVar2 * fVar8 + fVar1 * fVar16;
    fStack00000000000000c8 = fVar3 * fVar13 + fVar2 * fVar9 + fVar1 * fVar17;
    fStack00000000000000cc = fVar3 * fVar14 + fVar2 * fVar10 + fVar1 * fVar18;
    fVar1 = *(float *)(unaff_RBX + 0x158);
    fStack00000000000000d0 =
         fVar4 * fVar11 + fVar5 * fVar7 + fVar1 * fVar15 + in_stack_00000180[0xc];
    fStack00000000000000d4 =
         fVar4 * fVar12 + fVar5 * fVar8 + fVar1 * fVar16 + in_stack_00000180[0xd];
    fStack00000000000000d8 =
         fVar4 * fVar13 + fVar5 * fVar9 + fVar1 * fVar17 + in_stack_00000180[0xe];
    fStack00000000000000dc =
         fVar4 * fVar14 + fVar5 * fVar10 + fVar1 * fVar18 + in_stack_00000180[0xf];
    pfVar29 = &stack0x000000a0;
  }
  FUN_180085190(&stack0x00000060,unaff_R13 + 0x30,*(uint8_t *)(unaff_RBX + 0xf7),pfVar29);
  uVar26 = in_stack_00000098;
  uVar25 = in_stack_00000090;
  uVar24 = in_stack_00000088;
  uVar23 = in_stack_00000080;
  uVar22 = in_stack_00000078;
  uVar21 = in_stack_00000070;
  uVar20 = in_stack_00000068;
  uVar19 = in_stack_00000060;
  bVar28 = *(byte *)(unaff_R13 + 0x1bd8);
  iVar6 = *(int *)(_DAT_180c86870 + 0x224);
  if (((*(byte *)(unaff_RBX + 0xfd) & 1) == 0) &&
     ((*(int *)(unaff_RBX + 0x1d0) == iVar6 || (*(int *)(unaff_RBX + 0x1d0) == iVar6 + -1)))) {
    bVar27 = 0;
  }
  else {
    bVar27 = 1;
  }
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe | bVar27;
  bVar28 = bVar28 & 0x20;
  if ((bVar28 != 0) && (bVar27 != 0)) {
    *(void* *)(unaff_RBX + 0x160) = in_stack_00000060;
    *(void* *)(unaff_RBX + 0x168) = in_stack_00000068;
    *(void* *)(unaff_RBX + 0x170) = in_stack_00000070;
    *(void* *)(unaff_RBX + 0x178) = in_stack_00000078;
    *(void* *)(unaff_RBX + 0x180) = in_stack_00000080;
    *(void* *)(unaff_RBX + 0x188) = in_stack_00000088;
    *(void* *)(unaff_RBX + 400) = in_stack_00000090;
    *(void* *)(unaff_RBX + 0x198) = in_stack_00000098;
  }
  FUN_18024a290();
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe;
  *(int *)(unaff_RBX + 0x1d0) = iVar6;
  if (bVar28 != 0) {
    *(void* *)(unaff_RBX + 0x160) = uVar19;
    *(void* *)(unaff_RBX + 0x168) = uVar20;
    *(void* *)(unaff_RBX + 0x170) = uVar21;
    *(void* *)(unaff_RBX + 0x178) = uVar22;
    *(void* *)(unaff_RBX + 0x180) = uVar23;
    *(void* *)(unaff_RBX + 0x188) = uVar24;
    *(void* *)(unaff_RBX + 400) = uVar25;
    *(void* *)(unaff_RBX + 0x198) = uVar26;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180077dec(void)
void FUN_180077dec(void)

{
  int iVar1;
  void* uVar2;
  void* uVar3;
  void* uVar4;
  void* uVar5;
  void* uVar6;
  void* uVar7;
  void* uVar8;
  void* uVar9;
  byte bVar10;
  long long unaff_RBX;
  byte bVar11;
  long long unaff_R13;
  void* in_stack_00000060;
  void* in_stack_00000068;
  void* in_stack_00000070;
  void* in_stack_00000078;
  void* in_stack_00000080;
  void* in_stack_00000088;
  void* in_stack_00000090;
  void* in_stack_00000098;
  
  FUN_180085190(&stack0x00000060,unaff_R13 + 0x30,*(uint8_t *)(unaff_RBX + 0xf7));
  uVar9 = in_stack_00000098;
  uVar8 = in_stack_00000090;
  uVar7 = in_stack_00000088;
  uVar6 = in_stack_00000080;
  uVar5 = in_stack_00000078;
  uVar4 = in_stack_00000070;
  uVar3 = in_stack_00000068;
  uVar2 = in_stack_00000060;
  bVar11 = *(byte *)(unaff_R13 + 0x1bd8);
  iVar1 = *(int *)(_DAT_180c86870 + 0x224);
  if (((*(byte *)(unaff_RBX + 0xfd) & 1) == 0) &&
     ((*(int *)(unaff_RBX + 0x1d0) == iVar1 || (*(int *)(unaff_RBX + 0x1d0) == iVar1 + -1)))) {
    bVar10 = 0;
  }
  else {
    bVar10 = 1;
  }
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe | bVar10;
  bVar11 = bVar11 & 0x20;
  if ((bVar11 != 0) && (bVar10 != 0)) {
    *(void* *)(unaff_RBX + 0x160) = in_stack_00000060;
    *(void* *)(unaff_RBX + 0x168) = in_stack_00000068;
    *(void* *)(unaff_RBX + 0x170) = in_stack_00000070;
    *(void* *)(unaff_RBX + 0x178) = in_stack_00000078;
    *(void* *)(unaff_RBX + 0x180) = in_stack_00000080;
    *(void* *)(unaff_RBX + 0x188) = in_stack_00000088;
    *(void* *)(unaff_RBX + 400) = in_stack_00000090;
    *(void* *)(unaff_RBX + 0x198) = in_stack_00000098;
  }
  FUN_18024a290();
  *(byte *)(unaff_RBX + 0xfd) = *(byte *)(unaff_RBX + 0xfd) & 0xfe;
  *(int *)(unaff_RBX + 0x1d0) = iVar1;
  if (bVar11 != 0) {
    *(void* *)(unaff_RBX + 0x160) = uVar2;
    *(void* *)(unaff_RBX + 0x168) = uVar3;
    *(void* *)(unaff_RBX + 0x170) = uVar4;
    *(void* *)(unaff_RBX + 0x178) = uVar5;
    *(void* *)(unaff_RBX + 0x180) = uVar6;
    *(void* *)(unaff_RBX + 0x188) = uVar7;
    *(void* *)(unaff_RBX + 400) = uVar8;
    *(void* *)(unaff_RBX + 0x198) = uVar9;
  }
  return;
}



uint8_t FUN_180077ef9(void)

{
  return 0;
}



ulong long FUN_180077f20(long long param_1,void* param_2,uint32_t param_3,float *param_4,
                       uint32_t param_5,uint32_t param_6)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  char cVar19;
  ulong long in_RAX;
  long long lVar20;
  ulong long uVar21;
  long long lVar22;
  byte bVar23;
  void* uStack_88;
  ulong long uStack_80;
  void* uStack_78;
  ulong long uStack_70;
  void* uStack_68;
  ulong long uStack_60;
  float fStack_58;
  float fStack_54;
  float fStack_50;
  uint32_t uStack_4c;
  
  lVar22 = *(long long *)(param_1 + 0x1b8);
  if (lVar22 != 0) {
    bVar23 = *(byte *)(param_1 + 0xfd) & 0x20;
    lVar20 = param_1;
    if (bVar23 == 0) {
      lVar20 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
    }
    if (*(int *)(lVar20 + 0x200) != 0) {
      lVar20 = param_1;
      if (bVar23 == 0) {
        lVar20 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
      }
      if (*(int *)(lVar20 + 0x1fc) * 3 != 0) goto LAB_180077fcf;
    }
    if ((*(byte *)(param_1 + 0x100) & 4) != 0) {
LAB_180077fcf:
      lVar22 = *(long long *)(param_1 + 0x1b8);
      cVar19 = *(char *)(lVar22 + 0x38c);
      if (cVar19 == '\t') {
        cVar19 = func_0x00018022d300();
        *(char *)(lVar22 + 0x38c) = cVar19;
      }
      cVar19 = FUN_18007b240(param_1,param_1 + 0x1e8,cVar19,1);
      if (cVar19 == '\0') {
        *(byte *)(param_1 + 0xfe) = *(byte *)(param_1 + 0xfe) & 0xfb;
      }
      if ((*(uint *)(param_1 + 0x100) & 0x4000000) == 0) {
        uStack_88 = *(void* *)param_4;
        uStack_80._0_4_ = (float)*(void* *)(param_4 + 2);
        uStack_78 = *(void* *)(param_4 + 4);
        uStack_70._0_4_ = (float)*(void* *)(param_4 + 6);
        uStack_68 = *(void* *)(param_4 + 8);
        uStack_60._0_4_ = (float)*(void* *)(param_4 + 10);
        fStack_58 = param_4[0xc];
        fStack_54 = param_4[0xd];
        fStack_50 = param_4[0xe];
      }
      else {
        fVar10 = param_4[4];
        fVar11 = param_4[5];
        fVar12 = param_4[6];
        fVar1 = *(float *)(param_1 + 0x120);
        fVar2 = *(float *)(param_1 + 0x128);
        fVar3 = *(float *)(param_1 + 0x134);
        fVar4 = *(float *)(param_1 + 0x144);
        fVar5 = *(float *)(param_1 + 0x154);
        fVar13 = *param_4;
        fVar14 = param_4[1];
        fVar15 = param_4[2];
        fVar16 = param_4[8];
        fVar17 = param_4[9];
        fVar18 = param_4[10];
        fVar6 = *(float *)(param_1 + 0x124);
        fVar7 = *(float *)(param_1 + 0x130);
        uStack_80._0_4_ = fVar6 * fVar12 + fVar1 * fVar15 + fVar2 * fVar18;
        fVar8 = *(float *)(param_1 + 0x138);
        fVar9 = *(float *)(param_1 + 0x140);
        uStack_70._0_4_ = fVar3 * fVar12 + fVar7 * fVar15 + fVar8 * fVar18;
        uStack_88 = CONCAT44(fVar6 * fVar11 + fVar1 * fVar14 + fVar2 * fVar17,
                             fVar6 * fVar10 + fVar1 * fVar13 + fVar2 * fVar16);
        fVar1 = *(float *)(param_1 + 0x148);
        fVar2 = *(float *)(param_1 + 0x150);
        uStack_60._0_4_ = fVar4 * fVar12 + fVar9 * fVar15 + fVar1 * fVar18;
        fVar6 = *(float *)(param_1 + 0x158);
        uStack_78 = CONCAT44(fVar3 * fVar11 + fVar7 * fVar14 + fVar8 * fVar17,
                             fVar3 * fVar10 + fVar7 * fVar13 + fVar8 * fVar16);
        uStack_68 = CONCAT44(fVar4 * fVar11 + fVar9 * fVar14 + fVar1 * fVar17,
                             fVar4 * fVar10 + fVar9 * fVar13 + fVar1 * fVar16);
        fStack_58 = fVar5 * fVar10 + fVar2 * fVar13 + fVar6 * fVar16 + param_4[0xc];
        fStack_54 = fVar5 * fVar11 + fVar2 * fVar14 + fVar6 * fVar17 + param_4[0xd];
        fStack_50 = fVar5 * fVar12 + fVar2 * fVar15 + fVar6 * fVar18 + param_4[0xe];
      }
      uStack_4c = 0x3f800000;
      uStack_60 = (ulong long)(uint)(float)uStack_60;
      uStack_70 = (ulong long)(uint)(float)uStack_70;
      uStack_80 = (ulong long)(uint)(float)uStack_80;
      uVar21 = FUN_180252ca0(param_2,param_1,param_3,&uStack_88,param_5,param_6);
      return uVar21;
    }
    in_RAX = 0;
    if (*(char *)(lVar22 + 0x38c) == '\t') {
      in_RAX = func_0x00018022d300(lVar22);
      *(char *)(lVar22 + 0x38c) = (char)in_RAX;
      if ((char)in_RAX == '\t') goto LAB_180077fcf;
    }
  }
  return in_RAX & 0xffffffffffffff00;
}




// 函数: void FUN_180078051(void* param_1,void* param_2,float param_3,float param_4)
void FUN_180078051(void* param_1,void* param_2,float param_3,float param_4)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  long long unaff_RBX;
  float *unaff_RDI;
  uint32_t unaff_R14D;
  float in_XMM0_Dc;
  float in_XMM1_Dc;
  float in_XMM4_Da;
  float in_XMM4_Db;
  float in_XMM4_Dc;
  float in_XMM5_Da;
  uint32_t uStack0000000000000028;
  float fStack0000000000000030;
  float fStack0000000000000034;
  float fStack0000000000000038;
  uint32_t uStack000000000000003c;
  float fStack0000000000000040;
  float fStack0000000000000044;
  float fStack0000000000000048;
  uint32_t uStack000000000000004c;
  float fStack0000000000000050;
  float fStack0000000000000054;
  float fStack0000000000000058;
  uint32_t uStack000000000000005c;
  float fStack0000000000000060;
  float fStack0000000000000064;
  float fStack0000000000000068;
  uint32_t uStack000000000000006c;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  
  fVar4 = *unaff_RDI;
  fVar5 = unaff_RDI[1];
  fVar6 = unaff_RDI[2];
  fVar7 = unaff_RDI[8];
  fVar8 = unaff_RDI[9];
  fVar9 = unaff_RDI[10];
  fVar1 = *(float *)(unaff_RBX + 0x124);
  fVar2 = *(float *)(unaff_RBX + 0x130);
  fStack0000000000000030 = fVar1 * in_XMM4_Da + (float)param_1 * fVar4 + (float)param_2 * fVar7;
  fStack0000000000000034 =
       fVar1 * in_XMM4_Db + (float)((ulong long)param_1 >> 0x20) * fVar5 +
       (float)((ulong long)param_2 >> 0x20) * fVar8;
  fStack0000000000000038 = fVar1 * in_XMM4_Dc + in_XMM0_Dc * fVar6 + in_XMM1_Dc * fVar9;
  fVar1 = *(float *)(unaff_RBX + 0x138);
  fVar3 = *(float *)(unaff_RBX + 0x140);
  fStack0000000000000040 = in_XMM5_Da * in_XMM4_Da + fVar2 * fVar4 + fVar1 * fVar7;
  fStack0000000000000044 = in_XMM5_Da * in_XMM4_Db + fVar2 * fVar5 + fVar1 * fVar8;
  fStack0000000000000048 = in_XMM5_Da * in_XMM4_Dc + fVar2 * fVar6 + fVar1 * fVar9;
  fVar1 = *(float *)(unaff_RBX + 0x148);
  fVar2 = *(float *)(unaff_RBX + 0x150);
  fStack0000000000000050 = param_4 * in_XMM4_Da + fVar3 * fVar4 + fVar1 * fVar7;
  fStack0000000000000054 = param_4 * in_XMM4_Db + fVar3 * fVar5 + fVar1 * fVar8;
  fStack0000000000000058 = param_4 * in_XMM4_Dc + fVar3 * fVar6 + fVar1 * fVar9;
  fVar1 = *(float *)(unaff_RBX + 0x158);
  fStack0000000000000060 = param_3 * in_XMM4_Da + fVar2 * fVar4 + fVar1 * fVar7 + unaff_RDI[0xc];
  fStack0000000000000064 = param_3 * in_XMM4_Db + fVar2 * fVar5 + fVar1 * fVar8 + unaff_RDI[0xd];
  fStack0000000000000068 = param_3 * in_XMM4_Dc + fVar2 * fVar6 + fVar1 * fVar9 + unaff_RDI[0xe];
  uStack0000000000000028 = in_stack_000000e8;
  uStack000000000000006c = 0x3f800000;
  uStack000000000000005c = 0;
  uStack000000000000004c = 0;
  uStack000000000000003c = 0;
  FUN_180252ca0(0x3f800000,fVar1 * fVar7,unaff_R14D,&stack0x00000030,in_stack_000000e0);
  return;
}




// 函数: void FUN_180078143(void)
void FUN_180078143(void)

{
  void* *unaff_RDI;
  uint32_t unaff_R14D;
  uint32_t uStack0000000000000028;
  void* uStack0000000000000030;
  ulong long uStack0000000000000038;
  void* uStack0000000000000040;
  ulong long uStack0000000000000048;
  void* uStack0000000000000050;
  ulong long uStack0000000000000058;
  uint32_t uStack0000000000000060;
  uint32_t uStack0000000000000064;
  uint32_t uStack0000000000000068;
  uint32_t uStack000000000000006c;
  uint32_t in_stack_000000e0;
  uint32_t in_stack_000000e8;
  
  uStack0000000000000030 = *unaff_RDI;
  uStack0000000000000040 = unaff_RDI[2];
  uStack0000000000000050 = unaff_RDI[4];
  uStack0000000000000060 = *(uint32_t *)(unaff_RDI + 6);
  uStack0000000000000064 = *(uint32_t *)((long long)unaff_RDI + 0x34);
  uStack0000000000000068 = *(uint32_t *)(unaff_RDI + 7);
  uStack0000000000000028 = in_stack_000000e8;
  uStack000000000000006c = 0x3f800000;
  uStack0000000000000058 = unaff_RDI[5] & 0xffffffff;
  uStack0000000000000048 = unaff_RDI[3] & 0xffffffff;
  uStack0000000000000038 = unaff_RDI[1] & 0xffffffff;
  FUN_180252ca0(0x3f800000,uStack0000000000000060,unaff_R14D,&stack0x00000030,in_stack_000000e0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800781e0(long long param_1)
void FUN_1800781e0(long long param_1)

{
  long long lVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  char cVar5;
  uint8_t uVar6;
  void** systemCurrentNode;
  long long lVar8;
  uint uVar9;
  bool bVar10;
  float fVar11;
  
  lVar8 = param_1;
  if ((*(long long *)(param_1 + 0x1c8) != 0) &&
     (lVar1 = *(long long *)(*(long long *)(param_1 + 0x1c8) + 0x28), lVar1 != 0)) {
    fVar11 = (*(float *)(lVar1 + 0x74) * *(float *)(lVar1 + 0x88) -
             *(float *)(lVar1 + 0x78) * *(float *)(lVar1 + 0x84)) * *(float *)(lVar1 + 0x90);
    func_0x0001800773c0(fVar11,(*(float *)(lVar1 + 0x78) * *(float *)(lVar1 + 0x80) -
                               *(float *)(lVar1 + 0x70) * *(float *)(lVar1 + 0x88)) *
                               *(float *)(lVar1 + 0x94) + fVar11 +
                               (*(float *)(lVar1 + 0x70) * *(float *)(lVar1 + 0x84) -
                               *(float *)(lVar1 + 0x74) * *(float *)(lVar1 + 0x80)) *
                               *(float *)(lVar1 + 0x98) < 0.0);
  }
  if (*(long long *)(lVar8 + 0x1b8) == 0) {
LAB_1800782d4:
    bVar10 = (*(byte *)(param_1 + 0xfd) & 2) != 0;
  }
  else {
    uVar9 = *(uint *)(*(long long *)(lVar8 + 0x1b8) + 0x138);
    if ((uVar9 & 0x20) != 0) {
      cVar5 = '\0';
      goto LAB_1800782e0;
    }
    if ((uVar9 & 0x10) == 0) goto LAB_1800782d4;
    bVar10 = (*(byte *)(param_1 + 0xfd) & 2) == 0;
  }
  cVar5 = bVar10 + '\x01';
LAB_1800782e0:
  *(char *)(param_1 + 0xff) = cVar5;
  lVar8 = *(long long *)(param_1 + 0x1b8);
  uVar9 = *(uint *)(lVar8 + 0x138) & 0x3000;
  uVar6 = 0;
  if (uVar9 == 0x1000) {
    *(uint8_t *)(param_1 + 0xf7) = 1;
  }
  else {
    if (uVar9 == 0x2000) {
      uVar6 = 2;
    }
    *(uint8_t *)(param_1 + 0xf7) = uVar6;
  }
  if ((((*(float *)(lVar8 + 0x288) != 0.0) || (*(float *)(lVar8 + 0x28c) != 0.0)) ||
      (*(float *)(lVar8 + 0x290) != 0.0)) || (*(float *)(lVar8 + 0x294) != 0.0)) {
    uVar2 = *(uint32_t *)(lVar8 + 0x28c);
    uVar3 = *(uint32_t *)(lVar8 + 0x290);
    uVar4 = *(uint32_t *)(lVar8 + 0x294);
    *(uint32_t *)(param_1 + 0x2a8) = *(uint32_t *)(lVar8 + 0x288);
    *(uint32_t *)(param_1 + 0x2ac) = uVar2;
    *(uint32_t *)(param_1 + 0x2b0) = uVar3;
    *(uint32_t *)(param_1 + 0x2b4) = uVar4;
  }
  if (((*(float *)(lVar8 + 0x298) != 0.0) || (*(float *)(lVar8 + 0x29c) != 0.0)) ||
     ((*(float *)(lVar8 + 0x2a0) != 0.0 || (*(float *)(lVar8 + 0x2a4) != 0.0)))) {
    uVar2 = *(uint32_t *)(lVar8 + 0x29c);
    uVar3 = *(uint32_t *)(lVar8 + 0x2a0);
    uVar4 = *(uint32_t *)(lVar8 + 0x2a4);
    *(uint32_t *)(param_1 + 0x2b8) = *(uint32_t *)(lVar8 + 0x298);
    *(uint32_t *)(param_1 + 700) = uVar2;
    *(uint32_t *)(param_1 + 0x2c0) = uVar3;
    *(uint32_t *)(param_1 + 0x2c4) = uVar4;
  }
  *(undefined2 *)(lVar8 + 0x3c0) = 0xffff;
  FUN_180077150(param_1);
  if ((*(long long *)(param_1 + 600) == 0) &&
     ((*(uint *)(*(long long *)(param_1 + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,9);
    *(void* *)((long long)systemPreviousNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(systemPreviousNode + 9) = 0xffffffff;
    *systemPreviousNode = 0;
    systemPreviousNode[2] = 0;
    systemPreviousNode[7] = 0;
    *(uint32_t *)(systemPreviousNode + 5) = 0xffffffff;
    *(uint32_t *)(systemPreviousNode + 4) = 0xffffffff;
    systemPreviousNode[3] = 0;
    *(uint32_t *)(systemPreviousNode + 8) = 0;
    *(uint32_t *)(systemPreviousNode + 1) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x44) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x24) = 0;
    *(void* **)(param_1 + 600) = systemPreviousNode;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800781f4(long long param_1)
void FUN_1800781f4(long long param_1)

{
  long long lVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  char cVar5;
  uint8_t uVar6;
  long long in_RAX;
  void** systemCurrentNode;
  uint uVar8;
  long long unaff_RBX;
  bool bVar9;
  float fVar10;
  
  if ((in_RAX != 0) && (lVar1 = *(long long *)(in_RAX + 0x28), lVar1 != 0)) {
    fVar10 = (*(float *)(lVar1 + 0x74) * *(float *)(lVar1 + 0x88) -
             *(float *)(lVar1 + 0x78) * *(float *)(lVar1 + 0x84)) * *(float *)(lVar1 + 0x90);
    func_0x0001800773c0(fVar10,(*(float *)(lVar1 + 0x78) * *(float *)(lVar1 + 0x80) -
                               *(float *)(lVar1 + 0x70) * *(float *)(lVar1 + 0x88)) *
                               *(float *)(lVar1 + 0x94) + fVar10 +
                               (*(float *)(lVar1 + 0x70) * *(float *)(lVar1 + 0x84) -
                               *(float *)(lVar1 + 0x74) * *(float *)(lVar1 + 0x80)) *
                               *(float *)(lVar1 + 0x98) < 0.0);
  }
  if (*(long long *)(param_1 + 0x1b8) == 0) {
LAB_1800782d4:
    bVar9 = (*(byte *)(unaff_RBX + 0xfd) & 2) != 0;
  }
  else {
    uVar8 = *(uint *)(*(long long *)(param_1 + 0x1b8) + 0x138);
    if ((uVar8 & 0x20) != 0) {
      cVar5 = '\0';
      goto LAB_1800782e0;
    }
    if ((uVar8 & 0x10) == 0) goto LAB_1800782d4;
    bVar9 = (*(byte *)(unaff_RBX + 0xfd) & 2) == 0;
  }
  cVar5 = bVar9 + '\x01';
LAB_1800782e0:
  *(char *)(unaff_RBX + 0xff) = cVar5;
  lVar1 = *(long long *)(unaff_RBX + 0x1b8);
  uVar8 = *(uint *)(lVar1 + 0x138) & 0x3000;
  uVar6 = 0;
  if (uVar8 == 0x1000) {
    *(uint8_t *)(unaff_RBX + 0xf7) = 1;
  }
  else {
    if (uVar8 == 0x2000) {
      uVar6 = 2;
    }
    *(uint8_t *)(unaff_RBX + 0xf7) = uVar6;
  }
  if ((((*(float *)(lVar1 + 0x288) != 0.0) || (*(float *)(lVar1 + 0x28c) != 0.0)) ||
      (*(float *)(lVar1 + 0x290) != 0.0)) || (*(float *)(lVar1 + 0x294) != 0.0)) {
    uVar2 = *(uint32_t *)(lVar1 + 0x28c);
    uVar3 = *(uint32_t *)(lVar1 + 0x290);
    uVar4 = *(uint32_t *)(lVar1 + 0x294);
    *(uint32_t *)(unaff_RBX + 0x2a8) = *(uint32_t *)(lVar1 + 0x288);
    *(uint32_t *)(unaff_RBX + 0x2ac) = uVar2;
    *(uint32_t *)(unaff_RBX + 0x2b0) = uVar3;
    *(uint32_t *)(unaff_RBX + 0x2b4) = uVar4;
  }
  if (((*(float *)(lVar1 + 0x298) != 0.0) || (*(float *)(lVar1 + 0x29c) != 0.0)) ||
     ((*(float *)(lVar1 + 0x2a0) != 0.0 || (*(float *)(lVar1 + 0x2a4) != 0.0)))) {
    uVar2 = *(uint32_t *)(lVar1 + 0x29c);
    uVar3 = *(uint32_t *)(lVar1 + 0x2a0);
    uVar4 = *(uint32_t *)(lVar1 + 0x2a4);
    *(uint32_t *)(unaff_RBX + 0x2b8) = *(uint32_t *)(lVar1 + 0x298);
    *(uint32_t *)(unaff_RBX + 700) = uVar2;
    *(uint32_t *)(unaff_RBX + 0x2c0) = uVar3;
    *(uint32_t *)(unaff_RBX + 0x2c4) = uVar4;
  }
  *(undefined2 *)(lVar1 + 0x3c0) = 0xffff;
  FUN_180077150();
  if ((*(long long *)(unaff_RBX + 600) == 0) &&
     ((*(uint *)(*(long long *)(unaff_RBX + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,9);
    *(void* *)((long long)systemPreviousNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(systemPreviousNode + 9) = 0xffffffff;
    *systemPreviousNode = 0;
    systemPreviousNode[2] = 0;
    systemPreviousNode[7] = 0;
    *(uint32_t *)(systemPreviousNode + 5) = 0xffffffff;
    *(uint32_t *)(systemPreviousNode + 4) = 0xffffffff;
    systemPreviousNode[3] = 0;
    *(uint32_t *)(systemPreviousNode + 8) = 0;
    *(uint32_t *)(systemPreviousNode + 1) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x44) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x24) = 0;
    *(void* **)(unaff_RBX + 600) = systemPreviousNode;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180078239(float param_1,float param_2,float param_3,float param_4)
void FUN_180078239(float param_1,float param_2,float param_3,float param_4)

{
  long long lVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  char cVar5;
  uint8_t uVar6;
  long long in_RAX;
  void** systemCurrentNode;
  long long in_RCX;
  uint uVar8;
  long long unaff_RBX;
  bool bVar9;
  float fVar10;
  float in_XMM4_Da;
  float in_XMM5_Da;
  float unaff_XMM8_Da;
  
  fVar10 = (*(float *)(in_RAX + 0x74) * param_2 - param_3 * param_4) * *(float *)(in_RAX + 0x90);
  func_0x0001800773c0(fVar10,(param_3 * in_XMM4_Da - param_1 * param_2) * *(float *)(in_RAX + 0x94)
                             + fVar10 +
                             (in_XMM5_Da * param_4 - *(float *)(in_RAX + 0x74) * in_XMM4_Da) *
                             *(float *)(in_RAX + 0x98) < unaff_XMM8_Da);
  if (*(long long *)(in_RCX + 0x1b8) == 0) {
LAB_1800782d4:
    bVar9 = (*(byte *)(unaff_RBX + 0xfd) & 2) != 0;
  }
  else {
    uVar8 = *(uint *)(*(long long *)(in_RCX + 0x1b8) + 0x138);
    if ((uVar8 & 0x20) != 0) {
      cVar5 = '\0';
      goto LAB_1800782e0;
    }
    if ((uVar8 & 0x10) == 0) goto LAB_1800782d4;
    bVar9 = (*(byte *)(unaff_RBX + 0xfd) & 2) == 0;
  }
  cVar5 = bVar9 + '\x01';
LAB_1800782e0:
  *(char *)(unaff_RBX + 0xff) = cVar5;
  lVar1 = *(long long *)(unaff_RBX + 0x1b8);
  uVar8 = *(uint *)(lVar1 + 0x138) & 0x3000;
  uVar6 = 0;
  if (uVar8 == 0x1000) {
    *(uint8_t *)(unaff_RBX + 0xf7) = 1;
  }
  else {
    if (uVar8 == 0x2000) {
      uVar6 = 2;
    }
    *(uint8_t *)(unaff_RBX + 0xf7) = uVar6;
  }
  if ((((unaff_XMM8_Da != *(float *)(lVar1 + 0x288)) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x28c))
       ) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x290))) ||
     (unaff_XMM8_Da != *(float *)(lVar1 + 0x294))) {
    uVar2 = *(uint32_t *)(lVar1 + 0x28c);
    uVar3 = *(uint32_t *)(lVar1 + 0x290);
    uVar4 = *(uint32_t *)(lVar1 + 0x294);
    *(uint32_t *)(unaff_RBX + 0x2a8) = *(uint32_t *)(lVar1 + 0x288);
    *(uint32_t *)(unaff_RBX + 0x2ac) = uVar2;
    *(uint32_t *)(unaff_RBX + 0x2b0) = uVar3;
    *(uint32_t *)(unaff_RBX + 0x2b4) = uVar4;
  }
  if (((unaff_XMM8_Da != *(float *)(lVar1 + 0x298)) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x29c)))
     || ((unaff_XMM8_Da != *(float *)(lVar1 + 0x2a0) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x2a4))
         ))) {
    uVar2 = *(uint32_t *)(lVar1 + 0x29c);
    uVar3 = *(uint32_t *)(lVar1 + 0x2a0);
    uVar4 = *(uint32_t *)(lVar1 + 0x2a4);
    *(uint32_t *)(unaff_RBX + 0x2b8) = *(uint32_t *)(lVar1 + 0x298);
    *(uint32_t *)(unaff_RBX + 700) = uVar2;
    *(uint32_t *)(unaff_RBX + 0x2c0) = uVar3;
    *(uint32_t *)(unaff_RBX + 0x2c4) = uVar4;
  }
  *(undefined2 *)(lVar1 + 0x3c0) = 0xffff;
  FUN_180077150();
  if ((*(long long *)(unaff_RBX + 600) == 0) &&
     ((*(uint *)(*(long long *)(unaff_RBX + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,9);
    *(void* *)((long long)systemPreviousNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(systemPreviousNode + 9) = 0xffffffff;
    *systemPreviousNode = 0;
    systemPreviousNode[2] = 0;
    systemPreviousNode[7] = 0;
    *(uint32_t *)(systemPreviousNode + 5) = 0xffffffff;
    *(uint32_t *)(systemPreviousNode + 4) = 0xffffffff;
    systemPreviousNode[3] = 0;
    *(uint32_t *)(systemPreviousNode + 8) = 0;
    *(uint32_t *)(systemPreviousNode + 1) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x44) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x24) = 0;
    *(void* **)(unaff_RBX + 600) = systemPreviousNode;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800782a8(long long param_1)
void FUN_1800782a8(long long param_1)

{
  long long lVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  char cVar5;
  uint8_t uVar6;
  void** systemCurrentNode;
  uint uVar8;
  long long unaff_RBX;
  bool bVar9;
  float unaff_XMM8_Da;
  
  if (*(long long *)(param_1 + 0x1b8) == 0) {
LAB_1800782d4:
    bVar9 = (*(byte *)(unaff_RBX + 0xfd) & 2) != 0;
  }
  else {
    uVar8 = *(uint *)(*(long long *)(param_1 + 0x1b8) + 0x138);
    if ((uVar8 & 0x20) != 0) {
      cVar5 = '\0';
      goto LAB_1800782e0;
    }
    if ((uVar8 & 0x10) == 0) goto LAB_1800782d4;
    bVar9 = (*(byte *)(unaff_RBX + 0xfd) & 2) == 0;
  }
  cVar5 = bVar9 + '\x01';
LAB_1800782e0:
  *(char *)(unaff_RBX + 0xff) = cVar5;
  lVar1 = *(long long *)(unaff_RBX + 0x1b8);
  uVar8 = *(uint *)(lVar1 + 0x138) & 0x3000;
  uVar6 = 0;
  if (uVar8 == 0x1000) {
    *(uint8_t *)(unaff_RBX + 0xf7) = 1;
  }
  else {
    if (uVar8 == 0x2000) {
      uVar6 = 2;
    }
    *(uint8_t *)(unaff_RBX + 0xf7) = uVar6;
  }
  if ((((unaff_XMM8_Da != *(float *)(lVar1 + 0x288)) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x28c))
       ) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x290))) ||
     (unaff_XMM8_Da != *(float *)(lVar1 + 0x294))) {
    uVar2 = *(uint32_t *)(lVar1 + 0x28c);
    uVar3 = *(uint32_t *)(lVar1 + 0x290);
    uVar4 = *(uint32_t *)(lVar1 + 0x294);
    *(uint32_t *)(unaff_RBX + 0x2a8) = *(uint32_t *)(lVar1 + 0x288);
    *(uint32_t *)(unaff_RBX + 0x2ac) = uVar2;
    *(uint32_t *)(unaff_RBX + 0x2b0) = uVar3;
    *(uint32_t *)(unaff_RBX + 0x2b4) = uVar4;
  }
  if (((unaff_XMM8_Da != *(float *)(lVar1 + 0x298)) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x29c)))
     || ((unaff_XMM8_Da != *(float *)(lVar1 + 0x2a0) || (unaff_XMM8_Da != *(float *)(lVar1 + 0x2a4))
         ))) {
    uVar2 = *(uint32_t *)(lVar1 + 0x29c);
    uVar3 = *(uint32_t *)(lVar1 + 0x2a0);
    uVar4 = *(uint32_t *)(lVar1 + 0x2a4);
    *(uint32_t *)(unaff_RBX + 0x2b8) = *(uint32_t *)(lVar1 + 0x298);
    *(uint32_t *)(unaff_RBX + 700) = uVar2;
    *(uint32_t *)(unaff_RBX + 0x2c0) = uVar3;
    *(uint32_t *)(unaff_RBX + 0x2c4) = uVar4;
  }
  *(undefined2 *)(lVar1 + 0x3c0) = 0xffff;
  FUN_180077150();
  if ((*(long long *)(unaff_RBX + 600) == 0) &&
     ((*(uint *)(*(long long *)(unaff_RBX + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,9);
    *(void* *)((long long)systemPreviousNode + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(systemPreviousNode + 9) = 0xffffffff;
    *systemPreviousNode = 0;
    systemPreviousNode[2] = 0;
    systemPreviousNode[7] = 0;
    *(uint32_t *)(systemPreviousNode + 5) = 0xffffffff;
    *(uint32_t *)(systemPreviousNode + 4) = 0xffffffff;
    systemPreviousNode[3] = 0;
    *(uint32_t *)(systemPreviousNode + 8) = 0;
    *(uint32_t *)(systemPreviousNode + 1) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x44) = 0;
    *(uint8_t *)((long long)systemPreviousNode + 0x24) = 0;
    *(void* **)(unaff_RBX + 600) = systemPreviousNode;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800783b0(void)
void FUN_1800783b0(void)

{
  void* *puVar1;
  long long unaff_RBX;
  void* unaff_RDI;
  
  if ((*(uint *)(*(long long *)(unaff_RBX + 0x1b8) + 0x388) >> 0x19 & 1) != 0) {
    puVar1 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,9);
    *(void* *)((long long)puVar1 + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(puVar1 + 9) = 0xffffffff;
    *puVar1 = unaff_RDI;
    puVar1[2] = unaff_RDI;
    puVar1[7] = unaff_RDI;
    *(uint32_t *)(puVar1 + 5) = 0xffffffff;
    *(uint32_t *)(puVar1 + 4) = 0xffffffff;
    puVar1[3] = unaff_RDI;
    *(int *)(puVar1 + 8) = (int)unaff_RDI;
    *(int *)(puVar1 + 1) = (int)unaff_RDI;
    *(char *)((long long)puVar1 + 0x44) = (char)unaff_RDI;
    *(char *)((long long)puVar1 + 0x24) = (char)unaff_RDI;
    *(void* **)(unaff_RBX + 600) = puVar1;
  }
  return;
}



void* * FUN_1800784e0(void* *param_1,ulong long param_2)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  *param_1 = &UNK_180a001e8;
  FUN_180078550();
  FUN_1808fc8a8(param_1 + 1,8,7,FUN_180045af0,uVar1);
  if ((param_2 & 1) != 0) {
    free(param_1,0x158);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180078550(void* *param_1,void* param_2,void* param_3,void* param_4)
void FUN_180078550(void* *param_1,void* param_2,void* param_3,void* param_4)

{
  long long *plVar1;
  long long *plVar2;
  long long lVar3;
  uint32_t uVar4;
  void* uVar5;
  
  uVar5 = 0xfffffffffffffffe;
  if (0 < *(int *)(_DAT_180c8aa00 + 0x40)) {
    param_1[0x26] = *(void* *)(_DAT_180c8aa00 + 0x38);
  }
  plVar2 = param_1 + 1;
  lVar3 = 7;
  do {
    plVar1 = (long long *)*plVar2;
    *plVar2 = 0;
    if (plVar1 != (long long *)0x0) {
      (**(code **)(*plVar1 + 0x38))();
    }
    plVar2 = plVar2 + 1;
    lVar3 = lVar3 + -1;
  } while (lVar3 != 0);
  param_1[0x20] = 0x3f8000003f800000;
  param_1[0x21] = 0x3f8000003f800000;
  param_1[0x22] = 0;
  *(uint32_t *)(param_1 + 0x23) = 0;
  *(uint32_t *)((long long)param_1 + 0x11c) = 0x3f800000;
  param_1[0x24] = 0x3f800000;
  *(uint32_t *)(param_1 + 0x25) = 0;
  *(void* *)((long long)param_1 + 0x13c) = 0;
  *(uint32_t *)((long long)param_1 + 0x144) = 0;
  *(uint32_t *)(param_1 + 0x29) = 0x3f800000;
  *(uint32_t *)((long long)param_1 + 0x14c) = 0x3f800000;
  *(undefined2 *)(param_1 + 0x2a) = 0;
  *(uint8_t *)((long long)param_1 + 0x152) = 1;
  *(uint32_t *)(param_1 + 0x27) = 0;
  param_1[8] = 0x3f800000;
  param_1[9] = 0;
  param_1[10] = 0x3f80000000000000;
  param_1[0xb] = 0;
  *(uint32_t *)(param_1 + 0xc) = 0;
  *(uint32_t *)((long long)param_1 + 100) = 0;
  *(uint32_t *)(param_1 + 0xd) = 0x3f800000;
  *(uint32_t *)((long long)param_1 + 0x6c) = 0;
  *(uint32_t *)(param_1 + 0xe) = 0;
  *(uint32_t *)((long long)param_1 + 0x74) = 0;
  *(uint32_t *)(param_1 + 0xf) = 0;
  *(uint32_t *)((long long)param_1 + 0x7c) = 0x3f800000;
  if ((undefined *)*param_1 == &UNK_180a001e8) {
    param_1[0x10] = param_1[8];
    param_1[0x11] = param_1[9];
    param_1[0x12] = param_1[10];
    param_1[0x13] = param_1[0xb];
    *(uint32_t *)(param_1 + 0x14) = *(uint32_t *)(param_1 + 0xc);
    *(uint32_t *)((long long)param_1 + 0xa4) = *(uint32_t *)((long long)param_1 + 100);
    *(uint32_t *)(param_1 + 0x15) = *(uint32_t *)(param_1 + 0xd);
    *(uint32_t *)((long long)param_1 + 0xac) = *(uint32_t *)((long long)param_1 + 0x6c);
    *(uint32_t *)(param_1 + 0x16) = *(uint32_t *)(param_1 + 0xe);
    *(uint32_t *)((long long)param_1 + 0xb4) = *(uint32_t *)((long long)param_1 + 0x74);
    *(uint32_t *)(param_1 + 0x17) = *(uint32_t *)(param_1 + 0xf);
    *(uint32_t *)((long long)param_1 + 0xbc) = *(uint32_t *)((long long)param_1 + 0x7c);
    uVar4 = FUN_180084ae0();
    *(uint32_t *)((long long)param_1 + 0x8c) = 0;
    *(uint32_t *)((long long)param_1 + 0x9c) = 0;
    *(uint32_t *)((long long)param_1 + 0xac) = 0;
    *(uint32_t *)((long long)param_1 + 0xbc) = 0x3f800000;
    FUN_180084760(uVar4,param_1 + 0x18);
  }
  else {
    (**(code **)((undefined *)*param_1 + 0x10))(param_1,0,param_3,param_4,uVar5);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800786e0(void* *param_1,long long param_2)
void FUN_1800786e0(void* *param_1,long long param_2)

{
  long long lVar1;
  uint32_t uVar2;
  long long *plVar3;
  void* uVar4;
  float *pfVar5;
  undefined *puVar6;
  long long lVar7;
  long long *plVar8;
  int iVar9;
  float fVar10;
  uint32_t uVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  float fVar31;
  long long *plStackX_8;
  void* auStackX_10 [2];
  void* uStackX_20;
  void* uStack_58;
  void* uStack_50;
  uint32_t uStack_40;
  
  iVar9 = 0;
  plVar8 = param_1 + 1;
  do {
    plVar3 = (long long *)FUN_1801fd480(param_2,iVar9);
    if (plVar3 != (long long *)0x0) {
      plStackX_8 = plVar3;
      (**(code **)(*plVar3 + 0x28))(plVar3);
    }
    plStackX_8 = (long long *)*plVar8;
    *plVar8 = (long long)plVar3;
    if (plStackX_8 != (long long *)0x0) {
      (**(code **)(*plStackX_8 + 0x38))();
    }
    if ((((*(char *)(param_2 + 0x380) != '\0') && (*(char *)(param_2 + 0x381) == '\0')) &&
        (lVar1 = *plVar8, lVar1 != 0)) && ((*(uint *)(lVar1 + 0x328) & 0x200000) == 0)) {
      puVar6 = &SystemStringTemplate;
      if (*(undefined **)(lVar1 + 0x18) != (undefined *)0x0) {
        puVar6 = *(undefined **)(lVar1 + 0x18);
      }
      FUN_180626f80(&UNK_1809ffae0,puVar6);
    }
    iVar9 = iVar9 + 1;
    plVar8 = plVar8 + 1;
  } while (iVar9 < 7);
  uVar4 = FUN_1801fc6c0(param_2,&uStack_58);
  lVar1 = _DAT_180c8aa00;
  iVar9 = FUN_180191c00(_DAT_180c8aa00,uVar4);
  if ((iVar9 == -1) || (lVar7 = (long long)iVar9 * 0x68 + *(long long *)(lVar1 + 0x38), lVar7 == 0)) {
    lVar7 = *(long long *)(lVar1 + 0x28);
  }
  uStack_58 = &SystemGlobalDataReference;
  if (uStack_50 != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  uStack_50 = 0;
  uStack_40 = 0;
  uStack_58 = &SystemMemoryAllocatorReference;
  if (lVar7 == 0) {
    lVar7 = *(long long *)(_DAT_180c8aa00 + 0x38);
  }
  param_1[0x26] = lVar7;
  if ((*(char *)(param_2 + 0x248) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc730();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x240);
  }
  *(uint32_t *)((long long)param_1 + 0x114) = uVar2;
  if ((*(char *)(param_2 + 0x254) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc760();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x24c);
  }
  *(uint32_t *)(param_1 + 0x23) = uVar2;
  if ((*(char *)(param_2 + 0x2f0) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    FUN_1801fca40(*(long long *)(param_2 + 0x3c8),&uStack_58);
    uVar2 = (uint32_t)uStack_58;
    uVar11 = uStack_58._4_4_;
    uVar12 = (uint32_t)uStack_50;
    uVar13 = uStack_50._4_4_;
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x2d0);
    uVar11 = *(uint32_t *)(param_2 + 0x2d4);
    uVar12 = *(uint32_t *)(param_2 + 0x2d8);
    uVar13 = *(uint32_t *)(param_2 + 0x2dc);
  }
  *(uint32_t *)(param_1 + 0x20) = uVar2;
  *(uint32_t *)((long long)param_1 + 0x104) = uVar11;
  *(uint32_t *)(param_1 + 0x21) = uVar12;
  *(uint32_t *)((long long)param_1 + 0x10c) = uVar13;
  if ((*(char *)(param_2 + 0x2fc) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fca90();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x2f4);
  }
  *(uint32_t *)(param_1 + 0x22) = uVar2;
  if ((*(char *)(param_2 + 0x260) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fcac0();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 600);
  }
  *(uint32_t *)((long long)param_1 + 0x11c) = uVar2;
  if ((*(char *)(param_2 + 0x26c) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fcb00();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x264);
  }
  *(uint32_t *)(param_1 + 0x24) = uVar2;
  if ((*(char *)(param_2 + 0x278) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fcb40();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x270);
  }
  *(uint32_t *)((long long)param_1 + 0x124) = uVar2;
  if ((*(char *)(param_2 + 0x284) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fcb80();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x27c);
  }
  *(uint32_t *)(param_1 + 0x25) = uVar2;
  if ((*(char *)(param_2 + 0x290) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc7a0();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x288);
  }
  *(uint32_t *)(param_1 + 0x27) = uVar2;
  if ((*(char *)(param_2 + 0x29c) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc7d0();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x294);
  }
  *(uint32_t *)((long long)param_1 + 0x13c) = uVar2;
  if ((*(char *)(param_2 + 0x2a8) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc800();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x2a0);
  }
  *(uint32_t *)(param_1 + 0x28) = uVar2;
  if ((*(char *)(param_2 + 0x2b4) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc840();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x2ac);
  }
  *(uint32_t *)((long long)param_1 + 0x144) = uVar2;
  if ((*(char *)(param_2 + 0x2c0) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc880();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x2b8);
  }
  *(uint32_t *)(param_1 + 0x29) = uVar2;
  if ((*(char *)(param_2 + 0x2cc) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc8c0();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x2c4);
  }
  *(uint32_t *)((long long)param_1 + 0x14c) = uVar2;
  if ((*(char *)(param_2 + 0x29c) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    uVar2 = func_0x0001801fc7d0();
  }
  else {
    uVar2 = *(uint32_t *)(param_2 + 0x294);
  }
  *(uint32_t *)((long long)param_1 + 0x13c) = uVar2;
  *(uint8_t *)((long long)param_1 + 0x152) = *(uint8_t *)(param_2 + 0x380);
  *(uint8_t *)(param_1 + 0x2a) = *(uint8_t *)(param_2 + 0x381);
  if ((*(char *)(param_2 + 0x35c) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    FUN_1801fc9f0(*(long long *)(param_2 + 0x3c8),&plStackX_8);
  }
  else {
    plStackX_8 = *(long long **)(param_2 + 0x34c);
  }
  if ((*(char *)(param_2 + 0x348) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    FUN_1801fc9a0(*(long long *)(param_2 + 0x3c8),auStackX_10);
  }
  else {
    auStackX_10[0] = *(void* *)(param_2 + 0x338);
  }
  if ((*(char *)(param_2 + 0x334) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    FUN_1801fc950(*(long long *)(param_2 + 0x3c8),&uStackX_20);
  }
  else {
    uStackX_20 = *(void* *)(param_2 + 0x324);
  }
  if ((*(char *)(param_2 + 800) == '\0') && (*(long long *)(param_2 + 0x3c8) != 0)) {
    FUN_1801fc900(*(long long *)(param_2 + 0x3c8),&uStack_58);
  }
  else {
    uStack_58 = *(undefined **)(param_2 + 0x300);
    uStack_50 = *(void* *)(param_2 + 0x308);
  }
  FUN_180084c70(param_1 + 8,&uStack_58,&uStackX_20,auStackX_10,&plStackX_8);
  if ((undefined *)*param_1 == &UNK_180a001e8) {
    pfVar5 = (float *)(param_1 + 0x10);
    *(void* *)pfVar5 = param_1[8];
    param_1[0x11] = param_1[9];
    param_1[0x12] = param_1[10];
    param_1[0x13] = param_1[0xb];
    *(uint32_t *)(param_1 + 0x14) = *(uint32_t *)(param_1 + 0xc);
    *(uint32_t *)((long long)param_1 + 0xa4) = *(uint32_t *)((long long)param_1 + 100);
    *(uint32_t *)(param_1 + 0x15) = *(uint32_t *)(param_1 + 0xd);
    *(uint32_t *)((long long)param_1 + 0xac) = *(uint32_t *)((long long)param_1 + 0x6c);
    *(uint32_t *)(param_1 + 0x16) = *(uint32_t *)(param_1 + 0xe);
    *(uint32_t *)((long long)param_1 + 0xb4) = *(uint32_t *)((long long)param_1 + 0x74);
    *(uint32_t *)(param_1 + 0x17) = *(uint32_t *)(param_1 + 0xf);
    *(uint32_t *)((long long)param_1 + 0xbc) = *(uint32_t *)((long long)param_1 + 0x7c);
    FUN_180084ae0();
    *(uint32_t *)((long long)param_1 + 0x8c) = 0;
    *(uint32_t *)((long long)param_1 + 0x9c) = 0;
    *(uint32_t *)((long long)param_1 + 0xac) = 0;
    *(uint32_t *)((long long)param_1 + 0xbc) = 0x3f800000;
    fVar18 = pfVar5[6];
    fVar16 = pfVar5[0xd];
    fVar10 = pfVar5[9];
    fVar17 = pfVar5[1];
    fVar15 = pfVar5[0xe];
    fVar23 = pfVar5[2];
    fVar25 = pfVar5[10];
    fVar28 = pfVar5[5];
    fVar24 = fVar15 * fVar10 - fVar16 * fVar25;
    fVar21 = fVar15 * fVar28 - fVar16 * fVar18;
    fVar22 = fVar15 * fVar17 - fVar16 * fVar23;
    fVar29 = fVar28 * fVar25 - fVar10 * fVar18;
    fVar20 = fVar17 * fVar25 - fVar10 * fVar23;
    *(float *)(param_1 + 0x18) = fVar29;
    fVar19 = fVar17 * fVar18 - fVar28 * fVar23;
    fVar30 = fVar23 * pfVar5[9] - fVar25 * pfVar5[1];
    *(float *)((long long)param_1 + 0xc4) = fVar30;
    fVar16 = pfVar5[5];
    fVar15 = pfVar5[1];
    *(uint32_t *)((long long)param_1 + 0xcc) = 0;
    fVar31 = fVar18 * fVar15 - fVar23 * fVar16;
    *(float *)(param_1 + 0x19) = fVar31;
    fVar14 = fVar18 * pfVar5[8] - fVar25 * pfVar5[4];
    *(float *)(param_1 + 0x1a) = fVar14;
    fVar27 = fVar25 * *pfVar5 - fVar23 * pfVar5[8];
    *(float *)((long long)param_1 + 0xd4) = fVar27;
    fVar16 = pfVar5[4];
    fVar15 = *pfVar5;
    *(uint32_t *)((long long)param_1 + 0xdc) = 0;
    fVar26 = fVar23 * fVar16 - fVar18 * fVar15;
    *(float *)(param_1 + 0x1b) = fVar26;
    fVar15 = fVar10 * pfVar5[4] - fVar28 * pfVar5[8];
    *(float *)(param_1 + 0x1c) = fVar15;
    fVar10 = fVar17 * pfVar5[8] - fVar10 * *pfVar5;
    *(float *)((long long)param_1 + 0xe4) = fVar10;
    fVar18 = pfVar5[4];
    fVar16 = *pfVar5;
    *(uint32_t *)((long long)param_1 + 0xec) = 0;
    fVar28 = fVar28 * fVar16 - fVar17 * fVar18;
    *(float *)(param_1 + 0x1d) = fVar28;
    fVar16 = (fVar21 * pfVar5[8] - fVar24 * pfVar5[4]) - fVar29 * pfVar5[0xc];
    *(float *)(param_1 + 0x1e) = fVar16;
    fVar25 = (fVar24 * *pfVar5 - fVar22 * pfVar5[8]) + fVar20 * pfVar5[0xc];
    *(float *)((long long)param_1 + 0xf4) = fVar25;
    fVar23 = (fVar22 * pfVar5[4] - fVar21 * *pfVar5) - fVar19 * pfVar5[0xc];
    *(float *)(param_1 + 0x1f) = fVar23;
    fVar17 = (fVar29 * *pfVar5 - fVar20 * pfVar5[4]) + fVar19 * pfVar5[8];
    *(float *)((long long)param_1 + 0xfc) = fVar17;
    fVar18 = fVar30 * pfVar5[4] + fVar29 * *pfVar5 + fVar31 * pfVar5[8];
    if (fVar18 != 1.0) {
      fVar18 = 1.0 / fVar18;
      *(float *)(param_1 + 0x1a) = fVar14 * fVar18;
      *(float *)(param_1 + 0x1c) = fVar15 * fVar18;
      *(float *)(param_1 + 0x18) = fVar29 * fVar18;
      *(float *)((long long)param_1 + 0xc4) = fVar30 * fVar18;
      *(float *)(param_1 + 0x19) = fVar31 * fVar18;
      *(float *)((long long)param_1 + 0xd4) = fVar27 * fVar18;
      *(float *)(param_1 + 0x1b) = fVar26 * fVar18;
      *(float *)((long long)param_1 + 0xe4) = fVar10 * fVar18;
      *(float *)(param_1 + 0x1d) = fVar28 * fVar18;
      *(float *)(param_1 + 0x1e) = fVar16 * fVar18;
      *(float *)((long long)param_1 + 0xf4) = fVar25 * fVar18;
      *(float *)(param_1 + 0x1f) = fVar23 * fVar18;
      *(float *)((long long)param_1 + 0xfc) = fVar17 * fVar18;
    }
    return;
  }
  (**(code **)((undefined *)*param_1 + 0x10))(param_1);
  return;
}




// 函数: void FUN_180078c10(long long param_1)
void FUN_180078c10(long long param_1)

{
  float *pfVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  float fVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  
  pfVar1 = (float *)(param_1 + 0x80);
  *(void* *)pfVar1 = *(void* *)(param_1 + 0x40);
  *(void* *)(param_1 + 0x88) = *(void* *)(param_1 + 0x48);
  *(void* *)(param_1 + 0x90) = *(void* *)(param_1 + 0x50);
  *(void* *)(param_1 + 0x98) = *(void* *)(param_1 + 0x58);
  *(uint32_t *)(param_1 + 0xa0) = *(uint32_t *)(param_1 + 0x60);
  *(uint32_t *)(param_1 + 0xa4) = *(uint32_t *)(param_1 + 100);
  *(uint32_t *)(param_1 + 0xa8) = *(uint32_t *)(param_1 + 0x68);
  *(uint32_t *)(param_1 + 0xac) = *(uint32_t *)(param_1 + 0x6c);
  *(uint32_t *)(param_1 + 0xb0) = *(uint32_t *)(param_1 + 0x70);
  *(uint32_t *)(param_1 + 0xb4) = *(uint32_t *)(param_1 + 0x74);
  *(uint32_t *)(param_1 + 0xb8) = *(uint32_t *)(param_1 + 0x78);
  *(uint32_t *)(param_1 + 0xbc) = *(uint32_t *)(param_1 + 0x7c);
  FUN_180084ae0();
  *(uint32_t *)(param_1 + 0xbc) = 0x3f800000;
  *(uint32_t *)(param_1 + 0x8c) = 0;
  *(uint32_t *)(param_1 + 0x9c) = 0;
  *(uint32_t *)(param_1 + 0xac) = 0;
  fVar7 = pfVar1[6];
  fVar5 = pfVar1[0xd];
  fVar2 = pfVar1[9];
  fVar6 = pfVar1[1];
  fVar4 = pfVar1[0xe];
  fVar12 = pfVar1[2];
  fVar14 = pfVar1[10];
  fVar17 = pfVar1[5];
  fVar13 = fVar4 * fVar2 - fVar5 * fVar14;
  fVar10 = fVar4 * fVar17 - fVar5 * fVar7;
  fVar11 = fVar4 * fVar6 - fVar5 * fVar12;
  fVar18 = fVar17 * fVar14 - fVar2 * fVar7;
  fVar9 = fVar6 * fVar14 - fVar2 * fVar12;
  *(float *)(param_1 + 0xc0) = fVar18;
  fVar8 = fVar6 * fVar7 - fVar17 * fVar12;
  fVar19 = fVar12 * pfVar1[9] - fVar14 * pfVar1[1];
  *(float *)(param_1 + 0xc4) = fVar19;
  fVar5 = pfVar1[5];
  fVar4 = pfVar1[1];
  *(uint32_t *)(param_1 + 0xcc) = 0;
  fVar20 = fVar7 * fVar4 - fVar12 * fVar5;
  *(float *)(param_1 + 200) = fVar20;
  fVar3 = fVar7 * pfVar1[8] - fVar14 * pfVar1[4];
  *(float *)(param_1 + 0xd0) = fVar3;
  fVar16 = fVar14 * *pfVar1 - fVar12 * pfVar1[8];
  *(float *)(param_1 + 0xd4) = fVar16;
  fVar5 = pfVar1[4];
  fVar4 = *pfVar1;
  *(uint32_t *)(param_1 + 0xdc) = 0;
  fVar15 = fVar12 * fVar5 - fVar7 * fVar4;
  *(float *)(param_1 + 0xd8) = fVar15;
  fVar4 = fVar2 * pfVar1[4] - fVar17 * pfVar1[8];
  *(float *)(param_1 + 0xe0) = fVar4;
  fVar2 = fVar6 * pfVar1[8] - fVar2 * *pfVar1;
  *(float *)(param_1 + 0xe4) = fVar2;
  fVar7 = pfVar1[4];
  fVar5 = *pfVar1;
  *(uint32_t *)(param_1 + 0xec) = 0;
  fVar17 = fVar17 * fVar5 - fVar6 * fVar7;
  *(float *)(param_1 + 0xe8) = fVar17;
  fVar5 = (fVar10 * pfVar1[8] - fVar13 * pfVar1[4]) - fVar18 * pfVar1[0xc];
  *(float *)(param_1 + 0xf0) = fVar5;
  fVar14 = (fVar13 * *pfVar1 - fVar11 * pfVar1[8]) + fVar9 * pfVar1[0xc];
  *(float *)(param_1 + 0xf4) = fVar14;
  fVar12 = (fVar11 * pfVar1[4] - fVar10 * *pfVar1) - fVar8 * pfVar1[0xc];
  *(float *)(param_1 + 0xf8) = fVar12;
  fVar6 = (fVar18 * *pfVar1 - fVar9 * pfVar1[4]) + fVar8 * pfVar1[8];
  *(float *)(param_1 + 0xfc) = fVar6;
  fVar7 = fVar19 * pfVar1[4] + fVar18 * *pfVar1 + fVar20 * pfVar1[8];
  if (fVar7 != 1.0) {
    fVar7 = 1.0 / fVar7;
    *(float *)(param_1 + 0xd0) = fVar3 * fVar7;
    *(float *)(param_1 + 0xe0) = fVar4 * fVar7;
    *(float *)(param_1 + 0xc0) = fVar18 * fVar7;
    *(float *)(param_1 + 0xc4) = fVar19 * fVar7;
    *(float *)(param_1 + 200) = fVar20 * fVar7;
    *(float *)(param_1 + 0xd4) = fVar16 * fVar7;
    *(float *)(param_1 + 0xd8) = fVar15 * fVar7;
    *(float *)(param_1 + 0xe4) = fVar2 * fVar7;
    *(float *)(param_1 + 0xe8) = fVar17 * fVar7;
    *(float *)(param_1 + 0xf0) = fVar5 * fVar7;
    *(float *)(param_1 + 0xf4) = fVar14 * fVar7;
    *(float *)(param_1 + 0xf8) = fVar12 * fVar7;
    *(float *)(param_1 + 0xfc) = fVar6 * fVar7;
  }
  return;
}




// 函数: void FUN_180078c70(uint32_t *param_1,long long *param_2)
void FUN_180078c70(uint32_t *param_1,long long *param_2)

{
  uint32_t uVar1;
  uint32_t *puVar2;
  
  uVar1 = *param_1;
  puVar2 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[1];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[2];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[3];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = 0x3f800000;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[5];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[6];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[7];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = 0x3f800000;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[9];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[10];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0xb];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = 0x3f800000;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0xd];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0xe];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0xf];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = 0x3f800000;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0x11];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0x12];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0x13];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0x14];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0x15];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    puVar2 = (uint32_t *)param_2[1];
  }
  *puVar2 = uVar1;
  param_2[1] = param_2[1] + 4;
  puVar2 = (uint32_t *)param_2[1];
  uVar1 = param_1[0x16];
  if ((ulong long)((*param_2 - (long long)puVar2) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar2 + (4 - *param_2));
    *(uint32_t *)param_2[1] = uVar1;
  }
  else {
    *puVar2 = uVar1;
  }
  param_2[1] = param_2[1] + 4;
  return;
}




// 函数: void FUN_1800791a0(long long param_1)
void FUN_1800791a0(long long param_1)

{
  long long lVar1;
  long long lVar2;
  byte bVar3;
  
  lVar2 = *(long long *)(param_1 + 0x210);
  *(uint32_t *)(param_1 + 0x1f8) = *(uint32_t *)(lVar2 + 0x10);
  *(uint32_t *)(param_1 + 0x1fc) = *(uint32_t *)(lVar2 + 0x88);
  *(uint32_t *)(param_1 + 0x200) = *(uint32_t *)(lVar2 + 0x60);
  bVar3 = *(byte *)(param_1 + 0xfd) & 0x40;
  if ((((bVar3 != 0) && (lVar2 != 0)) || (*(long long *)(param_1 + 0x1b0) == 0)) ||
     (lVar1 = FUN_180085900(), param_1 == lVar1)) {
    *(uint32_t *)(param_1 + 0x204) = *(uint32_t *)(lVar2 + 200);
  }
  if (((bVar3 == 0) || (lVar2 == 0)) &&
     ((*(long long *)(param_1 + 0x1b0) != 0 && (lVar1 = FUN_180085900(), param_1 != lVar1)))) {
    return;
  }
  *(uint *)(param_1 + 0x208) = (uint)*(ushort *)(lVar2 + 0xc0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180079270(long long param_1,long long param_2)
void FUN_180079270(long long param_1,long long param_2)

{
  long long *plVar1;
  int *piVar2;
  long long *plVar3;
  byte *pbVar4;
  void* *puVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  uint8_t uVar15;
  char cVar16;
  long long lVar17;
  float *pfVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  void* uVar31;
  uint32_t uVar32;
  long long lVar33;
  long long *plVar34;
  long long lVar35;
  uint uVar36;
  int iVar37;
  uint uVar38;
  int iVar39;
  ulong long uVar40;
  char *pcVar41;
  uint *puVar42;
  int iVar43;
  int iVar44;
  int iVar45;
  uint32_t *puVar46;
  uint *puVar47;
  ulong long uVar48;
  ulong long uVar49;
  bool bVar50;
  
  lVar17 = _DAT_180c86890;
  lVar33 = param_1;
  if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
    lVar33 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  LOCK();
  piVar2 = (int *)(lVar17 + 0xed8);
  iVar43 = *piVar2;
  *piVar2 = *piVar2 + *(int *)(lVar33 + 0x200);
  UNLOCK();
  lVar17 = *(long long *)(param_1 + 600);
  uVar15 = *(uint8_t *)(param_2 + 0x24);
  uVar32 = *(uint32_t *)(param_2 + 0x20);
  cVar16 = *(char *)(param_2 + 0xd);
  *(uint32_t *)(lVar17 + 0x48) = *(uint32_t *)(lVar17 + 0x2c);
  *(uint32_t *)(lVar17 + 0x50) = *(uint32_t *)(lVar17 + 0x4c);
  *(int *)(lVar17 + 0x4c) = iVar43;
  *(uint8_t *)(lVar17 + 0x44) = uVar15;
  *(uint32_t *)(lVar17 + 0x2c) = uVar32;
  if (cVar16 != -1) {
    uVar38 = (int)*(char *)(param_2 + 0xd) + *(int *)(param_2 + 0x18);
    pfVar18 = (float *)**(long long **)(param_1 + 600);
    uVar36 = uVar38 >> 0xd;
    lVar17 = *(long long *)
              ((long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc30 +
              (ulong long)uVar36 * 8);
    lVar33 = (ulong long)(uVar38 + uVar36 * -0x2000) * 0x40;
    uVar31 = ((void* *)(lVar17 + lVar33))[1];
    *(void* *)pfVar18 = *(void* *)(lVar17 + lVar33);
    *(void* *)(pfVar18 + 2) = uVar31;
    puVar5 = (void* *)(lVar17 + 0x10 + lVar33);
    uVar31 = puVar5[1];
    *(void* *)(pfVar18 + 4) = *puVar5;
    *(void* *)(pfVar18 + 6) = uVar31;
    puVar5 = (void* *)(lVar17 + 0x20 + lVar33);
    uVar31 = puVar5[1];
    *(void* *)(pfVar18 + 8) = *puVar5;
    *(void* *)(pfVar18 + 10) = uVar31;
    puVar5 = (void* *)(lVar17 + 0x30 + lVar33);
    uVar31 = puVar5[1];
    *(void* *)(pfVar18 + 0xc) = *puVar5;
    *(void* *)(pfVar18 + 0xe) = uVar31;
    lVar17 = *(long long *)(param_2 + 0x10);
    fVar19 = pfVar18[8];
    fVar20 = pfVar18[9];
    fVar21 = pfVar18[10];
    fVar22 = pfVar18[0xb];
    fVar23 = *pfVar18;
    fVar24 = pfVar18[1];
    fVar25 = pfVar18[2];
    fVar26 = pfVar18[3];
    fVar27 = pfVar18[4];
    fVar28 = pfVar18[5];
    fVar29 = pfVar18[6];
    fVar30 = pfVar18[7];
    fVar6 = *(float *)(lVar17 + 0x374);
    fVar7 = *(float *)(lVar17 + 0x370);
    fVar8 = *(float *)(lVar17 + 0x378);
    fVar9 = *(float *)(lVar17 + 900);
    fVar10 = *(float *)(lVar17 + 0x394);
    fVar11 = *(float *)(lVar17 + 0x380);
    fVar12 = *(float *)(lVar17 + 0x388);
    fVar13 = *(float *)(lVar17 + 0x390);
    fVar14 = *(float *)(lVar17 + 0x398);
    *pfVar18 = fVar6 * fVar27 + fVar7 * fVar23 + fVar8 * fVar19;
    pfVar18[1] = fVar6 * fVar28 + fVar7 * fVar24 + fVar8 * fVar20;
    pfVar18[2] = fVar6 * fVar29 + fVar7 * fVar25 + fVar8 * fVar21;
    pfVar18[3] = fVar6 * fVar30 + fVar7 * fVar26 + fVar8 * fVar22;
    pfVar18[4] = fVar9 * fVar27 + fVar11 * fVar23 + fVar12 * fVar19;
    pfVar18[5] = fVar9 * fVar28 + fVar11 * fVar24 + fVar12 * fVar20;
    pfVar18[6] = fVar9 * fVar29 + fVar11 * fVar25 + fVar12 * fVar21;
    pfVar18[7] = fVar9 * fVar30 + fVar11 * fVar26 + fVar12 * fVar22;
    pfVar18[8] = fVar10 * fVar27 + fVar13 * fVar23 + fVar14 * fVar19;
    pfVar18[9] = fVar10 * fVar28 + fVar13 * fVar24 + fVar14 * fVar20;
    pfVar18[10] = fVar10 * fVar29 + fVar13 * fVar25 + fVar14 * fVar21;
    pfVar18[0xb] = fVar10 * fVar30 + fVar13 * fVar26 + fVar14 * fVar22;
  }
  lVar17 = *(long long *)(param_1 + 600);
  if (*(int *)(lVar17 + 0x28) != *(int *)(_DAT_180c86870 + 0x224)) {
    iVar43 = *(int *)(lVar17 + 0x1c) + *(int *)(lVar17 + 0x18);
    *(int *)(lVar17 + 0x28) = *(int *)(_DAT_180c86870 + 0x224);
    if (0 < iVar43) {
      lVar33 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
      uVar32 = FUN_180080380(lVar33,iVar43);
      *(uint32_t *)(lVar17 + 0x30) = uVar32;
      FUN_1800802e0(lVar33,uVar32);
      if (*(long long *)(lVar17 + 0x10) == 0) {
        if (*(int *)(lVar17 + 0x18) != 0) {
          *(uint32_t *)(lVar17 + 0x2c) = *(uint32_t *)(lVar17 + 0x30);
          return;
        }
      }
      else {
        cVar16 = *(char *)(lVar17 + 0x44);
        uVar40 = (ulong long)cVar16;
        plVar1 = (long long *)(lVar17 + 0x38);
        iVar43 = (int)cVar16;
        if (*(int *)(lVar17 + 0x40) == (int)cVar16) {
          plVar34 = (long long *)*plVar1;
        }
        else {
          *(int *)(lVar17 + 0x40) = iVar43;
          if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          *plVar1 = 0;
          if (cVar16 == '\0') {
            plVar34 = (long long *)0x0;
            *plVar1 = 0;
          }
          else {
            plVar34 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar16 * 4);
            *plVar1 = (long long)plVar34;
          }
        }
        if (plVar34 != (long long *)0x0) {
          iVar44 = 0;
          uVar36 = (uint)cVar16;
          iVar45 = iVar44;
          if ((0 < iVar43) && (0xf < uVar36)) {
            iVar39 = *(int *)(lVar17 + 0x2c);
            plVar3 = (long long *)((long long)plVar34 + (long long)(cVar16 + -1) * 4);
            if ((((long long *)(lVar17 + 0x2c) < plVar34) || (plVar3 < (long long *)(lVar17 + 0x2c)))
               && ((plVar1 < plVar34 || (iVar45 = 0, plVar3 < plVar1)))) {
              uVar38 = uVar36 & 0x8000000f;
              if ((int)uVar38 < 0) {
                uVar38 = (uVar38 - 1 | 0xfffffff0) + 1;
              }
              plVar34 = plVar34 + 4;
              iVar37 = 8;
              do {
                *(int *)(plVar34 + -4) = iVar44 + iVar39;
                *(int *)((long long)plVar34 + -0x1c) = iVar44 + 1 + iVar39;
                *(int *)(plVar34 + -3) = iVar44 + 2 + iVar39;
                *(int *)((long long)plVar34 + -0x14) = iVar44 + 3 + iVar39;
                iVar44 = iVar44 + 0x10;
                *(int *)(plVar34 + -2) = iVar37 + -4 + iVar39;
                *(int *)((long long)plVar34 + -0xc) = iVar37 + -3 + iVar39;
                *(int *)(plVar34 + -1) = iVar37 + -2 + iVar39;
                *(int *)((long long)plVar34 + -4) = iVar37 + -1 + iVar39;
                *(int *)plVar34 = iVar37 + iVar39;
                *(int *)((long long)plVar34 + 4) = iVar37 + 1 + iVar39;
                *(int *)(plVar34 + 1) = iVar37 + 2 + iVar39;
                *(int *)((long long)plVar34 + 0xc) = iVar37 + 3 + iVar39;
                *(int *)(plVar34 + 2) = iVar37 + 4 + iVar39;
                *(int *)((long long)plVar34 + 0x14) = iVar37 + 5 + iVar39;
                *(int *)(plVar34 + 3) = iVar37 + 6 + iVar39;
                *(int *)((long long)plVar34 + 0x1c) = iVar37 + 7 + iVar39;
                plVar34 = plVar34 + 8;
                iVar37 = iVar37 + 0x10;
                iVar45 = iVar44;
              } while (iVar44 < (int)(uVar36 - uVar38));
            }
          }
          for (lVar33 = (long long)iVar45; lVar33 < (long long)uVar40; lVar33 = lVar33 + 1) {
            iVar44 = *(int *)(lVar17 + 0x2c) + iVar45;
            iVar45 = iVar45 + 1;
            *(int *)(*plVar1 + lVar33 * 4) = iVar44;
          }
          iVar45 = *(int *)(lVar17 + 0x18);
          iVar44 = 0;
          if (0 < (long long)iVar45) {
            lVar33 = 0;
            do {
              iVar39 = *(int *)(lVar17 + 0x30) + iVar44;
              iVar44 = iVar44 + 1;
              pbVar4 = (byte *)(*(long long *)(lVar17 + 0x10) + lVar33);
              lVar33 = lVar33 + 1;
              *(int *)(*plVar1 + (ulong long)*pbVar4 * 4) = iVar39;
            } while (lVar33 < iVar45);
          }
        }
        puVar42 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 +
                          _DAT_180c86890 + 0x9d0);
        if (iVar43 == 0) {
          uVar36 = (int)cVar16 - 1;
        }
        else {
          LOCK();
          uVar36 = *puVar42;
          *puVar42 = *puVar42 + (int)cVar16;
          UNLOCK();
          uVar48 = (ulong long)(uVar36 >> 0xb);
          uVar49 = (ulong long)(cVar16 + -1 + uVar36 >> 0xb);
          if (uVar48 <= uVar49) {
            pcVar41 = (char *)((long long)puVar42 + uVar48 + 0x108);
            lVar33 = (uVar49 - uVar48) + 1;
            puVar47 = puVar42 + uVar48 * 2 + 2;
            do {
              iVar45 = (int)uVar48;
              if (*(long long *)puVar47 == 0) {
                lVar35 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
                LOCK();
                bVar50 = *(long long *)(puVar42 + (long long)iVar45 * 2 + 2) == 0;
                if (bVar50) {
                  *(long long *)(puVar42 + (long long)iVar45 * 2 + 2) = lVar35;
                }
                UNLOCK();
                if (bVar50) {
                  LOCK();
                  *(uint8_t *)((long long)iVar45 + 0x108 + (long long)puVar42) = 0;
                  UNLOCK();
                }
                else {
                  if (lVar35 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                  } while (*pcVar41 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar41 != '\0');
              }
              uVar48 = (ulong long)(iVar45 + 1);
              puVar47 = puVar47 + 2;
              pcVar41 = pcVar41 + 1;
              lVar33 = lVar33 + -1;
            } while (lVar33 != 0);
          }
        }
        puVar46 = *(uint32_t **)(lVar17 + 0x38);
        uVar38 = uVar36 >> 0xb;
        *(uint *)(lVar17 + 0x2c) = uVar36;
        if (uVar38 == (int)cVar16 + uVar36 >> 0xb) {
                    // WARNING: Subroutine does not return
          memcpy(*(long long *)(puVar42 + (ulong long)uVar38 * 2 + 2) +
                 (ulong long)(uVar36 + uVar38 * -0x800) * 4,puVar46,(uVar40 & 0xffffffff) << 2);
        }
        if (iVar43 != 0) {
          uVar40 = uVar40 & 0xffffffff;
          do {
            uVar32 = *puVar46;
            puVar46 = puVar46 + 1;
            *(uint32_t *)
             (*(long long *)(puVar42 + (ulong long)(uVar36 >> 0xb) * 2 + 2) +
             (ulong long)(uVar36 + (uVar36 >> 0xb) * -0x800) * 4) = uVar32;
            uVar40 = uVar40 - 1;
            uVar36 = uVar36 + 1;
          } while (uVar40 != 0);
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180079284(long long param_1)
void FUN_180079284(long long param_1)

{
  long long *plVar1;
  int *piVar2;
  long long *plVar3;
  byte *pbVar4;
  void* *puVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  float fVar14;
  uint8_t uVar15;
  char cVar16;
  long long lVar17;
  float *pfVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  void* uVar31;
  uint32_t uVar32;
  long long lVar33;
  long long *plVar34;
  long long lVar35;
  uint uVar36;
  int iVar37;
  uint uVar38;
  int iVar39;
  ulong long uVar40;
  char *pcVar41;
  uint *puVar42;
  int iVar43;
  long long unaff_RDI;
  int iVar44;
  int iVar45;
  uint32_t *puVar46;
  uint *puVar47;
  ulong long uVar48;
  ulong long uVar49;
  bool in_ZF;
  bool bVar50;
  
  lVar17 = _DAT_180c86890;
  lVar33 = param_1;
  if (in_ZF) {
    lVar33 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  LOCK();
  piVar2 = (int *)(lVar17 + 0xed8);
  iVar43 = *piVar2;
  *piVar2 = *piVar2 + *(int *)(lVar33 + 0x200);
  UNLOCK();
  lVar17 = *(long long *)(param_1 + 600);
  uVar15 = *(uint8_t *)(unaff_RDI + 0x24);
  uVar32 = *(uint32_t *)(unaff_RDI + 0x20);
  cVar16 = *(char *)(unaff_RDI + 0xd);
  *(uint32_t *)(lVar17 + 0x48) = *(uint32_t *)(lVar17 + 0x2c);
  *(uint32_t *)(lVar17 + 0x50) = *(uint32_t *)(lVar17 + 0x4c);
  *(int *)(lVar17 + 0x4c) = iVar43;
  *(uint8_t *)(lVar17 + 0x44) = uVar15;
  *(uint32_t *)(lVar17 + 0x2c) = uVar32;
  if (cVar16 != -1) {
    uVar38 = (int)*(char *)(unaff_RDI + 0xd) + *(int *)(unaff_RDI + 0x18);
    pfVar18 = (float *)**(long long **)(param_1 + 600);
    uVar36 = uVar38 >> 0xd;
    lVar17 = *(long long *)
              ((long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc30 +
              (ulong long)uVar36 * 8);
    lVar33 = (ulong long)(uVar38 + uVar36 * -0x2000) * 0x40;
    uVar31 = ((void* *)(lVar17 + lVar33))[1];
    *(void* *)pfVar18 = *(void* *)(lVar17 + lVar33);
    *(void* *)(pfVar18 + 2) = uVar31;
    puVar5 = (void* *)(lVar17 + 0x10 + lVar33);
    uVar31 = puVar5[1];
    *(void* *)(pfVar18 + 4) = *puVar5;
    *(void* *)(pfVar18 + 6) = uVar31;
    puVar5 = (void* *)(lVar17 + 0x20 + lVar33);
    uVar31 = puVar5[1];
    *(void* *)(pfVar18 + 8) = *puVar5;
    *(void* *)(pfVar18 + 10) = uVar31;
    puVar5 = (void* *)(lVar17 + 0x30 + lVar33);
    uVar31 = puVar5[1];
    *(void* *)(pfVar18 + 0xc) = *puVar5;
    *(void* *)(pfVar18 + 0xe) = uVar31;
    lVar17 = *(long long *)(unaff_RDI + 0x10);
    fVar19 = pfVar18[8];
    fVar20 = pfVar18[9];
    fVar21 = pfVar18[10];
    fVar22 = pfVar18[0xb];
    fVar23 = *pfVar18;
    fVar24 = pfVar18[1];
    fVar25 = pfVar18[2];
    fVar26 = pfVar18[3];
    fVar27 = pfVar18[4];
    fVar28 = pfVar18[5];
    fVar29 = pfVar18[6];
    fVar30 = pfVar18[7];
    fVar6 = *(float *)(lVar17 + 0x374);
    fVar7 = *(float *)(lVar17 + 0x370);
    fVar8 = *(float *)(lVar17 + 0x378);
    fVar9 = *(float *)(lVar17 + 900);
    fVar10 = *(float *)(lVar17 + 0x394);
    fVar11 = *(float *)(lVar17 + 0x380);
    fVar12 = *(float *)(lVar17 + 0x388);
    fVar13 = *(float *)(lVar17 + 0x390);
    fVar14 = *(float *)(lVar17 + 0x398);
    *pfVar18 = fVar6 * fVar27 + fVar7 * fVar23 + fVar8 * fVar19;
    pfVar18[1] = fVar6 * fVar28 + fVar7 * fVar24 + fVar8 * fVar20;
    pfVar18[2] = fVar6 * fVar29 + fVar7 * fVar25 + fVar8 * fVar21;
    pfVar18[3] = fVar6 * fVar30 + fVar7 * fVar26 + fVar8 * fVar22;
    pfVar18[4] = fVar9 * fVar27 + fVar11 * fVar23 + fVar12 * fVar19;
    pfVar18[5] = fVar9 * fVar28 + fVar11 * fVar24 + fVar12 * fVar20;
    pfVar18[6] = fVar9 * fVar29 + fVar11 * fVar25 + fVar12 * fVar21;
    pfVar18[7] = fVar9 * fVar30 + fVar11 * fVar26 + fVar12 * fVar22;
    pfVar18[8] = fVar10 * fVar27 + fVar13 * fVar23 + fVar14 * fVar19;
    pfVar18[9] = fVar10 * fVar28 + fVar13 * fVar24 + fVar14 * fVar20;
    pfVar18[10] = fVar10 * fVar29 + fVar13 * fVar25 + fVar14 * fVar21;
    pfVar18[0xb] = fVar10 * fVar30 + fVar13 * fVar26 + fVar14 * fVar22;
  }
  lVar17 = *(long long *)(param_1 + 600);
  if (*(int *)(lVar17 + 0x28) != *(int *)(_DAT_180c86870 + 0x224)) {
    iVar43 = *(int *)(lVar17 + 0x1c) + *(int *)(lVar17 + 0x18);
    *(int *)(lVar17 + 0x28) = *(int *)(_DAT_180c86870 + 0x224);
    if (0 < iVar43) {
      lVar33 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
      uVar32 = FUN_180080380(lVar33,iVar43);
      *(uint32_t *)(lVar17 + 0x30) = uVar32;
      FUN_1800802e0(lVar33,uVar32);
      if (*(long long *)(lVar17 + 0x10) == 0) {
        if (*(int *)(lVar17 + 0x18) != 0) {
          *(uint32_t *)(lVar17 + 0x2c) = *(uint32_t *)(lVar17 + 0x30);
          return;
        }
      }
      else {
        cVar16 = *(char *)(lVar17 + 0x44);
        uVar40 = (ulong long)cVar16;
        plVar1 = (long long *)(lVar17 + 0x38);
        iVar43 = (int)cVar16;
        if (*(int *)(lVar17 + 0x40) == (int)cVar16) {
          plVar34 = (long long *)*plVar1;
        }
        else {
          *(int *)(lVar17 + 0x40) = iVar43;
          if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          *plVar1 = 0;
          if (cVar16 == '\0') {
            plVar34 = (long long *)0x0;
            *plVar1 = 0;
          }
          else {
            plVar34 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar16 * 4);
            *plVar1 = (long long)plVar34;
          }
        }
        if (plVar34 != (long long *)0x0) {
          iVar44 = 0;
          uVar36 = (uint)cVar16;
          iVar45 = iVar44;
          if ((0 < iVar43) && (0xf < uVar36)) {
            iVar39 = *(int *)(lVar17 + 0x2c);
            plVar3 = (long long *)((long long)plVar34 + (long long)(cVar16 + -1) * 4);
            if ((((long long *)(lVar17 + 0x2c) < plVar34) || (plVar3 < (long long *)(lVar17 + 0x2c)))
               && ((plVar1 < plVar34 || (iVar45 = 0, plVar3 < plVar1)))) {
              uVar38 = uVar36 & 0x8000000f;
              if ((int)uVar38 < 0) {
                uVar38 = (uVar38 - 1 | 0xfffffff0) + 1;
              }
              plVar34 = plVar34 + 4;
              iVar37 = 8;
              do {
                *(int *)(plVar34 + -4) = iVar44 + iVar39;
                *(int *)((long long)plVar34 + -0x1c) = iVar44 + 1 + iVar39;
                *(int *)(plVar34 + -3) = iVar44 + 2 + iVar39;
                *(int *)((long long)plVar34 + -0x14) = iVar44 + 3 + iVar39;
                iVar44 = iVar44 + 0x10;
                *(int *)(plVar34 + -2) = iVar37 + -4 + iVar39;
                *(int *)((long long)plVar34 + -0xc) = iVar37 + -3 + iVar39;
                *(int *)(plVar34 + -1) = iVar37 + -2 + iVar39;
                *(int *)((long long)plVar34 + -4) = iVar37 + -1 + iVar39;
                *(int *)plVar34 = iVar37 + iVar39;
                *(int *)((long long)plVar34 + 4) = iVar37 + 1 + iVar39;
                *(int *)(plVar34 + 1) = iVar37 + 2 + iVar39;
                *(int *)((long long)plVar34 + 0xc) = iVar37 + 3 + iVar39;
                *(int *)(plVar34 + 2) = iVar37 + 4 + iVar39;
                *(int *)((long long)plVar34 + 0x14) = iVar37 + 5 + iVar39;
                *(int *)(plVar34 + 3) = iVar37 + 6 + iVar39;
                *(int *)((long long)plVar34 + 0x1c) = iVar37 + 7 + iVar39;
                plVar34 = plVar34 + 8;
                iVar37 = iVar37 + 0x10;
                iVar45 = iVar44;
              } while (iVar44 < (int)(uVar36 - uVar38));
            }
          }
          for (lVar33 = (long long)iVar45; lVar33 < (long long)uVar40; lVar33 = lVar33 + 1) {
            iVar44 = *(int *)(lVar17 + 0x2c) + iVar45;
            iVar45 = iVar45 + 1;
            *(int *)(*plVar1 + lVar33 * 4) = iVar44;
          }
          iVar45 = *(int *)(lVar17 + 0x18);
          iVar44 = 0;
          if (0 < (long long)iVar45) {
            lVar33 = 0;
            do {
              iVar39 = *(int *)(lVar17 + 0x30) + iVar44;
              iVar44 = iVar44 + 1;
              pbVar4 = (byte *)(*(long long *)(lVar17 + 0x10) + lVar33);
              lVar33 = lVar33 + 1;
              *(int *)(*plVar1 + (ulong long)*pbVar4 * 4) = iVar39;
            } while (lVar33 < iVar45);
          }
        }
        puVar42 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 +
                          _DAT_180c86890 + 0x9d0);
        if (iVar43 == 0) {
          uVar36 = (int)cVar16 - 1;
        }
        else {
          LOCK();
          uVar36 = *puVar42;
          *puVar42 = *puVar42 + (int)cVar16;
          UNLOCK();
          uVar48 = (ulong long)(uVar36 >> 0xb);
          uVar49 = (ulong long)(cVar16 + -1 + uVar36 >> 0xb);
          if (uVar48 <= uVar49) {
            pcVar41 = (char *)((long long)puVar42 + uVar48 + 0x108);
            lVar33 = (uVar49 - uVar48) + 1;
            puVar47 = puVar42 + uVar48 * 2 + 2;
            do {
              iVar45 = (int)uVar48;
              if (*(long long *)puVar47 == 0) {
                lVar35 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
                LOCK();
                bVar50 = *(long long *)(puVar42 + (long long)iVar45 * 2 + 2) == 0;
                if (bVar50) {
                  *(long long *)(puVar42 + (long long)iVar45 * 2 + 2) = lVar35;
                }
                UNLOCK();
                if (bVar50) {
                  LOCK();
                  *(uint8_t *)((long long)iVar45 + 0x108 + (long long)puVar42) = 0;
                  UNLOCK();
                }
                else {
                  if (lVar35 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                  } while (*pcVar41 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar41 != '\0');
              }
              uVar48 = (ulong long)(iVar45 + 1);
              puVar47 = puVar47 + 2;
              pcVar41 = pcVar41 + 1;
              lVar33 = lVar33 + -1;
            } while (lVar33 != 0);
          }
        }
        puVar46 = *(uint32_t **)(lVar17 + 0x38);
        uVar38 = uVar36 >> 0xb;
        *(uint *)(lVar17 + 0x2c) = uVar36;
        if (uVar38 == (int)cVar16 + uVar36 >> 0xb) {
                    // WARNING: Subroutine does not return
          memcpy(*(long long *)(puVar42 + (ulong long)uVar38 * 2 + 2) +
                 (ulong long)(uVar36 + uVar38 * -0x800) * 4,puVar46,(uVar40 & 0xffffffff) << 2);
        }
        if (iVar43 != 0) {
          uVar40 = uVar40 & 0xffffffff;
          do {
            uVar32 = *puVar46;
            puVar46 = puVar46 + 1;
            *(uint32_t *)
             (*(long long *)(puVar42 + (ulong long)(uVar36 >> 0xb) * 2 + 2) +
             (ulong long)(uVar36 + (uVar36 >> 0xb) * -0x800) * 4) = uVar32;
            uVar40 = uVar40 - 1;
            uVar36 = uVar36 + 1;
          } while (uVar40 != 0);
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800792ea(void)
void FUN_1800792ea(void)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  void* *puVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  char cVar14;
  float *pfVar15;
  long long lVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  void* uVar29;
  uint32_t uVar30;
  long long lVar31;
  long long *plVar32;
  uint uVar33;
  int iVar34;
  uint uVar35;
  int iVar36;
  long long unaff_RBX;
  ulong long uVar37;
  char *pcVar38;
  uint *puVar39;
  int iVar40;
  long long unaff_RDI;
  int iVar41;
  int iVar42;
  long long lVar43;
  uint32_t *puVar44;
  uint *puVar45;
  ulong long uVar46;
  ulong long uVar47;
  bool bVar48;
  uint32_t unaff_XMM7_Da;
  uint32_t unaff_XMM7_Db;
  void* uStack0000000000000050;
  void* in_stack_00000058;
  
  uVar35 = (int)*(char *)(unaff_RDI + 0xd) + *(int *)(unaff_RDI + 0x18);
  pfVar15 = (float *)**(long long **)(unaff_RBX + 600);
  lVar43 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
  uVar33 = uVar35 >> 0xd;
  lVar16 = *(long long *)(lVar43 + 8 + (ulong long)uVar33 * 8);
  lVar31 = (ulong long)(uVar35 + uVar33 * -0x2000) * 0x40;
  uVar29 = ((void* *)(lVar16 + lVar31))[1];
  *(void* *)pfVar15 = *(void* *)(lVar16 + lVar31);
  *(void* *)(pfVar15 + 2) = uVar29;
  puVar4 = (void* *)(lVar16 + 0x10 + lVar31);
  uVar29 = puVar4[1];
  *(void* *)(pfVar15 + 4) = *puVar4;
  *(void* *)(pfVar15 + 6) = uVar29;
  puVar4 = (void* *)(lVar16 + 0x20 + lVar31);
  uVar29 = puVar4[1];
  *(void* *)(pfVar15 + 8) = *puVar4;
  *(void* *)(pfVar15 + 10) = uVar29;
  puVar4 = (void* *)(lVar16 + 0x30 + lVar31);
  uVar29 = puVar4[1];
  *(void* *)(pfVar15 + 0xc) = *puVar4;
  *(void* *)(pfVar15 + 0xe) = uVar29;
  lVar16 = *(long long *)(unaff_RDI + 0x10);
  fVar17 = pfVar15[8];
  fVar18 = pfVar15[9];
  fVar19 = pfVar15[10];
  fVar20 = pfVar15[0xb];
  fVar21 = *pfVar15;
  fVar22 = pfVar15[1];
  fVar23 = pfVar15[2];
  fVar24 = pfVar15[3];
  fVar25 = pfVar15[4];
  fVar26 = pfVar15[5];
  fVar27 = pfVar15[6];
  fVar28 = pfVar15[7];
  fVar5 = *(float *)(lVar16 + 0x374);
  fVar6 = *(float *)(lVar16 + 0x370);
  fVar7 = *(float *)(lVar16 + 0x378);
  fVar8 = *(float *)(lVar16 + 900);
  fVar9 = *(float *)(lVar16 + 0x394);
  fVar10 = *(float *)(lVar16 + 0x380);
  fVar11 = *(float *)(lVar16 + 0x388);
  fVar12 = *(float *)(lVar16 + 0x390);
  fVar13 = *(float *)(lVar16 + 0x398);
  *pfVar15 = fVar5 * fVar25 + fVar6 * fVar21 + fVar7 * fVar17;
  pfVar15[1] = fVar5 * fVar26 + fVar6 * fVar22 + fVar7 * fVar18;
  pfVar15[2] = fVar5 * fVar27 + fVar6 * fVar23 + fVar7 * fVar19;
  pfVar15[3] = fVar5 * fVar28 + fVar6 * fVar24 + fVar7 * fVar20;
  pfVar15[4] = fVar8 * fVar25 + fVar10 * fVar21 + fVar11 * fVar17;
  pfVar15[5] = fVar8 * fVar26 + fVar10 * fVar22 + fVar11 * fVar18;
  pfVar15[6] = fVar8 * fVar27 + fVar10 * fVar23 + fVar11 * fVar19;
  pfVar15[7] = fVar8 * fVar28 + fVar10 * fVar24 + fVar11 * fVar20;
  pfVar15[8] = fVar9 * fVar25 + fVar12 * fVar21 + fVar13 * fVar17;
  pfVar15[9] = fVar9 * fVar26 + fVar12 * fVar22 + fVar13 * fVar18;
  pfVar15[10] = fVar9 * fVar27 + fVar12 * fVar23 + fVar13 * fVar19;
  pfVar15[0xb] = fVar9 * fVar28 + fVar12 * fVar24 + fVar13 * fVar20;
  lVar16 = *(long long *)(unaff_RBX + 600);
  if (*(int *)(lVar16 + 0x28) != *(int *)(_DAT_180c86870 + 0x224)) {
    iVar40 = *(int *)(lVar16 + 0x1c) + *(int *)(lVar16 + 0x18);
    *(int *)(lVar16 + 0x28) = *(int *)(_DAT_180c86870 + 0x224);
    if (0 < iVar40) {
      uStack0000000000000050 = in_stack_00000058;
      lVar31 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
      uVar30 = FUN_180080380(lVar31,iVar40,lVar43,pfVar15,CONCAT44(unaff_XMM7_Db,unaff_XMM7_Da));
      *(uint32_t *)(lVar16 + 0x30) = uVar30;
      FUN_1800802e0(lVar31,uVar30);
      if (*(long long *)(lVar16 + 0x10) == 0) {
        if (*(int *)(lVar16 + 0x18) != 0) {
          *(uint32_t *)(lVar16 + 0x2c) = *(uint32_t *)(lVar16 + 0x30);
          return;
        }
      }
      else {
        cVar14 = *(char *)(lVar16 + 0x44);
        uVar37 = (ulong long)cVar14;
        plVar1 = (long long *)(lVar16 + 0x38);
        iVar40 = (int)cVar14;
        if (*(int *)(lVar16 + 0x40) == (int)cVar14) {
          plVar32 = (long long *)*plVar1;
        }
        else {
          *(int *)(lVar16 + 0x40) = iVar40;
          if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          *plVar1 = 0;
          if (cVar14 == '\0') {
            plVar32 = (long long *)0x0;
            *plVar1 = 0;
          }
          else {
            plVar32 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar14 * 4);
            *plVar1 = (long long)plVar32;
          }
        }
        if (plVar32 != (long long *)0x0) {
          iVar41 = 0;
          uVar33 = (uint)cVar14;
          iVar42 = iVar41;
          if ((0 < iVar40) && (0xf < uVar33)) {
            iVar36 = *(int *)(lVar16 + 0x2c);
            plVar2 = (long long *)((long long)plVar32 + (long long)(cVar14 + -1) * 4);
            if ((((long long *)(lVar16 + 0x2c) < plVar32) || (plVar2 < (long long *)(lVar16 + 0x2c)))
               && ((plVar1 < plVar32 || (iVar42 = 0, plVar2 < plVar1)))) {
              uVar35 = uVar33 & 0x8000000f;
              if ((int)uVar35 < 0) {
                uVar35 = (uVar35 - 1 | 0xfffffff0) + 1;
              }
              plVar32 = plVar32 + 4;
              iVar34 = 8;
              do {
                *(int *)(plVar32 + -4) = iVar41 + iVar36;
                *(int *)((long long)plVar32 + -0x1c) = iVar41 + 1 + iVar36;
                *(int *)(plVar32 + -3) = iVar41 + 2 + iVar36;
                *(int *)((long long)plVar32 + -0x14) = iVar41 + 3 + iVar36;
                iVar41 = iVar41 + 0x10;
                *(int *)(plVar32 + -2) = iVar34 + -4 + iVar36;
                *(int *)((long long)plVar32 + -0xc) = iVar34 + -3 + iVar36;
                *(int *)(plVar32 + -1) = iVar34 + -2 + iVar36;
                *(int *)((long long)plVar32 + -4) = iVar34 + -1 + iVar36;
                *(int *)plVar32 = iVar34 + iVar36;
                *(int *)((long long)plVar32 + 4) = iVar34 + 1 + iVar36;
                *(int *)(plVar32 + 1) = iVar34 + 2 + iVar36;
                *(int *)((long long)plVar32 + 0xc) = iVar34 + 3 + iVar36;
                *(int *)(plVar32 + 2) = iVar34 + 4 + iVar36;
                *(int *)((long long)plVar32 + 0x14) = iVar34 + 5 + iVar36;
                *(int *)(plVar32 + 3) = iVar34 + 6 + iVar36;
                *(int *)((long long)plVar32 + 0x1c) = iVar34 + 7 + iVar36;
                plVar32 = plVar32 + 8;
                iVar34 = iVar34 + 0x10;
                iVar42 = iVar41;
              } while (iVar41 < (int)(uVar33 - uVar35));
            }
          }
          for (lVar31 = (long long)iVar42; lVar31 < (long long)uVar37; lVar31 = lVar31 + 1) {
            iVar41 = *(int *)(lVar16 + 0x2c) + iVar42;
            iVar42 = iVar42 + 1;
            *(int *)(*plVar1 + lVar31 * 4) = iVar41;
          }
          iVar42 = *(int *)(lVar16 + 0x18);
          iVar41 = 0;
          if (0 < (long long)iVar42) {
            lVar31 = 0;
            do {
              iVar36 = *(int *)(lVar16 + 0x30) + iVar41;
              iVar41 = iVar41 + 1;
              pbVar3 = (byte *)(*(long long *)(lVar16 + 0x10) + lVar31);
              lVar31 = lVar31 + 1;
              *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar36;
            } while (lVar31 < iVar42);
          }
        }
        puVar39 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 +
                          _DAT_180c86890 + 0x9d0);
        if (iVar40 == 0) {
          uVar33 = (int)cVar14 - 1;
        }
        else {
          LOCK();
          uVar33 = *puVar39;
          *puVar39 = *puVar39 + (int)cVar14;
          UNLOCK();
          uVar46 = (ulong long)(uVar33 >> 0xb);
          uVar47 = (ulong long)(cVar14 + -1 + uVar33 >> 0xb);
          if (uVar46 <= uVar47) {
            pcVar38 = (char *)((long long)puVar39 + uVar46 + 0x108);
            lVar31 = (uVar47 - uVar46) + 1;
            puVar45 = puVar39 + uVar46 * 2 + 2;
            do {
              iVar42 = (int)uVar46;
              if (*(long long *)puVar45 == 0) {
                lVar43 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
                LOCK();
                bVar48 = *(long long *)(puVar39 + (long long)iVar42 * 2 + 2) == 0;
                if (bVar48) {
                  *(long long *)(puVar39 + (long long)iVar42 * 2 + 2) = lVar43;
                }
                UNLOCK();
                if (bVar48) {
                  LOCK();
                  *(uint8_t *)((long long)iVar42 + 0x108 + (long long)puVar39) = 0;
                  UNLOCK();
                }
                else {
                  if (lVar43 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                  } while (*pcVar38 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar38 != '\0');
              }
              uVar46 = (ulong long)(iVar42 + 1);
              puVar45 = puVar45 + 2;
              pcVar38 = pcVar38 + 1;
              lVar31 = lVar31 + -1;
            } while (lVar31 != 0);
          }
        }
        puVar44 = *(uint32_t **)(lVar16 + 0x38);
        uVar35 = uVar33 >> 0xb;
        *(uint *)(lVar16 + 0x2c) = uVar33;
        if (uVar35 == (int)cVar14 + uVar33 >> 0xb) {
                    // WARNING: Subroutine does not return
          memcpy(*(long long *)(puVar39 + (ulong long)uVar35 * 2 + 2) +
                 (ulong long)(uVar33 + uVar35 * -0x800) * 4,puVar44,(uVar37 & 0xffffffff) << 2);
        }
        if (iVar40 != 0) {
          uVar37 = uVar37 & 0xffffffff;
          do {
            uVar30 = *puVar44;
            puVar44 = puVar44 + 1;
            *(uint32_t *)
             (*(long long *)(puVar39 + (ulong long)(uVar33 >> 0xb) * 2 + 2) +
             (ulong long)(uVar33 + (uVar33 >> 0xb) * -0x800) * 4) = uVar30;
            uVar37 = uVar37 - 1;
            uVar33 = uVar33 + 1;
          } while (uVar37 != 0);
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_180079309(long long param_1,uint param_2,void* param_3,float *param_4)
void FUN_180079309(long long param_1,uint param_2,void* param_3,float *param_4)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  void* *puVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float fVar9;
  float fVar10;
  float fVar11;
  float fVar12;
  float fVar13;
  char cVar14;
  long long lVar15;
  float fVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  float fVar22;
  float fVar23;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  void* uVar28;
  uint32_t uVar29;
  uint uVar30;
  long long lVar31;
  long long *plVar32;
  long long lVar33;
  int iVar34;
  int iVar35;
  long long unaff_RBX;
  ulong long uVar36;
  char *pcVar37;
  uint *puVar38;
  int iVar39;
  uint uVar40;
  long long unaff_RDI;
  int iVar41;
  int iVar42;
  uint32_t *puVar43;
  uint *puVar44;
  ulong long uVar45;
  ulong long uVar46;
  bool bVar47;
  uint32_t unaff_XMM7_Da;
  uint32_t unaff_XMM7_Db;
  void* uStack0000000000000050;
  void* in_stack_00000058;
  
  param_1 = (long long)*(int *)(param_1 + 0x250) * 0x128 + param_1;
  lVar15 = *(long long *)(param_1 + 8 + (ulong long)(param_2 >> 0xd) * 8);
  lVar31 = (ulong long)(param_2 + (param_2 >> 0xd) * -0x2000) * 0x40;
  uVar28 = ((void* *)(lVar15 + lVar31))[1];
  *(void* *)param_4 = *(void* *)(lVar15 + lVar31);
  *(void* *)(param_4 + 2) = uVar28;
  puVar4 = (void* *)(lVar15 + 0x10 + lVar31);
  uVar28 = puVar4[1];
  *(void* *)(param_4 + 4) = *puVar4;
  *(void* *)(param_4 + 6) = uVar28;
  puVar4 = (void* *)(lVar15 + 0x20 + lVar31);
  uVar28 = puVar4[1];
  *(void* *)(param_4 + 8) = *puVar4;
  *(void* *)(param_4 + 10) = uVar28;
  puVar4 = (void* *)(lVar15 + 0x30 + lVar31);
  uVar28 = puVar4[1];
  *(void* *)(param_4 + 0xc) = *puVar4;
  *(void* *)(param_4 + 0xe) = uVar28;
  lVar15 = *(long long *)(unaff_RDI + 0x10);
  fVar16 = param_4[8];
  fVar17 = param_4[9];
  fVar18 = param_4[10];
  fVar19 = param_4[0xb];
  fVar20 = *param_4;
  fVar21 = param_4[1];
  fVar22 = param_4[2];
  fVar23 = param_4[3];
  fVar24 = param_4[4];
  fVar25 = param_4[5];
  fVar26 = param_4[6];
  fVar27 = param_4[7];
  fVar5 = *(float *)(lVar15 + 0x374);
  fVar6 = *(float *)(lVar15 + 0x370);
  fVar7 = *(float *)(lVar15 + 0x378);
  fVar8 = *(float *)(lVar15 + 900);
  fVar9 = *(float *)(lVar15 + 0x394);
  fVar10 = *(float *)(lVar15 + 0x380);
  fVar11 = *(float *)(lVar15 + 0x388);
  fVar12 = *(float *)(lVar15 + 0x390);
  fVar13 = *(float *)(lVar15 + 0x398);
  *param_4 = fVar5 * fVar24 + fVar6 * fVar20 + fVar7 * fVar16;
  param_4[1] = fVar5 * fVar25 + fVar6 * fVar21 + fVar7 * fVar17;
  param_4[2] = fVar5 * fVar26 + fVar6 * fVar22 + fVar7 * fVar18;
  param_4[3] = fVar5 * fVar27 + fVar6 * fVar23 + fVar7 * fVar19;
  param_4[4] = fVar8 * fVar24 + fVar10 * fVar20 + fVar11 * fVar16;
  param_4[5] = fVar8 * fVar25 + fVar10 * fVar21 + fVar11 * fVar17;
  param_4[6] = fVar8 * fVar26 + fVar10 * fVar22 + fVar11 * fVar18;
  param_4[7] = fVar8 * fVar27 + fVar10 * fVar23 + fVar11 * fVar19;
  param_4[8] = fVar9 * fVar24 + fVar12 * fVar20 + fVar13 * fVar16;
  param_4[9] = fVar9 * fVar25 + fVar12 * fVar21 + fVar13 * fVar17;
  param_4[10] = fVar9 * fVar26 + fVar12 * fVar22 + fVar13 * fVar18;
  param_4[0xb] = fVar9 * fVar27 + fVar12 * fVar23 + fVar13 * fVar19;
  lVar15 = *(long long *)(unaff_RBX + 600);
  if (*(int *)(lVar15 + 0x28) != *(int *)(_DAT_180c86870 + 0x224)) {
    iVar39 = *(int *)(lVar15 + 0x1c) + *(int *)(lVar15 + 0x18);
    *(int *)(lVar15 + 0x28) = *(int *)(_DAT_180c86870 + 0x224);
    if (0 < iVar39) {
      uStack0000000000000050 = in_stack_00000058;
      lVar31 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
      uVar29 = FUN_180080380(lVar31,iVar39,param_1,param_4,CONCAT44(unaff_XMM7_Db,unaff_XMM7_Da));
      *(uint32_t *)(lVar15 + 0x30) = uVar29;
      FUN_1800802e0(lVar31,uVar29);
      if (*(long long *)(lVar15 + 0x10) == 0) {
        if (*(int *)(lVar15 + 0x18) != 0) {
          *(uint32_t *)(lVar15 + 0x2c) = *(uint32_t *)(lVar15 + 0x30);
          return;
        }
      }
      else {
        cVar14 = *(char *)(lVar15 + 0x44);
        uVar36 = (ulong long)cVar14;
        plVar1 = (long long *)(lVar15 + 0x38);
        iVar39 = (int)cVar14;
        if (*(int *)(lVar15 + 0x40) == (int)cVar14) {
          plVar32 = (long long *)*plVar1;
        }
        else {
          *(int *)(lVar15 + 0x40) = iVar39;
          if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          *plVar1 = 0;
          if (cVar14 == '\0') {
            plVar32 = (long long *)0x0;
            *plVar1 = 0;
          }
          else {
            plVar32 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar14 * 4);
            *plVar1 = (long long)plVar32;
          }
        }
        if (plVar32 != (long long *)0x0) {
          iVar41 = 0;
          uVar40 = (uint)cVar14;
          iVar42 = iVar41;
          if ((0 < iVar39) && (0xf < uVar40)) {
            iVar35 = *(int *)(lVar15 + 0x2c);
            plVar2 = (long long *)((long long)plVar32 + (long long)(cVar14 + -1) * 4);
            if ((((long long *)(lVar15 + 0x2c) < plVar32) || (plVar2 < (long long *)(lVar15 + 0x2c)))
               && ((plVar1 < plVar32 || (iVar42 = 0, plVar2 < plVar1)))) {
              uVar30 = uVar40 & 0x8000000f;
              if ((int)uVar30 < 0) {
                uVar30 = (uVar30 - 1 | 0xfffffff0) + 1;
              }
              plVar32 = plVar32 + 4;
              iVar34 = 8;
              do {
                *(int *)(plVar32 + -4) = iVar41 + iVar35;
                *(int *)((long long)plVar32 + -0x1c) = iVar41 + 1 + iVar35;
                *(int *)(plVar32 + -3) = iVar41 + 2 + iVar35;
                *(int *)((long long)plVar32 + -0x14) = iVar41 + 3 + iVar35;
                iVar41 = iVar41 + 0x10;
                *(int *)(plVar32 + -2) = iVar34 + -4 + iVar35;
                *(int *)((long long)plVar32 + -0xc) = iVar34 + -3 + iVar35;
                *(int *)(plVar32 + -1) = iVar34 + -2 + iVar35;
                *(int *)((long long)plVar32 + -4) = iVar34 + -1 + iVar35;
                *(int *)plVar32 = iVar34 + iVar35;
                *(int *)((long long)plVar32 + 4) = iVar34 + 1 + iVar35;
                *(int *)(plVar32 + 1) = iVar34 + 2 + iVar35;
                *(int *)((long long)plVar32 + 0xc) = iVar34 + 3 + iVar35;
                *(int *)(plVar32 + 2) = iVar34 + 4 + iVar35;
                *(int *)((long long)plVar32 + 0x14) = iVar34 + 5 + iVar35;
                *(int *)(plVar32 + 3) = iVar34 + 6 + iVar35;
                *(int *)((long long)plVar32 + 0x1c) = iVar34 + 7 + iVar35;
                plVar32 = plVar32 + 8;
                iVar34 = iVar34 + 0x10;
                iVar42 = iVar41;
              } while (iVar41 < (int)(uVar40 - uVar30));
            }
          }
          for (lVar31 = (long long)iVar42; lVar31 < (long long)uVar36; lVar31 = lVar31 + 1) {
            iVar41 = *(int *)(lVar15 + 0x2c) + iVar42;
            iVar42 = iVar42 + 1;
            *(int *)(*plVar1 + lVar31 * 4) = iVar41;
          }
          iVar42 = *(int *)(lVar15 + 0x18);
          iVar41 = 0;
          if (0 < (long long)iVar42) {
            lVar31 = 0;
            do {
              iVar35 = *(int *)(lVar15 + 0x30) + iVar41;
              iVar41 = iVar41 + 1;
              pbVar3 = (byte *)(*(long long *)(lVar15 + 0x10) + lVar31);
              lVar31 = lVar31 + 1;
              *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar35;
            } while (lVar31 < iVar42);
          }
        }
        puVar38 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 +
                          _DAT_180c86890 + 0x9d0);
        if (iVar39 == 0) {
          uVar40 = (int)cVar14 - 1;
        }
        else {
          LOCK();
          uVar40 = *puVar38;
          *puVar38 = *puVar38 + (int)cVar14;
          UNLOCK();
          uVar45 = (ulong long)(uVar40 >> 0xb);
          uVar46 = (ulong long)(cVar14 + -1 + uVar40 >> 0xb);
          if (uVar45 <= uVar46) {
            pcVar37 = (char *)((long long)puVar38 + uVar45 + 0x108);
            lVar31 = (uVar46 - uVar45) + 1;
            puVar44 = puVar38 + uVar45 * 2 + 2;
            do {
              iVar42 = (int)uVar45;
              if (*(long long *)puVar44 == 0) {
                lVar33 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
                LOCK();
                bVar47 = *(long long *)(puVar38 + (long long)iVar42 * 2 + 2) == 0;
                if (bVar47) {
                  *(long long *)(puVar38 + (long long)iVar42 * 2 + 2) = lVar33;
                }
                UNLOCK();
                if (bVar47) {
                  LOCK();
                  *(uint8_t *)((long long)iVar42 + 0x108 + (long long)puVar38) = 0;
                  UNLOCK();
                }
                else {
                  if (lVar33 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                  } while (*pcVar37 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar37 != '\0');
              }
              uVar45 = (ulong long)(iVar42 + 1);
              puVar44 = puVar44 + 2;
              pcVar37 = pcVar37 + 1;
              lVar31 = lVar31 + -1;
            } while (lVar31 != 0);
          }
        }
        puVar43 = *(uint32_t **)(lVar15 + 0x38);
        uVar30 = uVar40 >> 0xb;
        *(uint *)(lVar15 + 0x2c) = uVar40;
        if (uVar30 == (int)cVar14 + uVar40 >> 0xb) {
                    // WARNING: Subroutine does not return
          memcpy(*(long long *)(puVar38 + (ulong long)uVar30 * 2 + 2) +
                 (ulong long)(uVar40 + uVar30 * -0x800) * 4,puVar43,(uVar36 & 0xffffffff) << 2);
        }
        if (iVar39 != 0) {
          uVar36 = uVar36 & 0xffffffff;
          do {
            uVar29 = *puVar43;
            puVar43 = puVar43 + 1;
            *(uint32_t *)
             (*(long long *)(puVar38 + (ulong long)(uVar40 >> 0xb) * 2 + 2) +
             (ulong long)(uVar40 + (uVar40 >> 0xb) * -0x800) * 4) = uVar29;
            uVar36 = uVar36 - 1;
            uVar40 = uVar40 + 1;
          } while (uVar36 != 0);
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007940e(void)
void FUN_18007940e(void)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  char cVar4;
  long long systemTimeValue;
  uint32_t uVar6;
  uint uVar7;
  long long *plVar8;
  long long lVar9;
  int iVar10;
  int iVar11;
  long long unaff_RBX;
  long long lVar12;
  ulong long uVar13;
  char *pcVar14;
  uint *puVar15;
  int iVar16;
  uint uVar17;
  int iVar18;
  int iVar19;
  uint32_t *puVar20;
  uint *puVar21;
  ulong long uVar22;
  ulong long uVar23;
  bool bVar24;
  void* uStack0000000000000050;
  void* in_stack_00000058;
  
  lVar5 = *(long long *)(unaff_RBX + 600);
  if (*(int *)(lVar5 + 0x28) != *(int *)(_DAT_180c86870 + 0x224)) {
    iVar16 = *(int *)(lVar5 + 0x1c) + *(int *)(lVar5 + 0x18);
    *(int *)(lVar5 + 0x28) = *(int *)(_DAT_180c86870 + 0x224);
    if (0 < iVar16) {
      uStack0000000000000050 = in_stack_00000058;
      lVar12 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
      uVar6 = FUN_180080380(lVar12,iVar16);
      *(uint32_t *)(lVar5 + 0x30) = uVar6;
      FUN_1800802e0(lVar12,uVar6);
      if (*(long long *)(lVar5 + 0x10) == 0) {
        if (*(int *)(lVar5 + 0x18) != 0) {
          *(uint32_t *)(lVar5 + 0x2c) = *(uint32_t *)(lVar5 + 0x30);
          return;
        }
      }
      else {
        cVar4 = *(char *)(lVar5 + 0x44);
        uVar13 = (ulong long)cVar4;
        plVar1 = (long long *)(lVar5 + 0x38);
        iVar16 = (int)cVar4;
        if (*(int *)(lVar5 + 0x40) == (int)cVar4) {
          plVar8 = (long long *)*plVar1;
        }
        else {
          *(int *)(lVar5 + 0x40) = iVar16;
          if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          *plVar1 = 0;
          if (cVar4 == '\0') {
            plVar8 = (long long *)0x0;
            *plVar1 = 0;
          }
          else {
            plVar8 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar4 * 4);
            *plVar1 = (long long)plVar8;
          }
        }
        if (plVar8 != (long long *)0x0) {
          iVar18 = 0;
          uVar17 = (uint)cVar4;
          iVar19 = iVar18;
          if ((0 < iVar16) && (0xf < uVar17)) {
            iVar11 = *(int *)(lVar5 + 0x2c);
            plVar2 = (long long *)((long long)plVar8 + (long long)(cVar4 + -1) * 4);
            if ((((long long *)(lVar5 + 0x2c) < plVar8) || (plVar2 < (long long *)(lVar5 + 0x2c))) &&
               ((plVar1 < plVar8 || (iVar19 = 0, plVar2 < plVar1)))) {
              uVar7 = uVar17 & 0x8000000f;
              if ((int)uVar7 < 0) {
                uVar7 = (uVar7 - 1 | 0xfffffff0) + 1;
              }
              plVar8 = plVar8 + 4;
              iVar10 = 8;
              do {
                *(int *)(plVar8 + -4) = iVar18 + iVar11;
                *(int *)((long long)plVar8 + -0x1c) = iVar18 + 1 + iVar11;
                *(int *)(plVar8 + -3) = iVar18 + 2 + iVar11;
                *(int *)((long long)plVar8 + -0x14) = iVar18 + 3 + iVar11;
                iVar18 = iVar18 + 0x10;
                *(int *)(plVar8 + -2) = iVar10 + -4 + iVar11;
                *(int *)((long long)plVar8 + -0xc) = iVar10 + -3 + iVar11;
                *(int *)(plVar8 + -1) = iVar10 + -2 + iVar11;
                *(int *)((long long)plVar8 + -4) = iVar10 + -1 + iVar11;
                *(int *)plVar8 = iVar10 + iVar11;
                *(int *)((long long)plVar8 + 4) = iVar10 + 1 + iVar11;
                *(int *)(plVar8 + 1) = iVar10 + 2 + iVar11;
                *(int *)((long long)plVar8 + 0xc) = iVar10 + 3 + iVar11;
                *(int *)(plVar8 + 2) = iVar10 + 4 + iVar11;
                *(int *)((long long)plVar8 + 0x14) = iVar10 + 5 + iVar11;
                *(int *)(plVar8 + 3) = iVar10 + 6 + iVar11;
                *(int *)((long long)plVar8 + 0x1c) = iVar10 + 7 + iVar11;
                plVar8 = plVar8 + 8;
                iVar10 = iVar10 + 0x10;
                iVar19 = iVar18;
              } while (iVar18 < (int)(uVar17 - uVar7));
            }
          }
          for (lVar12 = (long long)iVar19; lVar12 < (long long)uVar13; lVar12 = lVar12 + 1) {
            iVar18 = *(int *)(lVar5 + 0x2c) + iVar19;
            iVar19 = iVar19 + 1;
            *(int *)(*plVar1 + lVar12 * 4) = iVar18;
          }
          iVar19 = *(int *)(lVar5 + 0x18);
          iVar18 = 0;
          if (0 < (long long)iVar19) {
            lVar12 = 0;
            do {
              iVar11 = *(int *)(lVar5 + 0x30) + iVar18;
              iVar18 = iVar18 + 1;
              pbVar3 = (byte *)(*(long long *)(lVar5 + 0x10) + lVar12);
              lVar12 = lVar12 + 1;
              *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar11;
            } while (lVar12 < iVar19);
          }
        }
        puVar15 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 +
                          _DAT_180c86890 + 0x9d0);
        if (iVar16 == 0) {
          uVar17 = (int)cVar4 - 1;
        }
        else {
          LOCK();
          uVar17 = *puVar15;
          *puVar15 = *puVar15 + (int)cVar4;
          UNLOCK();
          uVar22 = (ulong long)(uVar17 >> 0xb);
          uVar23 = (ulong long)(cVar4 + -1 + uVar17 >> 0xb);
          if (uVar22 <= uVar23) {
            pcVar14 = (char *)((long long)puVar15 + uVar22 + 0x108);
            lVar12 = (uVar23 - uVar22) + 1;
            puVar21 = puVar15 + uVar22 * 2 + 2;
            do {
              iVar19 = (int)uVar22;
              if (*(long long *)puVar21 == 0) {
                lVar9 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
                LOCK();
                bVar24 = *(long long *)(puVar15 + (long long)iVar19 * 2 + 2) == 0;
                if (bVar24) {
                  *(long long *)(puVar15 + (long long)iVar19 * 2 + 2) = lVar9;
                }
                UNLOCK();
                if (bVar24) {
                  LOCK();
                  *(uint8_t *)((long long)iVar19 + 0x108 + (long long)puVar15) = 0;
                  UNLOCK();
                }
                else {
                  if (lVar9 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                  } while (*pcVar14 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar14 != '\0');
              }
              uVar22 = (ulong long)(iVar19 + 1);
              puVar21 = puVar21 + 2;
              pcVar14 = pcVar14 + 1;
              lVar12 = lVar12 + -1;
            } while (lVar12 != 0);
          }
        }
        puVar20 = *(uint32_t **)(lVar5 + 0x38);
        uVar7 = uVar17 >> 0xb;
        *(uint *)(lVar5 + 0x2c) = uVar17;
        if (uVar7 == (int)cVar4 + uVar17 >> 0xb) {
                    // WARNING: Subroutine does not return
          memcpy(*(long long *)(puVar15 + (ulong long)uVar7 * 2 + 2) +
                 (ulong long)(uVar17 + uVar7 * -0x800) * 4,puVar20,(uVar13 & 0xffffffff) << 2);
        }
        if (iVar16 != 0) {
          uVar13 = uVar13 & 0xffffffff;
          do {
            uVar6 = *puVar20;
            puVar20 = puVar20 + 1;
            *(uint32_t *)
             (*(long long *)(puVar15 + (ulong long)(uVar17 >> 0xb) * 2 + 2) +
             (ulong long)(uVar17 + (uVar17 >> 0xb) * -0x800) * 4) = uVar6;
            uVar13 = uVar13 - 1;
            uVar17 = uVar17 + 1;
          } while (uVar13 != 0);
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * FUN_180079430(long long param_1,void* param_2,void* param_3,void* param_4)

{
  void* uVar1;
  
  uVar1 = 0xfffffffffffffffe;
  if (*(long long *)(param_1 + 0x1b8) != 0) {
    return (undefined *)(*(long long *)(param_1 + 0x1b8) + 0x10);
  }
  if (*(int *)(*(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8) +
              0x48) < _DAT_180d49158) {
    FUN_1808fcb90(&DAT_180d49158);
    if (_DAT_180d49158 == -1) {
      _DAT_180d49160 = &UNK_1809fcc28;
      _DAT_180d49168 = &DAT_180d49178;

// 函数: void FUN_180079520(long long param_1)
void FUN_180079520(long long param_1)

{
  long long lVar1;
  int iVar2;
  long long lVar3;
  
  if (((*(byte *)(param_1 + 0xfd) & 0x20) != 0) && (*(long long *)(param_1 + 0x1e0) != 0)) {
    iVar2 = 0;
    lVar3 = 0;
    do {
      while ((*(char *)(*(long long *)(param_1 + 0x1e0) + 0x15 + lVar3) == '\x02' ||
             (*(char *)(*(long long *)(param_1 + 0x1e0) + 0x15 + lVar3) == '\x01'))) {
        Sleep(0);
      }
      lVar1 = (long long)iVar2;
      lVar3 = lVar3 + 0x18;
      iVar2 = iVar2 + 1;
      LOCK();
      *(uint8_t *)(*(long long *)(param_1 + 0x1e0) + lVar1 * 0x18 + 0x15) = 0;
      UNLOCK();
    } while (iVar2 < 0x10);
  }
  return;
}



uint8_t FUN_18007953e(void)

{
  uint8_t *puVar1;
  uint8_t uVar2;
  long long lVar3;
  long long unaff_RBX;
  int iVar4;
  long long systemTimeValue;
  
  iVar4 = 0;
  lVar5 = 0;
  do {
    while ((*(char *)(*(long long *)(unaff_RBX + 0x1e0) + 0x15 + lVar5) == '\x02' ||
           (*(char *)(*(long long *)(unaff_RBX + 0x1e0) + 0x15 + lVar5) == '\x01'))) {
      Sleep(0);
    }
    lVar3 = (long long)iVar4;
    lVar5 = lVar5 + 0x18;
    iVar4 = iVar4 + 1;
    LOCK();
    puVar1 = (uint8_t *)(*(long long *)(unaff_RBX + 0x1e0) + lVar3 * 0x18 + 0x15);
    uVar2 = *puVar1;
    *puVar1 = 0;
    UNLOCK();
  } while (iVar4 < 0x10);
  return uVar2;
}




// 函数: void FUN_18007959e(void)
void FUN_18007959e(void)

{
  return;
}



uint8_t FUN_1800795a4(void)

{
  uint8_t *puVar1;
  uint8_t uVar2;
  long long lVar3;
  long long unaff_RBX;
  int unaff_ESI;
  long long unaff_RDI;
  
  do {
    Sleep(0);
    while ((*(char *)(*(long long *)(unaff_RBX + 0x1e0) + 0x15 + unaff_RDI) != '\x02' &&
           (*(char *)(*(long long *)(unaff_RBX + 0x1e0) + 0x15 + unaff_RDI) != '\x01'))) {
      lVar3 = (long long)unaff_ESI;
      unaff_RDI = unaff_RDI + 0x18;
      unaff_ESI = unaff_ESI + 1;
      LOCK();
      puVar1 = (uint8_t *)(*(long long *)(unaff_RBX + 0x1e0) + lVar3 * 0x18 + 0x15);
      uVar2 = *puVar1;
      *puVar1 = 0;
      UNLOCK();
      if (0xf < unaff_ESI) {
        return uVar2;
      }
    }
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x000180079699)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float * FUN_1800795b0(float *param_1)

{
  float *pfVar1;
  byte bVar2;
  long long *plVar3;
  float *pfVar4;
  char cVar5;
  float fVar6;
  float *pfVar7;
  uint uVar8;
  ulong long uVar9;
  bool bVar10;
  float fVar11;
  float fStack_b8;
  float fStack_b4;
  float fStack_b0;
  uint32_t uStack_ac;
  float fStack_a8;
  float fStack_a4;
  float fStack_a0;
  uint32_t uStack_9c;
  float *pfStack_98;
  uint32_t stackParameterC;
  long long lStack_88;
  void* uStack_80;
  void* uStack_78;
  void* uStack_70;
  void* uStack_68;
  void* uStack_60;
  undefined *puStack_58;
  float fStack_50;
  float fStack_4c;
  undefined *puStack_48;
  void* uStack_40;
  void* uStack_38;
  uint8_t auStack_30 [8];
  float *pfStack_28;
  uint32_t uStack_20;
  
  uStack_38 = 0xfffffffffffffffe;
  if (((uint)param_1[0x40] & 0x10000) == 0) {
    auStack_30[0] = 0;
    uStack_20 = 0;
    uStack_80 = 0x1800795fa;
    pfStack_28 = param_1;
    FUN_18007f4c0(auStack_30);
    uStack_80 = 0x180079605;
    fVar6 = (float)FUN_1802349a0(0);
    if ((10 < (int)fVar6) ||
       ((int)(*(int *)(*(long long *)(param_1 + 0x84) + 0x88) +
             (*(int *)(*(long long *)(param_1 + 0x84) + 0x88) >> 0x1f & 3U)) >> 2 < (int)fVar6)) {
      puStack_48 = &SystemStringTemplate;
      if (*(undefined **)(param_1 + 6) != (undefined *)0x0) {
        puStack_48 = *(undefined **)(param_1 + 6);
      }
      uStack_40 = CONCAT44(uStack_40._4_4_,*(uint32_t *)(*(long long *)(param_1 + 0x84) + 0x60));
      puStack_58 = &UNK_1809ffb30;
      uStack_80 = 0x18007967a;
      fStack_50 = fVar6;
      FUN_1800623b0(_DAT_180c86928,0,0x80000000000,3);
    }
    param_1[0x40] = (float)((uint)param_1[0x40] | 0x10000);
    uStack_80 = 0x18007968e;
    FUN_18007f6a0(auStack_30);
  }
  uStack_38 = 0xfffffffffffffffe;
  pfVar7 = param_1;
  if ((*(byte *)((long long)param_1 + 0xfd) & 0x20) == 0) {
    pfVar7 = (float *)func_0x000180085de0(*(void* *)(param_1 + 0x6c));
  }
  if ((*(long long *)(pfVar7 + 0x84) != 0) && (((uint)param_1[0x40] & 0x80) == 0)) {
    pfVar1 = param_1 + 0x9d;
    pfVar1[0] = 1e+08;
    pfVar1[1] = 1e+08;
    param_1[0x9f] = 1e+08;
    param_1[0xa0] = 3.4028235e+38;
    param_1[0xa1] = -1e+08;
    param_1[0xa2] = -1e+08;
    param_1[0xa3] = -1e+08;
    param_1[0xa4] = 3.4028235e+38;
    uVar8 = 0;
    param_1[0xa9] = 0.0;
    param_1[0xa5] = 0.0;
    param_1[0xa6] = 0.0;
    param_1[0xa7] = 0.0;
    param_1[0xa8] = 3.4028235e+38;
    stackParameterC = 0;
    pfStack_98 = pfVar7;
    FUN_18007f770(&pfStack_98);
    if (*(int *)(lStack_88 + 0x10) != 0) {
      do {
        pfVar7 = (float *)((long long)(int)uVar8 * 0x10 + *(long long *)(lStack_88 + 0x18));
        fStack_a8 = *pfVar7;
        if (*pfVar1 < fStack_a8) {
          fStack_a8 = *pfVar1;
        }
        fStack_a4 = pfVar7[1];
        if (param_1[0x9e] < fStack_a4) {
          fStack_a4 = param_1[0x9e];
        }
        fStack_a0 = pfVar7[2];
        if (param_1[0x9f] < fStack_a0) {
          fStack_a0 = param_1[0x9f];
        }
        *(ulong long *)pfVar1 = CONCAT44(fStack_a4,fStack_a8);
        *(ulong long *)(param_1 + 0x9f) = CONCAT44(uStack_9c,fStack_a0);
        fStack_b8 = *pfVar7;
        if (fStack_b8 < param_1[0xa1]) {
          fStack_b8 = param_1[0xa1];
        }
        fStack_b4 = pfVar7[1];
        if (fStack_b4 < param_1[0xa2]) {
          fStack_b4 = param_1[0xa2];
        }
        fStack_b0 = pfVar7[2];
        if (fStack_b0 < param_1[0xa3]) {
          fStack_b0 = param_1[0xa3];
        }
        *(ulong long *)(param_1 + 0xa1) = CONCAT44(fStack_b4,fStack_b8);
        *(ulong long *)(param_1 + 0xa3) = CONCAT44(uStack_ac,fStack_b0);
        uVar8 = uVar8 + 1;
      } while (uVar8 < *(uint *)(lStack_88 + 0x10));
    }
    pfVar7 = *(float **)(param_1 + 0x6e);
    if ((pfVar7 != (float *)0x0) && (((uint)pfVar7[0x4e] & 0x3000) != 0)) {
      uStack_78 = *(void* *)(param_1 + 0x48);
      uStack_70 = *(void* *)(param_1 + 0x4a);
      uStack_68 = *(void* *)(param_1 + 0x4c);
      uStack_60 = *(void* *)(param_1 + 0x4e);
      puStack_58 = *(undefined **)(param_1 + 0x50);
      fStack_50 = param_1[0x52];
      fStack_4c = param_1[0x53];
      puStack_48 = *(undefined **)(param_1 + 0x54);
      uStack_40 = *(void* *)(param_1 + 0x56);
      FUN_180085c10(&uStack_78);
      FUN_18063a240(pfVar1,pfVar1,&uStack_78);
      pfVar7 = *(float **)(param_1 + 0x6e);
      if (((uint)pfVar7[0x4e] & 0x3000) == 0x2000) {
        uStack_78 = *(void* *)(param_1 + 0x48);
        uStack_70 = *(void* *)(param_1 + 0x4a);
        uStack_68 = *(void* *)(param_1 + 0x4c);
        uStack_60 = *(void* *)(param_1 + 0x4e);
        puStack_58 = *(undefined **)(param_1 + 0x50);
        fStack_50 = param_1[0x52];
        fStack_4c = param_1[0x53];
        puStack_48 = *(undefined **)(param_1 + 0x54);
        uStack_40 = *(void* *)(param_1 + 0x56);
        FUN_180085ac0(&uStack_78,0x3fc90fdb);
        FUN_18063a240(pfVar1,pfVar1,&uStack_78);
        uStack_78 = *(void* *)(param_1 + 0x48);
        uStack_70 = *(void* *)(param_1 + 0x4a);
        uStack_68 = *(void* *)(param_1 + 0x4c);
        uStack_60 = *(void* *)(param_1 + 0x4e);
        puStack_58 = *(undefined **)(param_1 + 0x50);
        fStack_50 = param_1[0x52];
        fStack_4c = param_1[0x53];
        puStack_48 = *(undefined **)(param_1 + 0x54);
        uStack_40 = *(void* *)(param_1 + 0x56);
        FUN_180085970(&uStack_78);
        pfVar7 = (float *)FUN_18063a240(pfVar1,pfVar1,&uStack_78);
      }
    }
    pfVar4 = pfStack_98;
    if (param_1[0xa1] < *pfVar1) {
      param_1[0xa9] = 0.0;
      pfVar1[0] = 0.0;
      pfVar1[1] = 0.0;
      param_1[0x9f] = 0.0;
      param_1[0xa0] = 0.0;
      param_1[0xa1] = 0.0;
      param_1[0xa2] = 0.0;
      param_1[0xa3] = 0.0;
      param_1[0xa4] = 0.0;
      param_1[0xa5] = 0.0;
      param_1[0xa6] = 0.0;
      param_1[0xa7] = 0.0;
      param_1[0xa8] = 0.0;
    }
    else {
      param_1[0xa5] = (param_1[0xa1] + *pfVar1) * 0.5;
      param_1[0xa6] = (param_1[0xa2] + param_1[0x9e]) * 0.5;
      param_1[0xa7] = (param_1[0xa3] + param_1[0x9f]) * 0.5;
      param_1[0xa8] = 3.4028235e+38;
      fVar6 = 0.0;
      uVar9 = (ulong long)*(uint *)(lStack_88 + 0x10);
      if (0 < (int)*(uint *)(lStack_88 + 0x10)) {
        pfVar7 = *(float **)(lStack_88 + 0x18);
        fVar11 = fVar6;
        do {
          fVar6 = (*pfVar7 - param_1[0xa5]) * (*pfVar7 - param_1[0xa5]) +
                  (pfVar7[1] - param_1[0xa6]) * (pfVar7[1] - param_1[0xa6]) +
                  (pfVar7[2] - param_1[0xa7]) * (pfVar7[2] - param_1[0xa7]);
          if (fVar6 <= fVar11) {
            fVar6 = fVar11;
          }
          pfVar7 = pfVar7 + 4;
          uVar9 = uVar9 - 1;
          fVar11 = fVar6;
        } while (uVar9 != 0);
      }
      param_1[0xa9] = SQRT(fVar6);
    }
    if (pfStack_98 != (float *)0x0) {
      while( true ) {
        LOCK();
        cVar5 = *(char *)(pfVar4 + 0x3b);
        bVar10 = cVar5 == '\0';
        if (bVar10) {
          *(char *)(pfVar4 + 0x3b) = '\x01';
          cVar5 = '\0';
        }
        UNLOCK();
        if (bVar10) break;
        fVar6 = (float)_Thrd_id();
        if ((pfVar4[0x3c] == fVar6) || (pfVar4[0x3c] != 0.0)) goto LAB_180075f4f;
        Sleep();
      }
      cVar5 = '\0';
LAB_180075f4f:
      LOCK();
      pfVar1 = pfVar4 + 0x3a;
      fVar6 = *pfVar1;
      pfVar7 = (float *)(ulong long)(uint)fVar6;
      *pfVar1 = (float)((int)*pfVar1 + -1);
      UNLOCK();
      if (cVar5 == '\0') {
        if ((((fVar6 == 1.4013e-45) && (*(long long *)(pfStack_98 + 0x84) != 0)) &&
            (pfVar7 = pfStack_98, FUN_1800791a0(pfStack_98), *(char *)(pfVar7 + 0x3f) == '\0')) &&
           ((*(char *)(pfVar7 + 0x3d) == '\0' &&
            (((*(byte *)((long long)pfVar7 + 0xfd) & 0x20) == 0 ||
             ((*(byte *)((long long)pfVar7 + 0xfe) & 1) == 0)))))) {
          plVar3 = *(long long **)(pfVar7 + 0x84);
          pfVar7[0x84] = 0.0;
          pfVar7[0x85] = 0.0;
          if (plVar3 != (long long *)0x0) {
            (**(code **)(*plVar3 + 0x38))();
          }
        }
        LOCK();
        bVar2 = *(byte *)(pfVar4 + 0x3b);
        *(byte *)(pfVar4 + 0x3b) = 0;
        pfVar7 = (float *)(ulong long)bVar2;
        UNLOCK();
      }
    }
  }
  return pfVar7;
}



// WARNING: Removing unreachable block (ram,0x0001800797c0)
// WARNING: Removing unreachable block (ram,0x0001800797c8)
// WARNING: Removing unreachable block (ram,0x0001800797cd)
// WARNING: Removing unreachable block (ram,0x0001800797dd)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_1800796b0(long long param_1)
void FUN_1800796b0(long long param_1)

{
  int *piVar1;
  uint *puVar2;
  void* *puVar3;
  void* *puVar4;
  float fVar5;
  void* uVar6;
  void* uVar7;
  uint8_t auVar8 [16];
  bool bVar9;
  int *piVar10;
  int iVar11;
  long long lVar12;
  int *piVar13;
  int *piVar14;
  int *piVar15;
  int *piVar16;
  long long lVar17;
  float *pfVar18;
  uint uVar19;
  int *piVar20;
  long long lVar21;
  long long lVar22;
  long long lVar23;
  long long lVar24;
  int *piVar25;
  int *piVar26;
  int iVar27;
  ulong long uVar28;
  uint32_t *puVar29;
  ulong long uVar30;
  long long lVar31;
  uint *puVar32;
  uint uVar33;
  int *piVar34;
  uint8_t (*pauVar35) [16];
  ulong long uVar36;
  uint8_t (*pauVar37) [16];
  ulong long uVar38;
  long long *plVar39;
  long long lVar40;
  ulong long uVar41;
  uint8_t (*pauVar42) [16];
  long long lVar43;
  bool bVar44;
  float fVar45;
  float fVar46;
  uint8_t auVar47 [16];
  float fVar48;
  float fVar49;
  float fVar50;
  float fVar51;
  float fVar52;
  float fVar53;
  int iStackX_10;
  ulong long uStackX_18;
  ulong long uStackX_20;
  int *piStack_218;
  int *piStack_210;
  int *piStack_208;
  uint32_t uStack_200;
  int *piStack_1f8;
  int *piStack_1f0;
  int iStack_1e8;
  uint8_t (*pauStack_1e0) [16];
  ulong long uStack_1d8;
  long long lStack_1d0;
  uint uStack_1c8;
  uint uStack_1c0;
  uint32_t uStack_1bc;
  void* uStack_1b8;
  int *piStack_1b0;
  uint32_t uStack_1a8;
  void* uStack_1a0;
  void* uStack_198;
  int *piStack_190;
  uint32_t uStack_188;
  void* uStack_180;
  float fStack_178;
  float fStack_174;
  long long lStack_170;
  long long *plStack_168;
  long long *plStack_160;
  uint32_t uStack_158;
  uint8_t auStack_150 [16];
  void* uStack_140;
  uint32_t uStack_138;
  uint32_t *puStack_130;
  void* uStack_128;
  void* uStack_120;
  uint32_t uStack_118;
  void* uStack_110;
  void* uStack_108;
  void* uStack_100;
  void* uStack_f8;
  void* uStack_f0;
  void* uStack_e8;
  void* uStack_e0;
  void* uStack_d8;
  void* uStack_d0;
  void* uStack_c8;
  void* uStack_c0;
  void* uStack_b8;
  uint32_t uStack_b0;
  
  uStack_110 = 0xfffffffffffffffe;
  piVar1 = (int *)(param_1 + 0x60);
  iVar27 = *piVar1;
  iVar11 = *(int *)(param_1 + 0x88);
  uVar28 = (ulong long)iVar11;
  iStack_1e8 = *(int *)(param_1 + 0x10);
  puStack_130 = (uint32_t *)0x0;
  uStack_128 = 0;
  uStack_120 = 0;
  uStack_118 = 3;
  FUN_180080ca0(&puStack_130,uVar28);
  uVar41 = uVar28;
  puVar29 = puStack_130;
  if (0 < iVar11) {
    for (; uVar41 != 0; uVar41 = uVar41 - 1) {
      *puVar29 = 1;
      puVar29 = puVar29 + 1;
    }
  }
  auStack_150 = ZEXT816(0);
  uStack_140 = 0;
  uStack_138 = 3;
  lVar21 = (ulong long)*(ushort *)(param_1 + 0xc0) + 1;
  if (lVar21 == 0) {
    lVar21 = 0;
    auStack_150 = ZEXT816(0) << 0x40;
  }
  else {
    FUN_180082290(auStack_150,lVar21);
    lVar21 = auStack_150._0_8_;
  }
  pauStack_1e0 = (uint8_t (*) [16])(ulong long)*(ushort *)(param_1 + 0xc0);
  lVar23 = -1;
  do {
    lVar31 = lVar23 + 1;
    lVar22 = lVar31 * 0x20;
    lVar17 = *(long long *)(lVar21 + 8 + lVar22);
    lVar24 = *(long long *)(lVar21 + lVar22);
    uVar41 = lVar17 - lVar24 >> 4;
    if (uVar41 < uVar28) {
      uVar30 = uVar28 - uVar41;
      if ((ulong long)(*(long long *)(lVar21 + 0x10 + lVar22) - lVar17 >> 4) < uVar30) {
        if (uVar41 == 0) {
          uVar41 = 1;
        }
        else {
          uVar41 = uVar41 * 2;
        }
        if (uVar41 < uVar28) {
          uVar41 = uVar28;
        }
        if (uVar41 == 0) {
          lVar12 = 0;
        }
        else {
          lVar12 = CreateSystemThreadObject(_DAT_180c8ed18,uVar41 << 4,*(uint8_t *)(lVar21 + 0x18 + lVar22))
          ;
          lVar17 = *(long long *)(lVar21 + 8 + lVar22);
          lVar24 = *(long long *)(lVar21 + lVar22);
        }
        if (lVar24 != lVar17) {
                    // WARNING: Subroutine does not return
          memmove(lVar12,lVar24,lVar17 - lVar24);
        }
        if (uVar30 != 0) {
                    // WARNING: Subroutine does not return
          memset(lVar12,0,uVar30 * 0x10);
        }
        if (*(long long *)(lVar21 + lVar22) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(long long *)(lVar21 + lVar22) = lVar12;
        *(long long *)(lVar21 + 8 + lVar22) = lVar12;
        *(ulong long *)(lVar21 + 0x10 + lVar22) = uVar41 * 0x10 + lVar12;
      }
      else {
        if (uVar30 != 0) {
                    // WARNING: Subroutine does not return
          memset(lVar17,0,uVar30 * 0x10);
        }
        *(long long *)(lVar21 + 8 + lVar22) = lVar17;
      }
    }
    else {
      *(ulong long *)(lVar21 + 8 + lVar22) = uVar28 * 0x10 + lVar24;
    }
    uVar36 = 0;
    uVar41 = uVar36;
    uVar30 = uVar36;
    uVar38 = uVar28;
    if (0 < (long long)uVar28) {
      do {
        lVar21 = *(long long *)(param_1 + 0x90);
        lVar24 = (long long)*(int *)(lVar21 + 8 + uVar41);
        lVar17 = (long long)*(int *)(lVar21 + 4 + uVar41) * 0x5c;
        if (lVar23 == -1) {
          lVar12 = *(long long *)(param_1 + 0x68);
          lVar40 = *(long long *)(param_1 + 0x18);
          lVar17 = (long long)*(int *)(lVar17 + lVar12);
          lVar21 = (long long)*(int *)((long long)*(int *)(lVar21 + uVar41) * 0x5c + lVar12);
          fVar48 = *(float *)(lVar40 + 8 + lVar21 * 0x10);
          fVar49 = *(float *)(lVar40 + 8 + lVar17 * 0x10) - fVar48;
          fVar5 = *(float *)(lVar40 + 4 + lVar21 * 0x10);
          fVar52 = *(float *)(lVar40 + 4 + lVar17 * 0x10);
          fVar51 = *(float *)(lVar40 + lVar21 * 0x10);
          lVar21 = (long long)*(int *)(lVar24 * 0x5c + lVar12);
          fVar48 = *(float *)(lVar40 + 8 + lVar21 * 0x10) - fVar48;
          fVar45 = *(float *)(lVar40 + 4 + lVar21 * 0x10);
          fVar46 = *(float *)(lVar40 + lVar17 * 0x10);
          fVar53 = *(float *)(lVar40 + lVar21 * 0x10);
        }
        else {
          lVar12 = *(long long *)(param_1 + 0x68);
          lVar40 = *(long long *)(lVar23 * 0x50 + *(long long *)(param_1 + 0xb0) + 8);
          lVar17 = (long long)*(int *)(lVar17 + lVar12);
          lVar21 = (long long)*(int *)((long long)*(int *)(lVar21 + uVar41) * 0x5c + lVar12);
          fVar48 = *(float *)(lVar40 + 8 + lVar21 * 0x10);
          fVar49 = *(float *)(lVar40 + 8 + lVar17 * 0x10) - fVar48;
          fVar5 = *(float *)(lVar40 + 4 + lVar21 * 0x10);
          fVar52 = *(float *)(lVar40 + 4 + lVar17 * 0x10);
          fVar51 = *(float *)(lVar40 + lVar21 * 0x10);
          lVar21 = (long long)*(int *)(lVar24 * 0x5c + lVar12);
          fVar48 = *(float *)(lVar40 + 8 + lVar21 * 0x10) - fVar48;
          fVar45 = *(float *)(lVar40 + 4 + lVar21 * 0x10);
          fVar46 = *(float *)(lVar40 + lVar17 * 0x10);
          fVar53 = *(float *)(lVar40 + lVar21 * 0x10);
        }
        fVar50 = (fVar46 - fVar51) * (fVar45 - fVar5) - (fVar52 - fVar5) * (fVar53 - fVar51);
        fVar51 = fVar49 * (fVar53 - fVar51) - fVar48 * (fVar46 - fVar51);
        fVar48 = fVar48 * (fVar52 - fVar5) - fVar49 * (fVar45 - fVar5);
        fStack_174 = SQRT(fVar51 * fVar51 + fVar48 * fVar48 + fVar50 * fVar50);
        if (fStack_174 <= 0.0) {
          fVar48 = 0.0;
          fVar51 = 0.0;
          fStack_178 = 1.0;
          fStack_174 = 1.0;
        }
        else {
          fStack_178 = 1.0 / fStack_174;
          fVar48 = fVar48 * fStack_178;
          fVar51 = fStack_178 * fVar51;
          fStack_178 = fStack_178 * fVar50;
        }
        uStack_180 = CONCAT44(fVar51,fVar48);
        pfVar18 = (float *)(*(long long *)(auStack_150._0_8_ + lVar22) + uVar30);
        *pfVar18 = fVar48;
        pfVar18[1] = fVar51;
        pfVar18[2] = fStack_178;
        pfVar18[3] = fStack_174;
        uVar38 = uVar38 - 1;
        uVar41 = uVar41 + 0xc;
        uVar30 = uVar30 + 0x10;
      } while (uVar38 != 0);
    }
    lVar21 = auStack_150._0_8_;
    lVar23 = lVar31;
  } while (lVar31 < (long long)pauStack_1e0);
  lStack_170 = 0;
  plStack_168 = (long long *)0x0;
  plStack_160 = (long long *)0x0;
  uStack_158 = 3;
  FUN_180081010(&lStack_170,(long long)iVar27);
  uVar41 = uVar36;
  uStackX_20 = uVar28;
  if (0 < (long long)uVar28) {
    do {
      lVar23 = lStack_170;
      piVar13 = (int *)0x0;
      lVar21 = *(long long *)(param_1 + 0x90);
      lVar31 = (ulong long)*(uint *)(lVar21 + uVar36) * 0x20;
      piVar20 = *(int **)(lVar31 + 8 + lStack_170);
      iVar27 = (int)uVar41;
      if (piVar20 < *(int **)(lVar31 + 0x10 + lStack_170)) {
        *(int **)(lVar31 + 8 + lStack_170) = piVar20 + 1;
        *piVar20 = iVar27;
      }
      else {
        piVar15 = *(int **)(lVar31 + lStack_170);
        lVar17 = (long long)piVar20 - (long long)piVar15 >> 2;
        if (lVar17 == 0) {
          lVar17 = 1;
LAB_180079c12:
          piVar13 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,lVar17 * 4,
                                         *(uint8_t *)(lVar31 + 0x18 + lStack_170));
          piVar20 = *(int **)(lVar31 + 8 + lVar23);
          piVar15 = *(int **)(lVar31 + lVar23);
        }
        else {
          lVar17 = lVar17 * 2;
          if (lVar17 != 0) goto LAB_180079c12;
        }
        if (piVar15 != piVar20) {
                    // WARNING: Subroutine does not return
          memmove(piVar13,piVar15,(long long)piVar20 - (long long)piVar15);
        }
        *piVar13 = iVar27;
        if (*(long long *)(lVar31 + lVar23) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(int **)(lVar31 + lVar23) = piVar13;
        *(int **)(lVar31 + 8 + lVar23) = piVar13 + 1;
        *(int **)(lVar31 + 0x10 + lVar23) = piVar13 + lVar17;
      }
      lVar23 = lStack_170;
      piVar13 = (int *)0x0;
      lVar31 = (ulong long)*(uint *)(lVar21 + 4 + uVar36) * 0x20;
      piVar20 = *(int **)(lVar31 + 8 + lStack_170);
      if (piVar20 < *(int **)(lVar31 + 0x10 + lStack_170)) {
        *(int **)(lVar31 + 8 + lStack_170) = piVar20 + 1;
        *piVar20 = iVar27;
      }
      else {
        piVar15 = *(int **)(lVar31 + lStack_170);
        lVar17 = (long long)piVar20 - (long long)piVar15 >> 2;
        if (lVar17 == 0) {
          lVar17 = 1;
LAB_180079cd7:
          piVar13 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,lVar17 * 4,
                                         *(uint8_t *)(lVar31 + 0x18 + lStack_170));
          piVar20 = *(int **)(lVar31 + 8 + lVar23);
          piVar15 = *(int **)(lVar31 + lVar23);
        }
        else {
          lVar17 = lVar17 * 2;
          if (lVar17 != 0) goto LAB_180079cd7;
        }
        if (piVar15 != piVar20) {
                    // WARNING: Subroutine does not return
          memmove(piVar13,piVar15,(long long)piVar20 - (long long)piVar15);
        }
        *piVar13 = iVar27;
        if (*(long long *)(lVar31 + lVar23) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(int **)(lVar31 + lVar23) = piVar13;
        *(int **)(lVar31 + 8 + lVar23) = piVar13 + 1;
        *(int **)(lVar31 + 0x10 + lVar23) = piVar13 + lVar17;
      }
      lVar23 = lStack_170;
      lVar21 = (ulong long)*(uint *)(lVar21 + 8 + uVar36) * 0x20;
      piVar20 = *(int **)(lVar21 + 8 + lStack_170);
      if (piVar20 < *(int **)(lVar21 + 0x10 + lStack_170)) {
        *(int **)(lVar21 + 8 + lStack_170) = piVar20 + 1;
        *piVar20 = iVar27;
      }
      else {
        piVar13 = *(int **)(lVar21 + lStack_170);
        lVar31 = (long long)piVar20 - (long long)piVar13 >> 2;
        if (lVar31 == 0) {
          lVar31 = 1;
LAB_180079d9b:
          piVar15 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,lVar31 * 4,
                                         *(uint8_t *)(lVar21 + 0x18 + lStack_170));
          piVar20 = *(int **)(lVar21 + 8 + lVar23);
          piVar13 = *(int **)(lVar21 + lVar23);
        }
        else {
          lVar31 = lVar31 * 2;
          if (lVar31 != 0) goto LAB_180079d9b;
          piVar15 = (int *)0x0;
        }
        if (piVar13 != piVar20) {
                    // WARNING: Subroutine does not return
          memmove(piVar15,piVar13,(long long)piVar20 - (long long)piVar13);
        }
        *piVar15 = iVar27;
        if (*(long long *)(lVar21 + lVar23) != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *(int **)(lVar21 + lVar23) = piVar15;
        *(int **)(lVar21 + 8 + lVar23) = piVar15 + 1;
        *(int **)(lVar21 + 0x10 + lVar23) = piVar15 + lVar31;
      }
      uVar36 = uVar36 + 0xc;
      uStackX_20 = uStackX_20 - 1;
      uVar41 = (ulong long)(iVar27 + 1);
    } while (uStackX_20 != 0);
  }
  uVar19 = 0;
  systemInitializationFlag = 0;
  if (*piVar1 < 1) {
LAB_18007a5ac:
    FUN_180080fa0(&lStack_170);
    lVar21 = (long long)iStack_1e8;
    uStack_1d8 = (ulong long)*(ushort *)(param_1 + 0xc0);
    uStackX_18 = -1;
    do {
      piStack_218 = (int *)0x0;
      piStack_210 = (int *)0x0;
      piStack_208 = (int *)0x0;
      uStack_200 = 3;
      if (lVar21 == 0) {
        FUN_180082880(0);
        piStack_210 = piStack_218;
      }
      else {
        FUN_1800824a0(&piStack_218,lVar21);
      }
      plVar39 = (long long *)((uStackX_18 + 1) * 0x20 + auStack_150._0_8_);
      lVar23 = 0;
      piStack_1f0 = (int *)0x0;
      if (0 < (long long)uVar28) {
        piStack_1f8 = (int *)0x0;
        do {
          lVar21 = 0;
          uStack_180 = *(long long *)(param_1 + 0x90) + (long long)piStack_1f8;
          uVar19 = puStack_130[(long long)piStack_1f0];
          if (uVar19 == 0) {
            do {
              if (uStackX_18 == -1) {
                lVar31 = (long long)*(int *)(uStack_180 + lVar21 * 4) * 0x5c +
                         *(long long *)(param_1 + 0x68);
                uVar6 = ((void* *)(lVar23 + *plVar39))[1];
                *(void* *)(lVar31 + 4) = *(void* *)(lVar23 + *plVar39);
                *(void* *)(lVar31 + 0xc) = uVar6;
                uVar6 = ((void* *)(lVar23 + *plVar39))[1];
                *(void* *)(lVar31 + 0x34) = *(void* *)(lVar23 + *plVar39);
                *(void* *)(lVar31 + 0x3c) = uVar6;
                fVar48 = *(float *)(lVar31 + 8);
                fVar52 = *(float *)(lVar31 + 4);
                fVar51 = *(float *)(lVar31 + 0xc);
                fVar45 = fVar51 * fVar51 + fVar52 * fVar52 + fVar48 * fVar48;
                auVar47 = rsqrtss(ZEXT416((uint)fVar45),ZEXT416((uint)fVar45));
                fVar46 = auVar47._0_4_;
                fVar45 = fVar46 * 0.5 * (3.0 - fVar45 * fVar46 * fVar46);
                *(float *)(lVar31 + 4) = fVar45 * fVar52;
                *(float *)(lVar31 + 8) = fVar45 * fVar48;
                *(float *)(lVar31 + 0xc) = fVar45 * fVar51;
                fVar48 = *(float *)(lVar31 + 0x38);
                fVar52 = *(float *)(lVar31 + 0x34);
                fVar51 = *(float *)(lVar31 + 0x3c);
                fVar45 = fVar51 * fVar51 + fVar52 * fVar52 + fVar48 * fVar48;
                auVar47 = rsqrtss(ZEXT416((uint)fVar45),ZEXT416((uint)fVar45));
                fVar46 = auVar47._0_4_;
                fVar45 = fVar46 * 0.5 * (3.0 - fVar45 * fVar46 * fVar46);
                *(float *)(lVar31 + 0x34) = fVar52 * fVar45;
                *(float *)(lVar31 + 0x38) = fVar48 * fVar45;
                *(float *)(lVar31 + 0x3c) = fVar51 * fVar45;
              }
              else {
                uVar6 = ((void* *)(lVar23 + *plVar39))[1];
                puVar3 = (void* *)
                         (*(long long *)(*(long long *)(param_1 + 0xb0) + 0x30 + uStackX_18 * 0x50) +
                         (long long)*(int *)(uStack_180 + lVar21 * 4) * 0x10);
                *puVar3 = *(void* *)(lVar23 + *plVar39);
                puVar3[1] = uVar6;
                pfVar18 = (float *)((long long)*(int *)(uStack_180 + lVar21 * 4) * 0x10 +
                                   *(long long *)
                                    (*(long long *)(param_1 + 0xb0) + 0x30 + uStackX_18 * 0x50));
                fVar48 = pfVar18[1];
                fVar52 = *pfVar18;
                fVar51 = pfVar18[2];
                fVar45 = fVar51 * fVar51 + fVar52 * fVar52 + fVar48 * fVar48;
                auVar47 = rsqrtss(ZEXT416((uint)fVar45),ZEXT416((uint)fVar45));
                fVar46 = auVar47._0_4_;
                fVar45 = fVar46 * 0.5 * (3.0 - fVar45 * fVar46 * fVar46);
                *pfVar18 = fVar52 * fVar45;
                pfVar18[1] = fVar48 * fVar45;
                pfVar18[2] = fVar51 * fVar45;
              }
              lVar21 = lVar21 + 1;
            } while (lVar21 < 3);
          }
          else {
            lStack_1d0 = 0;
            do {
              piVar1 = piStack_218;
              lVar31 = 0;
              puVar32 = (uint *)((long long)*(int *)(uStack_180 + lStack_1d0 * 4) * 0x5c +
                                *(long long *)(param_1 + 0x68));
              bVar44 = false;
              lVar17 = (long long)
                       (int)((*(long long *)((long long)(piStack_218 + (ulong long)*puVar32 * 8) + 8) -
                             *(long long *)(piStack_218 + (ulong long)*puVar32 * 8)) / 0x14);
              lVar21 = lVar31;
              if (3 < lVar17) {
                lVar24 = (lVar17 - 4U >> 2) + 1;
                lVar21 = lVar24 * 4;
                do {
                  uVar33 = *puVar32;
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)uVar33 * 8) + lVar31) &
                      uVar19) != 0) {
                    puVar2 = (uint *)(lVar31 + *(long long *)(piStack_218 + (ulong long)uVar33 * 8));
                    *puVar2 = *puVar2 | uVar19;
                    lVar22 = *plVar39;
                    fVar48 = *(float *)(lVar23 + 8 + lVar22);
                    fVar52 = *(float *)(lVar23 + 4 + lVar22);
                    lVar12 = *(long long *)(piStack_218 + (ulong long)*puVar32 * 8);
                    *(float *)(lVar12 + 4 + lVar31) =
                         *(float *)(lVar12 + 4 + lVar31) + *(float *)(lVar23 + lVar22);
                    *(float *)(lVar12 + 8 + lVar31) = fVar52 + *(float *)(lVar12 + 8 + lVar31);
                    *(float *)(lVar12 + 0xc + lVar31) = fVar48 + *(float *)(lVar12 + 0xc + lVar31);
                    bVar44 = true;
                    uVar33 = *puVar32;
                  }
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)uVar33 * 8) + 0x14 + lVar31)
                      & uVar19) != 0) {
                    puVar2 = (uint *)(*(long long *)(piStack_218 + (ulong long)uVar33 * 8) + 0x14 +
                                     lVar31);
                    *puVar2 = *puVar2 | uVar19;
                    lVar22 = *plVar39;
                    fVar48 = *(float *)(lVar23 + 8 + lVar22);
                    fVar52 = *(float *)(lVar23 + 4 + lVar22);
                    lVar12 = *(long long *)(piStack_218 + (ulong long)*puVar32 * 8);
                    *(float *)(lVar12 + 0x18 + lVar31) =
                         *(float *)(lVar12 + 0x18 + lVar31) + *(float *)(lVar23 + lVar22);
                    *(float *)(lVar12 + 0x1c + lVar31) = fVar52 + *(float *)(lVar12 + 0x1c + lVar31)
                    ;
                    *(float *)(lVar12 + 0x20 + lVar31) = fVar48 + *(float *)(lVar12 + 0x20 + lVar31)
                    ;
                    bVar44 = true;
                    uVar33 = *puVar32;
                  }
                  if ((*(uint *)(*(long long *)(piStack_218 + (ulong long)uVar33 * 8) + 0x28 + lVar31)
                      & uVar19) != 0) {
                    puVar2 = (uint *)(*(long long *)(piStack_218 + (ulong long)uVar33 * 8) + 0x28 +
                                     lVar31);
                    *puVar2 = *puVar2 | uVar19;
                    lVar22 = *plVar39;
                    fVar48 = *(float *)(lVar23 + 8 + lVar22);
                    fVar52 = *(float *)(lVar23 + 4 + lVar22);
                    lVar12 = *(long long *)(piStack_218 + (ulong long)*puVar32 * 8);
                    *(float *)(lVar12 + 0x2c + lVar31) =
                         *(float *)(lVar12 + 0x2c + lVar31) + *(float *)(lVar23 + lVar22);
                    *(float *)(lVar12 + 0x30 + lVar31) = fVar52 + *(float *)(lVar12 + 0x30 + lVar31)
                    ;
                    *(float *)(lVar12 + 0x34 + lVar31) = fVar48 + *(float *)(lVar12 + 0x34 + lVar31)
                    ;
                    bVar44 = true;
                  }
                  uVar33 = *(uint *)(lVar31 + 0x3c +
                                    *(long long *)(piStack_218 + (ulong long)*puVar32 * 8));
                  if ((uVar19 & uVar33) != 0) {
                    *(uint *)(*(long long *)(piStack_218 + (ulong long)*puVar32 * 8) + 0x3c + lVar31)
                         = uVar33 | uVar19;
                    lVar22 = *plVar39;
                    fVar48 = *(float *)(lVar23 + 8 + lVar22);
                    fVar52 = *(float *)(lVar23 + 4 + lVar22);
                    lVar12 = *(long long *)(piStack_218 + (ulong long)*puVar32 * 8);
                    *(float *)(lVar12 + 0x40 + lVar31) =
                         *(float *)(lVar12 + 0x40 + lVar31) + *(float *)(lVar23 + lVar22);
                    *(float *)(lVar12 + 0x44 + lVar31) = fVar52 + *(float *)(lVar12 + 0x44 + lVar31)
                    ;
                    *(float *)(lVar12 + 0x48 + lVar31) = fVar48 + *(float *)(lVar12 + 0x48 + lVar31)
                    ;
                    bVar44 = true;
                  }
                  lVar31 = lVar31 + 0x50;
                  lVar24 = lVar24 + -1;
                } while (lVar24 != 0);
              }
              pauVar42 = (uint8_t (*) [16])0x0;
              if (lVar21 < lVar17) {
                lVar31 = lVar21 * 0x14;
                lVar17 = lVar17 - lVar21;
                do {
                  uVar33 = *(uint *)(lVar31 + *(long long *)(piStack_218 + (ulong long)*puVar32 * 8));
                  if ((uVar19 & uVar33) != 0) {
                    *(uint *)(lVar31 + *(long long *)(piStack_218 + (ulong long)*puVar32 * 8)) =
                         uVar33 | uVar19;
                    lVar21 = *plVar39;
                    fVar48 = *(float *)(lVar23 + 8 + lVar21);
                    fVar52 = *(float *)(lVar23 + 4 + lVar21);
                    lVar24 = *(long long *)(piStack_218 + (ulong long)*puVar32 * 8);
                    *(float *)(lVar31 + 4 + lVar24) =
                         *(float *)(lVar31 + 4 + lVar24) + *(float *)(lVar23 + lVar21);
                    *(float *)(lVar31 + 8 + lVar24) = fVar52 + *(float *)(lVar31 + 8 + lVar24);
                    *(float *)(lVar31 + 0xc + lVar24) = fVar48 + *(float *)(lVar31 + 0xc + lVar24);
                    bVar44 = true;
                  }
                  lVar31 = lVar31 + 0x14;
                  lVar17 = lVar17 + -1;
                } while (lVar17 != 0);
              }
              if (!bVar44) {
                lVar21 = *plVar39;
                uStack_1b8._4_4_ = *(uint32_t *)(lVar23 + 8 + lVar21);
                uStack_1b8._0_4_ = *(uint32_t *)(lVar23 + 4 + lVar21);
                uStack_1bc = *(uint32_t *)(lVar23 + lVar21);
                uStack_1a0 = (int *)CONCAT44((uint32_t)uStack_1b8,uStack_1bc);
                uStack_198 = (int *)CONCAT44(0x7f7fffff,uStack_1b8._4_4_);
                piStack_1b0 = (int *)CONCAT44(piStack_1b0._4_4_,0x7f7fffff);
                uVar41 = (ulong long)*puVar32;
                pauVar37 = *(uint8_t (**) [16])(piStack_218 + uVar41 * 8 + 2);
                uStack_1c0 = uVar19;
                if (pauVar37 < *(uint8_t (**) [16])(piStack_218 + uVar41 * 8 + 4)) {
                  *(uint8_t **)(piStack_218 + uVar41 * 8 + 2) = pauVar37[1] + 4;
                  auVar8._4_4_ = uStack_1bc;
                  auVar8._0_4_ = uVar19;
                  auVar8._8_4_ = (uint32_t)uStack_1b8;
                  auVar8._12_4_ = uStack_1b8._4_4_;
                  *pauVar37 = auVar8;
                  *(uint32_t *)pauVar37[1] = 0x7f7fffff;
                }
                else {
                  pauVar35 = *(uint8_t (**) [16])(piStack_218 + uVar41 * 8);
                  lVar21 = ((long long)pauVar37 - (long long)pauVar35) / 0x14;
                  if (lVar21 == 0) {
                    uStackX_20 = 1;
LAB_18007ac04:
                    pauVar42 = (uint8_t (*) [16])
                               CreateSystemThreadObject(_DAT_180c8ed18,uStackX_20 * 0x14,
                                             (char)piStack_218[uVar41 * 8 + 6]);
                    pauVar37 = *(uint8_t (**) [16])(piVar1 + uVar41 * 8 + 2);
                    pauVar35 = *(uint8_t (**) [16])(piVar1 + uVar41 * 8);
                  }
                  else {
                    uStackX_20 = lVar21 * 2;
                    if (uStackX_20 != 0) goto LAB_18007ac04;
                  }
                  pauStack_1e0 = pauVar42;
                  if (pauVar35 != pauVar37) {
                    // WARNING: Subroutine does not return
                    memmove(pauVar42,pauVar35,(long long)pauVar37 - (long long)pauVar35);
                  }
                  auVar47._4_4_ = uStack_1bc;
                  auVar47._0_4_ = uStack_1c0;
                  auVar47._8_4_ = (uint32_t)uStack_1b8;
                  auVar47._12_4_ = uStack_1b8._4_4_;
                  *pauVar42 = auVar47;
                  *(uint32_t *)pauVar42[1] = piStack_1b0._0_4_;
                  if (*(long long *)(piVar1 + uVar41 * 8) != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  *(uint8_t (**) [16])(piVar1 + uVar41 * 8) = pauVar42;
                  *(uint8_t **)(piVar1 + uVar41 * 8 + 2) = pauVar42[1] + 4;
                  *(ulong long *)(piVar1 + uVar41 * 8 + 4) = (long long)pauVar42 + uStackX_20 * 0x14;
                }
              }
              lStack_1d0 = lStack_1d0 + 1;
            } while (lStack_1d0 < 3);
          }
          piStack_1f0 = (int *)((long long)piStack_1f0 + 1);
          piStack_1f8 = piStack_1f8 + 3;
          lVar23 = lVar23 + 0x10;
        } while ((long long)piStack_1f0 < (long long)uVar28);
        lVar21 = (long long)iStack_1e8;
      }
      lVar17 = 0;
      lVar23 = lVar17;
      lVar31 = lVar21;
      if (0 < lVar21) {
        do {
          iVar27 = (int)((*(long long *)(lVar23 + 8 + (long long)piStack_218) -
                         *(long long *)(lVar23 + (long long)piStack_218)) / 0x14);
          lVar22 = (long long)iVar27;
          lVar24 = lVar17;
          if (0 < iVar27) {
            do {
              lVar12 = *(long long *)(lVar23 + (long long)piStack_218);
              fVar48 = *(float *)(lVar12 + 8 + lVar24);
              fVar52 = *(float *)(lVar12 + 4 + lVar24);
              fVar51 = *(float *)(lVar12 + 0xc + lVar24);
              fVar45 = fVar52 * fVar52 + fVar48 * fVar48 + fVar51 * fVar51;
              if (SQRT(fVar45) == 0.0) {
                *(uint8_t (*) [16])(lVar12 + 4 + lVar24) = _DAT_180a001d0;
              }
              else {
                auVar47 = rsqrtss(ZEXT416((uint)fVar45),ZEXT416((uint)fVar45));
                fVar46 = auVar47._0_4_;
                fVar45 = fVar46 * 0.5 * (3.0 - fVar45 * fVar46 * fVar46);
                *(float *)(lVar12 + 4 + lVar24) = fVar52 * fVar45;
                *(float *)(lVar12 + 8 + lVar24) = fVar45 * fVar48;
                *(float *)(lVar12 + 0xc + lVar24) = fVar51 * fVar45;
              }
              lVar22 = lVar22 + -1;
              lVar24 = lVar24 + 0x14;
            } while (lVar22 != 0);
          }
          lVar31 = lVar31 + -1;
          lVar23 = lVar23 + 0x20;
        } while (lVar31 != 0);
      }
      lVar23 = lVar17;
      if (0 < (long long)uVar28) {
        do {
          uVar19 = puStack_130[lVar23];
          if (uVar19 != 0) {
            lVar21 = *(long long *)(param_1 + 0x90);
            lVar12 = (long long)*(int *)(lVar17 + lVar21) * 0x5c;
            lVar22 = (long long)*(int *)(*(long long *)(param_1 + 0x68) + lVar12);
            lVar24 = 0;
            iVar27 = (int)((*(long long *)(piStack_218 + lVar22 * 8 + 2) -
                           *(long long *)(piStack_218 + lVar22 * 8)) / 0x14);
            lVar31 = -1;
            if (0 < iVar27) {
              puVar32 = *(uint **)(piStack_218 + lVar22 * 8);
              do {
                lVar31 = lVar24;
                if ((*puVar32 & uVar19) != 0) break;
                lVar24 = lVar24 + 1;
                puVar32 = puVar32 + 5;
                lVar31 = -1;
              } while (lVar24 < iVar27);
            }
            lVar24 = *(long long *)(piStack_218 + lVar22 * 8);
            puVar3 = (void* *)(lVar24 + 4 + lVar31 * 0x14);
            uVar6 = *puVar3;
            uVar7 = puVar3[1];
            if (uStackX_18 == -1) {
              puVar3 = (void* *)(*(long long *)(param_1 + 0x68) + 4 + lVar12);
              *puVar3 = uVar6;
              puVar3[1] = uVar7;
              puVar3 = (void* *)(lVar24 + 4 + lVar31 * 0x14);
              uVar6 = puVar3[1];
              puVar4 = (void* *)
                       ((long long)*(int *)(lVar17 + lVar21) * 0x5c + 0x34 +
                       *(long long *)(param_1 + 0x68));
              *puVar4 = *puVar3;
              puVar4[1] = uVar6;
            }
            else {
              puVar3 = (void* *)
                       (*(long long *)(*(long long *)(param_1 + 0xb0) + 0x30 + uStackX_18 * 0x50) +
                       (long long)*(int *)(lVar17 + lVar21) * 0x10);
              *puVar3 = uVar6;
              puVar3[1] = uVar7;
            }
            lVar40 = (long long)*(int *)(lVar17 + 4 + lVar21);
            lVar12 = lVar40 * 0x5c;
            lVar22 = (long long)*(int *)(*(long long *)(param_1 + 0x68) + lVar12);
            lVar24 = 0;
            iVar27 = (int)((*(long long *)(piStack_218 + lVar22 * 8 + 2) -
                           *(long long *)(piStack_218 + lVar22 * 8)) / 0x14);
            lVar31 = -1;
            if (0 < iVar27) {
              puVar32 = *(uint **)(piStack_218 + lVar22 * 8);
              do {
                lVar31 = lVar24;
                if ((*puVar32 & uVar19) != 0) break;
                lVar24 = lVar24 + 1;
                puVar32 = puVar32 + 5;
                lVar31 = -1;
              } while (lVar24 < iVar27);
            }
            lVar24 = *(long long *)(piStack_218 + lVar22 * 8);
            puVar3 = (void* *)(lVar24 + 4 + lVar31 * 0x14);
            uVar6 = *puVar3;
            uVar7 = puVar3[1];
            if (uStackX_18 == -1) {
              puVar3 = (void* *)(*(long long *)(param_1 + 0x68) + 4 + lVar12);
              *puVar3 = uVar6;
              puVar3[1] = uVar7;
              puVar3 = (void* *)(lVar24 + 4 + lVar31 * 0x14);
              uVar6 = puVar3[1];
              puVar4 = (void* *)
                       ((long long)*(int *)(lVar17 + 4 + lVar21) * 0x5c + 0x34 +
                       *(long long *)(param_1 + 0x68));
              *puVar4 = *puVar3;
              puVar4[1] = uVar6;
            }
            else {
              puVar3 = (void* *)
                       (*(long long *)(*(long long *)(param_1 + 0xb0) + 0x30 + uStackX_18 * 0x50) +
                       lVar40 * 0x10);
              *puVar3 = uVar6;
              puVar3[1] = uVar7;
            }
            lVar40 = (long long)*(int *)(lVar17 + 8 + lVar21);
            lVar43 = lVar40 * 0x5c;
            lVar12 = (long long)*(int *)(lVar43 + *(long long *)(param_1 + 0x68));
            lVar24 = 0;
            lVar22 = (long long)
                     (int)((*(long long *)(piStack_218 + lVar12 * 8 + 2) -
                           *(long long *)(piStack_218 + lVar12 * 8)) / 0x14);
            lVar31 = -1;
            if (0 < lVar22) {
              puVar32 = *(uint **)(piStack_218 + lVar12 * 8);
              do {
                lVar31 = lVar24;
                if ((*puVar32 & uVar19) != 0) break;
                lVar24 = lVar24 + 1;
                puVar32 = puVar32 + 5;
                lVar31 = -1;
              } while (lVar24 < lVar22);
            }
            lVar24 = *(long long *)(piStack_218 + lVar12 * 8);
            auVar47 = *(uint8_t (*) [16])(lVar24 + 4 + lVar31 * 0x14);
            if (uStackX_18 == -1) {
              *(uint8_t (*) [16])(lVar43 + 4 + *(long long *)(param_1 + 0x68)) = auVar47;
              puVar3 = (void* *)(lVar24 + 4 + lVar31 * 0x14);
              uVar6 = puVar3[1];
              puVar4 = (void* *)
                       ((long long)*(int *)(lVar17 + 8 + lVar21) * 0x5c + 0x34 +
                       *(long long *)(param_1 + 0x68));
              *puVar4 = *puVar3;
              puVar4[1] = uVar6;
            }
            else {
              *(uint8_t (*) [16])
               (*(long long *)(*(long long *)(param_1 + 0xb0) + 0x30 + uStackX_18 * 0x50) +
               lVar40 * 0x10) = auVar47;
            }
          }
          lVar23 = lVar23 + 1;
          lVar17 = lVar17 + 0xc;
        } while (lVar23 < (long long)uVar28);
        lVar21 = (long long)iStack_1e8;
      }
      FUN_1800810b0(&piStack_218);
      uStackX_18 = uStackX_18 + 1;
      if ((long long)uStack_1d8 <= (long long)uStackX_18) {
        FUN_180080fa0(auStack_150);
        if (puStack_130 != (uint32_t *)0x0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900(puStack_130);
        }
        return;
      }
    } while( true );
  }
  lStack_1d0 = 0;
LAB_180079e40:
  pauVar42 = (uint8_t (*) [16])(lStack_1d0 * 0x20);
  piVar20 = *(int **)(*pauVar42 + lStack_170);
  uVar41 = *(long long *)(*pauVar42 + lStack_170 + 8) - (long long)piVar20 >> 2;
  pauStack_1e0 = pauVar42;
  if (1 < uVar41) {
    bVar44 = true;
    uStack_1c8 = puStack_130[*piVar20];
    iVar27 = 1;
    uVar19 = uStack_1c8;
    piVar13 = piVar20;
    do {
      piVar13 = piVar13 + 1;
      if ((uVar19 & puStack_130[*piVar13]) == 0) {
        bVar44 = false;
        break;
      }
      uVar19 = uVar19 | puStack_130[*piVar13];
      iVar27 = iVar27 + 1;
    } while ((ulong long)(long long)iVar27 < uVar41);
    uVar19 = (uint)uStackX_18;
    if (!bVar44) {
      uStack_1a0 = (int *)0x0;
      uStack_198 = (int *)0x0;
      piStack_190 = (int *)0x0;
      uStack_188 = 3;
      piVar14 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,4,CONCAT71((uint7)(uint3)(uStackX_18 >> 8),3));
      *piVar14 = *piVar20;
      piVar20 = piVar14 + 1;
      piStack_218 = (int *)0x0;
      piStack_210 = (int *)0x0;
      piVar13 = (int *)0x0;
      piStack_208 = (int *)0x0;
      uStack_200 = 3;
      iStackX_10 = 1;
      piStack_1f8 = *(int **)(*pauVar42 + lStack_170);
      piVar15 = piVar20;
      uStack_1a0 = piVar14;
      uStack_198 = piVar20;
      piStack_190 = piVar20;
      if (1 < (ulong long)(*(long long *)(*pauVar42 + lStack_170 + 8) - (long long)piStack_1f8 >> 2)) {
        uStackX_20 = 4;
        piVar25 = (int *)0x0;
        do {
          piVar26 = piStack_210;
          piVar16 = (int *)0x0;
          if (piStack_210 < piVar13) {
            *piStack_210 = *(int *)(uStackX_20 + (long long)piStack_1f8);
            piVar16 = piVar25;
          }
          else {
            uStack_1d8 = (long long)piStack_210 - (long long)piVar25;
            if ((long long)uStack_1d8 >> 2 == 0) {
              piStack_1f0 = (int *)0x1;
LAB_180079fb3:
              piVar16 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,(long long)piStack_1f0 * 4,
                                             CONCAT71((int7)(uStackX_20 >> 8),3));
            }
            else {
              piStack_1f0 = (int *)(((long long)uStack_1d8 >> 2) * 2);
              if (piStack_1f0 != (int *)0x0) goto LAB_180079fb3;
            }
            if (piVar25 != piVar26) {
                    // WARNING: Subroutine does not return
              memmove(piVar16,piVar25,uStack_1d8);
            }
            *piVar16 = *(int *)(uStackX_20 + (long long)piStack_1f8);
            if (piVar25 != (int *)0x0) {
                    // WARNING: Subroutine does not return
              FUN_18064e900(piVar25);
            }
            piVar13 = piVar16 + (long long)piStack_1f0;
            pauVar42 = pauStack_1e0;
            piStack_218 = piVar16;
            piStack_208 = piVar13;
            piStack_210 = piVar16;
          }
          piStack_210 = piStack_210 + 1;
          iStackX_10 = iStackX_10 + 1;
          uStackX_20 = uStackX_20 + 4;
          piStack_1f8 = *(int **)(*pauVar42 + lStack_170);
          piVar25 = piVar16;
        } while ((ulong long)(long long)iStackX_10 <
                 (ulong long)(*(long long *)(*pauVar42 + lStack_170 + 8) - (long long)piStack_1f8 >> 2)
                );
      }
      do {
        piVar13 = (int *)0x0;
        uStack_1c0 = 0;
        uStack_1bc = 0;
        uStack_1b8 = (int *)0x0;
        piStack_1b0 = (int *)0x0;
        uStack_1a8 = 3;
        bVar44 = false;
        bVar9 = false;
        uVar33 = 0;
        uStack_180 = (long long)piStack_210 - (long long)piStack_218 >> 2;
        piVar26 = (int *)0x0;
        piVar25 = (int *)0x0;
        piVar16 = piVar25;
        piVar34 = piVar13;
        piVar10 = piStack_218;
        piStack_1f8 = piStack_210;
        if (uStack_180 != 0) {
          do {
            piStack_1f0 = piVar10;
            piVar16 = (int *)0x0;
            iVar27 = *piStack_1f0;
            if ((uStack_1c8 & puStack_130[iVar27]) == 0) {
              if (piVar26 < piVar13) {
                *piVar26 = iVar27;
                piVar16 = piVar25;
                uVar33 = (uint)piVar34;
              }
              else {
                uStack_1d8 = (long long)piVar26 - (long long)piVar25;
                if ((long long)uStack_1d8 >> 2 == 0) {
                  lVar21 = 1;
LAB_18007a203:
                  piVar16 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,lVar21 * 4,3);
                }
                else {
                  lVar21 = ((long long)uStack_1d8 >> 2) * 2;
                  if (lVar21 != 0) goto LAB_18007a203;
                }
                if (piVar25 != piVar26) {
                    // WARNING: Subroutine does not return
                  memmove(piVar16,piVar25,uStack_1d8);
                }
                *piVar16 = *piStack_1f0;
                if (piVar25 != (int *)0x0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900(piVar25);
                }
                uStack_1c0 = (uint)piVar16;
                uStack_1bc = (uint32_t)((ulong long)piVar16 >> 0x20);
                piVar13 = piVar16 + lVar21;
                piStack_1b0 = piVar13;
                piVar26 = piVar16;
              }
              piVar26 = piVar26 + 1;
              uStack_1b8 = piVar26;
              bVar44 = bVar9;
            }
            else {
              uStack_1c8 = uStack_1c8 | puStack_130[iVar27];
              if (piVar20 < piVar15) {
                uStack_198 = piVar20 + 1;
                *piVar20 = iVar27;
                piVar20 = uStack_198;
                piVar16 = piVar25;
                uVar33 = (uint)piVar34;
                bVar44 = true;
              }
              else {
                uStack_1d8 = (long long)piVar20 - (long long)piVar14;
                if ((long long)uStack_1d8 >> 2 == 0) {
                  lVar21 = 1;
LAB_18007a142:
                  piVar15 = (int *)CreateSystemThreadObject(_DAT_180c8ed18,lVar21 * 4,3);
                }
                else {
                  lVar21 = ((long long)uStack_1d8 >> 2) * 2;
                  piVar15 = piVar16;
                  if (lVar21 != 0) goto LAB_18007a142;
                }
                if (piVar14 != piVar20) {
                    // WARNING: Subroutine does not return
                  memmove(piVar15,piVar14,uStack_1d8);
                }
                *piVar15 = *piStack_1f0;
                piVar20 = piVar15 + 1;
                if (piVar14 != (int *)0x0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900(piVar14);
                }
                piStack_190 = piVar15 + lVar21;
                piVar16 = piVar25;
                piVar13 = piStack_1b0;
                piVar14 = piVar15;
                uStack_1a0 = piVar15;
                uStack_198 = piVar20;
                bVar44 = true;
              }
            }
            uVar33 = uVar33 + 1;
            piStack_1f0 = piStack_1f0 + 1;
            piVar25 = piVar16;
            piVar34 = (int *)(ulong long)uVar33;
            piVar10 = piStack_1f0;
            piVar15 = piStack_190;
            bVar9 = bVar44;
          } while ((ulong long)(long long)(int)uVar33 < uStack_180);
        }
        plVar39 = plStack_168;
        uStack_1c0 = (uint)piStack_218;
        uStack_1bc = (uint32_t)((ulong long)piStack_218 >> 0x20);
        uStack_1b8._0_4_ = SUB84(piStack_1f8,0);
        uStack_1b8._4_4_ = (uint32_t)((ulong long)piStack_1f8 >> 0x20);
        piStack_1b0 = piStack_208;
        uStack_200 = 3;
        uStack_1a8 = 3;
        piStack_210 = piVar26;
        piStack_208 = piVar13;
        piStack_1f8 = piVar26;
        if ((((long long)piVar26 - (long long)piVar16 & 0xfffffffffffffffcU) == 0) || (!bVar44))
        goto LAB_18007a312;
        bVar44 = piStack_218 != (int *)0x0;
        piStack_218 = piVar16;
        if (bVar44) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
      } while( true );
    }
  }
  goto LAB_18007a58b;
LAB_18007a312:
  if (piStack_218 != (int *)0x0) {
    piStack_218 = piVar16;
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  piVar13 = *(int **)(*pauStack_1e0 + lStack_170);
  piStack_218 = piVar16;
  if (((*(long long *)(*pauStack_1e0 + lStack_170 + 8) - (long long)piVar13 ^
       (long long)piVar20 - (long long)piVar14) & 0xfffffffffffffffcU) != 0) {
    *(int **)(*pauStack_1e0 + lStack_170) = piVar14;
    uStack_198 = *(int **)(*pauStack_1e0 + lStack_170 + 8);
    *(int **)(*pauStack_1e0 + lStack_170 + 8) = piVar20;
    piStack_190 = *(int **)(pauStack_1e0[1] + lStack_170);
    *(int **)(pauStack_1e0[1] + lStack_170) = piVar15;
    uStack_188 = *(uint32_t *)(pauStack_1e0[1] + lStack_170 + 8);
    *(uint32_t *)(pauStack_1e0[1] + lStack_170 + 8) = 3;
    uStack_1a0 = piVar13;
    if (plStack_168 < plStack_160) {
      uVar41 = (long long)piVar26 - (long long)piVar16;
      *(uint32_t *)(plStack_168 + 3) = 3;
      if (uVar41 < 4) {
        lVar21 = 0;
        plStack_168 = plStack_168 + 4;
      }
      else {
        plStack_168 = plStack_168 + 4;
        lVar21 = CreateSystemThreadObject(_DAT_180c8ed18,((long long)uVar41 >> 2) * 4,3);
      }
      *plVar39 = lVar21;
      plVar39[1] = lVar21;
      plVar39[2] = lVar21 + ((long long)uVar41 >> 2) * 4;
      if (piVar16 != piVar26) {
                    // WARNING: Subroutine does not return
        memmove(*plVar39,piVar16,uVar41);
      }
      plVar39[1] = *plVar39;
    }
    else {
      FUN_1800826b0(&lStack_170,&piStack_218);
      piVar26 = piStack_210;
      piVar16 = piStack_218;
    }
    lVar23 = lStack_1d0;
    iVar27 = *piVar1;
    lVar31 = lStack_1d0 * 0x5c;
    lVar21 = *(long long *)(param_1 + 0x68);
    uStack_108 = *(void* *)(lVar31 + lVar21);
    uStack_100 = ((void* *)(lVar31 + lVar21))[1];
    puVar3 = (void* *)(lVar31 + 0x10 + lVar21);
    uStack_f8 = *puVar3;
    uStack_f0 = puVar3[1];
    puVar3 = (void* *)(lVar31 + 0x20 + lVar21);
    uStack_e8 = *puVar3;
    uStack_e0 = puVar3[1];
    puVar3 = (void* *)(lVar31 + 0x30 + lVar21);
    uStack_d8 = *puVar3;
    uStack_d0 = puVar3[1];
    puVar3 = (void* *)(lVar31 + 0x40 + lVar21);
    uStack_c8 = *puVar3;
    uStack_c0 = puVar3[1];
    uStack_b8 = *(void* *)(lVar31 + 0x50 + lVar21);
    uStack_b0 = *(uint32_t *)(lVar31 + 0x58 + lVar21);
    FUN_180080c10(piVar1,&uStack_108);
    uVar38 = (long long)piVar26 - (long long)piVar16 >> 2;
    uVar30 = 0;
    piVar20 = piVar16;
    uVar41 = uVar30;
    if (uVar38 != 0) {
      do {
        lVar31 = (long long)*piVar20;
        lVar21 = *(long long *)(param_1 + 0x90);
        if (*(uint *)(lVar21 + lVar31 * 0xc) == (uint)uStackX_18) {
          *(int *)(lVar21 + lVar31 * 0xc) = iVar27;
        }
        if (*(uint *)(lVar21 + 4 + lVar31 * 0xc) == (uint)uStackX_18) {
          *(int *)(lVar21 + 4 + lVar31 * 0xc) = iVar27;
        }
        if (*(uint *)(lVar21 + 8 + lVar31 * 0xc) == (uint)uStackX_18) {
          *(int *)(lVar21 + 8 + lVar31 * 0xc) = iVar27;
        }
        uVar33 = (int)uVar41 + 1;
        piVar20 = piVar20 + 1;
        uVar41 = (ulong long)uVar33;
      } while ((ulong long)(long long)(int)uVar33 < uVar38);
    }
    uVar41 = uVar30;
    piVar14 = piVar13;
    if (*(short *)(param_1 + 0xc0) != 0) {
      do {
        lVar21 = uVar30 + *(long long *)(param_1 + 0xb0);
        lVar31 = *(long long *)(uVar30 + 0x30 + *(long long *)(param_1 + 0xb0));
        puVar3 = (void* *)(lVar31 + lVar23 * 0x10);
        uVar6 = *puVar3;
        uVar7 = puVar3[1];
        iVar27 = *(int *)(lVar21 + 0x2c);
        iVar11 = *(int *)(lVar21 + 0x28);
        if (iVar27 <= iVar11) {
          if (iVar27 < 2) {
            *(uint32_t *)(lVar21 + 0x2c) = 8;
          }
          else {
            *(int *)(lVar21 + 0x2c) = (iVar27 >> 1) + iVar27;
          }
          FUN_1800846d0(lVar21 + 0x28);
          iVar11 = *(int *)(lVar21 + 0x28);
          lVar31 = *(long long *)(lVar21 + 0x30);
        }
        puVar3 = (void* *)(lVar31 + (long long)iVar11 * 0x10);
        *puVar3 = uVar6;
        puVar3[1] = uVar7;
        *(int *)(lVar21 + 0x28) = *(int *)(lVar21 + 0x28) + 1;
        uVar33 = (int)uVar41 + 1;
        uVar30 = uVar30 + 0x50;
        uVar41 = (ulong long)uVar33;
      } while ((int)uVar33 < (int)(uint)*(ushort *)(param_1 + 0xc0));
    }
  }
  if (piVar16 != (int *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(piVar16);
  }
  if (piVar14 != (int *)0x0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900(piVar14);
  }
LAB_18007a58b:
  uVar19 = uVar19 + 1;
  uStackX_18 = (ulong long)uVar19;
  lStack_1d0 = lStack_1d0 + 1;
  if (*piVar1 <= (int)uVar19) goto LAB_18007a5ac;
  goto LAB_180079e40;
}




// 函数: void FUN_18007b1a0(long long *param_1)
void FUN_18007b1a0(long long *param_1)

{
  long long *plVar1;
  
  for (plVar1 = (long long *)*param_1; plVar1 != (long long *)param_1[1]; plVar1 = plVar1 + 4) {
    if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}




// 函数: void FUN_18007b1c0(long long *param_1)
void FUN_18007b1c0(long long *param_1)

{
  long long *plVar1;
  
  for (plVar1 = (long long *)*param_1; plVar1 != (long long *)param_1[1]; plVar1 = plVar1 + 4) {
    if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
  }
  if (*param_1 == 0) {
    return;
  }
                    // WARNING: Subroutine does not return
  FUN_18064e900();
}



uint8_t FUN_18007b1e0(long long param_1)

{
  char systemNodeFlag;
  long long lVar2;
  
  lVar2 = *(long long *)(param_1 + 0x1b8);
  cVar1 = *(char *)(lVar2 + 0x38c);
  if (cVar1 == '\t') {
    cVar1 = func_0x00018022d300();
    *(char *)(lVar2 + 0x38c) = cVar1;
  }
  cVar1 = FUN_18007b240(param_1,param_1 + 0x1e8,cVar1);
  if (cVar1 == '\0') {
    *(byte *)(param_1 + 0xfe) = *(byte *)(param_1 + 0xfe) & 0xfb;
    return 0;
  }
  return 1;
}



// WARNING: Removing unreachable block (ram,0x00018007b857)
// WARNING: Removing unreachable block (ram,0x00018007b868)
// WARNING: Removing unreachable block (ram,0x00018007b879)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulong long FUN_18007b240(long long param_1,long long *param_2,byte param_3,char param_4)

{
  byte *pbVar1;
  char cVar2;
  int memoryCompareResult;
  int iVar4;
  byte bVar5;
  long long lVar6;
  void** systemCurrentNode;
  ulong long uVar8;
  void* uVar9;
  long long *plVar10;
  long long *plVar11;
  long long *plVar12;
  uint32_t uVar13;
  long long *plVar14;
  bool bVar15;
  long long *plStack_f0;
  long long *plStack_e8;
  long long *plStack_e0;
  long long *plStack_d8;
  long long *plStack_d0;
  long long *plStack_c8;
  long long *plStack_c0;
  long long *plStack_b8;
  uint8_t auStack_b0 [8];
  long long lStack_a8;
  uint32_t uStack_a0;
  long long *plStack_98;
  long long lStack_90;
  uint32_t uStack_88;
  long long *aplStack_78 [2];
  code *pcStack_68;
  undefined *puStack_60;
  void* uStack_58;
  long long *plStack_50;
  long long *plStack_48;
  long long *plStack_40;
  
  uStack_58 = 0xfffffffffffffffe;
  while ((lVar6 = param_1, (*(byte *)(param_1 + 0xfd) & 0x20) == 0 &&
         (lVar6 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0)), lVar6 != param_1))) {
    if ((param_4 != '\0') ||
       (pbVar1 = (byte *)(param_1 + 0x100), param_1 = lVar6, (*pbVar1 & 8) != 0)) {
      param_4 = '\x01';
      param_1 = lVar6;
    }
  }
  if ((*(byte *)(param_1 + 0x100) & 8) != 0) {
    param_4 = '\x01';
  }
  FUN_18007baa0(param_1);
  plVar14 = (long long *)(*(long long *)(lVar6 + 0x1e0) + (ulong long)param_3 * 0x18);
  if ((long long *)*param_2 != plVar14) {
    if ((long long *)*param_2 != (long long *)0x0) {
      FUN_180080060();
    }
    *param_2 = (long long)plVar14;
    if (plVar14 != (long long *)0x0) {
      LOCK();
      *(int *)(plVar14 + 2) = (int)plVar14[2] + 1;
      UNLOCK();
    }
    if (param_2[1] != 0) {
      pbVar1 = (byte *)(param_2[1] + 0xfe);
      *pbVar1 = *pbVar1 & 0xfb;
    }
  }
  LOCK();
  bVar15 = *(char *)((long long)plVar14 + 0x15) == '\0';
  if (bVar15) {
    *(char *)((long long)plVar14 + 0x15) = '\x01';
  }
  UNLOCK();
  if (!bVar15) goto LAB_18007b8fd;
  lVar6 = param_1;
  if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
    lVar6 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  if (*(int *)(lVar6 + 0x200) < 1) {
    LOCK();
    if (*(char *)((long long)plVar14 + 0x15) == '\x01') {
      *(char *)((long long)plVar14 + 0x15) = '\x03';
    }
    UNLOCK();
    goto LAB_18007b8fd;
  }
  if (*plVar14 == 0) {
    systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x28,8,0x20);
    *systemPreviousNode = &UNK_180a21690;
    *systemPreviousNode = &UNK_180a21720;
    *(uint32_t *)(systemPreviousNode + 1) = 0;
    *systemPreviousNode = &UNK_180a00168;
    LOCK();
    *(uint8_t *)(systemPreviousNode + 2) = 0;
    UNLOCK();
    LOCK();
    *(uint32_t *)((long long)systemPreviousNode + 0x14) = 0;
    UNLOCK();
    systemPreviousNode[3] = 0;
    systemPreviousNode[4] = param_1;
    FUN_180056f10(plVar14);
  }
  if (plVar14[1] == 0) {
    systemPreviousNode = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x20,8,0x20);
    *systemPreviousNode = &UNK_180a21690;
    *systemPreviousNode = &UNK_180a21720;
    *(uint32_t *)(systemPreviousNode + 1) = 0;
    *systemPreviousNode = &UNK_180a00100;
    LOCK();
    *(uint32_t *)(systemPreviousNode + 2) = 0;
    UNLOCK();
    systemPreviousNode[3] = 0;
    FUN_180056f10(plVar14 + 1);
  }
  uStack_88 = 1;
  lStack_90 = param_1;
  FUN_18007f770(&lStack_90);
  lVar6 = *(long long *)(param_1 + 0x210);
  if (lVar6 == 0) {
LAB_18007b44a:
    if (*(long long *)(param_1 + 0xa8) == 0) {
LAB_18007b454:
      LOCK();
      *(uint8_t *)((long long)plVar14 + 0x15) = 4;
      UNLOCK();
      uVar8 = FUN_18007f840(&lStack_90);
      return uVar8 & 0xffffffffffffff00;
    }
  }
  else {
    if (*(int *)(lVar6 + 0x60) == 0) goto LAB_18007b454;
    if (lVar6 == 0) goto LAB_18007b44a;
  }
  uVar9 = FUN_18062b1e0(_DAT_180c8ed18,0xa0,8,0x20);
  plVar10 = (long long *)FUN_1800842a0(uVar9);
  plStack_50 = plVar10;
  if (plVar10 != (long long *)0x0) {
    (**(code **)(*plVar10 + 0x28))(plVar10);
  }
  lVar6 = param_1;
  if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
    lVar6 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  *(uint32_t *)(plVar10 + 2) = *(uint32_t *)(lVar6 + 0x200);
  *(byte *)(plVar10 + 0x13) =
       *(byte *)(plVar10 + 0x13) ^ (*(byte *)(param_1 + 0xfe) >> 1 ^ *(byte *)(plVar10 + 0x13)) & 1;
  *(byte *)((long long)plVar10 + 0x14) = param_3;
  cVar2 = *(char *)(param_1 + 0xfa);
  *(char *)((long long)plVar10 + 0x15) = cVar2;
  if (cVar2 == '\x01') {
    param_4 = '\x01';
  }
  plVar11 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x30,8,0x20);
  *plVar11 = (long long)&UNK_180a21690;
  *plVar11 = (long long)&UNK_180a21720;
  *(uint32_t *)(plVar11 + 1) = 0;
  *plVar11 = (long long)&UNK_180a00030;
  plVar11[4] = 0;
  plVar11[2] = 0;
  *(byte *)(plVar11 + 5) = *(byte *)(plVar11 + 5) | 1;
  plStack_48 = plVar11;
  (**(code **)(*plVar11 + 0x28))(plVar11);
  bVar5 = *(byte *)(param_1 + 0xfd) & 0x20;
  lVar6 = param_1;
  if (bVar5 == 0) {
    lVar6 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  iVar3 = *(int *)(lVar6 + 0x200);
  lVar6 = param_1;
  if (bVar5 == 0) {
    lVar6 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  iVar4 = *(int *)(lVar6 + 0x1fc);
  uVar13 = 2;
  if (0xffff < iVar3) {
    uVar13 = 4;
  }
  *(byte *)(plVar11 + 5) =
       *(byte *)(plVar11 + 5) ^ (*(byte *)(param_1 + 0xfe) >> 1 ^ *(byte *)(plVar11 + 5)) & 1;
  *(uint32_t *)((long long)plVar11 + 0x14) = uVar13;
  *(int *)(plVar11 + 2) = iVar4 * 3;
  *(uint8_t *)(plVar11 + 3) = *(uint8_t *)(param_1 + 0xfa);
  if ((*(long long *)(param_1 + 0xa8) == 0) || (*(long long *)(param_1 + 0x210) != 0)) {
    if (param_4 == '\0') {
      uVar9 = FUN_18062b1e0(_DAT_180c8ed18,0xe0,8,3);
      (**(code **)(*plVar10 + 0x28))(plVar10);
      (**(code **)(*plVar11 + 0x28))(plVar11);
      pcStack_68 = FUN_180083390;
      puStack_60 = &UNK_180083380;
      plStack_b8 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x20,8,DAT_180bf65bc);
      *plStack_b8 = param_1;
      *(byte *)(plStack_b8 + 1) = param_3;
      plStack_b8[2] = (long long)plVar10;
      plStack_b8[3] = (long long)plVar11;
      aplStack_78[0] = plStack_b8;
      plVar12 = (long long *)FUN_18006b640(uVar9,aplStack_78);
      plStack_c0 = plVar12;
      plStack_40 = plVar12;
      uVar9 = _DAT_180c82868;
      if (plVar12 != (long long *)0x0) {
        (**(code **)(*plVar12 + 0x28))(plVar12);
        uVar9 = _DAT_180c82868;
        (**(code **)(*plVar12 + 0x28))(plVar12);
      }
      FUN_18005e450(uVar9,&plStack_c0);
      if (plVar12 != (long long *)0x0) {
        lVar6 = *plVar12;
LAB_18007b8dc:
        (**(code **)(lVar6 + 0x38))(plVar12);
      }
    }
    else {
      plStack_e0 = plVar11;
      (**(code **)(*plVar11 + 0x28))(plVar11);
      plStack_d8 = plVar10;
      (**(code **)(*plVar10 + 0x28))(plVar10);
      FUN_18007e080(param_1,param_3,&plStack_d8,&plStack_e0);
      plStack_d0 = plVar11;
      (**(code **)(*plVar11 + 0x28))(plVar11);
      plStack_c8 = plVar10;
      (**(code **)(*plVar10 + 0x28))(plVar10);
      FUN_18007c8e0(param_1,param_3,&plStack_c8,&plStack_d0);
      FUN_18007f840(&lStack_90);
      if (*(char *)(param_1 + 0xf4) == '\x01') {
        plStack_b8 = (long long *)0x0;
        plStack_98 = (long long *)0x0;
        auStack_b0[0] = 0;
        uStack_a0 = 3;
        lStack_a8 = param_1;
        FUN_18007f4c0(auStack_b0);
        plVar12 = plStack_98;
        plStack_98 = (long long *)0x0;
        if (plVar12 != (long long *)0x0) {
          (**(code **)(*plVar12 + 0x38))();
        }
        FUN_18007f6a0(auStack_b0);
        if (plStack_98 != (long long *)0x0) {
          lVar6 = *plStack_98;
          plVar12 = plStack_98;
          goto LAB_18007b8dc;
        }
      }
    }
  }
  else {
    plStack_f0 = plVar10;
    (**(code **)(*plVar10 + 0x28))(plVar10);
    plStack_e8 = plVar11;
    (**(code **)(*plVar11 + 0x28))(plVar11);
    FUN_18007c490(param_1,param_3,&plStack_e8,&plStack_f0,param_4);
  }
  (**(code **)(*plVar11 + 0x38))(plVar11);
  (**(code **)(*plVar10 + 0x38))(plVar10);
  FUN_18007f840(&lStack_90);
LAB_18007b8fd:
  return (ulong long)((byte)(*(char *)((long long)plVar14 + 0x15) - 2U) < 2);
}




// 函数: void FUN_18007b930(long long *param_1)
void FUN_18007b930(long long *param_1)

{
  long long lVar1;
  long long *plVar2;
  long long *plStackX_8;
  long long *plStackX_10;
  long long **pplStackX_18;
  long long **pplStackX_20;
  void* uVar3;
  uint8_t auStack_40 [8];
  long long lStack_38;
  uint32_t uStack_30;
  long long *plStack_28;
  
  uVar3 = 0xfffffffffffffffe;
  lVar1 = *param_1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)param_1[3];
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  pplStackX_20 = &plStackX_10;
  plStackX_10 = (long long *)param_1[2];
  if (plStackX_10 != (long long *)0x0) {
    (**(code **)(*plStackX_10 + 0x28))();
  }
  FUN_18007e080(lVar1,(char)param_1[1],&plStackX_10,&plStackX_8,uVar3);
  lVar1 = *param_1;
  pplStackX_18 = &plStackX_8;
  plStackX_8 = (long long *)param_1[3];
  if (plStackX_8 != (long long *)0x0) {
    (**(code **)(*plStackX_8 + 0x28))();
  }
  pplStackX_20 = &plStackX_10;
  plStackX_10 = (long long *)param_1[2];
  if (plStackX_10 != (long long *)0x0) {
    (**(code **)(*plStackX_10 + 0x28))();
  }
  FUN_18007c8e0(lVar1,(char)param_1[1],&plStackX_10,&plStackX_8);
  lStack_38 = *param_1;
  if (*(char *)(lStack_38 + 0xf4) == '\x01') {
    plStackX_8 = (long long *)0x0;
    plStack_28 = (long long *)0x0;
    auStack_40[0] = 0;
    uStack_30 = 3;
    FUN_18007f4c0(auStack_40);
    plVar2 = plStack_28;
    plStackX_10 = plStack_28;
    plStack_28 = (long long *)0x0;
    if (plVar2 != (long long *)0x0) {
      (**(code **)(*plVar2 + 0x38))();
    }
    FUN_18007f6a0(auStack_40);
    if (plStack_28 != (long long *)0x0) {
      (**(code **)(*plStack_28 + 0x38))();
    }
  }
  return;
}




// 函数: void FUN_18007ba60(long long param_1)
void FUN_18007ba60(long long param_1)

{
  if (*(long long **)(param_1 + 0x18) != (long long *)0x0) {
    (**(code **)(**(long long **)(param_1 + 0x18) + 0x38))();
  }
  if (*(long long **)(param_1 + 0x10) != (long long *)0x0) {
    (**(code **)(**(long long **)(param_1 + 0x10) + 0x38))();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007baa0(long long param_1)
void FUN_18007baa0(long long param_1)

{
  void* uVar1;
  
  if (*(long long *)(param_1 + 0x1e0) == 0) {
    uVar1 = FUN_18062b1e0(_DAT_180c8ed18,0x180,8,0x1c);
                    // WARNING: Subroutine does not return
    memset(uVar1,0,0x180);
  }
  return;
}




// 函数: void FUN_18007bb70(long long *param_1)
void FUN_18007bb70(long long *param_1)

{
  if ((long long *)param_1[1] != (long long *)0x0) {
    (**(code **)(*(long long *)param_1[1] + 0x38))();
  }
  if ((long long *)*param_1 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_1 + 0x38))();
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x00018007c17d)
// WARNING: Removing unreachable block (ram,0x00018007c188)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007bbb0(long long param_1,long long param_2,long long param_3)
void FUN_18007bbb0(long long param_1,long long param_2,long long param_3)

{
  int iVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  void* uVar5;
  long long *plVar6;
  long long lVar7;
  long long *plVar8;
  void* *puVar9;
  uint *puVar10;
  uint uVar11;
  undefined *puVar12;
  uint uVar13;
  uint uVar14;
  ulong long uVar15;
  uint uVar16;
  uint uVar17;
  uint8_t auStack_68 [32];
  void* uStack_48;
  long long *plStack_40;
  void* uStack_38;
  long long *plStack_30;
  long long lStack_28;
  ulong long uStack_20;
  
  uStack_48 = 0xfffffffffffffffe;
  uStack_20 = _DAT_180bf00a8 ^ (ulong long)auStack_68;
  if ((param_2 == 0) ||
     (((*(float *)(param_1 + 0x238) == *(float *)(param_2 + 0x44) &&
       (*(float *)(param_1 + 0x23c) == *(float *)(param_2 + 0x48))) &&
      (*(float *)(param_1 + 0x240) == *(float *)(param_2 + 0x4c))))) {
    uVar5 = *(void* *)(param_3 + 0x4c);
    *(void* *)(param_1 + 0x238) = *(void* *)(param_3 + 0x44);
    *(void* *)(param_1 + 0x240) = uVar5;
  }
  if ((param_2 == 0) ||
     (((*(float *)(param_1 + 0x248) == *(float *)(param_2 + 0x54) &&
       (*(float *)(param_1 + 0x24c) == *(float *)(param_2 + 0x58))) &&
      (*(float *)(param_1 + 0x250) == *(float *)(param_2 + 0x5c))))) {
    uVar5 = *(void* *)(param_3 + 0x5c);
    *(void* *)(param_1 + 0x248) = *(void* *)(param_3 + 0x54);
    *(void* *)(param_1 + 0x250) = uVar5;
  }
  if ((param_2 == 0) ||
     (((*(float *)(param_1 + 0x2a8) == *(float *)(param_2 + 100) &&
       (*(float *)(param_1 + 0x2ac) == *(float *)(param_2 + 0x68))) &&
      (*(float *)(param_1 + 0x2b0) == *(float *)(param_2 + 0x6c))))) {
    uVar5 = *(void* *)(param_3 + 0x6c);
    *(void* *)(param_1 + 0x2a8) = *(void* *)(param_3 + 100);
    *(void* *)(param_1 + 0x2b0) = uVar5;
  }
  if ((param_2 == 0) ||
     (((*(float *)(param_1 + 0x2b8) == *(float *)(param_2 + 0x74) &&
       (*(float *)(param_1 + 700) == *(float *)(param_2 + 0x78))) &&
      (*(float *)(param_1 + 0x2c0) == *(float *)(param_2 + 0x7c))))) {
    uVar5 = *(void* *)(param_3 + 0x7c);
    *(void* *)(param_1 + 0x2b8) = *(void* *)(param_3 + 0x74);
    *(void* *)(param_1 + 0x2c0) = uVar5;
  }
  if (param_2 == 0) {
    *(uint32_t *)(param_1 + 0x100) = *(uint32_t *)(param_3 + 0x30);
  }
  else {
    uVar17 = 1;
    uVar11 = 2;
    do {
      puVar10 = (uint *)(param_1 + 0x100);
      uVar16 = *(uint *)(param_2 + 0x30);
      uVar14 = *(uint *)(param_3 + 0x30);
      if ((uVar17 & uVar16) != (uVar17 & uVar14)) {
        if ((uVar17 & uVar14) == 0) {
          uVar16 = *(uint *)(param_1 + 0x100) & ~(1 << (uVar11 - 2 & 0x1f));
        }
        else {
          uVar16 = *puVar10 | 1 << (uVar11 - 2 & 0x1f);
        }
        *puVar10 = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 1 & uVar14;
      if ((uVar17 << 1 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 - 1 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 - 1 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 2 & uVar14;
      if ((uVar17 << 2 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 3 & uVar14;
      if ((uVar17 << 3 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 1 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 1 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 4 & uVar14;
      if ((uVar17 << 4 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 2 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 2 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 5 & uVar14;
      if ((uVar17 << 5 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          *puVar10 = *puVar10 & ~(1 << (uVar11 + 3 & 0x1f));
          uVar16 = *(uint *)(param_2 + 0x30);
          uVar14 = *(uint *)(param_3 + 0x30);
        }
        else {
          *(uint *)(param_1 + 0x100) = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 3 & 0x1f);
          uVar16 = *(uint *)(param_2 + 0x30);
          uVar14 = *(uint *)(param_3 + 0x30);
        }
      }
      puVar10 = (uint *)(param_1 + 0x100);
      uVar13 = uVar17 << 6 & uVar14;
      if ((uVar17 << 6 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 4 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 4 & 0x1f);
        }
        *puVar10 = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 7 & uVar14;
      if ((uVar17 << 7 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 5 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 5 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 8 & uVar14;
      if ((uVar17 << 8 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 6 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 6 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 9 & uVar14;
      if ((uVar17 << 9 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 7 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 7 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar13 = uVar17 << 10 & uVar14;
      if ((uVar17 << 10 & uVar16) != uVar13) {
        if (uVar13 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 8 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 8 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
        uVar16 = *(uint *)(param_2 + 0x30);
        uVar14 = *(uint *)(param_3 + 0x30);
      }
      uVar14 = uVar17 << 0xb & uVar14;
      if ((uVar17 << 0xb & uVar16) != uVar14) {
        if (uVar14 == 0) {
          uVar16 = *puVar10 & ~(1 << (uVar11 + 9 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 9 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
      }
      uVar16 = uVar17 << 0xc & *(uint *)(param_3 + 0x30);
      if ((uVar17 << 0xc & *(uint *)(param_2 + 0x30)) != uVar16) {
        if (uVar16 == 0) {
          uVar16 = *(uint *)(param_1 + 0x100) & ~(1 << (uVar11 + 10 & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 10 & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
      }
      uVar16 = uVar17 << 0xd & *(uint *)(param_3 + 0x30);
      if ((uVar17 << 0xd & *(uint *)(param_2 + 0x30)) != uVar16) {
        if (uVar16 == 0) {
          uVar16 = *(uint *)(param_1 + 0x100) & ~(1 << (uVar11 + 0xb & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 0xb & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
      }
      uVar16 = uVar17 << 0xe & *(uint *)(param_3 + 0x30);
      if ((uVar17 << 0xe & *(uint *)(param_2 + 0x30)) != uVar16) {
        puVar10 = (uint *)(param_1 + 0x100);
        if (uVar16 == 0) {
          *puVar10 = *puVar10 & ~(1 << (uVar11 + 0xc & 0x1f));
        }
        else {
          *puVar10 = *puVar10 | 1 << (uVar11 + 0xc & 0x1f);
        }
      }
      uVar16 = uVar17 << 0xf & *(uint *)(param_3 + 0x30);
      if ((uVar17 << 0xf & *(uint *)(param_2 + 0x30)) != uVar16) {
        if (uVar16 == 0) {
          uVar16 = *(uint *)(param_1 + 0x100) & ~(1 << (uVar11 + 0xd & 0x1f));
        }
        else {
          uVar16 = *(uint *)(param_1 + 0x100) | 1 << (uVar11 + 0xd & 0x1f);
        }
        *(uint *)(param_1 + 0x100) = uVar16;
      }
      uVar17 = uVar17 << 0x10 | uVar17 >> 0x10;
      iVar1 = uVar11 + 0xe;
      uVar11 = uVar11 + 0x10;
    } while (iVar1 < 0x20);
  }
  *(uint32_t *)(param_1 + 0x208) = *(uint32_t *)(param_3 + 0x84);
  *(uint32_t *)(param_1 + 0x1f8) = *(uint32_t *)(param_3 + 0x88);
  *(uint32_t *)(param_1 + 0x1fc) = *(uint32_t *)(param_3 + 0x8c);
  *(uint32_t *)(param_1 + 0x200) = *(uint32_t *)(param_3 + 0x90);
  *(uint32_t *)(param_1 + 0x204) = *(uint32_t *)(param_3 + 0x94);
  uVar5 = *(void* *)(param_3 + 0xa0);
  *(void* *)(param_1 + 0x274) = *(void* *)(param_3 + 0x98);
  *(void* *)(param_1 + 0x27c) = uVar5;
  uVar5 = *(void* *)(param_3 + 0xb0);
  *(void* *)(param_1 + 0x284) = *(void* *)(param_3 + 0xa8);
  *(void* *)(param_1 + 0x28c) = uVar5;
  uVar2 = *(uint32_t *)(param_3 + 0xbc);
  uVar3 = *(uint32_t *)(param_3 + 0xc0);
  uVar4 = *(uint32_t *)(param_3 + 0xc4);
  *(uint32_t *)(param_1 + 0x294) = *(uint32_t *)(param_3 + 0xb8);
  *(uint32_t *)(param_1 + 0x298) = uVar2;
  *(uint32_t *)(param_1 + 0x29c) = uVar3;
  *(uint32_t *)(param_1 + 0x2a0) = uVar4;
  *(uint32_t *)(param_1 + 0x2a4) = *(uint32_t *)(param_3 + 200);
  plStack_30 = (long long *)0x0;
  lStack_28 = 0;
  if (param_2 != 0) {
    plVar6 = (long long *)(param_2 + 0x158);
    if ((*plVar6 == 0) && (*(long long *)(param_2 + 0x160) == 0)) {
      plVar6 = (long long *)(param_2 + 0x34);
    }
    plStack_30 = (long long *)*plVar6;
    lStack_28 = plVar6[1];
  }
  uStack_38 = 0;
  plVar6 = (long long *)(param_1 + 0x1b8);
  plStack_40 = (long long *)*plVar6;
  *plVar6 = 0;
  if (plStack_40 != (long long *)0x0) {
    (**(code **)(*plStack_40 + 0x38))();
  }
  plVar8 = (long long *)(param_3 + 0x158);
  if ((*plVar8 == 0) && (*(long long *)(param_3 + 0x160) == 0)) {
    plVar8 = (long long *)(param_3 + 0x34);
  }
  lVar7 = FUN_180255f80(*(void* *)(param_1 + 0xa8),&DAT_180a002e0,plVar8);
  if (lVar7 != 0) {
    FUN_180080810(plVar6,lVar7 + 0xb0);
  }
  if (*plVar6 == 0) {
    puVar12 = &SystemStringTemplate;
    if (*(undefined **)(param_1 + 0x18) != (undefined *)0x0) {
      puVar12 = *(undefined **)(param_1 + 0x18);
    }
    FUN_180627020(&UNK_1809ffb88,puVar12);
    plVar8 = (long long *)FUN_1800be9a0(_DAT_180c86898,&plStack_30,0);
    lVar7 = *plVar8;
    *plVar8 = 0;
    plStack_40 = (long long *)*plVar6;
    *plVar6 = lVar7;
    if (plStack_40 != (long long *)0x0) {
      (**(code **)(*plStack_40 + 0x38))();
    }
    if (plStack_30 != (long long *)0x0) {
      (**(code **)(*plStack_30 + 0x38))();
    }
  }
  FUN_1800781e0(param_1);
  if ((*(long long *)(param_1 + 600) == 0) &&
     ((*(uint *)(*(long long *)(param_1 + 0x1b8) + 0x388) >> 0x19 & 1) != 0)) {
    puVar9 = (void* *)FUN_18062b1e0(_DAT_180c8ed18,0x58,8,0x1c);
    *(void* *)((long long)puVar9 + 0x2c) = 0xffffffffffffffff;
    *(uint32_t *)(puVar9 + 9) = 0xffffffff;
    *puVar9 = 0;
    puVar9[2] = 0;
    puVar9[7] = 0;
    *(uint32_t *)(puVar9 + 5) = 0xffffffff;
    *(uint32_t *)(puVar9 + 4) = 0xffffffff;
    puVar9[3] = 0;
    *(uint32_t *)(puVar9 + 8) = 0;
    *(uint32_t *)(puVar9 + 1) = 0;
    *(uint8_t *)((long long)puVar9 + 0x44) = 0;
    *(uint8_t *)((long long)puVar9 + 0x24) = 0;
    *(void* **)(param_1 + 600) = puVar9;
  }
  *(uint8_t *)(param_1 + 0xf6) = *(uint8_t *)(param_3 + 0xcc);
  if ((void* *)(param_1 + 0x218) != (void* *)(param_3 + 0xd0)) {
    FUN_1800588c0((void* *)(param_1 + 0x218),*(void* *)(param_3 + 0xd0),
                  *(void* *)(param_3 + 0xd8));
  }
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x10) = *(uint32_t *)(param_3 + 0xf0);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x14) = *(uint32_t *)(param_3 + 0x144);
  *(uint8_t *)(*(long long *)(param_1 + 0x268) + 0x18) = *(uint8_t *)(param_3 + 0x148);
  *(uint8_t *)(*(long long *)(param_1 + 0x268) + 0x19) = *(uint8_t *)(param_3 + 0x149);
  *(uint8_t *)(*(long long *)(param_1 + 0x268) + 0x1a) = *(uint8_t *)(param_3 + 0x14a);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x44) = *(uint32_t *)(param_3 + 0x118);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x48) = *(uint32_t *)(param_3 + 0x11c);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x4c) = *(uint32_t *)(param_3 + 0x120);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x50) = *(uint32_t *)(param_3 + 0x124);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x54) = *(uint32_t *)(param_3 + 0x128);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x58) = *(uint32_t *)(param_3 + 300);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x5c) = *(uint32_t *)(param_3 + 0x130);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x60) = *(uint32_t *)(param_3 + 0x134);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 100) = *(uint32_t *)(param_3 + 0x138);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x68) = *(uint32_t *)(param_3 + 0x13c);
  *(uint32_t *)(*(long long *)(param_1 + 0x268) + 0x6c) = *(uint32_t *)(param_3 + 0x140);
  lVar7 = *(long long *)(param_1 + 0x268);
  uVar11 = *(uint *)(param_3 + 0x108);
  uVar15 = (ulong long)uVar11;
  if (*(long long *)(param_3 + 0x100) != 0) {
    FUN_1806277c0(lVar7 + 0x20,uVar15);
  }
  if (uVar11 != 0) {
                    // WARNING: Subroutine does not return
    memcpy(*(void* *)(lVar7 + 0x28),*(void* *)(param_3 + 0x100),uVar15);
  }
  *(uint32_t *)(lVar7 + 0x30) = 0;
  if (*(long long *)(lVar7 + 0x28) != 0) {
    *(uint8_t *)(uVar15 + *(long long *)(lVar7 + 0x28)) = 0;
  }
  *(uint32_t *)(lVar7 + 0x3c) = *(uint32_t *)(param_3 + 0x114);
                    // WARNING: Subroutine does not return
  FUN_1808fc050(uStack_20 ^ (ulong long)auStack_68);
}




// 函数: void FUN_18007c490(long long *param_1,byte param_2,long long *param_3,long long *param_4,char param_5)
void FUN_18007c490(long long *param_1,byte param_2,long long *param_3,long long *param_4,char param_5)

{
  char *pcVar1;
  long long *plVar2;
  long long *plVar3;
  long long* systemMemoryPointer;
  code *pcVar5;
  char cVar6;
  undefined *systemPreviousNode;
  uint32_t uStack_100;
  uint32_t uStack_fc;
  uint32_t uStack_f8;
  uint32_t uStack_f4;
  code *pcStack_f0;
  undefined *puStack_e8;
  void* uStack_e0;
  uint32_t uStack_d8;
  uint32_t uStack_d4;
  long long *plStack_d0;
  byte bStack_c8;
  long long *plStack_c0;
  long long *plStack_b8;
  long long *plStack_b0;
  byte bStack_a8;
  long long *plStack_a0;
  long long *plStack_98;
  void* stackParameterC;
  long long **pplStack_88;
  uint8_t auStack_80 [16];
  code *pcStack_70;
  uint8_t auStack_60 [16];
  code *pcStack_50;
  
  stackParameterC = 0xfffffffffffffffe;
  plVar2 = (long long *)*param_4;
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x28))(plVar2);
  }
  plVar3 = (long long *)*param_3;
  if (plVar3 != (long long *)0x0) {
    (**(code **)(*plVar3 + 0x28))(plVar3);
  }
  uStack_d8 = CONCAT31(uStack_d8._1_3_,param_2);
  uStack_e0 = param_1;
  if ((undefined *)*param_1 == &UNK_180a00270) {
    LOCK();
    *(int *)(param_1 + 1) = (int)param_1[1] + 1;
    UNLOCK();
  }
  else {
    (**(code **)((undefined *)*param_1 + 0x28))(param_1);
  }
  if (param_5 == '\0') {
    plVar4 = *(long long **)(param_1[0x15] + 0x88);
    pcVar5 = *(code **)(*plVar4 + 0x70);
    pcStack_f0 = (code *)&UNK_180083180;
    puStack_e8 = &UNK_180083170;
    uStack_100 = (uint32_t)uStack_e0;
    uStack_fc = uStack_e0._4_4_;
    uStack_f8 = uStack_d8;
    uStack_f4 = uStack_d4;
    plStack_b0 = param_1;
    bStack_a8 = param_2;
    plStack_a0 = plVar2;
    if (plVar2 != (long long *)0x0) {
      (**(code **)(*plVar2 + 0x28))(plVar2);
    }
    plStack_98 = plVar3;
    if (plVar3 != (long long *)0x0) {
      (**(code **)(*plVar3 + 0x28))(plVar3);
    }
    FUN_180081120(auStack_60,&plStack_b0);
    (*pcVar5)(plVar4,&DAT_1809fc768,param_1 + 0x17,0,auStack_60,&uStack_100);
    if (pcStack_50 != (code *)0x0) {
      (*pcStack_50)(auStack_60,0,0);
    }
    if (pcStack_f0 != (code *)0x0) {
      (*pcStack_f0)(&uStack_100,0,0);
    }
  }
  else {
    plVar4 = *(long long **)(param_1[0x15] + 0x88);
    pcVar5 = *(code **)(*plVar4 + 0x60);
    pplStack_88 = &plStack_d0;
    plStack_d0 = param_1;
    bStack_c8 = param_2;
    plStack_c0 = plVar2;
    if (plVar2 != (long long *)0x0) {
      (**(code **)(*plVar2 + 0x28))(plVar2);
    }
    plStack_b8 = plVar3;
    if (plVar3 != (long long *)0x0) {
      (**(code **)(*plVar3 + 0x28))(plVar3);
    }
    FUN_180081120(auStack_80,&plStack_d0);
    cVar6 = (*pcVar5)(plVar4,&DAT_1809fc768,param_1 + 0x17,0,auStack_80);
    if (pcStack_70 != (code *)0x0) {
      (*pcStack_70)(auStack_80,0,0);
    }
    if (cVar6 == '\0') {
      systemPreviousNode = &SystemStringTemplate;
      if ((undefined *)param_1[3] != (undefined *)0x0) {
        systemPreviousNode = (undefined *)param_1[3];
      }
      FUN_180626f80(&UNK_1809ffbb0,systemPreviousNode);
      pcVar1 = (char *)(param_1[0x3c] + 0x15 + (ulong long)param_2 * 0x18);
      LOCK();
      if (*pcVar1 == '\x01') {
        *pcVar1 = '\x04';
      }
      UNLOCK();
      (**(code **)(*param_1 + 0x38))(param_1);
    }
  }
  if (plVar3 != (long long *)0x0) {
    (**(code **)(*plVar3 + 0x38))(plVar3);
  }
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))(plVar2);
  }
  if ((long long *)*param_3 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_3 + 0x38))();
  }
  if ((long long *)*param_4 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_4 + 0x38))();
  }
  return;
}




// 函数: void FUN_18007c790(long long *param_1)
void FUN_18007c790(long long *param_1)

{
  char *pcVar1;
  undefined *puVar2;
  
  puVar2 = &SystemStringTemplate;
  if (*(undefined **)(*param_1 + 0x18) != (undefined *)0x0) {
    puVar2 = *(undefined **)(*param_1 + 0x18);
  }
  FUN_180626f80(&UNK_1809ffbb0,puVar2);
  pcVar1 = (char *)(*(long long *)(*param_1 + 0x1e0) + 0x15 +
                   (ulong long)*(byte *)(param_1 + 1) * 0x18);
  LOCK();
  if (*pcVar1 == '\x01') {
    *pcVar1 = '\x04';
  }
  UNLOCK();
                    // WARNING: Could not recover jumptable at 0x00018007c7e6. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(*(long long *)*param_1 + 0x38))();
  return;
}



void* * FUN_18007c7f0(void* *param_1,void* *param_2)

{
  long long *plVar1;
  
  *param_1 = *param_2;
  *(uint8_t *)(param_1 + 1) = *(uint8_t *)(param_2 + 1);
  plVar1 = (long long *)param_2[2];
  param_1[2] = plVar1;
  if (plVar1 != (long long *)0x0) {
    (**(code **)(*plVar1 + 0x28))();
  }
  plVar1 = (long long *)param_2[3];
  param_1[3] = plVar1;
  if (plVar1 != (long long *)0x0) {
    (**(code **)(*plVar1 + 0x28))();
  }
  return param_1;
}




// 函数: void FUN_18007c860(long long param_1,uint8_t param_2)
void FUN_18007c860(long long param_1,uint8_t param_2)

{
  char systemNodeFlag;
  long long lVar2;
  
  lVar2 = param_1;
  if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
    lVar2 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
  }
  if (0 < *(int *)(lVar2 + 0x200)) {
    lVar2 = *(long long *)(param_1 + 0x1b8);
    cVar1 = *(char *)(lVar2 + 0x38c);
    if (cVar1 == '\t') {
      cVar1 = func_0x00018022d300();
      *(char *)(lVar2 + 0x38c) = cVar1;
    }
    cVar1 = FUN_18007b240(param_1,param_1 + 0x1e8,cVar1,param_2);
    if (cVar1 == '\0') {
      *(byte *)(param_1 + 0xfe) = *(byte *)(param_1 + 0xfe) & 0xfb;
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x00018007cad0)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007c8e0(long long param_1,byte param_2,long long *param_3,long long *param_4)
void FUN_18007c8e0(long long param_1,byte param_2,long long *param_3,long long *param_4)

{
  long long lVar1;
  char *pcVar2;
  int memoryCompareResult;
  int iVar4;
  void* uVar5;
  long long *plVar6;
  long long *plStack_b8;
  long long *plStack_b0;
  long long *plStack_a8;
  long long **pplStack_a0;
  long long lStack_98;
  byte bStack_90;
  long long *plStack_88;
  long long *plStack_80;
  long long lStack_78;
  byte bStack_70;
  long long *plStack_68;
  long long *plStack_60;
  long long *aplStack_58 [2];
  code *pcStack_48;
  code *pcStack_40;
  void* uStack_38;
  long long *plStack_30;
  
  uStack_38 = 0xfffffffffffffffe;
  iVar3 = *(int *)(*(long long *)(*(long long *)(_DAT_180c82868 + 8) + 8) + 0x48);
  iVar4 = _Thrd_id();
  if (iVar4 == iVar3) {
    lVar1 = (ulong long)param_2 * 0x18;
    uVar5 = *(void* *)(*(long long *)(param_1 + 0x1e0) + lVar1);
    pplStack_a0 = &plStack_a8;
    plStack_a8 = (long long *)*param_3;
    if (plStack_a8 != (long long *)0x0) {
      (**(code **)(*plStack_a8 + 0x28))();
    }
    FUN_180255880(uVar5,&plStack_a8);
    uVar5 = *(void* *)(*(long long *)(param_1 + 0x1e0) + 8 + lVar1);
    pplStack_a0 = &plStack_b8;
    plStack_b8 = (long long *)*param_4;
    if (plStack_b8 != (long long *)0x0) {
      (**(code **)(*plStack_b8 + 0x28))();
    }
    FUN_180255b70(uVar5,&plStack_b8);
    pcVar2 = (char *)(*(long long *)(param_1 + 0x1e0) + 0x15 + lVar1);
    LOCK();
    if (*pcVar2 == '\x01') {
      *pcVar2 = '\x03';
    }
    UNLOCK();
  }
  else {
    uVar5 = FUN_18062b1e0(_DAT_180c8ed18,0x40,8,0x20);
    pplStack_a0 = aplStack_58;
    plStack_b0 = &lStack_98;
    plStack_88 = (long long *)*param_3;
    lStack_98 = param_1;
    bStack_90 = param_2;
    if (plStack_88 != (long long *)0x0) {
      (**(code **)(*plStack_88 + 0x28))();
    }
    plStack_80 = (long long *)*param_4;
    if (plStack_80 != (long long *)0x0) {
      (**(code **)(*plStack_80 + 0x28))();
    }
    plStack_b0 = &lStack_98;
    lStack_78 = lStack_98;
    bStack_70 = bStack_90;
    plStack_68 = plStack_88;
    plStack_88 = (long long *)0x0;
    plStack_60 = plStack_80;
    plStack_80 = (long long *)0x0;
    plStack_b8 = &lStack_78;
    pcStack_48 = FUN_180082e70;
    pcStack_40 = FUN_180082da0;
    plStack_a8 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,0x20,8,DAT_180bf65bc);
    *plStack_a8 = lStack_78;
    *(byte *)(plStack_a8 + 1) = bStack_70;
    plStack_a8[2] = (long long)plStack_68;
    plStack_a8[3] = (long long)plStack_60;
    plStack_60 = (long long *)0x0;
    plStack_68 = (long long *)0x0;
    aplStack_58[0] = plStack_a8;
    if (plStack_80 != (long long *)0x0) {
      (**(code **)(*plStack_80 + 0x38))();
    }
    if (plStack_88 != (long long *)0x0) {
      (**(code **)(*plStack_88 + 0x38))();
    }
    plVar6 = (long long *)FUN_18005c2a0(uVar5,aplStack_58);
    plStack_30 = plVar6;
    if (plVar6 != (long long *)0x0) {
      (**(code **)(*plVar6 + 0x28))(plVar6);
    }
    pplStack_a0 = &plStack_b0;
    plStack_b0 = plVar6;
    if (plVar6 != (long long *)0x0) {
      (**(code **)(*plVar6 + 0x28))(plVar6);
    }
    FUN_18005e370(_DAT_180c82868,&plStack_b0);
    pcVar2 = (char *)(*(long long *)(param_1 + 0x1e0) + 0x15 + (ulong long)param_2 * 0x18);
    LOCK();
    if (*pcVar2 == '\x01') {
      *pcVar2 = '\x02';
    }
    UNLOCK();
    if (plVar6 != (long long *)0x0) {
      (**(code **)(*plVar6 + 0x38))(plVar6);
    }
  }
  if ((long long *)*param_3 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_3 + 0x38))();
  }
  if ((long long *)*param_4 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_4 + 0x38))();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007cbb0(uint param_1,long long param_2,long long *param_3,void* param_4)
void FUN_18007cbb0(uint param_1,long long param_2,long long *param_3,void* param_4)

{
  float fVar1;
  int iVar2;
  long long *plVar3;
  long long lVar4;
  bool bVar5;
  ushort uVar6;
  undefined2 uVar7;
  int iVar8;
  uint uVar9;
  long long *plVar10;
  int *piVar11;
  int *piVar12;
  float *pfVar13;
  uint uVar14;
  float *pfVar15;
  uint32_t *puVar16;
  uint32_t *puVar17;
  byte *pbVar18;
  uint8_t *puVar19;
  float *pfVar20;
  long long lVar21;
  long long lVar22;
  uint uVar23;
  long long lVar24;
  long long lVar25;
  ulong long uVar26;
  long long lVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  float fVar31;
  float fVar32;
  float fVar33;
  float fVar34;
  long long *plStackX_20;
  uint32_t uVar35;
  float fStack_128;
  float fStack_124;
  float fStack_120;
  float fStack_11c;
  float fStack_118;
  float fStack_114;
  float fStack_110;
  uint32_t uStack_10c;
  float fStack_108;
  float fStack_104;
  float fStack_100;
  float fStack_fc;
  float fStack_f8;
  float fStack_f4;
  float fStack_f0;
  float fStack_ec;
  float fStack_e8;
  float fStack_e4;
  float fStack_e0;
  float fStack_dc;
  
  lVar21 = 0;
  if (param_1 < 0xe) {
    iVar8 = func_0x000180204ae0(param_1,param_2,param_3,param_4,0,0xfffffffffffffffe);
  }
  else {
    iVar8 = -1;
  }
  iVar2 = *(int *)(param_2 + 0x60);
  lVar27 = (long long)iVar2;
  plVar10 = (long long *)FUN_180081480(_DAT_180c8a998,&plStackX_20,iVar2 * iVar8);
  plVar10 = (long long *)*plVar10;
  if (plVar10 != (long long *)0x0) {
    (**(code **)(*plVar10 + 0x28))(plVar10);
  }
  plVar3 = (long long *)*param_3;
  *param_3 = (long long)plVar10;
  if (plVar3 != (long long *)0x0) {
    (**(code **)(*plVar3 + 0x38))();
  }
  uVar35 = 0;
  if (plStackX_20 != (long long *)0x0) {
    (**(code **)(*plStackX_20 + 0x38))();
  }
  pfVar20 = *(float **)(*param_3 + 0x10);
  switch(param_1) {
  case 0:
    if (0 < iVar2) {
      do {
        *pfVar20 = *(float *)(lVar21 + 0x54 + *(long long *)(param_2 + 0x68));
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 1:
    if (0 < iVar2) {
      do {
        *pfVar20 = *(float *)(lVar21 + 0x58 + *(long long *)(param_2 + 0x68));
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 2:
    if (3 < lVar27) {
      lVar25 = (long long)iVar8;
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x48);
      pfVar13 = (float *)(*(long long *)(param_2 + 0x68) + 0x100);
      lVar22 = (lVar27 - 4U >> 2) + 1;
      lVar21 = lVar22 * 4;
      do {
        *pfVar20 = pfVar15[-1];
        pfVar20[1] = 1.0 - *pfVar15;
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar15[0x16];
        pfVar20[1] = 1.0 - pfVar15[0x17];
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar13[-1];
        pfVar20[1] = 1.0 - *pfVar13;
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar13[0x16];
        pfVar20[1] = 1.0 - pfVar13[0x17];
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        pfVar15 = pfVar15 + 0x5c;
        pfVar13 = pfVar13 + 0x5c;
        lVar22 = lVar22 + -1;
      } while (lVar22 != 0);
    }
    if (lVar21 < lVar27) {
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x48 + lVar21 * 0x5c);
      lVar27 = lVar27 - lVar21;
      do {
        *pfVar20 = pfVar15[-1];
        pfVar20[1] = 1.0 - *pfVar15;
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        pfVar15 = pfVar15 + 0x17;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 3:
    if (3 < lVar27) {
      lVar25 = (long long)iVar8;
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x50);
      pfVar13 = (float *)(*(long long *)(param_2 + 0x68) + 0x108);
      lVar22 = (lVar27 - 4U >> 2) + 1;
      lVar21 = lVar22 * 4;
      do {
        *pfVar20 = pfVar15[-1];
        pfVar20[1] = 1.0 - *pfVar15;
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar15[0x16];
        pfVar20[1] = 1.0 - pfVar15[0x17];
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar13[-1];
        pfVar20[1] = 1.0 - *pfVar13;
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar13[0x16];
        pfVar20[1] = 1.0 - pfVar13[0x17];
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        pfVar15 = pfVar15 + 0x5c;
        pfVar13 = pfVar13 + 0x5c;
        lVar22 = lVar22 + -1;
      } while (lVar22 != 0);
    }
    if (lVar21 < lVar27) {
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x50 + lVar21 * 0x5c);
      lVar27 = lVar27 - lVar21;
      do {
        *pfVar20 = pfVar15[-1];
        pfVar20[1] = 1.0 - *pfVar15;
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        pfVar15 = pfVar15 + 0x17;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 4:
  case 5:
    if ((param_1 == 5) && (0 < *(int *)(param_2 + 0x38))) {
      bVar5 = true;
    }
    else {
      bVar5 = false;
    }
    piVar12 = (int *)(param_2 + 0x38);
    if (!bVar5) {
      piVar12 = (int *)(param_2 + 0x10);
    }
    if (3 < lVar27) {
      lVar25 = *(long long *)(piVar12 + 2);
      lVar24 = (long long)iVar8;
      piVar11 = (int *)(*(long long *)(param_2 + 0x68) + 0xb8);
      lVar22 = (lVar27 - 4U >> 2) + 1;
      lVar21 = lVar22 * 4;
      do {
        *pfVar20 = *(float *)(lVar25 + (long long)piVar11[-0x2e] * 0x10);
        pfVar20[1] = *(float *)(lVar25 + 4 + (long long)piVar11[-0x2e] * 0x10);
        pfVar20[2] = *(float *)(lVar25 + 8 + (long long)piVar11[-0x2e] * 0x10);
        puVar16 = (uint32_t *)((long long)pfVar20 + lVar24);
        *puVar16 = *(uint32_t *)(lVar25 + (long long)piVar11[-0x17] * 0x10);
        puVar16[1] = *(uint32_t *)(lVar25 + 4 + (long long)piVar11[-0x17] * 0x10);
        puVar16[2] = *(uint32_t *)(lVar25 + 8 + (long long)piVar11[-0x17] * 0x10);
        puVar16 = (uint32_t *)((long long)puVar16 + lVar24);
        *puVar16 = *(uint32_t *)(lVar25 + (long long)*piVar11 * 0x10);
        puVar16[1] = *(uint32_t *)(lVar25 + 4 + (long long)*piVar11 * 0x10);
        puVar16[2] = *(uint32_t *)(lVar25 + 8 + (long long)*piVar11 * 0x10);
        puVar16 = (uint32_t *)((long long)puVar16 + lVar24);
        *puVar16 = *(uint32_t *)(lVar25 + (long long)piVar11[0x17] * 0x10);
        puVar16[1] = *(uint32_t *)(lVar25 + 4 + (long long)piVar11[0x17] * 0x10);
        puVar16[2] = *(uint32_t *)(lVar25 + 8 + (long long)piVar11[0x17] * 0x10);
        pfVar20 = (float *)((long long)puVar16 + lVar24);
        piVar11 = piVar11 + 0x5c;
        lVar22 = lVar22 + -1;
      } while (lVar22 != 0);
    }
    if (lVar21 < lVar27) {
      lVar25 = *(long long *)(piVar12 + 2);
      pfVar20 = pfVar20 + 2;
      piVar12 = (int *)(lVar21 * 0x5c + *(long long *)(param_2 + 0x68));
      lVar27 = lVar27 - lVar21;
      do {
        pfVar20[-2] = *(float *)(lVar25 + (long long)*piVar12 * 0x10);
        pfVar20[-1] = *(float *)(lVar25 + 4 + (long long)*piVar12 * 0x10);
        *pfVar20 = *(float *)(lVar25 + 8 + (long long)*piVar12 * 0x10);
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        piVar12 = piVar12 + 0x17;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 6:
    if (3 < lVar27) {
      lVar25 = (long long)iVar8;
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x38);
      puVar16 = (uint32_t *)(*(long long *)(param_2 + 0x68) + 0xf0);
      lVar22 = (lVar27 - 4U >> 2) + 1;
      lVar21 = lVar22 * 4;
      do {
        *pfVar20 = pfVar15[-1];
        pfVar20[1] = *pfVar15;
        pfVar20[2] = pfVar15[1];
        pfVar20 = (float *)((long long)pfVar20 + lVar25);
        *pfVar20 = pfVar15[0x16];
        pfVar20[1] = pfVar15[0x17];
        pfVar20[2] = pfVar15[0x18];
        puVar17 = (uint32_t *)((long long)pfVar20 + lVar25);
        *puVar17 = puVar16[-1];
        puVar17[1] = *puVar16;
        puVar17[2] = puVar16[1];
        puVar17 = (uint32_t *)((long long)puVar17 + lVar25);
        *puVar17 = puVar16[0x16];
        puVar17[1] = puVar16[0x17];
        puVar17[2] = puVar16[0x18];
        pfVar20 = (float *)((long long)puVar17 + lVar25);
        pfVar15 = pfVar15 + 0x5c;
        puVar16 = puVar16 + 0x5c;
        lVar22 = lVar22 + -1;
      } while (lVar22 != 0);
    }
    if (lVar21 < lVar27) {
      pfVar20 = pfVar20 + 2;
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x38 + lVar21 * 0x5c);
      lVar27 = lVar27 - lVar21;
      do {
        pfVar20[-2] = pfVar15[-1];
        pfVar20[-1] = *pfVar15;
        *pfVar20 = pfVar15[1];
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        pfVar15 = pfVar15 + 0x17;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 7:
    if (3 < lVar27) {
      lVar22 = (long long)iVar8;
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 0x14);
      pfVar13 = (float *)(*(long long *)(param_2 + 0x68) + 0xc0);
      lVar25 = (lVar27 - 4U >> 2) + 1;
      lVar21 = lVar25 * 4;
      do {
        *pfVar20 = *pfVar15;
        pfVar20[1] = pfVar15[1];
        pfVar20[2] = pfVar15[2];
        if ((pfVar13[-0x2e] * pfVar13[-0x29] - pfVar13[-0x2d] * pfVar13[-0x2a]) * pfVar15[4] +
            (pfVar13[-0x2d] * *pfVar15 - pfVar15[-4] * pfVar13[-0x29]) * pfVar13[-0x26] +
            (pfVar15[-4] * pfVar13[-0x2a] - *pfVar15 * pfVar13[-0x2e]) * pfVar13[-0x25] <= 0.0) {
          fVar28 = -1.0;
        }
        else {
          fVar28 = 1.0;
        }
        pfVar20[3] = fVar28;
        pfVar20 = (float *)((long long)pfVar20 + lVar22);
        *pfVar20 = pfVar15[0x17];
        pfVar20[1] = pfVar15[0x18];
        pfVar20[2] = pfVar15[0x19];
        if ((pfVar13[-0x17] * pfVar13[-0x12] - pfVar13[-0x16] * pfVar13[-0x13]) * pfVar15[0x1b] +
            (pfVar15[0x17] * pfVar13[-0x16] - pfVar15[0x13] * pfVar13[-0x12]) * pfVar13[-0xf] +
            (pfVar15[0x13] * pfVar13[-0x13] - pfVar15[0x17] * pfVar13[-0x17]) * pfVar13[-0xe] <= 0.0
           ) {
          fVar28 = -1.0;
        }
        else {
          fVar28 = 1.0;
        }
        pfVar20[3] = fVar28;
        pfVar20 = (float *)((long long)pfVar20 + lVar22);
        *pfVar20 = pfVar13[3];
        pfVar20[1] = pfVar13[4];
        pfVar20[2] = pfVar13[5];
        if ((pfVar13[1] * pfVar13[3] - pfVar13[5] * pfVar13[-1]) * pfVar13[8] +
            (pfVar13[5] * *pfVar13 - pfVar13[1] * pfVar13[4]) * pfVar13[7] +
            (pfVar13[4] * pfVar13[-1] - *pfVar13 * pfVar13[3]) * pfVar13[9] <= 0.0) {
          fVar28 = -1.0;
        }
        else {
          fVar28 = 1.0;
        }
        pfVar20[3] = fVar28;
        pfVar20 = (float *)((long long)pfVar20 + lVar22);
        *pfVar20 = pfVar13[0x1a];
        pfVar20[1] = pfVar13[0x1b];
        pfVar20[2] = pfVar13[0x1c];
        if ((pfVar13[0x1c] * pfVar13[0x17] - pfVar13[0x18] * pfVar13[0x1b]) * pfVar13[0x1e] +
            (pfVar13[0x1a] * pfVar13[0x18] - pfVar13[0x1c] * pfVar13[0x16]) * pfVar13[0x1f] +
            (pfVar13[0x16] * pfVar13[0x1b] - pfVar13[0x1a] * pfVar13[0x17]) * pfVar13[0x20] <= 0.0)
        {
          fVar28 = -1.0;
        }
        else {
          fVar28 = 1.0;
        }
        pfVar20[3] = fVar28;
        pfVar20 = (float *)((long long)pfVar20 + lVar22);
        pfVar15 = pfVar15 + 0x5c;
        pfVar13 = pfVar13 + 0x5c;
        lVar25 = lVar25 + -1;
      } while (lVar25 != 0);
    }
    if (lVar21 < lVar27) {
      pfVar20 = pfVar20 + 2;
      pfVar15 = (float *)(*(long long *)(param_2 + 0x68) + 8 + lVar21 * 0x5c);
      lVar27 = lVar27 - lVar21;
      do {
        pfVar20[-2] = pfVar15[3];
        pfVar20[-1] = pfVar15[4];
        *pfVar20 = pfVar15[5];
        if ((pfVar15[5] * *pfVar15 - pfVar15[1] * pfVar15[4]) * pfVar15[7] +
            (pfVar15[3] * pfVar15[1] - pfVar15[-1] * pfVar15[5]) * pfVar15[8] +
            (pfVar15[-1] * pfVar15[4] - pfVar15[3] * *pfVar15) * pfVar15[9] <= 0.0) {
          fVar28 = -1.0;
        }
        else {
          fVar28 = 1.0;
        }
        pfVar20[1] = fVar28;
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        pfVar15 = pfVar15 + 0x17;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 8:
    if (*(int *)(param_2 + 200) < 1) {
code_r0x00018007db1b:
                    // WARNING: Subroutine does not return
      memset(pfVar20,0,(long long)(iVar2 * 4));
    }
    lVar25 = lVar21;
    if (3 < lVar27) {
      lVar24 = (long long)iVar8;
      lVar22 = (lVar27 - 4U >> 2) + 1;
      lVar25 = lVar22 * 4;
      do {
        lVar4 = *(long long *)(param_2 + 0x68);
        *(char *)pfVar20 =
             (char)(int)(*(float *)(*(long long *)(param_2 + 0xd0) +
                                   (long long)*(int *)(lVar21 + lVar4) * 0x14) * 255.0);
        *(char *)((long long)pfVar20 + 1) =
             (char)(int)(*(float *)(*(long long *)(param_2 + 0xd0) + 4 +
                                   (long long)*(int *)(lVar21 + lVar4) * 0x14) * 255.0);
        uVar9 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) + 8 +
                                 (long long)*(int *)(lVar21 + lVar4) * 0x14) * 255.0);
        *(char *)((long long)pfVar20 + 2) = (char)uVar9;
        fVar28 = (float)((uVar9 & 0xff) + (uint)*(byte *)((long long)pfVar20 + 1) +
                        (uint)*(byte *)pfVar20);
        if (0.0 <= fVar28) {
          if (1.0 <= fVar28) {
            fVar28 = 1.0;
          }
        }
        else {
          fVar28 = 0.0;
        }
        *(char *)((long long)pfVar20 + 3) = (char)(int)(1.0 - fVar28);
        pbVar18 = (byte *)((long long)pfVar20 + lVar24);
        lVar4 = *(long long *)(param_2 + 0x68);
        *pbVar18 = (byte)(int)(*(float *)(*(long long *)(param_2 + 0xd0) +
                                         (long long)*(int *)(lVar21 + 0x5c + lVar4) * 0x14) * 255.0);
        pbVar18[1] = (byte)(int)(*(float *)(*(long long *)(param_2 + 0xd0) + 4 +
                                           (long long)*(int *)(lVar21 + 0x5c + lVar4) * 0x14) * 255.0
                                );
        uVar9 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) + 8 +
                                 (long long)*(int *)(lVar21 + 0x5c + lVar4) * 0x14) * 255.0);
        pbVar18[2] = (byte)uVar9;
        fVar28 = (float)((uVar9 & 0xff) + (uint)pbVar18[1] + (uint)*pbVar18);
        if (0.0 <= fVar28) {
          if (1.0 <= fVar28) {
            fVar28 = 1.0;
          }
        }
        else {
          fVar28 = 0.0;
        }
        pbVar18[3] = (byte)(int)(1.0 - fVar28);
        pbVar18 = pbVar18 + lVar24;
        lVar4 = *(long long *)(param_2 + 0x68);
        *pbVar18 = (byte)(int)(*(float *)(*(long long *)(param_2 + 0xd0) +
                                         (long long)*(int *)(lVar21 + 0xb8 + lVar4) * 0x14) * 255.0);
        pbVar18[1] = (byte)(int)(*(float *)(*(long long *)(param_2 + 0xd0) + 4 +
                                           (long long)*(int *)(lVar21 + 0xb8 + lVar4) * 0x14) * 255.0
                                );
        uVar9 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) + 8 +
                                 (long long)*(int *)(lVar21 + 0xb8 + lVar4) * 0x14) * 255.0);
        pbVar18[2] = (byte)uVar9;
        fVar28 = (float)((uVar9 & 0xff) + (uint)pbVar18[1] + (uint)*pbVar18);
        if (0.0 <= fVar28) {
          if (1.0 <= fVar28) {
            fVar28 = 1.0;
          }
        }
        else {
          fVar28 = 0.0;
        }
        pbVar18[3] = (byte)(int)(1.0 - fVar28);
        pbVar18 = pbVar18 + lVar24;
        lVar4 = *(long long *)(param_2 + 0x68);
        *pbVar18 = (byte)(int)(*(float *)(*(long long *)(param_2 + 0xd0) +
                                         (long long)*(int *)(lVar21 + 0x114 + lVar4) * 0x14) * 255.0)
        ;
        pbVar18[1] = (byte)(int)(*(float *)(*(long long *)(param_2 + 0xd0) + 4 +
                                           (long long)*(int *)(lVar21 + 0x114 + lVar4) * 0x14) *
                                255.0);
        uVar9 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) + 8 +
                                 (long long)*(int *)(lVar21 + 0x114 + lVar4) * 0x14) * 255.0);
        pbVar18[2] = (byte)uVar9;
        fVar28 = (float)((uVar9 & 0xff) + (uint)pbVar18[1] + (uint)*pbVar18);
        if (0.0 <= fVar28) {
          if (1.0 <= fVar28) {
            fVar28 = 1.0;
          }
        }
        else {
          fVar28 = 0.0;
        }
        pbVar18[3] = (byte)(int)(1.0 - fVar28);
        pfVar20 = (float *)(pbVar18 + lVar24);
        lVar21 = lVar21 + 0x170;
        lVar22 = lVar22 + -1;
      } while (lVar22 != 0);
    }
    if (lVar25 < lVar27) {
      lVar21 = lVar25 * 0x5c;
      puVar19 = (uint8_t *)((long long)pfVar20 + 2);
      lVar27 = lVar27 - lVar25;
      do {
        lVar25 = *(long long *)(param_2 + 0x68);
        uVar23 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) +
                                  (long long)*(int *)(lVar21 + lVar25) * 0x14) * 255.0);
        puVar19[-2] = (char)uVar23;
        uVar14 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) + 4 +
                                  (long long)*(int *)(lVar21 + lVar25) * 0x14) * 255.0);
        puVar19[-1] = (char)uVar14;
        uVar9 = (uint)(*(float *)(*(long long *)(param_2 + 0xd0) + 8 +
                                 (long long)*(int *)(lVar21 + lVar25) * 0x14) * 255.0);
        *puVar19 = (char)uVar9;
        fVar28 = (float)((uVar9 & 0xff) + (uVar14 & 0xff) + (uVar23 & 0xff));
        if (0.0 <= fVar28) {
          if (1.0 <= fVar28) {
            fVar28 = 1.0;
          }
        }
        else {
          fVar28 = 0.0;
        }
        puVar19[1] = (char)(int)(1.0 - fVar28);
        puVar19 = puVar19 + iVar8;
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 9:
    if (*(int *)(param_2 + 200) < 1) goto code_r0x00018007db1b;
    if (0 < iVar2) {
      do {
        lVar25 = *(long long *)(param_2 + 0x68);
        *(uint8_t *)pfVar20 =
             *(uint8_t *)
              (*(long long *)(param_2 + 0xd0) + 0x10 + (long long)*(int *)(lVar21 + lVar25) * 0x14);
        *(uint8_t *)((long long)pfVar20 + 1) =
             *(uint8_t *)
              (*(long long *)(param_2 + 0xd0) + 0x11 + (long long)*(int *)(lVar21 + lVar25) * 0x14);
        *(uint8_t *)((long long)pfVar20 + 2) =
             *(uint8_t *)
              (*(long long *)(param_2 + 0xd0) + 0x12 + (long long)*(int *)(lVar21 + lVar25) * 0x14);
        *(uint8_t *)((long long)pfVar20 + 3) =
             *(uint8_t *)
              (*(long long *)(param_2 + 0xd0) + 0x13 + (long long)*(int *)(lVar21 + lVar25) * 0x14);
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 10:
    if (0 < iVar2) {
      do {
        lVar25 = *(long long *)(param_2 + 0x68);
        fVar29 = *(float *)(lVar21 + 0x34 + lVar25) * 0.5;
        fVar34 = *(float *)(lVar21 + 0x38 + lVar25) * 0.5;
        fVar28 = *(float *)(lVar21 + 0x3c + lVar25) * 0.5;
        fVar31 = fVar29 + 0.5;
        fVar32 = fVar34 + 0.5;
        fVar33 = fVar28 + 0.5;
        if (-0.5 <= fVar28) {
          if (1.0 <= fVar33) {
            fVar33 = 1.0;
          }
        }
        else {
          fVar33 = 0.0;
        }
        if (-0.5 <= fVar34) {
          if (1.0 <= fVar32) {
            fVar32 = 1.0;
          }
        }
        else {
          fVar32 = 0.0;
        }
        if (-0.5 <= fVar29) {
          if (1.0 <= fVar31) {
            fVar31 = 1.0;
          }
        }
        else {
          fVar31 = 0.0;
        }
        *pfVar20 = (float)(((uint)(long long)(fVar32 * 2047.0) & 0x7ff |
                           (int)(long long)(fVar31 * 2047.0) << 0xb) << 10 |
                          (uint)(long long)(fVar33 * 1023.0) & 0x3ff);
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 0xb:
    if (0 < iVar2) {
      lVar25 = 0x40;
      if (*(int *)(param_2 + 0x38) < 1) {
        lVar25 = 0x18;
      }
      uVar6 = func_0x0001800840d0(0x3f800000);
      uVar26 = (ulong long)uVar6;
      do {
        lVar22 = *(long long *)(param_2 + 0x68);
        uVar7 = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(lVar25 + param_2) +
                                     (long long)*(int *)(lVar21 + lVar22) * 0x10));
        *(undefined2 *)pfVar20 = uVar7;
        uVar7 = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(lVar25 + param_2) + 4 +
                                     (long long)*(int *)(lVar21 + lVar22) * 0x10));
        *(undefined2 *)((long long)pfVar20 + 2) = uVar7;
        uVar7 = func_0x0001800840d0(*(uint32_t *)
                                     (*(long long *)(lVar25 + param_2) + 8 +
                                     (long long)*(int *)(lVar21 + lVar22) * 0x10));
        *(undefined2 *)(pfVar20 + 1) = uVar7;
        *(short *)((long long)pfVar20 + 6) = (short)uVar26;
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 0xc:
    if (0 < iVar2) {
      do {
        lVar25 = *(long long *)(param_2 + 0x68);
        fVar28 = *(float *)(lVar21 + 0x1c + lVar25);
        fVar31 = *(float *)(lVar21 + 0x18 + lVar25);
        fVar32 = *(float *)(lVar21 + 0x14 + lVar25);
        fVar33 = *(float *)(lVar21 + 4 + lVar25);
        fVar34 = fVar32 * 0.5 + 0.5;
        fVar29 = fVar31 * 0.5 + 0.5;
        fVar30 = fVar28 * 0.5 + 0.5;
        if (-0.5 <= fVar28 * 0.5) {
          if (1.0 <= fVar30) {
            fVar30 = 1.0;
          }
        }
        else {
          fVar30 = 0.0;
        }
        if (-0.5 <= fVar31 * 0.5) {
          if (1.0 <= fVar29) {
            fVar29 = 1.0;
          }
        }
        else {
          fVar29 = 0.0;
        }
        if (-0.5 <= fVar32 * 0.5) {
          if (1.0 <= fVar34) {
            fVar34 = 1.0;
          }
        }
        else {
          fVar34 = 0.0;
        }
        uVar9 = 0;
        if ((fVar32 * *(float *)(lVar21 + 0xc + lVar25) - fVar33 * fVar28) *
            *(float *)(lVar21 + 0x28 + lVar25) +
            (fVar28 * *(float *)(lVar21 + 8 + lVar25) - fVar31 * *(float *)(lVar21 + 0xc + lVar25))
            * *(float *)(lVar21 + 0x24 + lVar25) +
            (fVar33 * fVar31 - fVar32 * *(float *)(lVar21 + 8 + lVar25)) *
            *(float *)(lVar21 + 0x2c + lVar25) < 0.0) {
          uVar9 = 0x80000000;
        }
        *pfVar20 = (float)((((uint)(long long)(fVar34 * 1023.0) & 0x3ff) << 0xb |
                           (uint)(long long)(fVar29 * 2047.0) & 0x7ff) << 10 |
                           (uint)(long long)(fVar30 * 1023.0) & 0x3ff | uVar9);
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
    break;
  case 0xd:
    if (0 < iVar2) {
      lVar22 = 0x48;
      lVar25 = *(long long *)((long long)ThreadLocalStoragePointer + (ulong long)__tls_index * 8);
      fVar28 = fRam0000000180d49154;
      do {
        lVar24 = *(long long *)(param_2 + 0x68);
        pfVar15 = (float *)(lVar21 + 0x34 + lVar24);
        fStack_108 = *pfVar15;
        fStack_104 = pfVar15[1];
        fStack_100 = pfVar15[2];
        fStack_fc = pfVar15[3];
        pfVar15 = (float *)(lVar21 + 0x14 + lVar24);
        fStack_f8 = *pfVar15;
        fStack_f4 = pfVar15[1];
        fStack_f0 = pfVar15[2];
        fStack_ec = pfVar15[3];
        pfVar15 = (float *)(lVar21 + 0x24 + lVar24);
        fStack_e8 = *pfVar15;
        fStack_e4 = pfVar15[1];
        fStack_e0 = pfVar15[2];
        fStack_dc = pfVar15[3];
        fVar31 = fStack_100 * fStack_f8 - fStack_f0 * fStack_108;
        if ((fStack_f0 * fStack_104 - fStack_100 * fStack_f4) * fStack_e8 + fStack_e4 * fVar31 +
            fStack_e0 * (fStack_f4 * fStack_108 - fStack_f8 * fStack_104) < 0.0) {
          fStack_e0 = -fStack_e0;
          fStack_118 = -fStack_e8;
          fStack_114 = -fStack_e4;
          uStack_10c = 0x7f7fffff;
          fStack_e8 = -fStack_e8;
          fStack_e4 = -fStack_e4;
          fStack_dc = 3.4028235e+38;
          fStack_110 = fStack_e0;
        }
        FUN_18063b470(&fStack_128,&fStack_108,fStack_e0,fVar31,uVar35);
        FUN_180084000(&fStack_128);
        if (fStack_128 < 0.0) {
          fStack_128 = -fStack_128;
          fStack_124 = -fStack_124;
          fStack_120 = -fStack_120;
          fStack_11c = -fStack_11c;
        }
        fVar34 = fStack_11c;
        fVar33 = fStack_120;
        fVar32 = fStack_124;
        fVar31 = fStack_128;
        if (*(int *)(lVar25 + lVar22) < iRam0000000180d49150) {
          FUN_1808fcb90(0x180d49150);
          if (iRam0000000180d49150 == -1) {
            fRam0000000180d49154 = 1.0;
            FUN_1808fcb30(0x180d49150);
          }
          lVar22 = 0x48;
          fVar28 = fRam0000000180d49154;
        }
        if (fVar31 < 3.051851e-05) {
          fVar31 = 3.051851e-05;
          fStack_128 = 3.051851e-05;
          fVar32 = fVar32 * fVar28;
          fVar33 = fVar33 * fVar28;
          fVar34 = fVar34 * fVar28;
          fStack_124 = fVar32;
          fStack_120 = fVar33;
          fStack_11c = fVar34;
        }
        fVar29 = *(float *)(lVar21 + 0x18 + lVar24);
        fVar30 = *(float *)(lVar21 + 0x1c + lVar24);
        fVar1 = *(float *)(lVar21 + 0x14 + lVar24);
        if ((fVar30 * *(float *)(lVar21 + 0x34 + lVar24) -
            fVar1 * *(float *)(lVar21 + 0x3c + lVar24)) * *(float *)(lVar21 + 0x28 + lVar24) +
            (fVar29 * *(float *)(lVar21 + 0x3c + lVar24) -
            fVar30 * *(float *)(lVar21 + 0x38 + lVar24)) * *(float *)(lVar21 + 0x24 + lVar24) +
            (fVar1 * *(float *)(lVar21 + 0x38 + lVar24) -
            fVar29 * *(float *)(lVar21 + 0x34 + lVar24)) * *(float *)(lVar21 + 0x2c + lVar24) <= 0.0
           ) {
          fVar31 = -fVar31;
          fVar32 = -fVar32;
          fVar33 = -fVar33;
          fVar34 = -fVar34;
          fStack_128 = fVar31;
          fStack_124 = fVar32;
          fStack_120 = fVar33;
          fStack_11c = fVar34;
        }
        *(short *)pfVar20 = (short)(int)(fVar32 * 32767.0);
        *(short *)((long long)pfVar20 + 2) = (short)(int)(fVar33 * 32767.0);
        *(short *)(pfVar20 + 1) = (short)(int)(fVar34 * 32767.0);
        *(short *)((long long)pfVar20 + 6) = (short)(int)(fVar31 * 32767.0);
        pfVar20 = (float *)((long long)pfVar20 + (long long)iVar8);
        lVar21 = lVar21 + 0x5c;
        lVar27 = lVar27 + -1;
      } while (lVar27 != 0);
    }
  }
  return;
}




// 函数: void FUN_18007df50(long long param_1,long long *param_2,char param_3,void* param_4)
void FUN_18007df50(long long param_1,long long *param_2,char param_3,void* param_4)

{
  long long lVar1;
  long long lVar2;
  uint uVar3;
  void* uVar4;
  uint uVar5;
  long long *plStackX_8;
  
  if (*(int *)(param_1 + 0x88) != 0) {
    if (param_3 == '\0') {
      uVar4 = FUN_180081350(param_1,&plStackX_8,*(int *)(param_1 + 0x88) * 3,param_4,
                            0xfffffffffffffffe);
      FUN_180080810(param_2,uVar4);
    }
    else {
      uVar4 = FUN_180081220();
      FUN_180080810(param_2,uVar4);
    }
    if (plStackX_8 != (long long *)0x0) {
      (**(code **)(*plStackX_8 + 0x38))();
    }
    lVar2 = *(long long *)(*param_2 + 0x10);
    if (param_3 != '\0') {
                    // WARNING: Could not recover jumptable at 0x0001808ffc47. Too many branches
                    // WARNING: Subroutine does not return
                    // WARNING: Treating indirect jump as call
      memcpy(lVar2,*(void* *)(param_1 + 0x90),(long long)*(int *)(param_1 + 0x88) * 0xc);
      return;
    }
    uVar5 = 0;
    if (*(int *)(param_1 + 0x88) != 0) {
      do {
        lVar1 = (long long)(int)uVar5 * 0xc;
        uVar3 = uVar5 * 3;
        *(undefined2 *)(lVar2 + (ulong long)uVar3 * 2) =
             *(undefined2 *)(lVar1 + *(long long *)(param_1 + 0x90));
        *(undefined2 *)(lVar2 + (ulong long)(uVar3 + 1) * 2) =
             *(undefined2 *)(*(long long *)(param_1 + 0x90) + 4 + lVar1);
        *(undefined2 *)(lVar2 + (ulong long)(uVar3 + 2) * 2) =
             *(undefined2 *)(*(long long *)(param_1 + 0x90) + 8 + lVar1);
        uVar5 = uVar5 + 1;
      } while (uVar5 < *(uint *)(param_1 + 0x88));
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007e080(long long param_1,ulong long param_2,long long *param_3,long long *param_4)
void FUN_18007e080(long long param_1,ulong long param_2,long long *param_3,long long *param_4)

{
  long long lVar1;
  int *piVar2;
  int memoryCompareResult;
  int iVar4;
  long long systemTimeValue;
  int iVar6;
  long long lStack_70;
  uint32_t uStack_68;
  long long lStack_60;
  long long lStack_58;
  uint32_t uStack_50;
  void* uStack_48;
  
  lVar5 = (param_2 & 0xff) * 0x1c0 + _DAT_180c86938;
  iVar4 = *(int *)(lVar5 + 0x70);
  lVar1 = (long long)iVar4;
  if (0 < iVar4) {
    uStack_68 = 0;
    lStack_70 = param_1;
    FUN_18007f770(&lStack_70);
    if (lStack_60 != 0) {
      iVar3 = 0;
      iVar6 = -1;
      if (0 < iVar4) {
        piVar2 = (int *)(lVar5 + 0x128);
        lVar5 = lStack_60;
        iVar4 = iVar6;
        do {
          switch(*piVar2) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 10:
          case 0xb:
          case 0xc:
          case 0xd:
            FUN_18007cbb0((long long)*piVar2,lVar5,*param_3 + 0x18 + (long long)iVar3 * 8);
            lVar5 = lStack_60;
            break;
          case 8:
            iVar6 = iVar3;
            break;
          case 9:
            iVar4 = iVar3;
          }
          iVar3 = iVar3 + 1;
          piVar2 = piVar2 + 3;
          lVar1 = lVar1 + -1;
        } while (lVar1 != 0);
        if (iVar6 != -1) {
          lStack_58 = param_1;
          if ((((*(byte *)(param_1 + 0xfd) & 0x40) == 0) || (*(long long *)(param_1 + 0x210) == 0))
             && (*(long long *)(param_1 + 0x1b0) != 0)) {
            lStack_58 = FUN_180085900();
          }
          uStack_50 = 0;
          FUN_18007f770(&lStack_58);
          FUN_18007cbb0(8,uStack_48,*param_3 + 0x18 + (long long)iVar6 * 8);
          FUN_18007cbb0(9,uStack_48,*param_3 + 0x18 + (long long)iVar4 * 8);
          FUN_18007f840(&lStack_58);
        }
      }
      if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
        param_1 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
      }
      FUN_18007df50(lStack_60,*param_4 + 0x20,0xffff < *(int *)(param_1 + 0x200));
    }
    FUN_18007f840(&lStack_70);
  }
  if ((long long *)*param_3 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_3 + 0x38))();
  }
  if ((long long *)*param_4 != (long long *)0x0) {
    (**(code **)(*(long long *)*param_4 + 0x38))();
  }
  return;
}




// 函数: void FUN_18007e2b0(long long param_1,long long param_2,void* param_3,void* param_4)
void FUN_18007e2b0(long long param_1,long long param_2,void* param_3,void* param_4)

{
  int iVar1;
  int iVar2;
  void* uVar3;
  
  uVar3 = 0xfffffffffffffffe;
  FUN_180080650(param_1 + 0x10);
  FUN_180080650(param_1 + 0x38,param_2);
  *(uint8_t *)(param_1 + 0x80) = *(uint8_t *)(param_2 + 0x1a);
  *(uint32_t *)(param_1 + 0x60) = **(uint32_t **)(param_2 + 8);
  *(long long *)(param_2 + 8) = *(long long *)(param_2 + 8) + 4;
  iVar1 = *(int *)(param_1 + 0x60);
  iVar2 = *(int *)(param_1 + 100);
  if (iVar2 < iVar1) {
    if (iVar1 == 0) {
      if (iVar2 < 2) {
        *(uint32_t *)(param_1 + 100) = 8;
      }
      else {
        *(int *)(param_1 + 100) = (iVar2 >> 1) + iVar2;
      }
    }
    else {
      *(int *)(param_1 + 100) = iVar1;
    }
    FUN_180086010(param_1 + 0x60);
  }
  *(int *)(param_1 + 0x60) = iVar1;
                    // WARNING: Subroutine does not return
  memcpy(*(void* *)(param_1 + 0x68),*(void* *)(param_2 + 8),(long long)(iVar1 * 0x5c),
         param_4,uVar3);
}




// 函数: void FUN_18007e5b0(long long param_1,long long *param_2)
void FUN_18007e5b0(long long param_1,long long *param_2)

{
  uint32_t uVar1;
  int *piVar2;
  uint32_t *puVar3;
  long long lVar4;
  int iVar5;
  int iVar6;
  long long lVar7;
  ulong long uVar8;
  ulong long uVar9;
  void* uVar10;
  
  uVar10 = 0xfffffffffffffffe;
  FUN_1800806e0(param_1 + 0x10);
  FUN_1800806e0(param_1 + 0x38,param_2);
  iVar6 = *(int *)(param_1 + 0x60);
  uVar9 = (long long)iVar6 * 0x5c + 4;
  lVar7 = param_2[2];
  piVar2 = (int *)param_2[1];
  lVar4 = *param_2;
  if ((ulong long)((lVar4 - (long long)piVar2) + lVar7) <= uVar9) {
    FUN_180639bf0(param_2,(long long)piVar2 + (uVar9 - lVar4),lVar7,uVar9,uVar10);
    iVar6 = *(int *)(param_1 + 0x60);
    lVar7 = param_2[2];
    piVar2 = (int *)param_2[1];
    lVar4 = *param_2;
  }
  if ((ulong long)((lVar4 - (long long)piVar2) + lVar7) < 5) {
    FUN_180639bf0(param_2,(long long)piVar2 + (4 - lVar4));
    piVar2 = (int *)param_2[1];
  }
  *piVar2 = iVar6;
  param_2[1] = param_2[1] + 4;
  puVar3 = (uint32_t *)param_2[1];
  iVar5 = 0;
  iVar6 = iVar5;
  if (0 < *(int *)(param_1 + 0x60)) {
    do {
      FUN_180078c70((long long)iVar6 * 0x5c + *(long long *)(param_1 + 0x68),param_2);
      iVar6 = iVar6 + 1;
    } while (iVar6 < *(int *)(param_1 + 0x60));
    puVar3 = (uint32_t *)param_2[1];
  }
  uVar1 = *(uint32_t *)(param_1 + 0x88);
  if ((ulong long)((*param_2 - (long long)puVar3) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar3 + (4 - *param_2));
    puVar3 = (uint32_t *)param_2[1];
  }
  *puVar3 = uVar1;
  param_2[1] = param_2[1] + 4;
  FUN_18063a180(param_2,*(void* *)(param_1 + 0x90),(long long)*(int *)(param_1 + 0x88) * 0xc);
  uVar8 = (ulong long)*(ushort *)(param_1 + 0xc0);
  uVar9 = uVar8 * 4 + 4;
  lVar7 = param_2[2];
  puVar3 = (uint32_t *)param_2[1];
  lVar4 = *param_2;
  if ((ulong long)((lVar4 - (long long)puVar3) + lVar7) <= uVar9) {
    FUN_180639bf0(param_2,(long long)puVar3 + (uVar9 - lVar4));
    uVar8 = (ulong long)*(ushort *)(param_1 + 0xc0);
    lVar7 = param_2[2];
    puVar3 = (uint32_t *)param_2[1];
    lVar4 = *param_2;
  }
  if ((ulong long)((lVar4 - (long long)puVar3) + lVar7) < 5) {
    FUN_180639bf0(param_2,(long long)puVar3 + (4 - lVar4));
    puVar3 = (uint32_t *)param_2[1];
  }
  *puVar3 = (int)uVar8;
  param_2[1] = param_2[1] + 4;
  FUN_18063a180(param_2,*(void* *)(param_1 + 0xb8),(ulong long)*(ushort *)(param_1 + 0xc0) << 2)
  ;
  if (*(short *)(param_1 + 0xc0) != 0) {
    do {
      lVar7 = (long long)iVar5 * 0x50 + *(long long *)(param_1 + 0xb0);
      FUN_1800806e0(lVar7,param_2);
      FUN_1800806e0(lVar7 + 0x28,param_2);
      iVar5 = iVar5 + 1;
    } while (iVar5 < (int)(uint)*(ushort *)(param_1 + 0xc0));
  }
  uVar1 = *(uint32_t *)(param_1 + 200);
  puVar3 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar3) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar3 + (4 - *param_2));
    puVar3 = (uint32_t *)param_2[1];
  }
  *puVar3 = uVar1;
  param_2[1] = param_2[1] + 4;
  FUN_18063a180(param_2,*(void* *)(param_1 + 0xd0),(long long)*(int *)(param_1 + 200) * 0x14);
  puVar3 = (uint32_t *)param_2[1];
  if ((ulong long)((*param_2 - (long long)puVar3) + param_2[2]) < 5) {
    FUN_180639bf0(param_2,(long long)puVar3 + (4 - *param_2));
    puVar3 = (uint32_t *)param_2[1];
  }
  *puVar3 = 0;
  param_2[1] = param_2[1] + 4;
  FUN_18063a180(param_2,0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007e880(long long param_1,char param_2,void* param_3)
void FUN_18007e880(long long param_1,char param_2,void* param_3)

{
  long long lVar1;
  void* uVar2;
  long long lVar3;
  
  *(int *)(*(long long *)(param_1 + 600) + 0x18) = (int)param_2;
  FUN_18007e990(param_1,*(int *)(*(long long *)(param_1 + 600) + 0x1c) +
                        *(int *)(*(long long *)(param_1 + 600) + 0x18));
  lVar1 = *(long long *)(param_1 + 600);
  if (*(long long *)(lVar1 + 0x10) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  uVar2 = 0;
  lVar3 = (long long)param_2;
  *(void* *)(lVar1 + 0x10) = 0;
  if (lVar3 != 0) {
    uVar2 = FUN_18062b1e0(_DAT_180c8ed18,lVar3,0x10,CONCAT71((int7)((ulong long)lVar1 >> 8),3));
  }
  *(void* *)(*(long long *)(param_1 + 600) + 0x10) = uVar2;
                    // WARNING: Could not recover jumptable at 0x0001808ffc47. Too many branches
                    // WARNING: Subroutine does not return
                    // WARNING: Treating indirect jump as call
  memcpy(*(void* *)(*(long long *)(param_1 + 600) + 0x10),param_3,lVar3);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007e930(long long param_1)
void FUN_18007e930(long long param_1)

{
  void* uVar1;
  
  if (*(long long *)(param_1 + 0x2c8) == 0) {
    *(uint *)(param_1 + 0x100) = *(uint *)(param_1 + 0x100) | 8;
    uVar1 = FUN_18062b1e0(_DAT_180c8ed18,0xd0,4,9);
                    // WARNING: Subroutine does not return
    memset(uVar1,0,0xd0);
  }
  return;
}




// 函数: void FUN_18007e95f(void)
void FUN_18007e95f(void)

{
  void* uVar1;
  
  uVar1 = FUN_18062b1e0();
                    // WARNING: Subroutine does not return
  memset(uVar1,0,0xd0);
}




// 函数: void FUN_18007e988(void)
void FUN_18007e988(void)

{
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007e990(long long param_1,int param_2)
void FUN_18007e990(long long param_1,int param_2)

{
  long long *plVar1;
  void* uVar2;
  
  plVar1 = *(long long **)(param_1 + 600);
  if ((int)plVar1[1] != param_2) {
    if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    uVar2 = 0;
    *plVar1 = 0;
    if (param_2 != 0) {
      uVar2 = FUN_18062b1e0(_DAT_180c8ed18,(long long)param_2 << 6,0x10,4);
    }
    **(void* **)(param_1 + 600) = uVar2;
    *(int *)(*(long long *)(param_1 + 600) + 8) = param_2;
  }
  return;
}




// 函数: void FUN_18007ea10(long long param_1,char param_2)
void FUN_18007ea10(long long param_1,char param_2)

{
  byte bVar1;
  long long lVar2;
  long long *plVar3;
  uint8_t auStack_40 [8];
  long long lStack_38;
  uint32_t uStack_30;
  long long *plStack_28;
  
  if (*(char *)(param_1 + 0xf4) == param_2) {
    return;
  }
  lVar2 = 0;
  if ((*(byte *)(param_1 + 0xfd) & 0x20) != 0) {
    FUN_18007baa0();
    do {
      *(char *)(*(long long *)(param_1 + 0x1e0) + 0x14 + lVar2) = param_2;
      lVar2 = lVar2 + 0x18;
    } while (lVar2 < 0x180);
  }
  plStack_28 = (long long *)0x0;
  auStack_40[0] = 0;
  uStack_30 = 1;
  lStack_38 = param_1;
  FUN_18007f4c0(auStack_40);
  if (plStack_28 == (long long *)0x0) goto LAB_18007eb55;
  plVar3 = plStack_28;
  if (param_2 != '\0') {
    if ((param_2 != '\x01') || ((*(byte *)(param_1 + 0xfd) & 0x20) == 0)) goto LAB_18007eb55;
    lVar2 = *(long long *)(param_1 + 0x1b8);
    bVar1 = *(byte *)(lVar2 + 0x38c);
    if (bVar1 == 9) {
      bVar1 = func_0x00018022d300();
      *(byte *)(lVar2 + 0x38c) = bVar1;
    }
    plVar3 = plStack_28;
    if ((*(char *)(*(long long *)(param_1 + 0x1e0) + 0x15 + (ulong long)bVar1 * 0x18) != '\x03') &&
       (*(char *)(*(long long *)(param_1 + 0x1e0) + 0x15 + (ulong long)bVar1 * 0x18) != '\x02'))
    goto LAB_18007eb55;
  }
  plStack_28 = (long long *)0x0;
  if (plVar3 != (long long *)0x0) {
    (**(code **)(*plVar3 + 0x38))();
  }
LAB_18007eb55:
  *(char *)(param_1 + 0xf4) = param_2;
  FUN_18007f6a0(auStack_40);
  if (plStack_28 != (long long *)0x0) {
    (**(code **)(*plStack_28 + 0x38))();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

code * FUN_18007eb80(long long param_1,char param_2)

{
  long long *plVar1;
  code *in_RAX;
  void* uVar2;
  code *pcVar3;
  long long* systemMemoryPointer;
  long long lStack_30;
  uint32_t uStack_28;
  code *pcStack_20;
  code *pcStack_18;
  
  pcVar3 = (code *)(param_1 + 0x210);
  if (*(long long *)pcVar3 == 0) {
    if ((*(byte *)(param_1 + 0xfd) & 0x20) == 0) {
      lStack_30 = func_0x000180085de0(*(void* *)(param_1 + 0x1b0));
      if (lStack_30 != param_1) {
        uStack_28 = 0;
        FUN_18007f770(&lStack_30);
        uVar2 = FUN_18062b1e0(_DAT_180c8ed18,0xf0,8,3);
        uVar2 = FUN_18007f2f0(uVar2);
        FUN_180056f10(pcVar3,uVar2);
        FUN_1800860f0(*(long long *)pcVar3 + 0x10,(long long)pcStack_20 + 0x10);
        FUN_1800860f0(*(long long *)pcVar3 + 0x38,(long long)pcStack_20 + 0x38);
        FUN_180086090(*(long long *)pcVar3 + 0x60,(long long)pcStack_20 + 0x60);
        FUN_180085fb0(*(long long *)pcVar3 + 0x88,(long long)pcStack_20 + 0x88);
        if (param_2 != '\0') {
          *(byte *)(param_1 + 0xfd) = *(byte *)(param_1 + 0xfd) | 0x40;
          FUN_180085ec0(*(long long *)pcVar3 + 200,(long long)pcStack_20 + 200);
          FUN_180085680(*(long long *)pcVar3 + 0xb0,(long long)pcStack_20 + 0xb0);
        }
        pcVar3 = (code *)FUN_18007f840(&lStack_30);
        return pcVar3;
      }
    }
    if (*(long long *)(param_1 + 0xa8) == 0) {
      if ((*(byte *)(param_1 + 0xfd) & 4) != 0) {
        uVar2 = FUN_18062b1e0(_DAT_180c8ed18,0xf0,8,3);
        plVar4 = (long long *)FUN_18007f2f0(uVar2);
        pcStack_18 = (code *)0xfffffffffffffffe;
        if (plVar4 != (long long *)0x0) {
          (**(code **)(*plVar4 + 0x28))(plVar4);
        }
        plVar1 = *(long long **)pcVar3;
        *(long long **)pcVar3 = plVar4;
        if (plVar1 != (long long *)0x0) {
          (**(code **)(*plVar1 + 0x38))();
        }
        return pcVar3;
      }
      FUN_1806272a0(&UNK_1809ffbe0);
      in_RAX = (code *)FUN_180626f80(&UNK_1809ffab0);
    }
    else {
      plVar4 = *(long long **)(*(long long *)(param_1 + 0xa8) + 0x88);
      pcStack_20 = (code *)&UNK_180083070;
      pcStack_18 = FUN_180082fd0;
      lStack_30 = param_1;
      (**(code **)(*plVar4 + 0x60))(plVar4,&GAME_CORE_SYSTEM_ID,param_1 + 0xb8,0,&lStack_30);
      in_RAX = pcStack_20;
      if (pcStack_20 != (code *)0x0) {
        pcVar3 = (code *)(*pcStack_20)(&lStack_30,0,0);
        return pcVar3;
      }
    }
  }
  return in_RAX;
}




// 函数: void FUN_18007edd0(long long param_1,char param_2)
void FUN_18007edd0(long long param_1,char param_2)

{
  long long *plVar1;
  
  if (*(long long *)(param_1 + 0x210) != 0) {
    FUN_1800791a0();
    if (param_2 != '\0') {
      *(byte *)(param_1 + 0xfd) = *(byte *)(param_1 + 0xfd) | 0x20;
      *(byte *)(param_1 + 0xfe) = *(byte *)(param_1 + 0xfe) | 1;
      FUN_18007baa0(param_1);
    }
    if (((*(char *)(param_1 + 0xfc) == '\0') && (*(char *)(param_1 + 0xf4) == '\0')) &&
       (((*(byte *)(param_1 + 0xfd) & 0x20) == 0 || ((*(byte *)(param_1 + 0xfe) & 1) == 0)))) {
      plVar1 = *(long long **)(param_1 + 0x210);
      *(void* *)(param_1 + 0x210) = 0;
      if (plVar1 != (long long *)0x0) {
                    // WARNING: Could not recover jumptable at 0x00018007ee5b. Too many branches
                    // WARNING: Treating indirect jump as call
        (**(code **)(*plVar1 + 0x38))();
        return;
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007ee70(long long param_1)
void FUN_18007ee70(long long param_1)

{
  int iVar1;
  uint uVar2;
  void* uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  long long lVar9;
  long long lVar10;
  ulong long uVar11;
  void* *puVar12;
  ulong long uVar13;
  ulong long uVar14;
  long long lVar15;
  
  lVar10 = *(long long *)(param_1 + 0x2d0);
  iVar1 = *(int *)(_DAT_180c86870 + 0x224);
  if (*(int *)(lVar10 + 0xc) != iVar1) {
    if (*(int *)(lVar10 + 8) < 1) {
      if (*(int *)(lVar10 + 0xc) == iVar1 + -1) {
        uVar6 = *(int *)(_DAT_180c86890 + 0x9c8) + 1U & 0x80000001;
        if ((int)uVar6 < 0) {
          uVar6 = (uVar6 - 1 | 0xfffffffe) + 1;
        }
        lVar15 = (long long)(int)uVar6 * 0x488 + _DAT_180c86890 + 0xb8;
        lVar9 = (long long)*(int *)(_DAT_180c86890 + 0x9c8) * 0x488 + _DAT_180c86890 + 0xb8;
        uVar14 = FUN_180080480(lVar9,*(uint32_t *)(lVar10 + 0x14));
        iVar7 = (int)uVar14;
        uVar11 = uVar14 & 0xffffffff;
        if (-1 < iVar7) {
          uVar13 = uVar14 >> 0xb & 0x1fffff;
          uVar6 = *(uint *)(*(long long *)(param_1 + 0x2d0) + 0x14);
          uVar14 = (ulong long)uVar6;
          uVar2 = *(uint *)(*(long long *)(param_1 + 0x2d0) + 0x18);
          uVar5 = (uint)uVar13;
          if (uVar5 == uVar6 + iVar7 >> 0xb) {
            uVar8 = uVar2 >> 0xb;
            if (uVar8 == uVar2 + uVar6 >> 0xb) {
                    // WARNING: Subroutine does not return
              memcpy(*(long long *)(lVar9 + 8 + uVar13 * 8) + (ulong long)(iVar7 + uVar5 * -0x800) * 8
                     ,*(long long *)(lVar15 + 8 + (ulong long)uVar8 * 8) +
                      (ulong long)(uVar2 + uVar8 * -0x800) * 8,(long long)(int)uVar6 << 3);
            }
          }
          if (0 < (int)uVar6) {
            do {
              iVar4 = (int)uVar11;
              uVar5 = (uVar2 - iVar7) + iVar4;
              uVar6 = uVar5 >> 0xb;
              uVar13 = uVar11 >> 0xb;
              uVar11 = (ulong long)(iVar4 + 1);
              *(void* *)
               (*(long long *)(lVar9 + 8 + uVar13 * 8) +
               (ulong long)(uint)(iVar4 + (int)uVar13 * -0x800) * 8) =
                   *(void* *)
                    (*(long long *)(lVar15 + 8 + (ulong long)uVar6 * 8) +
                    (ulong long)(uVar5 + uVar6 * -0x800) * 8);
              uVar14 = uVar14 - 1;
            } while (uVar14 != 0);
          }
          *(int *)(*(long long *)(param_1 + 0x2d0) + 0x18) = iVar7;
          *(int *)(*(long long *)(param_1 + 0x2d0) + 0xc) = iVar1;
        }
      }
      else {
        *(uint32_t *)(lVar10 + 0x14) = 0;
      }
    }
    else {
      lVar10 = (long long)*(int *)(_DAT_180c86890 + 0x9c8) * 0x488 + _DAT_180c86890 + 0xb8;
      uVar5 = FUN_180080480(lVar10);
      uVar2 = uVar5 >> 0xb;
      uVar6 = *(uint *)(*(void* **)(param_1 + 0x2d0) + 1);
      uVar14 = (ulong long)uVar6;
      puVar12 = (void* *)**(void* **)(param_1 + 0x2d0);
      if (uVar2 == uVar6 + uVar5 >> 0xb) {
                    // WARNING: Subroutine does not return
        memcpy(*(long long *)(lVar10 + 8 + (ulong long)uVar2 * 8) +
               (ulong long)(uVar5 + uVar2 * -0x800) * 8,puVar12,(ulong long)uVar6 << 3);
      }
      uVar2 = uVar5;
      if (uVar6 != 0) {
        do {
          uVar3 = *puVar12;
          puVar12 = puVar12 + 1;
          *(void* *)
           (*(long long *)(lVar10 + 8 + (ulong long)(uVar2 >> 0xb) * 8) +
           (ulong long)(uVar2 + (uVar2 >> 0xb) * -0x800) * 8) = uVar3;
          uVar14 = uVar14 - 1;
          uVar2 = uVar2 + 1;
        } while (uVar14 != 0);
      }
      *(uint32_t *)(*(long long *)(param_1 + 0x2d0) + 0x14) =
           *(uint32_t *)(*(long long *)(param_1 + 0x2d0) + 8);
      *(uint *)(*(long long *)(param_1 + 0x2d0) + 0x18) = uVar5;
      *(int *)(*(long long *)(param_1 + 0x2d0) + 0xc) = iVar1;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007eea1(long long param_1,int param_2,int param_3)
void FUN_18007eea1(long long param_1,int param_2,int param_3)

{
  uint uVar1;
  void* uVar2;
  int memoryCompareResult;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  long long unaff_RBX;
  int unaff_EBP;
  long long lVar8;
  ulong long uVar9;
  void* *puVar10;
  ulong long uVar11;
  ulong long uVar12;
  long long lVar13;
  
  if (param_2 < 1) {
    if (param_3 == unaff_EBP + -1) {
      uVar5 = *(int *)(_DAT_180c86890 + 0x9c8) + 1U & 0x80000001;
      if ((int)uVar5 < 0) {
        uVar5 = (uVar5 - 1 | 0xfffffffe) + 1;
      }
      lVar13 = (long long)(int)uVar5 * 0x488 + _DAT_180c86890 + 0xb8;
      lVar8 = (long long)*(int *)(_DAT_180c86890 + 0x9c8) * 0x488 + _DAT_180c86890 + 0xb8;
      uVar12 = FUN_180080480(lVar8,*(uint32_t *)(param_1 + 0x14));
      iVar6 = (int)uVar12;
      uVar9 = uVar12 & 0xffffffff;
      if (-1 < iVar6) {
        uVar11 = uVar12 >> 0xb & 0x1fffff;
        uVar5 = *(uint *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14);
        uVar12 = (ulong long)uVar5;
        uVar1 = *(uint *)(*(long long *)(unaff_RBX + 0x2d0) + 0x18);
        uVar4 = (uint)uVar11;
        if (uVar4 == uVar5 + iVar6 >> 0xb) {
          uVar7 = uVar1 >> 0xb;
          if (uVar7 == uVar1 + uVar5 >> 0xb) {
                    // WARNING: Subroutine does not return
            memcpy(*(long long *)(lVar8 + 8 + uVar11 * 8) + (ulong long)(iVar6 + uVar4 * -0x800) * 8,
                   *(long long *)(lVar13 + 8 + (ulong long)uVar7 * 8) +
                   (ulong long)(uVar1 + uVar7 * -0x800) * 8,(long long)(int)uVar5 << 3);
          }
        }
        if (0 < (int)uVar5) {
          do {
            iVar3 = (int)uVar9;
            uVar4 = (uVar1 - iVar6) + iVar3;
            uVar5 = uVar4 >> 0xb;
            uVar11 = uVar9 >> 0xb;
            uVar9 = (ulong long)(iVar3 + 1);
            *(void* *)
             (*(long long *)(lVar8 + 8 + uVar11 * 8) +
             (ulong long)(uint)(iVar3 + (int)uVar11 * -0x800) * 8) =
                 *(void* *)
                  (*(long long *)(lVar13 + 8 + (ulong long)uVar5 * 8) +
                  (ulong long)(uVar4 + uVar5 * -0x800) * 8);
            uVar12 = uVar12 - 1;
          } while (uVar12 != 0);
        }
        *(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x18) = iVar6;
        *(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0xc) = unaff_EBP;
      }
    }
    else {
      *(uint32_t *)(param_1 + 0x14) = 0;
    }
  }
  else {
    lVar8 = (long long)*(int *)(_DAT_180c86890 + 0x9c8) * 0x488 + _DAT_180c86890 + 0xb8;
    uVar4 = FUN_180080480(lVar8);
    uVar1 = uVar4 >> 0xb;
    uVar5 = *(uint *)(*(void* **)(unaff_RBX + 0x2d0) + 1);
    uVar12 = (ulong long)uVar5;
    puVar10 = (void* *)**(void* **)(unaff_RBX + 0x2d0);
    if (uVar1 == uVar5 + uVar4 >> 0xb) {
                    // WARNING: Subroutine does not return
      memcpy(*(long long *)(lVar8 + 8 + (ulong long)uVar1 * 8) +
             (ulong long)(uVar4 + uVar1 * -0x800) * 8,puVar10,(ulong long)uVar5 << 3);
    }
    uVar1 = uVar4;
    if (uVar5 != 0) {
      do {
        uVar2 = *puVar10;
        puVar10 = puVar10 + 1;
        *(void* *)
         (*(long long *)(lVar8 + 8 + (ulong long)(uVar1 >> 0xb) * 8) +
         (ulong long)(uVar1 + (uVar1 >> 0xb) * -0x800) * 8) = uVar2;
        uVar12 = uVar12 - 1;
        uVar1 = uVar1 + 1;
      } while (uVar12 != 0);
    }
    *(uint32_t *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14) =
         *(uint32_t *)(*(long long *)(unaff_RBX + 0x2d0) + 8);
    *(uint *)(*(long long *)(unaff_RBX + 0x2d0) + 0x18) = uVar4;
    *(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0xc) = unaff_EBP;
  }
  return;
}




// 函数: void FUN_18007ef9a(long long param_1,long long param_2)
void FUN_18007ef9a(long long param_1,long long param_2)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  ulong long uVar5;
  uint uVar6;
  uint uVar7;
  long long unaff_RBX;
  uint32_t unaff_EBP;
  ulong long uVar8;
  ulong long uVar9;
  long long lVar10;
  
  uVar3 = *(int *)(param_2 + 0x910) + 1U & 0x80000001;
  if ((int)uVar3 < 0) {
    uVar3 = (uVar3 - 1 | 0xfffffffe) + 1;
  }
  lVar10 = (long long)(int)uVar3 * 0x488 + param_2;
  param_2 = (long long)*(int *)(param_2 + 0x910) * 0x488 + param_2;
  uVar5 = FUN_180080480(param_2,*(uint32_t *)(param_1 + 0x14));
  iVar4 = (int)uVar5;
  uVar8 = uVar5 & 0xffffffff;
  if (-1 < iVar4) {
    uVar9 = uVar5 >> 0xb & 0x1fffff;
    uVar3 = *(uint *)(*(long long *)(unaff_RBX + 0x2d0) + 0x14);
    uVar5 = (ulong long)uVar3;
    uVar1 = *(uint *)(*(long long *)(unaff_RBX + 0x2d0) + 0x18);
    uVar7 = (uint)uVar9;
    if (uVar7 == uVar3 + iVar4 >> 0xb) {
      uVar6 = uVar1 >> 0xb;
      if (uVar6 == uVar1 + uVar3 >> 0xb) {
                    // WARNING: Subroutine does not return
        memcpy(*(long long *)(param_2 + 8 + uVar9 * 8) + (ulong long)(iVar4 + uVar7 * -0x800) * 8,
               *(long long *)(lVar10 + 8 + (ulong long)uVar6 * 8) +
               (ulong long)(uVar1 + uVar6 * -0x800) * 8,(long long)(int)uVar3 << 3);
      }
    }
    if (0 < (int)uVar3) {
      do {
        iVar2 = (int)uVar8;
        uVar7 = (uVar1 - iVar4) + iVar2;
        uVar3 = uVar7 >> 0xb;
        uVar9 = uVar8 >> 0xb;
        uVar8 = (ulong long)(iVar2 + 1);
        *(void* *)
         (*(long long *)(param_2 + 8 + uVar9 * 8) +
         (ulong long)(uint)(iVar2 + (int)uVar9 * -0x800) * 8) =
             *(void* *)
              (*(long long *)(lVar10 + 8 + (ulong long)uVar3 * 8) +
              (ulong long)(uVar7 + uVar3 * -0x800) * 8);
        uVar5 = uVar5 - 1;
      } while (uVar5 != 0);
    }
    *(int *)(*(long long *)(unaff_RBX + 0x2d0) + 0x18) = iVar4;
    *(uint32_t *)(*(long long *)(unaff_RBX + 0x2d0) + 0xc) = unaff_EBP;
  }
  return;
}




// 函数: void FUN_18007f0b5(void)
void FUN_18007f0b5(void)

{
  return;
}




// 函数: void FUN_18007f0bf(void)
void FUN_18007f0bf(void)

{
  return;
}




// 函数: void FUN_18007f0ca(long long param_1)
void FUN_18007f0ca(long long param_1)

{
  *(uint32_t *)(param_1 + 0x14) = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f0e0(long long param_1,long long param_2,int param_3)
void FUN_18007f0e0(long long param_1,long long param_2,int param_3)

{
  int *piVar1;
  void** systemDataTable;
  void* *puVar3;
  void* *puVar4;
  uint uVar5;
  int *piVar7;
  long long lVar8;
  ulong long uVar9;
  long long lVar10;
  void** systemRootNode;
  
  uVar9 = (ulong long)param_3;
  if (**(long long **)(param_1 + 0x2d0) != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  puVar4 = (void* *)0x0;
  **(long long **)(param_1 + 0x2d0) = 0;
  if (0 < param_3) {
    puVar2 = puVar4;
    if (param_3 != 0) {
      puVar2 = (void* *)CreateSystemThreadObject(_DAT_180c8ed18,uVar9 * 8,3);
      puVar3 = puVar2;
      puVar6 = puVar4;
      do {
        uVar5 = (int)puVar6 + 1;
        puVar6 = (void* *)(ulong long)uVar5;
        *puVar3 = 0;
        puVar3 = puVar3 + 1;
      } while ((ulong long)(long long)(int)uVar5 < uVar9);
    }
    **(void* **)(param_1 + 0x2d0) = puVar2;
    if (3 < (long long)uVar9) {
      lVar10 = -8 - param_2;
      lVar8 = (uVar9 - 4 >> 2) + 1;
      puVar4 = (void* *)(lVar8 * 4);
      piVar7 = (int *)(param_2 + 8);
      do {
        piVar1 = piVar7 + 8;
        *(float *)((long long)piVar7 + **(long long **)(param_1 + 0x2d0) + lVar10) = (float)piVar7[-2]
        ;
        *(int *)((long long)piVar7 + **(long long **)(param_1 + 0x2d0) + 4 + lVar10) = piVar7[-1];
        *(float *)((long long)piVar7 + **(long long **)(param_1 + 0x2d0) + 8 + lVar10) =
             (float)*piVar7;
        *(int *)((long long)piVar7 + **(long long **)(param_1 + 0x2d0) + 0xc + lVar10) = piVar7[1];
        *(float *)((**(long long **)(param_1 + 0x2d0) - param_2) + -0x18 + (long long)piVar1) =
             (float)piVar7[2];
        *(int *)((long long)piVar7 + **(long long **)(param_1 + 0x2d0) + 0x14 + lVar10) = piVar7[3];
        *(float *)((**(long long **)(param_1 + 0x2d0) - param_2) + -0x10 + (long long)piVar1) =
             (float)piVar7[4];
        *(int *)((long long)piVar7 + **(long long **)(param_1 + 0x2d0) + 0x1c + lVar10) = piVar7[5];
        lVar8 = lVar8 + -1;
        piVar7 = piVar1;
      } while (lVar8 != 0);
    }
    for (; (long long)puVar4 < (long long)uVar9; puVar4 = (void* *)((long long)puVar4 + 1)) {
      *(float *)(**(long long **)(param_1 + 0x2d0) + (long long)puVar4 * 8) =
           (float)*(int *)(param_2 + (long long)puVar4 * 8);
      *(uint32_t *)(**(long long **)(param_1 + 0x2d0) + 4 + (long long)puVar4 * 8) =
           *(uint32_t *)(param_2 + 4 + (long long)puVar4 * 8);
    }
    *(int *)(*(long long *)(param_1 + 0x2d0) + 8) = param_3;
    return;
  }
  *(int *)(*(long long *)(param_1 + 0x2d0) + 8) = param_3;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f11f(void)
void FUN_18007f11f(void)

{
  int *piVar1;
  ulong long *puVar2;
  ulong long *puVar3;
  ulong long unaff_RBX;
  long long unaff_RBP;
  long long unaff_RDI;
  uint uVar4;
  ulong long uVar5;
  int *piVar6;
  long long lVar7;
  ulong long unaff_R14;
  long long lVar8;
  bool in_ZF;
  
  if (in_ZF) {
    puVar2 = (ulong long *)(unaff_RBX & 0xffffffff);
  }
  else {
    puVar2 = (ulong long *)CreateSystemThreadObject(_DAT_180c8ed18,unaff_R14 * 8,3);
    uVar5 = unaff_RBX & 0xffffffff;
    puVar3 = puVar2;
    do {
      uVar4 = (int)uVar5 + 1;
      uVar5 = (ulong long)uVar4;
      *puVar3 = unaff_RBX;
      puVar3 = puVar3 + 1;
    } while ((ulong long)(long long)(int)uVar4 < unaff_R14);
  }
  **(long long **)(unaff_RDI + 0x2d0) = (long long)puVar2;
  if (3 < (long long)unaff_R14) {
    lVar8 = -8 - unaff_RBP;
    lVar7 = (unaff_R14 - 4 >> 2) + 1;
    unaff_RBX = lVar7 * 4;
    piVar6 = (int *)(unaff_RBP + 8);
    do {
      piVar1 = piVar6 + 8;
      *(float *)((long long)piVar6 + **(long long **)(unaff_RDI + 0x2d0) + lVar8) = (float)piVar6[-2];
      *(int *)((long long)piVar6 + **(long long **)(unaff_RDI + 0x2d0) + 4 + lVar8) = piVar6[-1];
      *(float *)((long long)piVar6 + **(long long **)(unaff_RDI + 0x2d0) + 8 + lVar8) = (float)*piVar6
      ;
      *(int *)((long long)piVar6 + **(long long **)(unaff_RDI + 0x2d0) + 0xc + lVar8) = piVar6[1];
      *(float *)((**(long long **)(unaff_RDI + 0x2d0) - unaff_RBP) + -0x18 + (long long)piVar1) =
           (float)piVar6[2];
      *(int *)((long long)piVar6 + **(long long **)(unaff_RDI + 0x2d0) + 0x14 + lVar8) = piVar6[3];
      *(float *)((**(long long **)(unaff_RDI + 0x2d0) - unaff_RBP) + -0x10 + (long long)piVar1) =
           (float)piVar6[4];
      *(int *)((long long)piVar6 + **(long long **)(unaff_RDI + 0x2d0) + 0x1c + lVar8) = piVar6[5];
      lVar7 = lVar7 + -1;
      piVar6 = piVar1;
    } while (lVar7 != 0);
  }
  for (; (long long)unaff_RBX < (long long)unaff_R14; unaff_RBX = unaff_RBX + 1) {
    *(float *)(**(long long **)(unaff_RDI + 0x2d0) + unaff_RBX * 8) =
         (float)*(int *)(unaff_RBP + unaff_RBX * 8);
    *(uint32_t *)(**(long long **)(unaff_RDI + 0x2d0) + 4 + unaff_RBX * 8) =
         *(uint32_t *)(unaff_RBP + 4 + unaff_RBX * 8);
  }
  *(int *)(*(long long *)(unaff_RDI + 0x2d0) + 8) = (int)unaff_R14;
  return;
}




// 函数: void FUN_18007f176(void)
void FUN_18007f176(void)

{
  int *piVar1;
  long long lVar2;
  long long unaff_RBP;
  long long unaff_RDI;
  int *piVar3;
  long long lVar4;
  long long unaff_R14;
  long long systemTimeValue;
  
  lVar5 = -8 - unaff_RBP;
  lVar4 = (unaff_R14 - 4U >> 2) + 1;
  lVar2 = lVar4 * 4;
  piVar3 = (int *)(unaff_RBP + 8);
  do {
    piVar1 = piVar3 + 8;
    *(float *)((long long)piVar3 + **(long long **)(unaff_RDI + 0x2d0) + lVar5) = (float)piVar3[-2];
    *(int *)((long long)piVar3 + **(long long **)(unaff_RDI + 0x2d0) + 4 + lVar5) = piVar3[-1];
    *(float *)((long long)piVar3 + **(long long **)(unaff_RDI + 0x2d0) + 8 + lVar5) = (float)*piVar3;
    *(int *)((long long)piVar3 + **(long long **)(unaff_RDI + 0x2d0) + 0xc + lVar5) = piVar3[1];
    *(float *)((**(long long **)(unaff_RDI + 0x2d0) - unaff_RBP) + -0x18 + (long long)piVar1) =
         (float)piVar3[2];
    *(int *)((long long)piVar3 + **(long long **)(unaff_RDI + 0x2d0) + 0x14 + lVar5) = piVar3[3];
    *(float *)((**(long long **)(unaff_RDI + 0x2d0) - unaff_RBP) + -0x10 + (long long)piVar1) =
         (float)piVar3[4];
    *(int *)((long long)piVar3 + **(long long **)(unaff_RDI + 0x2d0) + 0x1c + lVar5) = piVar3[5];
    lVar4 = lVar4 + -1;
    piVar3 = piVar1;
  } while (lVar4 != 0);
  for (; lVar2 < unaff_R14; lVar2 = lVar2 + 1) {
    *(float *)(**(long long **)(unaff_RDI + 0x2d0) + lVar2 * 8) =
         (float)*(int *)(unaff_RBP + lVar2 * 8);
    *(uint32_t *)(**(long long **)(unaff_RDI + 0x2d0) + 4 + lVar2 * 8) =
         *(uint32_t *)(unaff_RBP + 4 + lVar2 * 8);
  }
  *(int *)(*(long long *)(unaff_RDI + 0x2d0) + 8) = (int)unaff_R14;
  return;
}




// 函数: void FUN_18007f27a(void)
void FUN_18007f27a(void)

{
  long long unaff_RBX;
  long long unaff_RBP;
  long long unaff_RDI;
  long long unaff_R14;
  
  if (unaff_RBX < unaff_R14) {
    do {
      *(float *)(**(long long **)(unaff_RDI + 0x2d0) + unaff_RBX * 8) =
           (float)*(int *)(unaff_RBP + unaff_RBX * 8);
      *(uint32_t *)(**(long long **)(unaff_RDI + 0x2d0) + 4 + unaff_RBX * 8) =
           *(uint32_t *)(unaff_RBP + 4 + unaff_RBX * 8);
      unaff_RBX = unaff_RBX + 1;
    } while (unaff_RBX < unaff_R14);
  }
  *(int *)(*(long long *)(unaff_RDI + 0x2d0) + 8) = (int)unaff_R14;
  return;
}




// 函数: void FUN_18007f2cf(void)
void FUN_18007f2cf(void)

{
  long long unaff_RDI;
  uint32_t unaff_R14D;
  
  *(uint32_t *)(*(long long *)(unaff_RDI + 0x2d0) + 8) = unaff_R14D;
  return;
}



void* * FUN_18007f2f0(void* *param_1)

{
  *param_1 = &UNK_180a21690;
  *param_1 = &UNK_180a21720;
  *(uint32_t *)(param_1 + 1) = 0;
  *param_1 = &UNK_1809fffc8;
  param_1[2] = 0;
  param_1[3] = 0;
  *(uint8_t *)(param_1 + 6) = 3;
  param_1[7] = 0;
  param_1[8] = 0;
  *(uint8_t *)(param_1 + 0xb) = 3;
  param_1[0xc] = 0;
  param_1[0xd] = 0;
  *(uint8_t *)(param_1 + 0x10) = 3;
  param_1[0x11] = 0;
  param_1[0x12] = 0;
  *(uint8_t *)(param_1 + 0x15) = 3;
  *(undefined2 *)(param_1 + 0x18) = 0;
  param_1[0x16] = 0;
  param_1[0x17] = 0;
  param_1[0x19] = 0;
  param_1[0x1a] = 0;
  *(uint8_t *)(param_1 + 0x1d) = 3;
  *(uint8_t *)(param_1 + 6) = 0xf;
  *(uint8_t *)(param_1 + 0xb) = 0xf;
  *(uint8_t *)(param_1 + 0x10) = 0xf;
  *(uint8_t *)(param_1 + 0x15) = 0xf;
  *(uint8_t *)(param_1 + 0x1d) = 0xf;
  return param_1;
}



void* * FUN_18007f3b0(void* *param_1,ulong long param_2)

{
  *param_1 = &UNK_1809fffc8;
  if (param_1[0x1a] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  FUN_180085530(param_1[0x16]);
  param_1[0x16] = 0;
  if (param_1[0x17] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  param_1[0x17] = 0;
  if (param_1[0x12] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[0xd] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[8] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  if (param_1[3] != 0) {
                    // WARNING: Subroutine does not return
    FUN_18064e900();
  }
  *param_1 = &UNK_180a21720;
  *param_1 = &UNK_180a21690;
  if ((param_2 & 1) != 0) {
    free(param_1,0xf0);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f4c0(uint8_t *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18007f4c0(uint8_t *param_1,void* param_2,void* param_3,void* param_4)

{
  long long lVar1;
  long long *plVar2;
  long long *plVar3;
  char cVar4;
  int iVar5;
  uint32_t uVar6;
  long long lVar7;
  undefined *puVar8;
  bool bVar9;
  void* uVar10;
  
  uVar10 = 0xfffffffffffffffe;
  bVar9 = false;
  if ((*(byte *)(*(long long *)(param_1 + 8) + 0xfd) & 0x20) != 0) {
    FUN_18007baa0();
    lVar7 = 0;
    do {
      cVar4 = *(char *)(*(long long *)(*(long long *)(param_1 + 8) + 0x1e0) + 0x15 + lVar7 * 0x18);
      if (cVar4 == '\x01') {
        Sleep(0);
        bVar9 = true;
      }
      lVar1 = lVar7 + 1;
      lVar7 = 0;
      if (cVar4 != '\x01') {
        lVar7 = lVar1;
      }
    } while (lVar7 < 0x10);
    if ((bVar9) &&
       ((lVar7 = *(long long *)(param_1 + 8), *(char *)(lVar7 + 0xfa) == '\0' ||
        (*(char *)(lVar7 + 0xfb) == '\0')))) {
      puVar8 = &SystemStringTemplate;
      if (*(undefined **)(lVar7 + 0x18) != (undefined *)0x0) {
        puVar8 = *(undefined **)(lVar7 + 0x18);
      }
                    // WARNING: Subroutine does not return
      FUN_180062300(_DAT_180c86928,&UNK_1809ffc28,puVar8,param_4,uVar10);
    }
  }
  lVar7 = *(long long *)(param_1 + 8);
  while( true ) {
    LOCK();
    cVar4 = *(char *)(lVar7 + 0xec);
    bVar9 = cVar4 == '\0';
    if (bVar9) {
      *(char *)(lVar7 + 0xec) = '\x01';
      cVar4 = '\0';
    }
    UNLOCK();
    if (bVar9) break;
    iVar5 = _Thrd_id();
    if (*(int *)(lVar7 + 0xf0) == iVar5) goto LAB_18007f5cb;
    Sleep();
  }
  cVar4 = '\0';
LAB_18007f5cb:
  uVar6 = _Thrd_id();
  *(uint32_t *)(lVar7 + 0xf0) = uVar6;
  if (cVar4 == '\0') {
    *param_1 = 1;
  }
  while (*(int *)(lVar7 + 0xe8) != 0) {
    Sleep(0);
  }
  if ((*(uint *)(param_1 + 0x10) & 1) == 0) {
    FUN_18007eb80(*(void* *)(param_1 + 8),(byte)(*(uint *)(param_1 + 0x10) >> 2) & 1);
  }
  plVar2 = *(long long **)(*(long long *)(param_1 + 8) + 0x210);
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x28))(plVar2);
  }
  plVar3 = *(long long **)(param_1 + 0x18);
  *(long long **)(param_1 + 0x18) = plVar2;
  if (plVar3 != (long long *)0x0) {
    (**(code **)(*plVar3 + 0x38))();
  }
  return;
}




/**
 * @brief 系统状态更新函数
 * 
 * 该函数负责更新系统状态，处理系统事件和消息
 * 用于游戏运行时的状态管理和事件处理
 * 
 * @param SystemState 系统状态参数
 */
void UpdateSystemState(long long SystemState)

{
  FUN_18007f6a0();
  if (*(long long **)(param_1 + 0x18) != (long long *)0x0) {
    (**(code **)(**(long long **)(param_1 + 0x18) + 0x38))();
  }
  return;
}




// 函数: void FUN_18007f6a0(char *param_1,void* param_2,void* param_3,void* param_4)
void FUN_18007f6a0(char *param_1,void* param_2,void* param_3,void* param_4)

{
  long long lVar1;
  long long *plVar2;
  long long *plVar3;
  long long lVar4;
  void* uVar5;
  
  uVar5 = 0xfffffffffffffffe;
  lVar1 = *(long long *)(param_1 + 8);
  if (lVar1 != 0) {
    plVar2 = *(long long **)(param_1 + 0x18);
    if (plVar2 != (long long *)0x0) {
      (**(code **)(*plVar2 + 0x28))(plVar2);
    }
    plVar3 = *(long long **)(lVar1 + 0x210);
    *(long long **)(lVar1 + 0x210) = plVar2;
    if (plVar3 != (long long *)0x0) {
      (**(code **)(*plVar3 + 0x38))();
    }
    lVar1 = *(long long *)(param_1 + 8);
    if (*param_1 != '\0') {
      lVar4 = lVar1;
      if ((param_1[0x10] & 2U) == 0) {
        FUN_180079520(lVar1);
        FUN_180079520(*(void* *)(param_1 + 8));
        lVar4 = *(long long *)(param_1 + 8);
      }
      FUN_18007edd0(lVar4,1,param_3,param_4,uVar5);
      *(uint32_t *)(lVar1 + 0xf0) = 0;
      LOCK();
      *(uint8_t *)(lVar1 + 0xec) = 0;
      UNLOCK();
    }
  }
  param_1[8] = '\0';
  param_1[9] = '\0';
  param_1[10] = '\0';
  param_1[0xb] = '\0';
  param_1[0xc] = '\0';
  param_1[0xd] = '\0';
  param_1[0xe] = '\0';
  param_1[0xf] = '\0';
  plVar2 = *(long long **)(param_1 + 0x18);
  param_1[0x18] = '\0';
  param_1[0x19] = '\0';
  param_1[0x1a] = '\0';
  param_1[0x1b] = '\0';
  param_1[0x1c] = '\0';
  param_1[0x1d] = '\0';
  param_1[0x1e] = '\0';
  param_1[0x1f] = '\0';
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))();
  }
  return;
}




// 函数: void FUN_18007f770(long long *param_1)
void FUN_18007f770(long long *param_1)

{
  long long lVar1;
  char cVar2;
  int memoryCompareResult;
  bool bVar4;
  
  lVar1 = *param_1;
  iVar3 = _Thrd_id();
  while( true ) {
    LOCK();
    cVar2 = *(char *)(lVar1 + 0xec);
    bVar4 = cVar2 == '\0';
    if (bVar4) {
      *(char *)(lVar1 + 0xec) = '\x01';
      cVar2 = '\0';
    }
    UNLOCK();
    if (bVar4) break;
    if (*(int *)(lVar1 + 0xf0) == iVar3) goto LAB_18007f7cf;
    Sleep(0);
  }
  cVar2 = '\0';
LAB_18007f7cf:
  LOCK();
  *(int *)(lVar1 + 0xe8) = *(int *)(lVar1 + 0xe8) + 1;
  UNLOCK();
  if ((*(uint *)(param_1 + 1) & 1) == 0) {
    FUN_18007eb80(*param_1,(byte)(*(uint *)(param_1 + 1) >> 2) & 1);
  }
  if (cVar2 == '\0') {
    LOCK();
    *(uint8_t *)(lVar1 + 0xec) = 0;
    UNLOCK();
  }
  param_1[2] = *(long long *)(*param_1 + 0x210);
  return;
}




// 函数: void FUN_18007f820(void)
void FUN_18007f820(void)

{
  FUN_18007f840();
  return;
}




// 函数: void FUN_18007f840(long long *param_1)
void FUN_18007f840(long long *param_1)

{
  int *piVar1;
  long long lVar2;
  char cVar3;
  int iVar4;
  bool bVar5;
  
  lVar2 = *param_1;
  if (lVar2 != 0) {
    while( true ) {
      LOCK();
      cVar3 = *(char *)(lVar2 + 0xec);
      bVar5 = cVar3 == '\0';
      if (bVar5) {
        *(char *)(lVar2 + 0xec) = '\x01';
        cVar3 = '\0';
      }
      UNLOCK();
      if (bVar5) break;
      iVar4 = _Thrd_id();
      if ((*(int *)(lVar2 + 0xf0) == iVar4) || (*(int *)(lVar2 + 0xf0) != 0)) goto LAB_18007f89f;
      Sleep();
    }
    cVar3 = '\0';
LAB_18007f89f:
    LOCK();
    piVar1 = (int *)(lVar2 + 0xe8);
    iVar4 = *piVar1;
    *piVar1 = *piVar1 + -1;
    UNLOCK();
    if (cVar3 == '\0') {
      if (iVar4 == 1) {
        FUN_18007edd0(*param_1,0);
      }
      LOCK();
      *(uint8_t *)(lVar2 + 0xec) = 0;
      UNLOCK();
    }
    *param_1 = 0;
  }
  return;
}



uint FUN_18007f859(void)

{
  uint *puVar1;
  byte bVar2;
  char cVar3;
  int iVar4;
  uint uVar5;
  long long unaff_RBX;
  void* *unaff_RSI;
  bool bVar6;
  
  while( true ) {
    LOCK();
    cVar3 = *(char *)(unaff_RBX + 0xec);
    bVar6 = cVar3 == '\0';
    if (bVar6) {
      *(char *)(unaff_RBX + 0xec) = '\x01';
      cVar3 = '\0';
    }
    UNLOCK();
    if (bVar6) break;
    iVar4 = _Thrd_id();
    if ((*(int *)(unaff_RBX + 0xf0) == iVar4) || (*(int *)(unaff_RBX + 0xf0) != 0))
    goto LAB_18007f89f;
    Sleep();
  }
  cVar3 = '\0';
LAB_18007f89f:
  LOCK();
  puVar1 = (uint *)(unaff_RBX + 0xe8);
  uVar5 = *puVar1;
  *puVar1 = *puVar1 - 1;
  UNLOCK();
  if (cVar3 == '\0') {
    if (uVar5 == 1) {
      FUN_18007edd0(*unaff_RSI,0);
    }
    LOCK();
    bVar2 = *(byte *)(unaff_RBX + 0xec);
    *(byte *)(unaff_RBX + 0xec) = 0;
    uVar5 = (uint)bVar2;
    UNLOCK();
  }
  *unaff_RSI = 0;
  return uVar5;
}



uint8_t FUN_18007f8bb(void)

{
  uint8_t uVar1;
  int in_EAX;
  long long unaff_RBX;
  void* *unaff_RSI;
  
  if (in_EAX == 1) {
    FUN_18007edd0(*unaff_RSI,0);
  }
  LOCK();
  uVar1 = *(uint8_t *)(unaff_RBX + 0xec);
  *(uint8_t *)(unaff_RBX + 0xec) = 0;
  UNLOCK();
  *unaff_RSI = 0;
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f8f0(long long param_1)
void FUN_18007f8f0(long long param_1)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  char cVar4;
  uint32_t uVar5;
  uint uVar6;
  long long *plVar7;
  long long lVar8;
  int iVar9;
  int iVar10;
  long long lVar11;
  ulong long uVar12;
  char *pcVar13;
  uint *puVar14;
  int iVar15;
  uint uVar16;
  int iVar17;
  int iVar18;
  uint32_t *puVar19;
  uint *puVar20;
  ulong long uVar21;
  ulong long uVar22;
  bool bVar23;
  
  if (*(int *)(param_1 + 0x28) != *(int *)(_DAT_180c86870 + 0x224)) {
    iVar15 = *(int *)(param_1 + 0x1c) + *(int *)(param_1 + 0x18);
    *(int *)(param_1 + 0x28) = *(int *)(_DAT_180c86870 + 0x224);
    if (0 < iVar15) {
      lVar11 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
      uVar5 = FUN_180080380(lVar11,iVar15);
      *(uint32_t *)(param_1 + 0x30) = uVar5;
      FUN_1800802e0(lVar11,uVar5);
      if (*(long long *)(param_1 + 0x10) == 0) {
        if (*(int *)(param_1 + 0x18) != 0) {
          *(uint32_t *)(param_1 + 0x2c) = *(uint32_t *)(param_1 + 0x30);
          return;
        }
      }
      else {
        cVar4 = *(char *)(param_1 + 0x44);
        uVar12 = (ulong long)cVar4;
        plVar1 = (long long *)(param_1 + 0x38);
        iVar15 = (int)cVar4;
        if (*(int *)(param_1 + 0x40) == (int)cVar4) {
          plVar7 = (long long *)*plVar1;
        }
        else {
          *(int *)(param_1 + 0x40) = iVar15;
          if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          *plVar1 = 0;
          if (cVar4 == '\0') {
            plVar7 = (long long *)0x0;
            *plVar1 = 0;
          }
          else {
            plVar7 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar4 * 4);
            *plVar1 = (long long)plVar7;
          }
        }
        if (plVar7 != (long long *)0x0) {
          iVar17 = 0;
          uVar16 = (uint)cVar4;
          iVar18 = iVar17;
          if ((0 < iVar15) && (0xf < uVar16)) {
            iVar10 = *(int *)(param_1 + 0x2c);
            plVar2 = (long long *)((long long)plVar7 + (long long)(cVar4 + -1) * 4);
            if ((((long long *)(param_1 + 0x2c) < plVar7) || (plVar2 < (long long *)(param_1 + 0x2c)))
               && ((plVar1 < plVar7 || (iVar18 = 0, plVar2 < plVar1)))) {
              uVar6 = uVar16 & 0x8000000f;
              if ((int)uVar6 < 0) {
                uVar6 = (uVar6 - 1 | 0xfffffff0) + 1;
              }
              plVar7 = plVar7 + 4;
              iVar9 = 8;
              do {
                *(int *)(plVar7 + -4) = iVar17 + iVar10;
                *(int *)((long long)plVar7 + -0x1c) = iVar17 + 1 + iVar10;
                *(int *)(plVar7 + -3) = iVar17 + 2 + iVar10;
                *(int *)((long long)plVar7 + -0x14) = iVar17 + 3 + iVar10;
                iVar17 = iVar17 + 0x10;
                *(int *)(plVar7 + -2) = iVar9 + -4 + iVar10;
                *(int *)((long long)plVar7 + -0xc) = iVar9 + -3 + iVar10;
                *(int *)(plVar7 + -1) = iVar9 + -2 + iVar10;
                *(int *)((long long)plVar7 + -4) = iVar9 + -1 + iVar10;
                *(int *)plVar7 = iVar9 + iVar10;
                *(int *)((long long)plVar7 + 4) = iVar9 + 1 + iVar10;
                *(int *)(plVar7 + 1) = iVar9 + 2 + iVar10;
                *(int *)((long long)plVar7 + 0xc) = iVar9 + 3 + iVar10;
                *(int *)(plVar7 + 2) = iVar9 + 4 + iVar10;
                *(int *)((long long)plVar7 + 0x14) = iVar9 + 5 + iVar10;
                *(int *)(plVar7 + 3) = iVar9 + 6 + iVar10;
                *(int *)((long long)plVar7 + 0x1c) = iVar9 + 7 + iVar10;
                plVar7 = plVar7 + 8;
                iVar9 = iVar9 + 0x10;
                iVar18 = iVar17;
              } while (iVar17 < (int)(uVar16 - uVar6));
            }
          }
          for (lVar11 = (long long)iVar18; lVar11 < (long long)uVar12; lVar11 = lVar11 + 1) {
            iVar17 = *(int *)(param_1 + 0x2c) + iVar18;
            iVar18 = iVar18 + 1;
            *(int *)(*plVar1 + lVar11 * 4) = iVar17;
          }
          iVar18 = *(int *)(param_1 + 0x18);
          iVar17 = 0;
          if (0 < (long long)iVar18) {
            lVar11 = 0;
            do {
              iVar10 = *(int *)(param_1 + 0x30) + iVar17;
              iVar17 = iVar17 + 1;
              pbVar3 = (byte *)(*(long long *)(param_1 + 0x10) + lVar11);
              lVar11 = lVar11 + 1;
              *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar10;
            } while (lVar11 < iVar18);
          }
        }
        puVar14 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 +
                          _DAT_180c86890 + 0x9d0);
        if (iVar15 == 0) {
          uVar16 = (int)cVar4 - 1;
        }
        else {
          LOCK();
          uVar16 = *puVar14;
          *puVar14 = *puVar14 + (int)cVar4;
          UNLOCK();
          uVar21 = (ulong long)(uVar16 >> 0xb);
          uVar22 = (ulong long)(cVar4 + -1 + uVar16 >> 0xb);
          if (uVar21 <= uVar22) {
            pcVar13 = (char *)((long long)puVar14 + uVar21 + 0x108);
            lVar11 = (uVar22 - uVar21) + 1;
            puVar20 = puVar14 + uVar21 * 2 + 2;
            do {
              iVar18 = (int)uVar21;
              if (*(long long *)puVar20 == 0) {
                lVar8 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
                LOCK();
                bVar23 = *(long long *)(puVar14 + (long long)iVar18 * 2 + 2) == 0;
                if (bVar23) {
                  *(long long *)(puVar14 + (long long)iVar18 * 2 + 2) = lVar8;
                }
                UNLOCK();
                if (bVar23) {
                  LOCK();
                  *(uint8_t *)((long long)iVar18 + 0x108 + (long long)puVar14) = 0;
                  UNLOCK();
                }
                else {
                  if (lVar8 != 0) {
                    // WARNING: Subroutine does not return
                    FUN_18064e900();
                  }
                  do {
                  } while (*pcVar13 != '\0');
                }
              }
              else {
                do {
                } while (*pcVar13 != '\0');
              }
              uVar21 = (ulong long)(iVar18 + 1);
              puVar20 = puVar20 + 2;
              pcVar13 = pcVar13 + 1;
              lVar11 = lVar11 + -1;
            } while (lVar11 != 0);
          }
        }
        puVar19 = *(uint32_t **)(param_1 + 0x38);
        uVar6 = uVar16 >> 0xb;
        *(uint *)(param_1 + 0x2c) = uVar16;
        if (uVar6 == (int)cVar4 + uVar16 >> 0xb) {
                    // WARNING: Subroutine does not return
          memcpy(*(long long *)(puVar14 + (ulong long)uVar6 * 2 + 2) +
                 (ulong long)(uVar16 + uVar6 * -0x800) * 4,puVar19,(uVar12 & 0xffffffff) << 2);
        }
        if (iVar15 != 0) {
          uVar12 = uVar12 & 0xffffffff;
          do {
            uVar5 = *puVar19;
            puVar19 = puVar19 + 1;
            *(uint32_t *)
             (*(long long *)(puVar14 + (ulong long)(uVar16 >> 0xb) * 2 + 2) +
             (ulong long)(uVar16 + (uVar16 >> 0xb) * -0x800) * 4) = uVar5;
            uVar12 = uVar12 - 1;
            uVar16 = uVar16 + 1;
          } while (uVar12 != 0);
        }
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f90f(uint32_t param_1)
void FUN_18007f90f(uint32_t param_1)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  char cVar4;
  uint32_t uVar5;
  uint uVar6;
  long long *plVar7;
  long long lVar8;
  int iVar9;
  int iVar10;
  long long lVar11;
  ulong long uVar12;
  char *pcVar13;
  uint *puVar14;
  int iVar15;
  uint uVar16;
  long long unaff_RDI;
  int iVar17;
  int iVar18;
  uint32_t *puVar19;
  uint *puVar20;
  ulong long uVar21;
  ulong long uVar22;
  bool bVar23;
  
  iVar15 = *(int *)(unaff_RDI + 0x1c) + *(int *)(unaff_RDI + 0x18);
  *(uint32_t *)(unaff_RDI + 0x28) = param_1;
  if (0 < iVar15) {
    lVar11 = (long long)*(int *)(_DAT_180c86890 + 0xe78) * 0x128 + _DAT_180c86890 + 0xc28;
    uVar5 = FUN_180080380(lVar11,iVar15);
    *(uint32_t *)(unaff_RDI + 0x30) = uVar5;
    FUN_1800802e0(lVar11,uVar5);
    if (*(long long *)(unaff_RDI + 0x10) == 0) {
      if (*(int *)(unaff_RDI + 0x18) != 0) {
        *(uint32_t *)(unaff_RDI + 0x2c) = *(uint32_t *)(unaff_RDI + 0x30);
        return;
      }
    }
    else {
      cVar4 = *(char *)(unaff_RDI + 0x44);
      uVar12 = (ulong long)cVar4;
      plVar1 = (long long *)(unaff_RDI + 0x38);
      iVar15 = (int)cVar4;
      if (*(int *)(unaff_RDI + 0x40) == (int)cVar4) {
        plVar7 = (long long *)*plVar1;
      }
      else {
        *(int *)(unaff_RDI + 0x40) = iVar15;
        if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
          FUN_18064e900();
        }
        *plVar1 = 0;
        if (cVar4 == '\0') {
          plVar7 = (long long *)0x0;
          *plVar1 = 0;
        }
        else {
          plVar7 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar4 * 4);
          *plVar1 = (long long)plVar7;
        }
      }
      if (plVar7 != (long long *)0x0) {
        iVar17 = 0;
        uVar16 = (uint)cVar4;
        iVar18 = iVar17;
        if ((0 < iVar15) && (0xf < uVar16)) {
          iVar10 = *(int *)(unaff_RDI + 0x2c);
          plVar2 = (long long *)((long long)plVar7 + (long long)(cVar4 + -1) * 4);
          if ((((long long *)(unaff_RDI + 0x2c) < plVar7) ||
              (plVar2 < (long long *)(unaff_RDI + 0x2c))) &&
             ((plVar1 < plVar7 || (iVar18 = 0, plVar2 < plVar1)))) {
            uVar6 = uVar16 & 0x8000000f;
            if ((int)uVar6 < 0) {
              uVar6 = (uVar6 - 1 | 0xfffffff0) + 1;
            }
            plVar7 = plVar7 + 4;
            iVar9 = 8;
            do {
              *(int *)(plVar7 + -4) = iVar17 + iVar10;
              *(int *)((long long)plVar7 + -0x1c) = iVar17 + 1 + iVar10;
              *(int *)(plVar7 + -3) = iVar17 + 2 + iVar10;
              *(int *)((long long)plVar7 + -0x14) = iVar17 + 3 + iVar10;
              iVar17 = iVar17 + 0x10;
              *(int *)(plVar7 + -2) = iVar9 + -4 + iVar10;
              *(int *)((long long)plVar7 + -0xc) = iVar9 + -3 + iVar10;
              *(int *)(plVar7 + -1) = iVar9 + -2 + iVar10;
              *(int *)((long long)plVar7 + -4) = iVar9 + -1 + iVar10;
              *(int *)plVar7 = iVar9 + iVar10;
              *(int *)((long long)plVar7 + 4) = iVar9 + 1 + iVar10;
              *(int *)(plVar7 + 1) = iVar9 + 2 + iVar10;
              *(int *)((long long)plVar7 + 0xc) = iVar9 + 3 + iVar10;
              *(int *)(plVar7 + 2) = iVar9 + 4 + iVar10;
              *(int *)((long long)plVar7 + 0x14) = iVar9 + 5 + iVar10;
              *(int *)(plVar7 + 3) = iVar9 + 6 + iVar10;
              *(int *)((long long)plVar7 + 0x1c) = iVar9 + 7 + iVar10;
              plVar7 = plVar7 + 8;
              iVar9 = iVar9 + 0x10;
              iVar18 = iVar17;
            } while (iVar17 < (int)(uVar16 - uVar6));
          }
        }
        for (lVar11 = (long long)iVar18; lVar11 < (long long)uVar12; lVar11 = lVar11 + 1) {
          iVar17 = *(int *)(unaff_RDI + 0x2c) + iVar18;
          iVar18 = iVar18 + 1;
          *(int *)(*plVar1 + lVar11 * 4) = iVar17;
        }
        iVar18 = *(int *)(unaff_RDI + 0x18);
        iVar17 = 0;
        if (0 < (long long)iVar18) {
          lVar11 = 0;
          do {
            iVar10 = *(int *)(unaff_RDI + 0x30) + iVar17;
            iVar17 = iVar17 + 1;
            pbVar3 = (byte *)(*(long long *)(unaff_RDI + 0x10) + lVar11);
            lVar11 = lVar11 + 1;
            *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar10;
          } while (lVar11 < iVar18);
        }
      }
      puVar14 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 + _DAT_180c86890 + 0x9d0
                        );
      if (iVar15 == 0) {
        uVar16 = (int)cVar4 - 1;
      }
      else {
        LOCK();
        uVar16 = *puVar14;
        *puVar14 = *puVar14 + (int)cVar4;
        UNLOCK();
        uVar21 = (ulong long)(uVar16 >> 0xb);
        uVar22 = (ulong long)(cVar4 + -1 + uVar16 >> 0xb);
        if (uVar21 <= uVar22) {
          pcVar13 = (char *)((long long)puVar14 + uVar21 + 0x108);
          lVar11 = (uVar22 - uVar21) + 1;
          puVar20 = puVar14 + uVar21 * 2 + 2;
          do {
            iVar18 = (int)uVar21;
            if (*(long long *)puVar20 == 0) {
              lVar8 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
              LOCK();
              bVar23 = *(long long *)(puVar14 + (long long)iVar18 * 2 + 2) == 0;
              if (bVar23) {
                *(long long *)(puVar14 + (long long)iVar18 * 2 + 2) = lVar8;
              }
              UNLOCK();
              if (bVar23) {
                LOCK();
                *(uint8_t *)((long long)iVar18 + 0x108 + (long long)puVar14) = 0;
                UNLOCK();
              }
              else {
                if (lVar8 != 0) {
                    // WARNING: Subroutine does not return
                  FUN_18064e900();
                }
                do {
                } while (*pcVar13 != '\0');
              }
            }
            else {
              do {
              } while (*pcVar13 != '\0');
            }
            uVar21 = (ulong long)(iVar18 + 1);
            puVar20 = puVar20 + 2;
            pcVar13 = pcVar13 + 1;
            lVar11 = lVar11 + -1;
          } while (lVar11 != 0);
        }
      }
      puVar19 = *(uint32_t **)(unaff_RDI + 0x38);
      uVar6 = uVar16 >> 0xb;
      *(uint *)(unaff_RDI + 0x2c) = uVar16;
      if (uVar6 == (int)cVar4 + uVar16 >> 0xb) {
                    // WARNING: Subroutine does not return
        memcpy(*(long long *)(puVar14 + (ulong long)uVar6 * 2 + 2) +
               (ulong long)(uVar16 + uVar6 * -0x800) * 4,puVar19,(uVar12 & 0xffffffff) << 2);
      }
      if (iVar15 != 0) {
        uVar12 = uVar12 & 0xffffffff;
        do {
          uVar5 = *puVar19;
          puVar19 = puVar19 + 1;
          *(uint32_t *)
           (*(long long *)(puVar14 + (ulong long)(uVar16 >> 0xb) * 2 + 2) +
           (ulong long)(uVar16 + (uVar16 >> 0xb) * -0x800) * 4) = uVar5;
          uVar12 = uVar12 - 1;
          uVar16 = uVar16 + 1;
        } while (uVar12 != 0);
      }
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f933(void* param_1,long long param_2)
void FUN_18007f933(void* param_1,long long param_2)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  char cVar4;
  uint32_t uVar5;
  uint uVar6;
  long long *plVar7;
  long long lVar8;
  int iVar9;
  int iVar10;
  long long lVar11;
  ulong long uVar12;
  char *pcVar13;
  uint *puVar14;
  uint32_t unaff_ESI;
  uint uVar15;
  long long unaff_RDI;
  int iVar16;
  int iVar17;
  uint32_t *puVar18;
  int iVar19;
  uint *puVar20;
  ulong long uVar21;
  ulong long uVar22;
  bool bVar23;
  
  param_2 = (long long)*(int *)(param_2 + 0x250) * 0x128 + param_2;
  uVar5 = FUN_180080380(param_2,unaff_ESI);
  *(uint32_t *)(unaff_RDI + 0x30) = uVar5;
  FUN_1800802e0(param_2,uVar5);
  if (*(long long *)(unaff_RDI + 0x10) == 0) {
    if (*(int *)(unaff_RDI + 0x18) != 0) {
      *(uint32_t *)(unaff_RDI + 0x2c) = *(uint32_t *)(unaff_RDI + 0x30);
      return;
    }
  }
  else {
    cVar4 = *(char *)(unaff_RDI + 0x44);
    uVar12 = (ulong long)cVar4;
    plVar1 = (long long *)(unaff_RDI + 0x38);
    iVar19 = (int)cVar4;
    if (*(int *)(unaff_RDI + 0x40) == (int)cVar4) {
      plVar7 = (long long *)*plVar1;
    }
    else {
      *(int *)(unaff_RDI + 0x40) = iVar19;
      if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
        FUN_18064e900();
      }
      *plVar1 = 0;
      if (cVar4 == '\0') {
        plVar7 = (long long *)0x0;
        *plVar1 = 0;
      }
      else {
        plVar7 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)cVar4 * 4);
        *plVar1 = (long long)plVar7;
      }
    }
    if (plVar7 != (long long *)0x0) {
      iVar16 = 0;
      uVar15 = (uint)cVar4;
      iVar17 = iVar16;
      if ((0 < iVar19) && (0xf < uVar15)) {
        iVar10 = *(int *)(unaff_RDI + 0x2c);
        plVar2 = (long long *)((long long)plVar7 + (long long)(cVar4 + -1) * 4);
        if ((((long long *)(unaff_RDI + 0x2c) < plVar7) || (plVar2 < (long long *)(unaff_RDI + 0x2c)))
           && ((plVar1 < plVar7 || (iVar17 = 0, plVar2 < plVar1)))) {
          uVar6 = uVar15 & 0x8000000f;
          if ((int)uVar6 < 0) {
            uVar6 = (uVar6 - 1 | 0xfffffff0) + 1;
          }
          plVar7 = plVar7 + 4;
          iVar9 = 8;
          do {
            *(int *)(plVar7 + -4) = iVar16 + iVar10;
            *(int *)((long long)plVar7 + -0x1c) = iVar16 + 1 + iVar10;
            *(int *)(plVar7 + -3) = iVar16 + 2 + iVar10;
            *(int *)((long long)plVar7 + -0x14) = iVar16 + 3 + iVar10;
            iVar16 = iVar16 + 0x10;
            *(int *)(plVar7 + -2) = iVar9 + -4 + iVar10;
            *(int *)((long long)plVar7 + -0xc) = iVar9 + -3 + iVar10;
            *(int *)(plVar7 + -1) = iVar9 + -2 + iVar10;
            *(int *)((long long)plVar7 + -4) = iVar9 + -1 + iVar10;
            *(int *)plVar7 = iVar9 + iVar10;
            *(int *)((long long)plVar7 + 4) = iVar9 + 1 + iVar10;
            *(int *)(plVar7 + 1) = iVar9 + 2 + iVar10;
            *(int *)((long long)plVar7 + 0xc) = iVar9 + 3 + iVar10;
            *(int *)(plVar7 + 2) = iVar9 + 4 + iVar10;
            *(int *)((long long)plVar7 + 0x14) = iVar9 + 5 + iVar10;
            *(int *)(plVar7 + 3) = iVar9 + 6 + iVar10;
            *(int *)((long long)plVar7 + 0x1c) = iVar9 + 7 + iVar10;
            plVar7 = plVar7 + 8;
            iVar9 = iVar9 + 0x10;
            iVar17 = iVar16;
          } while (iVar16 < (int)(uVar15 - uVar6));
        }
      }
      for (lVar11 = (long long)iVar17; lVar11 < (long long)uVar12; lVar11 = lVar11 + 1) {
        iVar16 = *(int *)(unaff_RDI + 0x2c) + iVar17;
        iVar17 = iVar17 + 1;
        *(int *)(*plVar1 + lVar11 * 4) = iVar16;
      }
      iVar17 = *(int *)(unaff_RDI + 0x18);
      iVar16 = 0;
      if (0 < (long long)iVar17) {
        lVar11 = 0;
        do {
          iVar10 = *(int *)(unaff_RDI + 0x30) + iVar16;
          iVar16 = iVar16 + 1;
          pbVar3 = (byte *)(*(long long *)(unaff_RDI + 0x10) + lVar11);
          lVar11 = lVar11 + 1;
          *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar10;
        } while (lVar11 < iVar17);
      }
    }
    puVar14 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 + _DAT_180c86890 + 0x9d0);
    if (iVar19 == 0) {
      uVar15 = (int)cVar4 - 1;
    }
    else {
      LOCK();
      uVar15 = *puVar14;
      *puVar14 = *puVar14 + (int)cVar4;
      UNLOCK();
      uVar21 = (ulong long)(uVar15 >> 0xb);
      uVar22 = (ulong long)(cVar4 + -1 + uVar15 >> 0xb);
      if (uVar21 <= uVar22) {
        pcVar13 = (char *)((long long)puVar14 + uVar21 + 0x108);
        lVar11 = (uVar22 - uVar21) + 1;
        puVar20 = puVar14 + uVar21 * 2 + 2;
        do {
          iVar17 = (int)uVar21;
          if (*(long long *)puVar20 == 0) {
            lVar8 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
            LOCK();
            bVar23 = *(long long *)(puVar14 + (long long)iVar17 * 2 + 2) == 0;
            if (bVar23) {
              *(long long *)(puVar14 + (long long)iVar17 * 2 + 2) = lVar8;
            }
            UNLOCK();
            if (bVar23) {
              LOCK();
              *(uint8_t *)((long long)iVar17 + 0x108 + (long long)puVar14) = 0;
              UNLOCK();
            }
            else {
              if (lVar8 != 0) {
                    // WARNING: Subroutine does not return
                FUN_18064e900();
              }
              do {
              } while (*pcVar13 != '\0');
            }
          }
          else {
            do {
            } while (*pcVar13 != '\0');
          }
          uVar21 = (ulong long)(iVar17 + 1);
          puVar20 = puVar20 + 2;
          pcVar13 = pcVar13 + 1;
          lVar11 = lVar11 + -1;
        } while (lVar11 != 0);
      }
    }
    puVar18 = *(uint32_t **)(unaff_RDI + 0x38);
    uVar6 = uVar15 >> 0xb;
    *(uint *)(unaff_RDI + 0x2c) = uVar15;
    if (uVar6 == (int)cVar4 + uVar15 >> 0xb) {
                    // WARNING: Subroutine does not return
      memcpy(*(long long *)(puVar14 + (ulong long)uVar6 * 2 + 2) +
             (ulong long)(uVar15 + uVar6 * -0x800) * 4,puVar18,(uVar12 & 0xffffffff) << 2);
    }
    if (iVar19 != 0) {
      uVar12 = uVar12 & 0xffffffff;
      do {
        uVar5 = *puVar18;
        puVar18 = puVar18 + 1;
        *(uint32_t *)
         (*(long long *)(puVar14 + (ulong long)(uVar15 >> 0xb) * 2 + 2) +
         (ulong long)(uVar15 + (uVar15 >> 0xb) * -0x800) * 4) = uVar5;
        uVar12 = uVar12 - 1;
        uVar15 = uVar15 + 1;
      } while (uVar12 != 0);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f976(void)
void FUN_18007f976(void)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  uint32_t uVar4;
  uint uVar5;
  uint uVar6;
  long long *plVar7;
  long long lVar8;
  int iVar9;
  int iVar10;
  long long lVar11;
  uint uVar12;
  ulong long unaff_RBX;
  char *pcVar13;
  uint *puVar14;
  long long unaff_RDI;
  int iVar15;
  int iVar16;
  uint32_t *puVar17;
  ulong long uVar18;
  uint *puVar19;
  ulong long uVar20;
  bool bVar21;
  
  plVar1 = (long long *)(unaff_RDI + 0x38);
  uVar12 = (uint)unaff_RBX;
  if (*(uint *)(unaff_RDI + 0x40) == uVar12) {
    plVar7 = (long long *)*plVar1;
  }
  else {
    *(uint *)(unaff_RDI + 0x40) = uVar12;
    if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *plVar1 = 0;
    if ((char)unaff_RBX == '\0') {
      plVar7 = (long long *)0x0;
      *plVar1 = 0;
    }
    else {
      plVar7 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)(char)unaff_RBX * 4);
      *plVar1 = (long long)plVar7;
    }
  }
  if (plVar7 != (long long *)0x0) {
    iVar15 = 0;
    iVar16 = iVar15;
    if ((0 < (int)uVar12) && (0xf < uVar12)) {
      iVar10 = *(int *)(unaff_RDI + 0x2c);
      plVar2 = (long long *)((long long)plVar7 + (long long)(int)(uVar12 - 1) * 4);
      if ((((long long *)(unaff_RDI + 0x2c) < plVar7) || (plVar2 < (long long *)(unaff_RDI + 0x2c)))
         && ((plVar1 < plVar7 || (iVar16 = 0, plVar2 < plVar1)))) {
        uVar6 = uVar12 & 0x8000000f;
        if ((int)uVar6 < 0) {
          uVar6 = (uVar6 - 1 | 0xfffffff0) + 1;
        }
        plVar7 = plVar7 + 4;
        iVar9 = 8;
        do {
          *(int *)(plVar7 + -4) = iVar15 + iVar10;
          *(int *)((long long)plVar7 + -0x1c) = iVar15 + 1 + iVar10;
          *(int *)(plVar7 + -3) = iVar15 + 2 + iVar10;
          *(int *)((long long)plVar7 + -0x14) = iVar15 + 3 + iVar10;
          iVar15 = iVar15 + 0x10;
          *(int *)(plVar7 + -2) = iVar9 + -4 + iVar10;
          *(int *)((long long)plVar7 + -0xc) = iVar9 + -3 + iVar10;
          *(int *)(plVar7 + -1) = iVar9 + -2 + iVar10;
          *(int *)((long long)plVar7 + -4) = iVar9 + -1 + iVar10;
          *(int *)plVar7 = iVar9 + iVar10;
          *(int *)((long long)plVar7 + 4) = iVar9 + 1 + iVar10;
          *(int *)(plVar7 + 1) = iVar9 + 2 + iVar10;
          *(int *)((long long)plVar7 + 0xc) = iVar9 + 3 + iVar10;
          *(int *)(plVar7 + 2) = iVar9 + 4 + iVar10;
          *(int *)((long long)plVar7 + 0x14) = iVar9 + 5 + iVar10;
          *(int *)(plVar7 + 3) = iVar9 + 6 + iVar10;
          *(int *)((long long)plVar7 + 0x1c) = iVar9 + 7 + iVar10;
          plVar7 = plVar7 + 8;
          iVar9 = iVar9 + 0x10;
          iVar16 = iVar15;
        } while (iVar15 < (int)(uVar12 - uVar6));
      }
    }
    for (lVar11 = (long long)iVar16; lVar11 < (long long)unaff_RBX; lVar11 = lVar11 + 1) {
      iVar15 = *(int *)(unaff_RDI + 0x2c) + iVar16;
      iVar16 = iVar16 + 1;
      *(int *)(*plVar1 + lVar11 * 4) = iVar15;
    }
    iVar16 = *(int *)(unaff_RDI + 0x18);
    iVar15 = 0;
    if (0 < (long long)iVar16) {
      lVar11 = 0;
      do {
        iVar10 = *(int *)(unaff_RDI + 0x30) + iVar15;
        iVar15 = iVar15 + 1;
        pbVar3 = (byte *)(*(long long *)(unaff_RDI + 0x10) + lVar11);
        lVar11 = lVar11 + 1;
        *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar10;
      } while (lVar11 < iVar16);
    }
  }
  puVar14 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 + _DAT_180c86890 + 0x9d0);
  if (uVar12 == 0) {
    uVar6 = 0xffffffff;
  }
  else {
    LOCK();
    uVar6 = *puVar14;
    *puVar14 = *puVar14 + uVar12;
    UNLOCK();
    uVar18 = (ulong long)(uVar6 >> 0xb);
    uVar20 = (ulong long)((uVar12 - 1) + uVar6 >> 0xb);
    if (uVar18 <= uVar20) {
      pcVar13 = (char *)((long long)puVar14 + uVar18 + 0x108);
      lVar11 = (uVar20 - uVar18) + 1;
      puVar19 = puVar14 + uVar18 * 2 + 2;
      do {
        iVar16 = (int)uVar18;
        if (*(long long *)puVar19 == 0) {
          lVar8 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
          LOCK();
          bVar21 = *(long long *)(puVar14 + (long long)iVar16 * 2 + 2) == 0;
          if (bVar21) {
            *(long long *)(puVar14 + (long long)iVar16 * 2 + 2) = lVar8;
          }
          UNLOCK();
          if (bVar21) {
            LOCK();
            *(uint8_t *)((long long)iVar16 + 0x108 + (long long)puVar14) = 0;
            UNLOCK();
          }
          else {
            if (lVar8 != 0) {
                    // WARNING: Subroutine does not return
              FUN_18064e900();
            }
            do {
            } while (*pcVar13 != '\0');
          }
        }
        else {
          do {
          } while (*pcVar13 != '\0');
        }
        uVar18 = (ulong long)(iVar16 + 1);
        puVar19 = puVar19 + 2;
        pcVar13 = pcVar13 + 1;
        lVar11 = lVar11 + -1;
      } while (lVar11 != 0);
    }
  }
  puVar17 = *(uint32_t **)(unaff_RDI + 0x38);
  uVar5 = uVar6 >> 0xb;
  *(uint *)(unaff_RDI + 0x2c) = uVar6;
  if (uVar5 == uVar12 + uVar6 >> 0xb) {
                    // WARNING: Subroutine does not return
    memcpy(*(long long *)(puVar14 + (ulong long)uVar5 * 2 + 2) +
           (ulong long)(uVar6 + uVar5 * -0x800) * 4,puVar17,(unaff_RBX & 0xffffffff) << 2);
  }
  if (uVar12 != 0) {
    uVar18 = unaff_RBX & 0xffffffff;
    do {
      uVar4 = *puVar17;
      puVar17 = puVar17 + 1;
      *(uint32_t *)
       (*(long long *)(puVar14 + (ulong long)(uVar6 >> 0xb) * 2 + 2) +
       (ulong long)(uVar6 + (uVar6 >> 0xb) * -0x800) * 4) = uVar4;
      uVar18 = uVar18 - 1;
      uVar6 = uVar6 + 1;
    } while (uVar18 != 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007f983(void)
void FUN_18007f983(void)

{
  long long *plVar1;
  long long *plVar2;
  byte *pbVar3;
  uint32_t uVar4;
  uint uVar5;
  uint uVar6;
  long long *plVar7;
  long long lVar8;
  int iVar9;
  int iVar10;
  long long lVar11;
  int unaff_EBX;
  char *pcVar12;
  uint *puVar13;
  long long unaff_RDI;
  int iVar14;
  int iVar15;
  uint32_t *puVar16;
  ulong long uVar17;
  uint uVar18;
  ulong long unaff_R12;
  uint *puVar19;
  ulong long uVar20;
  bool bVar21;
  
  plVar1 = (long long *)(unaff_RDI + 0x38);
  uVar18 = (uint)unaff_R12;
  if (*(int *)(unaff_RDI + 0x40) == unaff_EBX) {
    plVar7 = (long long *)*plVar1;
  }
  else {
    *(uint *)(unaff_RDI + 0x40) = uVar18;
    if (*plVar1 != 0) {
                    // WARNING: Subroutine does not return
      FUN_18064e900();
    }
    *plVar1 = 0;
    if ((char)unaff_EBX == '\0') {
      plVar7 = (long long *)0x0;
      *plVar1 = 0;
    }
    else {
      plVar7 = (long long *)FUN_18062b1e0(_DAT_180c8ed18,(long long)(char)unaff_EBX * 4);
      *plVar1 = (long long)plVar7;
    }
  }
  if (plVar7 != (long long *)0x0) {
    iVar14 = 0;
    iVar15 = iVar14;
    if ((0 < (int)uVar18) && (0xf < uVar18)) {
      iVar10 = *(int *)(unaff_RDI + 0x2c);
      plVar2 = (long long *)((long long)plVar7 + (long long)(int)(uVar18 - 1) * 4);
      if ((((long long *)(unaff_RDI + 0x2c) < plVar7) || (plVar2 < (long long *)(unaff_RDI + 0x2c)))
         && ((plVar1 < plVar7 || (iVar15 = 0, plVar2 < plVar1)))) {
        uVar6 = uVar18 & 0x8000000f;
        if ((int)uVar6 < 0) {
          uVar6 = (uVar6 - 1 | 0xfffffff0) + 1;
        }
        plVar7 = plVar7 + 4;
        iVar9 = 8;
        do {
          *(int *)(plVar7 + -4) = iVar14 + iVar10;
          *(int *)((long long)plVar7 + -0x1c) = iVar14 + 1 + iVar10;
          *(int *)(plVar7 + -3) = iVar14 + 2 + iVar10;
          *(int *)((long long)plVar7 + -0x14) = iVar14 + 3 + iVar10;
          iVar14 = iVar14 + 0x10;
          *(int *)(plVar7 + -2) = iVar9 + -4 + iVar10;
          *(int *)((long long)plVar7 + -0xc) = iVar9 + -3 + iVar10;
          *(int *)(plVar7 + -1) = iVar9 + -2 + iVar10;
          *(int *)((long long)plVar7 + -4) = iVar9 + -1 + iVar10;
          *(int *)plVar7 = iVar9 + iVar10;
          *(int *)((long long)plVar7 + 4) = iVar9 + 1 + iVar10;
          *(int *)(plVar7 + 1) = iVar9 + 2 + iVar10;
          *(int *)((long long)plVar7 + 0xc) = iVar9 + 3 + iVar10;
          *(int *)(plVar7 + 2) = iVar9 + 4 + iVar10;
          *(int *)((long long)plVar7 + 0x14) = iVar9 + 5 + iVar10;
          *(int *)(plVar7 + 3) = iVar9 + 6 + iVar10;
          *(int *)((long long)plVar7 + 0x1c) = iVar9 + 7 + iVar10;
          plVar7 = plVar7 + 8;
          iVar9 = iVar9 + 0x10;
          iVar15 = iVar14;
        } while (iVar14 < (int)(uVar18 - uVar6));
      }
    }
    for (lVar11 = (long long)iVar15; lVar11 < (long long)unaff_R12; lVar11 = lVar11 + 1) {
      iVar14 = *(int *)(unaff_RDI + 0x2c) + iVar15;
      iVar15 = iVar15 + 1;
      *(int *)(*plVar1 + lVar11 * 4) = iVar14;
    }
    iVar15 = *(int *)(unaff_RDI + 0x18);
    iVar14 = 0;
    if (0 < (long long)iVar15) {
      lVar11 = 0;
      do {
        iVar10 = *(int *)(unaff_RDI + 0x30) + iVar14;
        iVar14 = iVar14 + 1;
        pbVar3 = (byte *)(*(long long *)(unaff_RDI + 0x10) + lVar11);
        lVar11 = lVar11 + 1;
        *(int *)(*plVar1 + (ulong long)*pbVar3 * 4) = iVar10;
      } while (lVar11 < iVar15);
    }
  }
  puVar13 = (uint *)((long long)*(int *)(_DAT_180c86890 + 0xc20) * 0x128 + _DAT_180c86890 + 0x9d0);
  if (uVar18 == 0) {
    uVar6 = 0xffffffff;
  }
  else {
    LOCK();
    uVar6 = *puVar13;
    *puVar13 = *puVar13 + uVar18;
    UNLOCK();
    uVar17 = (ulong long)(uVar6 >> 0xb);
    uVar20 = (ulong long)((uVar18 - 1) + uVar6 >> 0xb);
    if (uVar17 <= uVar20) {
      pcVar12 = (char *)((long long)puVar13 + uVar17 + 0x108);
      lVar11 = (uVar20 - uVar17) + 1;
      puVar19 = puVar13 + uVar17 * 2 + 2;
      do {
        iVar15 = (int)uVar17;
        if (*(long long *)puVar19 == 0) {
          lVar8 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
          LOCK();
          bVar21 = *(long long *)(puVar13 + (long long)iVar15 * 2 + 2) == 0;
          if (bVar21) {
            *(long long *)(puVar13 + (long long)iVar15 * 2 + 2) = lVar8;
          }
          UNLOCK();
          if (bVar21) {
            LOCK();
            *(uint8_t *)((long long)iVar15 + 0x108 + (long long)puVar13) = 0;
            UNLOCK();
          }
          else {
            if (lVar8 != 0) {
                    // WARNING: Subroutine does not return
              FUN_18064e900();
            }
            do {
            } while (*pcVar12 != '\0');
          }
        }
        else {
          do {
          } while (*pcVar12 != '\0');
        }
        uVar17 = (ulong long)(iVar15 + 1);
        puVar19 = puVar19 + 2;
        pcVar12 = pcVar12 + 1;
        lVar11 = lVar11 + -1;
      } while (lVar11 != 0);
    }
  }
  puVar16 = *(uint32_t **)(unaff_RDI + 0x38);
  uVar5 = uVar6 >> 0xb;
  *(uint *)(unaff_RDI + 0x2c) = uVar6;
  if (uVar5 == uVar18 + uVar6 >> 0xb) {
                    // WARNING: Subroutine does not return
    memcpy(*(long long *)(puVar13 + (ulong long)uVar5 * 2 + 2) +
           (ulong long)(uVar6 + uVar5 * -0x800) * 4,puVar16,(unaff_R12 & 0xffffffff) << 2);
  }
  if (uVar18 != 0) {
    uVar17 = unaff_R12 & 0xffffffff;
    do {
      uVar4 = *puVar16;
      puVar16 = puVar16 + 1;
      *(uint32_t *)
       (*(long long *)(puVar13 + (ulong long)(uVar6 >> 0xb) * 2 + 2) +
       (ulong long)(uVar6 + (uVar6 >> 0xb) * -0x800) * 4) = uVar4;
      uVar17 = uVar17 - 1;
      uVar6 = uVar6 + 1;
    } while (uVar17 != 0);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007fb5f(void)
void FUN_18007fb5f(void)

{
  uint32_t uVar1;
  long long lVar2;
  uint uVar3;
  char *pcVar4;
  uint *unaff_RBP;
  uint uVar5;
  long long unaff_RDI;
  uint32_t *puVar6;
  ulong long uVar7;
  uint unaff_R12D;
  void* *unaff_R13;
  uint *puVar8;
  int iVar9;
  ulong long uVar10;
  long long lVar11;
  bool bVar12;
  
  LOCK();
  uVar5 = *unaff_RBP;
  *unaff_RBP = *unaff_RBP + unaff_R12D;
  UNLOCK();
  uVar7 = (ulong long)(uVar5 >> 0xb);
  uVar10 = (ulong long)((unaff_R12D - 1) + uVar5 >> 0xb);
  if (uVar7 <= uVar10) {
    pcVar4 = (char *)((long long)unaff_RBP + uVar7 + 0x108);
    lVar11 = (uVar10 - uVar7) + 1;
    puVar8 = unaff_RBP + (ulong long)(uVar5 >> 0xb) * 2 + 2;
    do {
      iVar9 = (int)uVar7;
      if (*(long long *)puVar8 == 0) {
        lVar2 = CreateSystemThreadObject(_DAT_180c8ed18,0x2000,0x25);
        LOCK();
        bVar12 = *(long long *)(unaff_RBP + (long long)iVar9 * 2 + 2) == 0;
        if (bVar12) {
          *(long long *)(unaff_RBP + (long long)iVar9 * 2 + 2) = lVar2;
        }
        UNLOCK();
        if (bVar12) {
          LOCK();
          *(uint8_t *)((long long)iVar9 + 0x108 + (long long)unaff_RBP) = 0;
          UNLOCK();
        }
        else {
          if (lVar2 != 0) {
                    // WARNING: Subroutine does not return
            FUN_18064e900();
          }
          do {
          } while (*pcVar4 != '\0');
        }
      }
      else {
        do {
        } while (*pcVar4 != '\0');
      }
      uVar7 = (ulong long)(iVar9 + 1);
      puVar8 = puVar8 + 2;
      pcVar4 = pcVar4 + 1;
      lVar11 = lVar11 + -1;
    } while (lVar11 != 0);
    unaff_R13 = (void* *)(unaff_RDI + 0x38);
  }
  puVar6 = (uint32_t *)*unaff_R13;
  uVar3 = uVar5 >> 0xb;
  *(uint *)(unaff_RDI + 0x2c) = uVar5;
  if (uVar3 != unaff_R12D + uVar5 >> 0xb) {
    if (unaff_R12D != 0) {
      uVar7 = (ulong long)unaff_R12D;
      do {
        uVar1 = *puVar6;
        puVar6 = puVar6 + 1;
        *(uint32_t *)
         (*(long long *)(unaff_RBP + (ulong long)(uVar5 >> 0xb) * 2 + 2) +
         (ulong long)(uVar5 + (uVar5 >> 0xb) * -0x800) * 4) = uVar1;
        uVar7 = uVar7 - 1;
        uVar5 = uVar5 + 1;
      } while (uVar7 != 0);
    }
    return;
  }
                    // WARNING: Subroutine does not return
  memcpy(*(long long *)(unaff_RBP + (ulong long)uVar3 * 2 + 2) +
         (ulong long)(uVar5 + uVar3 * -0x800) * 4,puVar6,(ulong long)unaff_R12D << 2);
}




// 函数: void FUN_18007fc19(void)
void FUN_18007fc19(void)

{
  uint32_t uVar1;
  uint uVar2;
  long long unaff_RBP;
  uint unaff_ESI;
  long long unaff_RDI;
  uint32_t *puVar3;
  ulong long uVar4;
  uint unaff_R12D;
  void* *unaff_R13;
  
  puVar3 = (uint32_t *)*unaff_R13;
  uVar2 = unaff_ESI >> 0xb;
  *(uint *)(unaff_RDI + 0x2c) = unaff_ESI;
  if (uVar2 != unaff_R12D + unaff_ESI >> 0xb) {
    if (unaff_R12D != 0) {
      uVar4 = (ulong long)unaff_R12D;
      do {
        uVar1 = *puVar3;
        puVar3 = puVar3 + 1;
        *(uint32_t *)
         (*(long long *)(unaff_RBP + 8 + (ulong long)(unaff_ESI >> 0xb) * 8) +
         (ulong long)(unaff_ESI + (unaff_ESI >> 0xb) * -0x800) * 4) = uVar1;
        uVar4 = uVar4 - 1;
        unaff_ESI = unaff_ESI + 1;
      } while (uVar4 != 0);
    }
    return;
  }
                    // WARNING: Subroutine does not return
  memcpy(*(long long *)(unaff_RBP + 8 + (ulong long)uVar2 * 8) +
         (ulong long)(unaff_ESI + uVar2 * -0x800) * 4,puVar3,(ulong long)unaff_R12D << 2);
}




// 函数: void FUN_18007fc35(long long param_1,void* param_2,void* param_3,void* param_4)
void FUN_18007fc35(long long param_1,void* param_2,void* param_3,void* param_4)

{
  long long unaff_RBP;
  int unaff_ESI;
  uint unaff_R12D;
  
                    // WARNING: Subroutine does not return
  memcpy(*(long long *)(unaff_RBP + 8 + param_1 * 8) +
         (ulong long)(uint)(unaff_ESI + (int)param_1 * -0x800) * 4,param_4,(ulong long)unaff_R12D << 2
        );
}




// 函数: void FUN_18007fc63(void)
void FUN_18007fc63(void)

{
  return;
}




// 函数: void FUN_18007fc68(void)
void FUN_18007fc68(void)

{
  return;
}




// 函数: void FUN_18007fc6d(void)
void FUN_18007fc6d(void)

{
  return;
}




// 函数: void FUN_18007fc73(void)
void FUN_18007fc73(void)

{
  uint32_t uVar1;
  long long unaff_RBP;
  uint unaff_ESI;
  uint32_t *in_R9;
  ulong long uVar2;
  uint unaff_R12D;
  
  if (unaff_R12D != 0) {
    uVar2 = (ulong long)unaff_R12D;
    do {
      uVar1 = *in_R9;
      in_R9 = in_R9 + 1;
      *(uint32_t *)
       (*(long long *)(unaff_RBP + 8 + (ulong long)(unaff_ESI >> 0xb) * 8) +
       (ulong long)(unaff_ESI + (unaff_ESI >> 0xb) * -0x800) * 4) = uVar1;
      uVar2 = uVar2 - 1;
      unaff_ESI = unaff_ESI + 1;
    } while (uVar2 != 0);
  }
  return;
}




// 函数: void FUN_18007fca8(void)
void FUN_18007fca8(void)

{
  long long unaff_RDI;
  
  if (*(int *)(unaff_RDI + 0x18) != 0) {
    *(uint32_t *)(unaff_RDI + 0x2c) = *(uint32_t *)(unaff_RDI + 0x30);
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void SystemInitializationFunction(void* param_1,void* param_2,void* param_3)
void SystemInitializationFunction(void* param_1,void* param_2,void* param_3)

{
  void* uVar1;
  long long *plVar2;
  
  uVar1 = FUN_18062b1e0(_DAT_180c8ed18,0xf0,8,3,0xfffffffffffffffe);
  plVar2 = (long long *)FUN_18007f2f0(uVar1);
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x28))(plVar2);
  }
  FUN_18007e2b0(plVar2,param_1);
  FUN_18007e5b0(plVar2,param_3);
  if (plVar2 != (long long *)0x0) {
    (**(code **)(*plVar2 + 0x38))(plVar2);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void FUN_18007fd60(void* param_1,long long param_2,void* param_3,long long param_4)
void FUN_18007fd60(void* param_1,long long param_2,void* param_3,long long param_4)

{
  long long *plVar1;
  int iVar2;
  uint8_t auStack_338 [32];
  long long *plStack_318;
  long long *aplStack_310 [2];
  void* uStack_300;
  ulong long uStack_58;
  
  uStack_300 = 0xfffffffffffffffe;
  uStack_58 = _DAT_180bf00a8 ^ (ulong long)auStack_338;
  *(long long *)(param_4 + 8) = *(long long *)(param_4 + 8) + 4;
  iVar2 = *(int *)(param_2 + 0x14) * *(int *)(param_2 + 0x10);
  plVar1 = (long long *)FUN_180081590(param_1,aplStack_310,iVar2);
  plVar1 = (long long *)*plVar1;
  if (plVar1 != (long long *)0x0) {
    plStack_318 = plVar1;
    (**(code **)(*plVar1 + 0x28))(plVar1);
  }
  plStack_318 = *(long long **)(param_2 + 0x20);
  *(long long **)(param_2 + 0x20) = plVar1;
  if (plStack_318 != (long long *)0x0) {
    (**(code **)(*plStack_318 + 0x38))();
  }
  if (aplStack_310[0] != (long long *)0x0) {
    (**(code **)(*aplStack_310[0] + 0x38))();
  }
                    // WARNING: Subroutine does not return
  memcpy(*(void* *)(*(long long *)(param_2 + 0x20) + 0x10),*(void* *)(param_4 + 8),
         (long long)iVar2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address


// 函数: void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* initializationFlags);
void InitializeSystemEntryPoint(long long systemContext,void* entryPointData,void* memoryPool,void* initializationFlags);

// 函数: void ExecuteSystemEntryPoint(void* *entryPointPtr);
void ExecuteSystemEntryPoint(void* *entryPointPtr);

// 函数: 系统初始化完成检查函数
undefined SystemInitializationCompleteCheck;

// 函数: 系统配置验证函数
undefined SystemConfigurationValidation;
uint32_t SystemStatusIndicator;
undefined SystemInitializationFlag;
undefined SystemConfigurationFlag;

void* FUN_180779434(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  float *pfVar12;
  int unaff_EBX;
  float *unaff_RDI;
  uint uVar13;
  int iVar14;
  uint in_R9D;
  uint in_R10D;
  int unaff_R13D;
  long long unaff_R14;
  uint uVar15;
  uint uVar16;
  float fVar17;
  uint8_t auVar18 [16];
  float fVar19;
  int in_XMM5_Da;
  float fVar20;
  int in_XMM5_Db;
  float fVar22;
  int in_XMM5_Dc;
  float fVar23;
  int in_XMM5_Dd;
  uint8_t auVar21 [16];
  float fVar24;
  float unaff_XMM6_Da;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  float fVar31;
  float fVar32;
  float fVar33;
  float fVar34;
  float unaff_XMM9_Da;
  float fVar35;
  float fVar36;
  float fVar37;
  float fVar38;
  int unaff_XMM12_Da;
  int unaff_XMM12_Db;
  int unaff_XMM12_Dc;
  int unaff_XMM12_Dd;
  float *in_stack_00000120;
  
  pfVar12 = unaff_RDI;
  do {
    uVar10 = 0;
    iVar11 = unaff_R13D;
    uVar13 = in_R10D;
    if (unaff_R13D != 0) {
      do {
        uVar9 = uVar13 & 1;
        uVar13 = uVar13 >> 1;
        uVar10 = uVar10 * 2 | uVar9;
        iVar11 = iVar11 + -1;
      } while (iVar11 != 0);
    }
    in_R10D = in_R10D + 1;
    fVar17 = *(float *)(*(long long *)(unaff_R14 + 0x218) + 4 + (long long)(int)uVar10 * 8);
    fVar29 = *(float *)(*(long long *)(unaff_R14 + 0x218) + (long long)(int)uVar10 * 8);
    fVar17 = SQRT(fVar29 * fVar29 + fVar17 * fVar17) * 2.5;
    if (unaff_XMM9_Da <= fVar17) {
      fVar17 = unaff_XMM9_Da;
    }
    *pfVar12 = fVar17;
    pfVar12 = pfVar12 + 1;
  } while ((int)in_R10D < (int)in_R9D);
  if (in_stack_00000120 != (float *)0x0) {
    iVar11 = 0;
    if (0 < (int)in_R9D) {
      fVar17 = unaff_XMM6_Da;
      if (7 < in_R9D) {
        uVar13 = in_R9D & 0x80000007;
        if ((int)uVar13 < 0) {
          uVar13 = (uVar13 - 1 | 0xfffffff8) + 1;
        }
        auVar21._0_4_ = in_XMM5_Da + -1;
        auVar21._4_4_ = in_XMM5_Db + -1;
        auVar21._8_4_ = in_XMM5_Dc + -1;
        auVar21._12_4_ = in_XMM5_Dd + -1;
        auVar18._0_4_ = (float)auVar21._0_4_;
        auVar18._4_4_ = (float)auVar21._4_4_;
        auVar18._8_4_ = (float)auVar21._8_4_;
        auVar18._12_4_ = (float)auVar21._12_4_;
        auVar21 = rcpps(auVar21,auVar18);
        fVar17 = 0.0;
        fVar29 = 0.0;
        fVar31 = 0.0;
        fVar19 = 0.0;
        fVar20 = auVar21._0_4_;
        fVar22 = auVar21._4_4_;
        fVar23 = auVar21._8_4_;
        fVar24 = auVar21._12_4_;
        fVar30 = 0.0;
        fVar32 = 0.0;
        fVar33 = 0.0;
        fVar34 = 0.0;
        fVar35 = 0.0;
        fVar36 = 0.0;
        fVar37 = 0.0;
        fVar38 = 0.0;
        fVar25 = 0.0;
        fVar26 = 0.0;
        fVar27 = 0.0;
        fVar28 = 0.0;
        fVar20 = (fVar20 + fVar20) - fVar20 * fVar20 * auVar18._0_4_;
        fVar22 = (fVar22 + fVar22) - fVar22 * fVar22 * auVar18._4_4_;
        fVar23 = (fVar23 + fVar23) - fVar23 * fVar23 * auVar18._8_4_;
        fVar24 = (fVar24 + fVar24) - fVar24 * fVar24 * auVar18._12_4_;
        pfVar12 = unaff_RDI;
        iVar14 = iVar11;
        do {
          fVar1 = *pfVar12;
          fVar2 = pfVar12[1];
          fVar3 = pfVar12[2];
          fVar4 = pfVar12[3];
          uVar10 = -(uint)(0.0001 < fVar1);
          uVar9 = -(uint)(0.0001 < fVar2);
          uVar15 = -(uint)(0.0001 < fVar3);
          uVar16 = -(uint)(0.0001 < fVar4);
          iVar11 = iVar14 + 8;
          fVar5 = pfVar12[4];
          fVar6 = pfVar12[5];
          fVar7 = pfVar12[6];
          fVar8 = pfVar12[7];
          pfVar12 = pfVar12 + 8;
          fVar17 = (float)((uint)((float)iVar14 * (float)unaff_XMM12_Da * 0.5 * fVar20 * fVar1 +
                                 fVar17) & uVar10 | ~uVar10 & (uint)fVar17);
          fVar29 = (float)((uint)((float)(iVar14 + 1) * (float)unaff_XMM12_Db * 0.5 * fVar22 * fVar2
                                 + fVar29) & uVar9 | ~uVar9 & (uint)fVar29);
          fVar31 = (float)((uint)((float)(iVar14 + 2) * (float)unaff_XMM12_Dc * 0.5 * fVar23 * fVar3
                                 + fVar31) & uVar15 | ~uVar15 & (uint)fVar31);
          fVar19 = (float)((uint)((float)(iVar14 + 3) * (float)unaff_XMM12_Dd * 0.5 * fVar24 * fVar4
                                 + fVar19) & uVar16 | ~uVar16 & (uint)fVar19);
          fVar25 = (float)((uint)(fVar1 + fVar25) & uVar10 | ~uVar10 & (uint)fVar25);
          fVar26 = (float)((uint)(fVar2 + fVar26) & uVar9 | ~uVar9 & (uint)fVar26);
          fVar27 = (float)((uint)(fVar3 + fVar27) & uVar15 | ~uVar15 & (uint)fVar27);
          fVar28 = (float)((uint)(fVar4 + fVar28) & uVar16 | ~uVar16 & (uint)fVar28);
          uVar10 = -(uint)(0.0001 < fVar5);
          uVar9 = -(uint)(0.0001 < fVar6);
          uVar15 = -(uint)(0.0001 < fVar7);
          uVar16 = -(uint)(0.0001 < fVar8);
          fVar30 = (float)((uint)((float)(iVar14 + 4) * (float)unaff_XMM12_Da * 0.5 * fVar20 * fVar5
                                 + fVar30) & uVar10 | ~uVar10 & (uint)fVar30);
          fVar32 = (float)((uint)((float)(iVar14 + 5) * (float)unaff_XMM12_Db * 0.5 * fVar22 * fVar6
                                 + fVar32) & uVar9 | ~uVar9 & (uint)fVar32);
          fVar33 = (float)((uint)((float)(iVar14 + 6) * (float)unaff_XMM12_Dc * 0.5 * fVar23 * fVar7
                                 + fVar33) & uVar15 | ~uVar15 & (uint)fVar33);
          fVar34 = (float)((uint)((float)(iVar14 + 7) * (float)unaff_XMM12_Dd * 0.5 * fVar24 * fVar8
                                 + fVar34) & uVar16 | ~uVar16 & (uint)fVar34);
          fVar35 = (float)((uint)(fVar5 + fVar35) & uVar10 | ~uVar10 & (uint)fVar35);
          fVar36 = (float)((uint)(fVar6 + fVar36) & uVar9 | ~uVar9 & (uint)fVar36);
          fVar37 = (float)((uint)(fVar7 + fVar37) & uVar15 | ~uVar15 & (uint)fVar37);
          fVar38 = (float)((uint)(fVar8 + fVar38) & uVar16 | ~uVar16 & (uint)fVar38);
          iVar14 = iVar11;
        } while (iVar11 < (int)(in_R9D - uVar13));
        unaff_XMM6_Da = fVar27 + fVar37 + fVar25 + fVar35 + fVar28 + fVar38 + fVar26 + fVar36;
        fVar17 = fVar31 + fVar33 + fVar17 + fVar30 + fVar19 + fVar34 + fVar29 + fVar32;
      }
      if (iVar11 < (int)in_R9D) {
        if (3 < (int)(in_R9D - iVar11)) {
          iVar14 = iVar11 + 2;
          fVar29 = (float)unaff_EBX;
          pfVar12 = unaff_RDI + (long long)iVar11 + 2;
          fVar31 = (float)(int)in_R9D;
          do {
            fVar19 = pfVar12[-2];
            if (0.0001 < fVar19) {
              unaff_XMM6_Da = unaff_XMM6_Da + fVar19;
              fVar17 = fVar17 + ((fVar29 * 0.5 * (float)iVar11) / fVar31) * fVar19;
            }
            fVar19 = pfVar12[-1];
            if (0.0001 < fVar19) {
              unaff_XMM6_Da = unaff_XMM6_Da + fVar19;
              fVar17 = fVar17 + (((float)(iVar14 + -1) * fVar29 * 0.5) / fVar31) * fVar19;
            }
            fVar19 = *pfVar12;
            if (0.0001 < fVar19) {
              unaff_XMM6_Da = unaff_XMM6_Da + fVar19;
              fVar17 = fVar17 + (((float)iVar14 * fVar29 * 0.5) / fVar31) * fVar19;
            }
            fVar19 = pfVar12[1];
            if (0.0001 < fVar19) {
              unaff_XMM6_Da = unaff_XMM6_Da + fVar19;
              fVar17 = fVar17 + (((float)(iVar14 + 1) * fVar29 * 0.5) / fVar31) * fVar19;
            }
            pfVar12 = pfVar12 + 4;
            iVar11 = iVar11 + 4;
            iVar14 = iVar14 + 4;
          } while (iVar11 < (int)(in_R9D - 3));
        }
        if (iVar11 < (int)in_R9D) {
          pfVar12 = unaff_RDI + iVar11;
          do {
            fVar29 = *pfVar12;
            if (0.0001 < fVar29) {
              unaff_XMM6_Da = unaff_XMM6_Da + fVar29;
              fVar17 = fVar17 + (((float)unaff_EBX * 0.5 * (float)iVar11) / (float)(int)in_R9D) *
                                fVar29;
            }
            pfVar12 = pfVar12 + 1;
            iVar11 = iVar11 + 1;
          } while (iVar11 < (int)in_R9D);
        }
      }
      if (0.001 < unaff_XMM6_Da) {
        *in_stack_00000120 = fVar17 / unaff_XMM6_Da;
        return 0;
      }
    }
    *in_stack_00000120 = 0.0;
  }
  return 0;
}



void* FUN_1807794c5(void)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  uint uVar9;
  int iVar10;
  float *pfVar11;
  int unaff_EBX;
  float *unaff_RDI;
  int iVar12;
  uint in_R9D;
  float *in_R11;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint8_t auVar17 [16];
  float fVar18;
  int in_XMM5_Da;
  float fVar19;
  int in_XMM5_Db;
  float fVar21;
  int in_XMM5_Dc;
  float fVar22;
  int in_XMM5_Dd;
  uint8_t auVar20 [16];
  float fVar23;
  float unaff_XMM6_Da;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  float fVar31;
  float fVar32;
  float fVar33;
  float fVar34;
  float fVar35;
  float fVar36;
  float fVar37;
  float fVar38;
  int unaff_XMM12_Da;
  int unaff_XMM12_Db;
  int unaff_XMM12_Dc;
  int unaff_XMM12_Dd;
  
  iVar10 = 0;
  if (0 < (int)in_R9D) {
    fVar25 = unaff_XMM6_Da;
    if (7 < in_R9D) {
      uVar9 = in_R9D & 0x80000007;
      if ((int)uVar9 < 0) {
        uVar9 = (uVar9 - 1 | 0xfffffff8) + 1;
      }
      auVar20._0_4_ = in_XMM5_Da + -1;
      auVar20._4_4_ = in_XMM5_Db + -1;
      auVar20._8_4_ = in_XMM5_Dc + -1;
      auVar20._12_4_ = in_XMM5_Dd + -1;
      auVar17._0_4_ = (float)auVar20._0_4_;
      auVar17._4_4_ = (float)auVar20._4_4_;
      auVar17._8_4_ = (float)auVar20._8_4_;
      auVar17._12_4_ = (float)auVar20._12_4_;
      auVar20 = rcpps(auVar20,auVar17);
      fVar25 = 0.0;
      fVar29 = 0.0;
      fVar31 = 0.0;
      fVar18 = 0.0;
      fVar19 = auVar20._0_4_;
      fVar21 = auVar20._4_4_;
      fVar22 = auVar20._8_4_;
      fVar23 = auVar20._12_4_;
      fVar30 = 0.0;
      fVar32 = 0.0;
      fVar33 = 0.0;
      fVar34 = 0.0;
      fVar35 = 0.0;
      fVar36 = 0.0;
      fVar37 = 0.0;
      fVar38 = 0.0;
      fVar24 = 0.0;
      fVar26 = 0.0;
      fVar27 = 0.0;
      fVar28 = 0.0;
      fVar19 = (fVar19 + fVar19) - fVar19 * fVar19 * auVar17._0_4_;
      fVar21 = (fVar21 + fVar21) - fVar21 * fVar21 * auVar17._4_4_;
      fVar22 = (fVar22 + fVar22) - fVar22 * fVar22 * auVar17._8_4_;
      fVar23 = (fVar23 + fVar23) - fVar23 * fVar23 * auVar17._12_4_;
      pfVar11 = unaff_RDI;
      iVar12 = iVar10;
      do {
        fVar1 = *pfVar11;
        fVar2 = pfVar11[1];
        fVar3 = pfVar11[2];
        fVar4 = pfVar11[3];
        uVar13 = -(uint)(0.0001 < fVar1);
        uVar14 = -(uint)(0.0001 < fVar2);
        uVar15 = -(uint)(0.0001 < fVar3);
        uVar16 = -(uint)(0.0001 < fVar4);
        iVar10 = iVar12 + 8;
        fVar5 = pfVar11[4];
        fVar6 = pfVar11[5];
        fVar7 = pfVar11[6];
        fVar8 = pfVar11[7];
        pfVar11 = pfVar11 + 8;
        fVar25 = (float)((uint)((float)iVar12 * (float)unaff_XMM12_Da * 0.5 * fVar19 * fVar1 +
                               fVar25) & uVar13 | ~uVar13 & (uint)fVar25);
        fVar29 = (float)((uint)((float)(iVar12 + 1) * (float)unaff_XMM12_Db * 0.5 * fVar21 * fVar2 +
                               fVar29) & uVar14 | ~uVar14 & (uint)fVar29);
        fVar31 = (float)((uint)((float)(iVar12 + 2) * (float)unaff_XMM12_Dc * 0.5 * fVar22 * fVar3 +
                               fVar31) & uVar15 | ~uVar15 & (uint)fVar31);
        fVar18 = (float)((uint)((float)(iVar12 + 3) * (float)unaff_XMM12_Dd * 0.5 * fVar23 * fVar4 +
                               fVar18) & uVar16 | ~uVar16 & (uint)fVar18);
        fVar24 = (float)((uint)(fVar1 + fVar24) & uVar13 | ~uVar13 & (uint)fVar24);
        fVar26 = (float)((uint)(fVar2 + fVar26) & uVar14 | ~uVar14 & (uint)fVar26);
        fVar27 = (float)((uint)(fVar3 + fVar27) & uVar15 | ~uVar15 & (uint)fVar27);
        fVar28 = (float)((uint)(fVar4 + fVar28) & uVar16 | ~uVar16 & (uint)fVar28);
        uVar13 = -(uint)(0.0001 < fVar5);
        uVar14 = -(uint)(0.0001 < fVar6);
        uVar15 = -(uint)(0.0001 < fVar7);
        uVar16 = -(uint)(0.0001 < fVar8);
        fVar30 = (float)((uint)((float)(iVar12 + 4) * (float)unaff_XMM12_Da * 0.5 * fVar19 * fVar5 +
                               fVar30) & uVar13 | ~uVar13 & (uint)fVar30);
        fVar32 = (float)((uint)((float)(iVar12 + 5) * (float)unaff_XMM12_Db * 0.5 * fVar21 * fVar6 +
                               fVar32) & uVar14 | ~uVar14 & (uint)fVar32);
        fVar33 = (float)((uint)((float)(iVar12 + 6) * (float)unaff_XMM12_Dc * 0.5 * fVar22 * fVar7 +
                               fVar33) & uVar15 | ~uVar15 & (uint)fVar33);
        fVar34 = (float)((uint)((float)(iVar12 + 7) * (float)unaff_XMM12_Dd * 0.5 * fVar23 * fVar8 +
                               fVar34) & uVar16 | ~uVar16 & (uint)fVar34);
        fVar35 = (float)((uint)(fVar5 + fVar35) & uVar13 | ~uVar13 & (uint)fVar35);
        fVar36 = (float)((uint)(fVar6 + fVar36) & uVar14 | ~uVar14 & (uint)fVar36);
        fVar37 = (float)((uint)(fVar7 + fVar37) & uVar15 | ~uVar15 & (uint)fVar37);
        fVar38 = (float)((uint)(fVar8 + fVar38) & uVar16 | ~uVar16 & (uint)fVar38);
        iVar12 = iVar10;
      } while (iVar10 < (int)(in_R9D - uVar9));
      unaff_XMM6_Da = fVar27 + fVar37 + fVar24 + fVar35 + fVar28 + fVar38 + fVar26 + fVar36;
      fVar25 = fVar31 + fVar33 + fVar25 + fVar30 + fVar18 + fVar34 + fVar29 + fVar32;
    }
    if (iVar10 < (int)in_R9D) {
      if (3 < (int)(in_R9D - iVar10)) {
        iVar12 = iVar10 + 2;
        fVar29 = (float)unaff_EBX;
        pfVar11 = unaff_RDI + (long long)iVar10 + 2;
        fVar31 = (float)(int)in_R9D;
        do {
          fVar18 = pfVar11[-2];
          if (0.0001 < fVar18) {
            unaff_XMM6_Da = unaff_XMM6_Da + fVar18;
            fVar25 = fVar25 + ((fVar29 * 0.5 * (float)iVar10) / fVar31) * fVar18;
          }
          fVar18 = pfVar11[-1];
          if (0.0001 < fVar18) {
            unaff_XMM6_Da = unaff_XMM6_Da + fVar18;
            fVar25 = fVar25 + (((float)(iVar12 + -1) * fVar29 * 0.5) / fVar31) * fVar18;
          }
          fVar18 = *pfVar11;
          if (0.0001 < fVar18) {
            unaff_XMM6_Da = unaff_XMM6_Da + fVar18;
            fVar25 = fVar25 + (((float)iVar12 * fVar29 * 0.5) / fVar31) * fVar18;
          }
          fVar18 = pfVar11[1];
          if (0.0001 < fVar18) {
            unaff_XMM6_Da = unaff_XMM6_Da + fVar18;
            fVar25 = fVar25 + (((float)(iVar12 + 1) * fVar29 * 0.5) / fVar31) * fVar18;
          }
          pfVar11 = pfVar11 + 4;
          iVar10 = iVar10 + 4;
          iVar12 = iVar12 + 4;
        } while (iVar10 < (int)(in_R9D - 3));
      }
      if (iVar10 < (int)in_R9D) {
        pfVar11 = unaff_RDI + iVar10;
        do {
          fVar29 = *pfVar11;
          if (0.0001 < fVar29) {
            unaff_XMM6_Da = unaff_XMM6_Da + fVar29;
            fVar25 = fVar25 + (((float)unaff_EBX * 0.5 * (float)iVar10) / (float)(int)in_R9D) *
                              fVar29;
          }
          pfVar11 = pfVar11 + 1;
          iVar10 = iVar10 + 1;
        } while (iVar10 < (int)in_R9D);
      }
    }
    if (0.001 < unaff_XMM6_Da) {
      *in_R11 = fVar25 / unaff_XMM6_Da;
      return 0;
    }
  }
  *in_R11 = 0.0;
  return 0;
}



void* FUN_1807794dd(int param_1,void* param_2,void* param_3,uint param_4)

{
  float fVar1;
  float fVar2;
  float fVar3;
  float fVar4;
  float fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  uint uVar9;
  float *pfVar10;
  int unaff_EBX;
  float *unaff_RDI;
  int iVar11;
  float *in_R11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint8_t auVar16 [16];
  float fVar17;
  int in_XMM5_Da;
  float fVar18;
  int in_XMM5_Db;
  float fVar20;
  int in_XMM5_Dc;
  float fVar21;
  int in_XMM5_Dd;
  uint8_t auVar19 [16];
  float fVar22;
  float fVar23;
  float fVar24;
  float fVar25;
  float fVar26;
  float fVar27;
  float fVar28;
  float fVar29;
  float fVar30;
  float fVar31;
  float fVar32;
  float fVar33;
  float fVar34;
  float fVar35;
  float fVar36;
  float fVar37;
  int unaff_XMM12_Da;
  int unaff_XMM12_Db;
  int unaff_XMM12_Dc;
  int unaff_XMM12_Dd;
  
  uVar9 = param_4 & 0x80000007;
  if ((int)uVar9 < 0) {
    uVar9 = (uVar9 - 1 | 0xfffffff8) + 1;
  }
  auVar19._0_4_ = in_XMM5_Da + -1;
  auVar19._4_4_ = in_XMM5_Db + -1;
  auVar19._8_4_ = in_XMM5_Dc + -1;
  auVar19._12_4_ = in_XMM5_Dd + -1;
  auVar16._0_4_ = (float)auVar19._0_4_;
  auVar16._4_4_ = (float)auVar19._4_4_;
  auVar16._8_4_ = (float)auVar19._8_4_;
  auVar16._12_4_ = (float)auVar19._12_4_;
  auVar19 = rcpps(auVar19,auVar16);
  fVar24 = 0.0;
  fVar28 = 0.0;
  fVar30 = 0.0;
  fVar17 = 0.0;
  fVar18 = auVar19._0_4_;
  fVar20 = auVar19._4_4_;
  fVar21 = auVar19._8_4_;
  fVar22 = auVar19._12_4_;
  fVar29 = 0.0;
  fVar31 = 0.0;
  fVar32 = 0.0;
  fVar33 = 0.0;
  fVar34 = 0.0;
  fVar35 = 0.0;
  fVar36 = 0.0;
  fVar37 = 0.0;
  fVar23 = 0.0;
  fVar25 = 0.0;
  fVar26 = 0.0;
  fVar27 = 0.0;
  fVar18 = (fVar18 + fVar18) - fVar18 * fVar18 * auVar16._0_4_;
  fVar20 = (fVar20 + fVar20) - fVar20 * fVar20 * auVar16._4_4_;
  fVar21 = (fVar21 + fVar21) - fVar21 * fVar21 * auVar16._8_4_;
  fVar22 = (fVar22 + fVar22) - fVar22 * fVar22 * auVar16._12_4_;
  pfVar10 = unaff_RDI;
  do {
    iVar11 = param_1;
    fVar1 = *pfVar10;
    fVar2 = pfVar10[1];
    fVar3 = pfVar10[2];
    fVar4 = pfVar10[3];
    uVar12 = -(uint)(0.0001 < fVar1);
    uVar13 = -(uint)(0.0001 < fVar2);
    uVar14 = -(uint)(0.0001 < fVar3);
    uVar15 = -(uint)(0.0001 < fVar4);
    param_1 = iVar11 + 8;
    fVar5 = pfVar10[4];
    fVar6 = pfVar10[5];
    fVar7 = pfVar10[6];
    fVar8 = pfVar10[7];
    pfVar10 = pfVar10 + 8;
    fVar24 = (float)((uint)((float)iVar11 * (float)unaff_XMM12_Da * 0.5 * fVar18 * fVar1 + fVar24) &
                     uVar12 | ~uVar12 & (uint)fVar24);
    fVar28 = (float)((uint)((float)(iVar11 + 1) * (float)unaff_XMM12_Db * 0.5 * fVar20 * fVar2 +
                           fVar28) & uVar13 | ~uVar13 & (uint)fVar28);
    fVar30 = (float)((uint)((float)(iVar11 + 2) * (float)unaff_XMM12_Dc * 0.5 * fVar21 * fVar3 +
                           fVar30) & uVar14 | ~uVar14 & (uint)fVar30);
    fVar17 = (float)((uint)((float)(iVar11 + 3) * (float)unaff_XMM12_Dd * 0.5 * fVar22 * fVar4 +
                           fVar17) & uVar15 | ~uVar15 & (uint)fVar17);
    fVar23 = (float)((uint)(fVar1 + fVar23) & uVar12 | ~uVar12 & (uint)fVar23);
    fVar25 = (float)((uint)(fVar2 + fVar25) & uVar13 | ~uVar13 & (uint)fVar25);
    fVar26 = (float)((uint)(fVar3 + fVar26) & uVar14 | ~uVar14 & (uint)fVar26);
    fVar27 = (float)((uint)(fVar4 + fVar27) & uVar15 | ~uVar15 & (uint)fVar27);
    uVar12 = -(uint)(0.0001 < fVar5);
    uVar13 = -(uint)(0.0001 < fVar6);
    uVar14 = -(uint)(0.0001 < fVar7);
    uVar15 = -(uint)(0.0001 < fVar8);
    fVar29 = (float)((uint)((float)(iVar11 + 4) * (float)unaff_XMM12_Da * 0.5 * fVar18 * fVar5 +
                           fVar29) & uVar12 | ~uVar12 & (uint)fVar29);
    fVar31 = (float)((uint)((float)(iVar11 + 5) * (float)unaff_XMM12_Db * 0.5 * fVar20 * fVar6 +
                           fVar31) & uVar13 | ~uVar13 & (uint)fVar31);
    fVar32 = (float)((uint)((float)(iVar11 + 6) * (float)unaff_XMM12_Dc * 0.5 * fVar21 * fVar7 +
                           fVar32) & uVar14 | ~uVar14 & (uint)fVar32);
    fVar33 = (float)((uint)((float)(iVar11 + 7) * (float)unaff_XMM12_Dd * 0.5 * fVar22 * fVar8 +
                           fVar33) & uVar15 | ~uVar15 & (uint)fVar33);
    fVar34 = (float)((uint)(fVar5 + fVar34) & uVar12 | ~uVar12 & (uint)fVar34);
    fVar35 = (float)((uint)(fVar6 + fVar35) & uVar13 | ~uVar13 & (uint)fVar35);
    fVar36 = (float)((uint)(fVar7 + fVar36) & uVar14 | ~uVar14 & (uint)fVar36);
    fVar37 = (float)((uint)(fVar8 + fVar37) & uVar15 | ~uVar15 & (uint)fVar37);
  } while (param_1 < (int)(param_4 - uVar9));
  fVar18 = fVar26 + fVar36 + fVar23 + fVar34 + fVar27 + fVar37 + fVar25 + fVar35;
  fVar24 = fVar30 + fVar32 + fVar24 + fVar29 + fVar17 + fVar33 + fVar28 + fVar31;
  if (param_1 < (int)param_4) {
    if (3 < (int)(param_4 - param_1)) {
      iVar11 = iVar11 + 10;
      fVar28 = (float)unaff_EBX;
      pfVar10 = unaff_RDI + (long long)param_1 + 2;
      fVar30 = (float)(int)param_4;
      do {
        fVar17 = pfVar10[-2];
        if (0.0001 < fVar17) {
          fVar18 = fVar18 + fVar17;
          fVar24 = fVar24 + ((fVar28 * 0.5 * (float)param_1) / fVar30) * fVar17;
        }
        fVar17 = pfVar10[-1];
        if (0.0001 < fVar17) {
          fVar18 = fVar18 + fVar17;
          fVar24 = fVar24 + (((float)(iVar11 + -1) * fVar28 * 0.5) / fVar30) * fVar17;
        }
        fVar17 = *pfVar10;
        if (0.0001 < fVar17) {
          fVar18 = fVar18 + fVar17;
          fVar24 = fVar24 + (((float)iVar11 * fVar28 * 0.5) / fVar30) * fVar17;
        }
        fVar17 = pfVar10[1];
        if (0.0001 < fVar17) {
          fVar18 = fVar18 + fVar17;
          fVar24 = fVar24 + (((float)(iVar11 + 1) * fVar28 * 0.5) / fVar30) * fVar17;
        }
        pfVar10 = pfVar10 + 4;
        param_1 = param_1 + 4;
        iVar11 = iVar11 + 4;
      } while (param_1 < (int)(param_4 - 3));
    }
    if (param_1 < (int)param_4) {
      pfVar10 = unaff_RDI + param_1;
      do {
        fVar28 = *pfVar10;
        if (0.0001 < fVar28) {
          fVar18 = fVar18 + fVar28;
          fVar24 = fVar24 + (((float)unaff_EBX * 0.5 * (float)param_1) / (float)(int)param_4) *
                            fVar28;
        }
        pfVar10 = pfVar10 + 1;
        param_1 = param_1 + 1;
      } while (param_1 < (int)param_4);
    }
  }
  if (fVar18 <= 0.001) {
    *in_R11 = 0.0;
  }
  else {
    *in_R11 = fVar24 / fVar18;
  }
  return 0;
}



void* FUN_180779635(int param_1,void* param_2,void* param_3,float param_4)

{
  float fVar1;
  float *pfVar2;
  int unaff_EBX;
  long long unaff_RDI;
  int memoryCompareResult;
  int in_R9D;
  float *in_R11;
  float unaff_XMM6_Da;
  float fVar4;
  float fVar5;
  
  if (param_1 < in_R9D) {
    if (3 < in_R9D - param_1) {
      iVar3 = param_1 + 2;
      fVar4 = (float)unaff_EBX;
      pfVar2 = (float *)(unaff_RDI + ((long long)param_1 + 2) * 4);
      fVar5 = (float)in_R9D;
      do {
        fVar1 = pfVar2[-2];
        if (0.0001 < fVar1) {
          param_4 = param_4 + fVar1;
          unaff_XMM6_Da = unaff_XMM6_Da + ((fVar4 * 0.5 * (float)param_1) / fVar5) * fVar1;
        }
        fVar1 = pfVar2[-1];
        if (0.0001 < fVar1) {
          param_4 = param_4 + fVar1;
          unaff_XMM6_Da = unaff_XMM6_Da + (((float)(iVar3 + -1) * fVar4 * 0.5) / fVar5) * fVar1;
        }
        fVar1 = *pfVar2;
        if (0.0001 < fVar1) {
          param_4 = param_4 + fVar1;
          unaff_XMM6_Da = unaff_XMM6_Da + (((float)iVar3 * fVar4 * 0.5) / fVar5) * fVar1;
        }
        fVar1 = pfVar2[1];
        if (0.0001 < fVar1) {
          param_4 = param_4 + fVar1;
          unaff_XMM6_Da = unaff_XMM6_Da + (((float)(iVar3 + 1) * fVar4 * 0.5) / fVar5) * fVar1;
        }
        pfVar2 = pfVar2 + 4;
        param_1 = param_1 + 4;
        iVar3 = iVar3 + 4;
      } while (param_1 < in_R9D + -3);
    }
    if (param_1 < in_R9D) {
      pfVar2 = (float *)(unaff_RDI + (long long)param_1 * 4);
      do {
        fVar4 = *pfVar2;
        if (0.0001 < fVar4) {
          param_4 = param_4 + fVar4;
          unaff_XMM6_Da =
               unaff_XMM6_Da + (((float)unaff_EBX * 0.5 * (float)param_1) / (float)in_R9D) * fVar4;
        }
        pfVar2 = pfVar2 + 1;
        param_1 = param_1 + 1;
      } while (param_1 < in_R9D);
    }
  }
  if (param_4 <= 0.001) {
    *in_R11 = 0.0;
  }
  else {
    *in_R11 = unaff_XMM6_Da / param_4;
  }
  return 0;
}



void* FUN_1807797e0(long long param_1,uint param_2)

{
  float fVar1;
  float fVar2;
  float fVar3;
  long long lVar4;
  int iVar5;
  uint uVar6;
  ulong long uVar7;
  ulong long uVar8;
  uint uVar9;
  uint uVar10;
  long long lVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  ulong long uVar15;
  long long lVar16;
  ulong long uVar17;
  ulong long uVar18;
  float fVar19;
  float fVar20;
  float fVar21;
  float fVar22;
  uint32_t uStackX_10;
  
  uVar8 = (ulong long)param_2;
  uStackX_10 = 1;
  iVar5 = 1 << ((byte)param_2 & 0x1f);
  uVar6 = iVar5 / 2;
  if (0 < (int)param_2) {
    do {
      iVar13 = 0;
      if (0 < (int)uStackX_10) {
        uVar17 = (ulong long)uStackX_10;
        do {
          uVar7 = (long long)iVar13 / (long long)(int)uVar6 & 0xffffffff;
          uVar10 = 0;
          uVar14 = param_2;
          if (param_2 != 0) {
            do {
              uVar9 = (uint)uVar7;
              uVar7 = uVar7 >> 1;
              uVar10 = uVar10 * 2 | uVar9 & 1;
              uVar14 = uVar14 - 1;
            } while (uVar14 != 0);
          }
          fVar19 = (float)(int)uVar10 * (1.0 / (float)iVar5);
          uVar14 = (uint)(fVar19 * 32768.0);
          if ((int)uVar14 < 0) {
            uVar14 = -uVar14;
          }
          uVar14 = uVar14 & 0x7fff;
          uVar7 = (ulong long)uVar14;
          uVar10 = uVar14 >> 0xd;
          if (uVar14 >> 0xd == 0) {
            fVar22 = *(float *)(param_1 + 0x4cc + uVar7 * 4);
          }
          else if (uVar10 == 1) {
            fVar22 = -*(float *)(param_1 + (0x4132 - (ulong long)uVar14) * 4);
          }
          else if (uVar10 == 2) {
            fVar22 = -*(float *)(param_1 + -0xfb34 + uVar7 * 4);
          }
          else if (uVar10 == 3) {
            fVar22 = *(float *)(param_1 + (0x8132 - uVar7) * 4);
          }
          else {
            fVar22 = 0.0;
          }
          uVar14 = (uint)((fVar19 - 0.25) * 32768.0);
          if ((int)uVar14 < 0) {
            uVar14 = -uVar14;
          }
          uVar14 = uVar14 & 0x7fff;
          uVar7 = (ulong long)uVar14;
          uVar10 = uVar14 >> 0xd;
          if (uVar14 >> 0xd == 0) {
            fVar19 = *(float *)(param_1 + 0x4cc + uVar7 * 4);
          }
          else if (uVar10 == 1) {
            fVar19 = -*(float *)(param_1 + (0x4132 - (ulong long)uVar14) * 4);
          }
          else if (uVar10 == 2) {
            fVar19 = -*(float *)(param_1 + -0xfb34 + uVar7 * 4);
          }
          else if (uVar10 == 3) {
            fVar19 = *(float *)(param_1 + (0x8132 - uVar7) * 4);
          }
          else {
            fVar19 = 0.0;
          }
          lVar16 = (long long)iVar13;
          lVar11 = (long long)(int)(iVar13 + uVar6);
          fVar19 = -fVar19;
          if (lVar16 < lVar11) {
            iVar12 = iVar13;
            if (3 < lVar11 - lVar16) {
              uVar14 = iVar13 + uVar6 + 3;
              iVar12 = iVar13 + ((int)(((lVar11 + -3) - lVar16) - 1U >> 2) + 1) * 4;
              do {
                uVar18 = (ulong long)uVar14;
                lVar4 = *(long long *)(param_1 + 0x218);
                uVar15 = (ulong long)(uVar14 - 1);
                uVar7 = (ulong long)(uVar14 - 2);
                uVar10 = uVar14 - 3;
                fVar21 = *(float *)(lVar4 + 4 + (ulong long)uVar10 * 8);
                fVar1 = *(float *)(lVar4 + (ulong long)uVar10 * 8);
                fVar2 = *(float *)(lVar4 + lVar16 * 8);
                fVar3 = *(float *)(lVar4 + 4 + lVar16 * 8);
                fVar20 = fVar1 * fVar22 - fVar21 * fVar19;
                fVar21 = fVar21 * fVar22 + fVar1 * fVar19;
                *(float *)(lVar4 + lVar16 * 8) = fVar20 + fVar2;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + lVar16 * 8) = fVar21 + fVar3;
                *(float *)(*(long long *)(param_1 + 0x218) + (ulong long)uVar10 * 8) = fVar2 - fVar20;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + (ulong long)uVar10 * 8) =
                     fVar3 - fVar21;
                lVar4 = *(long long *)(param_1 + 0x218);
                fVar21 = *(float *)(lVar4 + 4 + uVar7 * 8);
                fVar1 = *(float *)(lVar4 + uVar7 * 8);
                fVar2 = *(float *)(lVar4 + 8 + lVar16 * 8);
                fVar3 = *(float *)(lVar4 + 0xc + lVar16 * 8);
                fVar20 = fVar1 * fVar22 - fVar21 * fVar19;
                fVar21 = fVar21 * fVar22 + fVar1 * fVar19;
                *(float *)(lVar4 + 8 + lVar16 * 8) = fVar20 + fVar2;
                *(float *)(*(long long *)(param_1 + 0x218) + 0xc + lVar16 * 8) = fVar21 + fVar3;
                *(float *)(*(long long *)(param_1 + 0x218) + uVar7 * 8) = fVar2 - fVar20;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + uVar7 * 8) = fVar3 - fVar21;
                lVar4 = *(long long *)(param_1 + 0x218);
                fVar21 = *(float *)(lVar4 + uVar15 * 8);
                fVar1 = *(float *)(lVar4 + 4 + uVar15 * 8);
                fVar2 = *(float *)(lVar4 + 0x10 + lVar16 * 8);
                fVar3 = *(float *)(lVar4 + 0x14 + lVar16 * 8);
                fVar20 = fVar21 * fVar22 - fVar1 * fVar19;
                fVar21 = fVar1 * fVar22 + fVar21 * fVar19;
                *(float *)(lVar4 + 0x10 + lVar16 * 8) = fVar20 + fVar2;
                *(float *)(*(long long *)(param_1 + 0x218) + 0x14 + lVar16 * 8) = fVar21 + fVar3;
                *(float *)(*(long long *)(param_1 + 0x218) + uVar15 * 8) = fVar2 - fVar20;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + uVar15 * 8) = fVar3 - fVar21;
                lVar4 = *(long long *)(param_1 + 0x218);
                fVar21 = *(float *)(lVar4 + uVar18 * 8);
                fVar1 = *(float *)(lVar4 + 4 + uVar18 * 8);
                fVar2 = *(float *)(lVar4 + 0x18 + lVar16 * 8);
                fVar3 = *(float *)(lVar4 + 0x1c + lVar16 * 8);
                fVar20 = fVar21 * fVar22 - fVar1 * fVar19;
                fVar21 = fVar1 * fVar22 + fVar21 * fVar19;
                *(float *)(lVar4 + 0x18 + lVar16 * 8) = fVar20 + fVar2;
                *(float *)(*(long long *)(param_1 + 0x218) + 0x1c + lVar16 * 8) = fVar21 + fVar3;
                lVar16 = lVar16 + 4;
                *(float *)(*(long long *)(param_1 + 0x218) + uVar18 * 8) = fVar2 - fVar20;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + uVar18 * 8) = fVar3 - fVar21;
                uVar14 = uVar14 + 4;
              } while (lVar16 < lVar11 + -3);
            }
            if (lVar16 < lVar11) {
              uVar14 = iVar12 + uVar6;
              do {
                uVar7 = (ulong long)uVar14;
                lVar4 = *(long long *)(param_1 + 0x218);
                fVar21 = *(float *)(lVar4 + uVar7 * 8);
                fVar1 = *(float *)(lVar4 + 4 + uVar7 * 8);
                fVar2 = *(float *)(lVar4 + lVar16 * 8);
                fVar3 = *(float *)(lVar4 + 4 + lVar16 * 8);
                fVar20 = fVar21 * fVar22 - fVar1 * fVar19;
                fVar21 = fVar1 * fVar22 + fVar21 * fVar19;
                *(float *)(lVar4 + lVar16 * 8) = fVar20 + fVar2;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + lVar16 * 8) = fVar21 + fVar3;
                lVar16 = lVar16 + 1;
                *(float *)(*(long long *)(param_1 + 0x218) + uVar7 * 8) = fVar2 - fVar20;
                *(float *)(*(long long *)(param_1 + 0x218) + 4 + uVar7 * 8) = fVar3 - fVar21;
                uVar14 = uVar14 + 1;
              } while (lVar16 < lVar11);
            }
          }
          iVar13 = iVar13 + uVar6 * 2;
          uVar17 = uVar17 - 1;
        } while (uVar17 != 0);
      }
      uStackX_10 = uStackX_10 * 2;
      uVar6 = uVar6 >> 1;
      uVar8 = uVar8 - 1;
    } while (uVar8 != 0);
  }
  return 0;
}



void* FUN_180779832(void* param_1,void* param_2,uint param_3)

{
  float fVar1;
  float fVar2;
  float fVar3;
  long long lVar4;
  ulong long uVar5;
  ulong long uVar6;
  uint uVar7;
  uint uVar8;
  long long lVar9;
  int iVar10;
  int iVar11;
  uint uVar12;
  ulong long uVar13;
  long long lVar14;
  long long in_R11;
  ulong long uVar15;
  uint unaff_R13D;
  uint unaff_R14D;
  ulong long uVar16;
  float fVar17;
  float fVar18;
  float fVar19;
  float fVar20;
  float unaff_XMM10_Da;
  uint in_stack_000000a8;
  
  uVar6 = (ulong long)unaff_R13D;
  do {
    iVar11 = 0;
    if (0 < (int)param_3) {
      uVar15 = (ulong long)param_3;
      do {
        uVar5 = (long long)iVar11 / (long long)(int)unaff_R14D & 0xffffffff;
        uVar7 = 0;
        uVar12 = unaff_R13D;
        if (unaff_R13D != 0) {
          do {
            uVar8 = (uint)uVar5;
            uVar5 = uVar5 >> 1;
            uVar7 = uVar7 * 2 | uVar8 & 1;
            uVar12 = uVar12 - 1;
          } while (uVar12 != 0);
        }
        uVar12 = (uint)((float)(int)uVar7 * unaff_XMM10_Da * 32768.0);
        if ((int)uVar12 < 0) {
          uVar12 = -uVar12;
        }
        uVar12 = uVar12 & 0x7fff;
        uVar5 = (ulong long)uVar12;
        uVar8 = uVar12 >> 0xd;
        if (uVar12 >> 0xd == 0) {
          fVar20 = *(float *)(in_R11 + 0x4cc + uVar5 * 4);
        }
        else if (uVar8 == 1) {
          fVar20 = -*(float *)(in_R11 + (0x4132 - (ulong long)uVar12) * 4);
        }
        else if (uVar8 == 2) {
          fVar20 = -*(float *)(in_R11 + -0xfb34 + uVar5 * 4);
        }
        else if (uVar8 == 3) {
          fVar20 = *(float *)(in_R11 + (0x8132 - uVar5) * 4);
        }
        else {
          fVar20 = 0.0;
        }
        uVar12 = (uint)(((float)(int)uVar7 * unaff_XMM10_Da - 0.25) * 32768.0);
        if ((int)uVar12 < 0) {
          uVar12 = -uVar12;
        }
        uVar12 = uVar12 & 0x7fff;
        uVar5 = (ulong long)uVar12;
        uVar7 = uVar12 >> 0xd;
        if (uVar12 >> 0xd == 0) {
          fVar19 = *(float *)(in_R11 + 0x4cc + uVar5 * 4);
        }
        else if (uVar7 == 1) {
          fVar19 = -*(float *)(in_R11 + (0x4132 - (ulong long)uVar12) * 4);
        }
        else if (uVar7 == 2) {
          fVar19 = -*(float *)(in_R11 + -0xfb34 + uVar5 * 4);
        }
        else if (uVar7 == 3) {
          fVar19 = *(float *)(in_R11 + (0x8132 - uVar5) * 4);
        }
        else {
          fVar19 = 0.0;
        }
        lVar14 = (long long)iVar11;
        lVar9 = (long long)(int)(iVar11 + unaff_R14D);
        fVar19 = -fVar19;
        if (lVar14 < lVar9) {
          iVar10 = iVar11;
          if (3 < lVar9 - lVar14) {
            uVar12 = iVar11 + unaff_R14D + 3;
            iVar10 = iVar11 + ((int)(((lVar9 + -3) - lVar14) - 1U >> 2) + 1) * 4;
            do {
              uVar16 = (ulong long)uVar12;
              lVar4 = *(long long *)(in_R11 + 0x218);
              uVar13 = (ulong long)(uVar12 - 1);
              uVar5 = (ulong long)(uVar12 - 2);
              uVar7 = uVar12 - 3;
              fVar18 = *(float *)(lVar4 + 4 + (ulong long)uVar7 * 8);
              fVar1 = *(float *)(lVar4 + (ulong long)uVar7 * 8);
              fVar2 = *(float *)(lVar4 + lVar14 * 8);
              fVar3 = *(float *)(lVar4 + 4 + lVar14 * 8);
              fVar17 = fVar1 * fVar20 - fVar18 * fVar19;
              fVar18 = fVar18 * fVar20 + fVar1 * fVar19;
              *(float *)(lVar4 + lVar14 * 8) = fVar17 + fVar2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + lVar14 * 8) = fVar18 + fVar3;
              *(float *)(*(long long *)(in_R11 + 0x218) + (ulong long)uVar7 * 8) = fVar2 - fVar17;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + (ulong long)uVar7 * 8) = fVar3 - fVar18;
              lVar4 = *(long long *)(in_R11 + 0x218);
              fVar18 = *(float *)(lVar4 + 4 + uVar5 * 8);
              fVar1 = *(float *)(lVar4 + uVar5 * 8);
              fVar2 = *(float *)(lVar4 + 8 + lVar14 * 8);
              fVar3 = *(float *)(lVar4 + 0xc + lVar14 * 8);
              fVar17 = fVar1 * fVar20 - fVar18 * fVar19;
              fVar18 = fVar18 * fVar20 + fVar1 * fVar19;
              *(float *)(lVar4 + 8 + lVar14 * 8) = fVar17 + fVar2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 0xc + lVar14 * 8) = fVar18 + fVar3;
              *(float *)(*(long long *)(in_R11 + 0x218) + uVar5 * 8) = fVar2 - fVar17;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + uVar5 * 8) = fVar3 - fVar18;
              lVar4 = *(long long *)(in_R11 + 0x218);
              fVar18 = *(float *)(lVar4 + uVar13 * 8);
              fVar1 = *(float *)(lVar4 + 4 + uVar13 * 8);
              fVar2 = *(float *)(lVar4 + 0x10 + lVar14 * 8);
              fVar3 = *(float *)(lVar4 + 0x14 + lVar14 * 8);
              fVar17 = fVar18 * fVar20 - fVar1 * fVar19;
              fVar18 = fVar1 * fVar20 + fVar18 * fVar19;
              *(float *)(lVar4 + 0x10 + lVar14 * 8) = fVar17 + fVar2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 0x14 + lVar14 * 8) = fVar18 + fVar3;
              *(float *)(*(long long *)(in_R11 + 0x218) + uVar13 * 8) = fVar2 - fVar17;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + uVar13 * 8) = fVar3 - fVar18;
              lVar4 = *(long long *)(in_R11 + 0x218);
              fVar18 = *(float *)(lVar4 + uVar16 * 8);
              fVar1 = *(float *)(lVar4 + 4 + uVar16 * 8);
              fVar2 = *(float *)(lVar4 + 0x18 + lVar14 * 8);
              fVar3 = *(float *)(lVar4 + 0x1c + lVar14 * 8);
              fVar17 = fVar18 * fVar20 - fVar1 * fVar19;
              fVar18 = fVar1 * fVar20 + fVar18 * fVar19;
              *(float *)(lVar4 + 0x18 + lVar14 * 8) = fVar17 + fVar2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 0x1c + lVar14 * 8) = fVar18 + fVar3;
              lVar14 = lVar14 + 4;
              *(float *)(*(long long *)(in_R11 + 0x218) + uVar16 * 8) = fVar2 - fVar17;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + uVar16 * 8) = fVar3 - fVar18;
              uVar12 = uVar12 + 4;
            } while (lVar14 < lVar9 + -3);
          }
          if (lVar14 < lVar9) {
            uVar12 = iVar10 + unaff_R14D;
            do {
              uVar5 = (ulong long)uVar12;
              lVar4 = *(long long *)(in_R11 + 0x218);
              fVar18 = *(float *)(lVar4 + uVar5 * 8);
              fVar1 = *(float *)(lVar4 + 4 + uVar5 * 8);
              fVar2 = *(float *)(lVar4 + lVar14 * 8);
              fVar3 = *(float *)(lVar4 + 4 + lVar14 * 8);
              fVar17 = fVar18 * fVar20 - fVar1 * fVar19;
              fVar18 = fVar1 * fVar20 + fVar18 * fVar19;
              *(float *)(lVar4 + lVar14 * 8) = fVar17 + fVar2;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + lVar14 * 8) = fVar18 + fVar3;
              lVar14 = lVar14 + 1;
              *(float *)(*(long long *)(in_R11 + 0x218) + uVar5 * 8) = fVar2 - fVar17;
              *(float *)(*(long long *)(in_R11 + 0x218) + 4 + uVar5 * 8) = fVar3 - fVar18;
              uVar12 = uVar12 + 1;
            } while (lVar14 < lVar9);
          }
        }
        iVar11 = iVar11 + unaff_R14D * 2;
        uVar15 = uVar15 - 1;
        param_3 = in_stack_000000a8;
      } while (uVar15 != 0);
    }
    param_3 = param_3 * 2;
    unaff_R14D = unaff_R14D >> 1;
    uVar6 = uVar6 - 1;
    in_stack_000000a8 = param_3;
  } while (uVar6 != 0);
  return 0;
}



/**
 * @brief 检查系统状态
 * 
 * 该函数是一个简单的状态检查函数，用于检查系统的当前状态。
 * 它返回固定的状态值0，表示系统状态正常。
 * 
 * @return 系统状态码，0表示正常
 * @note 这是一个状态检查函数，用于系统初始化过程中的状态验证
 */
void* CheckSystemStatus(void)

{
  return 0;
}




// 函数: 系统模块加载器 - 负责加载系统模块
undefined SystemModuleLoader;

// 函数: 系统接口管理器 - 负责管理系统接口
undefined SystemInterfaceManager;
undefined SystemModuleLoadFlag;
void* SystemInterfaceHandle;
uint32_t SystemInterfaceVersion;
undefined *SystemInterfaceTable;
uint8_t *SystemInterfaceData;
uint32_t SystemInterfaceConfig;
long long SystemInterfaceMemoryBase;
long long SystemInterfaceMemorySize;
long long SystemInterfaceDataOffset;
long long SystemInterfaceDataSize;
uint32_t SystemInterfaceFlags;
uint32_t SystemInterfaceStatus;
undefined SystemModuleConfigData;
undefined SystemModuleRuntimeData;
undefined SystemGlobalConfigFlag;
undefined SystemRuntimeDataFlag;
undefined SystemModuleLoadStatus;
long long SystemModuleLoadTime;
void* SystemModuleUnloadTime;
long long SystemModuleExecutionTime;
long long *SystemModuleExecutionCounter;

