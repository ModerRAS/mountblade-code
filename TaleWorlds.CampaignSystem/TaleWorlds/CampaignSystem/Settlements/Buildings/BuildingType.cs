// Decompiled with JetBrains decompiler
// Type: TaleWorlds.CampaignSystem.Settlements.Buildings.BuildingType
// Assembly: TaleWorlds.CampaignSystem, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E85F8C15-4DF6-4E9C-A58A-29177E40D07A
// Assembly location: D:\steam\steamapps\common\Mount & Blade II Bannerlord\bin\Win64_Shipping_Client\TaleWorlds.CampaignSystem.dll

using System;
using System.Collections.Generic;
using System.Linq;
using TaleWorlds.Core;
using TaleWorlds.Library;
using TaleWorlds.Localization;
using TaleWorlds.ObjectSystem;

#nullable disable
namespace TaleWorlds.CampaignSystem.Settlements.Buildings
{
  public sealed class BuildingType : MBObjectBase
  {
    public const int MaxLevel = 3;
    public bool IsDefaultProject;
    private int[] _productionCosts = new int[3];
    public int StartLevel;
    public BuildingLocation BuildingLocation;
    private BuildingType.EffectInfo[] _effects;

    internal static void AutoGeneratedStaticCollectObjectsBuildingType(
      object o,
      List<object> collectedObjects)
    {
      ((MBObjectBase) o).AutoGeneratedInstanceCollectObjects(collectedObjects);
    }

    protected override void AutoGeneratedInstanceCollectObjects(List<object> collectedObjects)
    {
      base.AutoGeneratedInstanceCollectObjects(collectedObjects);
    }

    public static MBReadOnlyList<BuildingType> All => Campaign.Current.AllBuildingTypes;

    public TextObject Name { get; private set; }

    public TextObject Explanation { get; private set; }

    public BuildingType(string stringId)
      : base(stringId)
    {
    }

    public void Initialize(
      TextObject name,
      TextObject explanation,
      int[] productionCosts,
      BuildingLocation buildingLocation,
      Tuple<BuildingEffectEnum, float, float, float>[] effects,
      int startLevel = 0)
    {
      this.Initialize();
      this.Name = name;
      this.Explanation = explanation;
      this._productionCosts = productionCosts;
      this.IsDefaultProject = buildingLocation == BuildingLocation.Daily;
      this._effects = ((IEnumerable<Tuple<BuildingEffectEnum, float, float, float>>) effects).Select<Tuple<BuildingEffectEnum, float, float, float>, BuildingType.EffectInfo>((Func<Tuple<BuildingEffectEnum, float, float, float>, BuildingType.EffectInfo>) (x => new BuildingType.EffectInfo(x.Item1, x.Item2, x.Item3, x.Item4))).ToArray<BuildingType.EffectInfo>();
      this.StartLevel = startLevel;
      this.BuildingLocation = buildingLocation;
      this.AfterInitialized();
    }

    public override string ToString() => this.Name.ToString();

    public int GetProductionCost(int level)
    {
      return level < this.StartLevel || level >= 3 ? 0 : this._productionCosts[level];
    }

    public float GetBaseBuildingEffectAmount(BuildingEffectEnum effect, int level)
    {
      for (int index = 0; index < this._effects.Length; ++index)
      {
        if (this._effects[index].BuildingEffect == effect)
          return this._effects[index].GetEffectValue(level);
      }
      return 0.0f;
    }

    public TextObject GetExplanationAtLevel(int level)
    {
      if (level == 0 || level > 3)
        return TextObject.Empty;
      TextObject variable = TextObject.Empty;
      if (this._effects.Length == 1)
      {
        variable = GameTexts.FindText("str_building_effect_explanation", Enum.GetName(typeof (BuildingEffectEnum), (object) this._effects[0].BuildingEffect));
        variable.SetTextVariable("BONUS_AMOUNT", this._effects[0].GetEffectValue(level));
      }
      else if (this._effects.Length >= 2)
      {
        variable = GameTexts.FindText("str_string_newline_string");
        TextObject text1 = GameTexts.FindText("str_building_effect_explanation", Enum.GetName(typeof (BuildingEffectEnum), (object) this._effects[0].BuildingEffect));
        text1.SetTextVariable("BONUS_AMOUNT", this._effects[0].GetEffectValue(level));
        TextObject text2 = GameTexts.FindText("str_building_effect_explanation", Enum.GetName(typeof (BuildingEffectEnum), (object) this._effects[1].BuildingEffect));
        text2.SetTextVariable("BONUS_AMOUNT", this._effects[1].GetEffectValue(level));
        variable.SetTextVariable("STR1", text1);
        variable.SetTextVariable("STR2", text2);
        variable.SetTextVariable("newline", "\n");
        for (int index = 2; index < this._effects.Length; ++index)
        {
          TextObject text3 = GameTexts.FindText("str_string_newline_string");
          text3.SetTextVariable("STR1", variable);
          TextObject text4 = GameTexts.FindText("str_building_effect_explanation", Enum.GetName(typeof (BuildingEffectEnum), (object) this._effects[index].BuildingEffect));
          text4.SetTextVariable("BONUS_AMOUNT", this._effects[index].GetEffectValue(level));
          text3.SetTextVariable("STR2", text4);
          text3.SetTextVariable("newline", "\n");
          variable = text3;
        }
      }
      return variable;
    }

    public struct EffectInfo
    {
      public BuildingEffectEnum BuildingEffect { get; }

      public float Level1Effect { get; }

      public float Level2Effect { get; }

      public float Level3Effect { get; }

      public float GetEffectValue(int i)
      {
        if (i == 1)
          return this.Level1Effect;
        return i != 2 ? this.Level3Effect : this.Level2Effect;
      }

      public EffectInfo(BuildingEffectEnum effect, float[] effectValues)
      {
        this.BuildingEffect = effect;
        this.Level1Effect = effectValues[0];
        this.Level2Effect = effectValues[1];
        this.Level3Effect = effectValues[2];
      }

      public EffectInfo(
        BuildingEffectEnum effect,
        float effectValue1,
        float effectValue2,
        float effectValue3)
      {
        this.BuildingEffect = effect;
        this.Level1Effect = effectValue1;
        this.Level2Effect = effectValue2;
        this.Level3Effect = effectValue3;
      }
    }
  }
}
